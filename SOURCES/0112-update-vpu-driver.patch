From 887422fe74b22b5cc4ab7e900abe4ef7ec8cb65f Mon Sep 17 00:00:00 2001
From: fuqiang <qiang.fu@spacemit.com>
Date: Thu, 14 Sep 2023 09:58:37 +0800
Subject: [PATCH 0112/1206] update vpu driver

1.move vpu driver to drivers/media/platform/spacemit/vpu_k1x
2.now can decode and encode normally on FPGA test
3.K1X fpga defconfig: open VIDEO_LINON_K1X by default
4.K1X dtsi: add k1x vpu config, disabled by default

Change-Id: I6fd5c07575a80c08f90b567b1c6840843f652e0e
Signed-off-by: fuqiang <qiang.fu@spacemit.com>
---
 arch/riscv/boot/dts/spacemit/k1-x.dtsi        |    7 +
 arch/riscv/configs/k1-x_fpga_defconfig        |    3 +
 drivers/media/Kconfig                         |    1 -
 drivers/media/Makefile                        |    2 +-
 drivers/media/platform/Kconfig                |    1 +
 drivers/media/platform/Makefile               |    1 +
 drivers/media/platform/spacemit/Kconfig       |    5 +
 drivers/media/platform/spacemit/Makefile      |    2 +
 .../{vpu => platform/spacemit/vpu_k1x}/Kbuild |   14 +-
 .../media/platform/spacemit/vpu_k1x/Kconfig   |   26 +
 .../spacemit/vpu_k1x}/Makefile                |    0
 .../spacemit/vpu_k1x}/dev/mvx_dev.c           |  223 +--
 .../spacemit/vpu_k1x}/dev/mvx_dev.h           |   26 +
 .../spacemit/vpu_k1x}/dev/mvx_hwreg.c         |   11 +-
 .../spacemit/vpu_k1x}/dev/mvx_hwreg.h         |    1 +
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v500.c    |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v500.h    |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v52_v76.c |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v52_v76.h |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v550.c    |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v550.h    |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v61.c     |    0
 .../spacemit/vpu_k1x}/dev/mvx_hwreg_v61.h     |    0
 .../spacemit/vpu_k1x}/dev/mvx_lsid.c          |   14 +-
 .../spacemit/vpu_k1x}/dev/mvx_lsid.h          |    0
 .../spacemit/vpu_k1x}/dev/mvx_scheduler.c     |  230 ++-
 .../spacemit/vpu_k1x}/dev/mvx_scheduler.h     |    7 +
 .../external/fw_v2/mve_protocol_def.h         |    2 +
 .../external/fw_v3/mve_protocol_def.h         |    0
 .../spacemit/vpu_k1x}/if/mvx_bitops.h         |    0
 .../spacemit/vpu_k1x}/if/mvx_buffer.c         |   28 +-
 .../spacemit/vpu_k1x}/if/mvx_buffer.h         |   25 +-
 .../spacemit/vpu_k1x}/if/mvx_firmware.c       |    0
 .../spacemit/vpu_k1x}/if/mvx_firmware.h       |    8 +-
 .../spacemit/vpu_k1x}/if/mvx_firmware_cache.c |   16 +-
 .../spacemit/vpu_k1x}/if/mvx_firmware_cache.h |    0
 .../spacemit/vpu_k1x}/if/mvx_firmware_priv.h  |    0
 .../spacemit/vpu_k1x}/if/mvx_firmware_v2.c    |  166 ++-
 .../spacemit/vpu_k1x}/if/mvx_firmware_v3.c    |    0
 .../spacemit/vpu_k1x}/if/mvx_if.c             |    0
 .../spacemit/vpu_k1x}/if/mvx_if.h             |    2 +
 .../spacemit/vpu_k1x}/if/mvx_mmu.c            |   84 +-
 .../spacemit/vpu_k1x}/if/mvx_mmu.h            |    0
 .../spacemit/vpu_k1x}/if/mvx_secure.c         |   29 +-
 .../spacemit/vpu_k1x}/if/mvx_secure.h         |    0
 .../spacemit/vpu_k1x}/if/mvx_session.c        |  482 +++++-
 .../spacemit/vpu_k1x}/if/mvx_session.h        |   43 +-
 .../vpu_k1x}/if/v4l2/mvx-v4l2-controls.h      |    6 +-
 .../spacemit/vpu_k1x}/if/v4l2/mvx_ext_if.h    |    0
 .../spacemit/vpu_k1x}/if/v4l2/mvx_ext_v4l2.c  |   27 +-
 .../vpu_k1x}/if/v4l2/mvx_v4l2_buffer.c        |   70 +-
 .../vpu_k1x}/if/v4l2/mvx_v4l2_buffer.h        |    0
 .../vpu_k1x}/if/v4l2/mvx_v4l2_ctrls.c         |  195 ++-
 .../vpu_k1x}/if/v4l2/mvx_v4l2_ctrls.h         |    0
 .../spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_fops.c |   19 +-
 .../spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_fops.h |    0
 .../vpu_k1x}/if/v4l2/mvx_v4l2_session.c       |  110 +-
 .../vpu_k1x}/if/v4l2/mvx_v4l2_session.h       |    0
 .../vpu_k1x}/if/v4l2/mvx_v4l2_vidioc.c        |   71 +-
 .../vpu_k1x}/if/v4l2/mvx_v4l2_vidioc.h        |    0
 .../spacemit/vpu_k1x}/mvx_driver.c            |    0
 .../platform/spacemit/vpu_k1x/mvx_dvfs.c      | 1296 +++++++++++++++++
 .../platform/spacemit/vpu_k1x/mvx_dvfs.h      |   90 ++
 .../spacemit/vpu_k1x}/mvx_log.c               |   25 +-
 .../spacemit/vpu_k1x}/mvx_log.h               |    0
 .../spacemit/vpu_k1x}/mvx_log_group.c         |    0
 .../spacemit/vpu_k1x}/mvx_log_group.h         |    0
 .../spacemit/vpu_k1x}/mvx_log_ram.h           |    0
 .../spacemit/vpu_k1x}/mvx_pm_runtime.c        |   34 +-
 .../spacemit/vpu_k1x}/mvx_pm_runtime.h        |    0
 .../spacemit/vpu_k1x}/mvx_seq.c               |    0
 .../spacemit/vpu_k1x}/mvx_seq.h               |    0
 .../spacemit/vpu_k1x}/sconscript              |    0
 drivers/media/vpu/Kconfig                     |   25 -
 drivers/media/vpu/modules.builtin             |    0
 75 files changed, 3038 insertions(+), 389 deletions(-)
 create mode 100644 drivers/media/platform/spacemit/Kconfig
 create mode 100644 drivers/media/platform/spacemit/Makefile
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/Kbuild (67%)
 create mode 100755 drivers/media/platform/spacemit/vpu_k1x/Kconfig
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/Makefile (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_dev.c (80%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_dev.h (76%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg.c (97%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg.h (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v500.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v500.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v52_v76.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v52_v76.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v550.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v550.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v61.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_hwreg_v61.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_lsid.c (98%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_lsid.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_scheduler.c (73%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/dev/mvx_scheduler.h (96%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/external/fw_v2/mve_protocol_def.h (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/external/fw_v3/mve_protocol_def.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_bitops.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_buffer.c (96%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_buffer.h (96%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware.h (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware_cache.c (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware_cache.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware_priv.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware_v2.c (94%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_firmware_v3.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_if.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_if.h (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_mmu.c (95%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_mmu.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_secure.c (95%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_secure.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_session.c (83%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/mvx_session.h (94%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx-v4l2-controls.h (99%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_ext_if.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_ext_v4l2.c (91%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_buffer.c (85%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_buffer.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_ctrls.c (84%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_ctrls.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_fops.c (93%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_fops.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_session.c (83%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_session.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_vidioc.c (96%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/if/v4l2/mvx_v4l2_vidioc.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_driver.c (100%)
 create mode 100755 drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.c
 create mode 100755 drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.h
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_log.c (97%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_log.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_log_group.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_log_group.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_log_ram.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_pm_runtime.c (66%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_pm_runtime.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_seq.c (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/mvx_seq.h (100%)
 rename drivers/media/{vpu => platform/spacemit/vpu_k1x}/sconscript (100%)
 delete mode 100755 drivers/media/vpu/Kconfig
 delete mode 100755 drivers/media/vpu/modules.builtin

diff --git a/arch/riscv/boot/dts/spacemit/k1-x.dtsi b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
index 4572a6954eb3..0d8bd06cb2af 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
@@ -578,6 +578,13 @@ core3_tcm@60000 {
 			};
 		};
 
+		linlon-v5@c0500000 {
+			compatible = "arm china,linlon-v5";
+			reg = <0x0 0xC0500000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <74>;
+			status = "disabled";
+		};
 	};
 
 	pmu {
diff --git a/arch/riscv/configs/k1-x_fpga_defconfig b/arch/riscv/configs/k1-x_fpga_defconfig
index 80bac146bf5d..52b62dc1b1e6 100644
--- a/arch/riscv/configs/k1-x_fpga_defconfig
+++ b/arch/riscv/configs/k1-x_fpga_defconfig
@@ -131,6 +131,9 @@ CONFIG_VIRTIO_CONSOLE=y
 # CONFIG_PTP_1588_CLOCK is not set
 # CONFIG_HWMON is not set
 CONFIG_MFD_SYSCON=y
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_LINLON_K1X=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_HID_GENERIC is not set
 CONFIG_USB=y
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index ec6f7e453de7..6abc9302cd84 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -262,7 +262,6 @@ source "drivers/media/i2c/Kconfig"
 source "drivers/media/spi/Kconfig"
 source "drivers/media/tuners/Kconfig"
 source "drivers/media/dvb-frontends/Kconfig"
-source "drivers/media/vpu/Kconfig"
 
 endmenu
 
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index 9ccd860d3733..20fac24e4f0f 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -29,6 +29,6 @@ obj-$(CONFIG_CEC_CORE) += cec/
 # Finally, merge the drivers that require the core
 #
 
-obj-y += common/ platform/ pci/ usb/ mmc/ firewire/ spi/ test-drivers/ vpu/
+obj-y += common/ platform/ pci/ usb/ mmc/ firewire/ spi/ test-drivers/
 obj-$(CONFIG_VIDEO_DEV) += radio/
 
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 85d2627776b6..a18ceedd6dca 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -89,5 +89,6 @@ source "drivers/media/platform/ti/Kconfig"
 source "drivers/media/platform/verisilicon/Kconfig"
 source "drivers/media/platform/via/Kconfig"
 source "drivers/media/platform/xilinx/Kconfig"
+source "drivers/media/platform/spacemit/Kconfig"
 
 endif # MEDIA_PLATFORM_DRIVERS
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index ace4e34483dd..02769df809bb 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -32,6 +32,7 @@ obj-y += ti/
 obj-y += verisilicon/
 obj-y += via/
 obj-y += xilinx/
+obj-y += spacemit/
 
 # Please place here only ancillary drivers that aren't SoC-specific
 # Please keep it alphabetically sorted by Kconfig name
diff --git a/drivers/media/platform/spacemit/Kconfig b/drivers/media/platform/spacemit/Kconfig
new file mode 100644
index 000000000000..c1e77d454d37
--- /dev/null
+++ b/drivers/media/platform/spacemit/Kconfig
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+comment "Spacemit media platform drivers"
+
+source "drivers/media/platform/spacemit/vpu_k1x/Kconfig"
diff --git a/drivers/media/platform/spacemit/Makefile b/drivers/media/platform/spacemit/Makefile
new file mode 100644
index 000000000000..be25ea319a80
--- /dev/null
+++ b/drivers/media/platform/spacemit/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-y += vpu_k1x/
diff --git a/drivers/media/vpu/Kbuild b/drivers/media/platform/spacemit/vpu_k1x/Kbuild
similarity index 67%
rename from drivers/media/vpu/Kbuild
rename to drivers/media/platform/spacemit/vpu_k1x/Kbuild
index 3f5396ac5b3e..999b1e201602 100755
--- a/drivers/media/vpu/Kbuild
+++ b/drivers/media/platform/spacemit/vpu_k1x/Kbuild
@@ -2,9 +2,14 @@
 # Set the include-path according to the defined interface.
 ###########################################################
 
-ccflags-y += -I$(src) -I$(src)/if -I$(src)/dev -I$(src)/if/v4l2 -I$(src)/external
-ccflags-$(CONFIG_VIDEO_LINLON_FTRACE) += -DMVX_LOG_FTRACE_ENABLE
-ccflags-$(CONFIG_VIDEO_LINLON_PRINT_FILE) += -DMVX_LOG_PRINT_FILE_ENABLE
+ccflags-y += -I$(srctree)/drivers/media/platform/spacemit/vpu_k1x
+ccflags-y += -I$(srctree)/drivers/media/platform/spacemit/vpu_k1x/if
+ccflags-y += -I$(srctree)/drivers/media/platform/spacemit/vpu_k1x/dev
+ccflags-y += -I$(srctree)/drivers/media/platform/spacemit/vpu_k1x/if/v4l2
+ccflags-y += -I$(srctree)/drivers/media/platform/spacemit/vpu_k1x/external
+
+ccflags-$(CONFIG_VIDEO_LINLON_K1X_FTRACE) += -DMVX_LOG_FTRACE_ENABLE
+ccflags-$(CONFIG_VIDEO_LINLON_K1X_PRINT_FILE) += -DMVX_LOG_PRINT_FILE_ENABLE
 ccflags-y += $(EXTRA_CCFLAGS)
 
 ###########################################################
@@ -12,7 +17,7 @@ ccflags-y += $(EXTRA_CCFLAGS)
 ###########################################################
 
 # Amvx module
-obj-$(CONFIG_VIDEO_LINLON) := amvx.o
+obj-$(CONFIG_VIDEO_LINLON_K1X) := amvx.o
 
 # Add objects for if module.
 if-y := if/mvx_if.o \
@@ -49,4 +54,5 @@ amvx-y := mvx_driver.o \
 	  mvx_seq.o \
 	  mvx_log.o \
 	  mvx_log_group.o \
+          mvx_dvfs.o \
 	  $(if-y) $(dev-y)
diff --git a/drivers/media/platform/spacemit/vpu_k1x/Kconfig b/drivers/media/platform/spacemit/vpu_k1x/Kconfig
new file mode 100755
index 000000000000..4b722305e1f5
--- /dev/null
+++ b/drivers/media/platform/spacemit/vpu_k1x/Kconfig
@@ -0,0 +1,26 @@
+config VIDEO_LINLON_K1X
+	tristate "Linlon VPU support."
+	depends on VIDEO_DEV
+#    depends on VIDEO_V4L2
+    select VIDEOBUF2_VMALLOC
+    select VIDEOBUF2_CORE
+    select DMA_SHARED_BUFFER
+    select VIDEOBUF2_MEMOPS
+    select VIDEOBUF2_DMA_SG
+	default n
+	help
+	  This enables support for the Linlon VPU family.
+
+config VIDEO_LINLON_FTRACE_K1X
+	depends on VIDEO_LINLON_K1X
+	bool "Send kernel space logs to ftrace."
+	default n
+	help
+		Send kernel space logs to ftrace.
+
+config VIDEO_LINLON_PRINT_FILE_K1X
+	depends on VIDEO_LINLON_K1X
+	bool "Append file and line number to kernel space log messages."
+	default y
+	help
+		Append file and line number to kernel space log messages.
diff --git a/drivers/media/vpu/Makefile b/drivers/media/platform/spacemit/vpu_k1x/Makefile
similarity index 100%
rename from drivers/media/vpu/Makefile
rename to drivers/media/platform/spacemit/vpu_k1x/Makefile
diff --git a/drivers/media/vpu/dev/mvx_dev.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.c
similarity index 80%
rename from drivers/media/vpu/dev/mvx_dev.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.c
index 1cf1b96fd823..c3fc1254c4f9 100755
--- a/drivers/media/vpu/dev/mvx_dev.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.c
@@ -45,16 +45,16 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <linux/printk.h>
-#include <linux/reset.h>
 #include <linux/workqueue.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
 #include "mvx_bitops.h"
 #include "mvx_dev.h"
-#include "mvx_hwreg.h"
 #include "mvx_if.h"
-#include "mvx_scheduler.h"
 #include "mvx_session.h"
 #include "mvx_log_group.h"
 #include "mvx_pm_runtime.h"
+#include "mvx_dvfs.h"
 
 /****************************************************************************
  * Defines
@@ -72,23 +72,6 @@
  * Types
  ****************************************************************************/
 
-/**
- * struct mvx_dev_ctx - Private context for the MVx dev device.
- */
-struct mvx_dev_ctx {
-	struct device *dev;
-	struct mvx_if_ops *if_ops;
-	struct mvx_client_ops client_ops;
-	struct mvx_hwreg hwreg;
-	struct mvx_sched scheduler;
-	unsigned int irq;
-	struct workqueue_struct *work_queue;
-	struct work_struct work;
-	unsigned long irqve;
-	struct dentry *dentry;
-	struct reset_control *rst;
-};
-
 /**
  * struct mvx_client_session - Device session.
  *
@@ -98,7 +81,6 @@ struct mvx_client_session {
 	struct mvx_dev_ctx *ctx;
 	struct mvx_sched_session session;
 };
-
 /****************************************************************************
  * Static variables and functions
  ****************************************************************************/
@@ -113,20 +95,9 @@ static void get_hw_ver(struct mvx_client_ops *client,
 {
 	struct mvx_dev_ctx *ctx = client_ops_to_ctx(client);
 
-	int ret = 0;
-
-	ret = mvx_pm_runtime_get_sync(ctx->dev);
-	if (ret < 0) {
-		hw_ver->id = MVE_Unknown;
-		return;
-	}
-
-	hw_ver->id = mvx_hwreg_get_hw_id(&ctx->hwreg, &hw_ver->revision,
-					 &hw_ver->patch);
-
-	ret = mvx_pm_runtime_put_sync(ctx->dev);
-	if (ret < 0)
-		hw_ver->id = MVE_Unknown;
+	hw_ver->id = ctx->hw_id;
+	hw_ver->revision = ctx->hw_revision;
+	hw_ver->patch = ctx->hw_patch;
 }
 
 static void get_formats(struct mvx_client_ops *client,
@@ -136,19 +107,12 @@ static void get_formats(struct mvx_client_ops *client,
 	struct mvx_dev_ctx *ctx = client_ops_to_ctx(client);
 	uint32_t fuses;
 
-	int ret = 0;
-
 	*formats = 0;
 
-	ret = mvx_pm_runtime_get_sync(ctx->dev);
-	if (ret < 0)
-		return;
-
 	ctx->hwreg.ops.get_formats(direction, formats);
 
 	/* Remove formats based on fuses. */
-	fuses = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_FUSE);
-
+	fuses = ctx->fuses;
 	if (fuses & MVX_HWREG_FUSE_DISABLE_AFBC) {
 		mvx_clear_bit(MVX_FORMAT_YUV420_AFBC_8, formats);
 		mvx_clear_bit(MVX_FORMAT_YUV420_AFBC_10, formats);
@@ -166,10 +130,6 @@ static void get_formats(struct mvx_client_ops *client,
 
 	if (fuses & MVX_HWREG_FUSE_DISABLE_HEVC)
 		mvx_clear_bit(MVX_FORMAT_HEVC, formats);
-
-	ret = mvx_pm_runtime_put_sync(ctx->dev);
-	if (ret < 0)
-		*formats = 0;
 }
 
 static unsigned int get_ncores(struct mvx_client_ops *client)
@@ -177,17 +137,7 @@ static unsigned int get_ncores(struct mvx_client_ops *client)
 	struct mvx_dev_ctx *ctx = client_ops_to_ctx(client);
 	uint32_t ncores;
 
-	int ret = 0;
-
-	ret = mvx_pm_runtime_get_sync(ctx->dev);
-	if (ret < 0)
-		return 0;
-
-	ncores = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NCORES);
-
-	ret = mvx_pm_runtime_put_sync(ctx->dev);
-	if (ret < 0)
-		return 0;
+	ncores = ctx->ncores;
 
 	return ncores;
 }
@@ -280,6 +230,14 @@ static void print_debug(struct mvx_client_session *csession)
 	mvx_sched_print_debug(&ctx->scheduler, &csession->session);
 }
 
+static void wait_session_idle(struct mvx_client_session *csession)
+{
+    struct mvx_dev_ctx *ctx = csession->ctx;
+
+    mvx_sched_wait_session_idle(&ctx->scheduler, &csession->session);
+ }
+
+
 static struct mvx_dev_ctx *work_to_ctx(struct work_struct *work)
 {
 	return container_of(work, struct mvx_dev_ctx, work);
@@ -298,7 +256,7 @@ static void irq_bottom(struct work_struct *work)
 	uint32_t nlsid;
 	uint32_t i;
 
-	nlsid = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NLSID);
+	nlsid = ctx->scheduler.nlsid;
 	for (i = 0; i < nlsid; i++)
 		if (test_and_clear_bit(i, &ctx->irqve))
 			mvx_sched_handle_irq(&ctx->scheduler, i);
@@ -330,6 +288,7 @@ static irqreturn_t irq_top(int irq,
 					     nlsid,
 					     MVX_HWREG_LIRQVE,
 					     0);
+			wmb(); //make sure the LIRQVE is cleared.
 			set_bit(nlsid, &ctx->irqve);
 			ret = IRQ_HANDLED;
 		}
@@ -352,20 +311,16 @@ static int mvx_dev_probe(struct device *dev,
 		return -EINVAL;
 
 	ctx->dev = dev;
+	ctx->clock = devm_clk_get(dev, NULL);
+	mutex_init(&ctx->pm_mutex);
 
 	dev_set_drvdata(dev, ctx);
+	mvx_dvfs_init(dev);
 
 	ret = mvx_pm_runtime_get_sync(ctx->dev);
 	if (ret < 0)
 		goto free_ctx;
 
-
-	ctx->rst = devm_reset_control_get_optional_exclusive(dev, NULL);
-	if (IS_ERR(ctx->rst))
-		goto exit_reset;
-
-	reset_control_deassert(ctx->rst);
-
 	/* Setup client ops callbacks. */
 	ctx->client_ops.get_hw_ver = get_hw_ver;
 	ctx->client_ops.get_formats = get_formats;
@@ -376,6 +331,7 @@ static int mvx_dev_probe(struct device *dev,
 	ctx->client_ops.send_irq = send_irq;
 	ctx->client_ops.flush_mmu = flush_mmu;
 	ctx->client_ops.print_debug = print_debug;
+       ctx->client_ops.wait_session_idle = wait_session_idle;
 
 	/* Create if context. */
 	ctx->if_ops = mvx_if_create(dev, &ctx->client_ops, ctx);
@@ -404,6 +360,9 @@ static int mvx_dev_probe(struct device *dev,
 	if (ret != 0)
 		goto destruct_hwreg;
 
+	ctx->fuses = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_FUSE);
+	ctx->ncores = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NCORES);
+
 	/* Create work queue for IRQ handler. */
 	ctx->work_queue = alloc_workqueue(dev_name(dev), WQ_UNBOUND, 1);
 	if (ctx->work_queue == NULL) {
@@ -429,11 +388,11 @@ static int mvx_dev_probe(struct device *dev,
 	}
 
 	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
-		      "Linlon v%x identified. cores=%u, nlsid=%u, id=%u.",
+		      "Linlon v%x identified. cores=%u, nlsid=%u, id=%u, fuse=%08x, hw_id=%08x, hw_rev=%08x",
 		      mvx_hwreg_get_hw_id(&ctx->hwreg, NULL, NULL),
 		      mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NCORES),
 		      mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NLSID),
-		      dev->id);
+		      dev->id, ctx->fuses, ctx->hw_id, ctx->hw_revision);
 
 	ret = mvx_pm_runtime_put_sync(ctx->dev);
 	if (ret < 0)
@@ -463,9 +422,6 @@ static int mvx_dev_probe(struct device *dev,
 runtime_put:
 	pm_runtime_put_sync(ctx->dev);
 
-exit_reset:
-	reset_control_assert(ctx->rst);
-
 free_ctx:
 	devm_kfree(dev, ctx);
 
@@ -475,6 +431,7 @@ static int mvx_dev_probe(struct device *dev,
 static int mvx_dev_remove(struct mvx_dev_ctx *ctx)
 {
 	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "remove");
+	mvx_dvfs_deinit(ctx->dev);
 
 	mvx_if_destroy(ctx->if_ops);
 	free_irq(ctx->irq, ctx);
@@ -486,8 +443,6 @@ static int mvx_dev_remove(struct mvx_dev_ctx *ctx)
 	if (IS_ENABLED(CONFIG_DEBUG_FS))
 		debugfs_remove_recursive(ctx->dentry);
 
-	reset_control_assert(ctx->rst);
-
 	devm_kfree(ctx->dev, ctx);
 
 	return 0;
@@ -501,7 +456,7 @@ static int mvx_pdev_probe(struct platform_device *pdev)
 {
 	struct resource iores;
 	struct resource irqres;
-	unsigned int irq;
+	int irq;
 	int ret;
 
 	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "probe");
@@ -515,15 +470,18 @@ static int mvx_pdev_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/* Get IRQ resource. */
-	irq = of_irq_to_resource(pdev->dev.of_node, 0, &irqres);
-	if (irq == 0) {
+	irq = platform_get_irq(pdev, 0);
+
+	if (irq < 0) {
 		MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_ERROR,
 			      "Failed to get IRQ resource.");
 		return -EINVAL;
 	}
 
-	pm_runtime_set_active(&pdev->dev);
+	irqres.start = irq;
+	irqres.end   = irq;
+	irqres.flags = 0;
+
 	pm_runtime_enable(&pdev->dev);
 
 	ret = mvx_dev_probe(&pdev->dev, &iores, &irqres);
@@ -548,35 +506,124 @@ static int mvx_pdev_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+static void reset_hw(struct device *dev)
+{
+    uint32_t ncores;
+    uint32_t corelsid_mask;
+    struct mvx_dev_ctx *ctx;
+    ctx = dev_get_drvdata(dev);
+
+    if (ctx->hwreg.registers != NULL) {
+        ncores = mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_NCORES);
+        corelsid_mask = 0;
+        for (; ncores > 0; --ncores) {
+            corelsid_mask = (corelsid_mask << 4) | 0xF;
+        }
+        mvx_hwreg_write(&ctx->hwreg, MVX_HWREG_RESET, 1);
+        while (corelsid_mask != mvx_hwreg_read(&ctx->hwreg, MVX_HWREG_CORELSID)){}
+        mvx_hwreg_write(&ctx->hwreg, MVX_HWREG_CLKFORCE, 0);
+    }
+}
+
+static int b_backto_active;
+static void mvx_pm_disable_clk(struct device *dev)
+{
+    struct clk* clock;
+    struct mvx_dev_ctx *ctx;
+
+    ctx = dev_get_drvdata(dev);
+    clock = ctx->clock;
+
+    if (!IS_ERR_OR_NULL(clock))
+    {
+        clk_disable_unprepare(clock);
+    }
+}
+
+static void mvx_pm_enable_clk(struct device *dev)
+{
+    struct clk* clock;
+    struct mvx_dev_ctx *ctx;
+
+    ctx = dev_get_drvdata(dev);
+    clock = ctx->clock;
+
+    if (!IS_ERR_OR_NULL(clock))
+    {
+        clk_prepare_enable(clock);
+    }
+}
+
+static int mvx_pm_poweron(struct device *dev)
+{
+    struct mvx_dev_ctx *ctx = dev_get_drvdata(dev);
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_poweron");
+    mvx_pm_enable_clk(dev);
+    reset_hw(dev);
+    mvx_sched_resume(&ctx->scheduler);
+
+    return 0;
+}
+
+static int mvx_pm_poweroff(struct device *dev)
+{
+    struct mvx_dev_ctx *ctx = dev_get_drvdata(dev);
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_poweroff");
+    mvx_sched_suspend(&ctx->scheduler);
+    mvx_pm_disable_clk(dev);
+
+    return 0;
+}
 
 static int mvx_pm_suspend(struct device *dev)
 {
-	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_suspend");
-	return 0;
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_suspend start. b_backto_active=%d", b_backto_active);
+
+    if (!pm_runtime_status_suspended(dev)) {
+        mvx_pm_poweroff(dev);
+        b_backto_active = true;
+    } else {
+        b_backto_active = false;
+    }
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_suspend exit. b_backto_active=%d", b_backto_active);
+
+    return 0;
 }
 
 static int mvx_pm_resume(struct device *dev)
 {
-	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_resume");
-	return 0;
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_resume start. b_backto_active=%d", b_backto_active);
+
+    if (b_backto_active) {
+        mvx_pm_poweron(dev);
+    }
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_resume exit. b_backto_active=%d", b_backto_active);
+    return 0;
 }
 
 static int mvx_pm_runtime_suspend(struct device *dev)
 {
-	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_suspend");
-	return 0;
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_suspend");
+    mvx_pm_disable_clk(dev);
+    return 0;
 }
 
 static int mvx_pm_runtime_resume(struct device *dev)
 {
-	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_resume");
-	return 0;
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_resume");
+    mvx_pm_enable_clk(dev);
+    reset_hw(dev);
+
+    return 0;
 }
 
 static int mvx_pm_runtime_idle(struct device *dev)
 {
-	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_idle");
-	return 0;
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_pm_runtime_idle");
+    return 0;
 }
 
 static const struct dev_pm_ops mvx_dev_pm_ops = {
diff --git a/drivers/media/vpu/dev/mvx_dev.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.h
similarity index 76%
rename from drivers/media/vpu/dev/mvx_dev.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.h
index eb8cda687b29..db156f9d6d0e 100755
--- a/drivers/media/vpu/dev/mvx_dev.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_dev.h
@@ -32,6 +32,32 @@
 #ifndef _MVX_DEV_H_
 #define _MVX_DEV_H_
 
+#include "mvx_hwreg.h"
+#include "mvx_scheduler.h"
+
+/**
+ * struct mvx_dev_ctx - Private context for the MVx dev device.
+ */
+struct mvx_dev_ctx {
+	struct device *dev;
+	struct mvx_if_ops *if_ops;
+	struct mvx_client_ops client_ops;
+	struct mvx_hwreg hwreg;
+	struct mvx_sched scheduler;
+	unsigned int irq;
+	struct workqueue_struct *work_queue;
+	struct work_struct work;
+	unsigned long irqve;
+	struct dentry *dentry;
+	struct clk* clock;
+	struct mutex pm_mutex;
+	uint32_t fuses;
+	uint32_t ncores;
+	enum mvx_hw_id hw_id;
+	uint32_t hw_revision;
+	uint32_t hw_patch;
+};
+
 /****************************************************************************
  * Exported functions
  ****************************************************************************/
diff --git a/drivers/media/vpu/dev/mvx_hwreg.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.c
similarity index 97%
rename from drivers/media/vpu/dev/mvx_hwreg.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.c
index 397e15a0bf6f..3bb9c3434c03 100755
--- a/drivers/media/vpu/dev/mvx_hwreg.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.c
@@ -35,6 +35,7 @@
 
 #include <linux/device.h>
 #include <linux/of_address.h>
+#include <linux/clk.h>
 #include "mvx_log_group.h"
 #include "mvx_hwreg.h"
 #include "mvx_hwreg_v500.h"
@@ -42,6 +43,7 @@
 #include "mvx_hwreg_v61.h"
 #include "mvx_hwreg_v52_v76.h"
 #include "mvx_pm_runtime.h"
+#include "mvx_dev.h"
 
 /****************************************************************************
  * Static functions
@@ -68,6 +70,8 @@ static unsigned int get_offset(enum mvx_hwreg_what what)
 		return 0x24;
 	case MVX_HWREG_FUSE:
 		return 0x34;
+	case MVX_HWREG_CONFIG:
+		return 0x38;
 	case MVX_HWREG_PROTCTRL:
 		return 0x40;
 	case MVX_HWREG_RESET:
@@ -198,6 +202,8 @@ static int regs_show(struct seq_file *s,
 		   mvx_hwreg_read(hwreg, MVX_HWREG_CLKFORCE));
 	seq_printf(s, "FUSE = 0x%08x\n",
 		   mvx_hwreg_read(hwreg, MVX_HWREG_FUSE));
+	seq_printf(s, "CONFIG = 0x%08x\n",
+		   mvx_hwreg_read(hwreg, MVX_HWREG_CONFIG));
 	seq_printf(s, "PROTCTRL = 0x%08x\n",
 		   mvx_hwreg_read(hwreg, MVX_HWREG_PROTCTRL));
 	seq_printf(s, "RESET = 0x%08x\n",
@@ -349,6 +355,7 @@ int mvx_hwreg_construct(struct mvx_hwreg *hwreg,
 	enum mvx_hw_id hw_id;
 	int ret;
 	int lsid;
+	struct mvx_dev_ctx *ctx = dev_get_drvdata(dev);
 
 	hwreg->dev = dev;
 
@@ -369,7 +376,7 @@ int mvx_hwreg_construct(struct mvx_hwreg *hwreg,
 		goto release_mem;
 	}
 
-	hw_id = get_hw_id(hwreg->registers, NULL, NULL);
+	hw_id = get_hw_id(hwreg->registers, &ctx->hw_revision, &ctx->hw_patch);
 	switch (hw_id) {
 	case MVE_v500:
 		hwreg->ops.get_formats = mvx_hwreg_get_formats_v500;
@@ -388,6 +395,8 @@ int mvx_hwreg_construct(struct mvx_hwreg *hwreg,
 		goto unmap_io;
 	}
 
+	ctx->hw_id = hw_id;
+
 	for (lsid = 0; lsid < MVX_LSID_MAX; ++lsid) {
 		hwreg->lsid_hwreg[lsid].hwreg = hwreg;
 		hwreg->lsid_hwreg[lsid].lsid = lsid;
diff --git a/drivers/media/vpu/dev/mvx_hwreg.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.h
similarity index 99%
rename from drivers/media/vpu/dev/mvx_hwreg.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.h
index de4d1f9cacbc..9ff71619bb8c 100755
--- a/drivers/media/vpu/dev/mvx_hwreg.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg.h
@@ -96,6 +96,7 @@ enum mvx_hwreg_what {
 	MVX_HWREG_FUSE,
 	MVX_HWREG_PROTCTRL,
 	MVX_HWREG_RESET,
+	MVX_HWREG_CONFIG,
 	MVX_HWREG_WHAT_MAX
 };
 
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v500.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v500.c
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v500.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v500.c
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v500.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v500.h
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v500.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v500.h
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v52_v76.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v52_v76.c
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v52_v76.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v52_v76.c
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v52_v76.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v52_v76.h
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v52_v76.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v52_v76.h
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v550.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v550.c
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v550.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v550.c
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v550.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v550.h
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v550.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v550.h
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v61.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v61.c
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v61.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v61.c
diff --git a/drivers/media/vpu/dev/mvx_hwreg_v61.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v61.h
similarity index 100%
rename from drivers/media/vpu/dev/mvx_hwreg_v61.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_hwreg_v61.h
diff --git a/drivers/media/vpu/dev/mvx_lsid.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_lsid.c
similarity index 98%
rename from drivers/media/vpu/dev/mvx_lsid.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_lsid.c
index f01fa9b91c92..4750eb65f3de 100755
--- a/drivers/media/vpu/dev/mvx_lsid.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_lsid.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -154,7 +154,7 @@ int mvx_lsid_map(struct mvx_lsid *lsid,
 
 	if (of_property_read_u32_array(lsid->dev->of_node, "busattr", busattr,
 				       ARRAY_SIZE(busattr))) {
-		MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+		MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_VERBOSE,
 			      "busattr in of_node is not available.");
 
 		/* We apply default values in this case. */
@@ -181,7 +181,7 @@ int mvx_lsid_map(struct mvx_lsid *lsid,
 			     busattr[3]);
 
 	/* Restore interrupt registers. */
-	mvx_hwreg_write_lsid(hwreg, lsid->lsid, MVX_HWREG_IRQVE, 0);
+	mvx_hwreg_write_lsid(hwreg, lsid->lsid, MVX_HWREG_LIRQVE, 0);
 	mvx_hwreg_write_lsid(hwreg, lsid->lsid, MVX_HWREG_IRQHOST,
 			     pcb->irqhost);
 
diff --git a/drivers/media/vpu/dev/mvx_lsid.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_lsid.h
similarity index 100%
rename from drivers/media/vpu/dev/mvx_lsid.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_lsid.h
diff --git a/drivers/media/vpu/dev/mvx_scheduler.c b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.c
similarity index 73%
rename from drivers/media/vpu/dev/mvx_scheduler.c
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.c
index 21c323c6ce74..dfe28ce4379e 100755
--- a/drivers/media/vpu/dev/mvx_scheduler.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -37,6 +37,7 @@
 #include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/workqueue.h>
+#include <linux/delay.h>
 #include "mvx_if.h"
 #include "mvx_hwreg.h"
 #include "mvx_mmu.h"
@@ -170,6 +171,7 @@ static void sched_task(struct work_struct *ws)
 	struct mvx_sched_session *pending;
 	struct mvx_sched_session *unmapped;
 	struct mvx_sched_session *tmp;
+	struct mvx_session *m_session;
 	LIST_HEAD(notify_list);
 	int ret;
 
@@ -191,6 +193,11 @@ static void sched_task(struct work_struct *ws)
 		 * Just make sure it is scheduled.
 		 */
 		if (pending->lsid != NULL) {
+			m_session = mvx_if_session_to_session(pending->isession);
+			if (sched->is_suspend == true && m_session != NULL && m_session->switched_in == false) {
+                continue;
+			}
+
 			ret = mvx_lsid_jobqueue_add(pending->lsid,
 						    pending->isession->ncores);
 			if (ret != 0) {
@@ -205,7 +212,9 @@ static void sched_task(struct work_struct *ws)
 			pending->in_pending = false;
 			list_del(&pending->pending);
 			continue;
-		}
+		} else if (sched->is_suspend == true) {
+            continue;
+        }
 
 		/* Find LSID to be used for the pending session. */
 		lsid = find_free_lsid(sched);
@@ -265,7 +274,7 @@ static void sched_task(struct work_struct *ws)
 					list_add_tail(&unmapped->notify,
 						      &notify_list);
 			} else {
-				MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+				MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO,
 					      "Ref is zero. csession=%p",
 					      unmapped);
 			}
@@ -342,7 +351,7 @@ static void sched_session_print(struct seq_file *s,
 					   MVX_HWREG_IRQHOST));
 	mvx_seq_printf(s, "IRQ MVE", ind, "%d\n",
 		       mvx_hwreg_read_lsid(hwreg, lsid->lsid,
-					   MVX_HWREG_IRQVE));
+					   MVX_HWREG_LIRQVE));
 }
 
 static int sched_show(struct seq_file *s,
@@ -435,6 +444,7 @@ int mvx_sched_construct(struct mvx_sched *sched,
 	sched->dev = dev;
 	sched->hwreg = hwreg;
 	sched->if_ops = if_ops;
+	sched->is_suspend = false;
 	mutex_init(&sched->mutex);
 	INIT_LIST_HEAD(&sched->pending);
 	INIT_WORK(&sched->sched_task, sched_task);
@@ -594,6 +604,36 @@ static void print_session(struct mvx_sched *sched,
 		      irqve, irqhost);
 }
 
+void mvx_sched_wait_session_idle(struct mvx_sched *sched,
+        struct mvx_sched_session *session)
+{
+    bool is_idle = 0;
+    int wait_count = 20;
+
+    mutex_lock(&sched->mutex);
+
+    if (session->lsid != NULL) {
+        is_idle = mvx_lsid_idle(session->lsid);
+        if (is_idle == 0) {
+            do {
+                mutex_unlock(&sched->mutex);
+                msleep(50);
+                mutex_lock(&sched->mutex);
+                if (session->lsid != NULL) {
+                    is_idle = mvx_lsid_idle(session->lsid);
+                } else {
+                    is_idle = 1;
+                }
+            } while(wait_count-- && is_idle != 1);
+        }
+
+        if (is_idle == 0) {
+            mvx_lsid_terminate(session->lsid);
+        }
+    }
+    mutex_unlock(&sched->mutex);
+}
+
 void mvx_sched_print_debug(struct mvx_sched *sched,
 			   struct mvx_sched_session *session)
 {
@@ -623,12 +663,19 @@ void mvx_sched_print_debug(struct mvx_sched *sched,
 	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING, "%p Print register:", s);
 
 	MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
-		      "%p     jobqueue=%08x, corelsid=%08x, irqve=%08x, irqhost=%08x",
+		      "%p     jobqueue=%08x, corelsid=%08x, irqve=%08x,HARDWARE_ID=0x%08x,ENABLE=0x%08x,NCORES=0x%08x,NLSID=0x%08x,CLKFORCE=0x%08x,PROTCTRL=0x%08x,RESET=0x%08x,FUSE=0x%08x",
 		      s,
 		      mvx_hwreg_read(hwreg, MVX_HWREG_JOBQUEUE),
 		      mvx_hwreg_read(hwreg, MVX_HWREG_CORELSID),
 		      mvx_hwreg_read(hwreg, MVX_HWREG_IRQVE),
-		      mvx_hwreg_read(hwreg, MVX_HWREG_IRQHOST));
+		      mvx_hwreg_read(hwreg, MVX_HWREG_HARDWARE_ID),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_ENABLE),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_NCORES),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_NLSID),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_CLKFORCE),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_PROTCTRL),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_RESET),
+		      mvx_hwreg_read(hwreg, MVX_HWREG_FUSE));
 
 	for (i = 0; i < sched->nlsid; i++) {
 		struct mvx_sched_session *ss = sched->lsid[i].session;
@@ -639,10 +686,19 @@ void mvx_sched_print_debug(struct mvx_sched *sched,
 
 		MVX_LOG_PRINT(
 			&mvx_log_dev, MVX_LOG_WARNING,
-			"%p     lsid=%u, session=%p, irqve=%08x, irqhost=%08x",
+			"%p     lsid=%u, session=%p, irqve=%08x, irqhost=%08x,CTRL=0x%08x,MMU_CTRL=0x%08x,NPROT=0x%08x,ALLOC=0x%08x,FLUSH_ALL=0x%08x,SCHED=0x%08x,TERMINATE=0x%08x,INTSIG=0x%08x,STREAMID=0x%08x",
 			s, i, ls,
 			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_LIRQVE),
-			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_IRQHOST));
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_IRQHOST),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_CTRL),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_MMU_CTRL),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_NPROT),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_ALLOC),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_FLUSH_ALL),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_SCHED),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_TERMINATE),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_INTSIG),
+			mvx_hwreg_read_lsid(hwreg, i, MVX_HWREG_STREAMID));
 	}
 
 	mutex_unlock(&sched->mutex);
@@ -721,3 +777,153 @@ void mvx_sched_terminate(struct mvx_sched *sched,
 
 	mutex_unlock(&sched->mutex);
 }
+
+static void suspend_session(struct mvx_sched *sched,
+        struct mvx_sched_session *session)
+{
+    struct mvx_lsid *lsid = session->lsid;
+
+    if (lsid == NULL)
+        return;
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+            "%p suspend_session LSID. lsid=%u, jobqueue=%08x, corelsid=%08x.",
+            mvx_if_session_to_session(session->isession),
+            lsid->lsid,
+            mvx_hwreg_read(sched->hwreg, MVX_HWREG_JOBQUEUE),
+            mvx_hwreg_read(sched->hwreg, MVX_HWREG_CORELSID));
+
+    mvx_lsid_unmap(lsid, &session->pcb);
+}
+
+static int resume_session(struct mvx_sched *sched,
+        struct mvx_sched_session *session,
+        struct mvx_lsid *lsid)
+{
+    int ret;
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+            "%p resume_session LSID. lsid=%u, jobqueue=%08x, corelsid=%08x.",
+            mvx_if_session_to_session(session->isession),
+            lsid->lsid,
+            mvx_hwreg_read(sched->hwreg, MVX_HWREG_JOBQUEUE),
+            mvx_hwreg_read(sched->hwreg, MVX_HWREG_CORELSID));
+
+    ret = mvx_lsid_map(lsid, &session->pcb);
+    if (ret != 0)
+        return ret;
+
+    return 0;
+}
+
+static void switch_out_session(struct mvx_sched *sched, struct mvx_sched_session *sched_session)
+{
+    int i;
+    int ret;
+    struct mvx_session *session = NULL;
+    struct mvx_if_session *isession = NULL;
+    int wait_count = 20;
+
+    if (sched_session != NULL) {
+        ret = kref_get_unless_zero(&sched_session->isession->kref);
+        if (ret != 0)
+            isession = sched_session->isession;
+    }
+
+    mutex_unlock(&sched->mutex);
+
+    if (isession != NULL) {
+        session = mvx_if_session_to_session(sched_session->isession);
+        mutex_lock(isession->mutex);
+        if (session != NULL) {
+            session->is_suspend = true;
+        }
+        ret = kref_put(&isession->kref, isession->release);
+
+        if (ret == 0)
+            mutex_unlock(isession->mutex);
+    }
+
+    mutex_lock(&sched->mutex);
+    for (i = 0; i < wait_count; i++) {
+        if (session != NULL && session->switched_in == false) {
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                    "%p finish switch_out session LSID. lsid=%u.", session, sched_session->lsid->lsid);
+            break;
+        }
+        mutex_unlock(&sched->mutex);
+        msleep(10);
+
+        mutex_lock(&sched->mutex);
+
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "%p wait switch_out session LSID. lsid=%u. loop=%d", session, sched_session->lsid->lsid, i);
+    }
+}
+
+static int switch_in_session(struct mvx_sched_session *sched_session)
+{
+    int ret;
+    struct mvx_session *session;
+    session = mvx_if_session_to_session(sched_session->isession);
+    if (session == NULL) {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING, "session is null when switch in.");
+        return -EINVAL;
+    }
+
+    session->is_suspend = false;
+    if (session->fw.msg_pending > 0) {
+        session->idle_count = 0;
+
+        if (session->switched_in != false)
+            return 0;
+
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "switch_in_session.");
+
+        ret = session->client_ops->switch_in(session->csession);
+        if (ret != 0) {
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING, "Failed to switch in session.");
+            session->error = ret;
+            wake_up(&session->waitq);
+            session->event(session, MVX_SESSION_EVENT_ERROR, (void *)session->error);
+            return ret;
+        }
+
+        session->switched_in = true;
+    }
+    return 0;
+}
+
+void mvx_sched_suspend(struct mvx_sched *sched)
+{
+    unsigned int i;
+
+    mutex_lock(&sched->mutex);
+    sched->is_suspend = true;
+
+    for (i = 0; i < sched->nlsid; i++) {
+        if (sched->lsid[i].session != NULL) {
+            switch_out_session(sched, sched->lsid[i].session);
+            mvx_lsid_terminate(sched->lsid[i].session->lsid);
+            suspend_session(sched, sched->lsid[i].session);
+        }
+    }
+
+    mutex_unlock(&sched->mutex);
+}
+
+void mvx_sched_resume(struct mvx_sched *sched)
+{
+    unsigned int i;
+
+    mutex_lock(&sched->mutex);
+
+    for (i = 0; i < sched->nlsid; i++) {
+        if (sched->lsid[i].session != NULL) {
+            resume_session(sched, sched->lsid[i].session, &(sched->lsid[i]));
+            switch_in_session(sched->lsid[i].session);
+        }
+    }
+    sched->is_suspend = false;
+    mutex_unlock(&sched->mutex);
+}
diff --git a/drivers/media/vpu/dev/mvx_scheduler.h b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.h
similarity index 96%
rename from drivers/media/vpu/dev/mvx_scheduler.h
rename to drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.h
index a1b1b1c00c99..e3b8d0ea4f2a 100755
--- a/drivers/media/vpu/dev/mvx_scheduler.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/dev/mvx_scheduler.h
@@ -68,6 +68,7 @@ struct mvx_sched {
 	struct mvx_lsid lsid[MVX_LSID_MAX];
 	struct work_struct sched_task;
 	struct workqueue_struct *sched_queue;
+	bool is_suspend;
 };
 
 /**
@@ -191,4 +192,10 @@ void mvx_sched_terminate(struct mvx_sched *sched,
 void mvx_sched_print_debug(struct mvx_sched *sched,
 			   struct mvx_sched_session *session);
 
+void mvx_sched_suspend(struct mvx_sched *sched);
+
+void mvx_sched_resume(struct mvx_sched *sched);
+
+void mvx_sched_wait_session_idle(struct mvx_sched *sched, struct mvx_sched_session *session);
+
 #endif /* _MVX_SCHEDULER_H_ */
diff --git a/drivers/media/vpu/external/fw_v2/mve_protocol_def.h b/drivers/media/platform/spacemit/vpu_k1x/external/fw_v2/mve_protocol_def.h
similarity index 99%
rename from drivers/media/vpu/external/fw_v2/mve_protocol_def.h
rename to drivers/media/platform/spacemit/vpu_k1x/external/fw_v2/mve_protocol_def.h
index 37b44bf12aea..57030cece21b 100755
--- a/drivers/media/vpu/external/fw_v2/mve_protocol_def.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/external/fw_v2/mve_protocol_def.h
@@ -1547,6 +1547,8 @@ struct mve_buffer_param_colour_description
     uint16_t sar_height;
     uint32_t num_units_in_tick;
     uint32_t time_scale;
+
+    uint32_t reserved[2];
 };
 
 struct mve_buffer_param_sei_user_data_unregistered
diff --git a/drivers/media/vpu/external/fw_v3/mve_protocol_def.h b/drivers/media/platform/spacemit/vpu_k1x/external/fw_v3/mve_protocol_def.h
similarity index 100%
rename from drivers/media/vpu/external/fw_v3/mve_protocol_def.h
rename to drivers/media/platform/spacemit/vpu_k1x/external/fw_v3/mve_protocol_def.h
diff --git a/drivers/media/vpu/if/mvx_bitops.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_bitops.h
similarity index 100%
rename from drivers/media/vpu/if/mvx_bitops.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_bitops.h
diff --git a/drivers/media/vpu/if/mvx_buffer.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.c
similarity index 96%
rename from drivers/media/vpu/if/mvx_buffer.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.c
index bba0ba0d1534..57922a3d91a3 100755
--- a/drivers/media/vpu/if/mvx_buffer.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -369,7 +369,7 @@ mvx_mmu_va mvx_buffer_va(struct mvx_buffer *buf,
 	if (plane >= buf->nplanes || p->pages == NULL)
 		return 0;
 
-	return p->pages->va + p->pages->offset;
+	return p->pages->va + p->pages->offset + p->offset;
 }
 
 int mvx_buffer_frame_dim(enum mvx_format format,
@@ -409,6 +409,10 @@ int mvx_buffer_frame_dim(enum mvx_format format,
         size[1] = DIV_ROUND_UP(height * s[1][1],
 				       SUBSAMPLE_PIXELS ) * stride[1];
     }
+
+    for (i = *nplanes; i < MVX_BUFFER_NPLANES; i++) {
+        size[i] = 0;
+    }
 	return 0;
 }
 
@@ -430,19 +434,18 @@ int mvx_buffer_frame_set(struct mvx_buffer *buf,
 		struct mvx_buffer_plane *plane = &buf->planes[i];
 
 		plane->stride = stride[i];
-		plane->offset = 0;
 
 		if (buf->dir == MVX_DIR_OUTPUT) {
 			int ret;
 
-			ret = mvx_buffer_filled_set(buf, i, size[i], 0);
+			ret = mvx_buffer_filled_set(buf, i, size[i], plane->offset);
 			if (ret != 0)
 				return ret;
 		}
 
 		/* Verify that plane has correct length. */
 		if (plane->filled > 0 && plane->filled != size[i]) {
-			MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING,
+			MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_INFO,
 				      "Buffer filled length does not match plane size. plane=%i, filled=%zu, size=%u.",
 				      i, plane->filled, size[i]);
 			//return -ENOMEM;
@@ -451,8 +454,8 @@ int mvx_buffer_frame_set(struct mvx_buffer *buf,
 		/* Verify that there is no buffer overflow. */
 		if ((plane->filled + plane->offset) > mvx_buffer_size(buf, i)) {
 			MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING,
-				      "Buffer plane size is too small. plane=%i, size=%zu, size=%u.",
-				      i, size[i], mvx_buffer_size(buf, i));
+				      "Buffer plane size is too small. plane=%i, size=%zu, size=%u, filled=%u, offset=%u",
+				      i, size[i], mvx_buffer_size(buf, i), plane->filled, plane->offset);
 			return -ENOMEM;
 		}
 	}
@@ -478,7 +481,6 @@ int mvx_buffer_afbc_set(struct mvx_buffer *buf,
 	buf->format = format;
 	buf->width = width;
 	buf->height = height;
-	buf->planes[0].offset = 0;
 	buf->planes[0].afbc_width = afbc_width;
 
 	if (buf->dir == MVX_DIR_INPUT) {
@@ -487,7 +489,7 @@ int mvx_buffer_afbc_set(struct mvx_buffer *buf,
 	}
 
 	if (buf->dir == MVX_DIR_OUTPUT) {
-		ret = mvx_buffer_filled_set(buf, 0, size, 0);
+		ret = mvx_buffer_filled_set(buf, 0, size, buf->planes[0].offset);
 		if (ret != 0)
 			return ret;
 	}
diff --git a/drivers/media/vpu/if/mvx_buffer.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.h
similarity index 96%
rename from drivers/media/vpu/if/mvx_buffer.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.h
index 4f7692ca554a..c035e23bab4c 100755
--- a/drivers/media/vpu/if/mvx_buffer.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_buffer.h
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 #ifndef _MVX_BUFFER_H_
@@ -184,6 +184,16 @@ struct mvx_buffer {
     struct mvx_buffer_general general;
 };
 
+/**
+ * struct mvx_buffer - Buffer descriptor.
+ * @head:	List head used to add buffer to corrupt buffer queues.
+ * @user_data:	User data copied from input- to output buffer.
+ */
+struct mvx_corrupt_buffer {
+	struct list_head head;
+	uint64_t user_data;
+};
+
 #define MVX_BUFFER_EOS                  0x00000001
 #define MVX_BUFFER_EOF                  0x00000002
 #define MVX_BUFFER_CORRUPT              0x00000004
@@ -216,6 +226,11 @@ struct mvx_buffer {
 
 #define MVX_BUFFER_FRAME_NEED_REALLOC       0x00100000  /* This buffer needs realloc */
 
+#define MVX_BUFFER_FRAME_FLAG_IFRAME        0x20000000
+#define MVX_BUFFER_FRAME_FLAG_PFRAME        0x40000000
+#define MVX_BUFFER_FRAME_FLAG_BFRAME        0x80000000
+
+
 /****************************************************************************
  * External functions
  ****************************************************************************/
diff --git a/drivers/media/vpu/if/mvx_firmware.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware.c
similarity index 100%
rename from drivers/media/vpu/if/mvx_firmware.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware.c
diff --git a/drivers/media/vpu/if/mvx_firmware.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware.h
similarity index 99%
rename from drivers/media/vpu/if/mvx_firmware.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware.h
index ae54a5f49452..0ef9d4172667 100755
--- a/drivers/media/vpu/if/mvx_firmware.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware.h
@@ -554,7 +554,11 @@ struct mvx_fw_set_option {
 
         MVX_FW_SET_LONG_TERM_REF,
 
-        MVX_FW_SET_DSL_MODE
+        MVX_FW_SET_DSL_MODE,
+
+        MVX_FW_SET_GOP_RESET,
+
+        MVX_FW_SET_INDEX_PROFILING
     } code;
 
     /**
@@ -606,6 +610,7 @@ struct mvx_fw_set_option {
         struct mvx_dsl_frame dsl_frame;
         struct mvx_long_term_ref ltr;
         int dsl_pos_mode;
+        int index_profiling;
     };
 };
 #define MVX_FW_COLOR_DESC_DISPLAY_VALID         0x1
@@ -635,6 +640,7 @@ enum mvx_fw_code {
 	MVX_FW_CODE_DEBUG,              /* Driver <-> Firmware. */
 	MVX_FW_CODE_BUFFER_GENERAL,     /* Driver <-> Firmware. */
 	MVX_FW_CODE_UNKNOWN,            /* Driver <- Firmware. */
+	MVX_FW_CODE_DPB_HELD_FRAMES,    /* Driver <- Firmware. */
 	MVX_FW_CODE_MAX
 };
 
diff --git a/drivers/media/vpu/if/mvx_firmware_cache.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_cache.c
similarity index 99%
rename from drivers/media/vpu/if/mvx_firmware_cache.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_cache.c
index 7b656a64cf51..4a607c18a419 100755
--- a/drivers/media/vpu/if/mvx_firmware_cache.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_cache.c
@@ -421,13 +421,13 @@ static struct attribute *fw_bin_attrs[] = {
 };
 
 static const struct attribute_group fw_bin_group = {
-	.name = "",
-	.attrs = fw_bin_attrs
+    .name = "",
+    .attrs = fw_bin_attrs
 };
 
 static const struct attribute_group *fw_bin_groups[] = {
-	&fw_bin_group,
-	NULL
+    &fw_bin_group,
+    NULL
 };
 
 static struct kobj_type fw_bin_ktype = {
@@ -603,13 +603,13 @@ static struct attribute *cache_attrs[] = {
 };
 
 static const struct attribute_group cache_group = {
-	.name = "",
-	.attrs = cache_attrs
+    .name = "",
+    .attrs = cache_attrs
 };
 
 static const struct attribute_group *cache_groups[] = {
-	&cache_group,
-	NULL
+    &cache_group,
+    NULL
 };
 
 static void cache_release(struct kobject *kobj)
diff --git a/drivers/media/vpu/if/mvx_firmware_cache.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_cache.h
similarity index 100%
rename from drivers/media/vpu/if/mvx_firmware_cache.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_cache.h
diff --git a/drivers/media/vpu/if/mvx_firmware_priv.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_priv.h
similarity index 100%
rename from drivers/media/vpu/if/mvx_firmware_priv.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_priv.h
diff --git a/drivers/media/vpu/if/mvx_firmware_v2.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_v2.c
similarity index 94%
rename from drivers/media/vpu/if/mvx_firmware_v2.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_v2.c
index 33e2709f6790..ee83f959729c 100755
--- a/drivers/media/vpu/if/mvx_firmware_v2.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_v2.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -35,6 +35,7 @@
 
 #include <linux/dma-buf.h>
 #include <linux/dma-mapping.h>
+#include <linux/string.h>
 #include "fw_v2/mve_protocol_def.h"
 #include "mvx_firmware_cache.h"
 #include "mvx_firmware_priv.h"
@@ -44,6 +45,7 @@
 #include "mvx_secure.h"
 #include "mvx_seq.h"
 #include "mvx_session.h"
+#include "mvx_v4l2_session.h"
 
 /****************************************************************************
  * Static functions
@@ -299,6 +301,17 @@ static int read_message(struct mvx_fw *fw,
 
 	if (capacity <= 0)
 		return 0;
+        /*
+         * It's possible below sequence occurs due to process out-of-order execution:
+         * 1. read msg_header first and host_area->out_rpos++;
+         * 2. firmware writes msg_header and updates mve_area->out_wpos;
+         * 3. compare host_area->out_rpos and mve_area->out_wpos, since the latter
+         *    is updated in step 2, the available is not 0;
+         * 4. parse the msg_header got in step 1 and it's invalid because it should
+         *    be read after update in step 2.
+         * Add barrier here to ensure msg_header is always read after firmware  updates.
+         */
+        smp_rmb();
 
 	/* Read the header. */
 	rpos = read32n(mve->out_data, rpos, (uint32_t *)&header,
@@ -394,7 +407,7 @@ static int write_message(struct mvx_fw *fw,
 			 size_t size,
 			 enum mvx_log_fwif_channel channel)
 {
-	struct mve_msg_header header = { code = code, .size = size };
+	struct mve_msg_header header = { .code = code, .size = size };
 	ssize_t capacity;
 	unsigned int wpos;
 
@@ -411,7 +424,7 @@ static int write_message(struct mvx_fw *fw,
 
 	/* Make sure there is enough space for both header and message. */
 	capacity -= DIV_ROUND_UP(sizeof(header) + size, sizeof(uint32_t));
-	if (capacity < 0)
+	if (capacity <= 0)
 		return -ENOMEM;
 
 	/* Write header. */
@@ -636,15 +649,33 @@ static void convert_buffer_bitstream(struct mvx_fw *fw,
 
 	buf->user_data = b->user_data_tag;
 	buf->flags = 0;
-
+    if (dir == MVX_DIR_INPUT) {
+        struct mvx_corrupt_buffer *corrupt_buf;
+        struct mvx_corrupt_buffer *tmp;
+        list_for_each_entry_safe(corrupt_buf, tmp, &fw->session->buffer_corrupt_queue, head) {
+            if (corrupt_buf->user_data == buf->user_data) {
+                list_del(&corrupt_buf->head);
+                buf->flags |= MVX_BUFFER_CORRUPT;
+                vfree(corrupt_buf);
+            }
+        }
+    }
 	if (b->bitstream_flags & MVE_BUFFER_BITSTREAM_FLAG_EOS)
 		buf->flags |= MVX_BUFFER_EOS;
 
-	if (b->bitstream_flags & MVE_BUFFER_BITSTREAM_FLAG_ENDOFFRAME)
-		buf->flags |= MVX_BUFFER_EOF;
+        if (b->bitstream_flags & MVE_BUFFER_BITSTREAM_FLAG_ENDOFFRAME)
+                buf->flags |= MVX_BUFFER_EOF;
+
+        if (b->bitstream_flags & MVE_BUFFER_BITSTREAM_FLAG_CODECCONFIG)
+                buf->flags |= MVX_BUFFER_CODEC_CONFIG;
 
-	if (b->bitstream_flags & MVE_BUFFER_BITSTREAM_FLAG_CODECCONFIG)
-		buf->flags |= MVX_BUFFER_CODEC_CONFIG;
+        if (b->frame_type == 0) {
+            buf->flags |= MVX_BUFFER_FRAME_FLAG_IFRAME;
+        } else if (b->frame_type == 1) {
+            buf->flags |= MVX_BUFFER_FRAME_FLAG_PFRAME;
+        } else if (b->frame_type == 2) {
+            buf->flags |= MVX_BUFFER_FRAME_FLAG_BFRAME;
+        }
 }
 
 static int convert_buffer_param(struct mvx_fw *fw,
@@ -688,6 +719,7 @@ static int convert_buffer_param(struct mvx_fw *fw,
 			d->primaries = MVX_FW_PRIMARIES_BT601_625;
 			break;
 		case 6:
+		case 7:
 			d->primaries = MVX_FW_PRIMARIES_BT601_525;
 			break;
 		case 8:
@@ -703,8 +735,11 @@ static int convert_buffer_param(struct mvx_fw *fw,
 
 		/* Transfer characteristics according to HEVC E.3.1. */
 		switch (c->transfer_characteristics) {
+		case 12:
+		        d->transfer = MVX_FW_TRANSFER_BT1361;
+		        break;
 		case 1:
-			d->transfer = MVX_FW_TRANSFER_BT1361;
+			d->transfer = MVX_FW_TRANSFER_SMPTE170M;
 			break;
 		case 4:
 			d->transfer = MVX_FW_TRANSFER_GAMMA22;
@@ -725,6 +760,8 @@ static int convert_buffer_param(struct mvx_fw *fw,
 			break;
 		case 9:
 		case 10:
+			d->transfer = MVX_FW_TRANSFER_UNSPECIFIED;
+			break;
 		case 18:
 			d->transfer = MVX_FW_TRANSFER_HLG;
 			break;
@@ -750,11 +787,12 @@ static int convert_buffer_param(struct mvx_fw *fw,
 		case 1:
 			d->matrix = MVX_FW_MATRIX_BT709;
 			break;
-		case 5:
+		case 4:
 			d->matrix = MVX_FW_MATRIX_BT470M;
 			break;
+		case 5:
 		case 6:
-			d->matrix = MVX_FW_MATRIX_BT709;
+			d->matrix = MVX_FW_MATRIX_BT601;
 			break;
 		case 7:
 			d->matrix = MVX_FW_MATRIX_SMPTE240M;
@@ -801,6 +839,12 @@ static int convert_buffer_param(struct mvx_fw *fw,
 		msg->code = MVX_FW_CODE_COLOR_DESC;
 		break;
 	}
+	case MVE_BUFFER_PARAM_TYPE_DPB_HELD_FRAMES: {
+		msg->arg = p->data.arg;
+		msg->code = MVX_FW_CODE_DPB_HELD_FRAMES;
+		break;
+	}
+
 	default:
 		MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_INFO,
 			      "Default buffer param. type=%d", p->type);
@@ -826,11 +870,19 @@ static int get_buffer(struct mvx_fw *fw,
 	} fw_msg;
 	size_t size = sizeof(fw_msg);
 	int ret;
+	struct mvx_session *session = fw->session;
+	struct mvx_v4l2_session *vsession =
+		           container_of(session, struct mvx_v4l2_session, session);
 
 	ret = read_message(fw, host, mve, &code, &fw_msg, &size, channel);
 	if (ret <= 0)
 		return ret;
 
+	if (vsession->port[dir].q_set == false) {
+		MVX_SESSION_WARN(session, "vb2 queue is released. dir=%d, code=%d.", dir, code);
+		return 0;
+	}
+
 	switch (code) {
 	case MVE_BUFFER_CODE_FRAME:
 		convert_buffer_frame(fw, dir, msg, &fw_msg.frame);
@@ -1008,11 +1060,50 @@ static int get_message_v2(struct mvx_fw *fw,
 		session->port[MVX_DIR_OUTPUT].interlaced = fw_msg.seq_param.interlace;
 		break;
 	case MVE_RESPONSE_CODE_EVENT:
+        if (MVE_EVENT_ERROR_STREAM_CORRUPT == fw_msg.event.event_code) {
+            int ret = 0;
+            bool is_find = false;
+            struct mvx_corrupt_buffer *buf_corrupt;
+            uint64_t user_data = 0;
+            char* tmp;
+            char* err_msg = fw_msg.event.event_data.message;
+            char* err_msg_sep = vmalloc(sizeof(char)*MVE_MAX_ERROR_MESSAGE_SIZE);
+            memcpy(err_msg_sep,err_msg,MVE_MAX_ERROR_MESSAGE_SIZE);
+            tmp = strsep(&err_msg_sep, ",");
+            while (tmp != NULL) {
+                ret = sscanf(tmp,"UDT[%llx]",&user_data);
+                if (ret == 1) {
+                    is_find = true;
+                    break;
+                }
+                tmp = strsep(&err_msg_sep, ",");
+            }
+            vfree(err_msg_sep);
+            if (!is_find) {
+               MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_ERROR, "EVENT code=%d %s.but not found UDT ret:%d",fw_msg.event.event_code,fw_msg.event.event_data.message,ret);
+            } else {
+                buf_corrupt = vmalloc(sizeof(struct mvx_corrupt_buffer));
+                buf_corrupt->user_data = user_data;
+                list_add(&buf_corrupt->head, &fw->session->buffer_corrupt_queue);
+            }
+        }
+        if (MVE_EVENT_ERROR_STREAM_NOT_SUPPORTED == fw_msg.event.event_code) {
+            MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING, "event STREAM_NOT_SUPPORTED. code=%d. %s.",fw_msg.event.event_code,fw_msg.event.event_data.message);
+            wake_up(&session->waitq);
+            session->event(session, MVX_SESSION_EVENT_ERROR, (void *)(-EINVAL));
+        }
 		MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_INFO,
 				      "EVENT code=%d. %s",
-				      fw_msg.event.event_code, 
+				      fw_msg.event.event_code,
 				      (MVE_EVENT_ERROR_STREAM_CORRUPT == fw_msg.event.event_code
 				      	|| MVE_EVENT_ERROR_STREAM_NOT_SUPPORTED == fw_msg.event.event_code) ? fw_msg.event.event_data.message : "");
+        if (fw_msg.event.event_code == MVE_EVENT_PROCESSED) {
+            session->bus_read_bytes_total += fw_msg.event.event_data.event_processed.bus_read_bytes;
+            session->bus_write_bytes_total += fw_msg.event.event_data.event_processed.bus_write_bytes;
+            if (fw_msg.event.event_data.event_processed.pic_format == 0) {
+                session->frame_id++;
+            }
+        }
 		break;
 	case MVE_RESPONSE_CODE_REF_FRAME_UNUSED:
 		break;
@@ -1723,7 +1814,6 @@ static int put_message_v2(struct mvx_fw *fw,
                     msg->set_option.rate_control.maximum_bitrate;
                 }
             }
-
             ret = put_fw_buf_param(fw, &param,
                            sizeof(param.data.rate_control));
             break;
@@ -1767,6 +1857,16 @@ static int put_message_v2(struct mvx_fw *fw,
 
             break;
         }
+        case MVX_FW_SET_INDEX_PROFILING: {
+            struct mve_request_set_option opt;
+
+            opt.index = MVE_SET_OPT_INDEX_PROFILING;
+            opt.data.arg = msg->set_option.index_profiling;
+
+            ret = put_fw_opt(fw, &opt, sizeof(opt.data.arg));
+
+            break;
+        }
         case MVX_FW_SET_HRD_BUF_SIZE: {
             struct mve_buffer_param param;
 
@@ -1825,7 +1925,7 @@ static int put_message_v2(struct mvx_fw *fw,
             /* Transfer characteristics according to HEVC E.3.1. */
     		switch (msg->set_option.colour_desc.transfer) {
         		case MVX_FW_TRANSFER_BT1361:
-        			param.data.colour_description.transfer_characteristics = 1;
+        			param.data.colour_description.transfer_characteristics = 12;
         			break;
         		case MVX_FW_TRANSFER_GAMMA22:
         			param.data.colour_description.transfer_characteristics = 4;
@@ -1843,7 +1943,7 @@ static int put_message_v2(struct mvx_fw *fw,
         			param.data.colour_description.transfer_characteristics = 8;
         			break;
         		case MVX_FW_TRANSFER_HLG:
-        			param.data.colour_description.transfer_characteristics = 9;
+        			param.data.colour_description.transfer_characteristics = 18;
         			break;
         		case MVX_FW_TRANSFER_XVYCC:
         			param.data.colour_description.transfer_characteristics = 11;
@@ -1867,7 +1967,7 @@ static int put_message_v2(struct mvx_fw *fw,
                     param.data.colour_description.matrix_coeff = 1;
                     break;
                 case MVX_FW_MATRIX_BT470M:
-                    param.data.colour_description.matrix_coeff = 5;
+                    param.data.colour_description.matrix_coeff = 4;
                     break;
                 case MVX_FW_MATRIX_BT601:
                     param.data.colour_description.matrix_coeff = 6;
@@ -1928,11 +2028,10 @@ static int put_message_v2(struct mvx_fw *fw,
                 param.data.colour_description.min_display_mastering_luminance =
                         msg->set_option.colour_desc.display.luminance_max;
             }
+
             ret = put_fw_buf_param(fw, &param,
                        sizeof(param.data.colour_description));
-
             break;
-
         }
         case MVX_FW_SET_SEI_USERDATA: {
             struct mve_buffer_param param;
@@ -2227,6 +2326,12 @@ static int put_message_v2(struct mvx_fw *fw,
 					       sizeof(param.data.qp));
 			break;
 		}
+		case MVX_FW_SET_GOP_RESET:{
+			struct mve_buffer_param param;
+			param.type = MVE_BUFFER_PARAM_TYPE_GOP_RESET;
+			ret = put_fw_buf_param(fw, &param, sizeof(param.data.arg));
+			break;
+		}
 		case MVX_FW_SET_RESYNC_INTERVAL: {
 			struct mve_request_set_option opt;
 
@@ -2811,6 +2916,7 @@ static int handle_rpc_v2(struct mvx_fw *fw)
 	return ret;
 }
 
+#ifdef MVX_FW_DEBUG_ENABLE
 #define RAM_PRINTBUF_SIZE MVE_FW_PRINT_RAM_SIZE
 #define RAM_PRINT_MAX_LEN (128)
 #define RAM_PRINT_BUF_CNT ((RAM_PRINTBUF_SIZE / RAM_PRINT_MAX_LEN) - 1)
@@ -2856,6 +2962,7 @@ static int handle_fw_ram_print_v2(struct mvx_fw *fw)
 
 	return ret;
 }
+#endif
 
 static void unmap_msq(struct mvx_fw *fw,
 		      void **data,
@@ -2909,6 +3016,7 @@ static int map_msq(struct mvx_fw *fw,
 	return 0;
 }
 
+#ifdef MVX_FW_DEBUG_ENABLE
 static void unmap_fw_print_ram(struct mvx_fw *fw,
 		      void **data,
 		      enum mvx_fw_region region)
@@ -2960,6 +3068,7 @@ static int map_fw_print_ram(struct mvx_fw *fw,
 
 	return 0;
 }
+#endif
 
 static void unmap_protocol_v2(struct mvx_fw *fw)
 {
@@ -2974,8 +3083,9 @@ static void unmap_protocol_v2(struct mvx_fw *fw)
 	unmap_msq(fw, &fw->buf_out_host, MVX_FW_REGION_BUF_OUT_HOST);
 	unmap_msq(fw, &fw->buf_out_mve, MVX_FW_REGION_BUF_OUT_MVE);
 	unmap_msq(fw, &fw->rpc, MVX_FW_REGION_RPC);
+#ifdef MVX_FW_DEBUG_ENABLE
 	unmap_fw_print_ram(fw, &fw->fw_print_ram, MVX_FW_REGION_PRINT_RAM);
-
+#endif
 	fw->latest_used_region_protected_pages = 0;
 	fw->latest_used_region_outbuf_pages = 0;
 
@@ -3017,9 +3127,11 @@ static int map_protocol_v2(struct mvx_fw *fw)
 	if (ret != 0)
 		goto unmap_fw;
 
+#ifdef MVX_FW_DEBUG_ENABLE
 	ret = map_fw_print_ram(fw, &fw->fw_print_ram, MVX_FW_REGION_PRINT_RAM);
 	if (ret != 0)
 		goto unmap_fw;
+#endif
 
 	return 0;
 
@@ -3083,6 +3195,8 @@ static void print_debug_v2(struct mvx_fw *fw)
 	unsigned int rpos, wpos;
 	ssize_t capacity;
 	struct mve_msg_header header;
+	struct mve_rpc_communication_area *rpc_area = fw->rpc;
+	union mve_rpc_params *p = &rpc_area->params;
 
 	dma_sync_single_for_cpu(fw->dev, virt_to_phys(msg_mve),
 				MVE_PAGE_SIZE, DMA_FROM_DEVICE);
@@ -3092,6 +3206,10 @@ static void print_debug_v2(struct mvx_fw *fw)
 			      msg_host->out_rpos, msg_host->in_wpos,
 			      msg_mve->out_wpos, msg_mve->in_rpos);
 
+	MVX_LOG_PRINT_SESSION(&mvx_log_session_if, MVX_LOG_WARNING, fw->session,
+			      "Dump fw rpc. state=%u, call_id=%u, size=%u, data=%u, debug_print=%s",
+			      rpc_area->state, rpc_area->call_id, rpc_area->size, p->data, p->debug_print.string);
+
 	rpos = msg_host->out_rpos;
 	wpos = msg_mve->out_wpos;
 
@@ -3161,7 +3279,9 @@ int mvx_fw_construct_v2(struct mvx_fw *fw,
 	fw->ops.get_message = get_message_v2;
 	fw->ops.put_message = put_message_v2;
 	fw->ops.handle_rpc = handle_rpc_v2;
+#ifdef MVX_FW_DEBUG_ENABLE
 	fw->ops.handle_fw_ram_print = handle_fw_ram_print_v2;
+#endif
 	fw->ops.print_stat = print_stat_v2;
 	fw->ops.print_debug = print_debug_v2;
 	fw->ops_priv.send_idle_ack = NULL;
diff --git a/drivers/media/vpu/if/mvx_firmware_v3.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_v3.c
similarity index 100%
rename from drivers/media/vpu/if/mvx_firmware_v3.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_firmware_v3.c
diff --git a/drivers/media/vpu/if/mvx_if.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_if.c
similarity index 100%
rename from drivers/media/vpu/if/mvx_if.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_if.c
diff --git a/drivers/media/vpu/if/mvx_if.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_if.h
similarity index 99%
rename from drivers/media/vpu/if/mvx_if.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_if.h
index 18090f01bb40..bff78e360024 100755
--- a/drivers/media/vpu/if/mvx_if.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_if.h
@@ -396,6 +396,8 @@ struct mvx_client_ops {
 	 * Return: 0 on success, else error code.
 	 */
 	void (*print_debug)(struct mvx_client_session *session);
+
+	void (*wait_session_idle)(struct mvx_client_session *session);
 };
 
 /****************************************************************************
diff --git a/drivers/media/vpu/if/mvx_mmu.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_mmu.c
similarity index 95%
rename from drivers/media/vpu/if/mvx_mmu.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_mmu.c
index 68ab5bebb774..43733b02b5c7 100755
--- a/drivers/media/vpu/if/mvx_mmu.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_mmu.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -436,7 +436,7 @@ static int append_sg_table(struct mvx_mmu_pages *pages,
 		int j;
 		phys_addr_t base;
 
-		base = (phys_addr_t)sg_page_iter_dma_address((struct sg_dma_page_iter*)&piter) &
+		base = (phys_addr_t)sg_page_iter_dma_address(&piter) &
 		       PAGE_MASK;
 
 		for (j = 0; j < MVX_PAGES_PER_PAGE; ++j)
@@ -641,31 +641,35 @@ void mvx_mmu_destruct(struct mvx_mmu *mmu)
 
 phys_addr_t mvx_mmu_alloc_page(struct device *dev)
 {
-	struct page *page;
-	phys_addr_t pa;
-	dma_addr_t dma_handle;
+    struct page *page;
+    phys_addr_t pa;
+    dma_addr_t dma_handle;
+    int retry = 20;
 
-	page = alloc_page(GFP_KERNEL | __GFP_ZERO | __GFP_NORETRY);
-	if (page == NULL)
-		return 0;
+    do {
+        page = alloc_page(GFP_KERNEL | __GFP_ZERO | __GFP_RETRY_MAYFAIL);
+    } while(retry-- && page == NULL);
 
-	dma_handle = dma_map_page(dev, page, 0, PAGE_SIZE, DMA_BIDIRECTIONAL);
-	if (dma_mapping_error(dev, dma_handle) != 0) {
-		MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING,
-			      "Cannot map page to DMA address space. page=%p.",
-			      page);
-		goto free_page;
-	}
+    if (page == NULL)
+        return 0;
 
-	pa = (phys_addr_t)dma_handle;
+    dma_handle = dma_map_page(dev, page, 0, PAGE_SIZE, DMA_BIDIRECTIONAL);
+    if (dma_mapping_error(dev, dma_handle) != 0) {
+        MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING,
+                "Cannot map page to DMA address space. page=%p.",
+                page);
+        goto free_page;
+    }
 
-	dma_sync_single_for_device(dev, pa, PAGE_SIZE, DMA_TO_DEVICE);
+    pa = (phys_addr_t)dma_handle;
 
-	return pa;
+    dma_sync_single_for_device(dev, pa, PAGE_SIZE, DMA_TO_DEVICE);
+
+    return pa;
 
 free_page:
-	__free_page(page);
-	return 0;
+    __free_page(page);
+    return 0;
 }
 
 void mvx_mmu_free_contiguous_pages(struct device *dev, phys_addr_t pa, size_t npages)
@@ -687,10 +691,14 @@ phys_addr_t mvx_mmu_alloc_contiguous_pages(struct device *dev, size_t npages)
 	phys_addr_t pa;
 	dma_addr_t dma_handle;
 	size_t size = (npages << PAGE_SHIFT);
+        int retry = 20;
 
-	page = alloc_pages(GFP_KERNEL | __GFP_ZERO | __GFP_NORETRY, get_order(size));
-	if (page == NULL)
-		return 0;
+        do {
+            page = alloc_pages(GFP_KERNEL | __GFP_ZERO | __GFP_RETRY_MAYFAIL, get_order(size));
+        } while(retry-- && page == NULL);
+
+        if (page == NULL)
+            return 0;
 
 	dma_handle = dma_map_page(dev, page, 0, size, DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(dev, dma_handle) != 0) {
@@ -736,12 +744,11 @@ struct mvx_mmu_pages *mvx_mmu_alloc_pages(struct device *dev,
 	capacity = roundup(capacity, MVX_PAGES_PER_PAGE);
 	capacity = max(count, capacity);
 
-	pages = devm_kzalloc(dev,
-			     sizeof(*pages) + sizeof(phys_addr_t) * capacity,
-			     GFP_KERNEL);
+        pages = vmalloc(sizeof(*pages) + sizeof(phys_addr_t) * capacity);
 	if (pages == NULL)
 		return ERR_PTR(-ENOMEM);
 
+        memset(pages, 0, sizeof(*pages) + sizeof(phys_addr_t) * capacity);
 	pages->dev = dev;
 	pages->capacity = capacity;
 	INIT_LIST_HEAD(&pages->dmabuf);
@@ -790,12 +797,11 @@ struct mvx_mmu_pages *mvx_mmu_alloc_pages_sg(struct device *dev,
 	capacity = roundup(capacity, MVX_PAGES_PER_PAGE);
 	capacity = max(count, capacity);
 
-	pages = devm_kzalloc(dev,
-			     sizeof(*pages) + sizeof(phys_addr_t) * capacity,
-			     GFP_KERNEL);
+        pages = vmalloc(sizeof(*pages) + sizeof(phys_addr_t) * capacity);
 	if (pages == NULL)
 		return ERR_PTR(-ENOMEM);
 
+        memset(pages, 0, sizeof(*pages) + sizeof(phys_addr_t) * capacity);
 	pages->dev = dev;
 	pages->capacity = capacity;
 	pages->is_external = true;
@@ -804,7 +810,7 @@ struct mvx_mmu_pages *mvx_mmu_alloc_pages_sg(struct device *dev,
 
 	ret = append_sg_table(pages, sgt);
 	if (ret != 0) {
-		devm_kfree(dev, pages);
+                vfree(pages);
 		return ERR_PTR(ret);
 	}
 
@@ -839,13 +845,14 @@ struct mvx_mmu_pages *mvx_mmu_alloc_pages_dma_buf(struct device *dev,
 	if (IS_ERR(pages))
 		goto unmap;
 
-	mbuf = devm_kzalloc(dev, sizeof(*mbuf), GFP_KERNEL);
+        mbuf = vmalloc(sizeof(*mbuf));
 	if (mbuf == NULL) {
 		mvx_mmu_free_pages(pages);
 		pages = ERR_PTR(-ENOMEM);
 		goto unmap;
 	}
 
+        memset(mbuf, 0, sizeof(*mbuf));
 	mbuf->dmabuf = dmabuf;
 	list_add_tail(&mbuf->head, &pages->dmabuf);
 
@@ -896,12 +903,13 @@ int mvx_mmu_pages_append_dma_buf(struct mvx_mmu_pages *pages,
 	if (ret != 0)
 		goto unmap;
 
-	mbuf = devm_kzalloc(pages->dev, sizeof(*mbuf), GFP_KERNEL);
+        mbuf = vmalloc(sizeof(*mbuf));
 	if (mbuf == NULL) {
 		ret = -ENOMEM;
 		goto unmap;
 	}
 
+        memset(mbuf, 0, sizeof(*mbuf));
 	mbuf->dmabuf = dmabuf;
 	list_add_tail(&mbuf->head, &pages->dmabuf);
 
@@ -976,10 +984,10 @@ void mvx_mmu_free_pages(struct mvx_mmu_pages *pages)
 
 	list_for_each_entry_safe(mbuf, tmp, &pages->dmabuf, head) {
 		dma_buf_put(mbuf->dmabuf);
-		devm_kfree(pages->dev, mbuf);
+                vfree(mbuf);
 	}
 
-	devm_kfree(pages->dev, pages);
+        vfree(pages);
 }
 
 size_t mvx_mmu_size_pages(struct mvx_mmu_pages *pages)
diff --git a/drivers/media/vpu/if/mvx_mmu.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_mmu.h
similarity index 100%
rename from drivers/media/vpu/if/mvx_mmu.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_mmu.h
diff --git a/drivers/media/vpu/if/mvx_secure.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_secure.c
similarity index 95%
rename from drivers/media/vpu/if/mvx_secure.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_secure.c
index c9abc98f7e23..9199d0f7703b 100755
--- a/drivers/media/vpu/if/mvx_secure.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_secure.c
@@ -81,17 +81,20 @@ int mvx_secure_construct(struct mvx_secure *secure,
 			 struct device *dev)
 {
 	secure->dev = dev;
+#ifndef MODULE
 	secure->kset = kset_create_and_add("securevideo", NULL, &dev->kobj);
 	if (secure->kset == NULL) {
 		MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_WARNING,
 			      "Failed to create securevideo kset.");
 		return -EINVAL;
 	}
-
+#endif
 	secure->workqueue = alloc_workqueue("mvx_securevideo",
 					    WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
 	if (secure->workqueue == NULL) {
+#ifndef MODULE
 		kset_unregister(secure->kset);
+#endif
 		return -EINVAL;
 	}
 
@@ -101,7 +104,9 @@ int mvx_secure_construct(struct mvx_secure *secure,
 void mvx_secure_destruct(struct mvx_secure *secure)
 {
 	destroy_workqueue(secure->workqueue);
+#ifndef MODULE
 	kset_unregister(secure->kset);
+#endif
 }
 
 /****************************************************************************
@@ -204,10 +209,19 @@ static struct mvx_secure_firmware_priv *secure_firmware_create(
 		&attr.attr,
 		NULL
 	};
+	static const struct attribute_group secure_group = {
+        .name = "",
+        .attrs = attrs
+    };
+
+    static const struct attribute_group *secure_groups[] = {
+        &secure_group,
+        NULL
+    };
 	static struct kobj_type secure_ktype = {
 		.sysfs_ops     = &kobj_sysfs_ops,
 		.release       = secure_firmware_release,
-		//.default_attrs = attrs
+		.default_groups = secure_groups
 	};
 	struct mvx_secure_firmware_priv *securefw;
 	char numcores_env[32];
@@ -342,10 +356,19 @@ struct dma_buf *mvx_secure_mem_alloc(struct mvx_secure *secure,
 		&attr.attr,
 		NULL
 	};
+	static const struct attribute_group secure_mem_group = {
+        .name = "",
+        .attrs = attrs
+    };
+
+    static const struct attribute_group *secure_mem_groups[] = {
+        &secure_mem_group,
+        NULL
+    };
 	static struct kobj_type secure_mem_ktype = {
 		.release       = secure_mem_release,
 		.sysfs_ops     = &kobj_sysfs_ops,
-		//.default_attrs = attrs
+		.default_groups = secure_mem_groups
 	};
 	struct mvx_secure_mem *smem;
 	char size_env[32];
diff --git a/drivers/media/vpu/if/mvx_secure.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_secure.h
similarity index 100%
rename from drivers/media/vpu/if/mvx_secure.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_secure.h
diff --git a/drivers/media/vpu/if/mvx_session.c b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.c
similarity index 83%
rename from drivers/media/vpu/if/mvx_session.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.c
index 6495ef586e48..aa6a69af4ed3 100755
--- a/drivers/media/vpu/if/mvx_session.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -47,12 +47,17 @@
 #include "mvx_firmware_cache.h"
 #include "mvx_session.h"
 #include "mvx_seq.h"
+#include "mvx_dvfs.h"
+#include "mvx_v4l2_session.h"
 
 /****************************************************************************
  * Private variables
  ****************************************************************************/
 
-static int session_watchdog_timeout = 30000;
+int session_wait_pending_timeout = 10000;  //10s
+int session_wait_flush_timeout = 2000;   //2s
+
+int session_watchdog_timeout = 30000;   //30s
 module_param(session_watchdog_timeout, int, 0660);
 
 static int fw_watchdog_timeout;
@@ -81,8 +86,6 @@ static void watchdog_start(struct mvx_session *session,
 		return;
 	}
 
-	session->watchdog_count = 0;
-
 	kref_get(&session->isession.kref);
 }
 
@@ -94,6 +97,7 @@ static void watchdog_stop(struct mvx_session *session)
 
 	/* ret: 0=watchdog expired, 1=watchdog still running */
 	MVX_SESSION_DEBUG(session, "Watchdog stop. ret=%d", ret);
+	session->watchdog_count = 0;
 
 	/* Decrement the kref if the watchdog was still running. */
 	if (ret != 0)
@@ -105,10 +109,14 @@ static void watchdog_update(struct mvx_session *session,
 {
 	int ret;
 
+#ifndef MODULE
 	ret = mod_timer_pending(&session->watchdog_timer,
 				jiffies + msecs_to_jiffies(timeout_ms));
-
-	session->watchdog_count = 0;
+#else
+	if (timer_pending(&session->watchdog_timer))
+		ret = mod_timer(&session->watchdog_timer,
+				jiffies + msecs_to_jiffies(timeout_ms));
+#endif
 
 	/* ret: 0=no restart, 1=restarted */
 	MVX_SESSION_DEBUG(session, "Watchdog update. ret=%d, timeout_ms=%u.",
@@ -143,6 +151,7 @@ static void send_event_error(struct mvx_session *session,
 static void session_unregister(struct mvx_session *session)
 {
 	if (!IS_ERR_OR_NULL(session->csession)) {
+		mvx_dvfs_unregister_session(session);
 		session->client_ops->unregister_session(session->csession);
 		session->csession = NULL;
 	}
@@ -153,6 +162,14 @@ static void release_fw_bin(struct mvx_session *session)
 	if (is_fw_loaded(session) != false) {
 		MVX_SESSION_INFO(session, "Release firmware binary.");
 
+        if (session->switched_in == true) {
+            if (IS_ERR_OR_NULL(session->csession)) {
+                MVX_SESSION_WARN(session, "release_fw_bin. csession is null. mvx_session:%p", session);
+            } else {
+                session->client_ops->wait_session_idle(session->csession);
+            }
+        }
+
 		mvx_fw_destruct(&session->fw);
 		mvx_fw_cache_put(session->cache, session->fw_bin);
 		session->fw_bin = NULL;
@@ -214,43 +231,103 @@ static bool is_stream_on(struct mvx_session *session)
  */
 static int wait_pending(struct mvx_session *session)
 {
-	int ret = 0;
+    int ret = 0;
+    int count = 0;
+    struct timespec64 curtime;
+    uint64_t timestart;
+    uint64_t timeend;
+
+    while (is_fw_loaded(session) != false &&
+            session->fw.msg_pending > 0 &&
+            session->error == 0) {
+        mutex_unlock(session->isession.mutex);
+
+        count++;
+        ktime_get_boottime_ts64(&curtime);
+        timestart = curtime.tv_sec*1000*1000l + curtime.tv_nsec/1000l;
+
+        ret = wait_event_timeout(
+                session->waitq,
+                is_fw_loaded(session) == false ||
+                session->fw.msg_pending == 0 ||
+                session->error != 0,
+                msecs_to_jiffies(session->watchdog_timeout*2));
+
+        ktime_get_boottime_ts64(&curtime);
+        timeend = curtime.tv_sec*1000*1000l + curtime.tv_nsec/1000l;
+        if (timeend - timestart >= 10000000l) {
+            MVX_SESSION_WARN(session, "wait_pending cost time is greater than 10 secs. cost_time=%llu us, ret=%d, error=%d, msg_pending=%d, in_fmt=%d, out_fmt=%d", timeend - timestart, ret, session->error, session->fw.msg_pending, session->port[MVX_DIR_INPUT].format, session->port[MVX_DIR_OUTPUT].format);
+        }
 
-	while (is_fw_loaded(session) != false &&
-	       session->fw.msg_pending > 0 &&
-	       session->error == 0) {
-		mutex_unlock(session->isession.mutex);
+        if (ret < 0)
+            goto lock_mutex;
 
-		ret = wait_event_timeout(
-			session->waitq,
-			is_fw_loaded(session) == false ||
-			session->fw.msg_pending == 0 ||
-			session->error != 0,
-			msecs_to_jiffies(10000));
+        if (ret == 0) {
+            send_event_error(session, -ETIME);
+            ret = -ETIME;
+            goto lock_mutex;
+        }
 
-		if (ret < 0)
-			goto lock_mutex;
+        mutex_lock(session->isession.mutex);
+    }
 
-		if (ret == 0) {
-			send_event_error(session, -ETIME);
-			ret = -ETIME;
-			goto lock_mutex;
-		}
+    return session->error;
 
-		mutex_lock(session->isession.mutex);
-	}
+lock_mutex:
+    mutex_lock(session->isession.mutex);
 
-	return session->error;
+    if (ret < 0) {
+        MVX_SESSION_WARN(session,
+                "Wait pending returned error. ret=%d, error=%d, msg_pending=%d.",
+                ret, session->error, session->fw.msg_pending);
+
+        print_debug(session);
+    }
+    return ret;
+}
+
+static int wait_flush_done(struct mvx_session *session, enum mvx_direction dir)
+{
+    int ret = 0;
+    struct mvx_session_port *port = &session->port[dir];
+
+    while (is_fw_loaded(session) != false &&
+            port->buffer_count > 0 &&
+            session->error == 0) {
+        mutex_unlock(session->isession.mutex);
+
+        ret = wait_event_timeout(
+                session->waitq,
+                is_fw_loaded(session) == false ||
+                port->buffer_count == 0 ||
+                session->error != 0,
+                msecs_to_jiffies(session_wait_flush_timeout));
+
+        if (ret < 0)
+            goto lock_mutex;
+
+        if (ret == 0) {
+            send_event_error(session, -ETIME);
+            ret = -ETIME;
+            goto lock_mutex;
+        }
+
+        mutex_lock(session->isession.mutex);
+    }
+
+    return session->error;
 
 lock_mutex:
-	mutex_lock(session->isession.mutex);
+    mutex_lock(session->isession.mutex);
 
-	if (ret < 0)
-		MVX_SESSION_WARN(session,
-				 "Wait pending returned error. ret=%d, error=%d, msg_pending=%d.",
-				 ret, session->error, session->fw.msg_pending);
+    if (ret < 0) {
+        MVX_SESSION_WARN(session,
+                "wait_flush_done returned error. ret=%d, error=%d, msg_pending=%d, buffer_count=%d",
+                ret, session->error, session->fw.msg_pending, port->buffer_count);
 
-	return ret;
+        print_debug(session);
+    }
+    return ret;
 }
 
 static int send_irq(struct mvx_session *session)
@@ -275,6 +352,9 @@ static int switch_in(struct mvx_session *session)
 	if (session->switched_in != false)
 		return 0;
 
+	if (IS_ERR_OR_NULL(session->csession))
+		return -EINVAL;
+
 	MVX_SESSION_INFO(session, "Switch in.");
 
 	ret = session->client_ops->switch_in(session->csession);
@@ -315,7 +395,7 @@ static int fw_send_msg(struct mvx_session *session,
 		goto send_error;
 	}
 
-	return switch_in(session);
+    return switch_in(session);
 
 send_error:
 	send_event_error(session, ret);
@@ -410,6 +490,7 @@ static int fw_dump(struct mvx_session *session)
 	return fw_send_msg_simple(session, MVX_FW_CODE_DUMP, "Dump");
 }
 
+#ifdef MVX_FW_DEBUG_ENABLE
 static int fw_set_debug(struct mvx_session *session, uint32_t debug_level)
 {
 	struct mvx_fw_msg msg = {
@@ -421,6 +502,7 @@ static int fw_set_debug(struct mvx_session *session, uint32_t debug_level)
 
 	return fw_send_msg(session, &msg);
 }
+#endif
 
 static int fw_set_option(struct mvx_session *session,
 			 struct mvx_fw_set_option *option)
@@ -517,6 +599,13 @@ static int fw_common_setup(struct mvx_session *session)
 {
 	int ret = 0;
 	struct mvx_fw_set_option option;
+	enum mvx_direction dir = get_bitstream_port(session);
+
+	if ((session->port[dir].format == MVX_FORMAT_VP8
+		|| session->port[dir].format == MVX_FORMAT_VP9)
+		&& session->nalu_format != MVX_NALU_FORMAT_ONE_NALU_PER_BUFFER) {
+		session->nalu_format = MVX_NALU_FORMAT_UNDEFINED;
+	}
 
 	if (session->nalu_format != MVX_NALU_FORMAT_UNDEFINED) {
 		option.code = MVX_FW_SET_NALU_FORMAT;
@@ -540,6 +629,20 @@ static int fw_common_setup(struct mvx_session *session)
 		}
 	}
 
+    if (session->enable_profiling) {
+        MVX_SESSION_WARN(session, "[Debug]set MVX_FW_SET_INDEX_PROFILING to read profiling data.");
+        session->bus_read_bytes_total = 0;
+        session->bus_write_bytes_total = 0;
+        option.code = MVX_FW_SET_INDEX_PROFILING;
+        option.index_profiling = 1;
+        ret = fw_set_option(session, &option);
+        if (ret != 0) {
+            MVX_SESSION_WARN(session,
+                    "Failed to set set index profiling");
+            return ret;
+        }
+    }
+
 	return ret;
 }
 
@@ -659,7 +762,7 @@ static int fw_encoder_setup(struct mvx_session *session)
 				return ret;
 		}
 
-		if (session->p_frames != 0) {
+		if (session->p_frames >= 0) {
 			option.code = MVX_FW_SET_P_FRAMES;
 			option.pb_frames = session->p_frames;
 			ret = fw_set_option(session, &option);
@@ -893,7 +996,7 @@ static int fw_encoder_setup(struct mvx_session *session)
 	}
 
 	if (codec == MVX_FORMAT_VP9) {
-		MVX_SESSION_WARN(session, "VP9 option!");
+		MVX_SESSION_INFO(session, "VP9 option!");
 		option.code = MVX_FW_SET_VP9_PROB_UPDATE;
 		option.vp9_prob_update = session->vp9_prob_update;
 		ret = fw_set_option(session, &option);
@@ -943,6 +1046,15 @@ static int fw_encoder_setup(struct mvx_session *session)
 
 	if (mvx_is_rgb(session->port[MVX_DIR_INPUT].format) != false) {
 		option.code = MVX_FW_SET_RGB_TO_YUV_MODE;
+		if (session->color_desc.primaries == MVX_FW_PRIMARIES_BT709)
+		{
+		    session->rgb_to_yuv = (session->color_desc.range == MVX_FW_RANGE_FULL)?MVX_RGB_TO_YUV_MODE_BT709_FULL:MVX_RGB_TO_YUV_MODE_BT709_STUDIO;
+		}
+		else if ((session->color_desc.primaries == MVX_FW_PRIMARIES_BT601_625) ||
+		    (session->color_desc.primaries == MVX_FW_PRIMARIES_BT601_525))
+		{
+		    session->rgb_to_yuv = (session->color_desc.range == MVX_FW_RANGE_FULL)?MVX_RGB_TO_YUV_MODE_BT601_FULL:MVX_RGB_TO_YUV_MODE_BT601_STUDIO;
+		}
 		option.rgb_to_yuv_mode = session->rgb_to_yuv;
 		ret = fw_set_option(session, &option);
 		if (ret != 0) {
@@ -1094,7 +1206,9 @@ static int fw_initial_setup(struct mvx_session *session)
 
 	MVX_SESSION_INFO(session, "Firmware initial setup.");
 
+#ifdef MVX_FW_DEBUG_ENABLE
 	fw_set_debug(session, 5);
+#endif
 
 	option.code = MVX_FW_SET_WATCHDOG_TIMEOUT;
 	option.watchdog_timeout = fw_watchdog_timeout;
@@ -1136,6 +1250,32 @@ static int fw_initial_setup(struct mvx_session *session)
 	return ret;
 }
 
+static void ddr_qos_request_update(struct mvx_session *session)
+{
+    struct estimate_ddr_input ddr_input;
+    //struct estimate_ddr_output ddr_output;
+
+    ddr_input.isEnc = is_encoder(session);
+    ddr_input.fps = session->frame_rate >> 16;
+
+    if (ddr_input.isEnc) {
+        ddr_input.isAFBC = mvx_is_afbc(session->port[MVX_DIR_INPUT].format);
+        ddr_input.width = session->port[MVX_DIR_INPUT].width;
+        ddr_input.height = session->port[MVX_DIR_INPUT].height;
+    } else {
+        ddr_input.isAFBC = mvx_is_afbc(session->port[MVX_DIR_OUTPUT].format);
+        ddr_input.width = session->port[MVX_DIR_OUTPUT].width;
+        ddr_input.height = session->port[MVX_DIR_OUTPUT].height;
+    }
+
+    //mvx_dvfs_estimate_ddr_bandwidth(&ddr_input, &ddr_output);
+
+    //session->estimated_ddr_read_throughput = (uint32_t)ddr_output.estimated_read;
+    //session->estimated_ddr_write_throughput = (uint32_t)ddr_output.estimated_write;
+
+    //mvx_dvfs_session_update_ddr_qos(session, session->estimated_ddr_read_throughput, session->estimated_ddr_write_throughput);
+}
+
 /**
  * map_buffer() - Memory map buffer to MVE address space.
  *
@@ -1204,6 +1344,7 @@ static int queue_buffer(struct mvx_session *session,
 {
 	struct mvx_session_port *port = &session->port[dir];
 	struct mvx_fw_msg msg;
+       int i;
 
 	/*
 	 * Vb2 cannot allocate buffers with bidirectional mapping, therefore
@@ -1213,6 +1354,7 @@ static int queue_buffer(struct mvx_session *session,
 		(dir == MVX_DIR_OUTPUT) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
 
 	int ret;
+       bool mapped = mvx_buffer_is_mapped(buf);
 
 	if (dir == MVX_DIR_OUTPUT) {
 		port->scaling_shift = (buf->flags & MVX_BUFFER_FRAME_FLAG_SCALING_MASK) >> 14;
@@ -1222,10 +1364,26 @@ static int queue_buffer(struct mvx_session *session,
 		if (ret != 0)
 			return ret;
 	}
+    buf->flags &= ~MVX_BUFFER_FRAME_NEED_REALLOC;
+
+    if (dir == MVX_DIR_OUTPUT && port->isreallocting == true) {
+        buf->flags |= MVX_BUFFER_FRAME_NEED_REALLOC;
+        return -EAGAIN;
+    }
+
     if (dir == MVX_DIR_OUTPUT && port->buffer_allocated < port->buffer_min) {
         buf->flags |= MVX_BUFFER_FRAME_NEED_REALLOC;
         return -EAGAIN;
     }
+
+    if (dir == MVX_DIR_INPUT && (buf->flags & MVX_BUFFER_EOS) != 0) {
+        session->eos_queued = true;
+    }
+
+    if (dir == MVX_DIR_OUTPUT) {
+        session->keep_freq_high = false;
+    }
+
 	/*
 	 * Update frame dimensions. They might have changed due to a resolution
 	 * change.
@@ -1244,10 +1402,16 @@ static int queue_buffer(struct mvx_session *session,
 					   port->interlaced);
 		if (ret != 0)
 			return ret;
-
 	}
 
-	ret = mvx_buffer_synch(buf, dma_dir);
+	if (mapped && (dir == MVX_DIR_OUTPUT))
+        {
+            /*no need to do cache invalidate each time for output buffer,
+	      only invalidate cache when buffer is mapped  */
+        }
+        else
+            ret = mvx_buffer_synch(buf, dma_dir);
+
 	if (ret != 0)
 		return ret;
 
@@ -1269,6 +1433,14 @@ static int queue_buffer(struct mvx_session *session,
 		goto send_error;
 
 	port->buffer_count++;
+
+    if (dir == MVX_DIR_OUTPUT && mvx_is_frame(buf->format)) {
+        for (i = 0; i < buf->nplanes; i++) {
+            if (port->buffer_size[i] == 0)
+                port->buffer_size[i] = mvx_buffer_size(buf, i);
+        }
+    }
+
 	port->flushed = false;
     if (dir == MVX_DIR_OUTPUT && port->isreallocting == true) {
         port->isreallocting = false;
@@ -1383,6 +1555,9 @@ static void fw_bin_ready(struct mvx_fw_bin *bin,
 
 	session->csession = session->client_ops->register_session(
 		session->client_ops, &session->isession);
+
+        mvx_dvfs_register_session(session, is_encoder(session));
+
 	if (IS_ERR(session->csession)) {
 		ret = PTR_ERR(session->csession);
 		send_event_error(session, ret);
@@ -1423,6 +1598,7 @@ static void fw_bin_ready(struct mvx_fw_bin *bin,
 	return;
 
 unregister_csession:
+	mvx_dvfs_unregister_session(session);
 	session->client_ops->unregister_session(session->csession);
 	session->csession = NULL;
 
@@ -1515,6 +1691,8 @@ static int try_format(struct mvx_session *session,
 	int ret = 0;
 
 	/* Limit width and height to 8k. */
+	if (*width == ((unsigned int) (-1))) *width = 0;
+       if (*height == ((unsigned int) (-1))) *height = 0;
 	*width = min_t(unsigned int, *width, 8192);
 	*height = min_t(unsigned int, *height, 8192);
 
@@ -1598,14 +1776,15 @@ static void watchdog_work(struct work_struct *work)
 	int ret;
 
 	mutex_lock(session->isession.mutex);
+	session->watchdog_count++;
 
-	MVX_SESSION_WARN(session, "Watchdog timeout. count=%u.",
-			 session->watchdog_count);
+	MVX_SESSION_WARN(session, "Watchdog timeout. count=%u. is_encoder=%d. in_fmt=%d, out_fmt=%d",
+			 session->watchdog_count, is_encoder(session), session->port[MVX_DIR_INPUT].format, session->port[MVX_DIR_OUTPUT].format);
 
 	/* Print debug information. */
 	print_debug(session);
 
-	if (session->watchdog_count++ < 2) {
+	if (session->watchdog_count == 1) {
 		/* Request firmware to dump its state. */
 		fw_dump(session);
 
@@ -1675,6 +1854,8 @@ int mvx_session_construct(struct mvx_session *session,
 	session->dentry = dentry;
 	session->port[MVX_DIR_INPUT].buffer_min = 1;
 	session->port[MVX_DIR_OUTPUT].buffer_min = 1;
+        session->port[MVX_DIR_OUTPUT].seq_param.afbc.buffers_min = 1;
+        session->port[MVX_DIR_OUTPUT].seq_param.planar.buffers_min = 1;
     session->port[MVX_DIR_INPUT].buffer_allocated = 1;
     session->port[MVX_DIR_OUTPUT].buffer_allocated = 1;
 	session->port[MVX_DIR_INPUT].scaling_shift = 0;
@@ -1697,7 +1878,24 @@ int mvx_session_construct(struct mvx_session *session,
     session->dsl_ratio.hor = 1;
     session->dsl_ratio.ver = 1;
     session->dsl_pos_mode = -1;//disable by default
+    session->estimated_ddr_read_throughput = 0;
+    session->estimated_ddr_write_throughput = 0;
+    session->port[MVX_DIR_OUTPUT].buffer_on_hold_count = 0;
+    session->port[MVX_DIR_OUTPUT].pending_buffer_on_hold_count = 0;
+    session->port[MVX_DIR_OUTPUT].isallocparam = false;
+    session->eos_queued = false;
+    session->keep_freq_high = true;
+    session->is_suspend = false;
+    for (i = 0; i < MVX_BUFFER_NPLANES; i++) {
+        session->port[MVX_DIR_OUTPUT].buffer_size[i] = 0;
+    }
+    session->port[MVX_DIR_OUTPUT].buffer_count = 0;
+    session->port[MVX_DIR_INPUT].buffer_count = 0;
+    session->watchdog_count = 0;
+    session->watchdog_timeout = session_watchdog_timeout;
+    session->frame_id = 0;
 
+    INIT_LIST_HEAD(&session->buffer_corrupt_queue);
 	ret = mvx_mmu_construct(&session->mmu, session->dev);
 	if (ret != 0)
 		return ret;
@@ -1719,11 +1917,22 @@ int mvx_session_construct(struct mvx_session *session,
 void mvx_session_destruct(struct mvx_session *session)
 {
 	/* Destruct the session object. */
+	struct mvx_corrupt_buffer* corrupt_buf;
+	struct mvx_corrupt_buffer* tmp;
+
+    if (session->enable_profiling && session->frame_id > 0) {
+        MVX_SESSION_WARN(session, "[Debug] Destroy session. is_encoder=%d, frame_count=%d", is_encoder(session), session->frame_id);
+        MVX_SESSION_WARN(session, "[Debug] bus_write_bytes_total=%lu. bus_read_bytes_total=%lu. avg_write_bw=%lu, avg_read_bw=%lu, 30fps_write_bw=%lu, 30fps_read_bw=%lu", session->bus_write_bytes_total, session->bus_read_bytes_total, session->bus_write_bytes_total/session->frame_id, session->bus_read_bytes_total/session->frame_id, session->bus_write_bytes_total/session->frame_id * 30, session->bus_read_bytes_total/session->frame_id * 30);
+    }
 
 	MVX_SESSION_INFO(session, "Destroy session.");
 
 	release_fw_bin(session);
 	mvx_mmu_destruct(&session->mmu);
+	list_for_each_entry_safe(corrupt_buf, tmp, &session->buffer_corrupt_queue, head) {
+		list_del(&corrupt_buf->head);
+		vfree(corrupt_buf);
+	}
 }
 
 void mvx_session_get(struct mvx_session *session)
@@ -1824,6 +2033,14 @@ int mvx_session_set_format(struct mvx_session *session,
 				 &p->interlaced);
 	}
 
+        if (dir == MVX_DIR_OUTPUT) {
+            if (mvx_is_afbc(port->format)) {
+                port->buffer_min = port->seq_param.afbc.buffers_min;
+            } else {
+                port->buffer_min = port->seq_param.planar.buffers_min;
+            }
+        }
+
 	return 0;
 }
 
@@ -1890,6 +2107,11 @@ int mvx_session_streamon(struct mvx_session *session,
 
 	MVX_SESSION_INFO(session, "Stream on. dir=%u.", dir);
 
+    if (dir == MVX_DIR_OUTPUT && session->port[dir].isallocparam == true) {
+        session->port[dir].isallocparam = false;
+        session->port[dir].isreallocting = false;
+    }
+
 	/* Verify that we don't enable an already activated port. */
 	if (session->port[dir].stream_on != false)
 		return 0;
@@ -1900,6 +2122,8 @@ int mvx_session_streamon(struct mvx_session *session,
 	if (!is_stream_on(session))
 		return 0;
 
+        ddr_qos_request_update(session);
+
 	/* Verify that a firmware binary load is not in progress. */
 	if (IS_ERR(session->fw_bin)) {
 		ret = PTR_ERR(session->fw_bin);
@@ -1973,12 +2197,15 @@ int mvx_session_streamon(struct mvx_session *session,
 int mvx_session_streamoff(struct mvx_session *session,
 			  enum mvx_direction dir)
 {
-	struct mvx_session_port *port = &session->port[dir];
-	struct mvx_buffer *buf;
-	struct mvx_buffer *tmp;
-	int ret = 0;
+    struct mvx_session_port *port = &session->port[dir];
+    struct mvx_session_port *port_input = &session->port[MVX_DIR_INPUT];
+    struct mvx_buffer *buf;
+    struct mvx_buffer *tmp;
+    bool force_stop = (dir == MVX_DIR_OUTPUT && port_input->stream_on == false) ? 1 : 0;
+    int ret = 0;
+    int i;
 
-	MVX_SESSION_INFO(session, "Stream off. dir=%u.", dir);
+	MVX_SESSION_INFO(session, "Stream off. dir=%u, flushed=%d, is_flushing=%d, isreallocting=%d, isallocparam=%d, force_stop=%d", dir,port->flushed,port->is_flushing,port->isreallocting,port->isallocparam,force_stop);
 
 	port->stream_on = false;
 
@@ -1987,18 +2214,24 @@ int mvx_session_streamoff(struct mvx_session *session,
 		 * Flush the ports if at least one buffer has been queued
 		 * since last flush.
 		 */
-		if (port->flushed == false && port->is_flushing == false) {
+		/* workaround for fw issue: It won't flush output buffer when STOP output stream
+		 * if flushed flag is true. It will result in no frame buffer output for seek operations.
+		 * Now force to flush output buffer if input stream is off.
+		 */
+
+		if ((port->flushed == false && port->is_flushing == false) || force_stop) {
 			ret = wait_pending(session);
 			if (ret != 0)
 				goto dequeue_buffers;
-            if (!(dir == MVX_DIR_OUTPUT && port->isreallocting == true)) {
+            if (!(dir == MVX_DIR_OUTPUT && port->isreallocting == true) || force_stop) {
     			ret = fw_state_change(session, MVX_FW_STATE_STOPPED);
     			if (ret != 0)
     				goto dequeue_buffers;
 
     			ret = fw_flush(session, dir);
-    			if (ret != 0)
+    			if (ret != 0) {
     				goto dequeue_buffers;
+    			}
             }
 			ret = wait_pending(session);
 			if (ret != 0)
@@ -2006,6 +2239,14 @@ int mvx_session_streamoff(struct mvx_session *session,
 
 			send_irq(session);
 		}
+        if (dir == MVX_DIR_OUTPUT && port->isallocparam == true) {
+            wait_flush_done(session, dir);
+            for (i = 0; i < MVX_BUFFER_NPLANES; i++)
+                session->port[MVX_DIR_OUTPUT].buffer_size[i] = 0;
+        }
+        if (session->fw_state == MVX_FW_STATE_STOPPED) {
+            fw_switch_out(session);
+        }
     }
 dequeue_buffers:
 	if (ret != 0)
@@ -2024,10 +2265,11 @@ static void handle_fw_message(struct mvx_session *session,
 			      struct mvx_fw_msg *msg)
 {
 	switch (msg->code) {
-	case MVX_FW_CODE_ALLOC_PARAM: {
-		struct mvx_session_port *input = &session->port[MVX_DIR_INPUT];
-		struct mvx_session_port *output =
-			&session->port[MVX_DIR_OUTPUT];
+       case MVX_FW_CODE_ALLOC_PARAM: {
+           struct mvx_session_port *input = &session->port[MVX_DIR_INPUT];
+           struct mvx_session_port *output = &session->port[MVX_DIR_OUTPUT];
+           unsigned int old_stride[MVX_BUFFER_NPLANES];
+
 		/* Update input port. */
 		input->width = msg->alloc_param.width;
 		input->height = msg->alloc_param.height;
@@ -2042,8 +2284,12 @@ static void handle_fw_message(struct mvx_session *session,
 		 */
 
 		output->nplanes = 0;
-		output->afbc_alloc_bytes = msg->alloc_param.afbc_alloc_bytes;
-		output->afbc_width = msg->alloc_param.afbc_width;
+        output->afbc_alloc_bytes = msg->alloc_param.afbc_alloc_bytes;
+        output->afbc_width = msg->alloc_param.afbc_width;
+        old_stride[0] = output->stride[0];
+        old_stride[1] = output->stride[1];
+        old_stride[2] = output->stride[2];
+
 		try_format(session, MVX_DIR_OUTPUT, output->format,
 			   &output->width, &output->height, &output->nplanes,
 			   output->stride, output->size,
@@ -2061,8 +2307,20 @@ static void handle_fw_message(struct mvx_session *session,
 				 output->stride[1],
 				 output->stride[2],
 				 output->interlaced);
-		session->event(session, MVX_SESSION_EVENT_PORT_CHANGED,
-						(void *)MVX_DIR_OUTPUT);
+
+		//update ddr qos for decoder output size changed.
+        ddr_qos_request_update(session);
+
+        if (output->size[0] > output->buffer_size[0] ||
+                output->size[1] > output->buffer_size[1] ||
+                output->size[2] > output->buffer_size[2]) {
+            output->isreallocting = true;
+        } else {
+            // don't update strides for some vp9 cases. gralloc buffer stride is fixed if no realloc.
+            output->stride[0] = old_stride[0];
+            output->stride[1] = old_stride[1];
+            output->stride[2] = old_stride[2];
+        }
 		break;
 	}
     case MVX_FW_CODE_BUFFER_GENERAL: {
@@ -2075,6 +2333,8 @@ static void handle_fw_message(struct mvx_session *session,
 		struct mvx_buffer *buf = msg->buf;
         struct mvx_session_port *output =
 			&session->port[MVX_DIR_OUTPUT];
+        struct mvx_v4l2_session *vsession =
+               container_of(session, struct mvx_v4l2_session, session);
 		MVX_SESSION_INFO(session,
 				 "Firmware rsp: Buffer. dir=%u, len=[%u, %u, %u], flags=0x%08x, eos=%u",
 				 buf->dir,
@@ -2086,6 +2346,10 @@ static void handle_fw_message(struct mvx_session *session,
 
 		session->port[buf->dir].buffer_count--;
 
+       if (buf->dir == MVX_DIR_OUTPUT && (buf->flags & MVX_BUFFER_EOS) != 0)	{
+           session->eos_queued = false;
+       }
+
 		/*
 		 * There is no point to flush or invalidate input buffer
 		 * after it was returned from the HW.
@@ -2101,9 +2365,14 @@ static void handle_fw_message(struct mvx_session *session,
                 }
             }
         }
-		if (buf->dir == MVX_DIR_OUTPUT)
+
+		if (buf->dir == MVX_DIR_OUTPUT && vsession->port[MVX_DIR_OUTPUT].q_set == true)
 			mvx_buffer_synch(buf, DMA_FROM_DEVICE);
 
+		if (buf->dir == MVX_DIR_OUTPUT && !is_encoder(session)) {
+                       session->port[MVX_DIR_OUTPUT].buffer_on_hold_count = session->port[MVX_DIR_OUTPUT].pending_buffer_on_hold_count;
+		}
+
 		session->event(session, MVX_SESSION_EVENT_BUFFER, buf);
 		break;
 	}
@@ -2118,6 +2387,8 @@ static void handle_fw_message(struct mvx_session *session,
 		MVX_SESSION_WARN(session,
 				 "Firmware rsp: Error. code=%u, message=%s.",
 				 msg->error.error_code, msg->error.message);
+		print_debug(session);
+		fw_dump(session);
 
 		/*
 		 * Release the dev session. It will prevent a dead session from
@@ -2178,8 +2449,13 @@ static void handle_fw_message(struct mvx_session *session,
 			p->buffer_min = msg->seq_param.afbc.buffers_min;
 		else
 			p->buffer_min = msg->seq_param.planar.buffers_min;
+                p->seq_param = msg->seq_param;
 
 		(void)fw_flush(session, MVX_DIR_OUTPUT);
+
+        //force to realloc if received seq_param message for it will flush output buffer.
+        p->isreallocting = true;
+
 		break;
 	}
 	case MVX_FW_CODE_SET_OPTION: {
@@ -2195,7 +2471,7 @@ static void handle_fw_message(struct mvx_session *session,
 		break;
 	}
 	case MVX_FW_CODE_SWITCH_IN: {
-		watchdog_start(session, session_watchdog_timeout);
+		watchdog_start(session, session->watchdog_timeout);
 		break;
 	}
 	case MVX_FW_CODE_SWITCH_OUT: {
@@ -2204,9 +2480,9 @@ static void handle_fw_message(struct mvx_session *session,
 		watchdog_stop(session);
 		session->switched_in = false;
 
-		if ((session->fw_state == MVX_FW_STATE_RUNNING &&
+		if (session->is_suspend == false && ((session->fw_state == MVX_FW_STATE_RUNNING &&
 		     session->idle_count < 2) ||
-		    session->fw.msg_pending > 0)
+		    session->fw.msg_pending > 0))
 			switch_in(session);
 
 		break;
@@ -2219,6 +2495,10 @@ static void handle_fw_message(struct mvx_session *session,
 		print_debug(session);
 		break;
 	}
+	case MVX_FW_CODE_DPB_HELD_FRAMES: {
+		session->port[MVX_DIR_OUTPUT].pending_buffer_on_hold_count = msg->arg;
+		break;
+	}
 	case MVX_FW_CODE_MAX:
 		break;
 	default:
@@ -2231,10 +2511,15 @@ void mvx_session_irq(struct mvx_if_session *isession)
 {
 	struct mvx_session *session = mvx_if_session_to_session(isession);
 	int ret;
+	struct mvx_session_port *output = &session->port[MVX_DIR_OUTPUT];
 
 	if (is_fw_loaded(session) == false)
 		return;
 
+	if (IS_ERR_OR_NULL(session->csession)) {
+		return;
+	}
+
 	ret = session->fw.ops.handle_rpc(&session->fw);
 	if (ret < 0) {
 		send_event_error(session, ret);
@@ -2244,7 +2529,7 @@ void mvx_session_irq(struct mvx_if_session *isession)
 	do {
 		struct mvx_fw_msg msg;
 
-		watchdog_update(session, session_watchdog_timeout);
+		watchdog_update(session, session->watchdog_timeout);
 
 		ret = session->fw.ops.get_message(&session->fw, &msg);
 		if (ret < 0) {
@@ -2257,11 +2542,18 @@ void mvx_session_irq(struct mvx_if_session *isession)
 			handle_fw_message(session, &msg);
 	} while (ret > 0 && session->error == 0);
 
+    if (output->isallocparam == false && output->isreallocting == true) {
+        output->isallocparam = true;
+        session->event(session, MVX_SESSION_EVENT_PORT_CHANGED, (void *)MVX_DIR_OUTPUT);
+    }
+
+#ifdef MVX_FW_DEBUG_ENABLE
 	ret = session->fw.ops.handle_fw_ram_print(&session->fw);
 	if (ret < 0) {
 		send_event_error(session, ret);
 		return;
 	}
+#endif
 
 	wake_up(&session->waitq);
 }
@@ -2298,6 +2590,10 @@ int mvx_session_set_frame_rate(struct mvx_session *session,
 	if (session->error != 0)
 		return session->error;
 
+	/*Frame rate values are limited to between 1 and 256 frames per second*/
+	if (frame_rate < (1 << 16)) frame_rate = (1 << 16); /*1 fps*/
+	else if (frame_rate > (256 << 16)) frame_rate = (256 << 16); /*256 fps*/
+
 	if (is_fw_loaded(session) != false) {
 		struct mvx_fw_set_option option;
 
@@ -2308,7 +2604,11 @@ int mvx_session_set_frame_rate(struct mvx_session *session,
 			return ret;
 	}
 
-	session->frame_rate = frame_rate;
+        //update ddr qos for framerate changed.
+        if (frame_rate != session->frame_rate) {
+             session->frame_rate = frame_rate;
+             ddr_qos_request_update(session);
+        }
 
 	return 0;
 }
@@ -2321,6 +2621,8 @@ int mvx_session_set_rate_control(struct mvx_session *session,
 		return session->error;
 
 	session->rc_enabled = enabled;
+	//set default rc type.
+	session->rc_type = enabled?((session->rc_type)?session->rc_type:MVX_OPT_RATE_CONTROL_MODE_STANDARD):0;
 
 	if (is_fw_loaded(session) != false) {
 		struct mvx_fw_set_option option;
@@ -3228,4 +3530,48 @@ int mvx_session_set_dsl_mode(struct mvx_session *session,
 	session->dsl_pos_mode = *mode;
 
 	return 0;
-}
\ No newline at end of file
+}
+int mvx_session_set_force_idr(struct mvx_session *session)
+{
+	int ret;
+	if (session->error != 0)
+		return session->error;
+	if (is_fw_loaded(session) != false) {
+		struct mvx_fw_set_option option;
+		/*reset GOP type to force idr frame.*/
+		option.code = MVX_FW_SET_GOP_RESET;
+		ret = fw_set_option(session, &option);
+		if (ret != 0) {
+			MVX_SESSION_WARN(session,
+					 "Failed to  GOP reset.");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int mvx_session_set_watchdog_timeout(struct mvx_session *session, int timeout)
+{
+    if (session->error != 0)
+        return session->error;
+
+    if (is_fw_loaded(session) != false)
+        return -EBUSY;
+
+    session->watchdog_timeout = timeout*1000;
+
+    return 0;
+}
+
+int mvx_session_set_profiling(struct mvx_session *session, int enable)
+{
+    if (session->error != 0)
+        return session->error;
+
+    if (is_fw_loaded(session) != false)
+        return -EBUSY;
+
+    session->enable_profiling = enable;
+
+    return 0;
+}
diff --git a/drivers/media/vpu/if/mvx_session.h b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.h
similarity index 94%
rename from drivers/media/vpu/if/mvx_session.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.h
index 163a581a64bb..e46d35e0bcfb 100755
--- a/drivers/media/vpu/if/mvx_session.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/mvx_session.h
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 #ifndef _MVX_SESSION_H_
@@ -135,6 +135,16 @@ struct mvx_session_port {
 	unsigned int roi_config_num;
     unsigned int qp_num;
     bool isreallocting;
+    bool isallocparam;
+    struct mvx_fw_seq_param seq_param;
+    uint32_t buffer_on_hold_count;              /**< Number of buffers that the firmware has completed process of,
+                                                 *   but is holding on to for frame reordering. */
+    uint32_t pending_buffer_on_hold_count;      /**< Some FW versions signal the DPB in the form of a message
+                                                 *   that will be valid once the next frame has been returned
+                                                 *   by the FW. In these cases, the new DPB is stored in this
+                                                 *   variable and copied to buffer_on_hold_count once the next
+                                                 *   buffer arrives. */
+    unsigned int buffer_size[MVX_BUFFER_NPLANES];
 };
 
 /**
@@ -297,6 +307,19 @@ struct mvx_session {
     struct mvx_dsl_ratio dsl_ratio;
     struct mvx_long_term_ref mvx_ltr;
     int dsl_pos_mode;
+    /*variable for DDR qos setting. */
+    uint32_t estimated_ddr_read_throughput;    /**<estimated ddr throughput requirement for this session */
+    uint32_t estimated_ddr_write_throughput;    /**<estimated ddr throughput requirement for this session */
+    bool eos_queued;                            /**< Indicates last incoming buffer has EOS flag */
+    bool keep_freq_high;                        /**< Control DVFS by avoiding low frequency at start of usecase */
+    bool is_suspend;
+    struct list_head buffer_corrupt_queue;
+    unsigned int watchdog_timeout;             //timeout value[ms] for watchdog
+    /*for debug. */
+    uint64_t bus_write_bytes_total;
+    uint64_t bus_read_bytes_total;
+    uint64_t frame_id;
+    int enable_profiling;
 };
 
 /****************************************************************************
@@ -1108,4 +1131,14 @@ int mvx_session_set_long_term_ref(struct mvx_session *session,
 
 int mvx_session_set_dsl_mode(struct mvx_session *session,
 			       int *mode);
+
+/*force insert IDR frame.*/
+int mvx_session_set_force_idr(struct mvx_session *session);
+
+/*set timeout value for watchdog*/
+int mvx_session_set_watchdog_timeout(struct mvx_session *session, int timeout);
+
+/*enable/disable profiling for vpu*/
+int mvx_session_set_profiling(struct mvx_session *session, int enable);
+
 #endif /* _MVX_SESSION_H_ */
diff --git a/drivers/media/vpu/if/v4l2/mvx-v4l2-controls.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx-v4l2-controls.h
similarity index 99%
rename from drivers/media/vpu/if/v4l2/mvx-v4l2-controls.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx-v4l2-controls.h
index 658248f09ac4..7fd35b8f1f71 100755
--- a/drivers/media/vpu/if/v4l2/mvx-v4l2-controls.h
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx-v4l2-controls.h
@@ -49,7 +49,7 @@
 #define V4L2_PIX_FMT_YUV422_AFBC_8   v4l2_fourcc('Y', '2', 'A', '8')
 #define V4L2_PIX_FMT_YUV422_AFBC_10  v4l2_fourcc('Y', '2', 'A', 'A')
 #define V4L2_PIX_FMT_Y210            v4l2_fourcc('Y', '2', '1', '0')
-#define V4L2_PIX_FMT_P010            v4l2_fourcc('Y', '0', 'P', '1')
+//#define V4L2_PIX_FMT_P010            v4l2_fourcc('Y', '0', 'P', '1')
 #define V4L2_PIX_FMT_Y0L2            v4l2_fourcc('Y', '0', 'Y', 'L')
 #define V4L2_PIX_FMT_RV              v4l2_fourcc('R', 'V', '0', '0')
 
@@ -370,7 +370,9 @@ enum v4l2_cid_mve_video {
 	V4L2_CID_MVE_VIDEO_CROP_RIGHT,
 	V4L2_CID_MVE_VIDEO_CROP_TOP,
 	V4L2_CID_MVE_VIDEO_CROP_BOTTOM,
-	V4L2_CID_MVE_VIDEO_HRD_BUFFER_SIZE
+	V4L2_CID_MVE_VIDEO_HRD_BUFFER_SIZE,
+	V4L2_CID_MVE_VIDEO_WATCHDOG_TIMEOUT,
+	V4L2_CID_MVE_VIDEO_PROFILING
 };
 
 /* block configuration uncompressed rows header. this configures the size of the
diff --git a/drivers/media/vpu/if/v4l2/mvx_ext_if.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_ext_if.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_ext_if.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_ext_if.h
diff --git a/drivers/media/vpu/if/v4l2/mvx_ext_v4l2.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_ext_v4l2.c
similarity index 91%
rename from drivers/media/vpu/if/v4l2/mvx_ext_v4l2.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_ext_v4l2.c
index cbf644a6d76f..aa83c6933b9c 100755
--- a/drivers/media/vpu/if/v4l2/mvx_ext_v4l2.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_ext_v4l2.c
@@ -62,6 +62,9 @@ static const struct v4l2_file_operations mvx_v4l2_fops = {
 	.release        = mvx_v4l2_release,
 	.poll           = mvx_v4l2_poll,
 	.unlocked_ioctl = video_ioctl2,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = video_ioctl2, /* for mvx_v4l2_vidioc_default() */
+#endif
 	.mmap           = mvx_v4l2_mmap
 };
 
@@ -116,6 +119,7 @@ int mvx_ext_if_construct(struct mvx_ext_if *ext,
 {
 	int ret;
 	const char name[] = "mvx";
+
 	ext->dev = dev;
 	ext->cache = cache;
 	ext->client_ops = client_ops;
@@ -134,17 +138,18 @@ int mvx_ext_if_construct(struct mvx_ext_if *ext,
 		goto delete_dentry;
 	}
 
-	/* Video device. */
-	ext->vdev.fops = &mvx_v4l2_fops;
-	ext->vdev.ioctl_ops = &mvx_v4l2_ioctl_ops;
-	ext->vdev.release = video_device_release_empty;
-	ext->vdev.vfl_dir = VFL_DIR_M2M;
-	ext->vdev.v4l2_dev = &ext->v4l2_dev;
-	ext->vdev.device_caps = V4L2_CAP_VIDEO_M2M |
-			V4L2_CAP_VIDEO_M2M_MPLANE |
-			V4L2_CAP_EXT_PIX_FORMAT |
-			V4L2_CAP_STREAMING;
-	strncpy(ext->vdev.name, name, sizeof(ext->vdev.name));
+        /* Video device. */
+        ext->vdev.fops = &mvx_v4l2_fops;
+        ext->vdev.ioctl_ops = &mvx_v4l2_ioctl_ops;
+        ext->vdev.release = video_device_release_empty;
+        ext->vdev.vfl_dir = VFL_DIR_M2M;
+        ext->vdev.v4l2_dev = &ext->v4l2_dev;
+        ext->vdev.device_caps = V4L2_CAP_VIDEO_M2M |
+            V4L2_CAP_VIDEO_M2M_MPLANE |
+            V4L2_CAP_EXT_PIX_FORMAT |
+            V4L2_CAP_STREAMING;
+        strncpy(ext->vdev.name, name, sizeof(ext->vdev.name));
+
 	video_set_drvdata(&ext->vdev, ext);
 
 	ret = video_register_device(&ext->vdev, VFL_TYPE_VIDEO, -1);
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_buffer.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_buffer.c
similarity index 85%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_buffer.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_buffer.c
index a3010dd57622..7d7903c616e2 100755
--- a/drivers/media/vpu/if/v4l2/mvx_v4l2_buffer.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_buffer.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 #include <linux/debugfs.h>
@@ -68,8 +68,8 @@ static void v4l2_buffer_show(struct mvx_v4l2_buffer *buffer,
 #else
 	mvx_seq_printf(s, "timestamp", ind, "\n");
 	ind++;
-	mvx_seq_printf(s, "tv_sec", ind, "%lu\n", v4l2->timestamp.tv_sec);
-	mvx_seq_printf(s, "tv_usec", ind, "%lu\n", v4l2->timestamp.tv_usec);
+	mvx_seq_printf(s, "tv_sec", ind, "%lu\n", v4l2->vb2_buf.timestamp.tv_sec);
+	mvx_seq_printf(s, "tv_usec", ind, "%lu\n", v4l2->vb2_buf.timestamp.tv_usec);
 	ind--;
 #endif
 	mvx_seq_printf(s, "timecode", ind, "\n");
@@ -272,7 +272,7 @@ static int update_mvx_buffer(struct mvx_v4l2_buffer *vbuf)
 	mvx_buf->user_data = vb2->timestamp;
 #else
 	{
-		struct timeval *ts = &vbuf->vb2_v4l2_buffer.timestamp;
+		struct timeval *ts = &vbuf->vb2_v4l2_buffer.vb2_buf.timestamp;
 
 		mvx_buf->user_data = ((uint64_t)ts->tv_sec << 32) |
 				     (ts->tv_usec & 0xffffffff);
@@ -281,7 +281,28 @@ static int update_mvx_buffer(struct mvx_v4l2_buffer *vbuf)
 
 	for (i = 0; i < vb2->num_planes; i++) {
 		unsigned int offset = vb2->planes[i].data_offset;
-
+                unsigned int filled = vb2->planes[i].bytesused;
+                if (V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == vb2->type &&
+                    vb2->memory == V4L2_MEMORY_DMABUF && offset > 0)
+                {
+                    // TODO(crbug.com/901264): The way to pass an offset within a DMA-buf is not defined
+                    // in V4L2 specification, so we abuse data_offset for now. Fix it when we have the
+                    // right interface, including any necessary validation and potential alignment.
+                    //workaround: for MPLANAR, if using vb2->planes[i].data_offset, bytesused should be
+                    // larger than data_offset, otherwise __verify_length() will fail in vb2_qbuf()
+                    // so 'bytesused - data_offset' is extact filled data size.
+                    filled = (vb2->planes[i].bytesused - offset);
+                }
+                else if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == vb2->type &&
+                    vb2->memory == V4L2_MEMORY_DMABUF && i > 0)
+                {
+                   //'data_offset' is not passed in v4l2-core for buffer type OUTPUT in "vb2_fill_vb2_v4l2_buffer"
+                   //'data_offset' is always 0, so reset plane offset in hard code.
+                    int k;
+                    offset = 0;
+                    for(k=i;k>0;k--)
+                        offset += vb2->planes[i-k].length;
+                }
 		/*
 		 * For single planar mmap buffers the offset is carried by
 		 * the lower part of the offset.
@@ -290,7 +311,7 @@ static int update_mvx_buffer(struct mvx_v4l2_buffer *vbuf)
 			offset += vb2->planes[i].m.offset & ~PAGE_MASK;
 
 		ret = mvx_buffer_filled_set(mvx_buf, i,
-					    vb2->planes[i].bytesused, offset);
+					    filled, offset);
 		if (ret != 0)
 			return ret;
 	}
@@ -326,7 +347,6 @@ static int update_v4l2_bytesused(struct mvx_v4l2_buffer *vbuf)
 		b->planes[i].bytesused =
 			buf->planes[i].filled + buf->planes[i].offset;
 		b->planes[i].data_offset = buf->planes[i].offset;
-		//printk("--David-- bytesused = %d filled = %d\n",buf->planes[i].filled, b->planes[i].bytesused);
 	}
 
 	return 0;
@@ -344,7 +364,7 @@ static int update_vb2_flags(struct mvx_v4l2_buffer *vbuf)
 	if (buf->flags & MVX_BUFFER_EOS)
 		b->flags |= V4L2_BUF_FLAG_LAST;
 
-	if (buf->flags & MVX_BUFFER_EOF)
+	if ((buf->flags & MVX_BUFFER_EOF) && (buf->flags & MVX_BUFFER_FRAME_FLAG_IFRAME))
 		b->flags |= V4L2_BUF_FLAG_KEYFRAME;
 
 	if (buf->flags & MVX_BUFFER_CORRUPT)
@@ -374,6 +394,12 @@ static int update_vb2_flags(struct mvx_v4l2_buffer *vbuf)
     if (buf->flags & MVX_BUFFER_FRAME_NEED_REALLOC)
 		b->flags |= V4L2_BUF_FLAG_MVX_BUFFER_NEED_REALLOC;
 
+	if ((buf->flags & MVX_BUFFER_EOF) && (buf->flags & MVX_BUFFER_FRAME_FLAG_PFRAME))
+		b->flags |= V4L2_BUF_FLAG_PFRAME;
+
+	if ((buf->flags & MVX_BUFFER_EOF) && (buf->flags & MVX_BUFFER_FRAME_FLAG_BFRAME))
+		b->flags |= V4L2_BUF_FLAG_BFRAME;
+
 	return 0;
 }
 
@@ -455,20 +481,22 @@ enum vb2_buffer_state mvx_v4l2_buffer_update(struct mvx_v4l2_buffer *vbuf)
 		goto error;
 
 	ret = update_vb2_flags(vbuf);
-	if (ret != 0 ||
-	    (vbuf->vb2_v4l2_buffer.flags & V4L2_BUF_FLAG_ERROR) != 0)
-		goto error;
+
 
 #if KERNEL_VERSION(4, 5, 0) <= LINUX_VERSION_CODE
-	vb2->timestamp = mvx_buf->user_data;
+        vb2->timestamp = mvx_buf->user_data;
 #else
-	{
-		struct timeval *ts = &vbuf->vb2_v4l2_buffer.timestamp;
+    {
+        struct timeval *ts = &vbuf->vb2_v4l2_buffer.timestamp;
 
-		ts->tv_sec = mvx_buf->user_data >> 32;
-		ts->tv_usec = mvx_buf->user_data & 0xffffffff;
-	}
+        ts->tv_sec = mvx_buf->user_data >> 32;
+        ts->tv_usec = mvx_buf->user_data & 0xffffffff;
+    }
 #endif
+	if (ret != 0 ||(vbuf->vb2_v4l2_buffer.flags & V4L2_BUF_FLAG_ERROR) != 0) {
+		MVX_LOG_PRINT(&mvx_log_if, MVX_LOG_INFO,"buf flag is V4L2_BUF_FLAG_ERROR user_data:%llx dir:%d",mvx_buf->user_data,mvx_buf->dir);
+		goto error;
+	}
 
 	return VB2_BUF_STATE_DONE;
 
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_buffer.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_buffer.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_buffer.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_buffer.h
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_ctrls.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_ctrls.c
similarity index 84%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_ctrls.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_ctrls.c
index 3f69d43ad049..46783b304390 100755
--- a/drivers/media/vpu/if/v4l2/mvx_v4l2_ctrls.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_ctrls.c
@@ -100,6 +100,11 @@ static const uint8_t h264_profile_list[] = {
 	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,
 	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10
 };
+static const uint8_t hevc_profile_list[] = {
+  V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,
+  //V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE,
+  //V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10
+};
 
 static const enum mvx_profile mvx_h264_profile_list[] = {
 	MVX_PROFILE_H264_BASELINE,
@@ -129,6 +134,21 @@ static uint8_t h264_level_list[] = {
 	V4L2_MPEG_VIDEO_H264_LEVEL_5_0,
 	V4L2_MPEG_VIDEO_H264_LEVEL_5_1
 };
+static uint8_t hevc_level_list[] = {
+ V4L2_MPEG_VIDEO_HEVC_LEVEL_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_2,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_3,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_4,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_5,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_6,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1,
+  V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2,
+};
 
 static const int mvx_h264_level_list[] = {
 	MVX_LEVEL_H264_1,
@@ -352,7 +372,7 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 	int64_t i64_val;
 	bool bool_val;
 	enum mvx_tristate tri_val;
-
+        struct mvx_buffer_param_rate_control rate_control_param;
 	ret = mutex_lock_interruptible(&vsession->mutex);
 	if (ret != 0)
 		return ret;
@@ -363,7 +383,7 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 		ret = mvx_session_set_securevideo(session, bool_val);
 		break;
 	case V4L2_CID_MVE_VIDEO_FRAME_RATE:
-		i64_val = *ctrl->p_new.p_s64;
+		i64_val = (ctrl->type == V4L2_CTRL_TYPE_INTEGER)?*ctrl->p_new.p_s32:*ctrl->p_new.p_s64;
 		ret = mvx_session_set_frame_rate(session, i64_val);
 		break;
 	case V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:
@@ -374,6 +394,35 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 		i32_val = *ctrl->p_new.p_s32;
 		ret = mvx_session_set_bitrate(session, i32_val);
 		break;
+       case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+       {
+              i32_val = *ctrl->p_new.p_s32;
+              rate_control_param.rate_control_mode = session->rc_type;
+              rate_control_param.target_bitrate = session->target_bitrate;
+              rate_control_param.maximum_bitrate = session->maximum_bitrate;
+              if (i32_val==V4L2_MPEG_VIDEO_BITRATE_MODE_VBR)
+              {
+                  rate_control_param.rate_control_mode = MVX_OPT_RATE_CONTROL_MODE_VARIABLE;
+              }
+              else if (i32_val==V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)
+              {
+                  rate_control_param.rate_control_mode = MVX_OPT_RATE_CONTROL_MODE_CONSTANT;
+              }
+              else if (i32_val == V4L2_MPEG_VIDEO_BITRATE_MODE_CQ)
+              {
+                  rate_control_param.rate_control_mode = MVX_OPT_RATE_CONTROL_MODE_OFF;
+              }
+              ret = mvx_session_set_bitrate_control(session, &rate_control_param);
+              break;
+	}
+	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:
+	{
+             rate_control_param.rate_control_mode = session->rc_type;
+             rate_control_param.target_bitrate = session->target_bitrate;
+             rate_control_param.maximum_bitrate = *ctrl->p_new.p_s32;
+             ret = mvx_session_set_bitrate_control(session, &rate_control_param);
+             break;
+       }
     case V4L2_CID_MVE_VIDEO_CROP_LEFT:
         i32_val = *ctrl->p_new.p_s32;
         ret = mvx_session_set_crop_left(session, i32_val);
@@ -415,6 +464,18 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 					      MVX_FORMAT_H264,
 					      mvx_profile);
 		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_PROFILE:
+        i32_val = *ctrl->p_new.p_s32;
+		ret = find_idx(hevc_profile_list,
+			       ARRAY_SIZE(hevc_profile_list), i32_val);
+		if (ret == -EINVAL)
+			goto unlock_mutex;
+
+		mvx_profile = mvx_h265_profile_list[ret];
+		ret = mvx_session_set_profile(session,
+					      MVX_FORMAT_HEVC,
+					      mvx_profile);
+		break;
 	case V4L2_CID_MVE_VIDEO_H265_PROFILE:
 		i32_val = *ctrl->p_new.p_s32;
 		mvx_profile = mvx_h265_profile_list[i32_val];
@@ -441,6 +502,18 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 					    MVX_FORMAT_H264,
 					    mvx_level);
 		break;
+    case V4L2_CID_MPEG_VIDEO_HEVC_LEVEL:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = find_idx(hevc_level_list,
+			       ARRAY_SIZE(hevc_level_list), i32_val);
+		if (ret == -EINVAL)
+			goto unlock_mutex;
+
+		mvx_level = mvx_h265_level_list[ret*2];
+		ret = mvx_session_set_level(session,
+					    MVX_FORMAT_HEVC,
+					    mvx_level);
+		break;
 	case V4L2_CID_MVE_VIDEO_H265_LEVEL:
 		i32_val = *ctrl->p_new.p_s32;
 		mvx_level = mvx_h265_level_list[i32_val];
@@ -516,6 +589,9 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 		entropy_mode = mvx_h264_entropy_mode_list[ret];
 		ret = mvx_session_set_entropy_mode(session, entropy_mode);
 		break;
+	case V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:
+	    mvx_session_set_force_idr(session);
+	    break;
 	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:
 		i32_val = *ctrl->p_new.p_s32;
 		ret = find_idx(multi_slice_mode_list,
@@ -621,6 +697,31 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 		ret = mvx_session_set_max_qp(session, MVX_FORMAT_H264,
 					     i32_val);
 		break;
+    case V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = mvx_session_set_i_frame_qp(session, MVX_FORMAT_HEVC,
+						 i32_val);
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = mvx_session_set_p_frame_qp(session, MVX_FORMAT_HEVC,
+						 i32_val);
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = mvx_session_set_b_frame_qp(session, MVX_FORMAT_HEVC,
+						 i32_val);
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = mvx_session_set_min_qp(session, MVX_FORMAT_HEVC,
+					     i32_val);
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP:
+		i32_val = *ctrl->p_new.p_s32;
+		ret = mvx_session_set_max_qp(session, MVX_FORMAT_HEVC,
+					     i32_val);
+		break;
 	case V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP:
 		i32_val = *ctrl->p_new.p_s32;
 		ret = mvx_session_set_i_frame_qp(session, MVX_FORMAT_VP9,
@@ -658,6 +759,18 @@ static int set_ctrl(struct v4l2_ctrl *ctrl)
 			ret = mvx_session_set_jpeg_quality(session, i32_val);
 
 		break;
+	case V4L2_CID_MVE_VIDEO_WATCHDOG_TIMEOUT:
+		i32_val = *ctrl->p_new.p_s32;
+		if (i32_val != 0)
+			ret = mvx_session_set_watchdog_timeout(session, i32_val);
+
+		break;
+	case V4L2_CID_MVE_VIDEO_PROFILING:
+	    i32_val = *ctrl->p_new.p_s32;
+	    if (i32_val != 0)
+		    ret = mvx_session_set_profiling(session, i32_val);
+
+	    break;
 	}
 
 unlock_mutex:
@@ -854,6 +967,17 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+        ctrl = v4l2_ctrl_new_std_menu(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+		V4L2_MPEG_VIDEO_BITRATE_MODE_CQ, ~7,  V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);
+	if (ctrl == NULL)
+		goto handler_free;
+
+        ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,
+		1000, 1000000000, 1, 64000);
+	if (ctrl == NULL)
+		goto handler_free;
 	ctrl = v4l2_ctrl_new_std(
 		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_BITRATE,
 		1000, 1000000000, 1, 64000);
@@ -887,6 +1011,15 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+	ctrl = v4l2_ctrl_new_std_menu(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,
+		V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,
+		get_skip_mask(hevc_profile_list,
+			      ARRAY_SIZE(hevc_profile_list)),
+		V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN);
+	if (ctrl == NULL)
+		goto handler_free;
+
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = V4L2_CID_MVE_VIDEO_H265_PROFILE;
 	cfg.ops = &ctrl_ops;
@@ -919,6 +1052,14 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+	ctrl = v4l2_ctrl_new_std_menu(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,
+		V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2,
+		get_skip_mask(hevc_level_list, ARRAY_SIZE(hevc_level_list)),
+		V4L2_MPEG_VIDEO_HEVC_LEVEL_1);
+	if (ctrl == NULL)
+		goto handler_free;
+
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = V4L2_CID_MVE_VIDEO_H265_LEVEL;
 	cfg.ops = &ctrl_ops;
@@ -951,7 +1092,7 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 
 	ctrl = mvx_v4l2_ctrl_new_custom_int(
 		hnd, V4L2_CID_MVE_VIDEO_P_FRAMES,
-		"video P frames", 0, INT_MAX, 0, 1);
+		"video P frames", 0, INT_MAX, 30, 1);
 	if (ctrl == NULL)
 		goto handler_free;
 
@@ -1121,6 +1262,18 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+	ctrl = mvx_v4l2_ctrl_new_custom_int(
+		hnd, V4L2_CID_MVE_VIDEO_WATCHDOG_TIMEOUT,
+		"watchdog timeout", 5, 60, 30, 1);
+	if (ctrl == NULL)
+		goto handler_free;
+
+	ctrl = mvx_v4l2_ctrl_new_custom_int(
+		hnd, V4L2_CID_MVE_VIDEO_PROFILING,
+		"enable profiling", 0, 1, 0, 1);
+	if (ctrl == NULL)
+		goto handler_free;
+
 	ctrl = v4l2_ctrl_new_std(
 		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP,
 		0, 31, 1, 0);
@@ -1181,6 +1334,36 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+    ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP,
+		0, 51, 1, 0);
+	if (ctrl == NULL)
+		goto handler_free;
+
+	ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP,
+		0, 51, 1, 0);
+	if (ctrl == NULL)
+		goto handler_free;
+
+	ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP,
+		0, 51, 1, 0);
+	if (ctrl == NULL)
+		goto handler_free;
+
+	ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP,
+		1, 51, 1, 1);
+	if (ctrl == NULL)
+		goto handler_free;
+
+	ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP,
+		1, 51, 1, 1);
+	if (ctrl == NULL)
+		goto handler_free;
+
 	ctrl = v4l2_ctrl_new_std(
 		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP,
 		0, 51, 1, 0);
@@ -1240,6 +1423,12 @@ int mvx_v4l2_ctrls_init(struct v4l2_ctrl_handler *hnd)
 	if (ctrl == NULL)
 		goto handler_free;
 
+	ctrl = v4l2_ctrl_new_std(
+		hnd, &ctrl_ops, V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME,
+		0, 1, 1, 0);
+	if (ctrl == NULL)
+		goto handler_free;
+
 	ret = v4l2_ctrl_handler_setup(hnd);
 	if (ret != 0)
 		goto handler_free;
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_ctrls.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_ctrls.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_ctrls.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_ctrls.h
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_fops.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_fops.c
similarity index 93%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_fops.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_fops.c
index e3591803bc38..fd07c7c65a27 100755
--- a/drivers/media/vpu/if/v4l2/mvx_v4l2_fops.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_fops.c
@@ -141,11 +141,8 @@ unsigned int mvx_v4l2_poll(struct file *file,
 	struct mvx_v4l2_session *vsession = file_to_session(file);
 	unsigned long events = poll_requested_events(wait);
 	unsigned int revents = 0;
-	int ret;
 
-	ret = mutex_lock_interruptible(&vsession->mutex);
-	if (ret != 0)
-		return POLLERR;
+	mutex_lock(&vsession->mutex);
 
 	if (vsession->session.error != 0) {
 		revents = POLLERR;
@@ -153,15 +150,21 @@ unsigned int mvx_v4l2_poll(struct file *file,
 	}
 
 	/* POLLPRI events are handled by Vb2 */
-	revents |= vb2_poll(&vsession->port[MVX_DIR_INPUT].vb2_queue,
+	if (vsession->port[MVX_DIR_INPUT].q_set)
+            revents |= vb2_poll(&vsession->port[MVX_DIR_INPUT].vb2_queue,
 			    file, wait);
-	revents |= vb2_poll(&vsession->port[MVX_DIR_OUTPUT].vb2_queue,
+	if (vsession->port[MVX_DIR_OUTPUT].q_set)
+            revents |= vb2_poll(&vsession->port[MVX_DIR_OUTPUT].vb2_queue,
 			    file, wait);
-
+#ifndef MODULE
 	MVX_SESSION_VERBOSE(&vsession->session,
 			    "v4l2: Poll. events=0x%lx, revents=0x%x, nevents=%d.",
 			    events, revents, v4l2_event_pending(&vsession->fh));
-
+#else
+	MVX_SESSION_VERBOSE(&vsession->session,
+			    "v4l2: Poll. events=0x%lx, revents=0x%x",
+			    events, revents);
+#endif
 unlock_mutex:
 	mutex_unlock(&vsession->mutex);
 
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_fops.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_fops.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_fops.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_fops.h
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_session.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
similarity index 83%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_session.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
index 9c1a5052aaf3..b48ab0177f76 100755
--- a/drivers/media/vpu/if/v4l2/mvx_v4l2_session.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
@@ -192,7 +192,96 @@ static void free_session(struct mvx_session *session)
     }
 	devm_kfree(s->ext->dev, s);
 }
+#ifdef MODULE
+static unsigned sev_pos(const struct v4l2_subscribed_event *sev, unsigned idx)
+{
+	idx += sev->first;
+	return idx >= sev->elems ? idx - sev->elems : idx;
+}
+
+/* Caller must hold fh->vdev->fh_lock! */
+static struct v4l2_subscribed_event *v4l2_event_subscribed(
+		struct v4l2_fh *fh, u32 type, u32 id)
+{
+	struct v4l2_subscribed_event *sev;
+
+	assert_spin_locked(&fh->vdev->fh_lock);
+
+	list_for_each_entry(sev, &fh->subscribed, list)
+		if (sev->type == type && sev->id == id)
+			return sev;
+
+	return NULL;
+}
+
+static void __v4l2_event_queue_fh(struct v4l2_fh *fh,
+				  const struct v4l2_event *ev, u64 ts)
+{
+	struct v4l2_subscribed_event *sev;
+	struct v4l2_kevent *kev;
+	bool copy_payload = true;
+
+	/* Are we subscribed? */
+	sev = v4l2_event_subscribed(fh, ev->type, ev->id);
+	if (sev == NULL)
+		return;
+
+	/* Increase event sequence number on fh. */
+	fh->sequence++;
+
+	/* Do we have any free events? */
+	if (sev->in_use == sev->elems) {
+		/* no, remove the oldest one */
+		kev = sev->events + sev_pos(sev, 0);
+		list_del(&kev->list);
+		sev->in_use--;
+		sev->first = sev_pos(sev, 1);
+		fh->navailable--;
+		if (sev->elems == 1) {
+			if (sev->ops && sev->ops->replace) {
+				sev->ops->replace(&kev->event, ev);
+				copy_payload = false;
+			}
+		} else if (sev->ops && sev->ops->merge) {
+			struct v4l2_kevent *second_oldest =
+				sev->events + sev_pos(sev, 0);
+			sev->ops->merge(&kev->event, &second_oldest->event);
+		}
+	}
+
+	/* Take one and fill it. */
+	kev = sev->events + sev_pos(sev, sev->in_use);
+	kev->event.type = ev->type;
+	if (copy_payload)
+		kev->event.u = ev->u;
+	kev->event.id = ev->id;
+	kev->ts = ts;
+	kev->event.sequence = fh->sequence;
+	sev->in_use++;
+	list_add_tail(&kev->list, &fh->available);
 
+	fh->navailable++;
+
+	wake_up_all(&fh->wait);
+}
+
+void spacemit_v4l2_event_queue_fh(struct v4l2_fh *fh, const struct v4l2_event *ev)
+{
+	unsigned long flags;
+	u64 ts = ktime_get_ns();
+
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	__v4l2_event_queue_fh(fh, ev, ts);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+}
+void spacemit_vb2_queue_error(struct vb2_queue *q)
+{
+	q->error = 1;
+
+	wake_up_all(&q->done_wq);
+}
+
+#endif
 static void handle_event(struct mvx_session *session,
 			 enum mvx_session_event event,
 			 void *arg)
@@ -221,6 +310,13 @@ static void handle_event(struct mvx_session *session,
 			vb2_buffer_done(vb, state);
 		}
 
+		if (vbuf->buf.dir == MVX_DIR_OUTPUT && vb->state != VB2_BUF_STATE_QUEUED
+				&& !waitqueue_active(&vb->vb2_queue->done_wq)
+                && vsession->port[MVX_DIR_INPUT].q_set
+				&& waitqueue_active(&vsession->port[MVX_DIR_INPUT].vb2_queue.done_wq)) {
+				/*wake up waiters of input queue, because output queue may reallocated and not registered in waiters list */
+				wake_up(&vsession->port[MVX_DIR_INPUT].vb2_queue.done_wq);
+		}
 		break;
 	}
 	case MVX_SESSION_EVENT_PORT_CHANGED: {
@@ -235,15 +331,22 @@ static void handle_event(struct mvx_session *session,
 		p->field = port->interlaced ? V4L2_FIELD_SEQ_TB : V4L2_FIELD_NONE;
 		set_format(&vport->pix_mp, port->width, port->height,
 			   port->nplanes, port->size, port->stride);
+#ifndef MODULE
 		v4l2_event_queue_fh(&vsession->fh, &event);
+#else
+		spacemit_v4l2_event_queue_fh(&vsession->fh, &event);
+#endif
 		break;
 	}
 	case MVX_SESSION_EVENT_COLOR_DESC: {
 		const struct v4l2_event event = {
 			.type = V4L2_EVENT_MVX_COLOR_DESC,
 		};
-
+#ifndef MODULE
 		v4l2_event_queue_fh(&vsession->fh, &event);
+#else
+		spacemit_v4l2_event_queue_fh(&vsession->fh, &event);
+#endif
 		break;
 	}
 	case MVX_SESSION_EVENT_ERROR: {
@@ -251,8 +354,11 @@ static void handle_event(struct mvx_session *session,
 
 		for (i = 0; i < MVX_DIR_MAX; ++i) {
 			struct vb2_queue *q = &vsession->port[i].vb2_queue;
-
+#ifndef MODULE
 			vb2_queue_error(q);
+#else
+			spacemit_vb2_queue_error(q);
+#endif
 		}
 
 		break;
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_session.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_session.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.h
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_vidioc.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_vidioc.c
similarity index 96%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_vidioc.c
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_vidioc.c
index cfb561ed2c2e..71665d391827 100755
--- a/drivers/media/vpu/if/v4l2/mvx_v4l2_vidioc.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_vidioc.c
@@ -10,23 +10,23 @@
  * and copies of this file may only be made by a person if such person is
  * permitted to do so under the terms of a subsisting license agreement
  * from Arm Technology (China) Co., Ltd.
- * 
+ *
  * SPDX-License-Identifier: GPL-2.0-only
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  */
 
 /****************************************************************************
@@ -152,6 +152,10 @@ struct mvx_format_map mvx_fmts[] = {
 	  0,
 	  V4L2_PIX_FMT_NV21,
 	  "Y/CrCb 4:2:0 (N-C)" },
+	{ MVX_FORMAT_YUV420_NV12,
+	  0,
+	  V4L2_PIX_FMT_NV12M,
+	  "Y/CbCr 4:2:0" },
 	{ MVX_FORMAT_YUV420_P010,
 	  0,
 	  V4L2_PIX_FMT_P010,
@@ -546,9 +550,15 @@ static void buf_cleanup(struct vb2_buffer *b)
 	struct mvx_session *session = &vsession->session;
 	struct mvx_v4l2_buffer *vbuf = vb2_to_mvx_v4l2_buffer(b);
 
-	MVX_SESSION_VERBOSE(session,
-			    "v4l2: Cleanup buffer. vb=%p, index=%u, vbuf=%p, type=%u.",
-			    b, b->type, b->index, vbuf);
+       if (session->port[vport->dir].stream_on) {
+            MVX_SESSION_VERBOSE(session,
+                "v4l2: Cleanup buffer in the coding process. Will remap mve va and pa address. dir=%d, type=%u, index=%u, vb=%p, vbuf=%p.",
+                vport->dir, b->type, b->index, b, vbuf);
+       } else {
+            MVX_SESSION_VERBOSE(session,
+                "v4l2: Cleanup buffer. type=%u, index=%u, vb=%p, vbuf=%p.",
+                b->type, b->index, b, vbuf);
+       }
 
 	mvx_v4l2_buffer_destruct(vbuf);
 }
@@ -1074,7 +1084,6 @@ int mvx_v4l2_vidioc_try_fmt_vid_out(struct file *file,
 {
 	return mvx_v4l2_vidioc_try_fmt_vid(file, f, MVX_DIR_INPUT);
 }
-
 int mvx_v4l2_vidioc_g_crop(struct file *file,
 			   void *fh,
 			   struct v4l2_crop *a)
@@ -1084,11 +1093,8 @@ int mvx_v4l2_vidioc_g_crop(struct file *file,
 				 MVX_DIR_INPUT : MVX_DIR_OUTPUT;
 	struct mvx_v4l2_port *vport = &vsession->port[dir];
 	struct mvx_session_port *port = &vsession->session.port[dir];
-	int ret;
 
-	ret = mutex_lock_interruptible(&vsession->mutex);
-	if (ret != 0)
-		return ret;
+	mutex_lock(&vsession->mutex);
 
 	a->c.left = vport->crop.left;
 	a->c.top = vport->crop.top;
@@ -1232,6 +1238,11 @@ int mvx_v4l2_vidioc_encoder_cmd(struct file *file,
 	case V4L2_ENC_CMD_STOP:
 		ret = mvx_session_send_eos(&vsession->session);
 		break;
+      case V4L2_ENC_CMD_START:
+             /*reset flag for v4l2 core, so that buffers can be queued normal.*/
+             vsession->port[1].vb2_queue.last_buffer_dequeued = false;
+             ret = 0;
+            break;
 	default:
 		MVX_SESSION_WARN(&vsession->session,
 				 "Unsupported command. cmd: %u.", cmd->cmd);
@@ -1249,6 +1260,7 @@ int mvx_v4l2_vidioc_try_encoder_cmd(struct file *file,
 {
 	switch (cmd->cmd) {
 	case V4L2_ENC_CMD_STOP:
+       case V4L2_ENC_CMD_START:
 		return 0;
 	default:
 		return -EINVAL;
@@ -1273,6 +1285,11 @@ int mvx_v4l2_vidioc_decoder_cmd(struct file *file,
 	case V4L2_DEC_CMD_STOP:
 		ret = mvx_session_send_eos(&vsession->session);
 		break;
+       case V4L2_DEC_CMD_START:
+             /*reset flag for v4l2 core, so that buffers can be queued normal.*/
+             vsession->port[1].vb2_queue.last_buffer_dequeued = false;
+             ret = 0;
+            break;
 	default:
 		MVX_SESSION_WARN(&vsession->session,
 				 "Unsupported command. cmd: %u.", cmd->cmd);
@@ -1290,6 +1307,7 @@ int mvx_v4l2_vidioc_try_decoder_cmd(struct file *file,
 {
 	switch (cmd->cmd) {
 	case V4L2_DEC_CMD_STOP:
+       case V4L2_DEC_CMD_START:
 		return 0;
 	default:
 		return -EINVAL;
@@ -1362,8 +1380,9 @@ int mvx_v4l2_vidioc_create_bufs(struct file *file,
 		goto unlock_mutex;
 
 	vport->q_set = true;
-
+#ifndef MODULE
 	ret = vb2_create_bufs(&vport->vb2_queue, b);
+#endif
     vport->port->buffer_allocated = b->count;
 unlock_mutex:
 	mutex_unlock(&vsession->mutex);
@@ -1435,9 +1454,7 @@ int mvx_v4l2_vidioc_qbuf(struct file *file,
             "v4l2: Queue buffer. dir=%d, type=%u, index=%u, flags=0x%x.",
             dir, b->type, b->index, b->flags);
 
-	ret = mutex_lock_interruptible(&vsession->mutex);
-	if (ret != 0)
-		return ret;
+	mutex_lock(&vsession->mutex);
 
     if ((b->flags & V4L2_BUF_FLAG_MVX_BUFFER_EPR) == V4L2_BUF_FLAG_MVX_BUFFER_EPR ){
         vb = vport->vb2_queue.bufs[b->index];
@@ -1471,15 +1488,15 @@ int mvx_v4l2_vidioc_dqbuf(struct file *file,
 				 MVX_DIR_INPUT : MVX_DIR_OUTPUT;
 	struct mvx_v4l2_port *vport = &vsession->port[dir];
 	struct vb2_buffer *vb;
+	struct mvx_v4l2_buffer *vbuf;
+       struct mvx_buffer *buf;
 	int ret;
 
 	MVX_SESSION_INFO(&vsession->session,
 			 "v4l2: Dequeue buffer. dir=%d, type=%u.",
 			 dir, b->type);
 
-	ret = mutex_lock_interruptible(&vsession->mutex);
-	if (ret != 0)
-		return ret;
+	mutex_lock(&vsession->mutex);
 
 	ret = vb2_dqbuf(&vport->vb2_queue, b, file->f_flags & O_NONBLOCK);
 	if (ret != 0)
@@ -1513,13 +1530,27 @@ int mvx_v4l2_vidioc_dqbuf(struct file *file,
 		}
 	}
 
+    if (vsession->port[MVX_DIR_INPUT].port->format <= MVX_FORMAT_BITSTREAM_LAST &&
+            dir == MVX_DIR_OUTPUT && V4L2_TYPE_IS_MULTIPLANAR(b->type)) {
+        vbuf = vb2_to_mvx_v4l2_buffer(vb);
+        buf = &vbuf->buf;
+        b->reserved2 = (buf->width << 16) | (buf->height);
+    }
+
 unlock_mutex:
 	mutex_unlock(&vsession->mutex);
 
+#ifndef MODULE
 	MVX_SESSION_INFO(&vsession->session,
 			 "v4l2: Dequeued buffer. dir=%d, type=%u, index=%u, flags=0x%x, nevents=%u, fh=%p.",
 			 dir, b->type, b->index, b->flags,
 			 v4l2_event_pending(&vsession->fh), fh);
+#else
+	MVX_SESSION_INFO(&vsession->session,
+			 "v4l2: Dequeued buffer. dir=%d, type=%u, index=%u, flags=0x%x, fh=%p.",
+			 dir, b->type, b->index, b->flags,
+			 fh);
+#endif
 
 	return ret;
 }
diff --git a/drivers/media/vpu/if/v4l2/mvx_v4l2_vidioc.h b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_vidioc.h
similarity index 100%
rename from drivers/media/vpu/if/v4l2/mvx_v4l2_vidioc.h
rename to drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_vidioc.h
diff --git a/drivers/media/vpu/mvx_driver.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_driver.c
similarity index 100%
rename from drivers/media/vpu/mvx_driver.c
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_driver.c
diff --git a/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.c
new file mode 100755
index 000000000000..fabb9b7a391c
--- /dev/null
+++ b/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.c
@@ -0,0 +1,1296 @@
+/*
+ * The confidential and proprietary information contained in this file may
+ * only be used by a person authorised under and to the extent permitted
+ * by a subsisting licensing agreement from Arm Technology (China) Co., Ltd.
+ *
+ *            (C) COPYRIGHT 2021-2021 Arm Technology (China) Co., Ltd.
+ *                ALL RIGHTS RESERVED
+ *
+ * This entire notice must be reproduced on all copies of this file
+ * and copies of this file may only be made by a person if such person is
+ * permitted to do so under the terms of a subsisting license agreement
+ * from Arm Technology (China) Co., Ltd.
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+/****************************************************************************
+ * Includes
+ ****************************************************************************/
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/pm_qos.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/stat.h>
+#include <linux/sysfs.h>
+#include <linux/thermal.h>
+
+#include "mvx_dvfs.h"
+#include "mvx_log_group.h"
+#include "mvx_session.h"
+
+#define DVFS_INTERNAL_DEBUG
+/** Default value for an interval between frequency updates in milliseconds.
+ * It could be overwritten by user in debug build when sysfs is enabled.
+ */
+#define POLL_INTERVAL_MS 100
+
+/* Adjustment step in percents of maximum supported frequency */
+#define UP_STEP_PERCENT 25
+#define DOWN_STEP_PERCENT 13
+#define DVFS_FREQ_MAX  819200000
+
+#if defined(CONFIG_SYSFS) && defined(DVFS_INTERNAL_DEBUG)
+#define DVFS_DEBUG_MODE 1
+#else
+#define DVFS_DEBUG_MODE 0
+#endif
+
+#define VPU_DDR_QOS_ENABLE 0
+#define VPU_DDR_QOS_MIN  50000   /* 50MB/s */
+#define VPU_DDR_QOS_MAX  4096000  /* 4GB/s */
+#define VPU_DDR_QOS_PREDEFINED_FPS 30
+
+#define NELEMS(a) (sizeof(a) / sizeof((a)[0]))
+
+extern int session_wait_pending_timeout;
+extern int session_watchdog_timeout;
+
+/**
+ * Structure used by DVFS module to keep track of session usage and to
+ * take decisions about power management.
+ *
+ * Currently the only parameter taken into consideration is an amount of
+ * output buffers enqueued in FW for each session. DVFS tries to keep this
+ * parameter equal to 1 for all sessions. If some session has more than one
+ * enqueued buffer, it means that a client is waiting for more than one
+ * frame and the clock frequency should be increased. If some session has
+ * no buffers enqueued, it means that the client is not waiting for
+ * anything and the clock frequency could be decreased. Priority is given
+ * to frequency increasing (when more than one session is registered).
+ */
+struct session
+{
+    mvx_session_id session_id;
+    struct list_head list;
+    bool is_encoder;
+    uint32_t ddr_qos_read;
+    uint32_t ddr_qos_write;
+    int restrict_buffer_count;
+};
+
+/* Avaible VPU frequency. */
+enum {
+    VPU_VMIN_LEVEL_0 = 0,
+    VPU_VMIN_LEVEL_1,
+    VPU_VMIN_LEVEL_2,
+    VPU_VMIN_LEVEL_3,
+    VPU_VMIN_LEVEL_4,
+    VPU_VMIN_LEVEL_5,
+    VPU_VMIN_LEVEL_6,
+};
+struct vpu_freq_vmin_info
+{
+    uint32_t freq;
+    uint32_t vmin_level;
+};
+
+/* for dvfs and ddr qos adjust. */
+struct mvx_dvfs_ctx_t
+{
+    /* ddr qos params */
+    uint32_t ddr_qos_rsum;
+    uint32_t ddr_qos_wsum;
+
+    /* Frequency limits */
+    struct clk* clock;
+    uint32_t max_freq;
+    uint32_t min_freq;
+    uint32_t up_step_freq;
+    uint32_t down_step_freq;
+    /**
+     * DVFS polling interval - an interval between frequency updates in milliseconds.
+     * It is a constant value for non-debug and non-sysfs builds.
+     */
+    uint32_t poll_interval_ms;
+
+#ifdef CONFIG_THERMAL
+    /* thermal restriction */
+    unsigned long max_state;
+    unsigned long cur_state;
+    struct thermal_cooling_device *cdev;
+#endif
+};
+
+/* A list containing all registered sessions */
+static LIST_HEAD(sessions);
+
+struct device *mvx_device;
+
+/* Flag used to prevent usage of DVFS module when it was not initialized */
+static bool initialized = false;
+
+/* Flag used to indicate that DVFS module is going to shut itself down */
+static bool shutdown = false;
+
+/* Semaphore used to prevent concurrent access to DVFS internal structures */
+static struct semaphore dvfs_sem;
+
+/* DVFS polling task */
+static struct task_struct *dvfs_task = NULL;
+static wait_queue_head_t dvfs_wq;
+
+#if (1 == DVFS_DEBUG_MODE)
+/**
+ * Counters used for debugging/verification purposes.
+ */
+
+/* Flag used to enable/disable DVFS in debug builds */
+static atomic_t dvfs_enabled = ATOMIC_INIT(1);
+
+#if (1 == VPU_DDR_QOS_ENABLE)
+static atomic_t ddr_qos_enabled = ATOMIC_INIT(1);
+#endif
+
+/* Amount of times clock frequency was changed by DVFS */
+static atomic_long_t changes_cnt = ATOMIC_LONG_INIT(0);
+
+/* Amount of times burst mode was used by DVFS */
+static atomic_long_t burst_cnt = ATOMIC_LONG_INIT(0);
+#endif
+
+static const struct vpu_freq_vmin_info vpufclk_freqtable[] =
+{
+    {307200000, VPU_VMIN_LEVEL_0},
+    {409600000, VPU_VMIN_LEVEL_1},
+    {491520000, VPU_VMIN_LEVEL_2},
+    {600000000, VPU_VMIN_LEVEL_3},
+    {614400000, VPU_VMIN_LEVEL_4},
+    {750000000, VPU_VMIN_LEVEL_5},
+    {819200000, VPU_VMIN_LEVEL_6}
+};
+
+#define  FREQ_TABLE_SIZE (sizeof(vpufclk_freqtable)/sizeof(struct vpu_freq_vmin_info))
+
+static struct mvx_dvfs_ctx_t mvx_dvfs_ctx;
+
+static void set_clock_rate(uint32_t clk_rate)
+{
+    //clk_set_rate(mvx_dvfs_ctx.clock, clk_rate);
+}
+
+static uint32_t get_clock_rate(void)
+{
+    return 0;
+    //return clk_get_rate(mvx_dvfs_ctx.clock);
+}
+
+static uint32_t get_max_clock_rate(void)
+{
+    return DVFS_FREQ_MAX;
+}
+
+/**
+ * Allocate and register a session in DVFS module.
+ *
+ * This function allocates needed resources for the session and registers
+ * it in the module.
+ *
+ * This function must be called when dvfs_sem semaphore IS locked.
+ *
+ * @param session_is Session id
+ * @return True when registration was successful,
+ *         False otherwise.
+ */
+static bool allocate_session(const mvx_session_id session_id, bool is_encoder)
+{
+    struct session *session;
+
+    session = devm_kzalloc(mvx_device, sizeof(*session), GFP_KERNEL);
+    if (NULL == session)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "DVFS is unable to allocate memory for a new session. session=%p",
+                session_id);
+        return false;
+    }
+
+    session->session_id = session_id;
+    session->ddr_qos_read  = session->ddr_qos_write = 0;
+    session->is_encoder = is_encoder;
+
+    INIT_LIST_HEAD(&session->list);
+    list_add(&session->list, &sessions);
+
+    return true;
+}
+
+/**
+ * Unregister a session from DVFS module.
+ *
+ * When session is not NULL, the function releases all previously allocated
+ * resources for the session and unregisters it from DVFS.
+ *
+ * This function must be called when dvfs_sem semaphore IS locked.
+ *
+ * @param session Session or NULL
+ */
+static void free_session(struct session *session)
+{
+    if (NULL == session)
+    {
+        return;
+    }
+
+    list_del(&session->list);
+    devm_kfree(mvx_device, session);
+}
+
+/**
+ * Find a session with provided session_id.
+ *
+ * This function tries to find previously registered session with provided
+ * session_id.
+ *
+ * This function must be called when dvfs_sem semaphore IS locked.
+ *
+ * @param session_id Session id
+ * @return pointer to session structure when a session was found,
+ *         NULL when a session was not found.
+ */
+static struct session *get_session(const mvx_session_id session_id)
+{
+    struct list_head *entry;
+    struct session *session;
+    list_for_each(entry, &sessions)
+    {
+        session = list_entry(entry, struct session, list);
+        if (session->session_id == session_id)
+        {
+            return session;
+        }
+    }
+    return NULL;
+}
+
+/**
+ * Warm up VPU.
+ *
+ * This function increases VPU clock frequency for requested amount
+ * of steps when possible.
+ *
+ * @param steps Requested amount of steps.
+ */
+static void warm_up(const int steps)
+{
+    uint32_t old_freq = get_clock_rate();
+    uint32_t new_freq;
+#if (1 == DVFS_DEBUG_MODE)
+    bool do_burst = false;
+#endif
+
+    /**
+     * If 3 or more steps are requested, we are far behind required
+     * performance level.
+     */
+    if (steps > 2)
+    {
+        new_freq = mvx_dvfs_ctx.max_freq;
+#if (1 == DVFS_DEBUG_MODE)
+        do_burst = true;
+#endif
+    }
+    else
+    {
+        new_freq = min(old_freq + steps * mvx_dvfs_ctx.up_step_freq, mvx_dvfs_ctx.max_freq);
+    }
+
+    if (old_freq != new_freq)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "warm_up. buffer count: %d, old_freq: %d, new_freq: %d", steps, old_freq, new_freq);
+        set_clock_rate(new_freq);
+#if (1 == DVFS_DEBUG_MODE)
+        atomic_long_inc(&changes_cnt);
+        if (do_burst)
+        {
+            atomic_long_inc(&burst_cnt);
+        }
+#endif
+
+    }
+}
+
+/**
+ * Cool down VPU.
+ *
+ * This function increases VPU clock frequency if possible.
+ */
+static void cool_down(void)
+{
+    uint32_t old_freq = get_clock_rate();
+    uint32_t new_freq;
+    if (old_freq == mvx_dvfs_ctx.min_freq)
+    {
+        return;
+    }
+    new_freq = max(mvx_dvfs_ctx.min_freq, max(mvx_dvfs_ctx.down_step_freq, old_freq - mvx_dvfs_ctx.down_step_freq));
+    if (old_freq != new_freq)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "cool_down. old_freq: %d, new_freq: %d", old_freq, new_freq);
+        set_clock_rate(new_freq);
+#if (1 == DVFS_DEBUG_MODE)
+        atomic_long_inc(&changes_cnt);
+#endif
+    }
+}
+
+static int get_restrict_buffer_count(mvx_session_id session_id)
+{
+    struct mvx_session *session = (struct mvx_session *)session_id;
+    int buffers_cnt;
+    struct session* dvfs_session = get_session(session_id);
+    if (dvfs_session == NULL)
+    {
+        return -1;
+    }
+
+    /* Don't have to lock the session since we just want to get the number of buffers */
+    if (!dvfs_session->is_encoder)
+    {
+        buffers_cnt = session->port[MVX_DIR_OUTPUT].buffer_count;
+        buffers_cnt -= session->port[MVX_DIR_OUTPUT].buffer_on_hold_count;
+
+        /* There is no enough inputs, no need to boost vpu. */
+        if (session->port[MVX_DIR_INPUT].buffer_count <= 1)
+        {
+            buffers_cnt = session->port[MVX_DIR_INPUT].buffer_count;
+        }
+        //MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "get_restrict_buffer_count. out buffer_count: %d, buffer_on_hold_count: %d, in buffer_count: %d", session->port[MVX_DIR_OUTPUT].buffer_count, session->port[MVX_DIR_OUTPUT].buffer_on_hold_count, session->port[MVX_DIR_INPUT].buffer_count);
+    }
+    else
+    {
+        buffers_cnt = session->port[MVX_DIR_INPUT].buffer_count;
+        if (false != session->eos_queued && buffers_cnt < 2)
+        {
+            buffers_cnt = 2;
+        }
+        //MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "get_restrict_buffer_count. buffer_count: %d, eos_queued: %d", session->port[MVX_DIR_INPUT].buffer_count, session->eos_queued);
+    }
+
+    if (session->keep_freq_high) {
+        buffers_cnt += 2;
+    }
+
+    return buffers_cnt;
+}
+
+/**
+ * Update sessions list and VPU clock frequency.
+ *
+ * This function queries the state of all registered sessions and adjusts
+ * VPU clock frequency to meet their needs when dvfs_control is enabled.
+ * When SYSFS is enabled, the function also stores the status of all sessions
+ * so it could be retrieved by the user.
+ *
+ * This function must be called when dvfs_sem semaphore IS NOT locked.
+ */
+static void update_sessions(void)
+{
+    struct list_head *entry;
+    struct list_head *safe;
+    struct session *session;
+    int  restrict_buffer_count;
+    unsigned int buf_max = 0;
+    unsigned int buf_min = UINT_MAX;
+    int sem_failed;
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    if (sem_failed)
+    {
+        return;
+    }
+
+    list_for_each_safe(entry, safe, &sessions)
+    {
+        session = list_entry(entry, struct session, list);
+
+        /**
+         * To avoid potential dead lock we release dvfs_sem before a call to
+         * get_session_status() callback. After a return from the callback
+         * we have to take dvfs_sem again and to verify that current session
+         * was not unregistered by the scheduler while we were sleeping.
+         */
+        restrict_buffer_count = get_restrict_buffer_count(session->session_id);
+        session->restrict_buffer_count = restrict_buffer_count;
+
+        if (shutdown)
+        {
+            up(&dvfs_sem);
+            return;
+        }
+
+        if (restrict_buffer_count < 0)
+        {
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                    "DVFS failed to retrieve status for the session. Session was removed? session=%p, restrict_buffer_count=%d",
+                    session->session_id, restrict_buffer_count);
+            continue;
+        }
+
+        if (restrict_buffer_count > buf_max)
+        {
+            buf_max = restrict_buffer_count;
+        }
+        if (restrict_buffer_count < buf_min)
+        {
+            buf_min = restrict_buffer_count;
+        }
+    }
+
+#if (1 == DVFS_DEBUG_MODE)
+    if (0 == atomic_read(&dvfs_enabled))
+    {
+        up(&dvfs_sem);
+        return;
+    }
+#endif
+
+    if (buf_max > 1)
+    {
+        warm_up(buf_max);
+    }
+    else if (buf_min < 1)
+    {
+        cool_down();
+    }
+    up(&dvfs_sem);
+}
+
+/**
+ * DVFS polling thread.
+ *
+ * This function is executed in a separate kernel thread. It updates clock
+ * frequency every poll_interval_ms milliseconds.
+ */
+static int dvfs_thread(void *v)
+{
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "DVFS polling thread started");
+    while (!kthread_should_stop())
+    {
+        wait_event_interruptible(dvfs_wq, list_empty(&sessions) == 0 || shutdown);
+        update_sessions();
+        msleep_interruptible(mvx_dvfs_ctx.poll_interval_ms);
+    }
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "DVFS polling thread finished");
+    return 0;
+}
+
+/**
+ *  Return percent percents from a value val.
+ */
+static uint32_t ratio(const uint32_t val, const uint32_t percent)
+{
+    return (uint32_t)(((uint64_t)val * percent) / 100);
+}
+
+#if (1 == DVFS_DEBUG_MODE)
+/**
+ * Print DVFS statistics to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_stats(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    struct list_head *entry;
+    struct session *session;
+    uint32_t freq = get_clock_rate();
+
+    num += scnprintf(buf + num, PAGE_SIZE - num,
+            "freq: %4u, max_freq: %4u, up_step_freq: %3u, down_step_freq: %3u",
+            freq, mvx_dvfs_ctx.max_freq, mvx_dvfs_ctx.up_step_freq, mvx_dvfs_ctx.down_step_freq);
+#if (1 == DVFS_DEBUG_MODE)
+    num += scnprintf(buf + num, PAGE_SIZE - num,
+            ", enabled: %1u, poll_interval_ms: %3u, changes_cnt: %10lu, burst_cnt: %10lu",
+            atomic_read(&dvfs_enabled), mvx_dvfs_ctx.poll_interval_ms,
+            atomic_long_read(&changes_cnt), atomic_long_read(&burst_cnt));
+#endif
+    num += scnprintf(buf + num, PAGE_SIZE - num, "\n");
+    list_for_each(entry, &sessions)
+    {
+        session = list_entry(entry, struct session, list);
+        num += scnprintf(buf + num, PAGE_SIZE - num,
+                "%p: out_buf: %02u\n",
+                session->session_id, session->restrict_buffer_count);
+    }
+
+    return num;
+}
+
+/**
+ * Print DVFS enabling status to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_enabled(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", atomic_read(&dvfs_enabled) ? 1 : 0);
+    return num;
+}
+
+/**
+ * Set DVFS enabling status from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_enabled(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    int enabled;
+    failed = kstrtouint(buf, 10, &enabled);
+    if (!failed)
+    {
+        atomic_set(&dvfs_enabled, enabled);
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Print current clock frequency to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_freq(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    uint32_t freq = get_clock_rate();
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", freq);
+    return num;
+}
+
+/**
+ * Set current clock frequency from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_freq(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int freq;
+    failed = kstrtouint(buf, 10, &freq);
+    if (!failed)
+    {
+        set_clock_rate((uint32_t)freq);
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Print min clock frequency to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_min_freq(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    uint32_t freq = mvx_dvfs_ctx.min_freq;
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", freq);
+    return num;
+}
+
+uint32_t clip_min_max_rate(uint32_t freq, bool is_min_freq)
+{
+    int i = 0;
+    bool clip = false;
+    uint32_t clip_freq;
+    if (is_min_freq) {
+        for (i = 0; i < FREQ_TABLE_SIZE; i++)
+        {
+            if (freq <= vpufclk_freqtable[i].freq)
+            {
+                clip = true;
+                clip_freq = vpufclk_freqtable[i].freq;
+                break;
+            }
+        }
+        if (!clip) clip_freq = vpufclk_freqtable[FREQ_TABLE_SIZE-1].freq;
+    } else {
+        for (i = FREQ_TABLE_SIZE-1; i >= 0; i--)
+        {
+            if (freq >= vpufclk_freqtable[i].freq)
+            {
+                clip = true;
+                clip_freq = vpufclk_freqtable[i].freq;
+                break;
+            }
+        }
+        if (!clip) clip_freq = vpufclk_freqtable[0].freq;
+    }
+
+    return clip_freq;
+}
+
+/**
+ * Set min clock frequency from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_min_freq(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int freq;
+    failed = kstrtouint(buf, 10, &freq);
+    freq = clip_min_max_rate(freq, true);
+    if (!failed)
+    {
+        mvx_dvfs_ctx.min_freq = (uint32_t)freq;
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Print max clock frequency to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_max_frep(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    uint32_t freq = mvx_dvfs_ctx.max_freq;
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", freq);
+    return num;
+}
+
+/**
+ * Set max clock frequency from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_max_freq(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int freq;
+    failed = kstrtouint(buf, 10, &freq);
+    freq = clip_min_max_rate(freq, false);
+    if (!failed)
+    {
+        mvx_dvfs_ctx.max_freq = (uint32_t)freq;
+        mvx_dvfs_ctx.up_step_freq = ratio(mvx_dvfs_ctx.max_freq, UP_STEP_PERCENT);
+        mvx_dvfs_ctx.down_step_freq = ratio(mvx_dvfs_ctx.max_freq, DOWN_STEP_PERCENT);
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Set polling interval from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_poll_interval_ms(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    failed = kstrtouint(buf, 10, &mvx_dvfs_ctx.poll_interval_ms);
+    return (failed) ? failed : count;
+}
+
+/**
+ * Set up_step value from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_up_step_percent(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int up_step_percent;
+    failed = kstrtouint(buf, 10, &up_step_percent);
+    if (!failed)
+    {
+        mvx_dvfs_ctx.up_step_freq = ratio(mvx_dvfs_ctx.max_freq, up_step_percent);
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Set down_step value from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_down_step_percent(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int down_step_percent;
+    failed = kstrtouint(buf, 10, &down_step_percent);
+    if (!failed)
+    {
+        mvx_dvfs_ctx.down_step_freq = ratio(mvx_dvfs_ctx.max_freq, down_step_percent);
+    }
+    return (failed) ? failed : count;
+}
+/**
+ * Print available clock frequency to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_available_freq(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    int32_t i;
+    for(i=0; i<FREQ_TABLE_SIZE; i++)
+    {
+        num += scnprintf(buf + num, PAGE_SIZE - num, "%u	", vpufclk_freqtable[i].freq);
+    }
+    num += scnprintf(buf + num, PAGE_SIZE - num, "\n");
+    return num;
+}
+
+#if (1 == VPU_DDR_QOS_ENABLE)
+static ssize_t sysfs_print_ddr_qos_enable(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    num += snprintf(buf, PAGE_SIZE, "%u\n", atomic_read(&ddr_qos_enabled) ? 1 : 0);
+    return num;
+}
+
+static ssize_t sysfs_set_ddr_qos_enable(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    int failed;
+    int enable;
+    failed = kstrtouint(buf, 10, &enable);
+    if (!failed)
+    {
+        atomic_set(&ddr_qos_enabled, enable);
+    }
+    return (failed) ? failed : count;
+}
+#endif
+
+/**
+ * Print watchdog timeout value to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_watchdog_timeout(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    uint32_t watchdog_timeout = session_watchdog_timeout;
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", watchdog_timeout);
+    return num;
+}
+
+/**
+ * Set watchdog timeout value from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_watchdog_timeout(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int watchdog_timeout;
+    failed = kstrtouint(buf, 10, &watchdog_timeout);
+    if (!failed)
+    {
+        session_watchdog_timeout = watchdog_timeout;
+    }
+    return (failed) ? failed : count;
+}
+
+/**
+ * Print wait pending timeout value to sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+static ssize_t sysfs_print_wait_pending_timeout(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    ssize_t num = 0;
+    uint32_t wait_pending_timeout = session_wait_pending_timeout;
+    num += scnprintf(buf, PAGE_SIZE, "%u\n", wait_pending_timeout);
+    return num;
+}
+
+/**
+ * Set wait pending timeout value from sysfs attribute.
+ *
+ * Used for debugging/verification purposes.
+ */
+ssize_t sysfs_set_wait_pending_timeout(struct device *dev, struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int failed;
+    unsigned int wait_pending_timeout;
+    failed = kstrtouint(buf, 10, &wait_pending_timeout);
+    if (!failed)
+    {
+        session_wait_pending_timeout = wait_pending_timeout;
+    }
+    return (failed) ? failed : count;
+}
+
+/* Sysfs attributes used to debug/verify DVFS module */
+static struct device_attribute sysfs_files[] =
+{
+    __ATTR(dvfs_stats, S_IRUGO, sysfs_print_stats, NULL),
+    __ATTR(dvfs_enable, (S_IRUGO | S_IWUSR), sysfs_print_enabled, sysfs_set_enabled),
+    __ATTR(dvfs_freq,	(S_IRUGO | S_IWUSR), sysfs_print_freq, sysfs_set_freq),
+    __ATTR(dvfs_poll_interval_ms,   S_IWUSR, NULL, sysfs_set_poll_interval_ms),
+    __ATTR(dvfs_up_step_percent,    S_IWUSR, NULL, sysfs_set_up_step_percent),
+    __ATTR(dvfs_down_step_percent,  S_IWUSR, NULL, sysfs_set_down_step_percent),
+    __ATTR(dvfs_available_freqency,	  S_IRUGO, sysfs_print_available_freq, NULL),
+    __ATTR(dvfs_min_freq, (S_IRUGO | S_IWUSR), sysfs_print_min_freq, sysfs_set_min_freq),
+    __ATTR(dvfs_max_freq, (S_IRUGO | S_IWUSR), sysfs_print_max_frep, sysfs_set_max_freq),
+#if (1 == VPU_DDR_QOS_ENABLE)
+    __ATTR(ddr_qos_enable, (S_IRUGO | S_IWUSR), sysfs_print_ddr_qos_enable, sysfs_set_ddr_qos_enable),
+#endif
+    __ATTR(watchdog_timeout, (S_IRUGO | S_IWUSR), sysfs_print_watchdog_timeout, sysfs_set_watchdog_timeout),
+    __ATTR(wait_pending_timeout, (S_IRUGO | S_IWUSR), sysfs_print_wait_pending_timeout, sysfs_set_wait_pending_timeout),
+};
+
+/**
+ * Register all DVFS attributes in sysfs subsystem
+ */
+static void sysfs_register_devices(struct device *dev)
+{
+    int err;
+    int i = NELEMS(sysfs_files);
+
+    while (i--)
+    {
+        err = device_create_file(dev, &sysfs_files[i]);
+        if (err < 0)
+        {
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_ERROR,
+                    "DVFS is unable to create sysfs file. name=%s",
+                    sysfs_files[i].attr.name);
+        }
+    }
+}
+
+/**
+ * Remove DVFS attributes from sysfs subsystem
+ */
+static void sysfs_unregister_devices(struct device *dev)
+{
+    int i = NELEMS(sysfs_files);
+
+    while (i--)
+    {
+        device_remove_file(dev, &sysfs_files[i]);
+    }
+}
+#endif /* DVFS_DEBUG_MODE */
+
+#ifdef CONFIG_THERMAL
+static int vpu_get_max_state(struct thermal_cooling_device *cdev,
+        unsigned long *state)
+{
+    struct mvx_dvfs_ctx_t *ctx = cdev->devdata;
+
+    *state = ctx->max_state;
+    return 0;
+}
+
+static int vpu_get_cur_state(struct thermal_cooling_device *cdev,
+        unsigned long *state)
+{
+    struct mvx_dvfs_ctx_t *ctx = cdev->devdata;
+
+    *state = ctx->cur_state;
+    return 0;
+}
+
+static int vpu_set_cur_state(struct thermal_cooling_device *cdev,
+        unsigned long state)
+{
+    struct mvx_dvfs_ctx_t *ctx = cdev->devdata;
+
+    if (state > ctx->max_state)
+        return -EINVAL;
+
+    if (ctx->cur_state == state)
+        return 0;
+
+    ctx->max_freq = vpufclk_freqtable[FREQ_TABLE_SIZE - state - 1].freq;
+    ctx->cur_state = state;
+    ctx->up_step_freq = ratio(mvx_dvfs_ctx.max_freq, UP_STEP_PERCENT);
+    ctx->down_step_freq = ratio(mvx_dvfs_ctx.max_freq, DOWN_STEP_PERCENT);
+    return 0;
+}
+
+static struct thermal_cooling_device_ops vpu_cooling_ops = {
+    .get_max_state		= vpu_get_max_state,
+    .get_cur_state		= vpu_get_cur_state,
+    .set_cur_state		= vpu_set_cur_state,
+};
+#endif
+
+/**
+ * Initialize the DVFS module.
+ *
+ * Must be called before any other function in this module.
+ *
+ * @param dev Device
+ */
+void mvx_dvfs_init(struct device *dev)
+{
+    if (!initialized)
+    {
+        int i;
+        int min_vmin_level;
+        sema_init(&dvfs_sem, 1);
+
+        mvx_dvfs_ctx.max_freq = get_max_clock_rate();
+        mvx_dvfs_ctx.up_step_freq = ratio(mvx_dvfs_ctx.max_freq, UP_STEP_PERCENT);
+        mvx_dvfs_ctx.down_step_freq = ratio(mvx_dvfs_ctx.max_freq, DOWN_STEP_PERCENT);
+        mvx_dvfs_ctx.min_freq = vpufclk_freqtable[0].freq;
+        min_vmin_level = vpufclk_freqtable[0].vmin_level;
+
+        /*Use the max clk freq with min vmin as bottom freq of dvfs */
+        for (i=1; i<FREQ_TABLE_SIZE; i++)
+        {
+            if (min_vmin_level < vpufclk_freqtable[i].vmin_level)
+            {
+                break;
+            }
+            mvx_dvfs_ctx.min_freq = vpufclk_freqtable[i].freq;
+        }
+
+        //mvx_dvfs_ctx.clock = devm_clk_get(dev, NULL);
+        mvx_dvfs_ctx.poll_interval_ms = POLL_INTERVAL_MS;
+
+        init_waitqueue_head(&dvfs_wq);
+        dvfs_task = kthread_run(dvfs_thread, NULL, "dvfs");
+
+#if (1 == DVFS_DEBUG_MODE)
+        if (NULL != dev && IS_ENABLED(CONFIG_DEBUG_FS))
+        {
+            sysfs_register_devices(dev);
+        }
+#endif
+
+        initialized = true;
+        shutdown = false;
+        mvx_device = dev;
+
+    }
+    else
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING, "Attempt to initialize DVFS twice");
+    }
+}
+
+/**
+ * Deinitialize the DVFS module.
+ *
+ * All remaining sessions will be unregistered.
+ *
+ * @param dev Device
+ */
+void mvx_dvfs_deinit(struct device *dev)
+{
+    int sem_failed;
+    struct list_head *entry;
+    struct list_head *safe;
+    struct session *session;
+
+    if (!initialized)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "Attempt to deinitialize DVFS when it was not initialized");
+        return;
+    }
+
+#ifdef CONFIG_THERMAL
+    if (mvx_dvfs_ctx.cdev) {
+        thermal_cooling_device_unregister(mvx_dvfs_ctx.cdev);
+        mvx_dvfs_ctx.cdev = NULL;
+    }
+#endif
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    shutdown = true;
+    if (!sem_failed)
+    {
+        up(&dvfs_sem);
+    }
+
+    wake_up_interruptible(&dvfs_wq);
+    if (!IS_ERR_OR_NULL(dvfs_task))
+    {
+        kthread_stop(dvfs_task);
+    }
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    list_for_each_safe(entry, safe, &sessions)
+    {
+        session = list_entry(entry, struct session, list);
+        free_session(session);
+    }
+
+#if (1 == DVFS_DEBUG_MODE)
+    if (NULL != dev && IS_ENABLED(CONFIG_DEBUG_FS))
+    {
+        sysfs_unregister_devices(dev);
+    }
+#endif
+
+    //devm_clk_put(mvx_device, mvx_dvfs_ctx.clock);
+    initialized = false;
+    mvx_device = NULL;
+    if (!sem_failed)
+    {
+        up(&dvfs_sem);
+    }
+}
+
+/**
+ * Register session in the DFVS module.
+ *
+ * @param session_id Session id
+ * @return True when registration was successful,
+ *         False, otherwise
+ */
+bool mvx_dvfs_register_session(const mvx_session_id session_id, bool is_encoder)
+{
+    bool success = false;
+    int sem_failed;
+
+    if (!initialized)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "DVFS module was not initialized");
+        return false;
+    }
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    if (sem_failed)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "DVFS semaphore was not obtained, sem_failed=%d", sem_failed);
+        return false;
+    }
+
+    if (shutdown)
+    {
+        up(&dvfs_sem);
+        return false;
+    }
+
+    if (get_session(session_id) != NULL)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO,
+                "this session is already registered. session=%p",
+                session_id);
+        up(&dvfs_sem);
+        return true;
+    }
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO,
+            "mvx_dvfs_register_session. session=%p", session_id);
+
+    success = allocate_session(session_id, is_encoder);
+    up(&dvfs_sem);
+
+    if (success)
+    {
+        bool adjust = true;
+#if (1 == DVFS_DEBUG_MODE)
+        /* Has DVFS been disabled through the sysfs interface? */
+        adjust = atomic_read(&dvfs_enabled);
+#endif
+        if (adjust) {
+            set_clock_rate(mvx_dvfs_ctx.max_freq);
+        }
+    }
+    wake_up_interruptible(&dvfs_wq);
+
+    return success;
+}
+
+/**
+ * Unregister session from the DFVS module.
+ *
+ * Usage of corresponding session is not permitted after this call.
+ * @param session_id Session id
+ */
+void mvx_dvfs_unregister_session(const mvx_session_id session_id)
+{
+    struct session *session;
+    int sem_failed;
+
+    if (!initialized)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "DVFS module was not initialized");
+        return;
+    }
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    if (sem_failed)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "DVFS semaphore was not obtained, %d",
+                sem_failed);
+        return;
+    }
+
+    session = get_session(session_id);
+    if (NULL != session)
+    {
+#if (1 == VPU_DDR_QOS_ENABLE)
+        if ((session->ddr_qos_read + session->ddr_qos_write) &&
+                mvx_dvfs_ctx.ddr_qos_rsum >= session->ddr_qos_read &&
+                mvx_dvfs_ctx.ddr_qos_wsum >= session->ddr_qos_write)
+        {
+            mvx_dvfs_ctx.ddr_qos_rsum -= session->ddr_qos_read;
+            mvx_dvfs_ctx.ddr_qos_wsum -= session->ddr_qos_write;
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO,
+                    "DVFS remove session[%p] ddr qos: [%d, %d]/[%d, %d]", session_id,  session->ddr_qos_read, session->ddr_qos_write, mvx_dvfs_ctx.ddr_qos_rsum, mvx_dvfs_ctx.ddr_qos_wsum);
+            session->ddr_qos_read = session->ddr_qos_write = 0;
+        }
+#endif
+
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "mvx_dvfs_unregister_session. session=%p", session_id);
+        free_session(session);
+
+    } else {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "session[%p] is already removed.", session_id);
+    }
+
+    up(&dvfs_sem);
+}
+
+void mvx_dvfs_estimate_ddr_bandwidth(struct estimate_ddr_input* input, struct estimate_ddr_output* output)
+{
+    /* predefined DDR throughput requirement for 1080p@30fps */
+    const int defined_width = 1920;
+    const int defined_height = 1080;
+    const uint32_t defined_bandwidth_tbl[2][2][2]={
+        {
+            /*decoder*/
+            {45000, 105000}, /*non-afbc[r, w]*/
+            {45000, 20000}   /*afbc*/
+        },
+        {    /*encoder*/
+            {162000, 54000}, /*non-afbc[r, w]*/
+            {162000, 54000} /*afbc*/
+        }
+    };
+    uint64_t estimated_read;
+    uint64_t estimated_write;
+
+    if (input->width == 0 || input->height == 0) {
+        input->width = defined_width;
+        input->height = defined_height;
+    }
+    if (input->fps <= 0) {
+        input->fps = VPU_DDR_QOS_PREDEFINED_FPS;
+    }
+
+    MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO, "estimate_ddr_bandwidth. isEnc=%d, isAFBC=%d, size=(%d, %d), framerate=%d.", input->isEnc, input->isAFBC, input->width, input->height, input->fps);
+
+    estimated_read = ((uint64_t)defined_bandwidth_tbl[input->isEnc][input->isAFBC][0] * ( input->width * input->height) * input->fps /(defined_width * defined_height*VPU_DDR_QOS_PREDEFINED_FPS));
+    estimated_write = ((uint64_t)defined_bandwidth_tbl[input->isEnc][input->isAFBC][1] * ( input->width * input->height) * input->fps /(defined_width * defined_height*VPU_DDR_QOS_PREDEFINED_FPS));
+    if ((estimated_read + estimated_write) < VPU_DDR_QOS_MIN)
+    {
+        estimated_read = VPU_DDR_QOS_MIN/2;
+        estimated_write = VPU_DDR_QOS_MIN/2;
+    }
+
+    if ((estimated_read + estimated_write) > VPU_DDR_QOS_MAX)
+    {
+        estimated_read = VPU_DDR_QOS_MAX/2;
+        estimated_write = VPU_DDR_QOS_MAX/2;
+    }
+
+    output->estimated_read = estimated_read;
+    output->estimated_write = estimated_write;
+}
+
+void mvx_dvfs_session_update_ddr_qos(const mvx_session_id session_id, uint32_t read_value, uint32_t write_value)
+{
+#if (1 == VPU_DDR_QOS_ENABLE)
+    struct session *session;
+    int sem_failed;
+
+#if (1 == DVFS_DEBUG_MODE)
+    if (0 == atomic_read(&ddr_qos_enabled))
+    {
+        return;
+    }
+#endif
+
+    sem_failed = down_interruptible(&dvfs_sem);
+    if (sem_failed)
+    {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_ERROR,
+                "DVFS semaphore was not obtained, %d",
+                sem_failed);
+        return;
+    }
+
+    session = get_session(session_id);
+    if (NULL != session && (session->ddr_qos_read != read_value || session->ddr_qos_write != write_value)
+            && mvx_dvfs_ctx.ddr_qos_rsum >= session->ddr_qos_read
+            && mvx_dvfs_ctx.ddr_qos_wsum >= session->ddr_qos_write)
+    {
+        mvx_dvfs_ctx.ddr_qos_rsum -= session->ddr_qos_read;
+        mvx_dvfs_ctx.ddr_qos_rsum += read_value;
+        session->ddr_qos_read = read_value;
+        mvx_dvfs_ctx.ddr_qos_wsum -= session->ddr_qos_write;
+        mvx_dvfs_ctx.ddr_qos_wsum += write_value;
+        session->ddr_qos_write = write_value;
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_INFO,
+                "DVFS update session[%p] ddr qos: [%d, %d]/[%d, %d]", session_id,  read_value, write_value, mvx_dvfs_ctx.ddr_qos_rsum, mvx_dvfs_ctx.ddr_qos_wsum);
+    }
+
+    up(&dvfs_sem);
+#endif
+}
+
diff --git a/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.h
new file mode 100755
index 000000000000..f97b6f04b8bd
--- /dev/null
+++ b/drivers/media/platform/spacemit/vpu_k1x/mvx_dvfs.h
@@ -0,0 +1,90 @@
+/*
+ * The confidential and proprietary information contained in this file may
+ * only be used by a person authorised under and to the extent permitted
+ * by a subsisting licensing agreement from Arm Technology (China) Co., Ltd.
+ *
+ *            (C) COPYRIGHT 2021-2021 Arm Technology (China) Co., Ltd.
+ *                ALL RIGHTS RESERVED
+ *
+ * This entire notice must be reproduced on all copies of this file
+ * and copies of this file may only be made by a person if such person is
+ * permitted to do so under the terms of a subsisting license agreement
+ * from Arm Technology (China) Co., Ltd.
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef _MVX_DVFS_H_
+#define _MVX_DVFS_H_
+
+typedef void *mvx_session_id;
+
+struct estimate_ddr_input
+{
+    int width;
+    int height;
+    int isAFBC;
+    int fps;
+    int isEnc;
+};
+
+struct estimate_ddr_output
+{
+    uint64_t estimated_read;
+    uint64_t estimated_write;
+};
+
+/**
+ * Initialize the DVFS module.
+ *
+ * Must be called before any other function in this module.
+ *
+ * @param dev Device
+ */
+void mvx_dvfs_init(struct device *dev);
+
+/**
+ * Deinitialize the DVFS module.
+ *
+ * All remaining sessions will be unregistered.
+ *
+ * @param dev Device
+ */
+void mvx_dvfs_deinit(struct device *dev);
+
+/**
+ * Register session in the DFVS module.
+ *
+ * @param session_id Session id
+ * @return True when registration was successful,
+ *         False, otherwise
+ */
+bool mvx_dvfs_register_session(const mvx_session_id session_id, bool is_encoder);
+
+/**
+ * Unregister session from the DFVS module.
+ *
+ * Usage of corresponding session is not permitted after this call.
+ * @param session_id Session id
+ */
+void mvx_dvfs_unregister_session(const mvx_session_id session_id);
+
+void mvx_dvfs_estimate_ddr_bandwidth(struct estimate_ddr_input* input, struct estimate_ddr_output* output);
+
+void mvx_dvfs_session_update_ddr_qos(const mvx_session_id session_id, uint32_t read_value, uint32_t write_value);
+#endif /* MVX_DVFS_H */
diff --git a/drivers/media/vpu/mvx_log.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_log.c
similarity index 97%
rename from drivers/media/vpu/mvx_log.c
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_log.c
index 6c05ed3fb21f..b4b31728caa3 100755
--- a/drivers/media/vpu/mvx_log.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/mvx_log.c
@@ -564,15 +564,16 @@ static void drain_dmesg_data(struct mvx_log_drain *drain,
 
 		while (length > 0) {
 			size_t j = min_t(size_t, length, 32);
-			char buf[3 + j * 3 + 1];
+			size_t buf_size=3 + j * 3 + 1;
+			char buf[3 + 32 * 3 + 1];
 			size_t n = 0;
 
 			length -= j;
 
-			n += scnprintf(&buf[n], sizeof(buf) - n, "   ");
+			n += scnprintf(&buf[n], (buf_size) - n, "   ");
 
 			while (j-- > 0)
-				n += scnprintf(&buf[n], sizeof(buf) - n,
+				n += scnprintf(&buf[n], (buf_size) - n,
 					       " %02x", *p++);
 
 			pr_info("%s\n", buf);
@@ -899,16 +900,16 @@ int mvx_log_group_add(struct mvx_log *log,
 	/* Store reference to group object in inode private data. */
 	group->dentry->d_inode->i_private = group;
 
-	/* Create <group>/severity. */
-	debugfs_create_u32("severity", 0600, group->dentry, &group->severity);
+    /* Create <group>/severity. */
+    debugfs_create_u32("severity", 0600, group->dentry, &group->severity);
 
-	/* Create <group>/drain. */
-	dentry = debugfs_create_file("drain", 0600, group->dentry, NULL, &group_drain_fops);
-	if (IS_ERR_OR_NULL(dentry)) {
-		pr_err("MVX: Failed to create '%s/severity' value.\n", name);
-		ret = -ENOMEM;
-		goto error;
-	}
+    /* Create <group>/drain. */
+    dentry = debugfs_create_file("drain", 0600, group->dentry, NULL, &group_drain_fops);
+    if (IS_ERR_OR_NULL(dentry)) {
+        pr_err("MVX: Failed to create '%s/severity' value.\n", name);
+        ret = -ENOMEM;
+        goto error;
+    }
 
 	return 0;
 
diff --git a/drivers/media/vpu/mvx_log.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_log.h
similarity index 100%
rename from drivers/media/vpu/mvx_log.h
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_log.h
diff --git a/drivers/media/vpu/mvx_log_group.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_log_group.c
similarity index 100%
rename from drivers/media/vpu/mvx_log_group.c
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_log_group.c
diff --git a/drivers/media/vpu/mvx_log_group.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_log_group.h
similarity index 100%
rename from drivers/media/vpu/mvx_log_group.h
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_log_group.h
diff --git a/drivers/media/vpu/mvx_log_ram.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_log_ram.h
similarity index 100%
rename from drivers/media/vpu/mvx_log_ram.h
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_log_ram.h
diff --git a/drivers/media/vpu/mvx_pm_runtime.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_pm_runtime.c
similarity index 66%
rename from drivers/media/vpu/mvx_pm_runtime.c
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_pm_runtime.c
index 8a6c96dea25d..1083c7f91fbb 100755
--- a/drivers/media/vpu/mvx_pm_runtime.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/mvx_pm_runtime.c
@@ -30,18 +30,25 @@
  */
 
 #include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
 #include "mvx_log_group.h"
+#include "mvx_dev.h"
 
 int mvx_pm_runtime_get_sync(struct device *dev)
 {
 #ifdef CONFIG_PM
 	int ret;
+	struct mvx_dev_ctx *ctx;
+	ctx = dev_get_drvdata(dev);
 
+	mutex_lock(&ctx->pm_mutex);
 	ret = pm_runtime_get_sync(dev);
 	if (ret < 0)
 		MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
 			      "PM runtime get sync failed! ret=%d", ret);
 
+       mutex_unlock(&ctx->pm_mutex);
 	return ret;
 #else /* !CONFIG_PM  */
 	return 1;
@@ -51,15 +58,28 @@ int mvx_pm_runtime_get_sync(struct device *dev)
 int mvx_pm_runtime_put_sync(struct device *dev)
 {
 #ifdef CONFIG_PM
-	int ret;
+    int ret;
+    int retry_count = 10;
+    struct mvx_dev_ctx *ctx;
+    ctx = dev_get_drvdata(dev);
 
-	ret = pm_runtime_put_sync(dev);
-	if (ret < 0)
-		MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
-			      "PM runtime put sync failed! ret=%d", ret);
+    mutex_lock(&ctx->pm_mutex);
+    ret = pm_runtime_put_sync(dev);
+    if (ret < 0) {
+        MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING,
+                "PM runtime put sync failed! ret=%d", ret);
+        while (ret == -EAGAIN && retry_count > 0) {
+            msleep(20);
+            pm_runtime_get_noresume(dev);
+            ret = pm_runtime_put_sync(dev);
+            MVX_LOG_PRINT(&mvx_log_dev, MVX_LOG_WARNING, "PM runtime put sync return EAGAIN. try to put sync again. ret=%d, retry_count=%d", ret, retry_count);
+            retry_count--;
+        }
+    }
 
-	return ret;
+    mutex_unlock(&ctx->pm_mutex);
+    return ret;
 #else /* !CONFIG_PM  */
-	return 0;
+    return 0;
 #endif /* CONFIG_PM */
 }
diff --git a/drivers/media/vpu/mvx_pm_runtime.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_pm_runtime.h
similarity index 100%
rename from drivers/media/vpu/mvx_pm_runtime.h
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_pm_runtime.h
diff --git a/drivers/media/vpu/mvx_seq.c b/drivers/media/platform/spacemit/vpu_k1x/mvx_seq.c
similarity index 100%
rename from drivers/media/vpu/mvx_seq.c
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_seq.c
diff --git a/drivers/media/vpu/mvx_seq.h b/drivers/media/platform/spacemit/vpu_k1x/mvx_seq.h
similarity index 100%
rename from drivers/media/vpu/mvx_seq.h
rename to drivers/media/platform/spacemit/vpu_k1x/mvx_seq.h
diff --git a/drivers/media/vpu/sconscript b/drivers/media/platform/spacemit/vpu_k1x/sconscript
similarity index 100%
rename from drivers/media/vpu/sconscript
rename to drivers/media/platform/spacemit/vpu_k1x/sconscript
diff --git a/drivers/media/vpu/Kconfig b/drivers/media/vpu/Kconfig
deleted file mode 100755
index f2bc23094530..000000000000
--- a/drivers/media/vpu/Kconfig
+++ /dev/null
@@ -1,25 +0,0 @@
-config VIDEO_LINLON
-	tristate "Linlon VPU support."
-	depends on VIDEO_DEV
-	select VIDEOBUF2_VMALLOC
-	select VIDEOBUF2_CORE
-	select DMA_SHARED_BUFFER
-	select VIDEOBUF2_MEMOPS
-	select VIDEOBUF2_DMA_SG
-	default n
-	help
-		This enables support for the Linlon VPU family.
-
-config VIDEO_LINLON_FTRACE
-	depends on VIDEO_LINLON
-	bool "Send kernel space logs to ftrace."
-	default n
-	help
-		Send kernel space logs to ftrace.
-
-config VIDEO_LINLON_PRINT_FILE
-	depends on VIDEO_LINLON
-	bool "Append file and line number to kernel space log messages."
-	default y
-	help
-		Append file and line number to kernel space log messages.
diff --git a/drivers/media/vpu/modules.builtin b/drivers/media/vpu/modules.builtin
deleted file mode 100755
index e69de29bb2d1..000000000000
-- 
2.47.0

