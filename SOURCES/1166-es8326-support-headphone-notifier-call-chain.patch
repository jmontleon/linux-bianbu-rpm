From 82016075ac3c0db83ee99557f03bccbe21018468 Mon Sep 17 00:00:00 2001
From: xuhaodong <haodong.xu@spacemit.com>
Date: Tue, 10 Sep 2024 10:20:32 +0800
Subject: [PATCH 1166/1448] es8326:support headphone notifier call chain

Change-Id: I832160f10cf833f62acd05bafc9d91e811d98c22
---
 include/soc/spacemit/spacemit_panel.h |  13 ++
 sound/soc/codecs/es8326.c             | 176 ++++++++++++++++++++++----
 2 files changed, 162 insertions(+), 27 deletions(-)

diff --git a/include/soc/spacemit/spacemit_panel.h b/include/soc/spacemit/spacemit_panel.h
index cd1d7b1fa634..08a82895673b 100644
--- a/include/soc/spacemit/spacemit_panel.h
+++ b/include/soc/spacemit/spacemit_panel.h
@@ -30,4 +30,17 @@ enum{
 extern int spacemit_hdmi_register_client(struct notifier_block *nb);
 extern int spacemit_hdmi_unregister_client(struct notifier_block *nb);
 
+typedef enum{
+	HEADSET_EVENT_CONNECTED = 0,
+	HEADSET_EVENT_DISCONNECTED,
+	HEADPHONE_EVENT_CONNECTED,
+	HEADPHONE_EVENT_DISCONNECTED,
+	HPMIC_EVENT_CONNECTED,
+	HPMIC_EVENT_DISCONNECTED,
+} __alsa_codec_event_e;
+
+extern int spacemit_headphone_register_client(struct notifier_block *nb);
+extern int spacemit_headphone_unregister_client(struct notifier_block *nb);
+extern int spacemit_headphone_notifier_call_chain(__alsa_codec_event_e val, char *v);
+
 #endif
diff --git a/sound/soc/codecs/es8326.c b/sound/soc/codecs/es8326.c
index 8827194e9efe..3b11a575bbe7 100644
--- a/sound/soc/codecs/es8326.c
+++ b/sound/soc/codecs/es8326.c
@@ -19,6 +19,10 @@
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 #include "es8326.h"
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+#include <linux/notifier.h>
+#include <soc/spacemit/spacemit_panel.h>
+#endif
 
 struct es8326_priv {
 	struct clk *mclk;
@@ -51,11 +55,16 @@ struct es8326_priv {
 	int hp_irq;
 	int mic_gpio;
 	int mic_irq;
+	int typec_hp;
 	struct delayed_work hpmic_detect_work;
 	unsigned int coeff;
 #endif
 };
 
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static struct es8326_priv *es8326_priv_ptr;
+#endif
+
 static int es8326_crosstalk1_get(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
@@ -580,8 +589,9 @@ static int es8326_mute(struct snd_soc_dai *dai, int mute, int direction)
 			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF,
 					0x30, 0x00);
 			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
-			if (!es8326->hp)
+			if (!es8326->hp && !es8326->typec_hp) {
 				es8326_enable_spk(es8326, false);
+			}
 			#endif
 		} else {
 			regmap_update_bits(es8326->regmap,  ES8326_ADC_MUTE,
@@ -611,8 +621,9 @@ static int es8326_mute(struct snd_soc_dai *dai, int mute, int direction)
 			regmap_update_bits(es8326->regmap, ES8326_DAC_MUTE,
 					ES8326_MUTE_MASK, ~(ES8326_MUTE));
 			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
-			if (!es8326->hp)
-                                es8326_enable_spk(es8326, true);
+			if (!es8326->hp && !es8326->typec_hp) {
+				es8326_enable_spk(es8326, true);
+			}
 			#endif
 		} else {
 			msleep(300);
@@ -826,6 +837,9 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 	if ((iface & ES8326_HPINSERT_FLAG) == 0) {
 		/* Jack unplugged or spurious IRQ */
 		dev_dbg(comp->dev, "No headset detected\n");
+		#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+		spacemit_headphone_notifier_call_chain(HEADSET_EVENT_DISCONNECTED, "headset");
+		#else
 		es8326_disable_micbias(es8326->component);
 		if (es8326->jack->status & SND_JACK_HEADPHONE) {
 			dev_dbg(comp->dev, "Report hp remove event\n");
@@ -849,6 +863,7 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 		regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x0a);
 		regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x03);
 		regmap_write(es8326->regmap, ES8326_INT_SOURCE, ES8326_INT_SRC_PIN9);
+		#endif
 		/*
 		 * Inverted HPJACK_POL bit to trigger one IRQ to double check HP Removal event
 		 */
@@ -905,10 +920,17 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 		}
 		if ((iface & ES8326_HPBUTTON_FLAG) == 0x01) {
 			dev_dbg(comp->dev, "Headphone detected\n");
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			spacemit_headphone_notifier_call_chain(HEADPHONE_EVENT_CONNECTED, "headphone");
+			#else
 			snd_soc_jack_report(es8326->jack,
 					SND_JACK_HEADPHONE, SND_JACK_HEADSET);
+			#endif
 		} else {
 			dev_dbg(comp->dev, "Headset detected\n");
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			spacemit_headphone_notifier_call_chain(HEADSET_EVENT_CONNECTED, "headset");
+			#else
 			snd_soc_jack_report(es8326->jack,
 					SND_JACK_HEADSET, SND_JACK_HEADSET);
 
@@ -921,6 +943,7 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 			regmap_update_bits(es8326->regmap, ES8326_PGA_PDN,
 					0x08, 0x00);
 			usleep_range(10000, 15000);
+			#endif
 		}
 	}
 exit:
@@ -964,31 +987,10 @@ static void es8326_hpmic_detect_handler(struct work_struct *work)
 	dev_dbg(comp->dev, "jack_status:%d\n", jack_status);
 	if ((jack_status & SND_JACK_HEADSET) == 0) {
 		/* Jack unplugged or spurious IRQ */
-		es8326_disable_micbias(es8326->component);
-		es8326->hp = 0;
-		regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
-		regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x0a);
-		regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x03);
-
+		spacemit_headphone_notifier_call_chain(HPMIC_EVENT_DISCONNECTED, "hpmic");
 	} else {
 		if (es8326->hp == 0) {
-			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
-			usleep_range(50000, 70000);
-			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
-			regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x1f);
-			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x08);
-			usleep_range(10000, 15000);
-			es8326->hp = 1;
-			regmap_write(es8326->regmap, ES8326_ADC_SCALE, 0x33);
-			regmap_update_bits(es8326->regmap, ES8326_PGA_PDN,
-					0x08, 0x08);
-			regmap_update_bits(es8326->regmap, ES8326_PGAGAIN,
-					0x80, 0x80);
-			regmap_write(es8326->regmap, ES8326_ADC1_SRC, 0x00);
-			regmap_write(es8326->regmap, ES8326_ADC2_SRC, 0x00);
-			regmap_update_bits(es8326->regmap, ES8326_PGA_PDN,
-					0x08, 0x00);
-			usleep_range(10000, 15000);
+			spacemit_headphone_notifier_call_chain(HPMIC_EVENT_CONNECTED, "hpmic");
 		}
 	}
 	snd_soc_jack_report(es8326->jack,
@@ -1064,6 +1066,7 @@ static int es8326_calibrate(struct snd_soc_component *component)
 static int es8326_init(struct snd_soc_component *component)
 {
 	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	es8326_priv_ptr = es8326;
 
 	/* reset internal clock state */
 	regmap_write(es8326->regmap, ES8326_RESET, 0x1f);
@@ -1142,7 +1145,7 @@ static int es8326_init(struct snd_soc_component *component)
 
 	es8326->jack_remove_retry = 0;
 	es8326->hp = 0;
-
+	es8326->typec_hp = 0;
 	return 0;
 }
 
@@ -1293,6 +1296,124 @@ static int es8326_suspend(struct snd_soc_component *component)
 }
 #endif
 
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static BLOCKING_NOTIFIER_HEAD(headphone_notifier_list);
+
+/* spacemit_headphone_register_client - register a client notifier */
+int spacemit_headphone_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&headphone_notifier_list, nb);
+}
+EXPORT_SYMBOL(spacemit_headphone_register_client);
+
+/* spacemit_headphone_unregister_client - unregister a client notifier */
+int spacemit_headphone_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&headphone_notifier_list, nb);
+}
+EXPORT_SYMBOL(spacemit_headphone_unregister_client);
+
+/* spacemit_headphone_notifier_call_chain - notify clients of headphone status events */
+int spacemit_headphone_notifier_call_chain(__alsa_codec_event_e val, char *v)
+{
+	return blocking_notifier_call_chain(&headphone_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(spacemit_headphone_notifier_call_chain);
+
+int headphone_connect_event(struct notifier_block *nb, unsigned long event,
+    void *v)
+{
+	switch(event){
+	case HEADSET_EVENT_CONNECTED:
+		pr_info("codec got the chain event: HEADSET_EVENT_CONNECTED\n");
+		if (strcmp(v, "typec") == 0) {
+			es8326_priv_ptr->typec_hp = 1;
+		}
+		snd_soc_jack_report(es8326_priv_ptr->jack,
+			SND_JACK_HEADSET, SND_JACK_HEADSET);
+		es8326_enable_spk(es8326_priv_ptr, false);
+		es8326_enable_micbias(es8326_priv_ptr->component);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGA_PDN,
+				0x08, 0x08);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGAGAIN,
+				0x80, 0x80);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_ADC1_SRC, 0x00);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_ADC2_SRC, 0x00);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGA_PDN,
+				0x08, 0x00);
+		usleep_range(10000, 15000);
+		break;
+
+	case HEADSET_EVENT_DISCONNECTED:
+		pr_info("codec got the chain event: HEADSET_EVENT_DISCONNECTED\n");
+		if (strcmp(v, "headset") == 0 || strcmp(v, "headphone") == 0) {
+			es8326_priv_ptr->hp = 0;
+		}
+		if (strcmp(v, "typec") == 0) {
+			es8326_priv_ptr->typec_hp = 0;
+		}
+		if (es8326_priv_ptr->hp == 0 && es8326_priv_ptr->typec_hp == 0) {
+			es8326_disable_micbias(es8326_priv_ptr->component);
+			dev_dbg(es8326_priv_ptr->component->dev, "Report hp remove event\n");
+			es8326_enable_spk(es8326_priv_ptr, true);
+			snd_soc_jack_report(es8326_priv_ptr->jack, 0, SND_JACK_HEADSET);
+			/* mute adc when mic path switch */
+			regmap_write(es8326_priv_ptr->regmap, ES8326_ADC1_SRC, es8326_priv_ptr->mic1_src);
+			regmap_write(es8326_priv_ptr->regmap, ES8326_ADC2_SRC, es8326_priv_ptr->mic2_src);
+			regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+			regmap_write(es8326_priv_ptr->regmap, ES8326_SYS_BIAS, 0x0a);
+			regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x03);
+			regmap_write(es8326_priv_ptr->regmap, ES8326_INT_SOURCE, ES8326_INT_SRC_PIN9);
+		}
+		break;
+
+	case HEADPHONE_EVENT_CONNECTED:
+		snd_soc_jack_report(es8326_priv_ptr->jack, SND_JACK_HEADPHONE, SND_JACK_HEADPHONE);
+		break;
+
+	case HEADPHONE_EVENT_DISCONNECTED:
+		snd_soc_jack_report(es8326_priv_ptr->jack, 0, SND_JACK_HEADPHONE);
+		break;
+
+	case HPMIC_EVENT_CONNECTED:
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+		usleep_range(50000, 70000);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_SYS_BIAS, 0x1f);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x08);
+		usleep_range(10000, 15000);
+		es8326_priv_ptr->hp = 1;
+		regmap_write(es8326_priv_ptr->regmap, ES8326_ADC_SCALE, 0x33);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGA_PDN,
+				0x08, 0x08);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGAGAIN,
+				0x80, 0x80);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_ADC1_SRC, 0x00);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_ADC2_SRC, 0x00);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_PGA_PDN,
+				0x08, 0x00);
+		usleep_range(10000, 15000);
+		break;
+
+	case HPMIC_EVENT_DISCONNECTED:
+		es8326_disable_micbias(es8326_priv_ptr->component);
+		es8326_priv_ptr->hp = 0;
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+		regmap_write(es8326_priv_ptr->regmap, ES8326_SYS_BIAS, 0x0a);
+		regmap_update_bits(es8326_priv_ptr->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x03);
+		break;
+
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block headphone_init_notifier = {
+	.notifier_call = headphone_connect_event,
+};
+#endif
+
 static int es8326_probe(struct snd_soc_component *component)
 {
 	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
@@ -1341,6 +1462,7 @@ static int es8326_probe(struct snd_soc_component *component)
 
 #ifdef SPACEMIT_CONFIG_CODEC_ES8326
 	es8326_init(component);
+	spacemit_headphone_register_client(&headphone_init_notifier);
 #else
 	es8326_resume(component);
 #endif
-- 
2.47.0

