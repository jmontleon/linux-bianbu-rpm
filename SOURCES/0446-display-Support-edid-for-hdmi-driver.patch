From 601f87e080d598ea17b79b5e5e0c56702dc56885 Mon Sep 17 00:00:00 2001
From: lilijun <lijun.li@spacemit.com>
Date: Wed, 28 Feb 2024 12:28:40 +0800
Subject: [PATCH 0446/1448] display: Support edid for hdmi driver

Change-Id: Id56a86d4e128455ea6832a493d2518924cb2a8b2
---
 drivers/gpu/drm/spacemit/spacemit_dpu.c  |   1 +
 drivers/gpu/drm/spacemit/spacemit_hdmi.c | 425 +++++++++++++++++++----
 2 files changed, 364 insertions(+), 62 deletions(-)

diff --git a/drivers/gpu/drm/spacemit/spacemit_dpu.c b/drivers/gpu/drm/spacemit/spacemit_dpu.c
index 7d4d489d66a0..cd15627ee2d4 100644
--- a/drivers/gpu/drm/spacemit/spacemit_dpu.c
+++ b/drivers/gpu/drm/spacemit/spacemit_dpu.c
@@ -973,6 +973,7 @@ static int spacemit_dpu_probe(struct platform_device *pdev)
 
 	pm_runtime_put_sync(dpu->dev);
 	msleep(10);
+	pm_runtime_get_sync(&pdev->dev);
 
 	/*
 	 * To keep bootloader logo on, below operations must be
diff --git a/drivers/gpu/drm/spacemit/spacemit_hdmi.c b/drivers/gpu/drm/spacemit/spacemit_hdmi.c
index 2afc647f8834..eeddc52fc9f7 100644
--- a/drivers/gpu/drm/spacemit/spacemit_hdmi.c
+++ b/drivers/gpu/drm/spacemit/spacemit_hdmi.c
@@ -26,7 +26,11 @@
 #include "spacemit_lib.h"
 #include "spacemit_dpu.h"
 
+#define SPACEMIT_HDMI_PHY_STATUS        0xC
+#define SPACEMIT_HDMI_PHY_HPD           0x1000
+
 struct hdmi_data_info {
+	uint8_t edid[128];
 	int vic;
 	bool sink_has_audio;
 	unsigned int enc_in_format;
@@ -54,7 +58,7 @@ struct spacemit_hdmi {
 
 	unsigned int tmds_rate;
 
-	struct hdmi_data_info	hdmi_data;
+	struct hdmi_data_info *hdmi_data;
 	struct drm_display_mode previous_mode;
 };
 
@@ -64,18 +68,25 @@ struct spacemit_hdmi {
 #define connector_to_spacemit_hdmi(connector) \
 	container_of(connector, struct spacemit_hdmi, connector)
 
-static inline u8 hdmi_readb(struct spacemit_hdmi *hdmi, u16 offset)
+static inline u32 hdmi_readb(struct spacemit_hdmi *hdmi, u16 offset)
 {
 	return readl_relaxed(hdmi->regs + (offset));
 }
 
 static inline void hdmi_writeb(struct spacemit_hdmi *hdmi, u16 offset, u32 val)
 {
-	void __iomem *hdmi_addr = (void __iomem *)ioremap(0xc0400500, 200);
-	//writel_relaxed(val, hdmi->regs + (offset));
-	writel_relaxed(val, hdmi_addr + (offset));
+	writel_relaxed(val, hdmi->regs + (offset));
 }
 
+static int hdmi_get_plug_in_status(struct spacemit_hdmi *hdmi)
+{
+	u32 value;
+	value = readl_relaxed(hdmi->regs + SPACEMIT_HDMI_PHY_STATUS) & SPACEMIT_HDMI_PHY_HPD;
+
+	return !!value;
+}
+
+#if 0
 static inline void hdmi_modb(struct spacemit_hdmi *hdmi, u16 offset,
 			     u32 msk, u32 val)
 {
@@ -84,6 +95,7 @@ static inline void hdmi_modb(struct spacemit_hdmi *hdmi, u16 offset,
 	temp |= val & msk;
 	hdmi_writeb(hdmi, offset, temp);
 }
+#endif
 
 static void spacemit_hdmi_set_pwr_mode(struct spacemit_hdmi *hdmi, int mode)
 {
@@ -134,9 +146,9 @@ static int spacemit_hdmi_config_video_avi(struct spacemit_hdmi *hdmi,
 						      &hdmi->connector,
 						      mode);
 
-	if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)
+	if (hdmi->hdmi_data->enc_out_format == HDMI_COLORSPACE_YUV444)
 		frame.avi.colorspace = HDMI_COLORSPACE_YUV444;
-	else if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)
+	else if (hdmi->hdmi_data->enc_out_format == HDMI_COLORSPACE_YUV422)
 		frame.avi.colorspace = HDMI_COLORSPACE_YUV422;
 	else
 		frame.avi.colorspace = HDMI_COLORSPACE_RGB;
@@ -150,65 +162,331 @@ static int spacemit_hdmi_config_video_timing(struct spacemit_hdmi *hdmi,
 	return 0;
 }
 
-static int spacemit_hdmi_setup(struct spacemit_hdmi *hdmi,
-			   struct drm_display_mode *mode)
-{
-	void __iomem *hdmi_addr = (void __iomem *)ioremap(0xC0400500, 1);
-	u32 value;
+enum bit_depth{
+	EIGHT_BPP = 0,
+	TEN_BPP = 1,
+	TWELVE_BPP =2,
+};
 
-	// hdmi config
-	if (mode->hdisplay > 1024) {
-	// 1920x1080
-	#if 0
+int power_of_two(int n) {
+	int result = 1;
+	for (int i = 0; i < n; ++i) {
+		result <<= 1;
+	}
+
+	return result;
+}
 
-		writel(0x4d, hdmi_addr + 0x34);
-		writel(0x20200000, hdmi_addr + 0xe8);
-		writel(0x509D453E, hdmi_addr + 0xec);
-		writel(0x821, hdmi_addr + 0xf0);
-		writel(0x3, hdmi_addr + 0xe4);
+int pll8_bit_5_6 (int bit_clock, int n){
+	int ret = 0;
+	bit_clock = bit_clock / n;
+
+	if (bit_clock < 425)
+		ret = 3;
+	else if (bit_clock < 850)
+		ret = 2;
+	else if (bit_clock < 1700)
+		ret = 1;
+	else
+		ret = 0;
 
-		udelay(2);
-		value = readl_relaxed(hdmi_addr + 0xe4);
-		DRM_INFO("%s() hdmi 0xe4 0x%x\n", __func__, value);
+	return ret;
+}
 
-		writel(0x30184000, hdmi_addr + 0x28);
-	#else
+int pll6_bit_4_5 (int bit_clock, int n){
+	int ret = 0;
+	bit_clock = bit_clock / n;
+
+	if (bit_clock < 338)
+		ret = 0;
+	else if (bit_clock < 425)
+		ret = 1;
+	else if (bit_clock < 675)
+		ret = 0;
+	else if (bit_clock < 850)
+		ret = 1;
+	else if (bit_clock < 1350)
+		ret = 0;
+	else if (bit_clock < 1700)
+		ret = 1;
+	else
+		ret = 0;
 
-		writel(0xEE40410F, hdmi_addr + 0xe0);
-		writel(0x0000005d, hdmi_addr + 0x34);
-		writel(0x2022C000, hdmi_addr + 0xe8);
-		writel(0x508D414D, hdmi_addr + 0xec);
+	return ret;
+}
 
-		writel(0x00000901, hdmi_addr + 0xf0);
-		writel(0x3, hdmi_addr + 0xe4);
+int pll5_bit_0_2 (int bit_clock, int n){
+	int value =  bit_clock * power_of_two(pll8_bit_5_6(bit_clock, n)) / n;
+	int ret;
 
-		udelay(2);
-		value = readl_relaxed(hdmi_addr + 0xe4);
-		DRM_INFO("%s() hdmi 0xe4 0x%x\n", __func__, value);
+	if (value < 1830)
+		ret = 0;
+	else if (value < 2030)
+		ret = 1;
+	else if (value < 2275)
+		ret = 2;
+	else if (value < 2520)
+		ret = 3;
+	else if (value < 2765)
+		ret = 4;
+	else if (value < 3015)
+		ret = 5;
+	else if (value < 3260)
+		ret = 6;
+	else
+		ret = 7;
 
-		writel(0x3018C001, hdmi_addr + 0x28);
+	return ret;
+}
 
-	#endif
+int PLL9_BIT0_1[3] = {0x0, 0x1, 0x2};
+
+void pll_reg_cal(int bit_clock, int ref_clock, int n, int *integer_part, u32 *hmdi_e8_reg) {
+	long long int_para = 1000000000;
+	long long value = (power_of_two(pll8_bit_5_6(bit_clock, n))) * bit_clock * int_para / (n * (pll6_bit_4_5(bit_clock, n) + 1) * ref_clock);
+	long long integer = (power_of_two(pll8_bit_5_6(bit_clock, n)))* bit_clock / (n * (pll6_bit_4_5(bit_clock, n) + 1) * ref_clock) * int_para;
+	long long fraction = value - integer;
+	bool negative = false;
+	int bit = 0;
+	int frac_20bit = 0;
+	int pll2_reg = 0;
+	int pll1_reg = 0;
+	int pll0_reg = 0;
+
+	negative =  fraction > 500000000 ? true : false;
+	fraction = negative ? 1000000000 - fraction : fraction;
+	*integer_part = negative ? integer/int_para + 1 : integer/int_para;
+
+
+	for (int i = 0; i < 20; i++){
+		if (bit >= int_para) {
+			frac_20bit |= 1 << (19 - i);
+			fraction -= int_para;
+		}
+		fraction *= 2;
+		bit = fraction;
+	}
 
+	if (!negative){
+		pll2_reg = ((frac_20bit & 0xF0000) >> 16) | (1 << 5);
 	} else {
-		// 640x480
-		writel(0x40, hdmi_addr + 0x34);
-		writel(0x20200000, hdmi_addr + 0xe8);
-		writel(0x508d425a, hdmi_addr + 0xec);
-		writel(0x861, hdmi_addr + 0xf0);
-		writel(0x3, hdmi_addr + 0xe4);
-
-		udelay(2);
-		value = readl_relaxed(hdmi_addr + 0xe4);
-		DRM_DEBUG("%s() hdmi 0xe4 0x%x\n", __func__, value);
-
-		writel(0x28008320, hdmi_addr + 0x20);
-		writel(0x1e00a20d, hdmi_addr + 0x24);
-		writel(0x0e404000, hdmi_addr + 0x28);
+		frac_20bit = (~frac_20bit + 1) & 0xfffff;
+		pll2_reg = 0x10 | ((frac_20bit & 0xF0000) >> 16) | (1 << 5);
 	}
 
-	spacemit_hdmi_config_video_timing(hdmi, mode);
+	pll1_reg = (frac_20bit & 0xFF00) >> 8;
+	pll0_reg = frac_20bit & 0xFF;
+	*hmdi_e8_reg = (0x20 << 24) | (pll2_reg << 16) | (pll1_reg << 8) | (pll0_reg);
+}
+
+int pll_reg (struct spacemit_hdmi *hdmi, int pixel_clock) {
+	int pll9_reg = 0, pll8_reg = 0, pll7_reg = 0, pll6_reg = 0, pll5_reg = 0, pll4_reg = 0;
+	int n = 100;
+	int ref_clock = 24;
+	int hdmi_ec_reg = 0;
+	int hdmi_f0_reg = 0;
+	int hdmi_e8_reg = 0;
+	int pow = 0;
+	int bit_clock = pixel_clock * 125 / 100;
+	int integer_part = 0;
+
+	pll_reg_cal(bit_clock, ref_clock, n, &integer_part, &hdmi_e8_reg);
+
+	pll9_reg = (2 << 2) | PLL9_BIT0_1[TEN_BPP];
+	pll8_reg = (0 << 7) | ((pll8_bit_5_6(bit_clock, n) << 5)) | 1;
+	pll7_reg = 0x50;
+	pll6_reg = 0xD | (pll6_bit_4_5(bit_clock, n) << 4) | (2 << 6);
+	pll5_reg = 0x40 | pll5_bit_0_2(bit_clock, n);
+
+	pow = (pll8_bit_5_6(bit_clock, n));
+
+	pll4_reg = integer_part;
+
+	hdmi_ec_reg = (pll7_reg << 24) | (pll6_reg << 16) | (pll5_reg << 8) | (pll4_reg);
+	hdmi_f0_reg = (pll9_reg << 8) | (pll8_reg);
+
+	writel(hdmi_e8_reg, hdmi->regs + 0xe8);
+	writel(hdmi_ec_reg, hdmi->regs + 0xec);
+
+	writel(hdmi_f0_reg, hdmi->regs + 0xf0);
+
+	return 0;
+}
+
+static void hdmi_i2c_timing(struct spacemit_hdmi *hdmi)
+{
+	uint32_t reg = 0;
+	uint32_t apb_clk = 153500*1000;/*Hz*/
+	uint32_t apb_time = 1000*1000*1000 / apb_clk; /*ns*/
+	uint32_t i2c_clk = 100*1000; /*Hz*/
+	uint32_t i2c_time = 1000*1000*1000 / i2c_clk; /*ns*/
+	uint32_t scl_high_time, scl_low_time; /*ns*/
+	uint32_t scl_high_count = 0, scl_low_count = 0;
+
+	DRM_DEBUG("%s()\n", __func__);
+
+	reg = hdmi_readb(hdmi, 0x18);
+	DRM_DEBUG("%s() hdmi 0x18 #1 0x%x\n", __func__, reg);
+
+	scl_high_time = i2c_time / 2;
+	scl_low_time = i2c_time / 2;
+	scl_high_count = scl_high_time / apb_time;
+	scl_low_count = scl_low_time / apb_time;
+
+	scl_high_count = (scl_high_count - 3) >> 2;
+	scl_low_count = (scl_low_count - 3) >> 2;
+
+	reg &= ~0x7FFFF;
+	reg |= 5 << 16; /*glitch*/
+	reg |= scl_high_count << 8; /*high. time = value *4 + 3*/
+	reg |= scl_low_count; /*low. time = value *4 +3*/
+	DRM_DEBUG("%s() scl_high_count %d, scl_low_count %d\n", __func__, scl_high_count, scl_low_count);
 
+	reg = hdmi_readb(hdmi, 0x18);
+	DRM_DEBUG("%s() hdmi 0x18 #2 0x%x\n", __func__, reg);
+}
+
+static void hdmi_i2c_read(struct spacemit_hdmi *hdmi, uint8_t addr, uint8_t* message, uint32_t length)
+{
+	int i, count = 0, left = length;
+	uint8_t *pvalue = message;
+	uint32_t value;
+	uint32_t reg, num;
+
+	DRM_DEBUG("hdmi_i2c_read ++%u\r\n", length);
+
+	do{
+		if(left <= 16)
+			count = left;
+		else
+			count = 16;
+		left -= count;
+
+		value = ((count-1) << 8) + (addr << 1) + 1;
+		hdmi_writeb(hdmi, 0x8, value & 0xFFFF);
+
+		reg = hdmi_readb(hdmi, 0xC);
+		num = (reg & 0x1f0) >> 4;
+
+		while(num < count){
+			reg = hdmi_readb(hdmi, 0xC);
+			num = (reg & 0x1f0) >> 4;
+		}
+
+		for(i = 0; i < count; i++){
+			value = hdmi_readb(hdmi, 0x4);
+			*pvalue++ = value;
+		}
+	} while(left > 0);
+
+	return;
+}
+
+static int hdmi_i2c_write(struct spacemit_hdmi *hdmi, uint8_t addr, uint8_t* message, uint32_t length)
+{
+	int i, count = 0, left = length;
+	uint8_t *pvalue = message;
+	uint32_t value, reg;
+
+	DRM_DEBUG("hdmi_i2c_write ++ %u\r\n", length);
+
+	do{
+		if(left <= 16)
+			count = left;
+		else
+			count = 16;
+		left -= count;
+
+		for(i = 0; i < count; i++){
+			value = *pvalue++;
+			hdmi_writeb(hdmi, 0x0, value & 0xFF);
+		}
+		value = ((count-1) << 8) + (addr << 1);
+		hdmi_writeb(hdmi, 0x8, value & 0xFFFF);
+		reg = hdmi_readb(hdmi, 0x0C);
+
+		if (reg & BIT(16)) {
+			DRM_INFO("hdmi_i2c_write  i2c ARB FAIL!!");
+			return -1;
+		}
+	} while(left > 0);
+
+	for(i=0; i<10; i++){
+		reg = hdmi_readb(hdmi, 0x0C);
+	}
+
+	DRM_DEBUG("hdmi_i2c_write --%u\r\n", length);
+
+	return 0;
+
+}
+
+int edid_read (struct spacemit_hdmi *hdmi){
+	int i;
+	struct hdmi_data_info *hdmi_data = hdmi->hdmi_data;
+
+	DRM_INFO("%s()\n", __func__);
+
+	if (0 == hdmi_i2c_write(hdmi, 0x50, hdmi_data->edid, 1))
+		hdmi_i2c_read(hdmi, 0x50, hdmi_data->edid, EDID_LENGTH);
+
+	for(i = 0; i < EDID_LENGTH; i += 4){
+		DRM_INFO("EDID 0x%x: 0x%x, 0x%x, 0x%x, 0x%x\r\n", i,
+			hdmi_data->edid[i], hdmi_data->edid[i+1], hdmi_data->edid[i+2], hdmi_data->edid[i+3]);
+	}
+
+	return 0;
+}
+
+static int spacemit_hdmi_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)
+{
+	struct spacemit_hdmi *hdmi = data;
+	struct hdmi_data_info *hdmi_data = hdmi->hdmi_data;
+
+	DRM_INFO("%s()\n", __func__);
+
+	if (len > 128)
+		return -EINVAL;
+
+	hdmi_i2c_timing(hdmi);
+	edid_read(hdmi);
+	memcpy(buf, hdmi_data->edid, len);
+
+	return 0;
+}
+
+void hdmi_init (struct spacemit_hdmi *hdmi, int pixek_clock){
+	u32 value = 0;
+	DRM_DEBUG("%s()\n", __func__);
+
+	writel(0xEE40410F, hdmi->regs + 0xe0);
+	writel(0x0000005d, hdmi->regs + 0x34);
+
+	pll_reg(hdmi, pixek_clock);
+	writel(0x3, hdmi->regs + 0xe4);
+
+	value = readl_relaxed(hdmi->regs + 0xe4);
+	while ( (value & 0x10000) != 0) {
+		value = readl_relaxed(hdmi->regs + 0xe4);
+	}
+
+	writel(0x3018C001, hdmi->regs + 0x28);
+}
+
+static int spacemit_hdmi_setup(struct spacemit_hdmi *hdmi,
+			   struct drm_display_mode *mode)
+{
+	u32 value;
+	DRM_DEBUG("%s() \n", __func__);
+
+	// hdmi config
+	hdmi_writeb(hdmi, 0xe8, 0x20200000);
+	hdmi_writeb(hdmi, 0xec, 0x508d425a);
+	hdmi_writeb(hdmi, 0xf0, 0x861);
+
+	hdmi_init(hdmi, hdmi->previous_mode.clock);
+
+	spacemit_hdmi_config_video_timing(hdmi, mode);
 	spacemit_hdmi_config_video_avi(hdmi, mode);
 	spacemit_hdmi_config_video_vsi(hdmi, mode);
 
@@ -220,7 +498,7 @@ static void spacemit_hdmi_encoder_mode_set(struct drm_encoder *encoder,
 				       struct drm_display_mode *adj_mode)
 {
 	struct spacemit_hdmi *hdmi = encoder_to_spacemit_hdmi(encoder);
-	DRM_DEBUG("%s()\n", __func__);
+	DRM_INFO("%s() \n", __func__);
 
 	/* Store the display mode for plugin/DPMS poweron events */
 	drm_mode_copy(&hdmi->previous_mode, adj_mode);
@@ -254,6 +532,7 @@ spacemit_hdmi_encoder_atomic_check(struct drm_encoder *encoder,
 			       struct drm_crtc_state *crtc_state,
 			       struct drm_connector_state *conn_state)
 {
+	DRM_DEBUG("%s()\n", __func__);
 	return 0;
 }
 
@@ -268,16 +547,32 @@ static struct drm_encoder_helper_funcs spacemit_hdmi_encoder_helper_funcs = {
 static enum drm_connector_status
 spacemit_hdmi_connector_detect(struct drm_connector *connector, bool force)
 {
-	return connector_status_connected;
+	struct spacemit_hdmi *hdmi = connector_to_spacemit_hdmi(connector);
+
+	DRM_DEBUG("%s() \n", __func__);
+
+	if (hdmi_get_plug_in_status(hdmi)) {
+		DRM_INFO("%s() hdmi status connected\n", __func__);
+		return connector_status_connected;
+	} else {
+		DRM_INFO("%s() hdmi status disconnected\n", __func__);
+		return connector_status_disconnected;
+	}
 }
 
 static int spacemit_hdmi_connector_get_modes(struct drm_connector *connector)
 {
-	// struct spacemit_hdmi *hdmi = connector_to_spacemit_hdmi(connector);
-	// struct edid *edid;
-	int ret = 0;
+	struct spacemit_hdmi *hdmi = connector_to_spacemit_hdmi(connector);
+	int ret;
+	struct edid *edid;
+
+	DRM_DEBUG("%s() \n", __func__);
+
+	edid = drm_do_get_edid(connector, spacemit_hdmi_get_edid_block, hdmi);
+	drm_connector_update_edid_property(connector, edid);
+	ret = drm_add_edid_modes(connector, edid);
+	kfree(edid);
 
-	ret = drm_add_modes_noedid(connector, 1920, 1080);
 	return ret;
 }
 
@@ -297,6 +592,8 @@ spacemit_hdmi_probe_single_connector_modes(struct drm_connector *connector,
 
 static void spacemit_hdmi_connector_destroy(struct drm_connector *connector)
 {
+	struct spacemit_hdmi *hdmi = connector_to_spacemit_hdmi(connector);
+	kfree(hdmi->hdmi_data);
 	drm_connector_unregister(connector);
 	drm_connector_cleanup(connector);
 }
@@ -357,12 +654,16 @@ static int spacemit_hdmi_bind(struct device *dev, struct device *master,
 	// int irq;
 	int ret;
 
-	DRM_DEBUG("%s()\n", __func__);
+	DRM_INFO("%s() \n", __func__);
 
 	hdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);
 	if (!hdmi)
 		return -ENOMEM;
 
+	hdmi->hdmi_data = devm_kzalloc(dev, sizeof(*(hdmi->hdmi_data)), GFP_KERNEL);
+	if (!hdmi->hdmi_data)
+		return -ENOMEM;
+
 	hdmi->dev = dev;
 	hdmi->drm_dev = drm;
 
@@ -384,7 +685,7 @@ static void spacemit_hdmi_unbind(struct device *dev, struct device *master,
 {
 	struct spacemit_hdmi *hdmi = dev_get_drvdata(dev);
 
-	DRM_DEBUG("%s()\n", __func__);
+	DRM_INFO("%s() \n", __func__);
 
 	hdmi->connector.funcs->destroy(&hdmi->connector);
 }
@@ -396,13 +697,13 @@ static const struct component_ops spacemit_hdmi_ops = {
 
 static int spacemit_hdmi_probe(struct platform_device *pdev)
 {
-	DRM_DEBUG("%s()\n", __func__);
+	DRM_INFO("%s() \n", __func__);
 	return component_add(&pdev->dev, &spacemit_hdmi_ops);
 }
 
 static int spacemit_hdmi_remove(struct platform_device *pdev)
 {
-	DRM_DEBUG("%s()\n", __func__);
+	DRM_INFO("%s() \n", __func__);
 	component_del(&pdev->dev, &spacemit_hdmi_ops);
 
 	return 0;
-- 
2.47.0

