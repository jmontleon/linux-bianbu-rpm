From 02d0c3ead1f8fa83c0a85a9a5701f6cfaab12632 Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Wed, 11 Dec 2024 19:19:36 +0800
Subject: [PATCH 09/21] Update for v2.0.4

---
 arch/riscv/Kconfig.socs                       |    7 +
 arch/riscv/Makefile                           |    2 +-
 arch/riscv/boot/dts/spacemit/Makefile         |    3 +-
 arch/riscv/boot/dts/spacemit/k1-x-hdmi.dtsi   |   32 +-
 arch/riscv/boot/dts/spacemit/k1-x.dtsi        |   50 +-
 .../boot/dts/spacemit/k1-x_FusionOne.dts      |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts |    2 +-
 .../boot/dts/spacemit/k1-x_MUSE-Book.dts      |    4 +-
 .../boot/dts/spacemit/k1-x_MUSE-Card.dts      |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts |    2 +-
 .../dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts  |   15 +-
 .../boot/dts/spacemit/k1-x_MUSE-Paper.dts     |   37 +-
 .../boot/dts/spacemit/k1-x_MUSE-Paper2.dts    | 1290 ++++++
 arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_ZT001H.dts  |   99 +-
 .../boot/dts/spacemit/k1-x_baton-camera.dts   |    2 +-
 .../boot/dts/spacemit/k1-x_bit-brick.dts      | 1125 ++++++
 arch/riscv/boot/dts/spacemit/k1-x_deb1.dts    |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_deb2.dts    |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_evb.dts     |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_hs450.dts   |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_kx312.dts   |    4 +-
 arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts   |    2 +-
 .../boot/dts/spacemit/k1-x_milkv-jupiter.dts  |    2 +-
 arch/riscv/boot/dts/spacemit/k1-x_mingo.dts   |    2 +-
 .../boot/dts/spacemit/k1-x_orangepi-rv2.dts   |   11 +-
 arch/riscv/boot/dts/spacemit/k1-x_uav.dts     |   13 +-
 .../spacemit/lcd/lcd_ft8201sinx101_mipi.dtsi  |  268 ++
 .../spacemit/lcd/lcd_jd9365aainx101_mipi.dtsi |  262 ++
 .../boot/dts/spacemit/m1-x_milkv-jupiter.dts  |    2 +-
 arch/riscv/configs/k1_defconfig               |    7 +-
 arch/riscv/configs/k1_rt_defconfig            |    2 +-
 arch/riscv/include/asm/rwonce.h               |   44 +
 arch/riscv/kernel/signal.c                    |   15 +-
 block/blk-mq.c                                |    2 -
 certs/Makefile                                |    2 +-
 drivers/dma-buf/dma-heap.c                    |   41 +-
 drivers/gpu/drm/img-rogue/Makefile            |   11 +-
 drivers/gpu/drm/img-rogue/allocmem.c          |   59 -
 .../gpu/drm/img-rogue/apollo/drm_pdp_crtc.c   |   18 -
 .../drm/img-rogue/apollo/drm_pdp_debugfs.c    |   14 +-
 .../gpu/drm/img-rogue/apollo/drm_pdp_drv.c    |  118 +-
 .../gpu/drm/img-rogue/apollo/drm_pdp_drv.h    |    5 -
 .../gpu/drm/img-rogue/apollo/drm_pdp_dvi.c    |   18 -
 drivers/gpu/drm/img-rogue/apollo/drm_pdp_fb.c |   36 +-
 .../gpu/drm/img-rogue/apollo/drm_pdp_gem.c    |    9 -
 .../gpu/drm/img-rogue/apollo/drm_pdp_gem.h    |    2 -
 .../drm/img-rogue/apollo/drm_pdp_modeset.c    |   42 +-
 .../gpu/drm/img-rogue/apollo/drm_pdp_plane.c  |    2 +-
 .../gpu/drm/img-rogue/apollo/drm_pdp_tmds.c   |    4 -
 drivers/gpu/drm/img-rogue/apollo/odin_defs.h  |   12 +
 drivers/gpu/drm/img-rogue/apollo/sysconfig.c  |  396 +-
 drivers/gpu/drm/img-rogue/apollo/sysinfo.h    |    8 +
 drivers/gpu/drm/img-rogue/apollo/tc_apollo.c  |   94 +-
 drivers/gpu/drm/img-rogue/apollo/tc_drv.c     |  126 +-
 drivers/gpu/drm/img-rogue/apollo/tc_drv.h     |   12 +-
 .../drm/img-rogue/apollo/tc_drv_internal.h    |    6 +-
 drivers/gpu/drm/img-rogue/apollo/tc_odin.c    |  239 +-
 .../img-rogue/apollo/tc_odin_common_regs.h    |    9 +
 drivers/gpu/drm/img-rogue/cache_km.c          |   19 +-
 drivers/gpu/drm/img-rogue/client_mm_bridge.h  |   26 +-
 .../drm/img-rogue/client_mm_direct_bridge.c   |   89 +-
 drivers/gpu/drm/img-rogue/client_ri_bridge.h  |    3 +-
 .../drm/img-rogue/client_ri_direct_bridge.c   |   10 +-
 .../gpu/drm/img-rogue/common_dmabuf_bridge.h  |   43 +-
 drivers/gpu/drm/img-rogue/common_mm_bridge.h  |  108 +-
 .../gpu/drm/img-rogue/common_rgxcmp_bridge.h  |  135 +-
 .../drm/img-rogue/common_rgxfwdbg_bridge.h    |   40 +-
 .../drm/img-rogue/common_rgxhwperf_bridge.h   |  162 +-
 .../gpu/drm/img-rogue/common_rgxta3d_bridge.h |  224 +-
 .../gpu/drm/img-rogue/common_rgxtq2_bridge.h  |   40 +-
 .../gpu/drm/img-rogue/common_rgxtq_bridge.h   |   39 +-
 drivers/gpu/drm/img-rogue/common_ri_bridge.h  |    3 +-
 drivers/gpu/drm/img-rogue/config_kernel.h     |  118 +-
 drivers/gpu/drm/img-rogue/config_kernel.mk    |    8 +-
 .../img-rogue/configs/rgxconfig_km_1.V.4.5.h  |   81 +
 drivers/gpu/drm/img-rogue/connection_server.c |  103 +-
 drivers/gpu/drm/img-rogue/connection_server.h |    2 -
 .../drm/img-rogue/cores/rgxcore_km_1.82.4.5.h |   69 +
 drivers/gpu/drm/img-rogue/debug_common.c      |  446 +--
 drivers/gpu/drm/img-rogue/debug_common.h      |    2 +
 drivers/gpu/drm/img-rogue/device.h            |   94 +-
 drivers/gpu/drm/img-rogue/devicemem.c         |  144 +-
 drivers/gpu/drm/img-rogue/devicemem_heapcfg.c |    6 +
 drivers/gpu/drm/img-rogue/devicemem_heapcfg.h |   10 -
 .../drm/img-rogue/devicemem_history_server.c  |   44 +-
 drivers/gpu/drm/img-rogue/devicemem_server.c  | 1451 +++++--
 drivers/gpu/drm/img-rogue/devicemem_server.h  |  227 +-
 .../drm/img-rogue/devicemem_server_utils.h    |   27 +-
 .../gpu/drm/img-rogue/devicemem_typedefs.h    |   10 -
 drivers/gpu/drm/img-rogue/devicemem_utils.c   |   53 +-
 drivers/gpu/drm/img-rogue/di_impl_brg.c       |   93 +-
 drivers/gpu/drm/img-rogue/di_impl_brg.h       |    2 +
 drivers/gpu/drm/img-rogue/di_server.c         |    4 +-
 drivers/gpu/drm/img-rogue/di_server.h         |    9 +-
 drivers/gpu/drm/img-rogue/dkf_server.c        |  409 ++
 drivers/gpu/drm/img-rogue/dkf_server.h        |  103 +
 drivers/gpu/drm/img-rogue/dkp_impl.h          |  163 +
 drivers/gpu/drm/img-rogue/dma_km.h            |    6 +-
 drivers/gpu/drm/img-rogue/dma_support.c       |    2 +-
 drivers/gpu/drm/img-rogue/env_connection.h    |    4 +
 drivers/gpu/drm/img-rogue/event.c             |    4 +-
 drivers/gpu/drm/img-rogue/fwload.c            |    8 +-
 drivers/gpu/drm/img-rogue/handle.c            |    9 +-
 drivers/gpu/drm/img-rogue/handle.h            |    1 +
 drivers/gpu/drm/img-rogue/handle_idr.c        |   23 -
 drivers/gpu/drm/img-rogue/handle_types.h      |    3 -
 drivers/gpu/drm/img-rogue/hash.c              |   13 +
 drivers/gpu/drm/img-rogue/hash.h              |    8 +
 drivers/gpu/drm/img-rogue/htb_debug.c         |   59 +-
 drivers/gpu/drm/img-rogue/htbserver.c         |   78 +-
 drivers/gpu/drm/img-rogue/htbuffer_sf.h       |  123 +-
 drivers/gpu/drm/img-rogue/img_defs.h          |   40 +-
 drivers/gpu/drm/img-rogue/img_types.h         |    6 +-
 drivers/gpu/drm/img-rogue/info_page_client.h  |    4 +-
 .../gpu/drm/img-rogue/kernel_compatibility.h  |  265 +-
 drivers/gpu/drm/img-rogue/kernel_nospec.h     |    4 +-
 .../gpu/drm/img-rogue/km/rgx_bvnc_defs_km.h   |  296 +-
 .../gpu/drm/img-rogue/km/rgx_bvnc_table_km.h  |  319 +-
 drivers/gpu/drm/img-rogue/km/rgxdefs_km.h     |   22 +-
 drivers/gpu/drm/img-rogue/km_apphint.c        |   53 +-
 .../drm/img-rogue/km_apphint_defs_common.h    |   36 +-
 drivers/gpu/drm/img-rogue/lock.h              |   11 +-
 drivers/gpu/drm/img-rogue/mem_utils.c         |   66 +-
 drivers/gpu/drm/img-rogue/mmu_common.c        | 1121 ++++--
 drivers/gpu/drm/img-rogue/mmu_common.h        |   25 +-
 drivers/gpu/drm/img-rogue/module_common.c     |   96 +-
 drivers/gpu/drm/img-rogue/module_common.h     |    8 +-
 .../gpu/drm/img-rogue/osconnection_server.c   |   11 +
 .../gpu/drm/img-rogue/osconnection_server.h   |    4 +
 drivers/gpu/drm/img-rogue/osdi_impl.h         |    6 +-
 drivers/gpu/drm/img-rogue/osfunc.c            |  349 +-
 drivers/gpu/drm/img-rogue/osfunc.h            |  171 +-
 drivers/gpu/drm/img-rogue/osfunc_arm.c        |   34 +-
 drivers/gpu/drm/img-rogue/osfunc_arm64.c      |   35 +-
 drivers/gpu/drm/img-rogue/osfunc_common.h     |   52 +-
 drivers/gpu/drm/img-rogue/osfunc_x86.c        |    4 -
 drivers/gpu/drm/img-rogue/ospvr_gputrace.h    |    4 +-
 drivers/gpu/drm/img-rogue/pci_support.c       |   83 -
 drivers/gpu/drm/img-rogue/pdump_km.h          |   21 +-
 drivers/gpu/drm/img-rogue/pdump_mmu.h         |    3 +
 drivers/gpu/drm/img-rogue/physheap.c          |  810 +++-
 drivers/gpu/drm/img-rogue/physheap.h          |   71 +-
 drivers/gpu/drm/img-rogue/physheap_config.h   |  161 +-
 drivers/gpu/drm/img-rogue/physmem.c           |  180 +-
 drivers/gpu/drm/img-rogue/physmem.h           |   49 +
 drivers/gpu/drm/img-rogue/physmem_dlm.h       |   88 +
 drivers/gpu/drm/img-rogue/physmem_dmabuf.c    | 1403 +++++--
 drivers/gpu/drm/img-rogue/physmem_dmabuf.h    |   22 +-
 .../drm/img-rogue/physmem_dmabuf_internal.h   |   69 +
 drivers/gpu/drm/img-rogue/physmem_extmem.c    |    3 +-
 .../gpu/drm/img-rogue/physmem_extmem_linux.c  |  196 +-
 .../gpu/drm/img-rogue/physmem_extmem_wrap.h   |    2 +-
 drivers/gpu/drm/img-rogue/physmem_hostmem.c   |   37 +-
 drivers/gpu/drm/img-rogue/physmem_ima.h       |   77 +
 drivers/gpu/drm/img-rogue/physmem_lma.c       | 2563 +-----------
 drivers/gpu/drm/img-rogue/physmem_lma.h       |   21 +-
 drivers/gpu/drm/img-rogue/physmem_osmem.c     |    2 +-
 drivers/gpu/drm/img-rogue/physmem_osmem.h     |   50 +-
 .../gpu/drm/img-rogue/physmem_osmem_linux.c   | 2102 ++++++----
 .../gpu/drm/img-rogue/physmem_osmem_linux.h   |    9 +-
 drivers/gpu/drm/img-rogue/physmem_ramem.c     | 2609 +++++++++++++
 drivers/gpu/drm/img-rogue/physmem_ramem.h     |  109 +
 drivers/gpu/drm/img-rogue/plato_drv.h         |    2 -
 drivers/gpu/drm/img-rogue/pmr.c               |  909 +++--
 drivers/gpu/drm/img-rogue/pmr.h               |  174 +-
 drivers/gpu/drm/img-rogue/pmr_env.c           |   83 +
 drivers/gpu/drm/img-rogue/pmr_env.h           |   90 +
 drivers/gpu/drm/img-rogue/pmr_impl.h          |   55 +-
 drivers/gpu/drm/img-rogue/pmr_os.c            |  139 +-
 drivers/gpu/drm/img-rogue/power.c             |  300 +-
 drivers/gpu/drm/img-rogue/power.h             |  117 +-
 .../drm/img-rogue/powervr/img_drm_fourcc.h    |   18 +
 .../drm/img-rogue/powervr/pvrsrv_sync_ext.h   |    2 +
 drivers/gpu/drm/img-rogue/proc_stats.h        |  164 +-
 drivers/gpu/drm/img-rogue/process_stats.c     | 1224 +++---
 drivers/gpu/drm/img-rogue/process_stats.h     |   10 +-
 drivers/gpu/drm/img-rogue/pvr_bridge.h        |   14 -
 drivers/gpu/drm/img-rogue/pvr_bridge_k.c      |   64 +-
 drivers/gpu/drm/img-rogue/pvr_bridge_k.h      |   18 +
 drivers/gpu/drm/img-rogue/pvr_buffer_sync.c   |    8 +-
 .../gpu/drm/img-rogue/pvr_counting_timeline.c |   12 +-
 drivers/gpu/drm/img-rogue/pvr_debug.c         |   19 +-
 drivers/gpu/drm/img-rogue/pvr_debug.h         |   58 +-
 drivers/gpu/drm/img-rogue/pvr_debugfs.c       |   11 -
 drivers/gpu/drm/img-rogue/pvr_drm.c           |  166 +-
 drivers/gpu/drm/img-rogue/pvr_drm.h           |   18 +
 drivers/gpu/drm/img-rogue/pvr_drv.h           |    8 +-
 drivers/gpu/drm/img-rogue/pvr_export_fence.c  |  472 +++
 drivers/gpu/drm/img-rogue/pvr_export_fence.h  |   77 +
 drivers/gpu/drm/img-rogue/pvr_fence.c         |    3 +-
 drivers/gpu/drm/img-rogue/pvr_fence.h         |   10 +-
 drivers/gpu/drm/img-rogue/pvr_fence_trace.h   |    2 +-
 drivers/gpu/drm/img-rogue/pvr_gputrace.c      |  363 +-
 drivers/gpu/drm/img-rogue/pvr_notifier.c      |   25 +-
 drivers/gpu/drm/img-rogue/pvr_platform_drv.c  |   31 +-
 drivers/gpu/drm/img-rogue/pvr_sw_fence.c      |    5 +-
 drivers/gpu/drm/img-rogue/pvr_sync_api.h      |    2 +
 drivers/gpu/drm/img-rogue/pvr_sync_file.c     |  269 +-
 .../gpu/drm/img-rogue/pvr_sync_ioctl_common.c |  276 +-
 .../gpu/drm/img-rogue/pvr_sync_ioctl_common.h |   20 +-
 .../gpu/drm/img-rogue/pvr_sync_ioctl_drm.c    |   32 +-
 .../gpu/drm/img-rogue/pvr_sync_ioctl_drm.h    |    4 +
 drivers/gpu/drm/img-rogue/pvrsrv.c            |  476 ++-
 drivers/gpu/drm/img-rogue/pvrsrv.h            |   69 +-
 .../gpu/drm/img-rogue/pvrsrv_bridge_init.c    |   11 -
 drivers/gpu/drm/img-rogue/pvrsrv_device.h     |   49 +-
 drivers/gpu/drm/img-rogue/pvrsrv_errors.h     |    1 +
 .../drm/img-rogue/pvrsrv_memalloc_physheap.h  |   54 +-
 .../gpu/drm/img-rogue/pvrsrv_memallocflags.h  |  113 +-
 drivers/gpu/drm/img-rogue/pvrsrv_pool.c       |    2 +-
 drivers/gpu/drm/img-rogue/pvrsrv_tlstreams.h  |    2 +-
 drivers/gpu/drm/img-rogue/pvrsrvkm.mk         |   11 +-
 drivers/gpu/drm/img-rogue/pvrversion.h        |   16 +-
 drivers/gpu/drm/img-rogue/ra.c                |  976 ++++-
 drivers/gpu/drm/img-rogue/ra.h                |  183 +-
 drivers/gpu/drm/img-rogue/rgx_bridge.h        |    2 -
 drivers/gpu/drm/img-rogue/rgx_bridge_init.c   |   83 +-
 drivers/gpu/drm/img-rogue/rgx_bridge_init.h   |    5 +-
 drivers/gpu/drm/img-rogue/rgx_common.h        |   32 +-
 drivers/gpu/drm/img-rogue/rgx_firmware_boot.h |   91 +
 .../gpu/drm/img-rogue/rgx_fwif_alignchecks.h  |    2 +-
 drivers/gpu/drm/img-rogue/rgx_fwif_km.h       | 1032 +----
 drivers/gpu/drm/img-rogue/rgx_fwif_sf.h       |  180 +-
 drivers/gpu/drm/img-rogue/rgx_fwif_shared.h   |  803 +++-
 drivers/gpu/drm/img-rogue/rgx_heap_firmware.h |   19 +-
 drivers/gpu/drm/img-rogue/rgx_heaps.h         |    1 -
 drivers/gpu/drm/img-rogue/rgx_heaps_server.h  |   86 +
 drivers/gpu/drm/img-rogue/rgx_hwperf_common.h |   83 +-
 drivers/gpu/drm/img-rogue/rgx_hwperf_table.c  |   24 +-
 drivers/gpu/drm/img-rogue/rgx_meta.h          |   16 +-
 drivers/gpu/drm/img-rogue/rgx_options.h       |   30 +-
 drivers/gpu/drm/img-rogue/rgx_riscv.h         |   22 +-
 drivers/gpu/drm/img-rogue/rgxapi_km.h         |   14 -
 drivers/gpu/drm/img-rogue/rgxbvnc.c           |   51 +-
 drivers/gpu/drm/img-rogue/rgxccb.c            |  223 +-
 drivers/gpu/drm/img-rogue/rgxccb.h            |    3 +-
 drivers/gpu/drm/img-rogue/rgxcompute.c        |  488 ++-
 drivers/gpu/drm/img-rogue/rgxcompute.h        |   34 +-
 drivers/gpu/drm/img-rogue/rgxdebug.c          | 1867 +--------
 drivers/gpu/drm/img-rogue/rgxdebug_common.c   | 1074 ++++-
 drivers/gpu/drm/img-rogue/rgxdebug_common.h   |   63 +-
 drivers/gpu/drm/img-rogue/rgxdevice.h         |  122 +-
 drivers/gpu/drm/img-rogue/rgxfwcmnctx.c       |   62 +-
 drivers/gpu/drm/img-rogue/rgxfwdbg.c          |  144 +-
 drivers/gpu/drm/img-rogue/rgxfwdbg.h          |   10 +-
 drivers/gpu/drm/img-rogue/rgxfwimageutils.c   |   15 +-
 drivers/gpu/drm/img-rogue/rgxfwmemctx.h       |    9 +-
 drivers/gpu/drm/img-rogue/rgxfwriscv.c        |   76 +-
 drivers/gpu/drm/img-rogue/rgxfwriscv.h        |    5 +
 drivers/gpu/drm/img-rogue/rgxfwutils.c        | 1523 +++-----
 drivers/gpu/drm/img-rogue/rgxfwutils.h        |  158 +-
 drivers/gpu/drm/img-rogue/rgxheapconfig.h     |   30 +-
 .../gpu/drm/img-rogue/rgxheapconfig_65273.h   |    7 +-
 drivers/gpu/drm/img-rogue/rgxhwperf.c         |   29 +-
 drivers/gpu/drm/img-rogue/rgxhwperf.h         |    7 +-
 drivers/gpu/drm/img-rogue/rgxhwperf_common.c  |  380 +-
 drivers/gpu/drm/img-rogue/rgxhwperf_common.h  |   22 +
 drivers/gpu/drm/img-rogue/rgxinit.c           | 1940 +++++----
 drivers/gpu/drm/img-rogue/rgxinit.h           |   73 +-
 drivers/gpu/drm/img-rogue/rgxinit_apphints.h  |  120 +
 drivers/gpu/drm/img-rogue/rgxkicksync.c       |   25 +-
 drivers/gpu/drm/img-rogue/rgxlayer.h          |   76 +-
 drivers/gpu/drm/img-rogue/rgxlayer_impl.c     |  894 +----
 drivers/gpu/drm/img-rogue/rgxlayer_impl.h     |    2 +
 .../gpu/drm/img-rogue/rgxlayer_impl_common.c  |  914 +++++
 drivers/gpu/drm/img-rogue/rgxmem.c            |   29 +-
 drivers/gpu/drm/img-rogue/rgxmmuinit.c        |  314 +-
 drivers/gpu/drm/img-rogue/rgxmmuinit.h        |    1 -
 drivers/gpu/drm/img-rogue/rgxmulticore.c      |  100 +-
 drivers/gpu/drm/img-rogue/rgxpower.c          | 1154 +++---
 drivers/gpu/drm/img-rogue/rgxpower.h          |  114 +-
 drivers/gpu/drm/img-rogue/rgxregconfig.c      |   36 +-
 drivers/gpu/drm/img-rogue/rgxshader.c         |   45 +-
 drivers/gpu/drm/img-rogue/rgxshader.h         |    4 +-
 drivers/gpu/drm/img-rogue/rgxsrvinit.c        |  928 ++---
 drivers/gpu/drm/img-rogue/rgxstartstop.c      |  669 ++--
 drivers/gpu/drm/img-rogue/rgxta3d.c           |  925 +++--
 drivers/gpu/drm/img-rogue/rgxta3d.h           |   19 +-
 drivers/gpu/drm/img-rogue/rgxtdmtransfer.c    |  180 +-
 drivers/gpu/drm/img-rogue/rgxtdmtransfer.h    |   26 +-
 drivers/gpu/drm/img-rogue/rgxtimecorr.c       |  114 +-
 drivers/gpu/drm/img-rogue/rgxtimecorr.h       |   66 +-
 drivers/gpu/drm/img-rogue/rgxtransfer.c       |  203 +-
 drivers/gpu/drm/img-rogue/rgxtransfer.h       |   24 +-
 .../gpu/drm/img-rogue/rgxtransfer_shader.h    |    4 +-
 drivers/gpu/drm/img-rogue/rgxutils.c          |   10 +-
 drivers/gpu/drm/img-rogue/rgxutils.h          |   27 +-
 drivers/gpu/drm/img-rogue/ri_server.c         | 1126 ++++--
 drivers/gpu/drm/img-rogue/ri_server.h         |   15 +-
 .../gpu/drm/img-rogue/rogue_trace_events.h    |    5 +-
 .../gpu/drm/img-rogue/server_cache_bridge.c   |    9 +-
 drivers/gpu/drm/img-rogue/server_cmm_bridge.c |   17 +-
 .../server_devicememhistory_bridge.c          |   21 +-
 drivers/gpu/drm/img-rogue/server_di_bridge.c  |   46 +-
 .../gpu/drm/img-rogue/server_dmabuf_bridge.c  |  234 +-
 .../drm/img-rogue/server_htbuffer_bridge.c    |    4 +-
 drivers/gpu/drm/img-rogue/server_mm_bridge.c  |  409 +-
 .../drm/img-rogue/server_mmextmem_bridge.c    |    4 +-
 .../gpu/drm/img-rogue/server_pvrtl_bridge.c   |   35 +-
 .../img-rogue/server_rgxbreakpoint_bridge.c   |   20 +-
 .../gpu/drm/img-rogue/server_rgxcmp_bridge.c  |  926 +++--
 .../drm/img-rogue/server_rgxfwdbg_bridge.c    |  157 +-
 .../drm/img-rogue/server_rgxhwperf_bridge.c   |  862 ++--
 .../drm/img-rogue/server_rgxkicksync_bridge.c |   15 +-
 .../img-rogue/server_rgxregconfig_bridge.c    |   17 +-
 .../gpu/drm/img-rogue/server_rgxta3d_bridge.c | 3476 +++++++++--------
 .../img-rogue/server_rgxtimerquery_bridge.c   |   10 +-
 .../gpu/drm/img-rogue/server_rgxtq2_bridge.c  |  488 ++-
 .../gpu/drm/img-rogue/server_rgxtq_bridge.c   |  810 +++-
 drivers/gpu/drm/img-rogue/server_ri_bridge.c  |   40 +-
 .../gpu/drm/img-rogue/server_srvcore_bridge.c |   61 +-
 .../gpu/drm/img-rogue/server_sync_bridge.c    |   43 +-
 .../img-rogue/server_synctracking_bridge.c    |    8 +-
 .../drm/img-rogue/services_kernel_client.h    |   12 +
 drivers/gpu/drm/img-rogue/servicesext.h       |   34 -
 .../gpu/drm/img-rogue/spacemit/sysconfig.c    |   12 +-
 drivers/gpu/drm/img-rogue/spacemit/sysinfo.h  |    1 +
 drivers/gpu/drm/img-rogue/srvcore.c           |   78 +-
 drivers/gpu/drm/img-rogue/srvcore.h           |   42 +-
 drivers/gpu/drm/img-rogue/srvkm.h             |   10 +-
 drivers/gpu/drm/img-rogue/sync.c              |   14 +-
 drivers/gpu/drm/img-rogue/sync_checkpoint.c   |  256 +-
 drivers/gpu/drm/img-rogue/sync_checkpoint.h   |   76 +-
 .../drm/img-rogue/sync_checkpoint_internal.h  |    1 -
 .../gpu/drm/img-rogue/sync_prim_internal.h    |    1 -
 drivers/gpu/drm/img-rogue/sync_server.c       |   30 +-
 drivers/gpu/drm/img-rogue/sysconfig_cmn.c     |   53 +-
 drivers/gpu/drm/img-rogue/sysvalidation.h     |    6 +-
 drivers/gpu/drm/img-rogue/tlclient.c          |    2 +-
 drivers/gpu/drm/img-rogue/tlintern.c          |    2 +-
 drivers/gpu/drm/img-rogue/tlintern.h          |    2 +
 drivers/gpu/drm/img-rogue/tlserver.c          |   14 +-
 drivers/gpu/drm/img-rogue/tlstream.c          |  103 +-
 drivers/gpu/drm/img-rogue/tlstream.h          |   21 +-
 drivers/gpu/drm/img-rogue/vmm_impl.h          |    7 +-
 drivers/gpu/drm/img-rogue/vmm_pvz_server.c    |   18 +-
 drivers/gpu/drm/img-rogue/vmm_type_stub.c     |    8 +-
 drivers/gpu/drm/img-rogue/vz_vmm_pvz.c        |   59 +-
 drivers/gpu/drm/img-rogue/vz_vmm_pvz.h        |    4 +-
 drivers/gpu/drm/img-rogue/vz_vmm_vm.c         |    8 +-
 drivers/gpu/drm/spacemit/spacemit_dpu.c       |   17 +-
 drivers/input/misc/spacemit-pwrkey.c          |    4 +-
 drivers/input/touchscreen/Kconfig             |    1 +
 drivers/input/touchscreen/Makefile            |    1 +
 .../input/touchscreen/focaltech_touch/Kconfig |   10 +
 .../touchscreen/focaltech_touch/Makefile      |   22 +
 .../focaltech_touch/focaltech_common.h        |  193 +
 .../focaltech_touch/focaltech_config.h        |  362 ++
 .../focaltech_touch/focaltech_core.c          | 2592 ++++++++++++
 .../focaltech_touch/focaltech_core.h          |  426 ++
 .../focaltech_touch/focaltech_debug.c         |  963 +++++
 .../focaltech_touch/focaltech_esdcheck.c      |  442 +++
 .../focaltech_touch/focaltech_ex_fun.c        | 1269 ++++++
 .../focaltech_touch/focaltech_ex_mode.c       |  390 ++
 .../focaltech_touch/focaltech_flash.c         | 2273 +++++++++++
 .../focaltech_touch/focaltech_flash.h         |  235 ++
 .../focaltech_upgrade_ft8201p.c               |  331 ++
 .../focaltech_touch/focaltech_flash_spi.c     | 1427 +++++++
 .../focaltech_touch/focaltech_gesture.c       |  511 +++
 .../focaltech_touch/focaltech_hp.c            |  888 +++++
 .../focaltech_touch/focaltech_i2c.c           |  335 ++
 .../focaltech_point_report_check.c            |  185 +
 .../focaltech_touch/focaltech_proximity.c     |  827 ++++
 .../focaltech_touch/focaltech_spi_v2.c        |  621 +++
 drivers/media/platform/spacemit/Kconfig       |    1 +
 drivers/media/platform/spacemit/Makefile      |    1 +
 .../spacemit/camera/vi/k1xvi/fe_isp.c         |    9 +-
 .../platform/spacemit/virtual_camera/Kconfig  |   25 +
 .../platform/spacemit/virtual_camera/Makefile |    5 +
 .../platform/spacemit/virtual_camera/svivi.c  | 1056 +++++
 .../spacemit/virtual_camera/vcam_dbg.c        |   80 +
 .../spacemit/virtual_camera/vcam_dbg.h        |   98 +
 .../vpu_k1x/if/v4l2/mvx_v4l2_session.c        |    2 +-
 drivers/misc/Kconfig                          |    7 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/ocp2138.c                        |   93 +
 drivers/net/ethernet/spacemit/k1x-emac.c      |    3 +
 .../net/wireless/realtek/rtw89/rtw8852be.c    |   17 +
 drivers/pci/controller/dwc/pcie-k1x.c         |    3 +-
 drivers/power/supply/sgm4154x_charger.c       |    7 +-
 drivers/power/supply/sgm4154x_charger.h       |    1 -
 drivers/soc/spacemit/ddr-bw/spacemit_ddrbw.h  |    8 +-
 .../soc/spacemit/spacemit-rf/spacemit-wlan.c  |   22 +-
 drivers/usb/gadget/function/f_mass_storage.c  |   11 +
 drivers/usb/gadget/function/storage_common.h  |    3 +
 drivers/usb/phy/phy-k1x-ci-otg.c              |    2 +-
 drivers/usb/typec/husb239.c                   |   72 +-
 include/linux/blk-mq.h                        |    1 -
 lib/raid6/algos.c                             |   16 +-
 net/ipv4/af_inet.c                            |    2 +-
 sound/soc/codecs/es8326.c                     |    2 +
 sound/soc/spacemit/spacemit-snd-sspa.c        |   44 +-
 393 files changed, 52182 insertions(+), 22012 deletions(-)
 create mode 100644 arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper2.dts
 create mode 100644 arch/riscv/boot/dts/spacemit/k1-x_bit-brick.dts
 create mode 100644 arch/riscv/boot/dts/spacemit/lcd/lcd_ft8201sinx101_mipi.dtsi
 create mode 100644 arch/riscv/boot/dts/spacemit/lcd/lcd_jd9365aainx101_mipi.dtsi
 create mode 100644 arch/riscv/include/asm/rwonce.h
 create mode 100644 drivers/gpu/drm/img-rogue/configs/rgxconfig_km_1.V.4.5.h
 create mode 100644 drivers/gpu/drm/img-rogue/cores/rgxcore_km_1.82.4.5.h
 create mode 100644 drivers/gpu/drm/img-rogue/dkf_server.c
 create mode 100644 drivers/gpu/drm/img-rogue/dkf_server.h
 create mode 100644 drivers/gpu/drm/img-rogue/dkp_impl.h
 create mode 100644 drivers/gpu/drm/img-rogue/physmem_dlm.h
 create mode 100644 drivers/gpu/drm/img-rogue/physmem_dmabuf_internal.h
 create mode 100644 drivers/gpu/drm/img-rogue/physmem_ima.h
 create mode 100644 drivers/gpu/drm/img-rogue/physmem_ramem.c
 create mode 100644 drivers/gpu/drm/img-rogue/physmem_ramem.h
 create mode 100644 drivers/gpu/drm/img-rogue/pmr_env.c
 create mode 100644 drivers/gpu/drm/img-rogue/pmr_env.h
 create mode 100644 drivers/gpu/drm/img-rogue/pvr_export_fence.c
 create mode 100644 drivers/gpu/drm/img-rogue/pvr_export_fence.h
 create mode 100644 drivers/gpu/drm/img-rogue/rgx_firmware_boot.h
 create mode 100644 drivers/gpu/drm/img-rogue/rgx_heaps_server.h
 create mode 100644 drivers/gpu/drm/img-rogue/rgxinit_apphints.h
 create mode 100644 drivers/gpu/drm/img-rogue/rgxlayer_impl_common.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/Kconfig
 create mode 100755 drivers/input/touchscreen/focaltech_touch/Makefile
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_common.h
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_config.h
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_core.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_core.h
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_debug.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_esdcheck.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_ex_fun.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_ex_mode.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_flash.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_flash.h
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_flash/focaltech_upgrade_ft8201p.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_flash_spi.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_gesture.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_hp.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_i2c.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_point_report_check.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_proximity.c
 create mode 100755 drivers/input/touchscreen/focaltech_touch/focaltech_spi_v2.c
 create mode 100644 drivers/media/platform/spacemit/virtual_camera/Kconfig
 create mode 100644 drivers/media/platform/spacemit/virtual_camera/Makefile
 create mode 100644 drivers/media/platform/spacemit/virtual_camera/svivi.c
 create mode 100644 drivers/media/platform/spacemit/virtual_camera/vcam_dbg.c
 create mode 100644 drivers/media/platform/spacemit/virtual_camera/vcam_dbg.h
 create mode 100644 drivers/misc/ocp2138.c

diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 486e882c0166..fc05047f7bab 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -169,6 +169,13 @@ config BIND_THREAD_TO_AICORES
 	help
 	  This enable bind ai cores when use AI instruction.
 
+config SPACEMIT_ERRATA_LOAD_ATOMIC
+	bool "enable issue fix which caused by readforward and writeback"
+	depends on SOC_SPACEMIT_K1X
+	default y
+	help
+	  This enable fix errata caused by readforward and writeback.
+
 endif
 
 endmenu # "SoC selection"
diff --git a/arch/riscv/Makefile b/arch/riscv/Makefile
index db7c82353e3c..b51514092129 100644
--- a/arch/riscv/Makefile
+++ b/arch/riscv/Makefile
@@ -155,7 +155,7 @@ ifeq ($(CONFIG_RISCV_M_MODE)$(CONFIG_ARCH_CANAAN),yy)
 KBUILD_IMAGE := $(boot)/loader.bin
 else
 ifeq ($(CONFIG_EFI_ZBOOT),)
-KBUILD_IMAGE := $(boot)/Image.gz.itb
+KBUILD_IMAGE := $(boot)/Image.gz
 else
 KBUILD_IMAGE := $(boot)/vmlinuz.efi
 endif
diff --git a/arch/riscv/boot/dts/spacemit/Makefile b/arch/riscv/boot/dts/spacemit/Makefile
index 8a961041d6ee..32f23816fe28 100644
--- a/arch/riscv/boot/dts/spacemit/Makefile
+++ b/arch/riscv/boot/dts/spacemit/Makefile
@@ -4,5 +4,6 @@ dtb-$(CONFIG_SOC_SPACEMIT_K1X) += k1-x_evb.dtb k1-x_deb2.dtb k1-x_deb1.dtb k1-x_
 				  k1-x_MUSE-Book.dtb k1-x_lpi3a.dtb k1-x_MUSE-Card.dtb \
 				  k1-x_MUSE-Paper.dtb k1-x_MUSE-Paper-mini-4g.dtb \
 				  k1-x_baton-camera.dtb k1-x_FusionOne.dtb k1-x_orangepi-rv2.dtb \
-				  k1-x_ZT001H.dtb k1-x_uav.dtb
+				  k1-x_ZT001H.dtb k1-x_uav.dtb k1-x_MUSE-Paper2.dtb \
+				  k1-x_bit-brick.dtb
 obj-$(CONFIG_BUILTIN_DTB) += $(addsuffix .o, $(dtb-y))
diff --git a/arch/riscv/boot/dts/spacemit/k1-x-hdmi.dtsi b/arch/riscv/boot/dts/spacemit/k1-x-hdmi.dtsi
index ec2c6c19734f..31a851679e1c 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x-hdmi.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x-hdmi.dtsi
@@ -37,11 +37,22 @@ dpu_offline0_hdmi_out: endpoint@1 {
 		};
 	};
 
+	hdmiaudio: spacemit_snd_sspa@C0883900 {
+		compatible = "spacemit,spacemit-snd-sspa";
+		reg = <0 0xc0883900 0 0x300>,
+			<0 0xc0882000 0 0x50>;
+		clocks = <&ccu CLK_RCPU_HDMIAUDIO>, <&ccu CLK_HDMI>;
+		resets = <&reset RESET_RCPU_HDMIAUDIO>;
+		assigned-clocks = <&ccu CLK_RCPU_HDMIAUDIO>;
+		assigned-clock-rates = <48000>;
+		power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
+		function-supply = <&hdmi>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
 	hdmi: hdmi@C0400500 {
-		compatible = "spacemit,hdmi", "simple-bus";
-		#address-cells = <2>;
-		#size-cells = <2>;
-		ranges;
+		compatible = "spacemit,hdmi";
 		reg = <0 0xC0400500 0 0x200>;
 		interrupt-parent = <&intc>;
 		interrupts = <136>;
@@ -61,18 +72,5 @@ hdmi_in: endpoint@0 {
 				remote-endpoint = <&dpu_online2_hdmi_out>;
 			};
 		};
-
-		hdmiaudio: spacemit_snd_sspa@C0883900 {
-			compatible = "spacemit,spacemit-snd-sspa";
-			reg = <0 0xc0883900 0 0x300>,
-				<0 0xc0882000 0 0x50>;
-			clocks = <&ccu CLK_RCPU_HDMIAUDIO>;
-			resets = <&reset RESET_RCPU_HDMIAUDIO>;
-			assigned-clocks = <&ccu CLK_RCPU_HDMIAUDIO>;
-			assigned-clock-rates = <48000>;
-			power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
-			#sound-dai-cells = <0>;
-			status = "disabled";
-		};
 	};
 };
diff --git a/arch/riscv/boot/dts/spacemit/k1-x.dtsi b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
index 30976f24dd80..522371130723 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
@@ -41,7 +41,7 @@ cpus: cpus {
 		#size-cells = <0>;
 		timebase-frequency = <10000000>;
 		cpu_0: cpu@0 {
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			device_type = "cpu";
 			model = "Spacemit(R) X60";
 			reg = <0>;
@@ -78,7 +78,7 @@ cpu_1: cpu@1 {
 			device_type = "cpu";
 			reg = <1>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -112,7 +112,7 @@ cpu_2: cpu@2 {
 			device_type = "cpu";
 			reg = <2>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -146,7 +146,7 @@ cpu_3: cpu@3 {
 			device_type = "cpu";
 			reg = <3>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -180,7 +180,7 @@ cpu_4: cpu@4 {
 			device_type = "cpu";
 			reg = <4>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -214,7 +214,7 @@ cpu_5: cpu@5 {
 			device_type = "cpu";
 			reg = <5>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -248,7 +248,7 @@ cpu_6: cpu@6 {
 			device_type = "cpu";
 			reg = <6>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -282,7 +282,7 @@ cpu_7: cpu@7 {
 			device_type = "cpu";
 			reg = <7>;
 			status = "okay";
-			compatible = "riscv";
+			compatible = "spacemit,x60", "riscv";
 			model = "Spacemit(R) X60";
 			riscv,isa = "rv64imafdcv";
 			riscv,isa-base = "rv64i";
@@ -507,13 +507,13 @@ dram_range1: dram_range@1 {
 			status = "okay";
 		};
 
-		/* dram mapping for pcie for ex. */
+		/* dram mapping for pcie0 for ex. */
 		dram_range2: dram_range@2 {
 			compatible = "spacemit-dram-bus";
 			#address-cells = <2>;
 			#size-cells = <2>;
 			dma-ranges = <0x0 0x00000000 0x0 0x00000000 0x0 0x80000000>,
-				     <0x0 0xb8000000 0x1 0x38000000 0x3 0x48000000>;
+				     <0x0 0x90000000 0x1 0x10000000 0x3 0x70000000>;
 			#interconnect-cells = <0>;
 			status = "okay";
 		};
@@ -551,6 +551,30 @@ dram_range5: dram_range@5 {
 			status = "okay";
 		};
 
+		/* dram mapping for pcie1 for ex. */
+		dram_range6: dram_range@6 {
+			compatible = "spacemit-dram-bus";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x00000000 0x0 0x00000000 0x0 0x80000000>,
+				     <0x0 0x80000000 0x1 0x00000000 0x0 0x10000000>,
+				     <0x0 0xa0000000 0x1 0x20000000 0x3 0x60000000>;
+			#interconnect-cells = <0>;
+			status = "okay";
+		};
+
+		/* dram mapping for pcie2 for ex. */
+		dram_range7: dram_range@7 {
+			compatible = "spacemit-dram-bus";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x00000000 0x0 0x00000000 0x0 0x80000000>,
+				     <0x0 0x80000000 0x1 0x00000000 0x0 0x20000000>,
+				     <0x0 0xb8000000 0x1 0x38000000 0x3 0x48000000>;
+			#interconnect-cells = <0>;
+			status = "okay";
+		};
+
 		clint0: clint@e4000000 {
 			compatible = "riscv,clint0";
 			interrupts-extended = <
@@ -1207,6 +1231,8 @@ i2c3: i2c@f0614000 {
 			#size-cells = <0>;
 			interrupt-parent = <&intc>;
 			interrupts = <39>;
+			clocks = <&ccu CLK_SEC_TWSI3>;
+			resets = <&reset RESET_SEC_TWSI3>;
 			spacemit,dma-disable;
 			/* spacemit,i2c-fast-mode; */
 			/* spacemit,i2c-high-mode; */
@@ -2249,7 +2275,7 @@ pcie1_rc: pcie@ca400000 {
 			#size-cells = <2>;
 			ranges = <0x01000000 0x0 0x9f002000 0 0x9f002000 0x0 0x100000>,
 				 <0x02000000 0x0 0x90000000 0 0x90000000 0x0 0x0f000000>;
-			interconnects = <&dram_range2>;
+			interconnects = <&dram_range6>;
 			interconnect-names = "dma-mem";
 
 			interrupts = <142>, <146>;
@@ -2299,7 +2325,7 @@ pcie2_rc: pcie@ca800000 {
 			ranges = <0x01000000 0x0 0xb7002000 0 0xb7002000 0x0 0x100000>,
 				 <0x42000000 0x0 0xa0000000 0 0xa0000000 0x0 0x10000000>,
 				 <0x02000000 0x0 0xb0000000 0 0xb0000000 0x0 0x7000000>;
-			interconnects = <&dram_range2>;
+			interconnects = <&dram_range7>;
 			interconnect-names = "dma-mem";
 
 			interrupts = <143>, <147>;
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts b/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
index 0874359a491f..be690425cf88 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
@@ -117,7 +117,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts b/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
index 1be8647964e2..d6dcf25092d2 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
index 85e70e676e9a..df31e5eee160 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
@@ -14,7 +14,7 @@
 
 / {
 	model = "M1-MUSE-BOOK";
-	modules_usrload = "8852be";
+	modules_usrload = "rtw89_core, rtw89_pci, rtw89_8852b, rtw89_8852be";
 
 	cpus: cpus {
 		#address-cells = <1>;
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "console=ttyS0,115200n8 loglevel=1 swiotlb=65536 rdinit=/init driver_async_probe=spacemit-hdmi-drv,i2c-spacemit-k1x,ri2c-spacemit-k1x,k1xccic,sdhci-spacemit,k1x-dwc-pcie,pxa2xx-uart";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
index 2942122e7968..a438ed1b2d21 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
index 7709daad504c..094fa3646abe 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
@@ -112,7 +112,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
index 9d1a954053c2..89e1953dca82 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
@@ -119,7 +119,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
@@ -358,7 +358,11 @@ husb239_u2: tcpc@42 {
 		compatible = "hynetek,husb239";
 		reg = <0x42>;
 		vbus-gpios = <&gpio 124 0>;
-		int-gpio = <&gpio 78 0>;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <316>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_husb239_u2>;
+		//wakeup-source;
 		status = "okay";
 
 		ports {
@@ -692,7 +696,6 @@ &range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
 		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_76  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
-		&range GPIO_78  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
 		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
 		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_89  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
@@ -724,6 +727,11 @@ K1X_PADCONF(MMC1_CLK,  MUX_MODE0, (EDGE_NONE | PULL_DOWN | PAD_3V_DS4))	/* mmc1_
 		>;
 	};
 
+	pinctrl_husb239_u2: husb239_u2_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_78, MUX_MODE0, (EDGE_FALL | PULL_UP | PAD_3V_DS2))
+		>;
+	};
 };
 
 &gpio{
@@ -737,7 +745,6 @@ &pinctrl 63  GPIO_63  5
 		&pinctrl 70  PRI_TDI  4
 		&pinctrl 74  GPIO_74  1
 		&pinctrl 76  GPIO_76  1
-		&pinctrl 78  GPIO_78  1
 		&pinctrl 80  GPIO_80  4
 		&pinctrl 89  GPIO_89  4
 		&pinctrl 96  DVL0     2
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
index f5319848a118..31b01e0fceba 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
@@ -119,7 +119,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
@@ -381,7 +381,11 @@ husb239_u2: tcpc@62 {
 		vbus-gpios = <&gpio 14 0>,
 				<&gpio 92 0>;
 		chg-gpio = <&gpio 13 0>;
-		int-gpio = <&gpio 06 0>;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <28>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_husb239_u2>;
+		wakeup-source;
 		status = "disabled";
 
 		ports {
@@ -403,12 +407,16 @@ husb239_u3: tcpc@42 {
 		vbus-gpios = <&gpio 89 0>,
 				<&gpio 124 0>;
 		chg-gpio = <&gpio 04 0>;
-		int-gpio = <&gpio 01 0>;
 		aud-gpio = <&gpio 86 0>;
 		mic-gpio = <&gpio 79 0>;
 		orient-oe-gpio  = <&gpio 48 0>;
 		orient-sel-gpio = <&gpio 78 0>;
 		orientation;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <8>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_husb239_u3>;
+		wakeup-source;
 		status = "okay";
 
 		ports {
@@ -767,8 +775,7 @@ pri_sgm4154x: pri-sgm4154x@1a {
 
 &pinctrl {
 	pinctrl-single,gpio-range = <
-		&range GPIO_01  4 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
-		&range GPIO_06  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_02  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_13  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_48  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_3V_DS4)
 		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
@@ -820,12 +827,22 @@ K1X_PADCONF(MMC1_CLK,  MUX_MODE0, (EDGE_NONE | PULL_DOWN | PAD_3V_DS4))	/* mmc1_
 		>;
 	};
 
+	pinctrl_husb239_u2: husb239_u2_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_06, MUX_MODE0, (EDGE_FALL | PULL_UP | PAD_1V8_DS2))
+		>;
+	};
+
+	pinctrl_husb239_u3: husb239_u3_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_01, MUX_MODE0, (EDGE_FALL | PULL_UP | PAD_1V8_DS2))
+		>;
+	};
 };
 
 &gpio{
 	gpio-ranges = <
-		&pinctrl 01  GPIO_01  4
-		&pinctrl 06  GPIO_06  1
+		&pinctrl 02  GPIO_02  3
 		&pinctrl 13  GPIO_13  2
 		&pinctrl 48  GPIO_48  3
 		&pinctrl 58  GPIO_58  1
@@ -945,12 +962,6 @@ &udc {
 	status = "okay";
 };
 
-&ehci {
-	spacemit,reset-on-resume;
-	spacemit,udc-mode = <MV_USB_MODE_OTG>;
-	status = "disabled";
-};
-
 &otg {
 	spacemit,udc-mode = <MV_USB_MODE_OTG>;
 	usb-role-switch;
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper2.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper2.dts
new file mode 100644
index 000000000000..7d2775aefa29
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper2.dts
@@ -0,0 +1,1290 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x-efuse.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "lcd/lcd_icnl9951r_mipi.dtsi"
+#include "k1-x-lcd.dtsi"
+#include "k1-x-hdmi.dtsi"
+#include "k1-x_opp_table.dtsi"
+#include "k1-x_thermal_cooling.dtsi"
+#include "k1-x-camera-sdk.dtsi"
+#include <dt-bindings/usb/pd.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "M1-MUSE-PAPER";
+	modules_usrload = "8852bs";
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <24000000>;
+
+		cpu_0: cpu@0 {
+			cpu-ai = "true";
+		};
+
+		cpu_1: cpu@1 {
+			cpu-ai = "true";
+		};
+
+		cpu_2: cpu@2 {
+			reg = <2>;
+			cpu-ai = "true";
+		};
+
+		cpu_3: cpu@3 {
+			reg = <3>;
+			cpu-ai = "true";
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu_0>;
+				};
+
+				core1 {
+					cpu = <&cpu_1>;
+				};
+
+				core2 {
+					cpu = <&cpu_2>;
+				};
+
+				core3 {
+					cpu = <&cpu_3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu_4>;
+				};
+
+				core1 {
+					cpu = <&cpu_5>;
+				};
+
+				core2 {
+					cpu = <&cpu_6>;
+				};
+
+				core3 {
+					cpu = <&cpu_7>;
+				};
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x0 0x80000000>;
+	};
+
+	memory@100000000 {
+		device_type = "memory";
+		reg = <0x1 0x00000000 0x0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			/* alloc memory from 0x40000000~0x80000000 */
+			alloc-ranges = <0 0x40000000 0 0x40000000>;
+			/* size of cma buffer is 384MByte */
+			size = <0 0x18000000>;
+			/* start address is 1Mbyte aligned */
+			alignment = <0x0 0x100000>;
+			linux,cma-default;
+			/* besides hardware, dma for ex. buffer can be used by memory management */
+			reusable;
+		};
+
+		/* reserved 384K for dpu, including mmu table(256K) and cmdlist(128K) */
+		dpu_resv: dpu_reserved@2ff40000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x2ff40000 0x0 0x000C0000>;
+			no-map;
+		};
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
+		stdout-path = "serial0:115200n8";
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc4v0_baseboard: vcc4v0-baseboard {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc4v0_baseboard";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <4000000>;
+		regulator-max-microvolt = <4000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	rf_pwrseq: rf-pwrseq {
+		compatible = "spacemit,rf-pwrseq";
+		//vdd-supply = <&ldo_7>;
+		//vdd_voltage = <3300000>;
+		io-supply = <&dcdc_3>;
+		io_voltage = <1800000>;
+		pwr-gpios  = <&gpio 67 0>,
+			     <&gpio 03 0>;
+		status = "okay";
+
+		wlan_pwrseq: wlan-pwrseq {
+			compatible = "spacemit,wlan-pwrseq";
+			regon-gpios = <&gpio 116 0>;
+			interrupt-parent = <&pinctrl>;
+			interrupts = <268>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_wlan_wakeup>;
+		};
+
+		bt_pwrseq: bt-pwrseq {
+			compatible = "spacemit,bt-pwrseq";
+			reset-gpios     = <&gpio 63 0>;
+		};
+	};
+
+	typec_0: connector@0 {
+		compatible = "usb-c-connector";
+		label = "USB-C";
+		data-role = "dual";
+		power-role = "dual";
+		try-power-role = "sink";
+		source-pdos = <PDO_FIXED(5000, 500, PDO_FIXED_USB_COMM)>;
+		sink-pdos = <PDO_FIXED(5000, 500, PDO_FIXED_USB_COMM)
+				PDO_VAR(5000, 9000, 2000)>;
+		op-sink-microwatt = <10000000>;
+
+		ports {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			port@0 {
+				reg = <0x0>;
+				otg_con_ep: endpoint {
+					remote-endpoint = <&con_u2_ep>;
+				};
+			};
+			port@1 {
+				reg = <0x1>;
+				otg_ep: endpoint {
+					remote-endpoint = <&otg_role_switch>;
+				};
+			};
+		};
+	};
+
+	typec_1: connector@1 {
+		compatible = "usb-c-connector";
+		label = "USB-C";
+		data-role = "dual";
+		power-role = "dual";
+		try-power-role = "sink";
+		source-pdos = <PDO_FIXED(5000, 500, PDO_FIXED_USB_COMM)>;
+		sink-pdos = <PDO_FIXED(5000, 500, PDO_FIXED_USB_COMM)
+				PDO_VAR(5000, 9000, 2000)>;
+		op-sink-microwatt = <10000000>;
+
+		ports {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			port@0 {
+				reg = <0x0>;
+				dwc3_con_ep: endpoint {
+					remote-endpoint = <&con_u3_ep>;
+				};
+			};
+			port@1 {
+				reg = <0x1>;
+				dwc3_ep: endpoint {
+					remote-endpoint = <&dwc3_role_switch>;
+				};
+			};
+		};
+	};
+
+	usb2hub: usb2hub {
+		compatible = "spacemit,usb3-hub";
+		vbus-gpios = <&gpio 91 0>;	/* for usb2 hub output vbus */
+		status = "okay";
+	};
+
+	hall_sensor: hall-sensor {
+		compatible = "spacemit,hall-sensor-as1911";
+		detect-gpio = <&gpio 74 0>;
+	};
+
+	gpio_keys: gpio_keys {
+		compatible = "gpio-keys";
+
+		key0: volumeup {
+			label = "KEY0";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&gpio 70 GPIO_ACTIVE_LOW>;
+		};
+
+		key1: volumedown {
+			label = "KEY1";
+			linux,code = <KEY_VOLUMEDOWN>;
+			gpios = <&gpio 71 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0_2>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&pwm14 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm14_1>;
+	status = "okay";
+};
+
+&dpu_online2_dsi {
+	memory-region = <&dpu_resv>;
+	spacemit-dpu-bitclk = <1000000000>;
+	spacemit-dpu-escclk = <76800000>;
+	dsi_1v2-supply = <&ldo_5>;
+	dsi_1v8-supply = <&ldo_11>;
+	vin-supply-names = "dsi_1v2", "dsi_1v8";
+	status = "okay";
+};
+
+&dsi2 {
+	status = "okay";
+
+	panel2: panel2@0 {
+		status = "ok";
+		compatible = "spacemit,mipi-panel2";
+		reg = <0>;
+
+		gpios-reset = <30>;
+		gpios-dc = <34 42>;
+		gpios-avdd = <35 36>;
+		gpios-bl = <31>;
+		id = <2>;
+		delay-after-reset = <10>;
+		force-attached = "lcd_icnl9951r_mipi";
+	};
+};
+
+&lcds {
+	status = "okay";
+};
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+};
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+};
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
+		status = "okay";
+
+		mac_address0: mac_address0@0 {
+			reg = <0x0 6>;
+		};
+
+		mac_address1: mac_address1@6 {
+			reg = <0x6 6>;
+		};
+	};
+
+	es8326: es8326@19{
+		compatible = "everest,es8326";
+		reg = <0x19>;
+		#sound-dai-cells = <0>;
+		interrupt-parent = <&gpio>;
+		interrupts = <126 1>;
+		spk-ctl-gpio = <&gpio 127 0>;
+		everest,jack-detect-inverted;
+		everest,mic1-src = [44];
+		everest,mic2-src = [66];
+		status = "okay";
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4_2>;
+	status = "okay";	
+
+	husb239_u2: tcpc@62 {
+		compatible = "hynetek,husb239";
+		reg = <0x62>;
+		vbus-gpios = <&gpio 14 0>,
+				<&gpio 92 0>;
+		chg-gpio = <&gpio 13 0>;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <28>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_husb239_u2>;
+		wakeup-source;
+		status = "okay";
+
+		ports {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			port@0 {
+				reg = <0x0>;
+				con_u2_ep: endpoint {
+					remote-endpoint = <&otg_con_ep>;
+				};
+			};
+		};
+	};
+
+	husb239_u3: tcpc@42 {
+		compatible = "hynetek,husb239";
+		reg = <0x42>;
+		vbus-gpios = <&gpio 89 0>,
+				<&gpio 124 0>;
+		chg-gpio = <&gpio 04 0>;
+		aud-gpio = <&gpio 86 0>;
+		mic-gpio = <&gpio 79 0>;
+		orient-oe-gpio  = <&gpio 48 0>;
+		orient-sel-gpio = <&gpio 78 0>;
+		orientation;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <8>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_husb239_u3>;
+		wakeup-source;
+		status = "okay";
+
+		ports {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			port@0 {
+				reg = <0x0>;
+				con_u3_ep: endpoint {
+					remote-endpoint = <&dwc3_con_ep>;
+				};
+			};
+		};
+	};
+};
+
+&i2c5 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_i2c5_0>;
+        status = "okay";
+
+	accelerometer: accel@15 {
+		compatible = "memsic,mxc4005";
+		reg = <0x15>;
+		status = "okay";
+	};
+
+        icm42607@68 {
+                compatible = "invn,icm42607";
+                reg = <0x68>;
+        };
+
+	light: light-sensor@48 {
+		compatible = "sensortek,stk3311";
+		reg = <0x48>;
+		proximity-near-level = <25>;
+		interrupt-parent = <&gpio>;
+		interrupts = <72 2>; /* PB0 */
+		pwr-gpios = <&gpio 73 0>;
+		status = "okay";
+	};
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6_0>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	ocp2138@3e {
+		compatible = "spacemit,lcd_bias_ocp2138";
+		reg = <0x3e>;
+		status = "okay";
+	};
+
+	sec_sgm4154x: sec-sgm4154x@1a {
+		status = "okay";
+		compatible = "sgm,sgm41515";
+		secondary-charger;
+		reg = <0x1a>;
+		interrupt-parent = <&gpio>;
+		interrupts = <123 0>;            //irq num base on hardware design
+		sgm,irq-gpio = <&gpio 123 0>;     //irq num base on hardware design
+		sgm,chg-en-gpio = <&gpio 46 0>;   //charger enable gpio num base on hardware design
+		nqon-gpios = <&gpio 43 0>;
+		/* sw jeita  parameter customer defined*/
+		enable_sw_jeita;
+		jeita_temp_above_t4_cv = <0>;
+		jeita_temp_t3_to_t4_cv = <4100000>;
+		jeita_temp_t2_to_t3_cv = <4350000>;
+		jeita_temp_t1_to_t2_cv = <4350000>;
+		jeita_temp_t0_to_t1_cv = <0>;
+		jeita_temp_below_t0_cv = <0>;
+
+		jeita_temp_above_t4_cc_current = <0>;
+		jeita_temp_t3_to_t4_cc_current = <1000000>;
+		jeita_temp_t2_to_t3_cc_current = <1250000>;
+		jeita_temp_t1_to_t2_cc_current = <1000000>;
+		jeita_temp_below_t0_cc_current = <0>;
+
+		temp_t4_thres = <50>;
+		temp_t4_thres_minus_x_degree = <48>;
+		temp_t3_thres = <45>;
+		temp_t3_thres_minus_x_degree = <45>;
+		temp_t2_thres = <20>;
+		temp_t2_thres_plus_x_degree = <15>;
+		temp_t1_thres = <0>;
+		temp_t1_thres_plus_x_degree = <0>;
+		temp_t0_thres = <0>;
+		temp_t0_thres_plus_x_degree = <2>;
+		temp_neg_10_thres = <0>;
+
+		sgm415xx-ichrg-uA = <1000000>;
+		sgm415xx-vchrg-uV = <4350000>;
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c8>;
+	status = "okay";
+
+	spm8821@41 {
+		compatible = "spacemit,spm8821";
+		reg = <0x41>;
+		interrupt-parent = <&intc>;
+		interrupts = <64>;
+		status = "okay";
+
+		vcc_sys-supply = <&vcc4v0_baseboard>;
+		dcdc5-supply = <&dcdc_5>;
+
+		regulators {
+			compatible = "pmic,regulator,spm8821";
+
+			/* buck */
+			dcdc_1: DCDC_REG1 {
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <650000>;
+				};
+			};
+
+			dcdc_2: DCDC_REG2 {
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_3: DCDC_REG3 {
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_4: DCDC_REG4 {
+				regulator-name = "dcdc4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			dcdc_5: DCDC_REG5 {
+				regulator-name = "dcdc5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_6: DCDC_REG6 {
+				regulator-name = "dcdc6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			/* aldo */
+			ldo_1: LDO_REG1 {
+				regulator-name = "ldo1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_2: LDO_REG2 {
+				regulator-name = "ldo2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_3: LDO_REG3 {
+				regulator-name = "ldo3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_4: LDO_REG4 {
+				regulator-name = "ldo4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			/* dldo */
+			ldo_5: LDO_REG5 {
+				regulator-name = "ldo5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_6: LDO_REG6 {
+				regulator-name = "ldo6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_7: LDO_REG7 {
+				regulator-name = "ldo7";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_8: LDO_REG8 {
+				regulator-name = "ldo8";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_9: LDO_REG9 {
+				regulator-name = "ldo9";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_10: LDO_REG10 {
+				regulator-name = "ldo10";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_11: LDO_REG11 {
+				regulator-name = "ldo11";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			sw_1: SWITCH_REG1 {
+				regulator-name = "switch1";
+			};
+		};
+
+		pmic_pinctrl: pinctrl {
+			compatible = "pmic,pinctrl,spm8821";
+			gpio-controller;
+			#gpio-cells = <2>;
+			spacemit,npins = <6>;
+/**
+ *			led_pins: led-pins {
+ *				pins = "PIN3";
+ *				function = "sleep";
+ *				bias-disable = <0>;
+ *				drive-open-drain = <0x1>;
+ *			};
+ */
+		};
+
+		pwr_key: key {
+			compatible = "pmic,pwrkey,spm8821";
+		};
+
+		ext_rtc: rtc {
+			compatible = "pmic,rtc,spm8821";
+		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
+	};
+
+	cw2015: cw2015@62 {
+		compatible = "cellwise,cw2015";
+		reg = <0x62>;
+		cellwise,battery-profile = /bits/ 8 <
+			0x17 0x67 0x73 0x69 0x68 0x65 0x64 0x55
+			0x75 0x60 0x4A 0x57 0x57 0x4E 0x42 0x3A
+			0x30 0x28 0x23 0x1E 0x23 0x35 0x46 0x4D
+			0x14 0x86 0x06 0x66 0x25 0x45 0x51 0x63
+			0x72 0x69 0x66 0x6B 0x3F 0x1B 0x78 0x39
+			0x0A 0x2F 0x1A 0x46 0x88 0x94 0x9B 0x12
+			0x3B 0x5F 0x9A 0xB6 0x80 0x57 0x7F 0xCB
+			0x2F 0x00 0x64 0xA5 0xB5 0xC1 0x46 0xAE
+		>;
+		status = "okay";
+	};
+
+	pri_sgm4154x: pri-sgm4154x@1a {
+		status = "okay";
+		compatible = "sgm,sgm41515";
+		reg = <0x1a>;
+		primary-charger;
+		interrupt-parent = <&gpio>;
+		interrupts = <5 0>;            //irq num base on hardware design
+		sgm,irq-gpio = <&gpio 5 0>;     //irq num base on hardware design
+		sgm,chg-en-gpio = <&gpio 117 0>;   //charger enable gpio num base on hardware design
+		nqon-gpios = <&gpio 115 0>;
+		/* sw jeita  parameter customer defined*/
+		enable_sw_jeita;
+		jeita_temp_above_t4_cv = <0>;
+		jeita_temp_t3_to_t4_cv = <4100000>;
+		jeita_temp_t2_to_t3_cv = <4350000>;
+		jeita_temp_t1_to_t2_cv = <4350000>;
+		jeita_temp_t0_to_t1_cv = <0>;
+		jeita_temp_below_t0_cv = <0>;
+
+		jeita_temp_above_t4_cc_current = <0>;
+		jeita_temp_t3_to_t4_cc_current = <1000000>;
+		jeita_temp_t2_to_t3_cc_current = <1250000>;
+		jeita_temp_t1_to_t2_cc_current = <1000000>;
+		jeita_temp_below_t0_cc_current = <0>;
+
+		temp_t4_thres = <50>;
+		temp_t4_thres_minus_x_degree = <48>;
+		temp_t3_thres = <45>;
+		temp_t3_thres_minus_x_degree = <45>;
+		temp_t2_thres = <20>;
+		temp_t2_thres_plus_x_degree = <15>;
+		temp_t1_thres = <0>;
+		temp_t1_thres_plus_x_degree = <0>;
+		temp_t0_thres = <0>;
+		temp_t0_thres_plus_x_degree = <2>;
+		temp_neg_10_thres = <0>;
+
+		sgm415xx-ichrg-uA = <1000000>;
+		sgm415xx-vchrg-uV = <4350000>;
+	};
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_02  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_13  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_48  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_3V_DS4)
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_66  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_76  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_78  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_86  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_89  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     2 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	pinctrl_rcpu: pinctrl_rcpu_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_47,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_tx */
+			K1X_PADCONF(GPIO_48,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_rx */
+		>;
+	};
+
+	pinctrl_wlan_wakeup: wlan_wakeup_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_FALL | PULL_DOWN | PAD_3V_DS2))   /* wifi edge detect */
+		>;
+	};
+
+	pinctrl_mmc1_debug: mmc1_debug_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(MMC1_DAT3, MUX_MODE3, (EDGE_NONE | PULL_UP   | PAD_3V_DS4))	/* uart0_txd */
+			K1X_PADCONF(MMC1_DAT2, MUX_MODE3, (EDGE_NONE | PULL_UP   | PAD_3V_DS4))	/* uart0_rxd */
+			K1X_PADCONF(MMC1_DAT1, MUX_MODE0, (EDGE_NONE | PULL_UP   | PAD_3V_DS4))	/* mmc1_d1 */
+			K1X_PADCONF(MMC1_DAT0, MUX_MODE0, (EDGE_NONE | PULL_UP   | PAD_3V_DS4))	/* mmc1_d0 */
+			K1X_PADCONF(MMC1_CMD,  MUX_MODE0, (EDGE_NONE | PULL_UP   | PAD_3V_DS4))	/* mmc1_cmd */
+			K1X_PADCONF(MMC1_CLK,  MUX_MODE0, (EDGE_NONE | PULL_DOWN | PAD_3V_DS4))	/* mmc1_clk */
+		>;
+	};
+
+	pinctrl_husb239_u2: husb239_u2_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_06, MUX_MODE0, (EDGE_FALL | PULL_UP | PAD_1V8_DS2))
+		>;
+	};
+
+	pinctrl_husb239_u3: husb239_u3_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_01, MUX_MODE0, (EDGE_FALL | PULL_UP | PAD_1V8_DS2))
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 02  GPIO_02  3
+		&pinctrl 13  GPIO_13  2
+		&pinctrl 48  GPIO_48  3
+		&pinctrl 58  GPIO_58  1
+		&pinctrl 63  GPIO_63  5
+		&pinctrl 70  PRI_TDI  4
+		&pinctrl 74  GPIO_74  1
+		&pinctrl 76  GPIO_76  1
+		&pinctrl 78  GPIO_78  6
+		&pinctrl 86  GPIO_86  1
+		&pinctrl 89  GPIO_89  4
+		&pinctrl 96  DVL0     2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+/* SD */
+&sdhci0 {
+	pinctrl-names = "default","fast","debug";
+	pinctrl-0 = <&pinctrl_mmc1>;
+	pinctrl-1 = <&pinctrl_mmc1_fast>;
+	pinctrl-2 = <&pinctrl_mmc1_debug>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	vmmc-supply = <&dcdc_4>;
+	vqmmc-supply = <&ldo_1>;
+	no-mmc;
+	no-sdio;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_SDR12 |
+			MMC_CAP_UHS_SDR25
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_INVERTED_WRITE_PROTECT |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE |
+			SDHCI_QUIRK2_SET_AIB_MMC
+			)>;
+	spacemit,aib_mmc1_io_reg = <0xD401E81C>;
+	spacemit,apbc_asfar_reg = <0xD4015050>;
+	spacemit,apbc_assar_reg = <0xD4015054>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0x7f>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <204800000>;
+	status = "okay";
+};
+
+/* SDIO */
+&sdhci1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc2>;
+	bus-width = <4>;
+	non-removable;
+	vqmmc-supply = <&dcdc_3>;
+	no-mmc;
+	no-sd;
+	keep-power-in-suspend;
+	/* bcmdhd use private oob solution rather than dat1/standard wakeup */
+	/delete-property/ enable-sdio-wakeup;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_DDR50 |
+			MMC_CAP_NEEDS_POLL
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE
+			)>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0xaf>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	no-sd;
+	no-sdio;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN
+			)>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&ehci {
+	spacemit,reset-on-resume;
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	status = "okay";
+};
+
+&udc {
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	status = "okay";
+};
+
+&otg {
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	usb-role-switch;
+	role-switch-user-control;
+	spacemit,reset-on-resume;
+	status = "okay";
+
+	usb-role-switch;
+	role-switch-default-mode = "peripheral";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0x0>;
+			otg_role_switch: endpoint {
+				remote-endpoint = <&otg_ep>;
+			};
+		};
+	};
+};
+
+&usbphy1 {
+	status = "okay";
+};
+
+&udc1 {
+	/*spacemit,udc-mode = <MV_USB_MODE_UDC>;*/
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	status = "disabled";
+};
+
+&ehci1 {
+	spacemit,reset-on-resume;
+	status = "okay";
+};
+
+&otg1 {
+	usb-role-switch;
+	role-switch-user-control;
+	spacemit,reset-on-resume;
+	role-switch-default-mode = "host";
+	vbus-gpios = <&gpio 123 0>;
+	status = "disabled";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usb3hub {
+	vbus-gpios = <&gpio 89 0>,
+		     <&gpio 124 0>;
+	status = "disabled";
+};
+
+&usbdrd3 {
+	status = "okay";
+	reset-on-resume;
+	dwc3@c0a00000 {
+		dr_mode = "otg";
+		phy_type = "utmi";
+		snps,hsphy_interface = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		snps,parkmode-disable-ss-quirk;
+
+		usb-role-switch;
+		role-switch-default-mode = "peripheral";
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0x0>;
+				dwc3_role_switch: endpoint {
+					remote-endpoint = <&dwc3_ep>;
+				};
+			};
+		};
+	};
+};
+
+&imggpu {
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "disabled";
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&spi3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ssp3_1>;
+	status = "okay";
+
+	chipone_tddi@0 {
+		compatible = "chipone-tddi";
+		reg = <0>;
+		spi-max-frequency = <9600000>;
+		//interrupt-parent = <&gpio>;
+		//interrupts = <29 0x2008>;
+		chipone,rst-gpio = <&gpio 32 0x00>;
+		chipone,irq-gpio = <&gpio 29 0x00>;
+		pwron-gpios = <&gpio 33 0>;
+		//chipone,cs-gpio = <&gpio 8 0>;
+		chipone,x-res = <1200>;
+		chipone,y-res = <1920>;
+
+		/* Charger detect */
+		chipone,touch-charger-detect-enable;
+		chipone,touch-charger-detect-type = "notify"; /* notify, poll */
+		chipone,touch-charger-detect-psy-name = "charger";
+		chipone,touch-charger-detect-psp = "POWER_SUPPLY_PROP_ONLINE";
+		chipone,touch-charger-detect-psp-poll-interval = <1000>;
+
+		/* Earjack detect */
+		chipone,touch-earjack-detect-enable;
+		/* MTK:  /sys/bus/platform/drivers/Accdet_Driver/state,
+			Sprd: /sys/kernel/headset/state
+			QCOM: None, and disable it */
+		chipone,touch-earjack-state-filepath = "/sys/bus/platform/drivers/Accdet_Driver/state";
+		chipone,touch-earjack-poll-interval = <1000>;
+
+		/* For tp selftest */
+		chipone,test-reset-pin;
+		chipone,test-int-pin;
+		chipone,test-rawdata;
+		chipone,test-rawdata-frames      = <1>;
+		chipone,rawdata-min              = <100>;
+		chipone,rawdata-max              = <10000>;
+		chipone,test-noise;
+		chipone,test-noise-frames        = <50>;
+		chipone,noise-max                = <1000>;
+		chipone,test-open;
+		chipone,open-min                 = <200>;
+		chipone,test-short;
+		chipone,short-min                = <200>;
+		chipone,test-compensate-cap;
+		chipone,compensate-cap-min       = <1>;
+		chipone,compensate-cap-max       = <127>;
+
+		/* gesture data test */
+		chipone,test-gesture-rawdata;
+		chipone,test-gesture-rawdata-frames = <1>;
+		chipone,gesture-rawdata-min = <100>;
+		chipone,gesture-rawdata-max = <10000>;
+
+		chipone,test-gesture-lp-rawdata;
+		chipone,test-gesture-lp-rawdata-frames = <1>;
+		chipone,gesture-lp-rawdata-min = <100>;
+		chipone,gesture-lp-rawdata-max = <10000>;
+
+		chipone,test-gesture-noise;
+		chipone,test-gesture-noise-frames = <50>;
+		chipone,gesture-noise-max = <1000>;
+
+		chipone,test-gesture-lp-noise;
+		chipone,test-gesture-lp-noise-frames = <50>;
+		chipone,gesture-lp-noise-max = <1000>;
+		chipone,panel = <&panel2>;
+	};
+};
+
+&pwm_bl {
+	pwms = <&pwm14 2000>;
+	brightness-levels = <
+		0   20  20  20  21  21  21  22  22  22  23  23  23  24  24  24
+		25  25  25  26  26  26  27  27  27  28  28  29  29  30  30  31
+		32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47
+		48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63
+		64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79
+		80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
+		96  97  98  99  100 101 102 103 104 105 106 107 108 109 110 111
+		112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
+		128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143
+		144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
+		160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
+		176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
+		192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
+		208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
+		224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239
+		240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255
+	>;
+	default-brightness-level = <100>;
+
+	status = "okay";
+};
+
+/* MIPI CSI1, clk lane1, Fixme: frontsensor gc08a8 */
+&backsensor {
+	af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 113 0>;
+	reset-gpios = <&gpio 111 0>;
+
+	twsi-index = <0>;
+
+	status = "okay";
+};
+
+/* MIPI CSI3 data line2,3 clk lane2 */
+&backsensor_aux {
+	//af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	//dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 114 0>;
+	reset-gpios = <&gpio 112 0>;
+
+	twsi-index = <1>;
+
+	status = "disabled";
+};
+
+/* MIPI CSI3 data line0,1 clk lane3, Fixme: backsensor gc13a0 */
+&frontsensor {
+	af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	clocks = <&ccu CLK_CAMM1>;
+	clock-names = "cam_mclk1";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_camera1>;
+
+	pwdn-gpios = <&gpio 114 0>;
+	reset-gpios = <&gpio 112 0>;
+
+	twsi-index = <1>;
+
+	status = "okay";
+};
+&csiphy0 {
+
+	status = "okay";
+};
+&csiphy1 {
+
+	status = "disabled";
+};
+&csiphy2 {
+
+	status = "okay";
+};
+
+&ccic0 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic1 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic2 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&isp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&cpp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&vi {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+&rcpu {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rcpu>;
+	mboxes = <&mailbox 0>, <&mailbox 1>;
+	mbox-names = "vq0", "vq1";
+	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>;
+	status = "okay";
+};
+
+&i2s0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_sspa0_0>;
+        status = "okay";
+};
+
+&sound_codec {
+	status = "okay";
+	simple-audio-card,name = "snd-es8326";
+	spacemit,mclk-fs = <64>;
+	simple-audio-card,codec {
+		sound-dai = <&es8326>;
+	};
+};
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
index 13393ae8d670..9107d43c3091 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_ZT001H.dts b/arch/riscv/boot/dts/spacemit/k1-x_ZT001H.dts
index b45155f56113..460bcbaf4003 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_ZT001H.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_ZT001H.dts
@@ -6,7 +6,7 @@
 #include "k1-x.dtsi"
 #include "k1-x-efuse.dtsi"
 #include "k1-x_pinctrl.dtsi"
-#include "lcd/lcd_icnl9951r_mipi.dtsi"
+#include "lcd/lcd_ft8201sinx101_mipi.dtsi"
 #include "k1-x-lcd.dtsi"
 #include "k1-x-hdmi.dtsi"
 #include "k1-x_opp_table.dtsi"
@@ -18,6 +18,7 @@
 
 / {
 	model = "ZT001H";
+	modules_usrload = "aic8800_bsp,aic8800_fdrv,aic8800_btlpm";
 
 	cpus: cpus {
 		#address-cells = <1>;
@@ -118,7 +119,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
@@ -141,20 +142,19 @@ vcc4v0_baseboard: vcc4v0-baseboard {
 		vin-supply = <&dc_12v>;
 	};
 
-/*
+
 	rf_pwrseq: rf-pwrseq {
 		compatible = "spacemit,rf-pwrseq";
 		//vdd-supply = <&ldo_7>;
 		//vdd_voltage = <3300000>;
-		io-supply = <&dcdc_3>;
+		io-supply = <&ldo_8>;
 		io_voltage = <1800000>;
-		pwr-gpios  = <&gpio 67 0>,
-			     <&gpio 03 0>;
+		pwr-gpios  = <&gpio 03 0>;
 		status = "okay";
 
 		wlan_pwrseq: wlan-pwrseq {
 			compatible = "spacemit,wlan-pwrseq";
-			regon-gpios = <&gpio 116 0>;
+			regon-gpios = <&gpio 67 0>;
 			interrupt-parent = <&pinctrl>;
 			interrupts = <268>;
 			pinctrl-names = "default";
@@ -166,7 +166,7 @@ bt_pwrseq: bt-pwrseq {
 			reset-gpios     = <&gpio 63 0>;
 		};
 	};
-*/
+
 
 	gpio_keys: gpio_keys {
 		compatible = "gpio-keys";
@@ -203,11 +203,9 @@ &pwm14 {
 	status = "okay";
 };
 
-/*
 &dpu_online2_dsi {
 	memory-region = <&dpu_resv>;
-	spacemit-dpu-bitclk = <1000000000>;
-	spacemit-dpu-escclk = <76800000>;
+	spacemit-dpu-bitclk = <614000000>;
 	dsi_1v2-supply = <&ldo_5>;
 	dsi_1v8-supply = <&ldo_11>;
 	vin-supply-names = "dsi_1v2", "dsi_1v8";
@@ -228,14 +226,13 @@ panel2: panel2@0 {
 		gpios-bl = <31>;
 		id = <2>;
 		delay-after-reset = <10>;
-		force-attached = "lcd_icnl9951r_mipi";
+		force-attached = "lcd_ft8201sinx101_mipi";
 	};
 };
 
 &lcds {
 	status = "okay";
 };
-*/
 
 &i2c0 {
 	pinctrl-names = "default";
@@ -298,6 +295,18 @@ &i2c5 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c5_0>;
 	status = "okay";
+
+	focaltech@38{
+                compatible = "focaltech,fts";
+                reg = <0x38>;
+                interrupt-parent = <&gpio>;
+                interrupts = <29 0x02>;
+                vdd-supply = <&ldo_11>;
+                focaltech,reset-gpio = <&gpio 32 0x01>;
+                focaltech,irq-gpio = <&gpio 29 0x02>;
+                focaltech,max-touch-number = <10>;
+                focaltech,display-coords =  <0 0 800 1280>;
+        };
 };
 
 
@@ -568,17 +577,17 @@ sgm4154x: sgm4154x@1a {
 	cw2015: cw2015@62 {
 		compatible = "cellwise,cw2015";
 		reg = <0x62>;
-/*		cellwise,battery-profile = /bits/ 8 <
-			0x17 0x67 0x73 0x69 0x68 0x65 0x64 0x55
-			0x75 0x60 0x4A 0x57 0x57 0x4E 0x42 0x3A
-			0x30 0x28 0x23 0x1E 0x23 0x35 0x46 0x4D
-			0x14 0x86 0x06 0x66 0x25 0x45 0x51 0x63
-			0x72 0x69 0x66 0x6B 0x3F 0x1B 0x78 0x39
-			0x0A 0x2F 0x1A 0x46 0x88 0x94 0x9B 0x12
-			0x3B 0x5F 0x9A 0xB6 0x80 0x57 0x7F 0xCB
+		cellwise,battery-profile = /bits/ 8 <
+			0x18 0x0A 0x8F 0x78 0x6D 0x6D 0x6D 0x6E
+			0x6E 0x6C 0x6A 0x69 0x66 0x5F 0x65 0x5D
+			0x4C 0x41 0x33 0x2C 0x28 0x27 0x2C 0x3A
+			0x46 0x4C 0x0C 0xCD 0x25 0x45 0x47 0x48
+			0x49 0x49 0x48 0x47 0x36 0x0F 0x65 0x11
+			0x02 0x21 0x3C 0x69 0x8A 0x92 0x93 0x32
+			0x4C 0x7D 0x98 0x9F 0x80 0x4F 0x9D 0xCB
 			0x2F 0x00 0x64 0xA5 0xB5 0xC1 0x46 0xAE
 		>;
-*/		status = "okay";
+		status = "okay";
 	};
 };
 
@@ -666,7 +675,7 @@ &sdhci1 {
 	pinctrl-0 = <&pinctrl_mmc2>;
 	bus-width = <4>;
 	non-removable;
-	vqmmc-supply = <&dcdc_3>;
+	vqmmc-supply = <&ldo_8>;
 	no-mmc;
 	no-sd;
 	keep-power-in-suspend;
@@ -724,7 +733,6 @@ &udc {
 	status = "okay";
 };
 
-/*
 &otg {
 	spacemit,udc-mode = <MV_USB_MODE_OTG>;
 	usb-role-switch;
@@ -734,18 +742,7 @@ &otg {
 
 	usb-role-switch;
 	role-switch-default-mode = "peripheral";
-	ports {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		port@0 {
-			reg = <0x0>;
-			otg_role_switch: endpoint {
-				remote-endpoint = <&otg_ep>;
-			};
-		};
-	};
 };
-*/
 
 &usbphy1 {
 	status = "okay";
@@ -754,11 +751,12 @@ &usbphy1 {
 &udc1 {
 	/*spacemit,udc-mode = <MV_USB_MODE_UDC>;*/
 	spacemit,udc-mode = <MV_USB_MODE_OTG>;
-	status = "disabled";
+	status = "okay";
 };
 
 &ehci1 {
 	spacemit,reset-on-resume;
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
 	status = "okay";
 };
 
@@ -767,21 +765,26 @@ &otg1 {
 	role-switch-user-control;
 	spacemit,reset-on-resume;
 	role-switch-default-mode = "host";
-	vbus-gpios = <&gpio 123 0>;
-	status = "disabled";
+	/* vbus-gpios = <&gpio 123 0>; */
+	status = "okay";
 };
 
 &usb2phy {
-	status = "okay";
+	status = "disabled";
 };
 
 &combphy {
+	status = "disabled";
+};
+
+&usb3hub {
+	/* gpio_124 for ehci1 dcdc-boost, gpio_89 for vbus */
+	vbus-gpios = <&gpio 124 0 &gpio 89 0>;
 	status = "okay";
 };
 
-/*
 &usbdrd3 {
-	status = "okay";
+	status = "disabled";
 	reset-on-resume;
 	dwc3@c0a00000 {
 		dr_mode = "otg";
@@ -793,22 +796,10 @@ dwc3@c0a00000 {
 		snps,dis-del-phy-power-chg-quirk;
 		snps,dis-tx-ipgap-linecheck-quirk;
 		snps,parkmode-disable-ss-quirk;
-
 		usb-role-switch;
-		role-switch-default-mode = "peripheral";
-		ports {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			port@0 {
-				reg = <0x0>;
-				dwc3_role_switch: endpoint {
-					remote-endpoint = <&dwc3_ep>;
-				};
-			};
-		};
+		role-switch-default-mode = "host";
 	};
 };
-*/
 
 &imggpu {
 	status = "okay";
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts b/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
index 3284d8f86537..d58d5478b250 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_bit-brick.dts b/arch/riscv/boot/dts/spacemit/k1-x_bit-brick.dts
new file mode 100644
index 000000000000..8c123ed04846
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/k1-x_bit-brick.dts
@@ -0,0 +1,1125 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x-efuse.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "lcd/lcd_jd9365aainx101_mipi.dtsi"
+#include "k1-x-lcd.dtsi"
+#include "k1-x-hdmi.dtsi"
+#include "k1-x_opp_table.dtsi"
+#include "k1-x_thermal_cooling.dtsi"
+#include "k1-x-camera-sdk.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/usb/pd.h>
+
+/ {
+	model = "spacemit k1-x bit-brick board";
+	modules_usrload = "8852bs";
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <24000000>;
+
+		cpu_0: cpu@0 {
+			cpu-ai = "true";
+		};
+
+		cpu_1: cpu@1 {
+			cpu-ai = "true";
+		};
+
+		cpu_2: cpu@2 {
+			reg = <2>;
+			cpu-ai = "true";
+		};
+
+		cpu_3: cpu@3 {
+			reg = <3>;
+			cpu-ai = "true";
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu_0>;
+				};
+
+				core1 {
+					cpu = <&cpu_1>;
+				};
+
+				core2 {
+					cpu = <&cpu_2>;
+				};
+
+				core3 {
+					cpu = <&cpu_3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu_4>;
+				};
+
+				core1 {
+					cpu = <&cpu_5>;
+				};
+
+				core2 {
+					cpu = <&cpu_6>;
+				};
+
+				core3 {
+					cpu = <&cpu_7>;
+				};
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x0 0x80000000>;
+	};
+
+	memory@100000000 {
+		device_type = "memory";
+		reg = <0x1 0x00000000 0x0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			/* alloc memory from 0x40000000~0x80000000 */
+			alloc-ranges = <0 0x40000000 0 0x40000000>;
+			/* size of cma buffer is 384MByte */
+			size = <0 0x18000000>;
+			/* start address is 1Mbyte aligned */
+			alignment = <0x0 0x100000>;
+			linux,cma-default;
+			/* besides hardware, dma for ex. buffer can be used by memory management */
+			reusable;
+		};
+
+		/* reserved 384K for dpu, including mmu table(256K) and cmdlist(128K) */
+		dpu_resv: dpu_reserved@2ff40000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x2ff40000 0x0 0x000C0000>;
+			no-map;
+		};
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
+		stdout-path = "serial0:115200n8";
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc4v0_baseboard: vcc4v0-baseboard {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc4v0_baseboard";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <4000000>;
+		regulator-max-microvolt = <4000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	rf_pwrseq: rf-pwrseq {
+		compatible = "spacemit,rf-pwrseq";
+		//vdd-supply = <&ldo_7>;
+		//vdd_voltage = <3300000>;
+		io-supply = <&dcdc_3>;
+		io_voltage = <1800000>;
+		pwr-gpios  = <&gpio 67 0>;
+		status = "okay";
+
+		wlan_pwrseq: wlan-pwrseq {
+			compatible = "spacemit,wlan-pwrseq";
+			regon-gpios = <&gpio 116 0>;
+			interrupt-parent = <&pinctrl>;
+			interrupts = <268>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_wlan_wakeup>;
+		};
+
+		bt_pwrseq: bt-pwrseq {
+			compatible = "spacemit,bt-pwrseq";
+			reset-gpios     = <&gpio 63 0>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led1 {
+			label = "sys-led";
+			gpios = <&gpio 96 0>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+			status = "okay";
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0_2>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&pwm14 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm14_1>;
+	status = "okay";
+};
+
+&dpu_online2_dsi {
+	memory-region = <&dpu_resv>;
+	spacemit-dpu-bitclk = <500000000>;
+	dsi_1v2-supply = <&ldo_5>;
+	vin-supply-names = "dsi_1v2";
+	status = "okay";
+};
+
+&dsi2 {
+	status = "okay";
+
+	panel2: panel2@0 {
+		status = "okay";
+		compatible = "spacemit,mipi-panel2";
+		reg = <0>;
+
+		gpios-reset = <43>;
+		gpios-dc = <42 83>;
+		id = <2>;
+		delay-after-reset = <10>;
+		force-attached = "lcd_jd9365aainx101_mipi";
+	};
+};
+
+&lcds {
+	status = "okay";
+};
+
+/* &dpu_online2_hdmi { */
+/* 	memory-region = <&dpu_resv>; */
+/* 	status = "okay"; */
+/* }; */
+
+/* &hdmi{ */
+/* 	pinctrl-names = "default"; */
+/* 	pinctrl-0 = <&pinctrl_hdmi_0>; */
+/* 	status = "okay"; */
+/* }; */
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+
+	smtouch@2e {
+		compatible = "chipsemi,chsc_cap_touch";
+		reg = <0x2e>;
+		chipsemi,int-gpio = <&gpio 29 0>;
+		chipsemi,rst-gpio = <&gpio 32 0>;
+		pwr-gpios  = <&gpio 33 0>;
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
+		status = "disabled";
+
+		mac_address0: mac_address0@0 {
+			reg = <0x0 6>;
+		};
+
+		mac_address1: mac_address1@6 {
+			reg = <0x6 6>;
+		};
+	};
+
+	es8326: es8326@19{
+		compatible = "everest,es8326";
+		reg = <0x19>;
+		#sound-dai-cells = <0>;
+		interrupt-parent = <&gpio>;
+		interrupts = <126 1>;
+		spk-ctl-gpio = <&gpio 127 0>;
+		everest,jack-detect-inverted;
+		everest,mic1-src = [66];
+		everest,mic2-src = [66];
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_2>;
+	status = "disabled";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4_2>;
+	status = "disabled";
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6_2>;
+	status = "disabled";
+
+	gt9xx@5d {
+		compatible = "goodix,gt9xx";
+		reg = <0x5d>;
+
+		reset-gpios = <&gpio 114 GPIO_ACTIVE_HIGH>;
+		irq-gpios = <&gpio 58 GPIO_ACTIVE_HIGH>;
+		irq-flags = <2>;
+
+		touchscreen-max-id = <11>;
+		touchscreen-size-x = <1200>;
+		touchscreen-size-y = <1920>;
+		touchscreen-max-w = <512>;
+		touchscreen-max-p = <512>;
+
+		goodix,int-sync = <1>;
+		status = "disabled";
+	};
+
+};
+
+&i2c7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c7>;
+	status = "disabled";
+};
+
+&i2c8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c8>;
+	status = "okay";
+
+	spm8821@41 {
+		compatible = "spacemit,spm8821";
+		reg = <0x41>;
+		interrupt-parent = <&intc>;
+		interrupts = <64>;
+		status = "okay";
+
+		vcc_sys-supply = <&vcc4v0_baseboard>;
+		dcdc5-supply = <&dcdc_5>;
+
+		regulators {
+			compatible = "pmic,regulator,spm8821";
+
+			/* buck */
+			dcdc_1: DCDC_REG1 {
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <650000>;
+				};
+			};
+
+			dcdc_2: DCDC_REG2 {
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_3: DCDC_REG3 {
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_4: DCDC_REG4 {
+				regulator-name = "dcdc4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			dcdc_5: DCDC_REG5 {
+				regulator-name = "dcdc5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_6: DCDC_REG6 {
+				regulator-name = "dcdc6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			/* aldo */
+			ldo_1: LDO_REG1 {
+				regulator-name = "ldo1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				/* set the min voltage means will disable this vol in suspend for ldo */
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_2: LDO_REG2 {
+				regulator-name = "ldo2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_3: LDO_REG3 {
+				regulator-name = "ldo3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_4: LDO_REG4 {
+				regulator-name = "ldo4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			/* dldo */
+			ldo_5: LDO_REG5 {
+				regulator-name = "ldo5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_6: LDO_REG6 {
+				regulator-name = "ldo6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_7: LDO_REG7 {
+				regulator-name = "ldo7";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_8: LDO_REG8 {
+				regulator-name = "ldo8";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_9: LDO_REG9 {
+				regulator-name = "ldo9";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_10: LDO_REG10 {
+				regulator-name = "ldo10";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_11: LDO_REG11 {
+				regulator-name = "ldo11";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			sw_1: SWITCH_REG1 {
+				regulator-name = "switch1";
+			};
+		};
+
+		pmic_pinctrl: pinctrl {
+			compatible = "pmic,pinctrl,spm8821";
+			gpio-controller;
+			#gpio-cells = <2>;
+			spacemit,npins = <6>;
+/**
+ *			led_pins: led-pins {
+ *				pins = "PIN3";
+ *				function = "sleep";
+ *				bias-disable = <0>;
+ *				drive-open-drain = <0x1>;
+ *			};
+ */
+		};
+
+		pwr_key: key {
+			compatible = "pmic,pwrkey,spm8821";
+		};
+
+		ext_rtc: rtc {
+			compatible = "pmic,rtc,spm8821";
+		};
+	};
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_63  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_64  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_67  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_79  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range DVL1     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_111 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_113 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_116 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_118 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_127 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+	>;
+
+	pinctrl_rcpu: pinctrl_rcpu_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_47,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_tx */
+			K1X_PADCONF(GPIO_48,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_rx */
+		>;
+	};
+
+	pinctrl_gmac0: gmac0_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_00,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rxdv */
+			K1X_PADCONF(GPIO_01,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d0 */
+			K1X_PADCONF(GPIO_02,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d1 */
+			K1X_PADCONF(GPIO_03,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_clk */
+			K1X_PADCONF(GPIO_04,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d2 */
+			K1X_PADCONF(GPIO_05,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d3 */
+			K1X_PADCONF(GPIO_06,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d0 */
+			K1X_PADCONF(GPIO_07,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d1 */
+			K1X_PADCONF(GPIO_08,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx */
+			K1X_PADCONF(GPIO_09,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d2 */
+			K1X_PADCONF(GPIO_10,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d3 */
+			K1X_PADCONF(GPIO_11,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_en */
+			K1X_PADCONF(GPIO_12,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac0_mdc */
+			K1X_PADCONF(GPIO_13,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac0_mdio */
+			K1X_PADCONF(GPIO_14,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_int_n */
+			K1X_PADCONF(GPIO_45,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_clk_ref */
+		>;
+	};
+
+	pinctrl_gmac1: gmac1_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_29,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rxdv */
+			K1X_PADCONF(GPIO_30,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rx_d0 */
+			K1X_PADCONF(GPIO_31,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rx_d1 */
+			K1X_PADCONF(GPIO_32,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rx_clk */
+			K1X_PADCONF(GPIO_33,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rx_d2 */
+			K1X_PADCONF(GPIO_34,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_rx_d3 */
+			K1X_PADCONF(GPIO_35,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_tx_d0 */
+			K1X_PADCONF(GPIO_36,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_tx_d1 */
+			K1X_PADCONF(GPIO_37,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_tx */
+			K1X_PADCONF(GPIO_38,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_tx_d2 */
+			K1X_PADCONF(GPIO_39,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_tx_d3 */
+			K1X_PADCONF(GPIO_40,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_tx_en */
+			K1X_PADCONF(GPIO_41,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_mdc */
+			K1X_PADCONF(GPIO_42,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac1_mdio */
+			K1X_PADCONF(GPIO_43,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_int_n */
+			K1X_PADCONF(GPIO_46,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac1_clk_ref */
+		>;
+	};
+
+	pinctrl_wlan_wakeup: wlan_wakeup_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_FALL | PULL_DOWN | PAD_3V_DS2))   /* wifi edge detect */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49  GPIO_49  2
+		&pinctrl 58  GPIO_58  1
+		&pinctrl 63  GPIO_63  1
+		&pinctrl 65  GPIO_65  1
+		&pinctrl 67  GPIO_67  1
+		&pinctrl 70  PRI_TDI  4
+		&pinctrl 74  GPIO_74  1
+		&pinctrl 79  GPIO_79  1
+		&pinctrl 80  GPIO_80  4
+		&pinctrl 90  GPIO_90  3
+		&pinctrl 96  DVL0     2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 111 GPIO_111 1
+		&pinctrl 113 GPIO_113 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 118 GPIO_118 1
+		&pinctrl 123 GPIO_123 5
+		&pinctrl 127 GPIO_127 1
+	>;
+};
+
+/* SD */
+&sdhci0 {
+	pinctrl-names = "default","fast";
+	pinctrl-0 = <&pinctrl_mmc1>;
+	pinctrl-1 = <&pinctrl_mmc1_fast>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	vmmc-supply = <&dcdc_4>;
+	vqmmc-supply = <&ldo_1>;
+	no-mmc;
+	no-sdio;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_SDR12 |
+			MMC_CAP_UHS_SDR25
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_INVERTED_WRITE_PROTECT |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE |
+			SDHCI_QUIRK2_SET_AIB_MMC
+			)>;
+	spacemit,aib_mmc1_io_reg = <0xD401E81C>;
+	spacemit,apbc_asfar_reg = <0xD4015050>;
+	spacemit,apbc_assar_reg = <0xD4015054>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0x7f>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <204800000>;
+	status = "okay";
+};
+
+/* SDIO */
+&sdhci1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc2>;
+	bus-width = <4>;
+	non-removable;
+	vqmmc-supply = <&dcdc_3>;
+	no-mmc;
+	no-sd;
+	keep-power-in-suspend;
+	/* bcmdhd use private oob solution rather than dat1/standard wakeup */
+	/delete-property/ enable-sdio-wakeup;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_DDR50 |
+			MMC_CAP_NEEDS_POLL
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE
+			)>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	no-sd;
+	no-sdio;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN
+			)>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+&eth0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	emac,reset-gpio = <&gpio 110 0>;
+	emac,reset-active-low;
+	emac,reset-delays-us = <0 10000 100000>;
+
+	/* store forward mode */
+	tx-threshold = <1518>;
+	rx-threshold = <12>;
+	tx-ring-num = <1024>;
+	rx-ring-num = <1024>;
+	dma-burst-len = <5>;
+
+	ref-clock-from-phy;
+
+	clk-tuning-enable;
+	clk-tuning-by-delayline;
+	tx-phase = <60>;
+	rx-phase = <73>;
+
+	nvmem-cells = <&mac_address0>;
+	nvmem-cell-names = "mac-address";
+
+	phy-handle = <&rgmii0>;
+
+	status = "okay";
+
+	mdio-bus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii0: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+			phy-mode = "rgmii";
+		};
+	};
+};
+
+&eth1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac1>;
+
+	emac,reset-gpio = <&gpio 115 0>;
+	emac,reset-active-low;
+	emac,reset-delays-us = <0 10000 100000>;
+
+        /* store forward mode */
+	tx-threshold = <1518>;
+	rx-threshold = <12>;
+	tx-ring-num = <1024>;
+	rx-ring-num = <1024>;
+	dma-burst-len = <5>;
+
+	ref-clock-from-phy;
+
+	clk-tuning-enable;
+	clk-tuning-by-delayline;
+	tx-phase = <90>;
+	rx-phase = <73>;
+	nvmem-cells = <&mac_address1>;
+	nvmem-cell-names = "mac-address";
+
+	phy-handle = <&rgmii1>;
+
+	status = "okay";
+
+	mdio-bus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii1: phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+			phy-mode = "rgmii";
+		};
+	};
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&udc {
+	spacemit,udc-mode = <MV_USB_MODE_UDC>;
+	status = "okay";
+};
+
+&usbphy1 {
+	status = "okay";
+};
+
+&otg1 {
+	usb-role-switch;
+	role-switch-user-control;
+	spacemit,reset-on-resume;
+	role-switch-default-mode = "host";
+	vbus-gpios = <&gpio 123 0>;
+	status = "okay";
+};
+
+&udc1 {
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	status = "okay";
+};
+
+&ehci1 {
+	spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	spacemit,reset-on-resume;
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	//vbus-gpios = <&gpio 127 0>;
+	status = "okay";
+};
+
+&usb3hub {
+	vbus-gpios = <&gpio 79 0>,<&gpio 127 0>;	/* gpio_97 for usb3 hub output vbus */
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	reset-on-resume;
+	dwc3@c0a00000 {
+		dr_mode = "otg";
+		phy_type = "utmi";
+		snps,hsphy_interface = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		snps,parkmode-disable-ss-quirk;
+		usb-role-switch;
+		role-switch-default-mode = "host";
+	};
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	status = "okay";
+};
+
+&pcie2_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie2_4>;
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&imggpu {
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "okay";
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+&spi3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ssp3_0>;
+	status = "disabled";
+};
+
+&pwm_bl {
+	pwms = <&pwm14 2000>;
+	brightness-levels = <
+		0   40  40  40  40  40  40  40  40  40  40  40  40  40  40  40
+		40  40  40  40  40  40  40  40  40  40  40  40  40  40  40  40
+		40  40  40  40  40  40  40  40  40  41  42  43  44  45  46  47
+		48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63
+		64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79
+		80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
+		96  97  98  99  100 101 102 103 104 105 106 107 108 109 110 111
+		112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
+		128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143
+		144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
+		160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
+		176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
+		192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
+		208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
+		224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239
+		240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255
+	>;
+	default-brightness-level = <100>;
+
+	status = "okay";
+};
+
+/* ov16a10 */
+&backsensor {
+	af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 113 0>;
+	reset-gpios = <&gpio 111 0>;
+
+	status = "okay";
+};
+
+&backsensor_aux {
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+
+	status = "disabled";
+};
+
+&frontsensor {
+	af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	clocks = <&ccu CLK_CAMM1>;
+	clock-names = "cam_mclk1";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_camera1>;
+
+	pwdn-gpios = <&gpio 114 0>;
+	reset-gpios = <&gpio 112 0>;
+
+	status = "disabled";
+};
+&csiphy0 {
+
+	status = "okay";
+};
+&csiphy1 {
+
+	status = "disabled";
+};
+&csiphy2 {
+	spacemit,bifmode-enable;
+	status = "okay";
+};
+
+&ccic0 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic1 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic2 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&isp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&cpp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&vi {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&rcpu {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rcpu>;
+	mboxes = <&mailbox 0>, <&mailbox 1>;
+	mbox-names = "vq0", "vq1";
+	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>;
+	status = "okay";
+};
+
+&thermal {
+	sensor_range = <0x1 0x4>;
+};
+
+&thermal_zones {
+	top_thermal {
+		polling-delay = <0>;
+		polling-delay-passive = <0>;
+		thermal-sensors = <&thermal 1>;
+
+		trips {
+			top_trip0: top-trip0 {
+				temperature = <40000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+
+			top_trip1: top-trip1 {
+				temperature = <55000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+
+			top_trip2: top-trip2 {
+				temperature = <70000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+
+			top_trip3: top-trip3 {
+				temperature = <85000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+		};
+
+	};
+
+	gpu_thermal {
+		polling-delay = <0>;
+		polling-delay-passive = <0>;
+		thermal-sensors = <&thermal 2>;
+
+		/* Just a placeholder */
+		trips {
+			gpu_trip0: gpu-trip0 {
+				temperature = <40000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+		};
+	};
+};
+
+&i2s0 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_sspa0_0>;
+        status = "okay";
+};
+
+//&i2s1 {
+//      //  pinctrl-names = "default";
+//       // pinctrl-0 = <&pinctrl_sspa0_0>;
+//        status = "okay";
+//};
+&sound_hdmi {
+	status = "okay";
+};
+
+&sound_codec {
+	status = "okay";
+	simple-audio-card,name = "snd-es8326";
+	spacemit,mclk-fs = <64>;
+	simple-audio-card,codec {
+		sound-dai = <&es8326>;
+	};
+};
+
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts b/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
index 2cab7ea9f545..30c03d0f803e 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_deb2.dts b/arch/riscv/boot/dts/spacemit/k1-x_deb2.dts
index e9cd8e7d4690..054ebac515c1 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_deb2.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_deb2.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_evb.dts b/arch/riscv/boot/dts/spacemit/k1-x_evb.dts
index faa2fb213b1f..66f2a3417a32 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_evb.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_evb.dts
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_hs450.dts b/arch/riscv/boot/dts/spacemit/k1-x_hs450.dts
index 37a18ed7dc99..8e10e49f7a90 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_hs450.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_hs450.dts
@@ -114,7 +114,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts b/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
index 84ad7eaf41dc..e6e86950e8f8 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
@@ -14,7 +14,7 @@
 
 / {
 	model = "spacemit k1-x kx312 board";
-	modules_usrload = "8852be";
+	modules_usrload = "rtw89_core, rtw89_pci, rtw89_8852b, rtw89_8852be";
 
 	cpus: cpus {
 		#address-cells = <1>;
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts b/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
index 2a8c886881bc..03583737c66b 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts b/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
index f8f4720a7cd2..09a6f2699a41 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts b/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
index f59adb3e379c..bab9450aaeef 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
@@ -111,7 +111,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8,initcall_debug=1 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_orangepi-rv2.dts b/arch/riscv/boot/dts/spacemit/k1-x_orangepi-rv2.dts
index ba7901464c35..1ddfc40fe764 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_orangepi-rv2.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_orangepi-rv2.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
@@ -194,6 +194,12 @@ &pwm14 {
 	status = "okay";
 };
 
+&rpwm9 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rpwm9_0>;
+	status = "okay";
+};
+
 &dpu_online2_dsi {
 	memory-region = <&dpu_resv>;
 	spacemit-dpu-bitclk = <424000000>;
@@ -284,7 +290,7 @@ es8323: es8323@11 {
 &i2c3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c3_2>;
-	status = "disabled";
+	status = "okay";
 };
 
 &i2c4 {
@@ -902,6 +908,7 @@ dwc3@c0a00000 {
 &pcie1_rc {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_pcie1_3>;
+	k1x,pwr_on = <&gpio 116 0>;
 	status = "okay";
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_uav.dts b/arch/riscv/boot/dts/spacemit/k1-x_uav.dts
index 5189dd9000e3..06a9bf5466de 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_uav.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_uav.dts
@@ -115,7 +115,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
@@ -609,6 +609,13 @@ K1X_PADCONF(GPIO_48,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0
 		>;
 	};
 
+	pinctrl_r_uart1: r_uart1_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_51,   MUX_MODE2, (EDGE_NONE | PULL_UP | PAD_3V_DS4))  /* r_uart1_txd */
+			K1X_PADCONF(GPIO_52,   MUX_MODE2, (EDGE_NONE | PULL_UP | PAD_3V_DS4))  /* r_uart1_rxd */
+		>;
+	};
+
 	pinctrl_gmac0: gmac0_grp {
 		pinctrl-single,pins =<
 			K1X_PADCONF(GPIO_00,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rxdv */
@@ -769,7 +776,7 @@ &eth0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_gmac0>;
 
-	emac,reset-gpio = <&gpio 110 0>;
+	emac,reset-gpio = <&gpio 49 0>;
 	emac,reset-active-low;
 	emac,reset-delays-us = <0 10000 100000>;
 
@@ -810,7 +817,7 @@ &eth1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_gmac1>;
 
-	emac,reset-gpio = <&gpio 115 0>;
+	emac,reset-gpio = <&gpio 50 0>;
 	emac,reset-active-low;
 	emac,reset-delays-us = <0 10000 100000>;
 
diff --git a/arch/riscv/boot/dts/spacemit/lcd/lcd_ft8201sinx101_mipi.dtsi b/arch/riscv/boot/dts/spacemit/lcd/lcd_ft8201sinx101_mipi.dtsi
new file mode 100644
index 000000000000..06cd2bbedc34
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/lcd/lcd_ft8201sinx101_mipi.dtsi
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/ { lcds: lcds {
+	lcd_ft8201sinx101_mipi: lcd_ft8201sinx101_mipi {
+		dsi-work-mode = <1>; /* video burst mode*/
+		dsi-lane-number = <4>;
+		dsi-color-format = "rgb888";
+		width-mm = <135>;
+		height-mm = <217>;
+		use-dcs-write;
+
+		/*mipi info*/
+		height = <1280>;
+		width = <800>;
+		hfp = <49>;
+		hbp = <136>;
+		hsync = <20>;
+		vfp = <137>;
+		vbp = <32>;
+		vsync = <6>;
+		fps = <60>;
+		work-mode = <0>;
+		rgb-mode = <3>;
+		lane-number = <4>;
+		phy-bit-clock = <614000000>;
+		split-enable = <0>;
+		eotp-enable = <0>;
+		burst-mode = <2>;
+		esd-check-enable = <0>;
+
+		/* DSI_CMD, DSI_MODE, timeout, len, cmd */
+		initial-command = [
+			39 01 00 02 41 5A
+			// blank 8
+			39 01 00 03 41 5A 08
+			39 01 00 05 80 82 00 82 00
+			// blank 9
+			39 01 00 03 41 5A 09
+			39 01 00 11 80 1A 01 AB 93 A5 97 59 2A B1 06 00 00 80 1F 80 10
+			39 01 00 11 90 42 44 84 14 C6 13 99 09 C0 BB 0A 0F 07 E0 2A 00
+			39 01 00 11 A0 80 90 20 AA 00 04 55 55 05 00 1F 15 42 00 FE FF
+			39 01 00 11 B0 03 39 6D 01 D3 05 D3 05 00 00 30 41 25 00 4A 00
+			39 01 00 11 C0 00 00 00 00 00 00 00 00 10 04 02 00 07 00 08 18
+			39 01 00 03 D0 00 00
+			// blank 10
+			39 01 00 03 41 5A 0A
+			39 01 00 11 80 91 91 D4 30 36 23 2D 34 3C 4A 56 57 63 66 7D 83
+			39 01 00 11 90 6D 6C 5F 56 4A 3A 30 27 15 0F 0A 30 36 23 2D 34
+			39 01 00 11 A0 3C 4A 56 57 63 66 7D 83 6D 6C 5F 56 4A 3A 30 27
+			39 01 00 04 B0 15 0F 0A
+			// blank 11
+			39 01 00 03 41 5A 0B
+			39 01 00 11 80 00 00 50 B5 C5 AC 00 00 A0 6A 8B A9 AE 22 02 00
+			39 01 00 11 90 EF D8 B8 F7 25 70 E0 08 11 02 40 13 4F 4D 3C 35
+			39 01 00 09 A0 F1 A4 06 FF FF 00 03 00
+			// blank 12
+			39 01 00 03 41 5A 0C
+			39 01 00 11 80 FA 68 90 01 28 05 7A 05 00 00 56 01 00 55 61 15
+			39 01 00 11 90 55 51 15 56 01 00 56 01 00 55 61 15 55 51 15 56
+			39 01 00 11 A0 B1 84 01 50 00 50 00 50 00 40 94 02 00 00 00 30
+			39 01 00 11 B0 28 15 80 04 00 18 00 00 00 30 0A 00 00 00 00 00
+			39 01 00 08 C0 00 01 05 C2 B0 00 00
+			// blank 13
+			39 01 00 03 41 5A 0D
+			39 01 00 11 80 08 00 00 28 02 00 04 12 00 08 02 77 02 4A 10 F0
+			39 01 00 07 90 00 02 58 16 04 A1
+			// blank 14
+			39 01 00 03 41 5A 0E
+			39 01 00 11 80 FF 81 68 6C 22 FD 22 00 55 55 55 55 05 5A 5A 80
+			39 01 00 07 90 01 00 00 60 01 00
+			// blank 15
+			39 01 00 03 41 5A 0F
+			39 01 00 11 80 01 D5 C1 24 52 00 50 00 00 06 28 06 1C 00 3C 82
+			39 01 00 11 90 1D 60 21 40 03 04 48 A0 05 5A 10 00 00 10 84 D0
+			39 01 00 11 A0 37 80 43 B3 1D C0 4A 0B 5A 71 22 80 19 4A 00 20
+			39 01 00 11 B0 27 9E 01 C0 19 7A 21 14 00 40 30 E0 00 2D D0 82
+			39 01 00 11 C0 00 00 80 20 84 A0 21 1A 9A 21 02 10 62 84 28 03
+			39 01 00 11 D0 8A 88 88 48 92 09 0F 15 1E E0 31 06 04 02 14 04
+			39 01 00 11 E0 10 22 22 7D AD 05 D6 42 B5 28 1E D2 62 40 41 00
+			39 01 00 10 F0 00 11 10 04 F5 FF FF 3F 00 00 15 40 14 00 00
+			// blank 16
+			39 01 00 03 41 5A 10
+			39 01 00 11 80 00 00 03 E7 8F 0B 10 28 00 A9 66 0C 18 C4 20 C5
+			39 01 00 11 90 1C 94 D4 62 CD 3D F8 03 3F F0 03 3F 00 FF FF FF
+			39 01 00 03 A0 81 00
+			// blank 17
+			39 01 00 03 41 5A 11
+			39 01 00 08 80 00 00 00 00 00 00 00
+			// blank 18
+			39 01 00 03 41 5A 12
+			39 01 00 11 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 90 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 A0 00 00 00 00 00 00 2D 23 05 FB 00 2D 23 05 FB 00
+			39 01 00 08 B0 01 00 00 00 00 00 00
+			// blank 19
+			39 01 00 03 41 5A 13
+			39 01 00 11 80 00 08 80 15 00 90 10 18 3E 10 00 D6 03 04 18 00
+			39 01 00 11 90 70 88 30 90 32 70 3E 97 8B 39 30 C4 09 C4 09 C4
+			39 01 00 11 A0 89 4F DC 45 80 0A C4 09 C4 09 80 02 00 00 00 00
+			39 01 00 11 B0 00 00 00 00 00 00 1B 01 31 75 B9 42 86 CA 31 75
+			39 01 00 11 C0 B9 42 86 CA 00 00 00 00 0C 60 00 24 18 00 09 06
+			39 01 00 11 D0 40 82 01 90 60 00 24 D0 01 09 74 40 02 1D 90 40
+			39 01 00 11 E0 07 24 D0 01 09 1E 46 1E 46 00 00 20 C5 0F 00 C0
+			39 01 00 0D F0 10 40 26 4E 46 02 C8 20 80 0C 00 00
+			// blank 20
+			39 01 00 03 41 5A 14
+			39 01 00 11 80 01 02 40 2C 99 DF EF F7 23 A7 03 00 00 80 82 78
+			39 01 00 11 90 F0 FB 11 B0 07 7E 3F 02 36 C1 EF 47 C0 26 F8 FD
+			39 01 00 11 A0 08 D8 0C BF 1F 01 9B E1 F7 23 00 00 05 00 00 00
+			39 01 00 11 B0 00 00 00 00 00 00 00 00 00 00 02 00 80 0B 05 0B
+			39 01 00 11 C0 05 05 00 30 18 0C D7 01 B2 97 04 C5 00 74 05 20
+			39 01 00 11 D0 7B 49 50 0C 40 57 02 B2 97 04 C5 00 74 45 20 7B
+			39 01 00 11 E0 49 50 0C 40 57 06 B2 97 04 C5 00 74 85 20 7B 49
+			39 01 00 11 F0 50 0C 40 57 0A B2 97 04 C5 00 74 C5 20 7B 49 50
+			// blank 21
+			39 01 00 03 41 5A 15
+			39 01 00 11 80 0C 40 40 80 DF 0F 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 C0 00 00 00 00 00 00 00 00 00 60 11 00 E0 01 50 5A
+			39 01 00 11 D0 93 92 3E 4E 41 0C 42 00 A0 B6 6D DB B6 6D DB B6
+			39 01 00 11 E0 6D 5B B3 8A 3E 2E 59 82 A1 38 A6 B6 6D DB B6 6D
+			39 01 00 11 F0 DB B6 6D 5B B3 9A 3E 6E 49 8E 62 08 A2 B6 6D DB
+			// blank 22
+			39 01 00 03 41 5A 16
+			39 01 00 11 80 B6 6D DB B6 6D 5B 93 82 3E 0E 51 00 81 30 A4 B6
+			39 01 00 11 90 6D DB B6 6D DB B6 6D 01 03 03 00 00 00 00 00 00
+			39 01 00 11 A0 00 00 00 00 00 00 00 00 00 00 00 00 C0 1F E1 01
+			39 01 00 11 B0 28 02 00 00 00 00 00 00 00 00 04 00 00 00 00 00
+			39 01 00 11 C0 00 00 00 00 00 00 02 02 00 00 00 00 00 00 02 00
+			39 01 00 11 D0 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
+			39 01 00 11 E0 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 11 F0 00 04 00 00 00 00 00 00 00 00 00 20 00 00 00 00
+			// blank 23
+			39 01 00 03 41 5A 17
+			39 01 00 11 80 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 20
+			39 01 00 11 90 00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00
+			39 01 00 11 A0 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 00
+			39 01 00 11 B0 40 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00
+			39 01 00 11 C0 00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 07 D0 00 01 00 00 00 00
+			// blank 24
+			39 01 00 03 41 5A 18
+			39 01 00 11 80 7F 7F FE FE FE FE FE FE FE FE FE FE D4 7F D4 D4
+			39 01 00 11 90 D4 D4 D4 D4 D4 D4 D4 D4 AA AA AA AA AA AA AA AA
+			39 01 00 11 A0 AA AA AA AA 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F
+			39 01 00 11 B0 7C 83 79 86 79 86 79 86 79 86 79 86 7A 83 7A 85
+			39 01 00 11 C0 7A 85 7A 85 7A 85 7A 85 7B 84 7B 84 7B 84 7B 84
+			39 01 00 11 D0 7B 84 7B 84 7C 83 7C 83 7C 83 7C 83 7C 83 7C 83
+			39 01 00 11 E0 FE 7F 7F FE FE FE FE FE FE FE FE FE FE D4 7F D4
+			39 01 00 11 F0 D4 D4 D4 D4 D4 D4 D4 D4 D4 AA AA AA AA AA AA AA
+			// blank 25
+			39 01 00 03 41 5A 19
+			39 01 00 11 80 AA AA AA AA AA 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F 7F
+			39 01 00 11 90 7F 7C 83 79 86 79 86 79 86 79 86 79 86 7A 83 7A
+			39 01 00 11 A0 85 7A 85 7A 85 7A 85 7A 85 7B 84 7B 84 7B 84 7B
+			39 01 00 11 B0 84 7B 84 7B 84 7C 83 7C 83 7C 83 7C 83 7C 83 7C
+			39 01 00 11 C0 83 7F 04 FF 1E 00 08 10 18 20 28 30 38 FC 00 04
+			39 01 00 0C D0 20 00 01 08 40 00 02 10 80 00 FC
+			// blank 26
+			39 01 00 03 41 5A 1A
+			39 01 00 11 80 F0 D9 C8 BA AF A6 9E 98 92 8D 88 84 00 60 F6 CF
+			39 01 00 11 90 FC 6F F6 EF CF AF 5F 55 00 F8 00 F8 00 F8 AD 8D
+			39 01 00 11 A0 73 60 53 4A 43 7F 78 10 A0 3F 00 00 00 00 00 00
+			39 01 00 11 B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+			39 01 00 09 C0 00 00 00 00 00 00 00 00
+			// blank 28
+			39 01 00 03 41 5A 1C
+			39 01 00 11 80 00 04 08 0C 00 10 14 18 1C 00 20 28 30 38 00 40
+			39 01 00 11 90 48 50 58 00 60 68 70 78 00 80 88 90 98 00 A0 A8
+			39 01 00 11 A0 B0 B8 00 C0 C8 D0 D8 00 E0 E8 F0 F8 00 FC FE FF
+			39 01 00 11 B0 00 00 04 08 0C 00 10 14 18 1C 00 20 28 30 38 00
+			39 01 00 11 C0 40 48 50 58 00 60 68 70 78 00 80 88 90 98 00 A0
+			39 01 00 11 D0 A8 B0 B8 00 C0 C8 D0 D8 00 E0 E8 F0 F8 00 FC FE
+			39 01 00 11 E0 FF 00 00 04 08 0C 00 10 14 18 1C 00 20 28 30 38
+			39 01 00 11 F0 00 40 48 50 58 00 60 68 70 78 00 80 88 90 98 00
+			// blank 29
+			39 01 00 03 41 5A 1D
+			39 01 00 11 80 A0 A8 B0 B8 00 C0 C8 D0 D8 00 E0 E8 F0 F8 00 FC
+			39 01 00 05 90 FE FF 00 00
+			// blank 31
+			39 01 00 03 41 5A 1F
+			39 01 00 11 80 5A 0F 70 09 28 30 38 40 48 50 58 60 20 30 38 40
+			39 01 00 11 90 48 50 58 60 20 28 38 40 48 50 58 60 20 28 30 40
+			39 01 00 11 A0 48 50 58 60 20 28 30 38 48 50 58 60 20 28 30 38
+			39 01 00 11 B0 40 50 58 60 20 28 30 38 40 48 58 60 20 28 30 38
+			39 01 00 11 C0 40 48 50 60 20 28 30 38 40 48 50 58 FF 5A 1E 20
+			39 01 00 0D D0 00 02 20 00 02 20 00 02 20 00 02 FE
+			// blank 32
+			39 01 00 03 41 5A 20
+			39 01 00 11 80 44 73 03 00 CA F3 FF 6B 10 08 02 08 03 41 18 30
+			39 01 00 11 90 18 44 E1 40 E1 20 30 18 C8 21 41 01 39 13 44 42
+			39 01 00 11 A0 91 50 28 14 0A 85 03 D2 B0 80 36 7F D0 1F 12 E0
+			39 01 00 11 B0 18 36 1B 11 04 20 02 D0 80 B3 21 38 20 18 88 03
+			39 01 00 11 C0 82 01 41 70 40 30 8D 0D A4 A2 00 80 04 38 00 50
+			39 01 00 11 D0 80 13 E0 00 14 C0 70 40 00 E0 81 00 00 28 0E 06
+			39 01 00 11 E0 43 55 55 55 55 55 D5 CC CC CC CC CC 4C 08 82 C6
+			39 01 00 11 F0 E0 01 00 00 00 21 42 88 00 00 00 00 00 00 00 20
+			// blank 33
+			39 01 00 03 41 5A 21
+			39 01 00 11 80 04 41 06 49 90 04 49 00 00 49 00 00 49 00 00 49
+			39 01 00 11 90 90 04 00 85 11 0C 00 00 40 00 00 00 00 16 00 A5
+			39 01 00 11 A0 00 08 08 15 10 D1 B6 45 92 8A 20 A2 6D 0B 00 54
+			39 01 00 11 B0 40 44 DB 16 00 48 92 24 09 E0 0F 80 55 30 01 10
+			39 01 00 11 C0 01 42 82 11 20 02 10 10 01 08 88 00 04 44 00 02
+			39 01 00 11 D0 22 00 04 91 80 1F 00 40 40 04 00 00 00 18 10 16
+			39 01 00 03 E0 10 00
+			// blank 34
+			39 01 00 03 41 5A 22
+			39 01 00 11 80 29 D3 00 55 55 55 55 55 55 55 55 55 55 55 1F 70
+			39 01 00 04 90 F0 00 00
+			// blank 35
+			39 01 00 03 41 5A 23
+			39 01 00 11 80 09 01 02 05 00 05 04 00 00 00 00 00 00 00 00 00
+			39 01 00 0A 90 00 FF 1F 20 00 01 00 00 FE
+			// blank 36
+			39 01 00 03 41 5A 24
+			39 01 00 11 80 00 03 00 FF FF 66 00 00 00 00 00 00 00 00 5B 26
+			39 01 00 0F 90 5A A5 5A 00 00 00 00 22 22 3A 22 00 00 00
+			// spi finish
+			39 01 00 03 41 5A 24
+			39 01 00 02 90 A5
+			// blank select 2f
+			39 01 00 03 41 5A 2F
+			// cancel tp i2c mode
+			39 01 00 02 4C 03
+			// bypass or fifo mode
+			39 01 00 02 09 01
+			// set led pwm
+			39 01 00 03 51 FF 0F
+			39 01 00 02 53 24
+			39 01 00 02 55 00
+			// bist mode
+			// 39 01 00 02 02 5A
+			39 01 78 02 11 00
+			39 01 32 02 29 00
+		];
+		sleep-in-command = [
+			39 01 78 01 28
+			39 01 32 01 10
+		];
+		sleep-out-command = [
+			39 01 78 01 11
+			39 01 32 01 29
+		];
+		read-id-command = [
+			37 01 00 01 02
+			14 01 00 01 DA DB
+		];
+
+		display-timings {
+			timing0 {
+				clock-frequency = <88000000>;
+				hactive = <800>;
+				hfront-porch = <49>;
+				hback-porch = <136>;
+				hsync-len = <20>;
+				vactive = <1280>;
+				vfront-porch = <137>;
+				vback-porch = <32>;
+				vsync-len = <6>;
+				vsync-active = <1>;
+				hsync-active = <1>;
+			};
+		};
+	};
+};};
diff --git a/arch/riscv/boot/dts/spacemit/lcd/lcd_jd9365aainx101_mipi.dtsi b/arch/riscv/boot/dts/spacemit/lcd/lcd_jd9365aainx101_mipi.dtsi
new file mode 100644
index 000000000000..76304c0b178d
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/lcd/lcd_jd9365aainx101_mipi.dtsi
@@ -0,0 +1,262 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/ { lcds: lcds {
+        lcd_jd9365aainx101_mipi: lcd_jd9365aainx101_mipi {
+                dsi-work-mode = <1>; /* video burst mode*/
+                dsi-lane-number = <4>;
+                dsi-color-format = "rgb888";
+                width-mm = <108>;
+                height-mm = <172>;
+                use-dcs-write;
+
+                /*mipi info*/
+                height = <1280>;
+                width = <800>;
+                hfp = <40>;
+                hbp = <107>;
+                hsync = <20>;
+                vfp = <20>;
+                vbp = <20>;
+                vsync = <4>;
+                fps = <60>;
+                work-mode = <0>;
+                rgb-mode = <3>;
+                lane-number = <4>;
+                phy-bit-clock = <500000000>;
+                split-enable = <0>;
+                eotp-enable = <0>;
+                burst-mode = <2>;
+                esd-check-enable = <1>;
+
+                /* DSI_CMD, DSI_MODE, timeout, len, cmd */
+                initial-command = [
+                        39 01 00 02 E0 00
+                        39 01 00 02 E1 93
+                        39 01 00 02 E2 65
+                        39 01 00 02 E3 F8
+                        39 01 00 02 80 03
+                        39 01 00 02 E0 01
+                        39 01 00 02 00 00
+                        39 01 00 02 01 3B
+                        39 01 00 02 0C 74
+                        39 01 00 02 17 00
+                        39 01 00 02 18 AF
+                        39 01 00 02 19 00
+                        39 01 00 02 1A 00
+                        39 01 00 02 1B AF
+                        39 01 00 02 1C 00
+                        39 01 00 02 35 26
+                        39 01 00 02 37 09
+                        39 01 00 02 38 04
+                        39 01 00 02 39 00
+                        39 01 00 02 3A 01
+                        39 01 00 02 3C 78
+                        39 01 00 02 3D FF
+                        39 01 00 02 3E FF
+                        39 01 00 02 3F 7F
+                        39 01 00 02 40 06
+                        39 01 00 02 41 A0
+                        39 01 00 02 42 81
+                        39 01 00 02 43 14
+                        39 01 00 02 44 23
+                        39 01 00 02 45 28
+                        39 01 00 02 55 02
+                        39 01 00 02 57 69
+                        39 01 00 02 59 0A
+                        39 01 00 02 5A 2A
+                        39 01 00 02 5B 17
+                        39 01 00 02 5D 7F
+                        39 01 00 02 5E 69
+                        39 01 00 02 5F 59
+                        39 01 00 02 60 4C
+                        39 01 00 02 61 47
+                        39 01 00 02 62 39
+                        39 01 00 02 63 3B
+                        39 01 00 02 64 24
+                        39 01 00 02 65 3D
+                        39 01 00 02 66 3C
+                        39 01 00 02 67 3C
+                        39 01 00 02 68 5A
+                        39 01 00 02 69 46
+                        39 01 00 02 6A 4A
+                        39 01 00 02 6B 43
+                        39 01 00 02 6C 46
+                        39 01 00 02 6D 20
+                        39 01 00 02 6E 0F
+                        39 01 00 02 6F 00
+                        39 01 00 02 70 7F
+                        39 01 00 02 71 69
+                        39 01 00 02 72 59
+                        39 01 00 02 73 4C
+                        39 01 00 02 74 47
+                        39 01 00 02 75 39
+                        39 01 00 02 76 3B
+                        39 01 00 02 77 24
+                        39 01 00 02 78 3D
+                        39 01 00 02 79 3C
+                        39 01 00 02 7A 3C
+                        39 01 00 02 7B 5A
+                        39 01 00 02 7C 46
+                        39 01 00 02 7D 4A
+                        39 01 00 02 7E 43
+                        39 01 00 02 7F 46
+                        39 01 00 02 80 20
+                        39 01 00 02 81 0F
+                        39 01 00 02 82 00
+                        39 01 00 02 E0 02
+                        39 01 00 02 00 42
+                        39 01 00 02 01 42
+                        39 01 00 02 02 40
+                        39 01 00 02 03 40
+                        39 01 00 02 04 5E
+                        39 01 00 02 05 5E
+                        39 01 00 02 06 5F
+                        39 01 00 02 07 5F
+                        39 01 00 02 08 5F
+                        39 01 00 02 09 57
+                        39 01 00 02 0A 57
+                        39 01 00 02 0B 77
+                        39 01 00 02 0C 77
+                        39 01 00 02 0D 47
+                        39 01 00 02 0E 47
+                        39 01 00 02 0F 45
+                        39 01 00 02 10 45
+                        39 01 00 02 11 4B
+                        39 01 00 02 12 4B
+                        39 01 00 02 13 49
+                        39 01 00 02 14 49
+                        39 01 00 02 15 5F
+                        39 01 00 02 16 41
+                        39 01 00 02 17 41
+                        39 01 00 02 18 40
+                        39 01 00 02 19 40
+                        39 01 00 02 1A 5E
+                        39 01 00 02 1B 5E
+                        39 01 00 02 1C 5F
+                        39 01 00 02 1D 5F
+                        39 01 00 02 1E 5F
+                        39 01 00 02 1F 57
+                        39 01 00 02 20 57
+                        39 01 00 02 21 77
+                        39 01 00 02 22 77
+                        39 01 00 02 23 46
+                        39 01 00 02 24 46
+                        39 01 00 02 25 44
+                        39 01 00 02 26 44
+                        39 01 00 02 27 4A
+                        39 01 00 02 28 4A
+                        39 01 00 02 29 48
+                        39 01 00 02 2A 48
+                        39 01 00 02 2B 5F
+                        39 01 00 02 2C 01
+                        39 01 00 02 2D 01
+                        39 01 00 02 2E 00
+                        39 01 00 02 2F 00
+                        39 01 00 02 30 1F
+                        39 01 00 02 31 1F
+                        39 01 00 02 32 1E
+                        39 01 00 02 33 1E
+                        39 01 00 02 34 1F
+                        39 01 00 02 35 17
+                        39 01 00 02 36 17
+                        39 01 00 02 37 37
+                        39 01 00 02 38 37
+                        39 01 00 02 39 08
+                        39 01 00 02 3A 08
+                        39 01 00 02 3B 0A
+                        39 01 00 02 3C 0A
+                        39 01 00 02 3D 04
+                        39 01 00 02 3E 04
+                        39 01 00 02 3F 06
+                        39 01 00 02 40 06
+                        39 01 00 02 41 1F
+                        39 01 00 02 42 02
+                        39 01 00 02 43 02
+                        39 01 00 02 44 00
+                        39 01 00 02 45 00
+                        39 01 00 02 46 1F
+                        39 01 00 02 47 1F
+                        39 01 00 02 48 1E
+                        39 01 00 02 49 1E
+                        39 01 00 02 4A 1F
+                        39 01 00 02 4B 17
+                        39 01 00 02 4C 17
+                        39 01 00 02 4D 37
+                        39 01 00 02 4E 37
+                        39 01 00 02 4F 09
+                        39 01 00 02 50 09
+                        39 01 00 02 51 0B
+                        39 01 00 02 52 0B
+                        39 01 00 02 53 05
+                        39 01 00 02 54 05
+                        39 01 00 02 55 07
+                        39 01 00 02 56 07
+                        39 01 00 02 57 1F
+                        39 01 00 02 58 40
+                        39 01 00 02 5B 30
+                        39 01 00 02 5C 16
+                        39 01 00 02 5D 34
+                        39 01 00 02 5E 05
+                        39 01 00 02 5F 02
+                        39 01 00 02 63 00
+                        39 01 00 02 64 6A
+                        39 01 00 02 67 73
+                        39 01 00 02 68 1D
+                        39 01 00 02 69 08
+                        39 01 00 02 6A 6A
+                        39 01 00 02 6B 08
+                        39 01 00 02 6C 00
+                        39 01 00 02 6D 00
+                        39 01 00 02 6E 00
+                        39 01 00 02 6F 88
+                        39 01 00 02 75 FF
+                        39 01 00 02 77 DD
+                        39 01 00 02 78 3F
+                        39 01 00 02 79 15
+                        39 01 00 02 7A 17
+                        39 01 00 02 7D 14
+                        39 01 00 02 7E 82
+                        39 01 00 02 E0 04
+                        39 01 00 02 00 0E
+                        39 01 00 02 02 B3
+                        39 01 00 02 09 61
+                        39 01 00 02 0E 48
+                        39 01 00 02 E0 00
+                        39 01 00 02 E6 02
+                        39 01 00 02 E7 0C
+                        39 01 78 02 11 00
+                        39 01 00 02 E0 00
+                        39 01 05 02 29 00
+                        39 01 00 02 35 00
+                ];
+
+                sleep-in-command = [
+                        39 01 78 01 28
+                        39 01 78 01 10
+                ];
+                sleep-out-command = [
+                        39 01 96 01 11
+                        39 01 32 01 29
+                ];
+                read-id-command = [
+                        37 01 00 01 01
+                        14 01 00 01 04
+                ];
+
+                display-timings {
+                        timing0 {
+                                clock-frequency = <76800000>;
+                                hactive = <800>;
+                                hfront-porch = <40>;
+                                hback-porch = <107>;
+                                hsync-len = <20>;
+                                vactive = <1280>;
+                                vfront-porch = <20>;
+                                vback-porch = <20>;
+                                vsync-len = <4>;
+                                vsync-active = <1>;
+                                hsync-active = <1>;
+                        };
+                };
+        };
+};};
diff --git a/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts b/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
index e6d74c2d1672..cfabd0687446 100644
--- a/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
+++ b/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
@@ -116,7 +116,7 @@ dpu_resv: dpu_reserved@2ff40000 {
 	};
 
 	chosen {
-		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 loglevel=8 swiotlb=65536 rdinit=/init";
 		stdout-path = "serial0:115200n8";
 	};
 
diff --git a/arch/riscv/configs/k1_defconfig b/arch/riscv/configs/k1_defconfig
index 8d94582bfd0f..1d0bbe7d644d 100644
--- a/arch/riscv/configs/k1_defconfig
+++ b/arch/riscv/configs/k1_defconfig
@@ -489,6 +489,7 @@ CONFIG_BT_HCIUART_RTL=y
 CONFIG_AF_KCM=m
 CONFIG_MCTP=y
 CONFIG_CFG80211=y
+CONFIG_MAC80211=y
 CONFIG_RFKILL=y
 CONFIG_NET_IFE=m
 CONFIG_PCI=y
@@ -661,8 +662,9 @@ CONFIG_USB_NET_ASIX=m
 # CONFIG_WLAN_VENDOR_MICROCHIP is not set
 # CONFIG_WLAN_VENDOR_PURELIFI is not set
 # CONFIG_WLAN_VENDOR_RALINK is not set
+CONFIG_RTW89=y
+CONFIG_RTW89_8852BE=m
 CONFIG_RTL8852BS=m
-CONFIG_RTL8852BE=m
 # CONFIG_WLAN_VENDOR_RSI is not set
 # CONFIG_WLAN_VENDOR_SILABS is not set
 # CONFIG_WLAN_VENDOR_ST is not set
@@ -680,10 +682,12 @@ CONFIG_TOUCHSCREEN_GOODIX=y
 CONFIG_TOUCHSCREEN_CHIPONE_TDDI=y
 CONFIG_TOUCHSCREEN_CHSC5XXX=y
 CONFIG_SEMI_TOUCH_AUTO_UPDATE_EN=y
+CONFIG_TOUCHSCREEN_FTS=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_UINPUT=y
 CONFIG_INPUT_SPACEMIT_POWERKEY=y
 CONFIG_HALL_SENSOR_AS1911=y
+# CONFIG_LEGACY_PTYS is not set
 CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
 CONFIG_SERIAL_PXA=y
 CONFIG_SERIAL_PXA_SPACEMIT_K1X=y
@@ -738,6 +742,7 @@ CONFIG_SPACEMIT_K1X_VI_IOMMU=y
 CONFIG_SPACEMIT_K1X_ISP_V2=y
 CONFIG_SPACEMIT_K1X_CPP_V2=y
 CONFIG_SPACEMIT_K1X_SENSOR_V2=y
+CONFIG_SPACEMIT_K1X_VIR_CAMERA=y
 # CONFIG_CXD2880_SPI_DRV is not set
 # CONFIG_MEDIA_TUNER_E4000 is not set
 # CONFIG_MEDIA_TUNER_FC0011 is not set
diff --git a/arch/riscv/configs/k1_rt_defconfig b/arch/riscv/configs/k1_rt_defconfig
index e214683ef063..12ce1171c9d6 100644
--- a/arch/riscv/configs/k1_rt_defconfig
+++ b/arch/riscv/configs/k1_rt_defconfig
@@ -33,9 +33,9 @@ CONFIG_CGROUP_MISC=y
 CONFIG_NAMESPACES=y
 CONFIG_USER_NS=y
 CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_SCHED_AUTOGROUP=y
 CONFIG_RELAY=y
-CONFIG_INITRAMFS_SOURCE="rootfs.cpio.gz"
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
 # CONFIG_RD_XZ is not set
diff --git a/arch/riscv/include/asm/rwonce.h b/arch/riscv/include/asm/rwonce.h
new file mode 100644
index 000000000000..349b8792aedb
--- /dev/null
+++ b/arch/riscv/include/asm/rwonce.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2024 Spaciemit Ltd.
+ */
+#ifndef __ASM_RWONCE_H
+#define __ASM_RWONCE_H
+
+#if defined(CONFIG_SPACEMIT_ERRATA_LOAD_ATOMIC) && !defined(__ASSEMBLY__)
+
+
+#define __READ_ONCE(x)							\
+({									\
+	typeof(&(x)) __x = &(x);					\
+	int atomic = 1;							\
+	union { __unqual_scalar_typeof(*__x) __val; char __c[1]; } __u;	\
+	switch (sizeof(x)) {						\
+	case 4:								\
+		asm volatile (						\
+			"lr.w %0, 0(%1)"				\
+			: "=r" (*(__u32 *)__u.__c)			\
+			: "r" (__x)					\
+			: "memory"					\
+		);							\
+		break;							\
+	case 8:								\
+		asm volatile (						\
+			"lr.d %0, 0(%1)"				\
+			: "=r" (*(__u64 *)__u.__c)			\
+			: "r" (__x)					\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		asm volatile ("fence	rw, rw" ::: "memory");		\
+		atomic = 0;						\
+	}								\
+	atomic ? (typeof(*__x))__u.__val : (*(volatile typeof(__x))__x);\
+})
+
+#endif	/* CONFIG_SPACEMIT_ERRATA_LOAD_ATOMIC && !__ASSEMBLY__ */
+
+#include <asm-generic/rwonce.h>
+
+#endif	/* __ASM_RWONCE_H */
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index 5d69f4db9e8f..e81871ca4eac 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -119,6 +119,13 @@ static long __restore_v_state(struct pt_regs *regs, void __user *sc_vec)
 	struct __sc_riscv_v_state __user *state = sc_vec;
 	void __user *datap;
 
+	/*
+	 * Mark the vstate as clean prior performing the actual copy,
+	 * to avoid getting the vstate incorrectly clobbered by the
+	 *  discarded vector state.
+	 */
+	riscv_v_vstate_set_restore(current, regs);
+
 	/* Copy everything of __sc_riscv_v_state except datap. */
 	err = __copy_from_user(&current->thread.vstate, &state->v_state,
 			       offsetof(struct __riscv_v_ext_state, datap));
@@ -133,13 +140,7 @@ static long __restore_v_state(struct pt_regs *regs, void __user *sc_vec)
 	 * Copy the whole vector content from user space datap. Use
 	 * copy_from_user to prevent information leak.
 	 */
-	err = copy_from_user(current->thread.vstate.datap, datap, riscv_v_vsize);
-	if (unlikely(err))
-		return err;
-
-	riscv_v_vstate_set_restore(current, regs);
-
-	return err;
+	return copy_from_user(current->thread.vstate.datap, datap, riscv_v_vsize);
 }
 #else
 #define save_v_state(task, regs) (0)
diff --git a/block/blk-mq.c b/block/blk-mq.c
index c4128748d448..5da948b07058 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -1185,7 +1185,6 @@ static void blk_mq_complete_send_ipi(struct request *rq)
 	cpu = rq->mq_ctx->cpu;
 	if (llist_add(&rq->ipi_list, &per_cpu(blk_cpu_done, cpu)))
 		smp_call_function_single_async(cpu, &per_cpu(blk_cpu_csd, cpu));
-	WRITE_ONCE(rq->request_debug_flags, 1);
 }
 
 static void blk_mq_raise_softirq(struct request *rq)
@@ -3428,7 +3427,6 @@ static int blk_mq_init_request(struct blk_mq_tag_set *set, struct request *rq,
 	}
 
 	WRITE_ONCE(rq->state, MQ_RQ_IDLE);
-	WRITE_ONCE(rq->request_debug_flags, 0);
 	return 0;
 }
 
diff --git a/certs/Makefile b/certs/Makefile
index 799ad7b9e68a..f15eca11ea1e 100644
--- a/certs/Makefile
+++ b/certs/Makefile
@@ -47,7 +47,7 @@ keytype-$(CONFIG_MODULE_SIG_KEY_TYPE_ECDSA) := -newkey ec -pkeyopt ec_paramgen_c
 quiet_cmd_gen_key = GENKEY  $@
       cmd_gen_key = openssl req -new -nodes -utf8 -$(CONFIG_MODULE_SIG_HASH) -days 36500 \
 		-batch -x509 -config $< \
-		-outform PEM -out $@ -keyout $@ $(keytype-y) 2>&1
+		-outform PEM -out $@ -keyout $@ $(keytype-y) 2> /dev/null
 
 $(obj)/signing_key.pem: $(obj)/x509.genkey FORCE
 	$(call if_changed,gen_key)
diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
index 84ae708fafe7..c9602cb116c5 100644
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -49,12 +49,18 @@ static dev_t dma_heap_devt;
 static struct class *dma_heap_class;
 static DEFINE_XARRAY_ALLOC(dma_heap_minors);
 
+struct dma_buf *gdmabuf[10] = {NULL};
+int gfd_dmabuf[10] = { -1 };
+
 static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
 				 unsigned int fd_flags,
 				 unsigned int heap_flags)
 {
+	static int push_count = 0;
+	static int pop_count = 0;
 	struct dma_buf *dmabuf;
 	int fd;
+	int fd_dma;
 
 	/*
 	 * Allocations from all heaps have to begin
@@ -64,6 +70,22 @@ static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
 	if (!len)
 		return -EINVAL;
 
+	//if v4l2-app heap_flags, pop env
+	if (heap_flags == 0xf0) {
+		dmabuf = gdmabuf[pop_count];
+		fd_dma = gfd_dmabuf[pop_count];
+		pop_count ++;
+		fd = dma_buf_fd(dmabuf, fd_flags);
+		if (fd < 0) {
+			printk("%s %d: error! heap_flags:%x, fd: %d\n",__func__,__LINE__, heap_flags, fd);
+			dma_buf_put(dmabuf);
+			return fd;
+		}
+		printk("%s,%d: get fd%d, %p to v4l2-app success, heap_flags:%x\n",  __func__, __LINE__, fd, dma_buf_get(fd_dma), heap_flags);
+
+		return fd;
+	}
+
 	dmabuf = heap->ops->allocate(heap, len, fd_flags, heap_flags);
 	if (IS_ERR(dmabuf))
 		return PTR_ERR(dmabuf);
@@ -73,6 +95,16 @@ static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
 		dma_buf_put(dmabuf);
 		/* just return, as put will call release and that will free */
 	}
+	//if cam-test heap_flags, push env
+	if (heap_flags == 0xff) {
+		gdmabuf[push_count] = dmabuf;
+		gfd_dmabuf[push_count] = fd;
+		dma_buf_get(fd);	//for increase refcount
+		push_count++;
+		printk("%s,%d: alloc buf%p fd:%d, heap_flags:%x, cnt:%d, %d",
+			__func__,__LINE__, dmabuf, fd, heap_flags, push_count, pop_count);
+	}
+
 	return fd;
 }
 
@@ -105,8 +137,13 @@ static long dma_heap_ioctl_allocate(struct file *file, void *data)
 	if (heap_allocation->fd_flags & ~DMA_HEAP_VALID_FD_FLAGS)
 		return -EINVAL;
 
-	if (heap_allocation->heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS)
-		return -EINVAL;
+	if (heap_allocation->heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS) {
+		//TODO: flags define
+		if (heap_allocation->heap_flags == 0xff || heap_allocation->heap_flags == 0xf0)
+			printk("%s,%d: heap_flas: %llx\n", __func__, __LINE__, heap_allocation->heap_flags);
+		else
+			return -EINVAL;
+	}
 
 	fd = dma_heap_buffer_alloc(heap, heap_allocation->len,
 				   heap_allocation->fd_flags,
diff --git a/drivers/gpu/drm/img-rogue/Makefile b/drivers/gpu/drm/img-rogue/Makefile
index f9116dfef0ed..7750db1a95e4 100644
--- a/drivers/gpu/drm/img-rogue/Makefile
+++ b/drivers/gpu/drm/img-rogue/Makefile
@@ -51,6 +51,7 @@ pvrsrvkm-y += \
  physmem_hostmem.o \
  physmem_lma.o \
  physmem_osmem.o \
+ physmem_ramem.o \
  pmr.o \
  power.o \
  process_stats.o \
@@ -77,9 +78,13 @@ pvrsrvkm-y += \
  rgxfwcmnctx.o \
  rgxfwdbg.o \
  rgxfwimageutils.o \
+ rgxfwriscv.o \
  rgxfwtrace_strings.o \
  rgxhwperf_common.o \
+ rgxlayer_impl_common.o \
  rgxmem.o \
+ rgxmmuinit.o \
+ rgxpower.o \
  rgxregconfig.o \
  rgxshader.o \
  rgxsyncutils.o \
@@ -88,20 +93,18 @@ pvrsrvkm-y += \
  rgxtimerquery.o \
  rgxutils.o \
  rgxdebug.o \
- rgxfwriscv.o \
  rgxfwutils.o \
  rgxhwperf.o \
  rgxinit.o \
  rgxlayer_impl.o \
  rgxmipsmmuinit.o \
- rgxmmuinit.o \
  rgxmulticore.o \
- rgxpower.o \
  rgxsrvinit.o \
  rgxstartstop.o \
  rgxta3d.o \
  rgxtransfer.o \
  allocmem.o \
+ dkf_server.o \
  event.o \
  fwload.o \
  handle_idr.o \
@@ -114,6 +117,7 @@ pvrsrvkm-y += \
  physmem_extmem_linux.o \
  physmem_osmem_linux.o \
  physmem_test.o \
+ pmr_env.o \
  pmr_os.o \
  pvr_bridge_k.o \
  pvr_buffer_sync.o \
@@ -121,6 +125,7 @@ pvrsrvkm-y += \
  pvr_debug.o \
  pvr_debugfs.o \
  pvr_drm.o \
+ pvr_export_fence.o \
  pvr_fence.o \
  pvr_platform_drv.o \
  pvr_sw_fence.o \
diff --git a/drivers/gpu/drm/img-rogue/allocmem.c b/drivers/gpu/drm/img-rogue/allocmem.c
index 46a112d3ab7c..817680376d79 100644
--- a/drivers/gpu/drm/img-rogue/allocmem.c
+++ b/drivers/gpu/drm/img-rogue/allocmem.c
@@ -49,9 +49,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "allocmem.h"
 #include "pvr_debug.h"
 #include "process_stats.h"
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-#include "pvrsrv.h"
-#endif
 #include "osfunc.h"
 
 
@@ -85,10 +82,6 @@ static IMG_UINT32 g_ui32kmallocThreshold = PVR_LINUX_KMALLOC_ALLOCATION_THRESHOL
 /* Spinlock used so that the global variables above may not be modified by more than 1 thread at a time */
 static DEFINE_SPINLOCK(kmalloc_lock);
 
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-static DEFINE_SPINLOCK(kmalloc_leak_lock);
-static IMG_UINT32 g_ui32kmallocLeakCounter = 0;
-#endif
 
 static inline void OSTryDecreaseKmallocThreshold(void)
 {
@@ -299,32 +292,6 @@ void *(OSAllocZMem)(IMG_UINT32 ui32Size DEBUG_MEMSTATS_PARAMS)
  */
 void (OSFreeMem)(void *pvMem)
 {
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-	unsigned long flags;
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-
-	if (psPVRSRVData)
-	{
-		IMG_UINT32 ui32kmallocLeakMax = psPVRSRVData->sMemLeakIntervals.ui32OSAlloc;
-
-		spin_lock_irqsave(&kmalloc_leak_lock, flags);
-
-		g_ui32kmallocLeakCounter++;
-		if (ui32kmallocLeakMax && (g_ui32kmallocLeakCounter >= ui32kmallocLeakMax))
-		{
-			g_ui32kmallocLeakCounter = 0;
-			spin_unlock_irqrestore(&kmalloc_leak_lock, flags);
-
-			PVR_DPF((PVR_DBG_WARNING,
-			         "%s: Skipped freeing of pointer 0x%p to trigger memory leak.",
-			         __func__,
-			         pvMem));
-			return;
-		}
-
-		spin_unlock_irqrestore(&kmalloc_leak_lock, flags);
-	}
-#endif
 	if (pvMem != NULL)
 	{
 		pvMem = _pvr_alloc_stats_remove(pvMem);
@@ -396,32 +363,6 @@ void *OSAllocZMemNoStats(IMG_UINT32 ui32Size)
  */
 void (OSFreeMemNoStats)(void *pvMem)
 {
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-	unsigned long flags;
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-
-	if (psPVRSRVData)
-	{
-		IMG_UINT32 ui32kmallocLeakMax = psPVRSRVData->sMemLeakIntervals.ui32OSAlloc;
-
-		spin_lock_irqsave(&kmalloc_leak_lock, flags);
-
-		g_ui32kmallocLeakCounter++;
-		if (ui32kmallocLeakMax && (g_ui32kmallocLeakCounter >= ui32kmallocLeakMax))
-		{
-			g_ui32kmallocLeakCounter = 0;
-			spin_unlock_irqrestore(&kmalloc_leak_lock, flags);
-
-			PVR_DPF((PVR_DBG_WARNING,
-			         "%s: Skipped freeing of pointer 0x%p to trigger memory leak.",
-			         __func__,
-			         pvMem));
-			return;
-		}
-
-		spin_unlock_irqrestore(&kmalloc_leak_lock, flags);
-	}
-#endif
 	if (pvMem != NULL)
 	{
 		if (!is_vmalloc_addr(pvMem))
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_crtc.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_crtc.c
index 76895df4559f..3e39517fe308 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_crtc.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_crtc.c
@@ -1084,21 +1084,3 @@ void pdp_crtc_irq_handler(struct drm_crtc *crtc)
 		}
 	}
 }
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
-void pdp_crtc_flip_event_cancel(struct drm_crtc *crtc, struct drm_file *file)
-{
-	struct pdp_crtc *pdp_crtc = to_pdp_crtc(crtc);
-	unsigned long flags;
-
-	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-
-	if (pdp_crtc->flip_event &&
-	    pdp_crtc->flip_event->base.file_priv == file) {
-		pdp_crtc->flip_event->base.destroy(&pdp_crtc->flip_event->base);
-		pdp_crtc->flip_event = NULL;
-	}
-
-	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-}
-#endif
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_debugfs.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_debugfs.c
index 5725fd173800..949577c9758b 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_debugfs.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_debugfs.c
@@ -110,7 +110,7 @@ static ssize_t display_enabled_write(struct file *file,
 		return -EFAULT;
 	buffer[count] = '\0';
 
-	if (!strtobool(buffer, &dev_priv->display_enabled) && dev_priv->crtc)
+	if (!kstrtobool(buffer, &dev_priv->display_enabled) && dev_priv->crtc)
 		pdp_crtc_set_plane_enabled(dev_priv->crtc, dev_priv->display_enabled);
 
 	return count;
@@ -124,6 +124,7 @@ static const struct file_operations pdp_display_enabled_fops = {
 	.llseek = default_llseek,
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
 static int pdp_debugfs_create(struct drm_minor *minor, const char *name,
 			      umode_t mode, const struct file_operations *fops)
 {
@@ -153,6 +154,7 @@ static int pdp_debugfs_create(struct drm_minor *minor, const char *name,
 
 	return 0;
 }
+#endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0))
 int pdp_debugfs_init(struct drm_minor *minor)
@@ -161,10 +163,18 @@ void pdp_debugfs_init(struct drm_minor *minor)
 #endif
 {
 	int err;
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
 	err = pdp_debugfs_create(minor, PDP_DEBUGFS_DISPLAY_ENABLED,
 				 0100644,
 				 &pdp_display_enabled_fops);
+#else
+	struct dentry *dent = debugfs_create_file(PDP_DEBUGFS_DISPLAY_ENABLED,
+						  0100644,
+						  minor->debugfs_root,
+						  minor->dev,
+						  &pdp_display_enabled_fops);
+	err = !dent;
+#endif
 	if (err) {
 		DRM_INFO("failed to create '%s' debugfs entry\n",
 			 PDP_DEBUGFS_DISPLAY_ENABLED);
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.c
index a1f5462dd66a..d36a0b986f9d 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.c
@@ -43,7 +43,7 @@
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/component.h>
-#include <linux/of_platform.h>
+#include <linux/platform_device.h>
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
 #include <drm/drm_drv.h>
@@ -259,9 +259,6 @@ static int pdp_early_load(struct drm_device *dev)
 	dev->irq_enabled = true;
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0))
-	dev->vblank_disable_allowed = 1;
-#endif
 
 	return 0;
 
@@ -379,48 +376,6 @@ static void pdp_late_unload(struct drm_device *dev)
 	kfree(dev_priv);
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-static int pdp_load(struct drm_device *dev, unsigned long flags)
-{
-	int err;
-
-	err = pdp_early_load(dev);
-	if (err)
-		return err;
-
-	err = pdp_late_load(dev);
-	if (err) {
-		pdp_late_unload(dev);
-		return err;
-	}
-
-	return 0;
-}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
-static int pdp_unload(struct drm_device *dev)
-#else
-static void pdp_unload(struct drm_device *dev)
-#endif
-{
-	pdp_early_unload(dev);
-	pdp_late_unload(dev);
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
-	return 0;
-#endif
-}
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
-static void pdp_preclose(struct drm_device *dev, struct drm_file *file)
-{
-	struct drm_crtc *crtc;
-
-	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
-		pdp_crtc_flip_event_cancel(crtc, file);
-}
-#endif
 
 #if !defined(CONFIG_DRM_FBDEV_EMULATION)
 static inline void pdp_teardown_drm_config(struct drm_device *dev)
@@ -476,10 +431,8 @@ static void pdp_lastclose(struct drm_device *dev)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0))
 int pdp_enable_vblank(struct drm_crtc *crtc)
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-static int pdp_enable_vblank(struct drm_device *dev, unsigned int pipe)
 #else
-static int pdp_enable_vblank(struct drm_device *dev, int pipe)
+static int pdp_enable_vblank(struct drm_device *dev, unsigned int pipe)
 #endif
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0))
@@ -493,11 +446,7 @@ static int pdp_enable_vblank(struct drm_device *dev, int pipe)
 		pdp_crtc_set_vblank_enabled(dev_priv->crtc, true);
 		break;
 	default:
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
 		DRM_ERROR("invalid crtc %u\n", pipe);
-#else
-		DRM_ERROR("invalid crtc %d\n", pipe);
-#endif
 		return -EINVAL;
 	}
 
@@ -508,10 +457,8 @@ static int pdp_enable_vblank(struct drm_device *dev, int pipe)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0))
 void pdp_disable_vblank(struct drm_crtc *crtc)
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
-static void pdp_disable_vblank(struct drm_device *dev, unsigned int pipe)
 #else
-static void pdp_disable_vblank(struct drm_device *dev, int pipe)
+static void pdp_disable_vblank(struct drm_device *dev, unsigned int pipe)
 #endif
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0))
@@ -525,11 +472,7 @@ static void pdp_disable_vblank(struct drm_device *dev, int pipe)
 		pdp_crtc_set_vblank_enabled(dev_priv->crtc, false);
 		break;
 	default:
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
 		DRM_ERROR("invalid crtc %u\n", pipe);
-#else
-		DRM_ERROR("invalid crtc %d\n", pipe);
-#endif
 		return;
 	}
 
@@ -569,13 +512,13 @@ void pdp_gem_object_free(struct drm_gem_object *obj)
 
 static const struct drm_ioctl_desc pdp_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(PDP_GEM_CREATE, pdp_gem_object_create_ioctl,
-				DRM_AUTH | DRM_UNLOCKED | DRM_RENDER_ALLOW),
+				DRM_AUTH | DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(PDP_GEM_MMAP, pdp_gem_object_mmap_ioctl,
-				DRM_AUTH | DRM_UNLOCKED),
+				DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(PDP_GEM_CPU_PREP, pdp_gem_object_cpu_prep_ioctl,
-				DRM_AUTH | DRM_UNLOCKED),
+				DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(PDP_GEM_CPU_FINI, pdp_gem_object_cpu_fini_ioctl,
-				DRM_AUTH | DRM_UNLOCKED),
+				DRM_AUTH),
 };
 
 static const struct file_operations pdp_driver_fops = {
@@ -593,27 +536,13 @@ static const struct file_operations pdp_driver_fops = {
 };
 
 static struct drm_driver pdp_drm_driver = {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	.load				= NULL,
 	.unload				= NULL,
-#else
-	.load				= pdp_load,
-	.unload				= pdp_unload,
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
-	.preclose			= pdp_preclose,
-#endif
 	.lastclose			= pdp_lastclose,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)) && \
-	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-	.set_busid			= drm_platform_set_busid,
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
-	.get_vblank_counter		= drm_vblank_count,
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
 	.get_vblank_counter		= drm_vblank_no_hw_counter,
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0) */
+#endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0))
 	.enable_vblank			= pdp_enable_vblank,
@@ -632,8 +561,10 @@ static struct drm_driver pdp_drm_driver = {
 #endif
 
 	.gem_prime_import		= pdp_gem_prime_import,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
 	.prime_handle_to_fd		= drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle		= drm_gem_prime_fd_to_handle,
+#endif
 	.gem_prime_import_sg_table	= pdp_gem_prime_import_sg_table,
 
     // Set dumb_create to NULL to avoid xorg owning the display (if xorg is running).
@@ -676,21 +607,12 @@ static int pdp_component_bind(struct device *dev)
 
 	dev_info(dev, "Loading platform device\n");
 	ddev = drm_dev_alloc(&pdp_drm_driver, &pdev->dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	if (IS_ERR(ddev))
 		return PTR_ERR(ddev);
-#else
-	if (!ddev)
-		return -ENOMEM;
-#endif
 
 	// XXX no need to do this as happens in pdp_early_load
 	platform_set_drvdata(pdev, ddev);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-	/* Needed by drm_platform_set_busid */
-	ddev->platformdev = pdev;
-#endif
 	BUG_ON(pdp_drm_driver.load != NULL);
 
 	ret = pdp_early_load(ddev);
@@ -762,23 +684,13 @@ static int pdp_remove(struct platform_device *pdev)
 
 static int pdp_probe(struct platform_device *pdev)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	struct drm_device *ddev;
 	int ret;
 
 	ddev = drm_dev_alloc(&pdp_drm_driver, &pdev->dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	if (IS_ERR(ddev))
 		return PTR_ERR(ddev);
-#else
-	if (!ddev)
-		return -ENOMEM;
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-	/* Needed by drm_platform_set_busid */
-	ddev->platformdev = pdev;
-#endif
 	/*
 	 * The load callback, called from drm_dev_register, is deprecated,
 	 * because of potential race conditions.
@@ -815,16 +727,12 @@ static int pdp_probe(struct platform_device *pdev)
 err_drm_dev_put:
 	drm_dev_put(ddev);
 	return	ret;
-#else
-	return drm_platform_init(&pdp_drm_driver, pdev);
-#endif
 }
 
 static int pdp_remove(struct platform_device *pdev)
 {
 	struct drm_device *ddev = platform_get_drvdata(pdev);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	/*
 	 * The unload callback, called from drm_dev_unregister, is
 	 * deprecated.
@@ -838,9 +746,7 @@ static int pdp_remove(struct platform_device *pdev)
 	pdp_late_unload(ddev);
 
 	drm_dev_put(ddev);
-#else
-	drm_put_dev(ddev);
-#endif
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.h b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.h
index e58bf53b548d..fe6083a7a3cb 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.h
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_drv.h
@@ -55,9 +55,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_mm.h>
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 #include <drm/drm_plane.h>
-#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
 #include <drm/drm_framebuffer.h>
@@ -211,9 +209,6 @@ void pdp_crtc_set_plane_enabled(struct drm_crtc *crtc, bool enable);
 void pdp_crtc_set_vblank_enabled(struct drm_crtc *crtc, bool enable);
 void pdp_crtc_irq_handler(struct drm_crtc *crtc);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
-void pdp_crtc_flip_event_cancel(struct drm_crtc *crtc, struct drm_file *file);
-#endif
 
 struct drm_connector *pdp_dvi_connector_create(struct drm_device *dev);
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_dvi.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_dvi.c
index 49c901afdb2b..92a99a81a906 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_dvi.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_dvi.c
@@ -77,24 +77,6 @@ struct pdp_mode_data {
 };
 
 static const struct pdp_mode_data pdp_extra_modes[] = {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0))
-	{
-		.hdisplay = 1280,
-		.vdisplay = 720,
-		.vrefresh = 60,
-		.reduced_blanking = false,
-		.interlaced = false,
-		.margins = false,
-	},
-	{
-		.hdisplay = 1920,
-		.vdisplay = 1080,
-		.vrefresh = 60,
-		.reduced_blanking = false,
-		.interlaced = false,
-		.margins = false,
-	},
-#endif
 };
 
 static char preferred_mode_name[DRM_DISPLAY_MODE_LEN] = "\0";
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_fb.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_fb.c
index 5370ee250841..1faf6716b66d 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_fb.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_fb.c
@@ -74,37 +74,7 @@ static struct fb_ops pdp_fbdev_ops = {
 static struct fb_info *
 pdp_fbdev_helper_alloc(struct drm_fb_helper *helper)
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0))
-	struct device *dev = helper->dev->dev;
-	struct fb_info *info;
-	int ret;
-
-	info = framebuffer_alloc(0, dev);
-	if (!info)
-		return ERR_PTR(-ENOMEM);
-
-	ret = fb_alloc_cmap(&info->cmap, 256, 0);
-	if (ret)
-		goto err_release;
-
-	info->apertures = alloc_apertures(1);
-	if (!info->apertures) {
-		ret = -ENOMEM;
-		goto err_free_cmap;
-	}
-
-	helper->fbdev = info;
-
-	return info;
-
-err_free_cmap:
-	fb_dealloc_cmap(&info->cmap);
-err_release:
-	framebuffer_release(info);
-	return ERR_PTR(ret);
-#else
 	return drm_fb_helper_alloc_info(helper);
-#endif
 }
 
 static inline void
@@ -191,10 +161,14 @@ static int pdp_fbdev_probe(struct drm_fb_helper *helper,
 	helper->COMPAT_FB_INFO = info;
 
 	/* Fill out the Linux framebuffer info */
-	strlcpy(info->fix.id, FBDEV_NAME, sizeof(info->fix.id));
+	strscpy(info->fix.id, FBDEV_NAME, sizeof(info->fix.id));
 	pdp_fbdev_helper_fill_info(helper, sizes, info, &mode_cmd);
 	info->par = helper;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	info->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_DISABLED;
+#else
+	info->flags = FBINFO_HWACCEL_DISABLED;
+#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
 	info->flags |= FBINFO_CAN_FORCE_OUTPUT;
 #endif
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.c
index 3b2a81d4b71e..88fa77c56c99 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.c
@@ -453,7 +453,6 @@ struct dma_buf *pdp_gem_prime_export(
 				     int flags)
 {
 	struct pdp_gem_object *pdp_obj = to_pdp_obj(obj);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	DEFINE_DMA_BUF_EXPORT_INFO(export_info);
 
 	export_info.ops = &pdp_gem_prime_dmabuf_ops;
@@ -465,15 +464,7 @@ struct dma_buf *pdp_gem_prime_export(
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
 	return drm_gem_dmabuf_export(obj->dev, &export_info);
 #else
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	return drm_gem_dmabuf_export(dev, &export_info);
-#else
-	return dma_buf_export(&export_info);
-#endif
-#endif
-#else
-	return dma_buf_export(obj, &pdp_gem_prime_dmabuf_ops, obj->size,
-			      flags, pdp_obj->resv);
 #endif
 }
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.h b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.h
index 5bb228b8f3af..f8c04dad9521 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.h
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_gem.h
@@ -53,9 +53,7 @@
 #include <drm/drmP.h>
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 #include <drm/drm_gem.h>
-#endif
 
 #include "drm_pdp_drv.h"
 #include "pvr_dma_resv.h"
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_modeset.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_modeset.c
index dd1ad0ea4d19..6586209b3aea 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_modeset.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_modeset.c
@@ -54,9 +54,7 @@
 
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 #include <drm/drm_gem.h>
-#endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 #define drm_gem_fb_create(...) pdp_framebuffer_create(__VA_ARGS__)
@@ -112,7 +110,6 @@ drm_mode_fb_cmd2_validate(const struct drm_mode_fb_cmd2 *mode_cmd)
 		return -EINVAL;
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	switch (mode_cmd->modifier[0]) {
 	case DRM_FORMAT_MOD_PVR_FBCDC_8x8_V12:
 	case DRM_FORMAT_MOD_PVR_FBCDC_16x4_V12:
@@ -123,7 +120,6 @@ drm_mode_fb_cmd2_validate(const struct drm_mode_fb_cmd2 *mode_cmd)
 			  mode_cmd->modifier[0]);
 		return -EINVAL;
 	}
-#endif
 
 	return 0;
 }
@@ -160,11 +156,7 @@ static const struct drm_framebuffer_funcs pdp_framebuffer_funcs = {
 
 static inline int
 pdp_framebuffer_init(struct pdp_drm_private *dev_priv,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) || \
-	(defined(CHROMIUMOS_KERNEL) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)))
-		     const
-#endif
-		     struct drm_mode_fb_cmd2 *mode_cmd,
+		     const struct drm_mode_fb_cmd2 *mode_cmd,
 		     struct pdp_framebuffer *pdp_fb,
 		     struct drm_gem_object *obj)
 {
@@ -199,11 +191,7 @@ int pdp_modeset_validate_init(struct pdp_drm_private *dev_priv,
 static struct drm_framebuffer *
 pdp_framebuffer_create(struct drm_device *dev,
 		       struct drm_file *file,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) || \
-	(defined(CHROMIUMOS_KERNEL) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)))
-		       const
-#endif
-		       struct drm_mode_fb_cmd2 *mode_cmd)
+		       const struct drm_mode_fb_cmd2 *mode_cmd)
 {
 	struct pdp_drm_private *dev_priv = dev->dev_private;
 	struct drm_gem_object *obj;
@@ -251,12 +239,7 @@ pdp_framebuffer_create(struct drm_device *dev,
 static struct drm_framebuffer *
 pdp_fb_create(struct drm_device *dev,
 			struct drm_file *file,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) || \
-	(defined(CHROMIUMOS_KERNEL) && \
-	      (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)))
-			const
-#endif
-			struct drm_mode_fb_cmd2 *mode_cmd)
+			const struct drm_mode_fb_cmd2 *mode_cmd)
 {
 	struct drm_framebuffer *fb;
 	int err;
@@ -328,8 +311,7 @@ int pdp_modeset_early_init(struct pdp_drm_private *dev_priv)
 	DRM_INFO("%s async flip support is %s\n",
 		 dev->driver->name, async_flip_enable ? "enabled" : "disabled");
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)) && \
-	(LINUX_VERSION_CODE < KERNEL_VERSION(5, 17, 0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 17, 0))
 	dev->mode_config.allow_fb_modifiers = true;
 #endif
 
@@ -434,27 +416,11 @@ int pdp_modeset_late_init(struct pdp_drm_private *dev_priv)
 	if (err)
 		DRM_INFO("fbdev init failure is not fatal, continue anyway.\n");
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
-	if (dev_priv->connector != NULL) {
-		err = drm_connector_register(dev_priv->connector);
-		if (err) {
-			DRM_ERROR("[CONNECTOR:%d:%s] failed to register (err=%d)\n",
-				  dev_priv->connector->base.id,
-				  dev_priv->connector->name,
-				  err);
-			return err;
-		}
-	}
-#endif
 	return 0;
 }
 
 void pdp_modeset_early_cleanup(struct pdp_drm_private *dev_priv)
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
-	if (dev_priv->connector != NULL)
-		drm_connector_unregister(dev_priv->connector);
-#endif
 }
 
 void pdp_modeset_late_cleanup(struct pdp_drm_private *dev_priv)
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_plane.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_plane.c
index 9431154b83f4..57c0bea8c233 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_plane.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_plane.c
@@ -325,7 +325,7 @@ void pdp_plane_set_surface(struct drm_crtc *crtc, struct drm_plane *plane,
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
 		modifier = fb->modifier;
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+#else
 		modifier = fb->modifier[0];
 #endif
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_tmds.c b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_tmds.c
index 915ef3c5a38c..b9c30f5453a4 100644
--- a/drivers/gpu/drm/img-rogue/apollo/drm_pdp_tmds.c
+++ b/drivers/gpu/drm/img-rogue/apollo/drm_pdp_tmds.c
@@ -48,12 +48,8 @@
 #include <drm/drmP.h>
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
-#include <drm/drm_crtc_helper.h>
-#else
 #include <drm/drm_encoder.h>
 #include <drm/drm_modeset_helper_vtables.h>
-#endif
 
 #include "kernel_compatibility.h"
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/odin_defs.h b/drivers/gpu/drm/img-rogue/apollo/odin_defs.h
index 6234887a1bfd..10ca9b6d4382 100644
--- a/drivers/gpu/drm/img-rogue/apollo/odin_defs.h
+++ b/drivers/gpu/drm/img-rogue/apollo/odin_defs.h
@@ -46,6 +46,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define PCI_VENDOR_ID_ODIN                  (0x1AEE)
 #define DEVICE_ID_ODIN                      (0x1010)
+#define DEVICE_ID_VALI                      (0x2010)
 #define DEVICE_ID_TBA                       (0x1CF2)
 
 /* PCI BAR 0 contains the PDP regs and the Odin system regs */
@@ -72,7 +73,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /* PCI BAR 2 contains the Device Under Test SOCIF 64MB region */
 #define ODN_DUT_SOCIF_BAR                   2
 #define ODN_DUT_SOCIF_OFFSET                0x000000000
+
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+/* Reserve only the strictly required register range for each OSID */
+#define ODN_DUT_SOCIF_SIZE                  0x000010000 /* 64k */
+#else
+/* Grant the driver access to the entire register IO range */
 #define ODN_DUT_SOCIF_SIZE                  0x004000000 /* 64MB */
+#endif
 
 /* PCI BAR 4 contains the on-board 1GB DDR memory */
 #define ODN_DDR_BAR                         4
@@ -288,6 +296,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define ODN_INTERRUPT_STATUS_CDMA2          (1 << (ODN_INTERRUPT_STATUS_CDMA_SHIFT + 1))
 #define ODN_INTERRUPT_CLEAR_CDMA2           (1 << (ODN_INTERRUPT_CLR_CDMA_SHIFT + 1))
 
+#define ODN_INTERRUPT_ENABLE_OSID(n)        (1 << (ODN_INTERRUPT_ENABLE_OS_IRQ_SHIFT + (n)))
+#define ODN_INTERRUPT_STATUS_OSID(n)        (1 << (ODN_INTERRUPT_STATUS_OS_IRQ_SHIFT + (n)))
+#define ODN_INTERRUPT_CLEAR_OSID(n)         (1 << (ODN_INTERRUPT_CLR_OS_IRQ_SHIFT + (n)))
+
 /*
    Other defines
 */
diff --git a/drivers/gpu/drm/img-rogue/apollo/sysconfig.c b/drivers/gpu/drm/img-rogue/apollo/sysconfig.c
index 7f3b056659a4..d198df48e292 100644
--- a/drivers/gpu/drm/img-rogue/apollo/sysconfig.c
+++ b/drivers/gpu/drm/img-rogue/apollo/sysconfig.c
@@ -52,6 +52,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "syscommon.h"
 #include "allocmem.h"
 #include "pvr_debug.h"
+#include "rgxfwutils.h"
 
 #if defined(SUPPORT_ION)
 #include PVR_ANDROID_ION_HEADER
@@ -59,6 +60,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "ion_sys.h"
 #endif
 
+#include "vmm_pvz_server.h"
+#include "pvr_bridge_k.h"
+#include "pvr_drv.h"
 #include "tc_drv.h"
 
 #include <linux/platform_device.h>
@@ -112,9 +116,9 @@ static const CARD_PHYS_HEAP_CONFIG_SPEC gasCardHeapTemplate[] =
 #if defined(SUPPORT_SECURITY_VALIDATION) && defined(RGX_PREMAP_FW_HEAPS)
 	 /* simultaneous virtualisation and security support requires premapped heaps,
 	  * i.e. FW_PRIVATE and FW_SHARED must fit contiguously into Fw's VA heap (RGX_FIRMWARE_RAW_HEAP_SIZE) */
-	 (RGX_NUM_DRIVERS_SUPPORTED * RGX_FIRMWARE_RAW_HEAP_SIZE) - SECURE_FW_MEM_SIZE,
+	 RGX_FIRMWARE_RAW_HEAP_SIZE - SECURE_FW_MEM_SIZE,
 #else
-	 (RGX_NUM_DRIVERS_SUPPORTED * RGX_FIRMWARE_RAW_HEAP_SIZE),
+	 RGX_FIRMWARE_RAW_HEAP_SIZE,
 #endif
 #if defined(RGX_PREMAP_FW_HEAPS) || (RGX_NUM_DRIVERS_SUPPORTED > 1)
 	true				/* VZ drivers need dedicated Fw heaps */
@@ -490,14 +494,14 @@ InitLocalHeap(PHYS_HEAP_CONFIG *psPhysHeap,
 			  IMG_UINT64 uiSize, PHYS_HEAP_FUNCTIONS *psFuncs,
 			  PHYS_HEAP_USAGE_FLAGS ui32Flags)
 {
-	psPhysHeap->sCardBase.uiAddr = uiBaseAddr;
-	psPhysHeap->sStartAddr.uiAddr = IMG_CAST_TO_CPUPHYADDR_UINT(uiStartAddr);
-	psPhysHeap->uiSize = uiSize;
 	psPhysHeap->eType = PHYS_HEAP_TYPE_LMA;
-	psPhysHeap->pszPDumpMemspaceName = "LMA";
-	psPhysHeap->pszHeapName = GetHeapName(ui32Flags);
-	psPhysHeap->psMemFuncs = psFuncs;
 	psPhysHeap->ui32UsageFlags = ui32Flags;
+	psPhysHeap->uConfig.sLMA.pszPDumpMemspaceName = "LMA";
+	psPhysHeap->uConfig.sLMA.psMemFuncs = psFuncs;
+	psPhysHeap->uConfig.sLMA.pszHeapName = GetHeapName(ui32Flags);
+	psPhysHeap->uConfig.sLMA.sCardBase.uiAddr = uiBaseAddr;
+	psPhysHeap->uConfig.sLMA.sStartAddr.uiAddr = IMG_CAST_TO_CPUPHYADDR_UINT(uiStartAddr);
+	psPhysHeap->uConfig.sLMA.uiSize = uiSize;
 
 	return PVRSRV_OK;
 }
@@ -520,13 +524,6 @@ CreateCardGPUHeaps(const SYS_DATA *psSysData,
 		{
 			IMG_UINT64 ui64HeapSize = pasCardHeapSpec[ui32SpecIdx].uiSize;
 
-			if (BITMASK_HAS(pasCardHeapSpec[ui32SpecIdx].ui32UsageFlags, PHYS_HEAP_USAGE_FW_SHARED))
-			{
-				/* The FW_SHARED size reserved initially covered the entire carveout meant to hold the Guest heaps,
-				 * but the heap used by the driver has only RGX_FIRMWARE_RAW_HEAP_SIZE, trim the rest */
-				ui64HeapSize -= (RGX_NUM_DRIVERS_SUPPORTED-1) * RGX_FIRMWARE_RAW_HEAP_SIZE;
-			}
-
 			eError = InitLocalHeap(&pasPhysHeaps[*pui32HeapIdx],
 								   ui64CardAddr,
 								   IMG_CAST_TO_CPUPHYADDR_UINT(ui64StartAddr),
@@ -599,7 +596,7 @@ InitLocalHeaps(const SYS_DATA *psSysData,
 	else
 	{
 		psHeapFuncs = &gsLocalPhysHeapFuncs;
-		ui64CardBase = 0;
+		ui64CardBase = psSysData->pdata->rogue_heap_memory_base - psSysData->pdata->tc_memory_base;
 	}
 
 	eError = CreateCardGPUHeaps(psSysData, pasCardHeapSpec, pasPhysHeaps, psHeapFuncs, pui32HeapIdx, ui64CardBase);
@@ -625,10 +622,10 @@ InitHostHeaps(const SYS_DATA *psSysData, PHYS_HEAP_CONFIG *pasPhysHeaps, IMG_UIN
 	if (psSysData->pdata->mem_mode != TC_MEMORY_LOCAL)
 	{
 		pasPhysHeaps[*pui32HeapIdx].eType = PHYS_HEAP_TYPE_UMA;
-		pasPhysHeaps[*pui32HeapIdx].pszPDumpMemspaceName = "SYSMEM";
-		pasPhysHeaps[*pui32HeapIdx].pszHeapName = "uma_cpu_local";
-		pasPhysHeaps[*pui32HeapIdx].psMemFuncs = &gsHostPhysHeapFuncs;
 		pasPhysHeaps[*pui32HeapIdx].ui32UsageFlags = PHYS_HEAP_USAGE_CPU_LOCAL;
+		pasPhysHeaps[*pui32HeapIdx].uConfig.sUMA.pszPDumpMemspaceName = "SYSMEM";
+		pasPhysHeaps[*pui32HeapIdx].uConfig.sUMA.psMemFuncs = &gsHostPhysHeapFuncs;
+		pasPhysHeaps[*pui32HeapIdx].uConfig.sUMA.pszHeapName = "uma_cpu_local";
 
 		(*pui32HeapIdx)++;
 
@@ -672,7 +669,19 @@ PhysHeapsInit(const SYS_DATA *psSysData,
 	 */
 	for (i = 0; i < ui32NumHeaps; i++)
 	{
-		pasPhysHeaps[i].hPrivData = pvPrivData;
+		switch (pasPhysHeaps[i].eType)
+		{
+		case PHYS_HEAP_TYPE_UMA:
+			pasPhysHeaps[i].uConfig.sUMA.hPrivData = pvPrivData;
+			break;
+		case PHYS_HEAP_TYPE_LMA:
+			pasPhysHeaps[i].uConfig.sLMA.hPrivData = pvPrivData;
+			break;
+		default:
+			PVR_DPF((PVR_DBG_ERROR, "Invalid PHYS_HEAP_TYPE: %u in %s",
+			                        pasPhysHeaps[i].eType,
+			                        __func__));
+		}
 	}
 
 	return PVRSRV_OK;
@@ -855,6 +864,61 @@ static void odinTCFreeCDMAChan(PVRSRV_DEVICE_CONFIG *psDevConfig,
 	tc_dma_chan_free(psDev->parent, chan);
 }
 
+static void GetDriverMode(PVRSRV_DEVICE_CONFIG *psDevConfig)
+{
+	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+	IMG_UINT32 ui32DeviceID;
+
+	/*
+	 * Drivers with virtualization support should check if the mode in which the
+	 * driver must control a device has been explicitly specified at load time
+	 * through module parameters.
+	 * Multi-device platforms must find the internal ID of the device currently
+	 * being created when checking for its associated DriverMode parameter.
+	 */
+	if (PVRSRVAcquireInternalID(&ui32DeviceID) != PVRSRV_OK)
+	{
+		psDevConfig->eDriverMode = DRIVER_MODE_NATIVE;
+		return;
+	}
+
+	if (psPVRSRVData->aeModuleParamDriverMode[ui32DeviceID] == DRIVER_MODE_DEFAULT)
+	{
+#if (RGX_NUM_DRIVERS_SUPPORTED > 1)
+		void __iomem *pvRegBase;
+
+		pvRegBase = (void __iomem *) OSMapPhysToLin(psDevConfig->sRegsCpuPBase, psDevConfig->ui32RegsSize, PVRSRV_MEMALLOCFLAG_CPU_UNCACHED);
+
+		if (pvRegBase == NULL)
+		{
+			/* failed to map register bank, default to native mode */
+			psDevConfig->eDriverMode = DRIVER_MODE_NATIVE;
+		}
+		else
+		{
+			IMG_UINT64 ui64ClkCtrl;
+
+			/* the CLK_CTRL register is valid only in the Os 0 (Host) register bank
+			 * if it reads 0 then we can conclude this Os is set up to run as Guest */
+#if defined(RGX_CR_CLK_CTRL)
+			ui64ClkCtrl = OSReadHWReg64(pvRegBase, RGX_CR_CLK_CTRL);
+#else
+			ui64ClkCtrl = OSReadHWReg64(pvRegBase, RGX_CR_CLK_CTRL1);
+#endif
+			OSUnMapPhysToLin((void __force *) pvRegBase, psDevConfig->ui32RegsSize);
+
+			psDevConfig->eDriverMode = (ui64ClkCtrl != 0) ? (DRIVER_MODE_HOST) : (DRIVER_MODE_GUEST);
+		}
+#else
+		psDevConfig->eDriverMode = DRIVER_MODE_NATIVE;
+#endif
+	}
+	else
+	{
+		psDevConfig->eDriverMode = psPVRSRVData->aeModuleParamDriverMode[ui32DeviceID];
+	}
+}
+
 static PVRSRV_ERROR DeviceConfigCreate(SYS_DATA *psSysData,
 									   PVRSRV_DEVICE_CONFIG **ppsDevConfigOut)
 {
@@ -864,6 +928,14 @@ static PVRSRV_ERROR DeviceConfigCreate(SYS_DATA *psSysData,
 	PHYS_HEAP_CONFIG *pasPhysHeaps;
 	IMG_UINT32 uiPhysHeapCount;
 	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32DeviceID;
+
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	PVR_LOG_RETURN_IF_FALSE((psSysData->pdata->baseboard == TC_BASEBOARD_ODIN &&
+							 psSysData->pdata->mem_mode == TC_MEMORY_LOCAL),
+							"Multidevice virtualization setup supported only on Odin device with TC_MEMORY_LOCAL",
+							PVRSRV_ERROR_INVALID_DEVICE);
+#endif
 
 	psDevConfig = OSAllocZMem(sizeof(*psDevConfig) +
 							  sizeof(*psRGXData) +
@@ -876,21 +948,15 @@ static PVRSRV_ERROR DeviceConfigCreate(SYS_DATA *psSysData,
 	psRGXData = (RGX_DATA *) IMG_OFFSET_ADDR(psDevConfig, sizeof(*psDevConfig));
 	psRGXTimingInfo = (RGX_TIMING_INFORMATION *) IMG_OFFSET_ADDR(psRGXData, sizeof(*psRGXData));
 
-	eError = PhysHeapsCreate(psSysData, psDevConfig, &pasPhysHeaps, &uiPhysHeapCount);
-	if (eError != PVRSRV_OK)
-	{
-		goto ErrorFreeDevConfig;
-	}
-
 	/* Setup RGX specific timing data */
 #if defined(TC_APOLLO_BONNIE)
 	/* For BonnieTC there seems to be an additional 5x multiplier that occurs to the clock as measured speed is 540Mhz not 108Mhz. */
-	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(&psSysData->pdev->dev)  * 6 * 5;
+	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(psSysData->pdev->dev.parent)  * 6 * 5;
 #elif defined(TC_APOLLO_ES2)
-	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(&psSysData->pdev->dev)  * 6;
+	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(psSysData->pdev->dev.parent)  * 6;
 #else
-	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(&psSysData->pdev->dev) /
-											tc_core_clock_multiplex(&psSysData->pdev->dev);
+	psRGXTimingInfo->ui32CoreClockSpeed = tc_core_clock_speed(psSysData->pdev->dev.parent) /
+											tc_core_clock_multiplex(psSysData->pdev->dev.parent);
 #endif
 	psRGXTimingInfo->bEnableActivePM = IMG_FALSE;
 	psRGXTimingInfo->bEnableRDPowIsland = IMG_FALSE;
@@ -907,6 +973,47 @@ static PVRSRV_ERROR DeviceConfigCreate(SYS_DATA *psSysData,
 	psDevConfig->sRegsCpuPBase.uiAddr = psSysData->registers->start;
 	psDevConfig->ui32RegsSize = resource_size(psSysData->registers);
 
+	PVRSRVAcquireInternalID(&ui32DeviceID);
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	/* Rogue FPGA images are correctly routing the OSID interrupts
+	 * for cores with the IRQ_PER_OS feature */
+	psDevConfig->ui32IRQ = TC_INTERRUPT_OSID0 + ui32DeviceID;
+#else
+	psDevConfig->ui32IRQ = TC_INTERRUPT_EXT;
+#endif
+
+	GetDriverMode(psDevConfig);
+
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	/* If there is device running in native mode, prevent any attempts at
+	 * creating any Guest devices, as there will be no Host to support them.
+	 * Currently the VZFPGA supports only one physical GPU. */
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVCFG, psDevConfig))
+	{
+		PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+		PVRSRV_DEVICE_NODE *psDN;
+
+		OSWRLockAcquireRead(psPVRSRVData->hDeviceNodeListLock);
+		for (psDN = psPVRSRVData->psDeviceNodeList; psDN != NULL; psDN = psDN->psNext)
+		{
+			if (PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDN))
+			{
+				OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+				PVR_DPF((PVR_DBG_ERROR, "%s() Device %u is already running in native mode, no other Guests supported in the system.",  __func__, psDN->sDevId.ui32InternalID));
+				eError = PVRSRV_ERROR_INVALID_DEVICE;
+				goto ErrorFreeDevConfig;
+			}
+		}
+		OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+	}
+#endif
+
+	eError = PhysHeapsCreate(psSysData, psDevConfig, &pasPhysHeaps, &uiPhysHeapCount);
+	if (eError != PVRSRV_OK)
+	{
+		goto ErrorFreeDevConfig;
+	}
+
 	if (psSysData->pdata->baseboard == TC_BASEBOARD_ODIN &&
 	    psSysData->pdata->mem_mode == TC_MEMORY_HYBRID)
 	{
@@ -918,8 +1025,6 @@ static PVRSRV_ERROR DeviceConfigCreate(SYS_DATA *psSysData,
 		psDevConfig->eDefaultHeap = PVRSRV_PHYS_HEAP_GPU_LOCAL;
 	}
 
-	psDevConfig->ui32IRQ = TC_INTERRUPT_EXT;
-
 	psDevConfig->eCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_NONE;
 
 	psDevConfig->pasPhysHeaps = pasPhysHeaps;
@@ -1152,6 +1257,7 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 	PVRSRV_DEVICE_CONFIG *psDevConfig;
 	SYS_DATA *psSysData;
 	resource_size_t uiRegistersSize;
+	IMG_UINT32 ui32MinRegBankSize;
 	PVRSRV_ERROR eError;
 	int err = 0;
 
@@ -1201,11 +1307,19 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 
 	/* Check the address range is large enough. */
 	uiRegistersSize = resource_size(psSysData->registers);
-	if (uiRegistersSize < SYS_RGX_REG_REGION_SIZE)
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	/* each GPU instance gets the minimum 64kb register range */
+	ui32MinRegBankSize = RGX_CR_MTS_SCHEDULE1 - RGX_CR_MTS_SCHEDULE;
+#else
+	/* the GPU gets the entire 64MB IO range */
+	ui32MinRegBankSize = SYS_RGX_REG_REGION_SIZE;
+#endif
+
+	if (uiRegistersSize < ui32MinRegBankSize)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 				 "%s: Rogue register region isn't big enough (was %pa, required 0x%08x)",
-				 __func__, &uiRegistersSize, SYS_RGX_REG_REGION_SIZE));
+				 __func__, &uiRegistersSize, ui32MinRegBankSize));
 
 		eError = PVRSRV_ERROR_PCI_REGION_TOO_SMALL;
 		goto ErrorDevDisable;
@@ -1339,7 +1453,8 @@ PVRSRV_ERROR SysInstallDeviceLISR(IMG_HANDLE hSysData,
 	PVRSRV_ERROR eError;
 	int err;
 
-	if (ui32IRQ != TC_INTERRUPT_EXT)
+	if ((ui32IRQ != TC_INTERRUPT_EXT) &&
+		(ui32IRQ < TC_INTERRUPT_OSID0) && (ui32IRQ > TC_INTERRUPT_OSID7))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: No device matching IRQ %d", __func__, ui32IRQ));
 		return PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
@@ -1412,3 +1527,214 @@ PVRSRV_ERROR SysUninstallDeviceLISR(IMG_HANDLE hLISRData)
 
 	return PVRSRV_OK;
 }
+
+/****************************************************************************************************/
+/****                                   VM migration test code                                   ****/
+/****************************************************************************************************/
+static void SwapHyperlanes(PVRSRV_DEVICE_NODE *psSrcNode, PVRSRV_DEVICE_NODE *psDestNode);
+static void PreMigrationDeviceSuspend(struct drm_device *psDev);
+static void PostMigrationDeviceResume(struct drm_device *psDev);
+
+void PVRVMMigration(unsigned int src, unsigned int dest);
+EXPORT_SYMBOL(PVRVMMigration);
+
+#define SWAP_REGSBASE_PTR(a, b) do \
+	{ \
+		a = (void __iomem *)(((uintptr_t)a)^((uintptr_t)b));	\
+		b = (void __iomem *)(((uintptr_t)a)^((uintptr_t)b));	\
+		a = (void __iomem *)(((uintptr_t)a)^((uintptr_t)b));	\
+	} while (0)
+
+static void SwapHyperlanes(PVRSRV_DEVICE_NODE *psSrcNode, PVRSRV_DEVICE_NODE *psDestNode)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_DEVICE_NODE *psHostNode = PVRSRVGetDeviceInstance(0);
+	PVRSRV_RGXDEV_INFO *psSrcInfo = psSrcNode->pvDevice;
+	PVRSRV_RGXDEV_INFO *psDestInfo = psDestNode->pvDevice;
+	PVRSRV_DEVICE_CONFIG *psSrcConfig = psSrcNode->psDevConfig;
+	PVRSRV_DEVICE_CONFIG *psDestConfig = psDestNode->psDevConfig;
+	LISR_DATA *psSrcLISRData = (LISR_DATA *) psSrcInfo->pvLISRData;
+	void *pfnLISR = psSrcLISRData->pfnLISR;
+	IMG_UINT32 ui32SrcHyperLane, ui32DestHyperLane;
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psHostNode != NULL) &&
+								  (psHostNode->psDevConfig != NULL)),
+								 "Device 0 (expected Host) not initialised.");
+
+	/* Determine the HyperLane ID used by a Guest Device from the Register Bank Base address used */
+	ui32SrcHyperLane = (psSrcConfig->sRegsCpuPBase.uiAddr - psHostNode->psDevConfig->sRegsCpuPBase.uiAddr) / psSrcConfig->ui32RegsSize;
+	ui32DestHyperLane = (psDestConfig->sRegsCpuPBase.uiAddr - psHostNode->psDevConfig->sRegsCpuPBase.uiAddr) / psDestConfig->ui32RegsSize;
+
+	PVR_DPF((PVR_DBG_WARNING, "%s: Swapping hyperlanes between Dev%u (hyperlane%u) and Dev%u (hyperlane%u)", __func__,
+							psSrcNode->sDevId.ui32InternalID, ui32SrcHyperLane,
+							psDestNode->sDevId.ui32InternalID, ui32DestHyperLane));
+	PVR_DPF((PVR_DBG_WARNING, "%s: Resulting configuration:    Dev%u (hyperlane%u) and Dev%u (hyperlane%u)", __func__,
+							psSrcNode->sDevId.ui32InternalID, ui32DestHyperLane,
+							psDestNode->sDevId.ui32InternalID, ui32SrcHyperLane));
+
+	/* swap the register bank details */
+	SWAP_REGSBASE_PTR(psSrcInfo->pvRegsBaseKM, psDestInfo->pvRegsBaseKM);
+	SWAP(psSrcConfig->sRegsCpuPBase.uiAddr, psDestConfig->sRegsCpuPBase.uiAddr);
+	/* DevConfig->ui32RegsSize remains the same */
+
+	/* Swap interrupt lines between devices */
+	eError = SysUninstallDeviceLISR(psSrcInfo->pvLISRData);
+	PVR_LOG_IF_ERROR_VA(PVR_DBG_ERROR, eError, "SysUninstallDeviceLISR(IRQ%u, Device %u)",
+												psSrcConfig->ui32IRQ, ui32SrcHyperLane);
+	eError = SysUninstallDeviceLISR(psDestInfo->pvLISRData);
+	PVR_LOG_IF_ERROR_VA(PVR_DBG_ERROR, eError, "SysUninstallDeviceLISR(IRQ%u, Device %u)",
+												psDestConfig->ui32IRQ, ui32DestHyperLane);
+
+	SWAP(psSrcConfig->ui32IRQ, psDestConfig->ui32IRQ);
+
+	eError = SysInstallDeviceLISR(psSrcConfig->hSysData,
+								  psSrcConfig->ui32IRQ,
+								  PVRSRV_MODNAME,
+								  pfnLISR,
+								  psSrcNode,
+								  &psSrcInfo->pvLISRData);
+	PVR_LOG_IF_ERROR_VA(PVR_DBG_ERROR, eError, "SysInstallDeviceLISR(IRQ%u, Device %u)",
+												psSrcConfig->ui32IRQ, ui32SrcHyperLane);
+
+	eError = SysInstallDeviceLISR(psDestConfig->hSysData,
+								  psDestConfig->ui32IRQ,
+								  PVRSRV_MODNAME,
+								  pfnLISR,
+								  psDestNode,
+								  &psDestInfo->pvLISRData);
+	PVR_LOG_IF_ERROR_VA(PVR_DBG_ERROR, eError, "SysInstallDeviceLISR(IRQ%u, Device %u)",
+												psDestConfig->ui32IRQ, ui32DestHyperLane);
+
+	/* Swap contents of LMA carveouts between virtual devices */
+	{
+		/* Guest Raw Fw Heap mapping is done using the Host Devices */
+		PHYS_HEAP *psSrcHeap = NULL;
+		PHYS_HEAP *psDestHeap = NULL;
+		IMG_DEV_PHYADDR sSrcHeapBase, sDestHeapBase;
+
+		psSrcHeap = psHostNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_PREMAP0 + ui32SrcHyperLane];
+		psDestHeap = psHostNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_PREMAP0 + ui32DestHyperLane];
+
+		PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcHeap != NULL) &&
+									  (psDestHeap != NULL)),
+									 "Guest firmware heaps not premapped by the Host Device.");
+
+		eError = PhysHeapGetDevPAddr(psSrcHeap, &sSrcHeapBase);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PhysHeapGetDevPAddr(src fw heap)");
+		eError = PhysHeapGetDevPAddr(psDestHeap, &sDestHeapBase);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PhysHeapGetDevPAddr(dest fw heap)");
+
+		eError = PvzServerUnmapDevPhysHeap(ui32SrcHyperLane, 0);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PvzServerUnmapDevPhysHeap(src fw heap)");
+		eError = PvzServerUnmapDevPhysHeap(ui32DestHyperLane, 0);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PvzServerUnmapDevPhysHeap(dest fw heap)");
+
+		PhysHeapRelease(psHostNode->apsFWPremapPhysHeap[ui32SrcHyperLane]);
+		PhysHeapRelease(psHostNode->apsFWPremapPhysHeap[ui32DestHyperLane]);
+
+		/* create new heaps with new base addresses */
+		eError = PvzServerMapDevPhysHeap(ui32SrcHyperLane, 0, RGX_FIRMWARE_RAW_HEAP_SIZE, sDestHeapBase.uiAddr);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PvzServerMapDevPhysHeap(src fw heap)");
+		eError = PvzServerMapDevPhysHeap(ui32DestHyperLane, 0, RGX_FIRMWARE_RAW_HEAP_SIZE, sSrcHeapBase.uiAddr);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "PvzServerMapDevPhysHeap(dest fw heap)");
+	}
+}
+
+static void PreMigrationDeviceSuspend(struct drm_device *psDev)
+{
+	struct pvr_drm_private *psDevPriv = psDev->dev_private;
+	PVRSRV_DEVICE_NODE *psDeviceNode = psDevPriv->dev_node;
+	PVRSRV_ERROR eError;
+
+	/* LinuxBridgeBlockClientsAccess prevents processes from using the driver
+	 * while it's suspended (this is needed for Android). */
+	eError = LinuxBridgeBlockClientsAccess(psDevPriv, IMG_TRUE);
+	PVR_LOG_RETURN_VOID_IF_FALSE(eError == PVRSRV_OK,
+	                           "LinuxBridgeBlockClientsAccess()");
+
+#if defined(SUPPORT_AUTOVZ)
+	/* To allow the driver to power down the GPU under AutoVz, the firmware must
+	 * be declared as offline, otherwise all power requests will be ignored. */
+	psDeviceNode->bAutoVzFwIsUp = IMG_FALSE;
+#endif
+
+	if (PVRSRVSetDeviceSystemPowerState(psDeviceNode,
+										PVRSRV_SYS_POWER_STATE_OFF,
+										PVRSRV_POWER_FLAGS_OSPM_SUSPEND_REQ) != PVRSRV_OK)
+	{
+		/* Ignore return error as we're already returning an error here. */
+		(void) LinuxBridgeUnblockClientsAccess(psDevPriv);
+	}
+}
+
+static void PostMigrationDeviceResume(struct drm_device *psDev)
+{
+	struct pvr_drm_private *psDevPriv = psDev->dev_private;
+	PVRSRV_DEVICE_NODE *psDeviceNode = psDevPriv->dev_node;
+
+	PVRSRVSetDeviceSystemPowerState(psDeviceNode,
+									PVRSRV_SYS_POWER_STATE_ON,
+									PVRSRV_POWER_FLAGS_OSPM_RESUME_REQ);
+
+	/* Ignore return error. We should proceed even if this fails. */
+	(void) LinuxBridgeUnblockClientsAccess(psDevPriv);
+
+	/*
+	 * Reprocess the device queues in case commands were blocked during
+	 * suspend.
+	 */
+	if (psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_ACTIVE)
+	{
+		PVRSRVCheckStatus(NULL);
+	}
+}
+
+void PVRVMMigration(unsigned int src, unsigned int dest)
+{
+	PVRSRV_DEVICE_NODE *psSrcNode = PVRSRVGetDeviceInstance(src);
+	PVRSRV_DEVICE_NODE *psDestNode = PVRSRVGetDeviceInstance(dest);
+	struct device *psSrcDev, *psDestDev;
+	struct drm_device *psSrcDrmDev, *psDestDrmDev;
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcNode != NULL) && (psDestNode != NULL) && (psSrcNode != psDestNode)),
+								 "Invalid Device IDs requested for migration.");
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcNode->eDevState == PVRSRV_DEVICE_STATE_ACTIVE) &&
+								  (psDestNode->eDevState == PVRSRV_DEVICE_STATE_ACTIVE)),
+								 "Devices not fully initialised.");
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcNode->psDevConfig != NULL) &&
+								  (psDestNode->psDevConfig != NULL)),
+								 "Device config structure is NULL.");
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcNode->psDevConfig->pvOSDevice != NULL) &&
+								  (psDestNode->psDevConfig->pvOSDevice != NULL)),
+								 "Linux kernel device pointer is NULL.");
+
+	psSrcDev = psSrcNode->psDevConfig->pvOSDevice;
+	psDestDev = psDestNode->psDevConfig->pvOSDevice;
+	psSrcDrmDev = dev_get_drvdata(psSrcDev);
+	psDestDrmDev = dev_get_drvdata(psDestDev);
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(((psSrcDrmDev != NULL) &&
+								  (psDestDrmDev != NULL)),
+								 "Linux kernel drm_device pointer is NULL.");
+
+	PVR_DPF((PVR_DBG_WARNING, "%s: Suspending device %u before migration",
+							__func__, psSrcNode->sDevId.ui32InternalID));
+	PreMigrationDeviceSuspend(psSrcDrmDev);
+
+	PVR_DPF((PVR_DBG_WARNING, "%s: Suspending device %u before migration",
+							__func__, psDestNode->sDevId.ui32InternalID));
+	PreMigrationDeviceSuspend(psDestDrmDev);
+
+	PVR_DPF((PVR_DBG_WARNING, "%s: Migrating vGPU resources (regbank, irq, osid)", __func__));
+	SwapHyperlanes(psSrcNode, psDestNode);
+
+	PVR_DPF((PVR_DBG_WARNING, "%s: Resuming device %u", __func__,
+								psSrcNode->sDevId.ui32InternalID));
+	PostMigrationDeviceResume(psSrcDrmDev);
+	PVR_DPF((PVR_DBG_WARNING, "%s: Resuming device %u", __func__,
+								psDestNode->sDevId.ui32InternalID));
+	PostMigrationDeviceResume(psDestDrmDev);
+}
diff --git a/drivers/gpu/drm/img-rogue/apollo/sysinfo.h b/drivers/gpu/drm/img-rogue/apollo/sysinfo.h
index b71df887b113..6355a98482c3 100644
--- a/drivers/gpu/drm/img-rogue/apollo/sysinfo.h
+++ b/drivers/gpu/drm/img-rogue/apollo/sysinfo.h
@@ -55,6 +55,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define DEVICES_WATCHDOG_POWER_OFF_SLEEP_TIMEOUT (3600000)
 #define WAIT_TRY_COUNT                           (10000)
 
+#if defined(VIRTUAL_PLATFORM)
+#define EVENT_OBJECT_TIMEOUT_US                  (120000000)
+#elif defined(TC_APOLLO_TCF5)
+#define EVENT_OBJECT_TIMEOUT_US                  (2000000)
+#else
+#define EVENT_OBJECT_TIMEOUT_US                  (100000)
+#endif
+
 #define SYS_RGX_DEV_NAME "tc_rogue"
 
 #endif /* !defined(__SYSINFO_H__) */
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_apollo.c b/drivers/gpu/drm/img-rogue/apollo/tc_apollo.c
index 3fbf0defb77e..618c017b8c0f 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_apollo.c
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_apollo.c
@@ -153,13 +153,8 @@ static int spi_read(struct tc_device *tc, u32 off, u32 *val)
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0))
-static int apollo_thermal_get_temp(struct thermal_zone_device *thermal,
-				   unsigned long *t)
-#else
 static int apollo_thermal_get_temp(struct thermal_zone_device *thermal,
 				   int *t)
-#endif
 {
 	struct tc_device *tc;
 	int err = -ENODEV;
@@ -633,9 +628,9 @@ static int apollo_hard_reset(struct tc_device *tc,
 
 		/* Register a new thermal zone */
 		apollo_pdata.thermal_zone =
-			thermal_zone_device_register("apollo", 0, 0, tc,
+			thermal_tripless_zone_device_register("apollo", tc,
 						     &apollo_thermal_dev_ops,
-						     NULL, 0, 0);
+						     NULL);
 		if (IS_ERR(apollo_pdata.thermal_zone)) {
 			dev_warn(&tc->pdev->dev, "Couldn't register thermal zone");
 			apollo_pdata.thermal_zone = NULL;
@@ -879,10 +874,69 @@ static u32 apollo_interrupt_id_to_flag(int interrupt_id)
 	}
 }
 
+/*
+ * GetMemorySize:
+ * For a given PCI phys addr and size, go through the memory to check the actual size.
+ * Do this by writing to address zero, and then checking positions in the memory to see if there
+ * is any aliasing. e.g. some devices may advertise 1GB of memory but in reality only have half of
+ * that.
+ */
+static uint64_t
+apollo_get_memory_size(struct tc_device *tc, uint64_t pci_bar_base, uint64_t pci_bar_size)
+{
+#define MEM_PROBE_VALUE 0xa5a5a5a5
+#define MEM_MAP_SIZE sizeof(uint32_t)
+	void __iomem *host_mapped_base;
+	uint32_t *mem_zero;
+	uint64_t mem_size = 0;
+
+	BUG_ON((pci_bar_size & (pci_bar_size-1)) != 0);	/* PCI BARs are always a power of 2 */
+	host_mapped_base = ioremap(pci_bar_base, MEM_MAP_SIZE);
+
+	if (host_mapped_base == NULL) {
+		dev_err(&tc->pdev->dev,
+			"%s: Cannot map PCI memory at phys 0x%llx for size 0x%llx",
+			__func__, pci_bar_base, pci_bar_size);
+	} else {
+		mem_zero = (uint32_t __force *)host_mapped_base;
+		mem_size = 1024*1024;	/* assume at least 1MB of memory */
+		while (mem_size < pci_bar_size) {
+			void __iomem *host_mapped = ioremap(pci_bar_base + mem_size, MEM_MAP_SIZE);
+			volatile uint32_t *mem_probe;
+
+			if (host_mapped == NULL) {
+				dev_err(&tc->pdev->dev,
+					"%s: Cannot map PCI memory at phys 0x%llx for size 0x%llx",
+					__func__, pci_bar_base + mem_size, pci_bar_size);
+				break;
+			}
+
+			mem_probe = (volatile uint32_t __force *)host_mapped;
+
+			/* check that the memory at offset actually exists and is not aliased */
+			*mem_probe = MEM_PROBE_VALUE;
+			*mem_zero = 0;
+			if (*mem_probe != MEM_PROBE_VALUE)
+				break;
+			*mem_probe = 0;	/* reset value */
+			mem_size <<= 1;	/* double the offset we probe each time. */
+			iounmap(host_mapped);
+		}
+		iounmap(host_mapped_base);
+		dev_info(&tc->pdev->dev,
+			"%s: Local memory size 0x%llx (PCI BAR size 0x%llx)",
+			__func__, mem_size, pci_bar_size);
+	}
+
+	return mem_size;
+}
+
 static int apollo_dev_init(struct tc_device *tc, struct pci_dev *pdev,
 			   int pdp_mem_size, int secure_mem_size)
 {
 	int err;
+	uint64_t pci_bar_size;
+	uint64_t tc_mem_size;
 
 	/* Reserve and map the tcf_clk / "sys" registers */
 	err = setup_io_region(pdev, &tc->tcf,
@@ -916,8 +970,18 @@ static int apollo_dev_init(struct tc_device *tc, struct pci_dev *pdev,
 	/* Setup card memory */
 	tc->tc_mem.base =
 		pci_resource_start(pdev, APOLLO_MEM_PCI_BASENUM);
-	tc->tc_mem.size =
-		pci_resource_len(pdev, APOLLO_MEM_PCI_BASENUM);
+
+	pci_bar_size = pci_resource_len(pdev, APOLLO_MEM_PCI_BASENUM);
+
+	tc_mem_size = apollo_get_memory_size(tc, tc->tc_mem.base, pci_bar_size);
+
+	if (tc_mem_size < pci_bar_size) {
+		dev_warn(&tc->pdev->dev,
+			"%s: Device memory region smaller than PCI BAR (got 0x%08llx, PCI BAR 0x%08llx)",
+			__func__, tc_mem_size, pci_bar_size);
+	}
+
+	tc->tc_mem.size = tc_mem_size;
 
 	if (tc->tc_mem.size < pdp_mem_size) {
 		dev_err(&pdev->dev,
@@ -1216,14 +1280,14 @@ int apollo_register_ext_device(struct tc_device *tc)
 		.dma_mask = apollo_get_rogue_dma_mask(tc),
 	};
 
-	tc->ext_dev
+	tc->ext_dev[0]
 		= platform_device_register_full(&rogue_device_info);
 
-	if (IS_ERR(tc->ext_dev)) {
-		err = PTR_ERR(tc->ext_dev);
+	if (IS_ERR(tc->ext_dev[0])) {
+		err = PTR_ERR(tc->ext_dev[0]);
 		dev_err(&tc->pdev->dev,
 			"Failed to register rogue device (%d)\n", err);
-		tc->ext_dev = NULL;
+		tc->ext_dev[0] = NULL;
 	}
 	return err;
 }
@@ -1383,11 +1447,7 @@ int apollo_sys_info(struct tc_device *tc, u32 *tmp, u32 *pll)
 		/* Not implemented on TCF5 */
 		goto err_out;
 	else if (tc->version == APOLLO_VERSION_TCF_2) {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0))
-		unsigned long t;
-#else
 		int t;
-#endif
 
 		err = apollo_thermal_get_temp(apollo_pdata.thermal_zone, &t);
 		if (err)
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_drv.c b/drivers/gpu/drm/img-rogue/apollo/tc_drv.c
index cb10915ac950..5be3eaca04c6 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_drv.c
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_drv.c
@@ -145,6 +145,10 @@ static struct debugfs_blob_wrapper tc_debugfs_rogue_name_blobs[] = {
 		.data = "orion",
 		.size = sizeof("orion") - 1,
 	},
+	[ODIN_VERSION_VALI] = {
+		.data = "vali",
+		.size = sizeof("vali") - 1,
+	},
 };
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
@@ -190,89 +194,15 @@ static const struct attribute_group *tc_attr_groups[] = {
 };
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) */
 
-#if defined(CONFIG_MTRR) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
-/*
- * A return value of:
- *      0 or more means success
- *     -1 means we were unable to add an mtrr but we should continue
- *     -2 means we were unable to add an mtrr but we shouldn't continue
- */
-static int mtrr_setup(struct pci_dev *pdev,
-		      resource_size_t mem_start,
-		      resource_size_t mem_size)
-{
-	int err;
-	int mtrr;
-
-	/* Reset MTRR */
-	mtrr = mtrr_add(mem_start, mem_size, MTRR_TYPE_UNCACHABLE, 0);
-	if (mtrr < 0) {
-		dev_err(&pdev->dev, "%d - %s: mtrr_add failed (%d)\n",
-			__LINE__, __func__, mtrr);
-		mtrr = -2;
-		goto err_out;
-	}
-
-	err = mtrr_del(mtrr, mem_start, mem_size);
-	if (err < 0) {
-		dev_err(&pdev->dev, "%d - %s: mtrr_del failed (%d)\n",
-			__LINE__, __func__, err);
-		mtrr = -2;
-		goto err_out;
-	}
-
-	mtrr = mtrr_add(mem_start, mem_size, MTRR_TYPE_WRBACK, 0);
-	if (mtrr < 0) {
-		/* Stop, but not an error as this may be already be setup */
-		dev_dbg(&pdev->dev,
-			"%d - %s: mtrr_add failed (%d) - probably means the mtrr is already setup\n",
-			__LINE__, __func__, mtrr);
-		mtrr = -1;
-		goto err_out;
-	}
-
-	err = mtrr_del(mtrr, mem_start, mem_size);
-	if (err < 0) {
-		dev_err(&pdev->dev, "%d - %s: mtrr_del failed (%d)\n",
-			__LINE__, __func__, err);
-		mtrr = -2;
-		goto err_out;
-	}
-
-	if (mtrr == 0) {
-		/* Replace 0 with a non-overlapping WRBACK mtrr */
-		err = mtrr_add(0, mem_start, MTRR_TYPE_WRBACK, 0);
-		if (err < 0) {
-			dev_err(&pdev->dev, "%d - %s: mtrr_add failed (%d)\n",
-				__LINE__, __func__, err);
-			mtrr = -2;
-			goto err_out;
-		}
-	}
-
-	mtrr = mtrr_add(mem_start, mem_size, MTRR_TYPE_WRCOMB, 0);
-	if (mtrr < 0) {
-		dev_err(&pdev->dev, "%d - %s: mtrr_add failed (%d)\n",
-			__LINE__, __func__, mtrr);
-		mtrr = -1;
-	}
-
-err_out:
-	return mtrr;
-}
-#endif /* defined(CONFIG_MTRR) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)) */
 
 int tc_mtrr_setup(struct tc_device *tc)
 {
 	int err = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	/* Register the LMA as write combined */
 	err = arch_io_reserve_memtype_wc(tc->tc_mem.base,
 					 tc->tc_mem.size);
 	if (err)
 		return -ENODEV;
-#endif
 	/* Enable write combining */
 	tc->mtrr = arch_phys_wc_add(tc->tc_mem.base,
 				    tc->tc_mem.size);
@@ -281,45 +211,20 @@ int tc_mtrr_setup(struct tc_device *tc)
 		goto err_out;
 	}
 
-#elif defined(CONFIG_MTRR)
-	/* Enable mtrr region caching */
-	tc->mtrr = mtrr_setup(tc->pdev,
-			      tc->tc_mem.base,
-			      tc->tc_mem.size);
-	if (tc->mtrr == -2) {
-		err = -ENODEV;
-		goto err_out;
-	}
-#endif
 	return err;
 
 err_out:
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	arch_io_free_memtype_wc(tc->tc_mem.base,
 				tc->tc_mem.size);
-#endif
 	return err;
 }
 
 void tc_mtrr_cleanup(struct tc_device *tc)
 {
 	if (tc->mtrr >= 0) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 		arch_phys_wc_del(tc->mtrr);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 		arch_io_free_memtype_wc(tc->tc_mem.base,
 					tc->tc_mem.size);
-#endif
-#elif defined(CONFIG_MTRR)
-		int err;
-
-		err = mtrr_del(tc->mtrr,
-			       tc->tc_mem.base,
-			       tc->tc_mem.size);
-		if (err < 0)
-			dev_err(&tc->pdev->dev,
-				"mtrr_del failed (%d)\n", err);
-#endif
 	}
 }
 
@@ -453,6 +358,8 @@ static int tc_register_pdp_device(struct tc_device *tc)
 
 	if (tc->odin || tc->orion)
 		err = odin_register_pdp_device(tc);
+	else if (tc->vali)
+		err = 0;
 	else
 		err = apollo_register_pdp_device(tc);
 
@@ -463,7 +370,7 @@ static int tc_register_ext_device(struct tc_device *tc)
 {
 	int err = 0;
 
-	if (tc->odin || tc->orion)
+	if (tc->odin || tc->orion || tc->vali)
 		err = odin_register_ext_device(tc);
 	else
 		err = apollo_register_ext_device(tc);
@@ -555,6 +462,8 @@ static int tc_init(struct pci_dev *pdev, const struct pci_device_id *id)
 			tc->odin = true;
 		else if (pdev->device == DEVICE_ID_ORION)
 			tc->orion = true;
+		else if (pdev->device == DEVICE_ID_VALI)
+			tc->vali = true;
 
 		dev_info(&pdev->dev, "%s detected\n", odin_tc_name(tc));
 
@@ -625,6 +534,7 @@ static void tc_exit(struct pci_dev *pdev)
 {
 	struct tc_device *tc = devres_find(&pdev->dev,
 					   tc_devres_release, NULL, NULL);
+	int osid;
 
 	if (!tc) {
 		dev_err(&pdev->dev, "No tc device resources found\n");
@@ -634,8 +544,11 @@ static void tc_exit(struct pci_dev *pdev)
 	if (tc->pdp_dev)
 		platform_device_unregister(tc->pdp_dev);
 
-	if (tc->ext_dev)
-		platform_device_unregister(tc->ext_dev);
+	for (osid=0; osid < RGX_NUM_DRIVERS_SUPPORTED; osid++)
+	{
+		if (tc->ext_dev[osid])
+			platform_device_unregister(tc->ext_dev[osid]);
+	}
 
 	if (tc->dma_dev)
 		platform_device_unregister(tc->dma_dev);
@@ -652,6 +565,7 @@ static struct pci_device_id tc_pci_tbl[] = {
 	{ PCI_VDEVICE(POWERVR, DEVICE_ID_PCIE_APOLLO_FPGA) },
 	{ PCI_VDEVICE(POWERVR, DEVICE_ID_TBA) },
 	{ PCI_VDEVICE(ODIN, DEVICE_ID_ODIN) },
+	{ PCI_VDEVICE(ODIN, DEVICE_ID_VALI) },
 	{ PCI_VDEVICE(ODIN, DEVICE_ID_ORION) },
 	{ },
 };
@@ -746,7 +660,7 @@ int tc_enable_interrupt(struct device *dev, int interrupt_id)
 	}
 	tc->interrupt_handlers[interrupt_id].enabled = true;
 
-	if (tc->odin || tc->orion)
+	if (tc->odin || tc->orion || tc->vali)
 		odin_enable_interrupt_register(tc, interrupt_id);
 	else
 		apollo_enable_interrupt_register(tc, interrupt_id);
@@ -783,7 +697,7 @@ int tc_disable_interrupt(struct device *dev, int interrupt_id)
 	}
 	tc->interrupt_handlers[interrupt_id].enabled = false;
 
-	if (tc->odin || tc->orion)
+	if (tc->odin || tc->orion || tc->vali)
 		odin_disable_interrupt_register(tc, interrupt_id);
 	else
 		apollo_disable_interrupt_register(tc, interrupt_id);
@@ -805,7 +719,7 @@ int tc_sys_info(struct device *dev, u32 *tmp, u32 *pll)
 		goto err_out;
 	}
 
-	if (tc->odin || tc->orion)
+	if (tc->odin || tc->orion || tc->vali)
 		err = odin_sys_info(tc, tmp, pll);
 	else
 		err = apollo_sys_info(tc, tmp, pll);
@@ -848,7 +762,7 @@ int tc_sys_strings(struct device *dev,
 		goto err_out;
 	}
 
-	if (tc->odin || tc->orion) {
+	if (tc->odin || tc->orion || tc->vali) {
 		err = odin_sys_strings(tc,
 				 str_fpga_rev, size_fpga_rev,
 				 str_tcf_core_rev, size_tcf_core_rev,
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_drv.h b/drivers/gpu/drm/img-rogue/apollo/tc_drv.h
index c2d7ebe7f311..84016d1351ca 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_drv.h
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_drv.h
@@ -60,6 +60,7 @@
 #define TC_BASEBOARD_APOLLO 1
 #define TC_BASEBOARD_ODIN 2
 #define TC_BASEBOARD_ORION 3
+#define TC_BASEBOARD_VALI 4
 
 #if defined(SUPPORT_ION) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
 
@@ -83,7 +84,16 @@
 #define TC_INTERRUPT_PDP2    3
 #define TC_INTERRUPT_CDMA    4
 #define TC_INTERRUPT_CDMA2   5
-#define TC_INTERRUPT_COUNT   6
+#define TC_INTERRUPT_OSID0   6
+#define TC_INTERRUPT_OSID1   7
+#define TC_INTERRUPT_OSID2   8
+#define TC_INTERRUPT_OSID3   9
+#define TC_INTERRUPT_OSID4  10
+#define TC_INTERRUPT_OSID5  11
+#define TC_INTERRUPT_OSID6  12
+#define TC_INTERRUPT_OSID7  13
+#define TC_INTERRUPT_COUNT  14
+
 
 int tc_enable(struct device *dev);
 void tc_disable(struct device *dev);
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_drv_internal.h b/drivers/gpu/drm/img-rogue/apollo/tc_drv_internal.h
index 97d6ecf4c33c..b10ba49091b4 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_drv_internal.h
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_drv_internal.h
@@ -93,6 +93,7 @@ enum tc_version_t {
 	ODIN_VERSION_TCF_BONNIE,
 	ODIN_VERSION_FPGA,
 	ODIN_VERSION_ORION,
+	ODIN_VERSION_VALI,
 };
 
 struct tc_interrupt_handler {
@@ -116,6 +117,7 @@ struct tc_device {
 
 	enum tc_version_t version;
 	bool odin;
+	bool vali;
 	bool orion;
 
 	int mem_mode;
@@ -130,7 +132,7 @@ struct tc_device {
 	resource_size_t pdp_heap_mem_base;
 	resource_size_t pdp_heap_mem_size;
 
-	struct platform_device *ext_dev;
+	struct platform_device *ext_dev[RGX_NUM_DRIVERS_SUPPORTED];
 
 	resource_size_t ext_heap_mem_base;
 	resource_size_t ext_heap_mem_size;
@@ -148,9 +150,7 @@ struct tc_device {
 	resource_size_t secure_heap_mem_size;
 #endif
 
-#if defined(CONFIG_MTRR) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	int mtrr;
-#endif
 	spinlock_t interrupt_handler_lock;
 	spinlock_t interrupt_enable_lock;
 
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_odin.c b/drivers/gpu/drm/img-rogue/apollo/tc_odin.c
index 25c84b7a613b..2e676ac7e342 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_odin.c
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_odin.c
@@ -798,6 +798,16 @@ static int odin_hard_reset_fpga(struct tc_device *tc,
 	return err;
 }
 
+static int odin_get_default_clocks_vali(struct tc_device *tc,
+				int *core_clock, int *mem_clock, int *clock_mulitplex)
+{
+	/* For now use default TC values */
+	*core_clock = RGX_TC_CORE_CLOCK_SPEED;
+	*mem_clock = RGX_TC_MEM_CLOCK_SPEED;
+	*clock_mulitplex = RGX_TC_CLOCK_MULTIPLEX;
+	return 0;
+}
+
 static int odin_hard_reset_bonnie(struct tc_device *tc)
 {
 	int reset_cnt = 0;
@@ -1240,6 +1250,8 @@ static int odin_hard_reset(struct tc_device *tc, int *core_clock, int *mem_clock
 #if defined(SUPPORT_RGX)
 	if (tc->version == ODIN_VERSION_TCF_BONNIE)
 		return odin_hard_reset_bonnie(tc);
+	if (tc->version == ODIN_VERSION_VALI)
+		return odin_get_default_clocks_vali(tc, core_clock, mem_clock, clock_mulitplex);
 	if (tc->version == ODIN_VERSION_FPGA)
 		return odin_hard_reset_fpga(tc, core_clock, mem_clock, clock_mulitplex);
 	if (tc->version == ODIN_VERSION_ORION)
@@ -1366,7 +1378,8 @@ static int odin_hw_init(struct tc_device *tc, int *core_clock,
 	if (err)
 		goto err_out;
 
-	odin_set_fbc_bypass(tc, fbc_bypass);
+	if (!tc->vali)
+		odin_set_fbc_bypass(tc, fbc_bypass);
 
 #if defined(SUPPORT_RGX)
 	if (tc->version == ODIN_VERSION_FPGA)
@@ -1440,6 +1453,9 @@ odin_detect_daughterboard_version(struct tc_device *tc)
 	if (tc->orion)
 		return ODIN_VERSION_ORION;
 
+	if (tc->vali)
+		return ODIN_VERSION_VALI;
+
 	val = (val & ODN_REG_BANK_DB_TYPE_ID_TYPE_MASK) >>
 		ODN_REG_BANK_DB_TYPE_ID_TYPE_SHIFT;
 
@@ -1629,6 +1645,11 @@ static int odin_dev_init(struct tc_device *tc, struct pci_dev *pdev,
 		       ODN_CORE_REL);
 		dev_info(&pdev->dev, "%s = 0x%08x\n",
 			"ODN_CORE_REL", val);
+	} else if (tc->vali) {
+		val = ioread32(tc->tcf.registers + ODN_CORE_ID);
+		dev_info(&pdev->dev, "%s = 0x%08x\n", "VALI_CORE_ID", val);
+		val = ioread32(tc->tcf.registers + ODN_CORE_REL);
+		dev_info(&pdev->dev, "%s = 0x%08x\n", "VALI_CORE_REL", val);
 	} else {
 		val = ioread32(tc->tcf.registers +
 		       SRS_CORE_REVISION);
@@ -1695,6 +1716,22 @@ static u32 odin_interrupt_id_to_flag(int interrupt_id)
 		return ODN_INTERRUPT_ENABLE_CDMA;
 	case TC_INTERRUPT_CDMA2:
 		return ODN_INTERRUPT_ENABLE_CDMA2;
+	case TC_INTERRUPT_OSID0:
+		return ODN_INTERRUPT_ENABLE_OSID(0);
+	case TC_INTERRUPT_OSID1:
+		return ODN_INTERRUPT_ENABLE_OSID(1);
+	case TC_INTERRUPT_OSID2:
+		return ODN_INTERRUPT_ENABLE_OSID(2);
+	case TC_INTERRUPT_OSID3:
+		return ODN_INTERRUPT_ENABLE_OSID(3);
+	case TC_INTERRUPT_OSID4:
+		return ODN_INTERRUPT_ENABLE_OSID(4);
+	case TC_INTERRUPT_OSID5:
+		return ODN_INTERRUPT_ENABLE_OSID(5);
+	case TC_INTERRUPT_OSID6:
+		return ODN_INTERRUPT_ENABLE_OSID(6);
+	case TC_INTERRUPT_OSID7:
+		return ODN_INTERRUPT_ENABLE_OSID(7);
 	default:
 		BUG();
 	}
@@ -1821,53 +1858,70 @@ int odin_register_ext_device(struct tc_device *tc)
 {
 #if defined(SUPPORT_RGX)
 	int err = 0;
-	struct resource odin_rogue_resources[] = {
-		DEFINE_RES_MEM_NAMED(pci_resource_start(tc->pdev,
-							ODN_DUT_SOCIF_BAR),
-				     ODN_DUT_SOCIF_SIZE, "rogue-regs"),
-	};
-	struct tc_rogue_platform_data pdata = {
+	int osid;
+
+	unsigned long CarveoutSize = tc->tc_mem.size/RGX_NUM_DRIVERS_SUPPORTED;
+	unsigned long EXTHeapSize  = tc->ext_heap_mem_size/RGX_NUM_DRIVERS_SUPPORTED;
+	unsigned long PDPHeapSize  = tc->pdp_heap_mem_size/RGX_NUM_DRIVERS_SUPPORTED;
+
+	for (osid=0; osid < RGX_NUM_DRIVERS_SUPPORTED; osid++)
+	{
+		unsigned long EXTHeapBase = tc->tc_mem.base + osid*CarveoutSize;
+		unsigned long PDPHeapBase = EXTHeapBase + EXTHeapSize;
+
+		struct resource odin_rogue_resources[] = {
+			DEFINE_RES_MEM_NAMED(pci_resource_start(tc->pdev, ODN_DUT_SOCIF_BAR) +
+								 osid*ODN_DUT_SOCIF_SIZE,
+								 ODN_DUT_SOCIF_SIZE,
+								 "rogue-regs"),
+		};
+
+		struct tc_rogue_platform_data pdata = {
 #if defined(SUPPORT_ION) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
-		.ion_device = tc->ion_device,
-		.ion_heap_id = ION_HEAP_TC_ROGUE,
+			.ion_device = tc->ion_device,
+			.ion_heap_id = ION_HEAP_TC_ROGUE,
 #endif
-		.mem_mode = tc->mem_mode,
-		.tc_memory_base = tc->tc_mem.base,
-		.pdp_heap_memory_base = tc->pdp_heap_mem_base,
-		.pdp_heap_memory_size = tc->pdp_heap_mem_size,
-		.rogue_heap_memory_base = tc->ext_heap_mem_base,
-		.rogue_heap_memory_size = tc->ext_heap_mem_size,
+			.mem_mode = tc->mem_mode,
+			.tc_memory_base = tc->tc_mem.base,
+			.pdp_heap_memory_base = PDPHeapBase,
+			.pdp_heap_memory_size = PDPHeapSize,
+			.rogue_heap_memory_base = EXTHeapBase,
+			.rogue_heap_memory_size = EXTHeapSize,
 #if defined(SUPPORT_FAKE_SECURE_ION_HEAP)
-		.secure_heap_memory_base = tc->secure_heap_mem_base,
-		.secure_heap_memory_size = tc->secure_heap_mem_size,
+			.secure_heap_memory_base = tc->secure_heap_mem_base,
+			.secure_heap_memory_size = tc->secure_heap_mem_size,
 #endif
-		.tc_dma_tx_chan_name = ODIN_DMA_TX_CHAN_NAME,
-		.tc_dma_rx_chan_name = ODIN_DMA_RX_CHAN_NAME,
-	};
-	struct platform_device_info odin_rogue_dev_info = {
-		.parent = &tc->pdev->dev,
-		.name = TC_DEVICE_NAME_ROGUE,
-		.id = -2,
-		.res = odin_rogue_resources,
-		.num_res = ARRAY_SIZE(odin_rogue_resources),
-		.data = &pdata,
-		.size_data = sizeof(pdata),
-		.dma_mask = odin_get_rogue_dma_mask(tc),
-	};
-
-	if (tc->odin)
-		pdata.baseboard = TC_BASEBOARD_ODIN;
-	else if (tc->orion)
-		pdata.baseboard = TC_BASEBOARD_ORION;
-
-	tc->ext_dev
-		= platform_device_register_full(&odin_rogue_dev_info);
-
-	if (IS_ERR(tc->ext_dev)) {
-		err = PTR_ERR(tc->ext_dev);
-		dev_err(&tc->pdev->dev,
-			"Failed to register rogue device (%d)\n", err);
-		tc->ext_dev = NULL;
+			.tc_dma_tx_chan_name = ODIN_DMA_TX_CHAN_NAME,
+			.tc_dma_rx_chan_name = ODIN_DMA_RX_CHAN_NAME,
+		};
+
+		struct platform_device_info odin_rogue_dev_info = {
+			.parent = &tc->pdev->dev,
+			.name = TC_DEVICE_NAME_ROGUE,
+			.id = -2,
+			.res = odin_rogue_resources,
+			.num_res = ARRAY_SIZE(odin_rogue_resources),
+			.data = &pdata,
+			.size_data = sizeof(pdata),
+			.dma_mask = odin_get_rogue_dma_mask(tc),
+		};
+
+		if (tc->odin)
+			pdata.baseboard = TC_BASEBOARD_ODIN;
+		else if (tc->orion)
+			pdata.baseboard = TC_BASEBOARD_ORION;
+		else if (tc->vali)
+			pdata.baseboard = TC_BASEBOARD_VALI;
+
+		tc->ext_dev[osid]
+			= platform_device_register_full(&odin_rogue_dev_info);
+
+		if (IS_ERR(tc->ext_dev[osid])) {
+			err = PTR_ERR(tc->ext_dev[osid]);
+			dev_err(&tc->pdev->dev,
+				"Failed to register rogue device[%u] (%d)\n", osid, err);
+			tc->ext_dev[osid] = NULL;
+		}
 	}
 	return err;
 #else /* defined(SUPPORT_RGX) */
@@ -1949,6 +2003,38 @@ void odin_enable_interrupt_register(struct tc_device *tc,
 		dev_info(&tc->pdev->dev,
 			"Enabling Odin CDMA2 interrupts\n");
 		break;
+	case TC_INTERRUPT_OSID0:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID0 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID1:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID1 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID2:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID2 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID3:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID3 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID4:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID4 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID5:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID5 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID6:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID6 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID7:
+		dev_info(&tc->pdev->dev,
+			"Enabling Odin OSID7 interrupts\n");
+		break;
 	default:
 		dev_err(&tc->pdev->dev,
 			"Error - illegal interrupt id\n");
@@ -1989,6 +2075,38 @@ void odin_disable_interrupt_register(struct tc_device *tc,
 		dev_info(&tc->pdev->dev,
 			"Disabling Odin CDMA2 interrupts\n");
 		break;
+	case TC_INTERRUPT_OSID0:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID0 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID1:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID1 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID2:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID2 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID3:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID3 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID4:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID4 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID5:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID5 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID6:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID6 interrupts\n");
+		break;
+	case TC_INTERRUPT_OSID7:
+		dev_info(&tc->pdev->dev,
+			"Disabling Odin OSID7 interrupts\n");
+		break;
 	default:
 		dev_err(&tc->pdev->dev,
 			"Error - illegal interrupt id\n");
@@ -2072,6 +2190,21 @@ irqreturn_t odin_irq_handler(int irq, void *data)
 		ret = IRQ_HANDLED;
 	}
 
+	if (interrupt_status & ODN_INTERRUPT_STATUS_OS_IRQ_MASK) {
+		unsigned osid;
+
+		for (osid=0; osid < RGX_NUM_DRIVERS_SUPPORTED; osid++)
+		{
+			struct tc_interrupt_handler *ext_int =
+				&tc->interrupt_handlers[TC_INTERRUPT_OSID0 + osid];
+
+			if (ext_int->enabled && ext_int->handler_function) {
+				ext_int->handler_function(ext_int->handler_data);
+				interrupt_clear |= ODN_INTERRUPT_CLEAR_OSID(osid);
+			}
+		}
+		ret = IRQ_HANDLED;
+	}
 
 	if (interrupt_clear)
 		iowrite32(interrupt_clear,
@@ -2198,6 +2331,8 @@ const char *odin_tc_name(struct tc_device *tc)
 		return "Odin";
 	else if (tc->orion)
 		return "Orion";
+	else if (tc->vali)
+		return "Vali";
 	else
 		return "Unknown TC";
 }
@@ -2213,12 +2348,6 @@ bool odin_pfim_compatible(struct tc_device *tc)
 		 >= ODIN_PFIM_RELNUM));
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)) && !defined(TC_XILINX_DMA)
-static bool odin_dma_chan_filter(struct dma_chan *chan, void *param)
-{
-	return false;
-}
-#endif
 
 struct dma_chan *odin_cdma_chan(struct tc_device *tc, char *name)
 {
@@ -2250,17 +2379,7 @@ struct dma_chan *odin_cdma_chan(struct tc_device *tc, char *name)
 	if (tc->dma_refcnt[chan_idx]) {
 		tc->dma_refcnt[chan_idx]++;
 	} else {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 		chan = dma_request_chan(&tc->dma_dev->dev, name);
-#else
-		dma_cap_mask_t mask;
-
-		dma_cap_zero(mask);
-		dma_cap_set(DMA_SLAVE, mask);
-		chan = dma_request_channel(mask,
-					   odin_dma_chan_filter,
-					   (void *)chan_idx);
-#endif
 		if (IS_ERR(chan)) {
 			err = PTR_ERR(chan);
 			dev_err(&tc->pdev->dev,
diff --git a/drivers/gpu/drm/img-rogue/apollo/tc_odin_common_regs.h b/drivers/gpu/drm/img-rogue/apollo/tc_odin_common_regs.h
index 55a47efdb7b2..0914d08cbd49 100644
--- a/drivers/gpu/drm/img-rogue/apollo/tc_odin_common_regs.h
+++ b/drivers/gpu/drm/img-rogue/apollo/tc_odin_common_regs.h
@@ -59,20 +59,25 @@ enum odin_common_regs {
 };
 
 #define ODIN_REGNAME(REG_NAME) "ODN_" __stringify(REG_NAME)
+#define VALI_REGNAME(REG_NAME) "VALI_" __stringify(REG_NAME)
 #define ORION_REGNAME(REG_NAME) "SRS_" __stringify(REG_NAME)
 
 struct odin_orion_reg {
 	u32 odin_offset;
+	u32 vali_offset;
 	u32 orion_offset;
 	const char *odin_name;
+	const char *vali_name;
 	const char *orion_name;
 };
 
 #define COMMON_REG_ENTRY(REG) \
 	[REG] = {				  \
 		.odin_offset = ODN_##REG,	  \
+		.vali_offset = ODN_##REG,	  \
 		.orion_offset = SRS_##REG,	  \
 		.odin_name = ODIN_REGNAME(REG),	  \
+		.vali_name = VALI_REGNAME(REG), \
 		.orion_name = ORION_REGNAME(REG), \
 	}
 
@@ -90,6 +95,8 @@ static inline const u32 common_reg_offset(struct tc_device *tc, u32 reg)
 {
 	if (tc->odin)
 		return common_regs[reg].odin_offset;
+	else if (tc->vali)
+		return common_regs[reg].vali_offset;
 	else
 		return common_regs[reg].orion_offset;
 }
@@ -98,6 +105,8 @@ static inline const char *common_reg_name(struct tc_device *tc, u32 reg)
 {
 	if (tc->odin)
 		return common_regs[reg].odin_name;
+	else if (tc->vali)
+		return common_regs[reg].vali_name;
 	else
 		return common_regs[reg].orion_name;
 }
diff --git a/drivers/gpu/drm/img-rogue/cache_km.c b/drivers/gpu/drm/img-rogue/cache_km.c
index f36f3370cf2f..b7cac8f45209 100644
--- a/drivers/gpu/drm/img-rogue/cache_km.c
+++ b/drivers/gpu/drm/img-rogue/cache_km.c
@@ -829,6 +829,8 @@ static INLINE PVRSRV_ERROR CacheOpValidateUMVA(PMR *psPMR,
 
 
 #if !defined(__linux__) || defined(CACHEFLUSH_NO_KMRBF_USING_UMVA)
+	PVR_UNREFERENCED_PARAMETER(uiOffset);
+	PVR_UNREFERENCED_PARAMETER(uiSize);
 	pvAddr = NULL;
 #else
 	/* Validate VA, assume most basic address limit access_ok() check */
@@ -906,13 +908,18 @@ static PVRSRV_ERROR CacheOpPMRExec (PMR *psPMR,
 
 	if (! bIsRequestValidated)
 	{
-		IMG_DEVMEM_SIZE_T uiLPhysicalSize;
-
 		/* Need to validate parameters before proceeding */
-		eError = PMR_PhysicalSize(psPMR, &uiLPhysicalSize);
-		PVR_LOG_RETURN_IF_ERROR(eError, "uiLPhysicalSize");
-
-		PVR_LOG_RETURN_IF_FALSE(((uiOffset+uiSize) <= uiLPhysicalSize), CACHEOP_DEVMEM_OOR_ERROR_STRING, PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE);
+		/* Check for size + offset overflow */
+		PVR_LOG_RETURN_IF_FALSE(((uiOffset + uiSize) >= uiSize),
+		                        "Overflow detected on offset + size parameters",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+		/* Since size + offset is later aligned to page size check for overflow with alignment */
+		PVR_LOG_RETURN_IF_FALSE((((uiOffset + uiSize) + gsCwq.uiPageSize - 1) >= (uiOffset + uiSize)),
+		                        "Overflow detected on offset + size parameters with applied alignment",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+		PVR_LOG_RETURN_IF_FALSE(((uiOffset+uiSize) <= PMR_PhysicalSize(psPMR)),
+		                        CACHEOP_DEVMEM_OOR_ERROR_STRING,
+		                        PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE);
 
 		eError = PMRLockSysPhysAddresses(psPMR);
 		PVR_LOG_RETURN_IF_ERROR(eError, "PMRLockSysPhysAddresses");
diff --git a/drivers/gpu/drm/img-rogue/client_mm_bridge.h b/drivers/gpu/drm/img-rogue/client_mm_bridge.h
index 4f00526c8f3e..fe2494bc472e 100644
--- a/drivers/gpu/drm/img-rogue/client_mm_bridge.h
+++ b/drivers/gpu/drm/img-rogue/client_mm_bridge.h
@@ -85,8 +85,6 @@ IMG_INTERNAL PVRSRV_ERROR BridgePMRLocalImportPMR(IMG_HANDLE hBridge,
 
 IMG_INTERNAL PVRSRV_ERROR BridgePMRUnrefPMR(IMG_HANDLE hBridge, IMG_HANDLE hPMR);
 
-IMG_INTERNAL PVRSRV_ERROR BridgePMRUnrefUnlockPMR(IMG_HANDLE hBridge, IMG_HANDLE hPMR);
-
 IMG_INTERNAL PVRSRV_ERROR BridgePhysmemNewRamBackedPMR(IMG_HANDLE hBridge,
 						       IMG_DEVMEM_SIZE_T uiSize,
 						       IMG_UINT32 ui32NumPhysChunks,
@@ -114,25 +112,20 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntHeapCreate(IMG_HANDLE hBridge,
 						    IMG_HANDLE hDevmemCtx,
 						    IMG_UINT32 ui32HeapConfigIndex,
 						    IMG_UINT32 ui32HeapIndex,
-						    IMG_DEV_VIRTADDR sHeapBaseAddr,
-						    IMG_UINT32 ui32Log2DataPageSize,
 						    IMG_HANDLE * phDevmemHeapPtr);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntHeapDestroy(IMG_HANDLE hBridge, IMG_HANDLE hDevmemHeap);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntMapPMR(IMG_HANDLE hBridge,
-						IMG_HANDLE hDevmemServerHeap,
-						IMG_HANDLE hReservation,
-						IMG_HANDLE hPMR,
-						PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-						IMG_HANDLE * phMapping);
+						IMG_HANDLE hReservation, IMG_HANDLE hPMR);
 
-IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnmapPMR(IMG_HANDLE hBridge, IMG_HANDLE hMapping);
+IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnmapPMR(IMG_HANDLE hBridge, IMG_HANDLE hReservation);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRange(IMG_HANDLE hBridge,
 						      IMG_HANDLE hDevmemServerHeap,
 						      IMG_DEV_VIRTADDR sAddress,
 						      IMG_DEVMEM_SIZE_T uiLength,
+						      PVRSRV_MEMALLOCFLAGS_T uiFlags,
 						      IMG_HANDLE * phReservation);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRangeAndMapPMR(IMG_HANDLE hBridge,
@@ -140,26 +133,19 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRangeAndMapPMR(IMG_HANDLE hBridg
 							       IMG_DEV_VIRTADDR sAddress,
 							       IMG_DEVMEM_SIZE_T uiLength,
 							       IMG_HANDLE hPMR,
-							       PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-							       IMG_HANDLE * phMapping);
-
-IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnreserveRangeAndUnmapPMR(IMG_HANDLE hBridge,
-								   IMG_HANDLE hMapping);
+							       PVRSRV_MEMALLOCFLAGS_T uiFlags,
+							       IMG_HANDLE * phReservation);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnreserveRange(IMG_HANDLE hBridge,
 							IMG_HANDLE hReservation);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeChangeSparseMem(IMG_HANDLE hBridge,
-						IMG_HANDLE hSrvDevMemHeap,
-						IMG_HANDLE hPMR,
 						IMG_UINT32 ui32AllocPageCount,
 						IMG_UINT32 * pui32AllocPageIndices,
 						IMG_UINT32 ui32FreePageCount,
 						IMG_UINT32 * pui32FreePageIndices,
 						IMG_UINT32 ui32SparseFlags,
-						PVRSRV_MEMALLOCFLAGS_T uiFlags,
-						IMG_DEV_VIRTADDR sDevVAddr,
-						IMG_UINT64 ui64CPUVAddr);
+						IMG_HANDLE hReservation);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIsVDevAddrValid(IMG_HANDLE hBridge,
 						      IMG_HANDLE hDevmemCtx,
diff --git a/drivers/gpu/drm/img-rogue/client_mm_direct_bridge.c b/drivers/gpu/drm/img-rogue/client_mm_direct_bridge.c
index 184355b3abbf..a1d1bd895f5f 100644
--- a/drivers/gpu/drm/img-rogue/client_mm_direct_bridge.c
+++ b/drivers/gpu/drm/img-rogue/client_mm_direct_bridge.c
@@ -217,19 +217,6 @@ IMG_INTERNAL PVRSRV_ERROR BridgePMRUnrefPMR(IMG_HANDLE hBridge, IMG_HANDLE hPMR)
 	return eError;
 }
 
-IMG_INTERNAL PVRSRV_ERROR BridgePMRUnrefUnlockPMR(IMG_HANDLE hBridge, IMG_HANDLE hPMR)
-{
-	PVRSRV_ERROR eError;
-	PMR *psPMRInt;
-	PVR_UNREFERENCED_PARAMETER(hBridge);
-
-	psPMRInt = (PMR *) hPMR;
-
-	eError = PMRUnrefUnlockPMR(psPMRInt);
-
-	return eError;
-}
-
 IMG_INTERNAL PVRSRV_ERROR BridgePhysmemNewRamBackedPMR(IMG_HANDLE hBridge,
 						       IMG_DEVMEM_SIZE_T uiSize,
 						       IMG_UINT32 ui32NumPhysChunks,
@@ -301,8 +288,6 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntHeapCreate(IMG_HANDLE hBridge,
 						    IMG_HANDLE hDevmemCtx,
 						    IMG_UINT32 ui32HeapConfigIndex,
 						    IMG_UINT32 ui32HeapIndex,
-						    IMG_DEV_VIRTADDR sHeapBaseAddr,
-						    IMG_UINT32 ui32Log2DataPageSize,
 						    IMG_HANDLE * phDevmemHeapPtr)
 {
 	PVRSRV_ERROR eError;
@@ -314,9 +299,7 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntHeapCreate(IMG_HANDLE hBridge,
 
 	eError =
 	    DevmemIntHeapCreate(psDevmemCtxInt,
-				ui32HeapConfigIndex,
-				ui32HeapIndex,
-				sHeapBaseAddr, ui32Log2DataPageSize, &psDevmemHeapPtrInt);
+				ui32HeapConfigIndex, ui32HeapIndex, &psDevmemHeapPtrInt);
 
 	*phDevmemHeapPtr = psDevmemHeapPtrInt;
 	return eError;
@@ -336,40 +319,30 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntHeapDestroy(IMG_HANDLE hBridge, IMG_HAN
 }
 
 IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntMapPMR(IMG_HANDLE hBridge,
-						IMG_HANDLE hDevmemServerHeap,
-						IMG_HANDLE hReservation,
-						IMG_HANDLE hPMR,
-						PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-						IMG_HANDLE * phMapping)
+						IMG_HANDLE hReservation, IMG_HANDLE hPMR)
 {
 	PVRSRV_ERROR eError;
-	DEVMEMINT_HEAP *psDevmemServerHeapInt;
 	DEVMEMINT_RESERVATION *psReservationInt;
 	PMR *psPMRInt;
-	DEVMEMINT_MAPPING *psMappingInt = NULL;
 	PVR_UNREFERENCED_PARAMETER(hBridge);
 
-	psDevmemServerHeapInt = (DEVMEMINT_HEAP *) hDevmemServerHeap;
 	psReservationInt = (DEVMEMINT_RESERVATION *) hReservation;
 	psPMRInt = (PMR *) hPMR;
 
-	eError =
-	    DevmemIntMapPMR(psDevmemServerHeapInt,
-			    psReservationInt, psPMRInt, uiMapFlags, &psMappingInt);
+	eError = DevmemIntMapPMR(psReservationInt, psPMRInt);
 
-	*phMapping = psMappingInt;
 	return eError;
 }
 
-IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnmapPMR(IMG_HANDLE hBridge, IMG_HANDLE hMapping)
+IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnmapPMR(IMG_HANDLE hBridge, IMG_HANDLE hReservation)
 {
 	PVRSRV_ERROR eError;
-	DEVMEMINT_MAPPING *psMappingInt;
+	DEVMEMINT_RESERVATION *psReservationInt;
 	PVR_UNREFERENCED_PARAMETER(hBridge);
 
-	psMappingInt = (DEVMEMINT_MAPPING *) hMapping;
+	psReservationInt = (DEVMEMINT_RESERVATION *) hReservation;
 
-	eError = DevmemIntUnmapPMR(psMappingInt);
+	eError = DevmemIntUnmapPMR(psReservationInt);
 
 	return eError;
 }
@@ -378,6 +351,7 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRange(IMG_HANDLE hBridge,
 						      IMG_HANDLE hDevmemServerHeap,
 						      IMG_DEV_VIRTADDR sAddress,
 						      IMG_DEVMEM_SIZE_T uiLength,
+						      PVRSRV_MEMALLOCFLAGS_T uiFlags,
 						      IMG_HANDLE * phReservation)
 {
 	PVRSRV_ERROR eError;
@@ -388,7 +362,8 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRange(IMG_HANDLE hBridge,
 	psDevmemServerHeapInt = (DEVMEMINT_HEAP *) hDevmemServerHeap;
 
 	eError =
-	    DevmemIntReserveRange(psDevmemServerHeapInt, sAddress, uiLength, &psReservationInt);
+	    DevmemIntReserveRange(psDevmemServerHeapInt,
+				  sAddress, uiLength, uiFlags, &psReservationInt);
 
 	*phReservation = psReservationInt;
 	return eError;
@@ -399,13 +374,13 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRangeAndMapPMR(IMG_HANDLE hBridg
 							       IMG_DEV_VIRTADDR sAddress,
 							       IMG_DEVMEM_SIZE_T uiLength,
 							       IMG_HANDLE hPMR,
-							       PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-							       IMG_HANDLE * phMapping)
+							       PVRSRV_MEMALLOCFLAGS_T uiFlags,
+							       IMG_HANDLE * phReservation)
 {
 	PVRSRV_ERROR eError;
 	DEVMEMINT_HEAP *psDevmemServerHeapInt;
 	PMR *psPMRInt;
-	DEVMEMINT_MAPPING *psMappingInt = NULL;
+	DEVMEMINT_RESERVATION *psReservationInt = NULL;
 	PVR_UNREFERENCED_PARAMETER(hBridge);
 
 	psDevmemServerHeapInt = (DEVMEMINT_HEAP *) hDevmemServerHeap;
@@ -413,23 +388,10 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntReserveRangeAndMapPMR(IMG_HANDLE hBridg
 
 	eError =
 	    DevmemIntReserveRangeAndMapPMR(psDevmemServerHeapInt,
-					   sAddress, uiLength, psPMRInt, uiMapFlags, &psMappingInt);
-
-	*phMapping = psMappingInt;
-	return eError;
-}
-
-IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnreserveRangeAndUnmapPMR(IMG_HANDLE hBridge,
-								   IMG_HANDLE hMapping)
-{
-	PVRSRV_ERROR eError;
-	DEVMEMINT_MAPPING *psMappingInt;
-	PVR_UNREFERENCED_PARAMETER(hBridge);
-
-	psMappingInt = (DEVMEMINT_MAPPING *) hMapping;
-
-	eError = DevmemIntUnreserveRangeAndUnmapPMR(psMappingInt);
+					   sAddress,
+					   uiLength, psPMRInt, uiFlags, &psReservationInt);
 
+	*phReservation = psReservationInt;
 	return eError;
 }
 
@@ -447,32 +409,23 @@ IMG_INTERNAL PVRSRV_ERROR BridgeDevmemIntUnreserveRange(IMG_HANDLE hBridge, IMG_
 }
 
 IMG_INTERNAL PVRSRV_ERROR BridgeChangeSparseMem(IMG_HANDLE hBridge,
-						IMG_HANDLE hSrvDevMemHeap,
-						IMG_HANDLE hPMR,
 						IMG_UINT32 ui32AllocPageCount,
 						IMG_UINT32 * pui32AllocPageIndices,
 						IMG_UINT32 ui32FreePageCount,
 						IMG_UINT32 * pui32FreePageIndices,
-						IMG_UINT32 ui32SparseFlags,
-						PVRSRV_MEMALLOCFLAGS_T uiFlags,
-						IMG_DEV_VIRTADDR sDevVAddr, IMG_UINT64 ui64CPUVAddr)
+						IMG_UINT32 ui32SparseFlags, IMG_HANDLE hReservation)
 {
 	PVRSRV_ERROR eError;
-	DEVMEMINT_HEAP *psSrvDevMemHeapInt;
-	PMR *psPMRInt;
+	DEVMEMINT_RESERVATION *psReservationInt;
 	PVR_UNREFERENCED_PARAMETER(hBridge);
 
-	psSrvDevMemHeapInt = (DEVMEMINT_HEAP *) hSrvDevMemHeap;
-	psPMRInt = (PMR *) hPMR;
+	psReservationInt = (DEVMEMINT_RESERVATION *) hReservation;
 
 	eError =
-	    DevmemIntChangeSparse(psSrvDevMemHeapInt,
-				  psPMRInt,
-				  ui32AllocPageCount,
+	    DevmemIntChangeSparse(ui32AllocPageCount,
 				  pui32AllocPageIndices,
 				  ui32FreePageCount,
-				  pui32FreePageIndices,
-				  ui32SparseFlags, uiFlags, sDevVAddr, ui64CPUVAddr);
+				  pui32FreePageIndices, ui32SparseFlags, psReservationInt);
 
 	return eError;
 }
diff --git a/drivers/gpu/drm/img-rogue/client_ri_bridge.h b/drivers/gpu/drm/img-rogue/client_ri_bridge.h
index b3c42e6f496e..c419e21e9d07 100644
--- a/drivers/gpu/drm/img-rogue/client_ri_bridge.h
+++ b/drivers/gpu/drm/img-rogue/client_ri_bridge.h
@@ -62,8 +62,7 @@ IMG_INTERNAL PVRSRV_ERROR BridgeRIWriteMEMDESCEntry(IMG_HANDLE hBridge,
 						    const IMG_CHAR * puiTextB,
 						    IMG_UINT64 ui64Offset,
 						    IMG_UINT64 ui64Size,
-						    IMG_BOOL bIsImport,
-						    IMG_BOOL bIsSuballoc, IMG_HANDLE * phRIHandle);
+						    IMG_UINT64 ui64Flags, IMG_HANDLE * phRIHandle);
 
 IMG_INTERNAL PVRSRV_ERROR BridgeRIWriteProcListEntry(IMG_HANDLE hBridge,
 						     IMG_UINT32 ui32TextBSize,
diff --git a/drivers/gpu/drm/img-rogue/client_ri_direct_bridge.c b/drivers/gpu/drm/img-rogue/client_ri_direct_bridge.c
index 74eaf18e4aeb..6e60293d68e2 100644
--- a/drivers/gpu/drm/img-rogue/client_ri_direct_bridge.c
+++ b/drivers/gpu/drm/img-rogue/client_ri_direct_bridge.c
@@ -70,21 +70,19 @@ IMG_INTERNAL PVRSRV_ERROR BridgeRIWriteMEMDESCEntry(IMG_HANDLE hBridge,
 						    const IMG_CHAR * puiTextB,
 						    IMG_UINT64 ui64Offset,
 						    IMG_UINT64 ui64Size,
-						    IMG_BOOL bIsImport,
-						    IMG_BOOL bIsSuballoc, IMG_HANDLE * phRIHandle)
+						    IMG_UINT64 ui64Flags, IMG_HANDLE * phRIHandle)
 {
 	PVRSRV_ERROR eError;
 	PMR *psPMRHandleInt;
 	RI_HANDLE psRIHandleInt = NULL;
-	PVR_UNREFERENCED_PARAMETER(hBridge);
 
 	psPMRHandleInt = (PMR *) hPMRHandle;
 
 	eError =
-	    RIWriteMEMDESCEntryKM(psPMRHandleInt,
+	    RIWriteMEMDESCEntryKM(NULL, (PVRSRV_DEVICE_NODE *) ((void *)hBridge),
+				  psPMRHandleInt,
 				  ui32TextBSize,
-				  puiTextB,
-				  ui64Offset, ui64Size, bIsImport, bIsSuballoc, &psRIHandleInt);
+				  puiTextB, ui64Offset, ui64Size, ui64Flags, &psRIHandleInt);
 
 	*phRIHandle = psRIHandleInt;
 	return eError;
diff --git a/drivers/gpu/drm/img-rogue/common_dmabuf_bridge.h b/drivers/gpu/drm/img-rogue/common_dmabuf_bridge.h
index 7547d9f76297..cc631e3e1116 100644
--- a/drivers/gpu/drm/img-rogue/common_dmabuf_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_dmabuf_bridge.h
@@ -55,8 +55,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define PVRSRV_BRIDGE_DMABUF_CMD_FIRST			0
 #define PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUF			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+0
-#define PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUFLOCKED			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+1
-#define PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTDMABUF			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+2
+#define PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTDMABUF			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+1
+#define PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTGEMHANDLE			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+2
 #define PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTSPARSEDMABUF			PVRSRV_BRIDGE_DMABUF_CMD_FIRST+3
 #define PVRSRV_BRIDGE_DMABUF_CMD_LAST			(PVRSRV_BRIDGE_DMABUF_CMD_FIRST+3)
 
@@ -82,28 +82,6 @@ typedef struct PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUF_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUF;
 
-/*******************************************
-            PhysmemImportDmaBufLocked
- *******************************************/
-
-/* Bridge in structure for PhysmemImportDmaBufLocked */
-typedef struct PVRSRV_BRIDGE_IN_PHYSMEMIMPORTDMABUFLOCKED_TAG
-{
-	const IMG_CHAR *puiName;
-	IMG_INT ifd;
-	IMG_UINT32 ui32NameSize;
-	PVRSRV_MEMALLOCFLAGS_T uiFlags;
-} __packed PVRSRV_BRIDGE_IN_PHYSMEMIMPORTDMABUFLOCKED;
-
-/* Bridge out structure for PhysmemImportDmaBufLocked */
-typedef struct PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUFLOCKED_TAG
-{
-	IMG_DEVMEM_ALIGN_T uiAlign;
-	IMG_DEVMEM_SIZE_T uiSize;
-	IMG_HANDLE hPMRPtr;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUFLOCKED;
-
 /*******************************************
             PhysmemExportDmaBuf
  *******************************************/
@@ -121,6 +99,23 @@ typedef struct PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTDMABUF_TAG
 	IMG_INT iFd;
 } __packed PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTDMABUF;
 
+/*******************************************
+            PhysmemExportGemHandle
+ *******************************************/
+
+/* Bridge in structure for PhysmemExportGemHandle */
+typedef struct PVRSRV_BRIDGE_IN_PHYSMEMEXPORTGEMHANDLE_TAG
+{
+	IMG_HANDLE hPMR;
+} __packed PVRSRV_BRIDGE_IN_PHYSMEMEXPORTGEMHANDLE;
+
+/* Bridge out structure for PhysmemExportGemHandle */
+typedef struct PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTGEMHANDLE_TAG
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32Handle;
+} __packed PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTGEMHANDLE;
+
 /*******************************************
             PhysmemImportSparseDmaBuf
  *******************************************/
diff --git a/drivers/gpu/drm/img-rogue/common_mm_bridge.h b/drivers/gpu/drm/img-rogue/common_mm_bridge.h
index cf9f8834c48f..80fa1baeb390 100644
--- a/drivers/gpu/drm/img-rogue/common_mm_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_mm_bridge.h
@@ -64,36 +64,34 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVRSRV_BRIDGE_MM_PMRIMPORTPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+5
 #define PVRSRV_BRIDGE_MM_PMRLOCALIMPORTPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+6
 #define PVRSRV_BRIDGE_MM_PMRUNREFPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+7
-#define PVRSRV_BRIDGE_MM_PMRUNREFUNLOCKPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+8
-#define PVRSRV_BRIDGE_MM_PHYSMEMNEWRAMBACKEDPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+9
-#define PVRSRV_BRIDGE_MM_DEVMEMINTCTXCREATE			PVRSRV_BRIDGE_MM_CMD_FIRST+10
-#define PVRSRV_BRIDGE_MM_DEVMEMINTCTXDESTROY			PVRSRV_BRIDGE_MM_CMD_FIRST+11
-#define PVRSRV_BRIDGE_MM_DEVMEMINTHEAPCREATE			PVRSRV_BRIDGE_MM_CMD_FIRST+12
-#define PVRSRV_BRIDGE_MM_DEVMEMINTHEAPDESTROY			PVRSRV_BRIDGE_MM_CMD_FIRST+13
-#define PVRSRV_BRIDGE_MM_DEVMEMINTMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+14
-#define PVRSRV_BRIDGE_MM_DEVMEMINTUNMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+15
-#define PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+16
-#define PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGEANDMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+17
-#define PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGEANDUNMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+18
-#define PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+19
-#define PVRSRV_BRIDGE_MM_CHANGESPARSEMEM			PVRSRV_BRIDGE_MM_CMD_FIRST+20
-#define PVRSRV_BRIDGE_MM_DEVMEMISVDEVADDRVALID			PVRSRV_BRIDGE_MM_CMD_FIRST+21
-#define PVRSRV_BRIDGE_MM_DEVMEMINVALIDATEFBSCTABLE			PVRSRV_BRIDGE_MM_CMD_FIRST+22
-#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGCOUNT			PVRSRV_BRIDGE_MM_CMD_FIRST+23
-#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCOUNT			PVRSRV_BRIDGE_MM_CMD_FIRST+24
-#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGNAME			PVRSRV_BRIDGE_MM_CMD_FIRST+25
-#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPDETAILS			PVRSRV_BRIDGE_MM_CMD_FIRST+26
-#define PVRSRV_BRIDGE_MM_DEVMEMINTREGISTERPFNOTIFYKM			PVRSRV_BRIDGE_MM_CMD_FIRST+27
-#define PVRSRV_BRIDGE_MM_PHYSHEAPGETMEMINFO			PVRSRV_BRIDGE_MM_CMD_FIRST+28
-#define PVRSRV_BRIDGE_MM_GETDEFAULTPHYSICALHEAP			PVRSRV_BRIDGE_MM_CMD_FIRST+29
-#define PVRSRV_BRIDGE_MM_DEVMEMGETFAULTADDRESS			PVRSRV_BRIDGE_MM_CMD_FIRST+30
-#define PVRSRV_BRIDGE_MM_PVRSRVSTATSUPDATEOOMSTAT			PVRSRV_BRIDGE_MM_CMD_FIRST+31
-#define PVRSRV_BRIDGE_MM_DEVMEMXINTRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+32
-#define PVRSRV_BRIDGE_MM_DEVMEMXINTUNRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+33
-#define PVRSRV_BRIDGE_MM_DEVMEMXINTMAPPAGES			PVRSRV_BRIDGE_MM_CMD_FIRST+34
-#define PVRSRV_BRIDGE_MM_DEVMEMXINTUNMAPPAGES			PVRSRV_BRIDGE_MM_CMD_FIRST+35
-#define PVRSRV_BRIDGE_MM_DEVMEMXINTMAPVRANGETOBACKINGPAGE			PVRSRV_BRIDGE_MM_CMD_FIRST+36
-#define PVRSRV_BRIDGE_MM_CMD_LAST			(PVRSRV_BRIDGE_MM_CMD_FIRST+36)
+#define PVRSRV_BRIDGE_MM_PHYSMEMNEWRAMBACKEDPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+8
+#define PVRSRV_BRIDGE_MM_DEVMEMINTCTXCREATE			PVRSRV_BRIDGE_MM_CMD_FIRST+9
+#define PVRSRV_BRIDGE_MM_DEVMEMINTCTXDESTROY			PVRSRV_BRIDGE_MM_CMD_FIRST+10
+#define PVRSRV_BRIDGE_MM_DEVMEMINTHEAPCREATE			PVRSRV_BRIDGE_MM_CMD_FIRST+11
+#define PVRSRV_BRIDGE_MM_DEVMEMINTHEAPDESTROY			PVRSRV_BRIDGE_MM_CMD_FIRST+12
+#define PVRSRV_BRIDGE_MM_DEVMEMINTMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+13
+#define PVRSRV_BRIDGE_MM_DEVMEMINTUNMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+14
+#define PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+15
+#define PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGEANDMAPPMR			PVRSRV_BRIDGE_MM_CMD_FIRST+16
+#define PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+17
+#define PVRSRV_BRIDGE_MM_CHANGESPARSEMEM			PVRSRV_BRIDGE_MM_CMD_FIRST+18
+#define PVRSRV_BRIDGE_MM_DEVMEMISVDEVADDRVALID			PVRSRV_BRIDGE_MM_CMD_FIRST+19
+#define PVRSRV_BRIDGE_MM_DEVMEMINVALIDATEFBSCTABLE			PVRSRV_BRIDGE_MM_CMD_FIRST+20
+#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGCOUNT			PVRSRV_BRIDGE_MM_CMD_FIRST+21
+#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCOUNT			PVRSRV_BRIDGE_MM_CMD_FIRST+22
+#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGNAME			PVRSRV_BRIDGE_MM_CMD_FIRST+23
+#define PVRSRV_BRIDGE_MM_HEAPCFGHEAPDETAILS			PVRSRV_BRIDGE_MM_CMD_FIRST+24
+#define PVRSRV_BRIDGE_MM_DEVMEMINTREGISTERPFNOTIFYKM			PVRSRV_BRIDGE_MM_CMD_FIRST+25
+#define PVRSRV_BRIDGE_MM_PHYSHEAPGETMEMINFO			PVRSRV_BRIDGE_MM_CMD_FIRST+26
+#define PVRSRV_BRIDGE_MM_GETDEFAULTPHYSICALHEAP			PVRSRV_BRIDGE_MM_CMD_FIRST+27
+#define PVRSRV_BRIDGE_MM_DEVMEMGETFAULTADDRESS			PVRSRV_BRIDGE_MM_CMD_FIRST+28
+#define PVRSRV_BRIDGE_MM_PVRSRVSTATSUPDATEOOMSTAT			PVRSRV_BRIDGE_MM_CMD_FIRST+29
+#define PVRSRV_BRIDGE_MM_DEVMEMXINTRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+30
+#define PVRSRV_BRIDGE_MM_DEVMEMXINTUNRESERVERANGE			PVRSRV_BRIDGE_MM_CMD_FIRST+31
+#define PVRSRV_BRIDGE_MM_DEVMEMXINTMAPPAGES			PVRSRV_BRIDGE_MM_CMD_FIRST+32
+#define PVRSRV_BRIDGE_MM_DEVMEMXINTUNMAPPAGES			PVRSRV_BRIDGE_MM_CMD_FIRST+33
+#define PVRSRV_BRIDGE_MM_DEVMEMXINTMAPVRANGETOBACKINGPAGE			PVRSRV_BRIDGE_MM_CMD_FIRST+34
+#define PVRSRV_BRIDGE_MM_CMD_LAST			(PVRSRV_BRIDGE_MM_CMD_FIRST+34)
 
 /*******************************************
             PMRExportPMR
@@ -236,22 +234,6 @@ typedef struct PVRSRV_BRIDGE_OUT_PMRUNREFPMR_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_PMRUNREFPMR;
 
-/*******************************************
-            PMRUnrefUnlockPMR
- *******************************************/
-
-/* Bridge in structure for PMRUnrefUnlockPMR */
-typedef struct PVRSRV_BRIDGE_IN_PMRUNREFUNLOCKPMR_TAG
-{
-	IMG_HANDLE hPMR;
-} __packed PVRSRV_BRIDGE_IN_PMRUNREFUNLOCKPMR;
-
-/* Bridge out structure for PMRUnrefUnlockPMR */
-typedef struct PVRSRV_BRIDGE_OUT_PMRUNREFUNLOCKPMR_TAG
-{
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_PMRUNREFUNLOCKPMR;
-
 /*******************************************
             PhysmemNewRamBackedPMR
  *******************************************/
@@ -321,11 +303,9 @@ typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTCTXDESTROY_TAG
 /* Bridge in structure for DevmemIntHeapCreate */
 typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTHEAPCREATE_TAG
 {
-	IMG_DEV_VIRTADDR sHeapBaseAddr;
 	IMG_HANDLE hDevmemCtx;
 	IMG_UINT32 ui32HeapConfigIndex;
 	IMG_UINT32 ui32HeapIndex;
-	IMG_UINT32 ui32Log2DataPageSize;
 } __packed PVRSRV_BRIDGE_IN_DEVMEMINTHEAPCREATE;
 
 /* Bridge out structure for DevmemIntHeapCreate */
@@ -358,16 +338,13 @@ typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTHEAPDESTROY_TAG
 /* Bridge in structure for DevmemIntMapPMR */
 typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTMAPPMR_TAG
 {
-	IMG_HANDLE hDevmemServerHeap;
 	IMG_HANDLE hPMR;
 	IMG_HANDLE hReservation;
-	PVRSRV_MEMALLOCFLAGS_T uiMapFlags;
 } __packed PVRSRV_BRIDGE_IN_DEVMEMINTMAPPMR;
 
 /* Bridge out structure for DevmemIntMapPMR */
 typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR_TAG
 {
-	IMG_HANDLE hMapping;
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR;
 
@@ -378,7 +355,7 @@ typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR_TAG
 /* Bridge in structure for DevmemIntUnmapPMR */
 typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTUNMAPPMR_TAG
 {
-	IMG_HANDLE hMapping;
+	IMG_HANDLE hReservation;
 } __packed PVRSRV_BRIDGE_IN_DEVMEMINTUNMAPPMR;
 
 /* Bridge out structure for DevmemIntUnmapPMR */
@@ -397,6 +374,7 @@ typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGE_TAG
 	IMG_DEV_VIRTADDR sAddress;
 	IMG_DEVMEM_SIZE_T uiLength;
 	IMG_HANDLE hDevmemServerHeap;
+	PVRSRV_MEMALLOCFLAGS_T uiFlags;
 } __packed PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGE;
 
 /* Bridge out structure for DevmemIntReserveRange */
@@ -417,32 +395,16 @@ typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGEANDMAPPMR_TAG
 	IMG_DEVMEM_SIZE_T uiLength;
 	IMG_HANDLE hDevmemServerHeap;
 	IMG_HANDLE hPMR;
-	PVRSRV_MEMALLOCFLAGS_T uiMapFlags;
+	PVRSRV_MEMALLOCFLAGS_T uiFlags;
 } __packed PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGEANDMAPPMR;
 
 /* Bridge out structure for DevmemIntReserveRangeAndMapPMR */
 typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTRESERVERANGEANDMAPPMR_TAG
 {
-	IMG_HANDLE hMapping;
+	IMG_HANDLE hReservation;
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_DEVMEMINTRESERVERANGEANDMAPPMR;
 
-/*******************************************
-            DevmemIntUnreserveRangeAndUnmapPMR
- *******************************************/
-
-/* Bridge in structure for DevmemIntUnreserveRangeAndUnmapPMR */
-typedef struct PVRSRV_BRIDGE_IN_DEVMEMINTUNRESERVERANGEANDUNMAPPMR_TAG
-{
-	IMG_HANDLE hMapping;
-} __packed PVRSRV_BRIDGE_IN_DEVMEMINTUNRESERVERANGEANDUNMAPPMR;
-
-/* Bridge out structure for DevmemIntUnreserveRangeAndUnmapPMR */
-typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGEANDUNMAPPMR_TAG
-{
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGEANDUNMAPPMR;
-
 /*******************************************
             DevmemIntUnreserveRange
  *******************************************/
@@ -466,16 +428,12 @@ typedef struct PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGE_TAG
 /* Bridge in structure for ChangeSparseMem */
 typedef struct PVRSRV_BRIDGE_IN_CHANGESPARSEMEM_TAG
 {
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_UINT64 ui64CPUVAddr;
-	IMG_HANDLE hPMR;
-	IMG_HANDLE hSrvDevMemHeap;
+	IMG_HANDLE hReservation;
 	IMG_UINT32 *pui32AllocPageIndices;
 	IMG_UINT32 *pui32FreePageIndices;
 	IMG_UINT32 ui32AllocPageCount;
 	IMG_UINT32 ui32FreePageCount;
 	IMG_UINT32 ui32SparseFlags;
-	PVRSRV_MEMALLOCFLAGS_T uiFlags;
 } __packed PVRSRV_BRIDGE_IN_CHANGESPARSEMEM;
 
 /* Bridge out structure for ChangeSparseMem */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxcmp_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxcmp_bridge.h
index 7f5687d826d5..aa1d2b73985a 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxcmp_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxcmp_bridge.h
@@ -58,13 +58,16 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVRSRV_BRIDGE_RGXCMP_RGXCREATECOMPUTECONTEXT			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+0
 #define PVRSRV_BRIDGE_RGXCMP_RGXDESTROYCOMPUTECONTEXT			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+1
 #define PVRSRV_BRIDGE_RGXCMP_RGXFLUSHCOMPUTEDATA			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+2
-#define PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPRIORITY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+3
-#define PVRSRV_BRIDGE_RGXCMP_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+4
-#define PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM2			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+5
+#define PVRSRV_BRIDGE_RGXCMP_RGXSENDCANCELCMD			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+3
+#define PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPRIORITY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+4
+#define PVRSRV_BRIDGE_RGXCMP_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+5
 #define PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPROPERTY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+6
 #define PVRSRV_BRIDGE_RGXCMP_RGXGETLASTDEVICEERROR			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+7
 #define PVRSRV_BRIDGE_RGXCMP_RGXKICKTIMESTAMPQUERY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+8
-#define PVRSRV_BRIDGE_RGXCMP_CMD_LAST			(PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+8)
+#define PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+9
+#define PVRSRV_BRIDGE_RGXCMP_RGXCDMGETSHAREDMEMORY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+10
+#define PVRSRV_BRIDGE_RGXCMP_RGXCDMRELEASESHAREDMEMORY			PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+11
+#define PVRSRV_BRIDGE_RGXCMP_CMD_LAST			(PVRSRV_BRIDGE_RGXCMP_CMD_FIRST+11)
 
 /*******************************************
             RGXCreateComputeContext
@@ -124,6 +127,24 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFLUSHCOMPUTEDATA_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXFLUSHCOMPUTEDATA;
 
+/*******************************************
+            RGXSendCancelCmd
+ *******************************************/
+
+/* Bridge in structure for RGXSendCancelCmd */
+typedef struct PVRSRV_BRIDGE_IN_RGXSENDCANCELCMD_TAG
+{
+	IMG_HANDLE hComputeContext;
+	IMG_INT32 i32FirstIntJobRefToCancel;
+	IMG_INT32 i32LastIntJobRefToCancel;
+} __packed PVRSRV_BRIDGE_IN_RGXSENDCANCELCMD;
+
+/* Bridge out structure for RGXSendCancelCmd */
+typedef struct PVRSRV_BRIDGE_OUT_RGXSENDCANCELCMD_TAG
+{
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXSENDCANCELCMD;
+
 /*******************************************
             RGXSetComputeContextPriority
  *******************************************/
@@ -157,40 +178,6 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE;
 
-/*******************************************
-            RGXKickCDM2
- *******************************************/
-
-/* Bridge in structure for RGXKickCDM2 */
-typedef struct PVRSRV_BRIDGE_IN_RGXKICKCDM2_TAG
-{
-	IMG_UINT64 ui64DeadlineInus;
-	IMG_HANDLE hComputeContext;
-	IMG_UINT32 *pui32ClientUpdateOffset;
-	IMG_UINT32 *pui32ClientUpdateValue;
-	IMG_UINT32 *pui32SyncPMRFlags;
-	IMG_BYTE *pui8DMCmd;
-	IMG_CHAR *puiUpdateFenceName;
-	IMG_HANDLE *phClientUpdateUFOSyncPrimBlock;
-	IMG_HANDLE *phSyncPMRs;
-	PVRSRV_FENCE hCheckFenceFd;
-	PVRSRV_TIMELINE hUpdateTimeline;
-	IMG_UINT32 ui32ClientUpdateCount;
-	IMG_UINT32 ui32CmdSize;
-	IMG_UINT32 ui32ExtJobRef;
-	IMG_UINT32 ui32NumOfWorkgroups;
-	IMG_UINT32 ui32NumOfWorkitems;
-	IMG_UINT32 ui32PDumpFlags;
-	IMG_UINT32 ui32SyncPMRCount;
-} __packed PVRSRV_BRIDGE_IN_RGXKICKCDM2;
-
-/* Bridge out structure for RGXKickCDM2 */
-typedef struct PVRSRV_BRIDGE_OUT_RGXKICKCDM2_TAG
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_FENCE hUpdateFence;
-} __packed PVRSRV_BRIDGE_OUT_RGXKICKCDM2;
-
 /*******************************************
             RGXSetComputeContextProperty
  *******************************************/
@@ -236,7 +223,9 @@ typedef struct PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY_TAG
 {
 	IMG_HANDLE hComputeContext;
 	IMG_BYTE *pui8DMCmd;
+	IMG_CHAR *puiUpdateFenceName;
 	PVRSRV_FENCE hCheckFenceFd;
+	PVRSRV_TIMELINE hUpdateTimeline;
 	IMG_UINT32 ui32CmdSize;
 	IMG_UINT32 ui32ExtJobRef;
 } __packed PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY;
@@ -245,6 +234,76 @@ typedef struct PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY_TAG
 typedef struct PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY_TAG
 {
 	PVRSRV_ERROR eError;
+	PVRSRV_FENCE hUpdateFence;
 } __packed PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY;
 
+/*******************************************
+            RGXKickCDM
+ *******************************************/
+
+/* Bridge in structure for RGXKickCDM */
+typedef struct PVRSRV_BRIDGE_IN_RGXKICKCDM_TAG
+{
+	IMG_UINT64 ui64DeadlineInus;
+	IMG_HANDLE hComputeContext;
+	IMG_UINT32 *pui32ClientUpdateOffset;
+	IMG_UINT32 *pui32ClientUpdateValue;
+	IMG_UINT32 *pui32SyncPMRFlags;
+	IMG_BYTE *pui8DMCmd;
+	IMG_CHAR *puiUpdateFenceName;
+	IMG_HANDLE *phClientUpdateUFOSyncPrimBlock;
+	IMG_HANDLE *phSyncPMRs;
+	PVRSRV_FENCE hCheckFenceFd;
+	PVRSRV_FENCE hExportFenceToSignal;
+	PVRSRV_TIMELINE hUpdateTimeline;
+	IMG_UINT32 ui32ClientUpdateCount;
+	IMG_UINT32 ui32CmdSize;
+	IMG_UINT32 ui32ExtJobRef;
+	IMG_UINT32 ui32NumOfWorkgroups;
+	IMG_UINT32 ui32NumOfWorkitems;
+	IMG_UINT32 ui32PDumpFlags;
+	IMG_UINT32 ui32SyncPMRCount;
+} __packed PVRSRV_BRIDGE_IN_RGXKICKCDM;
+
+/* Bridge out structure for RGXKickCDM */
+typedef struct PVRSRV_BRIDGE_OUT_RGXKICKCDM_TAG
+{
+	PVRSRV_ERROR eError;
+	PVRSRV_FENCE hUpdateFence;
+	IMG_UINT32 ui32IntJobRef;
+} __packed PVRSRV_BRIDGE_OUT_RGXKICKCDM;
+
+/*******************************************
+            RGXCDMGetSharedMemory
+ *******************************************/
+
+/* Bridge in structure for RGXCDMGetSharedMemory */
+typedef struct PVRSRV_BRIDGE_IN_RGXCDMGETSHAREDMEMORY_TAG
+{
+	IMG_UINT32 ui32EmptyStructPlaceholder;
+} __packed PVRSRV_BRIDGE_IN_RGXCDMGETSHAREDMEMORY;
+
+/* Bridge out structure for RGXCDMGetSharedMemory */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCDMGETSHAREDMEMORY_TAG
+{
+	IMG_HANDLE hCLIPMRMem;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCDMGETSHAREDMEMORY;
+
+/*******************************************
+            RGXCDMReleaseSharedMemory
+ *******************************************/
+
+/* Bridge in structure for RGXCDMReleaseSharedMemory */
+typedef struct PVRSRV_BRIDGE_IN_RGXCDMRELEASESHAREDMEMORY_TAG
+{
+	IMG_HANDLE hPMRMem;
+} __packed PVRSRV_BRIDGE_IN_RGXCDMRELEASESHAREDMEMORY;
+
+/* Bridge out structure for RGXCDMReleaseSharedMemory */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCDMRELEASESHAREDMEMORY_TAG
+{
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCDMRELEASESHAREDMEMORY;
+
 #endif /* COMMON_RGXCMP_BRIDGE_H */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxfwdbg_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxfwdbg_bridge.h
index a92ae9bfdb8d..534b8e9536ed 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxfwdbg_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxfwdbg_bridge.h
@@ -58,8 +58,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST			0
 #define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETFWLOG			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+0
 #define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGDUMPFREELISTPAGELIST			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+1
-#define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSUSPENDDEVICE			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+2
-#define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGRESUMEDEVICE			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+3
+#define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWEROFF			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+2
+#define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWERON			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+3
 #define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+4
 #define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETHCSDEADLINE			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+5
 #define PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETDRIVERPRIORITY			PVRSRV_BRIDGE_RGXFWDBG_CMD_FIRST+6
@@ -107,36 +107,36 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGDUMPFREELISTPAGELIST_TAG
 } __packed PVRSRV_BRIDGE_OUT_RGXFWDEBUGDUMPFREELISTPAGELIST;
 
 /*******************************************
-            RGXFWDebugSuspendDevice
+            RGXFWDebugPowerOff
  *******************************************/
 
-/* Bridge in structure for RGXFWDebugSuspendDevice */
-typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGSUSPENDDEVICE_TAG
+/* Bridge in structure for RGXFWDebugPowerOff */
+typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWEROFF_TAG
 {
 	IMG_UINT32 ui32EmptyStructPlaceholder;
-} __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGSUSPENDDEVICE;
+} __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWEROFF;
 
-/* Bridge out structure for RGXFWDebugSuspendDevice */
-typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGSUSPENDDEVICE_TAG
+/* Bridge out structure for RGXFWDebugPowerOff */
+typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWEROFF_TAG
 {
 	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXFWDEBUGSUSPENDDEVICE;
+} __packed PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWEROFF;
 
 /*******************************************
-            RGXFWDebugResumeDevice
+            RGXFWDebugPowerOn
  *******************************************/
 
-/* Bridge in structure for RGXFWDebugResumeDevice */
-typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGRESUMEDEVICE_TAG
+/* Bridge in structure for RGXFWDebugPowerOn */
+typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWERON_TAG
 {
 	IMG_UINT32 ui32EmptyStructPlaceholder;
-} __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGRESUMEDEVICE;
+} __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWERON;
 
-/* Bridge out structure for RGXFWDebugResumeDevice */
-typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGRESUMEDEVICE_TAG
+/* Bridge out structure for RGXFWDebugPowerOn */
+typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWERON_TAG
 {
 	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXFWDEBUGRESUMEDEVICE;
+} __packed PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWERON;
 
 /*******************************************
             RGXFWDebugSetVzConnectionCooldownPeriodInSec
@@ -145,7 +145,7 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGRESUMEDEVICE_TAG
 /* Bridge in structure for RGXFWDebugSetVzConnectionCooldownPeriodInSec */
 typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC_TAG
 {
-	IMG_UINT32 ui32ui32VzConnectionCooldownPeriodInSec;
+	IMG_UINT32 ui32VzConne;
 } __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC;
 
 /* Bridge out structure for RGXFWDebugSetVzConnectionCooldownPeriodInSec */
@@ -195,7 +195,7 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERPRIORITY_TAG
 typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICE_TAG
 {
 	IMG_UINT32 ui32DriverID;
-	IMG_UINT32 ui32TimeSlice;
+	IMG_UINT32 ui32TSPercentage;
 } __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICE;
 
 /* Bridge out structure for RGXFWDebugSetDriverTimeSlice */
@@ -211,7 +211,7 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERTIMESLICE_TAG
 /* Bridge in structure for RGXFWDebugSetDriverTimeSliceInterval */
 typedef struct PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICEINTERVAL_TAG
 {
-	IMG_UINT32 ui32TimeSliceInterval;
+	IMG_UINT32 ui32TSIntervalMs;
 } __packed PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICEINTERVAL;
 
 /* Bridge out structure for RGXFWDebugSetDriverTimeSliceInterval */
@@ -310,7 +310,7 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXFWDEBUGWDGCONFIGURE_TAG
 /* Bridge in structure for RGXCurrentTime */
 typedef struct PVRSRV_BRIDGE_IN_RGXCURRENTTIME_TAG
 {
-	IMG_UINT32 ui32EmptyStructPlaceholder;
+	IMG_UINT8 ui8TimerType;
 } __packed PVRSRV_BRIDGE_IN_RGXCURRENTTIME;
 
 /* Bridge out structure for RGXCurrentTime */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxhwperf_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxhwperf_bridge.h
index 609429400ae2..4d86216c8197 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxhwperf_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxhwperf_bridge.h
@@ -55,18 +55,72 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgx_hwperf.h"
 
 #define PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST			0
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+0
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+1
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+2
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+3
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+4
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+5
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+6
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+7
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+8
-#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+9
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+0
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+1
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+2
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+3
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+4
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+5
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+6
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+7
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+8
+#define PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS			PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+9
 #define PVRSRV_BRIDGE_RGXHWPERF_CMD_LAST			(PVRSRV_BRIDGE_RGXHWPERF_CMD_FIRST+9)
 
+/*******************************************
+            RGXGetConfiguredHWPerfCounters
+ *******************************************/
+
+/* Bridge in structure for RGXGetConfiguredHWPerfCounters */
+typedef struct PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS_TAG
+{
+	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCounters;
+	IMG_UINT32 ui32BlockID;
+} __packed PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS;
+
+/* Bridge out structure for RGXGetConfiguredHWPerfCounters */
+typedef struct PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS_TAG
+{
+	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCounters;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS;
+
+/*******************************************
+            RGXGetEnabledHWPerfBlocks
+ *******************************************/
+
+/* Bridge in structure for RGXGetEnabledHWPerfBlocks */
+typedef struct PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS_TAG
+{
+	IMG_UINT32 *pui32EnabledBlockIDs;
+	IMG_UINT32 ui32ArrayLen;
+} __packed PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS;
+
+/* Bridge out structure for RGXGetEnabledHWPerfBlocks */
+typedef struct PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS_TAG
+{
+	IMG_UINT32 *pui32EnabledBlockIDs;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32BlockCount;
+} __packed PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS;
+
+/*******************************************
+            RGXGetHWPerfTimeStamp
+ *******************************************/
+
+/* Bridge in structure for RGXGetHWPerfTimeStamp */
+typedef struct PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP_TAG
+{
+	IMG_UINT32 ui32EmptyStructPlaceholder;
+} __packed PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP;
+
+/* Bridge out structure for RGXGetHWPerfTimeStamp */
+typedef struct PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP_TAG
+{
+	IMG_UINT64 ui64TimeStamp;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP;
+
 /*******************************************
             RGXCtrlHWPerf
  *******************************************/
@@ -102,23 +156,6 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS;
 
-/*******************************************
-            RGXConfigMuxHWPerfCounters
- *******************************************/
-
-/* Bridge in structure for RGXConfigMuxHWPerfCounters */
-typedef struct PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS_TAG
-{
-	RGX_HWPERF_CONFIG_MUX_CNTBLK *psBlockConfigs;
-	IMG_UINT32 ui32ArrayLen;
-} __packed PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS;
-
-/* Bridge out structure for RGXConfigMuxHWPerfCounters */
-typedef struct PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS_TAG
-{
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS;
-
 /*******************************************
             RGXControlHWPerfBlocks
  *******************************************/
@@ -137,6 +174,23 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS;
 
+/*******************************************
+            RGXConfigMuxHWPerfCounters
+ *******************************************/
+
+/* Bridge in structure for RGXConfigMuxHWPerfCounters */
+typedef struct PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS_TAG
+{
+	RGX_HWPERF_CONFIG_MUX_CNTBLK *psBlockConfigs;
+	IMG_UINT32 ui32ArrayLen;
+} __packed PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS;
+
+/* Bridge out structure for RGXConfigMuxHWPerfCounters */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS_TAG
+{
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS;
+
 /*******************************************
             RGXConfigCustomCounters
  *******************************************/
@@ -191,58 +245,4 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS;
 
-/*******************************************
-            RGXGetConfiguredHWPerfCounters
- *******************************************/
-
-/* Bridge in structure for RGXGetConfiguredHWPerfCounters */
-typedef struct PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS_TAG
-{
-	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCounters;
-	IMG_UINT32 ui32BlockID;
-} __packed PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS;
-
-/* Bridge out structure for RGXGetConfiguredHWPerfCounters */
-typedef struct PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS_TAG
-{
-	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCounters;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS;
-
-/*******************************************
-            RGXGetEnabledHWPerfBlocks
- *******************************************/
-
-/* Bridge in structure for RGXGetEnabledHWPerfBlocks */
-typedef struct PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS_TAG
-{
-	IMG_UINT32 *pui32EnabledBlockIDs;
-	IMG_UINT32 ui32ArrayLen;
-} __packed PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS;
-
-/* Bridge out structure for RGXGetEnabledHWPerfBlocks */
-typedef struct PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS_TAG
-{
-	IMG_UINT32 *pui32EnabledBlockIDs;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 ui32BlockCount;
-} __packed PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS;
-
-/*******************************************
-            RGXGetHWPerfTimeStamp
- *******************************************/
-
-/* Bridge in structure for RGXGetHWPerfTimeStamp */
-typedef struct PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP_TAG
-{
-	IMG_UINT32 ui32EmptyStructPlaceholder;
-} __packed PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP;
-
-/* Bridge out structure for RGXGetHWPerfTimeStamp */
-typedef struct PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP_TAG
-{
-	IMG_UINT64 ui64TimeStamp;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP;
-
 #endif /* COMMON_RGXHWPERF_BRIDGE_H */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxta3d_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxta3d_bridge.h
index 7974b6735280..849d18cc78a8 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxta3d_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxta3d_bridge.h
@@ -57,66 +57,23 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_sync_km.h"
 
 #define PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST			0
-#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+0
-#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYHWRTDATASET			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+1
-#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+2
-#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+3
-#define PVRSRV_BRIDGE_RGXTA3D_RGXPOPULATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+4
-#define PVRSRV_BRIDGE_RGXTA3D_RGXUNPOPULATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+5
-#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+6
-#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYFREELIST			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+7
-#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+8
-#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYRENDERCONTEXT			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+9
-#define PVRSRV_BRIDGE_RGXTA3D_RGXSENDZSSTOREDISABLE			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+10
-#define PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPRIORITY			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+11
-#define PVRSRV_BRIDGE_RGXTA3D_RGXRENDERCONTEXTSTALLED			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+12
-#define PVRSRV_BRIDGE_RGXTA3D_RGXKICKTA3D2			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+13
-#define PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPROPERTY			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+14
+#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYHWRTDATASET			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+0
+#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+1
+#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+2
+#define PVRSRV_BRIDGE_RGXTA3D_RGXPOPULATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+3
+#define PVRSRV_BRIDGE_RGXTA3D_RGXUNPOPULATEZSBUFFER			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+4
+#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYFREELIST			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+5
+#define PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYRENDERCONTEXT			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+6
+#define PVRSRV_BRIDGE_RGXTA3D_RGXSENDZSSTOREDISABLE			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+7
+#define PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPRIORITY			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+8
+#define PVRSRV_BRIDGE_RGXTA3D_RGXRENDERCONTEXTSTALLED			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+9
+#define PVRSRV_BRIDGE_RGXTA3D_RGXKICKTA3D2			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+10
+#define PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPROPERTY			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+11
+#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+12
+#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+13
+#define PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT			PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+14
 #define PVRSRV_BRIDGE_RGXTA3D_CMD_LAST			(PVRSRV_BRIDGE_RGXTA3D_CMD_FIRST+14)
 
-/*******************************************
-            RGXCreateHWRTDataSet
- *******************************************/
-
-/* Bridge in structure for RGXCreateHWRTDataSet */
-typedef struct PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET_TAG
-{
-	IMG_UINT64 ui64FlippedMultiSampleCtl;
-	IMG_UINT64 ui64MultiSampleCtl;
-	IMG_DEV_VIRTADDR *psMacrotileArrayDevVAddr;
-	IMG_DEV_VIRTADDR *psPMMlistDevVAddr;
-	IMG_DEV_VIRTADDR *psRTCDevVAddr;
-	IMG_DEV_VIRTADDR *psRgnHeaderDevVAddr;
-	IMG_DEV_VIRTADDR *psTailPtrsDevVAddr;
-	IMG_DEV_VIRTADDR *psVHeapTableDevVAddr;
-	IMG_HANDLE *phKmHwRTDataSet;
-	IMG_HANDLE *phapsFreeLists;
-	IMG_UINT32 ui32ISPMergeLowerX;
-	IMG_UINT32 ui32ISPMergeLowerY;
-	IMG_UINT32 ui32ISPMergeScaleX;
-	IMG_UINT32 ui32ISPMergeScaleY;
-	IMG_UINT32 ui32ISPMergeUpperX;
-	IMG_UINT32 ui32ISPMergeUpperY;
-	IMG_UINT32 ui32ISPMtileSize;
-	IMG_UINT32 ui32MTileStride;
-	IMG_UINT32 ui32PPPScreen;
-	IMG_UINT32 ui32RgnHeaderSize;
-	IMG_UINT32 ui32TEAA;
-	IMG_UINT32 ui32TEMTILE1;
-	IMG_UINT32 ui32TEMTILE2;
-	IMG_UINT32 ui32TEScreen;
-	IMG_UINT32 ui32TPCSize;
-	IMG_UINT32 ui32TPCStride;
-	IMG_UINT16 ui16MaxRTs;
-} __packed PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET;
-
-/* Bridge out structure for RGXCreateHWRTDataSet */
-typedef struct PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET_TAG
-{
-	IMG_HANDLE *phKmHwRTDataSet;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET;
-
 /*******************************************
             RGXDestroyHWRTDataSet
  *******************************************/
@@ -201,32 +158,6 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER;
 
-/*******************************************
-            RGXCreateFreeList
- *******************************************/
-
-/* Bridge in structure for RGXCreateFreeList */
-typedef struct PVRSRV_BRIDGE_IN_RGXCREATEFREELIST_TAG
-{
-	IMG_DEV_VIRTADDR spsFreeListDevVAddr;
-	IMG_DEVMEM_OFFSET_T uiPMROffset;
-	IMG_HANDLE hMemCtxPrivData;
-	IMG_HANDLE hsFreeListPMR;
-	IMG_HANDLE hsGlobalFreeList;
-	IMG_UINT32 ui32GrowFLPages;
-	IMG_UINT32 ui32GrowParamThreshold;
-	IMG_UINT32 ui32InitFLPages;
-	IMG_UINT32 ui32MaxFLPages;
-	IMG_BOOL bbFreeListCheck;
-} __packed PVRSRV_BRIDGE_IN_RGXCREATEFREELIST;
-
-/* Bridge out structure for RGXCreateFreeList */
-typedef struct PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST_TAG
-{
-	IMG_HANDLE hCleanupCookie;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST;
-
 /*******************************************
             RGXDestroyFreeList
  *******************************************/
@@ -243,35 +174,6 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST;
 
-/*******************************************
-            RGXCreateRenderContext
- *******************************************/
-
-/* Bridge in structure for RGXCreateRenderContext */
-typedef struct PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT_TAG
-{
-	IMG_DEV_VIRTADDR sVDMCallStackAddr;
-	IMG_UINT64 ui64RobustnessAddress;
-	IMG_HANDLE hPrivData;
-	IMG_BYTE *pui8FrameworkCmd;
-	IMG_BYTE *pui8StaticRenderContextState;
-	IMG_INT32 i32Priority;
-	IMG_UINT32 ui32ContextFlags;
-	IMG_UINT32 ui32FrameworkCmdSize;
-	IMG_UINT32 ui32Max3DDeadlineMS;
-	IMG_UINT32 ui32MaxTADeadlineMS;
-	IMG_UINT32 ui32PackedCCBSizeU8888;
-	IMG_UINT32 ui32StaticRenderContextStateSize;
-	IMG_UINT32 ui32ui32CallStackDepth;
-} __packed PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT;
-
-/* Bridge out structure for RGXCreateRenderContext */
-typedef struct PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT_TAG
-{
-	IMG_HANDLE hRenderContext;
-	PVRSRV_ERROR eError;
-} __packed PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT;
-
 /*******************************************
             RGXDestroyRenderContext
  *******************************************/
@@ -421,4 +323,100 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY;
 
+/*******************************************
+            RGXCreateHWRTDataSet
+ *******************************************/
+
+/* Bridge in structure for RGXCreateHWRTDataSet */
+typedef struct PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET_TAG
+{
+	IMG_UINT64 ui64FlippedMultiSampleCtl;
+	IMG_UINT64 ui64MultiSampleCtl;
+	IMG_DEV_VIRTADDR *psMacrotileArrayDevVAddr;
+	IMG_DEV_VIRTADDR *psPMMlistDevVAddr;
+	IMG_DEV_VIRTADDR *psRTCDevVAddr;
+	IMG_DEV_VIRTADDR *psRgnHeaderDevVAddr;
+	IMG_DEV_VIRTADDR *psTailPtrsDevVAddr;
+	IMG_DEV_VIRTADDR *psVHeapTableDevVAddr;
+	IMG_HANDLE *phKmHwRTDataSet;
+	IMG_HANDLE *phapsFreeLists;
+	IMG_UINT32 ui32ISPMergeLowerX;
+	IMG_UINT32 ui32ISPMergeLowerY;
+	IMG_UINT32 ui32ISPMergeScaleX;
+	IMG_UINT32 ui32ISPMergeScaleY;
+	IMG_UINT32 ui32ISPMergeUpperX;
+	IMG_UINT32 ui32ISPMergeUpperY;
+	IMG_UINT32 ui32ISPMtileSize;
+	IMG_UINT32 ui32MTileStride;
+	IMG_UINT32 ui32PPPScreen;
+	IMG_UINT32 ui32RgnHeaderSize;
+	IMG_UINT32 ui32TEAA;
+	IMG_UINT32 ui32TEMTILE1;
+	IMG_UINT32 ui32TEMTILE2;
+	IMG_UINT32 ui32TEScreen;
+	IMG_UINT32 ui32TPCSize;
+	IMG_UINT32 ui32TPCStride;
+	IMG_UINT16 ui16MaxRTs;
+} __packed PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET;
+
+/* Bridge out structure for RGXCreateHWRTDataSet */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET_TAG
+{
+	IMG_HANDLE *phKmHwRTDataSet;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET;
+
+/*******************************************
+            RGXCreateFreeList
+ *******************************************/
+
+/* Bridge in structure for RGXCreateFreeList */
+typedef struct PVRSRV_BRIDGE_IN_RGXCREATEFREELIST_TAG
+{
+	IMG_HANDLE hFreeListReservation;
+	IMG_HANDLE hMemCtxPrivData;
+	IMG_HANDLE hsGlobalFreeList;
+	IMG_UINT32 ui32GrowFLPages;
+	IMG_UINT32 ui32GrowParamThreshold;
+	IMG_UINT32 ui32InitFLPages;
+	IMG_UINT32 ui32MaxFLPages;
+	IMG_BOOL bbFreeListCheck;
+} __packed PVRSRV_BRIDGE_IN_RGXCREATEFREELIST;
+
+/* Bridge out structure for RGXCreateFreeList */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST_TAG
+{
+	IMG_HANDLE hCleanupCookie;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST;
+
+/*******************************************
+            RGXCreateRenderContext
+ *******************************************/
+
+/* Bridge in structure for RGXCreateRenderContext */
+typedef struct PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT_TAG
+{
+	IMG_DEV_VIRTADDR sVDMCallStackAddr;
+	IMG_UINT64 ui64RobustnessAddress;
+	IMG_HANDLE hPrivData;
+	IMG_BYTE *pui8FrameworkCmd;
+	IMG_BYTE *pui8StaticRenderContextState;
+	IMG_INT32 i32Priority;
+	IMG_UINT32 ui32ContextFlags;
+	IMG_UINT32 ui32FrameworkCmdSize;
+	IMG_UINT32 ui32Max3DDeadlineMS;
+	IMG_UINT32 ui32MaxTADeadlineMS;
+	IMG_UINT32 ui32PackedCCBSizeU8888;
+	IMG_UINT32 ui32StaticRenderContextStateSize;
+	IMG_UINT32 ui32ui32CallStackDepth;
+} __packed PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT;
+
+/* Bridge out structure for RGXCreateRenderContext */
+typedef struct PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT_TAG
+{
+	IMG_HANDLE hRenderContext;
+	PVRSRV_ERROR eError;
+} __packed PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT;
+
 #endif /* COMMON_RGXTA3D_BRIDGE_H */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxtq2_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxtq2_bridge.h
index 9d8397fc90bf..f20fca015dc0 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxtq2_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxtq2_bridge.h
@@ -63,7 +63,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVRSRV_BRIDGE_RGXTQ2_RGXTDMGETSHAREDMEMORY			PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+5
 #define PVRSRV_BRIDGE_RGXTQ2_RGXTDMRELEASESHAREDMEMORY			PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+6
 #define PVRSRV_BRIDGE_RGXTQ2_RGXTDMSETTRANSFERCONTEXTPROPERTY			PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+7
-#define PVRSRV_BRIDGE_RGXTQ2_CMD_LAST			(PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+7)
+#define PVRSRV_BRIDGE_RGXTQ2_RGXTDMSUBMITTRANSFER3			PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+8
+#define PVRSRV_BRIDGE_RGXTQ2_CMD_LAST			(PVRSRV_BRIDGE_RGXTQ2_CMD_FIRST+8)
 
 /*******************************************
             RGXTDMCreateTransferContext
@@ -78,6 +79,7 @@ typedef struct PVRSRV_BRIDGE_IN_RGXTDMCREATETRANSFERCONTEXT_TAG
 	IMG_INT32 i32Priority;
 	IMG_UINT32 ui32ContextFlags;
 	IMG_UINT32 ui32FrameworkCmdSize;
+	IMG_UINT32 ui32MaxDeadlineMS;
 	IMG_UINT32 ui32PackedCCBSizeU88;
 } __packed PVRSRV_BRIDGE_IN_RGXTDMCREATETRANSFERCONTEXT;
 
@@ -186,7 +188,6 @@ typedef struct PVRSRV_BRIDGE_IN_RGXTDMGETSHAREDMEMORY_TAG
 typedef struct PVRSRV_BRIDGE_OUT_RGXTDMGETSHAREDMEMORY_TAG
 {
 	IMG_HANDLE hCLIPMRMem;
-	IMG_HANDLE hUSCPMRMem;
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXTDMGETSHAREDMEMORY;
 
@@ -225,4 +226,39 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXTDMSETTRANSFERCONTEXTPROPERTY_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXTDMSETTRANSFERCONTEXTPROPERTY;
 
+/*******************************************
+            RGXTDMSubmitTransfer3
+ *******************************************/
+
+/* Bridge in structure for RGXTDMSubmitTransfer3 */
+typedef struct PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER3_TAG
+{
+	IMG_UINT64 ui64DeadlineInus;
+	IMG_HANDLE hTransferContext;
+	IMG_UINT32 *pui32SyncPMRFlags;
+	IMG_UINT32 *pui32UpdateSyncOffset;
+	IMG_UINT32 *pui32UpdateValue;
+	IMG_UINT8 *pui8FWCommand;
+	IMG_CHAR *puiUpdateFenceName;
+	IMG_HANDLE *phSyncPMRs;
+	IMG_HANDLE *phUpdateUFOSyncPrimBlock;
+	PVRSRV_FENCE hCheckFenceFD;
+	PVRSRV_FENCE hExportFenceToSignal;
+	PVRSRV_TIMELINE hUpdateTimeline;
+	IMG_UINT32 ui32Characteristic1;
+	IMG_UINT32 ui32Characteristic2;
+	IMG_UINT32 ui32ClientUpdateCount;
+	IMG_UINT32 ui32CommandSize;
+	IMG_UINT32 ui32ExternalJobReference;
+	IMG_UINT32 ui32PDumpFlags;
+	IMG_UINT32 ui32SyncPMRCount;
+} __packed PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER3;
+
+/* Bridge out structure for RGXTDMSubmitTransfer3 */
+typedef struct PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER3_TAG
+{
+	PVRSRV_ERROR eError;
+	PVRSRV_FENCE hUpdateFence;
+} __packed PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER3;
+
 #endif /* COMMON_RGXTQ2_BRIDGE_H */
diff --git a/drivers/gpu/drm/img-rogue/common_rgxtq_bridge.h b/drivers/gpu/drm/img-rogue/common_rgxtq_bridge.h
index b4a9be2bd977..31d90dc0f993 100644
--- a/drivers/gpu/drm/img-rogue/common_rgxtq_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_rgxtq_bridge.h
@@ -62,7 +62,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVRSRV_BRIDGE_RGXTQ_RGXTQGETSHAREDMEMORY			PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+4
 #define PVRSRV_BRIDGE_RGXTQ_RGXTQRELEASESHAREDMEMORY			PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+5
 #define PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPROPERTY			PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+6
-#define PVRSRV_BRIDGE_RGXTQ_CMD_LAST			(PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+6)
+#define PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER3			PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+7
+#define PVRSRV_BRIDGE_RGXTQ_CMD_LAST			(PVRSRV_BRIDGE_RGXTQ_CMD_FIRST+7)
 
 /*******************************************
             RGXCreateTransferContext
@@ -168,7 +169,6 @@ typedef struct PVRSRV_BRIDGE_IN_RGXTQGETSHAREDMEMORY_TAG
 typedef struct PVRSRV_BRIDGE_OUT_RGXTQGETSHAREDMEMORY_TAG
 {
 	IMG_HANDLE hCLIPMRMem;
-	IMG_HANDLE hUSCPMRMem;
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXTQGETSHAREDMEMORY;
 
@@ -207,4 +207,39 @@ typedef struct PVRSRV_BRIDGE_OUT_RGXSETTRANSFERCONTEXTPROPERTY_TAG
 	PVRSRV_ERROR eError;
 } __packed PVRSRV_BRIDGE_OUT_RGXSETTRANSFERCONTEXTPROPERTY;
 
+/*******************************************
+            RGXSubmitTransfer3
+ *******************************************/
+
+/* Bridge in structure for RGXSubmitTransfer3 */
+typedef struct PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER3_TAG
+{
+	IMG_HANDLE hTransferContext;
+	IMG_UINT32 *pui32ClientUpdateCount;
+	IMG_UINT32 *pui32CommandSize;
+	IMG_UINT32 *pui32SyncPMRFlags;
+	IMG_UINT32 *pui32TQPrepareFlags;
+	IMG_UINT32 **pui32UpdateSyncOffset;
+	IMG_UINT32 **pui32UpdateValue;
+	IMG_UINT8 **pui8FWCommand;
+	IMG_CHAR *puiUpdateFenceName;
+	IMG_HANDLE *phSyncPMRs;
+	IMG_HANDLE **phUpdateUFOSyncPrimBlock;
+	PVRSRV_TIMELINE h2DUpdateTimeline;
+	PVRSRV_TIMELINE h3DUpdateTimeline;
+	PVRSRV_FENCE hCheckFenceFD;
+	PVRSRV_FENCE hExportFenceToSignal;
+	IMG_UINT32 ui32ExtJobRef;
+	IMG_UINT32 ui32PrepareCount;
+	IMG_UINT32 ui32SyncPMRCount;
+} __packed PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER3;
+
+/* Bridge out structure for RGXSubmitTransfer3 */
+typedef struct PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER3_TAG
+{
+	PVRSRV_ERROR eError;
+	PVRSRV_FENCE h2DUpdateFence;
+	PVRSRV_FENCE h3DUpdateFence;
+} __packed PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER3;
+
 #endif /* COMMON_RGXTQ_BRIDGE_H */
diff --git a/drivers/gpu/drm/img-rogue/common_ri_bridge.h b/drivers/gpu/drm/img-rogue/common_ri_bridge.h
index 967ed5395518..baa41adccdfe 100644
--- a/drivers/gpu/drm/img-rogue/common_ri_bridge.h
+++ b/drivers/gpu/drm/img-rogue/common_ri_bridge.h
@@ -88,13 +88,12 @@ typedef struct PVRSRV_BRIDGE_OUT_RIWRITEPMRENTRY_TAG
 /* Bridge in structure for RIWriteMEMDESCEntry */
 typedef struct PVRSRV_BRIDGE_IN_RIWRITEMEMDESCENTRY_TAG
 {
+	IMG_UINT64 ui64Flags;
 	IMG_UINT64 ui64Offset;
 	IMG_UINT64 ui64Size;
 	IMG_HANDLE hPMRHandle;
 	const IMG_CHAR *puiTextB;
 	IMG_UINT32 ui32TextBSize;
-	IMG_BOOL bIsImport;
-	IMG_BOOL bIsSuballoc;
 } __packed PVRSRV_BRIDGE_IN_RIWRITEMEMDESCENTRY;
 
 /* Bridge out structure for RIWriteMEMDESCEntry */
diff --git a/drivers/gpu/drm/img-rogue/config_kernel.h b/drivers/gpu/drm/img-rogue/config_kernel.h
index 540767d31894..09747a8a950f 100644
--- a/drivers/gpu/drm/img-rogue/config_kernel.h
+++ b/drivers/gpu/drm/img-rogue/config_kernel.h
@@ -2,11 +2,12 @@
 #define RGX_FW_FILENAME "rgx.fw"
 #define RGX_SH_FILENAME "rgx.sh"
 #define PVR_BUILD_DIR "spacemit"
+#define PVR_CTSR_DEV
 #define PVR_BUILD_TYPE "release"
 #define PVRSRV_MODNAME "pvrsrvkm"
 #define PVRSYNC_MODNAME "pvr_sync"
 #define SUPPORT_RGX 1
-#define PVRSRV_MAX_DEVICES 4
+#define PVRSRV_MAX_DEVICES 8
 #define PVRSRV_HWPERF_COUNTERS_PERBLK 12
 #define RGX_BVNC_CORE_KM_HEADER "cores/rgxcore_km_36.29.52.182.h"
 #define RGX_BNC_CONFIG_KM_HEADER "configs/rgxconfig_km_36.V.52.182.h"
@@ -34,30 +35,128 @@
 #define RGX_DRIVERID_6_DEFAULT_ISOLATION_GROUP 0
 #define RGX_DRIVERID_7_DEFAULT_ISOLATION_GROUP 0
 #define RGX_DRIVERID_0_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_10_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_10_DEFAULT_PRIORITY (1 - 10)
+#define RGX_DRIVERID_10_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_11_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_11_DEFAULT_PRIORITY (1 - 11)
+#define RGX_DRIVERID_11_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_12_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_12_DEFAULT_PRIORITY (1 - 12)
+#define RGX_DRIVERID_12_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_13_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_13_DEFAULT_PRIORITY (1 - 13)
+#define RGX_DRIVERID_13_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_14_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_14_DEFAULT_PRIORITY (1 - 14)
+#define RGX_DRIVERID_14_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_15_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_15_DEFAULT_PRIORITY (1 - 15)
+#define RGX_DRIVERID_15_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_16_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_16_DEFAULT_PRIORITY (1 - 16)
+#define RGX_DRIVERID_16_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_17_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_17_DEFAULT_PRIORITY (1 - 17)
+#define RGX_DRIVERID_17_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_18_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_18_DEFAULT_PRIORITY (1 - 18)
+#define RGX_DRIVERID_18_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_19_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_19_DEFAULT_PRIORITY (1 - 19)
+#define RGX_DRIVERID_19_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_1_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_20_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_20_DEFAULT_PRIORITY (1 - 20)
+#define RGX_DRIVERID_20_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_21_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_21_DEFAULT_PRIORITY (1 - 21)
+#define RGX_DRIVERID_21_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_22_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_22_DEFAULT_PRIORITY (1 - 22)
+#define RGX_DRIVERID_22_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_23_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_23_DEFAULT_PRIORITY (1 - 23)
+#define RGX_DRIVERID_23_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_24_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_24_DEFAULT_PRIORITY (1 - 24)
+#define RGX_DRIVERID_24_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_25_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_25_DEFAULT_PRIORITY (1 - 25)
+#define RGX_DRIVERID_25_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_26_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_26_DEFAULT_PRIORITY (1 - 26)
+#define RGX_DRIVERID_26_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_27_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_27_DEFAULT_PRIORITY (1 - 27)
+#define RGX_DRIVERID_27_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_28_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_28_DEFAULT_PRIORITY (1 - 28)
+#define RGX_DRIVERID_28_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_29_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_29_DEFAULT_PRIORITY (1 - 29)
+#define RGX_DRIVERID_29_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_2_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_30_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_30_DEFAULT_PRIORITY (1 - 30)
+#define RGX_DRIVERID_30_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_31_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_31_DEFAULT_PRIORITY (1 - 31)
+#define RGX_DRIVERID_31_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_3_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_4_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_5_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_6_DEFAULT_TIME_SLICE 0
 #define RGX_DRIVERID_7_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_8_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_8_DEFAULT_PRIORITY (1 - 8)
+#define RGX_DRIVERID_8_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVERID_9_DEFAULT_ISOLATION_GROUP 0
+#define RGX_DRIVERID_9_DEFAULT_PRIORITY (1 - 9)
+#define RGX_DRIVERID_9_DEFAULT_TIME_SLICE 0
+#define RGX_DRIVER_DEFAULT_TIME_SLICES_SUM (((((((((((((((((((((((((((((((( + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0) + 0)
 #define RGX_DRIVER_DEFAULT_TIME_SLICE_INTERVAL 0
 #define RGX_HCS_DEFAULT_DEADLINE_MS 0xFFFFFFFFU
 #define DRIVER0_SECURITY_SUPPORT 0
+#define DRIVER10_SECURITY_SUPPORT 0
+#define DRIVER11_SECURITY_SUPPORT 0
+#define DRIVER12_SECURITY_SUPPORT 0
+#define DRIVER13_SECURITY_SUPPORT 0
+#define DRIVER14_SECURITY_SUPPORT 0
+#define DRIVER15_SECURITY_SUPPORT 0
+#define DRIVER16_SECURITY_SUPPORT 0
+#define DRIVER17_SECURITY_SUPPORT 0
+#define DRIVER18_SECURITY_SUPPORT 0
+#define DRIVER19_SECURITY_SUPPORT 0
 #define DRIVER1_SECURITY_SUPPORT 0
+#define DRIVER20_SECURITY_SUPPORT 0
+#define DRIVER21_SECURITY_SUPPORT 0
+#define DRIVER22_SECURITY_SUPPORT 0
+#define DRIVER23_SECURITY_SUPPORT 0
+#define DRIVER24_SECURITY_SUPPORT 0
+#define DRIVER25_SECURITY_SUPPORT 0
+#define DRIVER26_SECURITY_SUPPORT 0
+#define DRIVER27_SECURITY_SUPPORT 0
+#define DRIVER28_SECURITY_SUPPORT 0
+#define DRIVER29_SECURITY_SUPPORT 0
 #define DRIVER2_SECURITY_SUPPORT 0
+#define DRIVER30_SECURITY_SUPPORT 0
+#define DRIVER31_SECURITY_SUPPORT 0
 #define DRIVER3_SECURITY_SUPPORT 0
 #define DRIVER4_SECURITY_SUPPORT 0
 #define DRIVER5_SECURITY_SUPPORT 0
 #define DRIVER6_SECURITY_SUPPORT 0
 #define DRIVER7_SECURITY_SUPPORT 0
+#define DRIVER8_SECURITY_SUPPORT 0
+#define DRIVER9_SECURITY_SUPPORT 0
+#define ENABLE_PVRDEBUG_PRIVILEGED_CMDS
 #define RGX_FW_HEAP_USES_FIRMWARE_OSID 0
 #define RGX_FW_HEAP_USES_HOST_OSID 1
 #define RGX_FW_HEAP_USES_DEDICATED_OSID 2
 #define RGX_FW_HEAP_OSID_ASSIGNMENT RGX_FW_HEAP_USES_FIRMWARE_OSID
 #define PVRSRV_APPHINT_PHYSHEAPMINMEMONCONNECTION 0
 #define RGX_FW_PHYSHEAP_MINMEM_ON_CONNECTION  512
-#define PVRSRV_APPHINT_DRIVERMODE 0x7FFFFFFF
+#define PVRSRV_APPHINT_DRIVERMODE "default"
 #define RGX_FW_HEAP_SHIFT 25
 #define RGX_VZ_CONNECTION_TIMEOUT_US 60000000
 #define GPUVIRT_VALIDATION_NUM_OS 8
@@ -72,7 +171,9 @@
 #define ION_DEFAULT_HEAP_NAME "ion_system_heap"
 #define ION_DEFAULT_HEAP_ID_MASK (1 << ION_HEAP_TYPE_SYSTEM)
 #define PVRSRV_APPHINT_HWRDEBUGDUMPLIMIT APPHNT_BLDVAR_DBGDUMPLIMIT
+#define PVRSRV_APPHINT_ICSTIMEINTERVAL_THRESHOLD 90
 #define PVRSRV_APPHINT_ENABLETRUSTEDDEVICEACECONFIG IMG_FALSE
+#define PVRSRV_APPHINT_FAULTDETECTIONTIMEINTERVAL_USEC 40000
 #define PVRSRV_APPHINT_GENERALNON4KHEAPPAGESIZE 0x4000
 #define PVRSRV_APPHINT_HWPERFCLIENTBUFFERSIZE 786432
 #define PVRSRV_APPHINT_ENABLESIGNATURECHECKS APPHNT_BLDVAR_ENABLESIGNATURECHECKS
@@ -97,7 +198,6 @@
 #define PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP 1
 #define PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLSCHEME 0
 #define PVRSRV_APPHINT_TFBCVERSION 0
-#define PVRSRV_APPHINT_JONESDISABLEMASK 0
 #define PVRSRV_APPHINT_NEWFILTERINGMODE 1
 #define PVRSRV_APPHINT_TRUNCATEMODE 0
 #define PVRSRV_APPHINT_EMUMAXFREQ 0
@@ -110,11 +210,13 @@
 #define PVRSRV_APPHINT_DEVMEM_HISTORY_MAX_ENTRIES 10000
 #define PVRSRV_APPHINT_ASSERTONHWRTRIGGER IMG_FALSE
 #define PVRSRV_APPHINT_ASSERTOUTOFMEMORY IMG_FALSE
+#define PVRSRV_APPHINT_AUTOVZGPUPOWERDOWN IMG_FALSE
 #define PVRSRV_APPHINT_CHECKMLIST APPHNT_BLDVAR_DEBUG
 #define PVRSRV_APPHINT_DISABLEFEDLOGGING IMG_FALSE
 #define PVRSRV_APPHINT_KCCB_SIZE_LOG2 10
 #define PVRSRV_APPHINT_ENABLEAPM RGX_ACTIVEPM_DEFAULT
 #define PVRSRV_APPHINT_ENABLEHTBLOGGROUP 0
+#define PVRSRV_APPHINT_ENABLEIDLECYCLESTEALING 0
 #define PVRSRV_APPHINT_ENABLELOGGROUP RGXFWIF_LOG_TYPE_NONE
 #define PVRSRV_APPHINT_FIRMWARELOGTYPE 0
 #define PVRSRV_APPHINT_FWTRACEBUFSIZEINDWORDS RGXFW_TRACE_BUF_DEFAULT_SIZE_IN_DWORDS
@@ -131,11 +233,12 @@
 #define PVRSRV_APPHINT_HWPERFCLIENTFILTER_OPENCL 0
 #define PVRSRV_APPHINT_HWPERFCLIENTFILTER_VULKAN 0
 #define PVRSRV_APPHINT_HWPERFCLIENTFILTER_OPENGL 0
-#define PVRSRV_APPHINT_TIMECORRCLOCK 0
+#define PVRSRV_APPHINT_TIMECORRCLOCK 2
 #define PVRSRV_APPHINT_ENABLEFWPOISONONFREE IMG_FALSE
 #define PVRSRV_APPHINT_FWPOISONONFREEVALUE 0xBD
 #define PVRSRV_APPHINT_ZEROFREELIST IMG_FALSE
 #define PVRSRV_APPHINT_GPUUNITSPOWERCHANGE IMG_FALSE
+#define PVRSRV_APPHINT_GUESTFWHEAPSTRIDE (1 << RGX_FW_HEAP_SHIFT)
 #define PVRSRV_APPHINT_DISABLEPDUMPPANIC IMG_FALSE
 #define PVRSRV_APPHINT_CACHEOPCONFIG 0
 #define PVRSRV_APPHINT_CACHEOPUMKMHRESHOLDSIZE 0
@@ -146,29 +249,34 @@
 #define PVRSRV_APPHINT_VALIDATESOCUSCTIMERS 0
 #define PVRSRV_APPHINT_CHECKPOINTPOOLMAXLOG2 8
 #define PVRSRV_APPHINT_CHECKPOINTPOOLINITLOG2 7
-#define SOC_TIMER_FREQ 20
 #define PDVFS_COM_HOST 1
 #define PDVFS_COM_AP 2
 #define PDVFS_COM_PMC 3
+#define PDVFS_COM_SYSREG 5
 #define PDVFS_COM_IMG_CLKDIV 4
 #define PDVFS_COM PDVFS_COM_HOST
 #define PVR_GPIO_MODE_GENERAL 1
 #define PVR_GPIO_MODE_POWMON_PIN 2
 #define PVR_GPIO_MODE PVR_GPIO_MODE_GENERAL
 #define PVRSRV_ENABLE_PROCESS_STATS
+#define PVRSRV_FORCE_HWPERF_TO_SCHED_CLK
 #define SUPPORT_USC_BREAKPOINT
 #define SUPPORT_AGP
 #define RGXFW_SAFETY_WATCHDOG_PERIOD_IN_US 2000000
 #define PVR_ANNOTATION_MAX_LEN 63
 #define PVRSRV_DEVICE_INIT_MODE PVRSRV_LINUX_DEV_INIT_ON_CONNECT
 #define SUPPORT_DI_BRG_IMPL
+#define SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY
+#define SUPPORT_LINUX_FDINFO
 #define PVR_LINUX_PHYSMEM_MAX_POOL_PAGES 10240
+#define PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES
 #define PVR_LINUX_PHYSMEM_MAX_EXCESS_POOL_PAGES 20480
 #define PVR_DIRTY_BYTES_FLUSH_THRESHOLD 524288
 #define PVR_LINUX_HIGHORDER_ALLOCATION_THRESHOLD 256
 #define PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM 2
 #define PVR_LINUX_KMALLOC_ALLOCATION_THRESHOLD 16384
 #define SUPPORT_PMR_DEFERRED_FREE
+#define SUPPORT_PMR_PAGES_DEFERRED_FREE
 #define SUPPORT_MMU_DEFERRED_FREE
 #define PVRSRV_USE_LINUX_CONFIG_INIT_ON_ALLOC 1
 #define SUPPORT_NATIVE_FENCE_SYNC
diff --git a/drivers/gpu/drm/img-rogue/config_kernel.mk b/drivers/gpu/drm/img-rogue/config_kernel.mk
index 7a87f2823526..c1c9e873d6a4 100644
--- a/drivers/gpu/drm/img-rogue/config_kernel.mk
+++ b/drivers/gpu/drm/img-rogue/config_kernel.mk
@@ -1,4 +1,5 @@
 override PVRSRV_DIR := services
+override PVRSRV_FORCE_HWPERF_TO_SCHED_CLK := 1
 override HOST_PRIMARY_ARCH := host_x86_64
 override HOST_32BIT_ARCH := host_i386
 override HOST_FORCE_32BIT := -m32
@@ -10,7 +11,7 @@ override TARGET_FORCE_32BIT :=
 override PVR_ARCH := rogue
 override METAG_VERSION_NEEDED := 2.8.1.0.3
 override MIPS_VERSION_NEEDED := 2014.07-1
-override RISCV_VERSION_NEEDED := 1.0.1
+override RISCV_VERSION_NEEDED := 1.7.1
 override KERNELDIR := /home/likaiyang/work/Jindie/out/bootable/fpga/linux
 override KERNEL_ID := 6.1.15-00003-g57b93bb899b2-dirty
 override PVRSRV_MODULE_BASEDIR := /lib/modules/6.1.15-00003-g57b93bb899b2-dirty/extra/
@@ -34,10 +35,11 @@ override RGX_NUM_DRIVERS_SUPPORTED := 1
 override RGX_FW_HEAP_OSID_ASSIGNMENT := RGX_FW_HEAP_USES_FIRMWARE_OSID
 override VMM_TYPE := stub
 override SUPPORT_POWMON_COMPONENT := 1
-override RGX_TIMECORR_CLOCK := mono
+override RGX_TIMECORR_CLOCK := sched
 override PDVFS_COM_HOST := 1
 override PDVFS_COM_AP := 2
 override PDVFS_COM_PMC := 3
+override PDVFS_COM_SYSREG := 5
 override PDVFS_COM_IMG_CLKDIV := 4
 override PDVFS_COM := PDVFS_COM_HOST
 override PVR_GPIO_MODE_GENERAL := 1
@@ -50,4 +52,6 @@ override SUPPORT_DI_BRG_IMPL := 1
 override SUPPORT_WRAP_EXTMEM := 1
 override SUPPORT_NATIVE_FENCE_SYNC := 1
 override SUPPORT_DMA_FENCE := 1
+override SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY := 1
+override SUPPORT_LINUX_FDINFO := 1
 override SUPPORT_BUFFER_SYNC := 1
diff --git a/drivers/gpu/drm/img-rogue/configs/rgxconfig_km_1.V.4.5.h b/drivers/gpu/drm/img-rogue/configs/rgxconfig_km_1.V.4.5.h
new file mode 100644
index 000000000000..1af637872cf9
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/configs/rgxconfig_km_1.V.4.5.h
@@ -0,0 +1,81 @@
+/*************************************************************************/ /*!
+@Title          RGX Configuration for BVNC 1.V.4.5 (kernel defines)
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#ifndef RGXCONFIG_KM_1_V_4_5_H
+#define RGXCONFIG_KM_1_V_4_5_H
+
+/***** Automatically generated file. Do not edit manually ********************/
+
+/******************************************************************************
+ * B.V.N.C Validation defines
+ *****************************************************************************/
+#define RGX_BNC_KM_B 1
+#define RGX_BNC_KM_N 4
+#define RGX_BNC_KM_C 5
+
+/******************************************************************************
+ * DDK Defines
+ *****************************************************************************/
+#define RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT (1U)
+#define RGX_FEATURE_COMPUTE
+#define RGX_FEATURE_COMPUTE_OVERLAP
+#define RGX_FEATURE_FAULT_DECODE_VERSION (0U)
+#define RGX_FEATURE_FBCDC_ALGORITHM (1U)
+#define RGX_FEATURE_FBCDC_ARCHITECTURE (1U)
+#define RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS (0U)
+#define RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS (0U)
+#define RGX_FEATURE_GS_RTA_SUPPORT
+#define RGX_FEATURE_LAYOUT_MARS (0U)
+#define RGX_FEATURE_META (MTP218)
+#define RGX_FEATURE_META_COREMEM_SIZE (0U)
+#define RGX_FEATURE_NUM_CLUSTERS (4U)
+#define RGX_FEATURE_NUM_ISP_IPP_PIPES (3U)
+#define RGX_FEATURE_NUM_RASTER_PIPES (1U)
+#define RGX_FEATURE_PERFBUS
+#define RGX_FEATURE_PHYS_BUS_WIDTH (40U)
+#define RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS (512U)
+#define RGX_FEATURE_SLC_SIZE_IN_KILOBYTES (128U)
+#define RGX_FEATURE_TILE_SIZE_X (32U)
+#define RGX_FEATURE_TILE_SIZE_Y (32U)
+#define RGX_FEATURE_TLA
+#define RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS (40U)
+
+#endif /* RGXCONFIG_KM_1_V_4_5_H */
diff --git a/drivers/gpu/drm/img-rogue/connection_server.c b/drivers/gpu/drm/img-rogue/connection_server.c
index 559a4be802d8..b519ee14de22 100644
--- a/drivers/gpu/drm/img-rogue/connection_server.c
+++ b/drivers/gpu/drm/img-rogue/connection_server.c
@@ -54,6 +54,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "osfunc.h"
 #include "tlstream.h"
 #include "rgxhwperf_common.h"
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+#include "ri_server.h"
+#endif
 
 /* PID associated with Connection currently being purged by Cleanup thread */
 static IMG_PID gCurrentPurgeConnectionPid;
@@ -93,10 +96,10 @@ static PVRSRV_ERROR ConnectionDataDestroy(CONNECTION_DATA *psConnection)
 
 	if (psProcessHandleBase != NULL)
 	{
-		/* PVRSRVReleaseProcessHandleBase() calls PVRSRVFreeKernelHendles()
+		/* PVRSRVReleaseProcessHandleBase() calls PVRSRVFreeKernelHandles()
 		 * and PVRSRVFreeHandleBase() for the process handle base.
 		 * Releasing kernel handles can never return RETRY error because
-		 * release function for those handles are NOPs and PVRSRVFreeKernelHendles()
+		 * release function for those handles are NOPs and PVRSRVFreeKernelHandles()
 		 * doesn't even call pfnReleaseData() callback.
 		 * Process handles can potentially return RETRY hence additional check
 		 * below. */
@@ -199,11 +202,11 @@ PVRSRV_ERROR PVRSRVCommonConnectionConnect(void **ppvPrivData, void *pvOSData)
 	CONNECTION_DATA *psConnection;
 	PVRSRV_ERROR eError;
 	PROCESS_HANDLE_BASE *psProcessHandleBase;
+	PVRSRV_DEVICE_NODE *psDevNode;
 
 	/* Allocate connection data area, no stats since process not registered yet */
 	psConnection = OSAllocZMemNoStats(sizeof(*psConnection));
 	PVR_LOG_RETURN_IF_NOMEM(psConnection, "psConnection");
-	psConnection->bSyncConnection = IMG_FALSE;
 
 	/* Allocate process statistics as early as possible to catch all allocs */
 #if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
@@ -215,20 +218,25 @@ PVRSRV_ERROR PVRSRVCommonConnectionConnect(void **ppvPrivData, void *pvOSData)
 	eError = OSConnectionPrivateDataInit(&psConnection->hOsPrivateData, pvOSData);
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSConnectionPrivateDataInit", failure);
 
+	/* Must come after OSConnectionPrivateDataInit */
+	psDevNode = OSGetDevNode(psConnection);
+	PVR_LOG_GOTO_IF_NOMEM(psDevNode, eError, failure);
+
+	if (psDevNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
+		psDevNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "Cannot connect to the device during deinit"));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_DEVICE, failure);
+	}
+
 	psConnection->pid = OSGetCurrentClientProcessIDKM();
 	psConnection->vpid = OSGetCurrentVirtualProcessID();
 	psConnection->tid = (IMG_UINT32)OSGetCurrentClientThreadIDKM();
-	OSStringLCopy(psConnection->pszProcName, OSGetCurrentClientProcessNameKM(), PVRSRV_CONNECTION_PROCESS_NAME_LEN);
+	OSStringSafeCopy(psConnection->pszProcName, OSGetCurrentClientProcessNameKM(), PVRSRV_CONNECTION_PROCESS_NAME_LEN);
 
 #if defined(SUPPORT_DMA_TRANSFER)
-	OSLockCreate(&psConnection->hDmaReqLock);
-
-	eError = OSEventObjectCreate("Dma transfer cleanup event object",
-															 &psConnection->hDmaEventObject);
-	PVR_LOG_GOTO_IF_ERROR(eError, "OSEventObjectCreate", failure);
-
-	OSAtomicWrite(&psConnection->ui32NumDmaTransfersInFlight, 0);
-	psConnection->bAcceptDmaRequests = IMG_TRUE;
+	eError = PVRSRVInitialiseDMA(psDevNode, psConnection);
+	PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVInitialiseDMA", failure);
 #endif
 
 	/* Register this connection with the sync core */
@@ -239,7 +247,7 @@ PVRSRV_ERROR PVRSRVCommonConnectionConnect(void **ppvPrivData, void *pvOSData)
 	 * Register this connection and Sync PDump callback with
 	 * the pdump core. Pass in the Sync connection data.
 	 */
-	eError = PDumpRegisterConnection(OSGetDevNode(psConnection),
+	eError = PDumpRegisterConnection(psDevNode,
 	                                 psConnection->psSyncConnectionData,
 	                                 SyncConnectionPDumpSyncBlocks,
 	                                 &psConnection->psPDumpConnectionData);
@@ -258,7 +266,6 @@ PVRSRV_ERROR PVRSRVCommonConnectionConnect(void **ppvPrivData, void *pvOSData)
 	{
 		IMG_BOOL bHostStreamIsNull;
 		PVRSRV_RGXDEV_INFO  *psRgxDevInfo;
-		PVRSRV_DEVICE_NODE	*psDevNode = OSGetDevNode(psConnection);
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 		eError = PVRSRVStatsDeviceConnect(psDevNode);
@@ -273,7 +280,7 @@ PVRSRV_ERROR PVRSRVCommonConnectionConnect(void **ppvPrivData, void *pvOSData)
 #endif
 		OSLockRelease(psDevNode->hConnectionsLock);
 
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 		{
 			psRgxDevInfo = _RGX_DEVICE_INFO_FROM_NODE(psDevNode);
 
@@ -335,50 +342,6 @@ static PVRSRV_ERROR _CleanupThreadPurgeConnectionData(void *pvConnectionData)
 	return eErrorConnection;
 }
 
-#if defined(SUPPORT_DMA_TRANSFER)
-static void WaitForOutstandingDma(CONNECTION_DATA *psConnectionData)
-{
-
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hEvent;
-	IMG_UINT32 ui32Tries = 100;
-
-#if defined(DMA_VERBOSE)
-	PVR_DPF((PVR_DBG_ERROR,
-					"Waiting on %d DMA transfers in flight...", OSAtomicRead(&psConnectionData->ui32NumDmaTransfersInFlight)));
-#endif
-
-	eError = OSEventObjectOpen(psConnectionData->hDmaEventObject, &hEvent);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to open event object", __func__));
-		return;
-	}
-
-	while (OSAtomicRead(&psConnectionData->ui32NumDmaTransfersInFlight) != 0)
-	{
-		/*
-		#define DMA_TRANSFER_TIMEOUT_US (5000000ULL)
-
-		This currently doesn't work properly. Wait time is not as requested.
-		Using OSSleepms instead
-
-		OSEventObjectWaitKernel(hEvent, DMA_TRANSFER_TIMEOUT_US);
-		*/
-		OSSleepms(50);
-		if (!ui32Tries)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Timeout while waiting on outstanding DMA transfers!", __func__));
-			break;
-		}
-
-		ui32Tries--;
-	}
-
-	OSEventObjectClose(hEvent);
-}
-#endif
-
 void PVRSRVCommonConnectionDisconnect(void *pvDataPtr)
 {
 	CONNECTION_DATA *psConnectionData = pvDataPtr;
@@ -395,7 +358,7 @@ void PVRSRVCommonConnectionDisconnect(void *pvDataPtr)
 	}
 
 	/* Add a HOST_CLIENT_INFO event to match the one on connection */
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 	{
 		IMG_BOOL bHostStreamIsNull;
 		PVRSRV_RGXDEV_INFO  *psRgxDevInfo;
@@ -416,17 +379,13 @@ void PVRSRVCommonConnectionDisconnect(void *pvDataPtr)
 		}
 	}
 
-#if defined(SUPPORT_DMA_TRANSFER)
-	OSLockAcquire(psConnectionData->hDmaReqLock);
-
-	psConnectionData->bAcceptDmaRequests = IMG_FALSE;
-
-	OSLockRelease(psConnectionData->hDmaReqLock);
-
-	WaitForOutstandingDma(psConnectionData);
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+	/* Mark remaining resources for driver to free */
+	RIConnectionClosed(psConnectionData);
+#endif
 
-	OSEventObjectDestroy(psConnectionData->hDmaEventObject);
-	OSLockDestroy(psConnectionData->hDmaReqLock);
+#if defined(SUPPORT_DMA_TRANSFER)
+	PVRSRVDeInitialiseDMA(psDevNode, psConnectionData);
 #endif
 
 #if defined(DEBUG) || defined(PDUMP)
@@ -501,7 +460,7 @@ void PVRSRVConnectionDebugNotify(PVRSRV_DEVICE_NODE *psDevNode,
 					   CONNECTIONS_PREFIX,
 					   (unsigned char)psDevNode->sDevId.ui32InternalID,
 					   (unsigned char)psDevNode->sDevId.i32KernelDeviceID);
-		OSStringLCopy(sActiveConnections+uiPos, szTmpConBuff, uiSize);
+		OSStringSafeCopy(sActiveConnections+uiPos, szTmpConBuff, uiSize);
 
 		/* Move the write offset to the end of the current string */
 		uiPos += i;
@@ -518,7 +477,7 @@ void PVRSRVConnectionDebugNotify(PVRSRV_DEVICE_NODE *psDevNode,
 			i = MIN(MAX_DEBUG_DUMP_CONNECTION_STR_LEN, i);
 			bPrinted = IMG_FALSE;
 
-			OSStringLCopy(sActiveConnections+uiPos, sTmpBuff, uiSize);
+			OSStringSafeCopy(sActiveConnections+uiPos, sTmpBuff, uiSize);
 
 			/* Move the write offset to the end of the current string */
 			uiPos += i;
diff --git a/drivers/gpu/drm/img-rogue/connection_server.h b/drivers/gpu/drm/img-rogue/connection_server.h
index d9eb515c2e5a..673c37c02a3c 100644
--- a/drivers/gpu/drm/img-rogue/connection_server.h
+++ b/drivers/gpu/drm/img-rogue/connection_server.h
@@ -99,7 +99,6 @@ typedef struct _CONNECTION_DATA_
 #if defined(SUPPORT_DMA_TRANSFER)
 	IMG_BOOL            bAcceptDmaRequests;
 	ATOMIC_T            ui32NumDmaTransfersInFlight;
-	POS_LOCK            hDmaReqLock;
 	IMG_HANDLE          hDmaEventObject;
 #endif
 	/* Structure which is hooked into the cleanup thread work list */
@@ -110,7 +109,6 @@ typedef struct _CONNECTION_DATA_
 	/* List navigation for deferred freeing of connection data */
 	struct _CONNECTION_DATA_	**ppsThis;
 	struct _CONNECTION_DATA_	*psNext;
-	IMG_BOOL            bSyncConnection;
 } CONNECTION_DATA;
 
 #include "osconnection_server.h"
diff --git a/drivers/gpu/drm/img-rogue/cores/rgxcore_km_1.82.4.5.h b/drivers/gpu/drm/img-rogue/cores/rgxcore_km_1.82.4.5.h
new file mode 100644
index 000000000000..ae53d7ceef27
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/cores/rgxcore_km_1.82.4.5.h
@@ -0,0 +1,69 @@
+/*************************************************************************/ /*!
+@Title          RGX Core BVNC 1.82.4.5
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#ifndef RGXCORE_KM_1_82_4_5_H
+#define RGXCORE_KM_1_82_4_5_H
+
+/* Automatically generated file (21/01/2022 09:01:15): Do not edit manually */
+/* CS: @2503111 */
+
+/******************************************************************************
+ * BVNC = 1.82.4.5
+ *****************************************************************************/
+#define RGX_BVNC_KM_B 1
+#define RGX_BVNC_KM_V 82
+#define RGX_BVNC_KM_N 4
+#define RGX_BVNC_KM_C 5
+
+/******************************************************************************
+ * Errata
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+ * Enhancements
+ *****************************************************************************/
+
+
+
+#endif /* RGXCORE_KM_1_82_4_5_H */
diff --git a/drivers/gpu/drm/img-rogue/debug_common.c b/drivers/gpu/drm/img-rogue/debug_common.c
index 98e7dbe6ed29..16746b5d550a 100644
--- a/drivers/gpu/drm/img-rogue/debug_common.c
+++ b/drivers/gpu/drm/img-rogue/debug_common.c
@@ -69,9 +69,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 static DI_ENTRY *gpsVersionDIEntry;
 static DI_ENTRY *gpsStatusDIEntry;
 
-#ifdef SUPPORT_VALIDATION
-static DI_ENTRY *gpsTestMemLeakDIEntry;
-#endif /* SUPPORT_VALIDATION */
 #if defined(DEBUG) || defined(PVR_DPF_ADHOC_DEBUG_ON)
 static DI_ENTRY *gpsDebugLevelDIEntry;
 #endif /* defined(DEBUG) || defined(PVR_DPF_ADHOC_DEBUG_ON) */
@@ -169,7 +166,7 @@ static void *_VersionDINext(OSDI_IMPL_ENTRY *psEntry,void *pvPriv,
 #define STR_DEBUG   "debug"
 #define STR_RELEASE "release"
 
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 #define BUILD_OPT_LEN 80
 
 static inline void _AppendOptionStr(IMG_CHAR pszBuildOptions[], const IMG_CHAR* str, OSDI_IMPL_ENTRY *psEntry, IMG_UINT32* pui32BuildOptionLen)
@@ -186,7 +183,7 @@ static inline void _AppendOptionStr(IMG_CHAR pszBuildOptions[], const IMG_CHAR*
 	}
 	if (strLen < optStrLen)
 	{
-		OSStringLCopy(pszBuildOptions+ui32BuildOptionLen, str, strLen);
+		OSStringSafeCopy(pszBuildOptions+ui32BuildOptionLen, str, strLen);
 		ui32BuildOptionLen += strLen - 1;
 	}
 	*pui32BuildOptionLen = ui32BuildOptionLen;
@@ -246,7 +243,7 @@ static int _VersionDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvPriv)
 		PVRSRV_DEVICE_CONFIG *psDevConfig = psDevNode->psDevConfig;
 #ifdef SUPPORT_RGX
 		PVRSRV_RGXDEV_INFO *psDevInfo = psDevNode->pvDevice;
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 		IMG_CHAR pszBuildOptions[BUILD_OPT_LEN];
 		IMG_UINT32 ui32BuildOptionLen = 0;
 		static const char* aszOptions[] = RGX_BUILD_OPTIONS_LIST;
@@ -278,7 +275,7 @@ static int _VersionDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvPriv)
 			}
 		}
 
-		if (PVRSRV_VZ_MODE_IS(GUEST))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 		{
 #ifdef SUPPORT_RGX
 			/* print device's firmware version info */
@@ -306,7 +303,7 @@ static int _VersionDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvPriv)
 						         PVR_BUILD_DIR);
 						bFwVersionInfoPrinted = IMG_TRUE;
 
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 						DIPrintf(psEntry, "Firmware Build Options:\n");
 
 						for (i = 0; i < ARRAY_SIZE(aszOptions); i++)
@@ -348,7 +345,7 @@ static int _VersionDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvPriv)
 					 PVR_BUILD_DIR);
 
 			bFwVersionInfoPrinted = IMG_TRUE;
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 			DIPrintf(psEntry, "Firmware Build Options:\n");
 
 			for (i = 0; i < ARRAY_SIZE(aszOptions); i++)
@@ -398,7 +395,7 @@ static PVRSRV_ERROR SendPowerCounterCommand(PVRSRV_DEVICE_NODE* psDeviceNode,
 
 	RGXFWIF_KCCB_CMD sCounterDumpCmd;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	sCounterDumpCmd.eCmdType = RGXFWIF_KCCB_CMD_COUNTER_DUMP;
 	sCounterDumpCmd.uCmdData.sCounterDumpConfigData.eCounterDumpRequest = eRequestType;
@@ -504,12 +501,14 @@ static int _DebugPowerDataDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 				for (j = 0; j < ui32NumOfInstances * ui32NumOfCores; j++)
 				{
 					ui32Low = *pui32PowerBuffer++;
+#if defined(RGX_FEATURE_CATURIX_XTP_TOP_INFRASTRUCTURE_BIT_MASK)
 					if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, CATURIX_XTP_TOP_INFRASTRUCTURE))
 					{
 						/* Power counters have 32-bit range */
 						DIPrintf(psEntry, " 0x%08x", ui32Low);
 					}
 					else
+#endif
 					{
 						/* Power counters have 64-bit range */
 						ui32High = *pui32PowerBuffer++;
@@ -641,6 +640,50 @@ static void *_DebugStatusDINext(OSDI_IMPL_ENTRY *psEntry,
 										  *pui64Pos);
 	OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
 
+#ifdef SUPPORT_RGX
+	if (psDeviceNode && !PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+	{
+		PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+
+		if (psDevInfo && psDevInfo->pfnGetGpuUtilStats)
+		{
+			PVRSRV_DEVICE_DEBUG_INFO *psDebugInfo = &psDeviceNode->sDebugInfo;
+			PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus = OSAtomicRead(&psDeviceNode->eHealthStatus);
+
+			if (eHealthStatus == PVRSRV_DEVICE_HEALTH_STATUS_OK)
+			{
+				PVRSRV_ERROR eError;
+#if defined(EMULATOR) || defined(VIRTUAL_PLATFORM)
+				static IMG_BOOL bFirstTime = IMG_TRUE;
+#endif
+
+				OSLockAcquire(psDevInfo->hGpuUtilStatsLock);
+
+				eError = psDevInfo->pfnGetGpuUtilStats(psDeviceNode,
+													   psDebugInfo->hGpuUtilUserDebugFS,
+													   &psDevInfo->sGpuUtilStats);
+
+				OSLockRelease(psDevInfo->hGpuUtilStatsLock);
+
+				if (eError != PVRSRV_OK)
+				{
+#if defined(EMULATOR) || defined(VIRTUAL_PLATFORM)
+					if (bFirstTime)
+					{
+						bFirstTime = IMG_FALSE;
+#endif	/* defined(EMULATOR) || defined(VIRTUAL_PLATFORM) */
+					PVR_DPF((PVR_DBG_ERROR,
+					        "%s: Failed to get GPU statistics (%s)",
+					        __func__, PVRSRVGetErrorString(eError)));
+#if defined(EMULATOR) || defined(VIRTUAL_PLATFORM)
+					}
+#endif	/* defined(EMULATOR) || defined(VIRTUAL_PLATFORM) */
+				}
+			}
+		}
+	}
+#endif
+
 	return psDeviceNode;
 }
 
@@ -779,7 +822,7 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 			 *	- Perform actual on-chip GPU power/dvfs management.
 			 *	- As a result no more information can be provided.
 			 */
-			if (!PVRSRV_VZ_MODE_IS(GUEST))
+			if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 			{
 				if (psFwSysData != NULL)
 				{
@@ -793,28 +836,19 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 				if (psDevInfo->pfnGetGpuUtilStats &&
 					eHealthStatus == PVRSRV_DEVICE_HEALTH_STATUS_OK)
 				{
-					PVRSRV_DEVICE_DEBUG_INFO *psDebugInfo = &psDeviceNode->sDebugInfo;
-					RGXFWIF_GPU_UTIL_STATS *psGpuUtilStats = OSAllocMem(sizeof(*psGpuUtilStats));
-					PVRSRV_ERROR eError = PVRSRV_OK;
+					PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+					RGXFWIF_GPU_UTIL_STATS *psGpuUtilStats = &psDevInfo->sGpuUtilStats;
 
-					if (psGpuUtilStats == NULL)
-					{
-						PVR_DPF((PVR_DBG_ERROR, "%s: Failed to allocate GPU stats memory", __func__));
-						goto return_;
-					}
+					OSLockAcquire(psDevInfo->hGpuUtilStatsLock);
 
-					eError = psDevInfo->pfnGetGpuUtilStats(psDeviceNode,
-														   psDebugInfo->hGpuUtilUserDebugFS,
-														   psGpuUtilStats);
-
-					if ((eError == PVRSRV_OK) &&
-						((IMG_UINT32)psGpuUtilStats->ui64GpuStatCumulative))
+					if ((IMG_UINT32)psGpuUtilStats->ui64GpuStatCumulative)
 					{
 						const IMG_CHAR *apszDmNames[RGXFWIF_DM_MAX] = {"GP", "TDM", "GEOM", "3D", "CDM", "RAY", "GEOM2", "GEOM3", "GEOM4"};
 						IMG_UINT64 util;
 						IMG_UINT32 rem;
 						IMG_UINT32 ui32DriverID;
 						RGXFWIF_DM eDM;
+						IMG_INT    iDM_Util = 0;
 
 						if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, FASTRENDER_DM)))
 						{
@@ -826,7 +860,7 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 
 						DIPrintf(psEntry, "GPU Utilisation: %u%%\n", (IMG_UINT32)util);
 
-						DIPrintf(psEntry, "                  ");
+						DIPrintf(psEntry, "DM Utilisation:");
 
 						FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 						{
@@ -835,13 +869,13 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 
 						DIPrintf(psEntry, "\n");
 
-						for (eDM = RGXFWIF_DM_TDM; eDM < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; eDM++)
+						for (eDM = RGXFWIF_DM_TDM; eDM < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; eDM++,iDM_Util++)
 						{
-							DIPrintf(psEntry, "%-5s Utilisation: ", apszDmNames[eDM]);
+							DIPrintf(psEntry, "        %5s: ", apszDmNames[eDM]);
 
 							FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 							{
-								IMG_UINT32 uiDivisor = (IMG_UINT32)psGpuUtilStats->aaui64DMOSStatCumulative[eDM][ui32DriverID];
+								IMG_UINT32 uiDivisor = (IMG_UINT32)psGpuUtilStats->aaui64DMOSStatCumulative[iDM_Util][ui32DriverID];
 
 								if (uiDivisor == 0U)
 								{
@@ -849,7 +883,7 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 									continue;
 								}
 
-								util = 100 * psGpuUtilStats->aaui64DMOSStatActive[eDM][ui32DriverID];
+								util = 100 * psGpuUtilStats->aaui64DMOSStatActive[iDM_Util][ui32DriverID];
 								util = OSDivide64(util, uiDivisor, &rem);
 
 								DIPrintf(psEntry, "%3u%% ", (IMG_UINT32)util);
@@ -864,16 +898,14 @@ static int _DebugStatusDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 						DIPrintf(psEntry, "GPU Utilisation: -\n");
 					}
 
-					OSFreeMem(psGpuUtilStats);
+					OSLockRelease(psDevInfo->hGpuUtilStatsLock);
+
 				}
 			}
 #endif /* SUPPORT_RGX */
 		}
 	}
 
-#ifdef SUPPORT_RGX
-return_:
-#endif
 	return 0;
 }
 
@@ -904,7 +936,7 @@ const IMG_CHAR *PVRSRVGetDebugDevStateString(PVRSRV_DEVICE_STATE eDevState)
 	#undef X
 	};
 
-	if (eDevState < 0 || eDevState > PVRSRV_DEVICE_STATE_LAST)
+	if (eDevState < 0 || eDevState >= PVRSRV_DEVICE_STATE_LAST)
 	{
 		return "Undefined";
 	}
@@ -912,6 +944,40 @@ const IMG_CHAR *PVRSRVGetDebugDevStateString(PVRSRV_DEVICE_STATE eDevState)
 	return _pszDeviceStateStrings[eDevState];
 }
 
+
+const IMG_CHAR *PVRSRVGetDebugHealthStatusString(PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus)
+{
+	static const char *const _pszDeviceHealthStatusStrings[] = {
+	#define X(_name) #_name,
+		PVRSRV_DEVICE_HEALTH_STATUS_LIST
+	#undef X
+	};
+
+	if (eHealthStatus < 0 || eHealthStatus >= PVRSRV_DEVICE_HEALTH_STATUS_LAST)
+	{
+		return "Undefined";
+	}
+
+	return _pszDeviceHealthStatusStrings[eHealthStatus];
+}
+
+
+const IMG_CHAR *PVRSRVGetDebugHealthReasonString(PVRSRV_DEVICE_HEALTH_REASON eHealthReason)
+{
+	static const char *const _pszDeviceHealthReasonStrings[] = {
+	#define X(_name) #_name,
+		PVRSRV_DEVICE_HEALTH_REASON_LIST
+	#undef X
+	};
+
+	if (eHealthReason < 0 || eHealthReason >= PVRSRV_DEVICE_HEALTH_REASON_LAST)
+	{
+		return "Undefined";
+	}
+
+	return _pszDeviceHealthReasonStrings[eHealthReason];
+}
+
 /*************************************************************************/ /*!
  Dump Debug DebugFS entry
 */ /**************************************************************************/
@@ -942,6 +1008,8 @@ static int _DebugFWTraceDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	PVRSRV_DEVICE_NODE *psDeviceNode = DIGetPrivData(psEntry);
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
+	PVR_UNREFERENCED_PARAMETER(pvData);
+
 	if (psDevInfo != NULL)
 	{
 		RGXDumpFirmwareTrace(_DumpDebugDIPrintfWrapper, psEntry, psDevInfo);
@@ -954,6 +1022,7 @@ static int _DebugFWTraceDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
  Firmware Translated Page Tables DebugFS entry
 */ /**************************************************************************/
 
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
 static int _FirmwareMappingsDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 {
 	PVRSRV_DEVICE_NODE *psDeviceNode;
@@ -962,6 +1031,8 @@ static int _FirmwareMappingsDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	IMG_UINT32 ui32FwPageSize;
 	IMG_UINT32 ui32DriverID;
 
+	PVR_UNREFERENCED_PARAMETER(pvData);
+
 	psDeviceNode = DIGetPrivData(psEntry);
 
 	if ((psDeviceNode == NULL) ||
@@ -1041,7 +1112,7 @@ static int _FirmwareMappingsDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 		DIPrintf(psEntry, "+-----------------+------------------------+------------------------+--------------+\n");
 
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-		if (PVRSRV_VZ_MODE_IS(NATIVE))
+		if (PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode))
 		{
 			break;
 		}
@@ -1050,6 +1121,7 @@ static int _FirmwareMappingsDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 
 	return 0;
 }
+#endif
 
 #ifdef SUPPORT_FIRMWARE_GCOV
 
@@ -1111,159 +1183,8 @@ static int _FirmwareGcovDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 
 #endif /* SUPPORT_FIRMWARE_GCOV */
 
-#ifdef SUPPORT_VALIDATION
-
-#ifndef SYS_RGX_DEV_UNMAPPED_FW_REG
-#define SYS_RGX_DEV_UNMAPPED_FW_REG 0XFFFFFFFF
-#endif
-#define DI_RGXREGS_TIMEOUT_MS 1000
-
-/*************************************************************************/ /*!
- RGX Registers Dump DebugFS entry
-*/ /**************************************************************************/
-
-static IMG_INT64 _RgxRegsSeek(IMG_UINT64 ui64Offset, void *pvData)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE*)pvData;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_LOG_RETURN_IF_FALSE(psDeviceNode != NULL, "psDeviceNode is NULL", -1);
-
-	psDevInfo = psDeviceNode->pvDevice;
-
-	PVR_LOG_RETURN_IF_FALSE(ui64Offset <= (psDevInfo->ui32RegSize - 4),
-	                        "register offset is too big", -1);
-
-	return ui64Offset;
-}
-
-static IMG_INT64 _RgxRegsRead(IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
-                              IMG_UINT64 *pui64Pos, void *pvData)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE*)pvData;
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	IMG_UINT64 ui64RegVal = 0;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT64 ui64CompRes;
-
-	PVR_LOG_RETURN_IF_FALSE(psDeviceNode != NULL, "psDeviceNode is NULL", -ENXIO);
-	PVR_LOG_RETURN_IF_FALSE(ui64Count == 4 || ui64Count == 8,
-	                        "wrong RGX register size", -EIO);
-	PVR_LOG_RETURN_IF_FALSE(!(*pui64Pos & (ui64Count - 1)),
-	                        "register read offset isn't aligned", -EINVAL);
-
-	psDevInfo = psDeviceNode->pvDevice;
-
-	if (*pui64Pos >= SYS_RGX_DEV_UNMAPPED_FW_REG)
-	{
-		if (!psDevInfo->bFirmwareInitialised)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "RGX Register offset is above PCI mapped range but "
-					 "Firmware isn't yet initialised\n"));
-			return -EIO;
-		}
-
-		reinit_completion(&psDevInfo->sFwRegs.sRegComp);
-
-		eError = RGXScheduleRgxRegCommand(psDevInfo,
-										  0x00,
-										  ui64Count,
-										  (IMG_UINT32) *pui64Pos,
-										  IMG_FALSE);
-
-		if (eError != PVRSRV_OK)
-		{
-			PVR_LOG_ERROR(eError, "RGXScheduleRgxRegCommand");
-			return -EIO;
-		}
-
-		ui64CompRes = wait_for_completion_timeout(&psDevInfo->sFwRegs.sRegComp,
-												  msecs_to_jiffies(DI_RGXREGS_TIMEOUT_MS));
-		if (!ui64CompRes)
-		{
-				PVR_DPF((PVR_DBG_ERROR, "FW RGX Register access timeout %#x\n",
-				   (IMG_UINT32) *pui64Pos));
-				return -EIO;
-		}
-
-		OSCachedMemCopy(pcBuffer, &psDevInfo->sFwRegs.ui64RegVal, ui64Count);
-	}
-	else
-	{
-		ui64RegVal = ui64Count == 4 ?
-	        OSReadHWReg32(psDevInfo->pvRegsBaseKM, *pui64Pos) :
-			OSReadHWReg64(psDevInfo->pvRegsBaseKM, *pui64Pos);
-		OSCachedMemCopy(pcBuffer, &ui64RegVal, ui64Count);
-	}
-
-	return ui64Count;
-}
-
-static IMG_INT64 _RgxRegsWrite(const IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
-                               IMG_UINT64 *pui64Pos, void *pvData)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE*)pvData;
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	IMG_UINT64 ui64RegVal = 0;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	/* ignore the '\0' character */
-	ui64Count -= 1;
-
-	PVR_LOG_RETURN_IF_FALSE(psDeviceNode != NULL, "psDeviceNode is NULL", -ENXIO);
-	PVR_LOG_RETURN_IF_FALSE(ui64Count == 4 || ui64Count == 8,
-	                        "wrong RGX register size", -EIO);
-	PVR_LOG_RETURN_IF_FALSE(!(*pui64Pos & (ui64Count - 1)),
-	                        "register read offset isn't aligned", -EINVAL);
-
-	psDevInfo = psDeviceNode->pvDevice;
-
-	if (*pui64Pos >= SYS_RGX_DEV_UNMAPPED_FW_REG)
-	{
-		if (!psDevInfo->bFirmwareInitialised)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "RGX Register offset is above PCI mapped range but "
-					 "Firmware isn't yet initialised\n"));
-			return -EIO;
-		}
-
-		if (ui64Count == 4)
-			ui64RegVal = (IMG_UINT64) *((IMG_UINT32 *) pcBuffer);
-		else
-			ui64RegVal = *((IMG_UINT64 *) pcBuffer);
-
-		eError = RGXScheduleRgxRegCommand(psDevInfo,
-										  ui64RegVal,
-										  ui64Count,
-										  (IMG_UINT32) *pui64Pos,
-										  IMG_TRUE);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_LOG_ERROR(eError, "RGXScheduleRgxRegCommand");
-			return -EIO;
-		}
-
-	}
-	else
-	{
-		if (ui64Count == 4)
-		{
-			OSWriteHWReg32(psDevInfo->pvRegsBaseKM, *pui64Pos,
-						   *((IMG_UINT32 *) (void *) pcBuffer));
-		}
-		else
-		{
-			OSWriteHWReg64(psDevInfo->pvRegsBaseKM, *pui64Pos,
-						   *((IMG_UINT64 *) (void *) pcBuffer));
-		}
-	}
 
-	return ui64Count;
-}
-
-#endif /* SUPPORT_VALIDATION */
-
-#if defined(SUPPORT_VALIDATION) || defined(SUPPORT_RISCV_GDB)
+#if  defined(SUPPORT_RISCV_GDB)
 #define RISCV_DMI_SIZE  (8U)
 
 static IMG_INT64 _RiscvDmiRead(IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
@@ -1304,70 +1225,6 @@ static IMG_INT64 _RiscvDmiWrite(const IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
 
 #endif /* SUPPORT_RGX */
 
-#ifdef SUPPORT_VALIDATION
-
-static int TestMemLeakDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
-{
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-
-	PVR_UNREFERENCED_PARAMETER(pvData);
-
-	PVR_RETURN_IF_FALSE(pvData != NULL, -EINVAL);
-
-	DIPrintf(psEntry, "os: %s, %u\ngpu: %s, %u\nmmu: %s, %u\n",
-	         psPVRSRVData->sMemLeakIntervals.ui32OSAlloc ? "enabled" : "disabled",
-	         psPVRSRVData->sMemLeakIntervals.ui32OSAlloc,
-	         psPVRSRVData->sMemLeakIntervals.ui32GPU ? "enabled" : "disabled",
-	         psPVRSRVData->sMemLeakIntervals.ui32GPU,
-	         psPVRSRVData->sMemLeakIntervals.ui32MMU ? "enabled" : "disabled",
-	         psPVRSRVData->sMemLeakIntervals.ui32MMU);
-
-	return 0;
-}
-
-static IMG_INT64 TestMemLeakDISet(const IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
-                                  IMG_UINT64 *pui64Pos, void *pvData)
-{
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-	IMG_CHAR *pcTemp;
-	unsigned long ui32MemLeakInterval;
-
-	PVR_UNREFERENCED_PARAMETER(pvData);
-
-	PVR_RETURN_IF_FALSE(pcBuffer != NULL, -EIO);
-	PVR_RETURN_IF_FALSE(pui64Pos != NULL && *pui64Pos == 0, -EIO);
-	PVR_RETURN_IF_FALSE(ui64Count <= 16, -EINVAL);
-	PVR_RETURN_IF_FALSE(pcBuffer[ui64Count - 1] == '\0', -EINVAL);
-
-	pcTemp = strchr(pcBuffer, ',');
-
-	if (kstrtoul(pcTemp+1, 0, &ui32MemLeakInterval) != 0)
-	{
-		return -EINVAL;
-	}
-
-	if (strncmp(pcBuffer, "os", pcTemp-pcBuffer) == 0)
-	{
-		psPVRSRVData->sMemLeakIntervals.ui32OSAlloc = ui32MemLeakInterval;
-	}
-	else if (strncmp(pcBuffer, "gpu", pcTemp-pcBuffer) == 0)
-	{
-		psPVRSRVData->sMemLeakIntervals.ui32GPU = ui32MemLeakInterval;
-	}
-	else if (strncmp(pcBuffer, "mmu", pcTemp-pcBuffer) == 0)
-	{
-		psPVRSRVData->sMemLeakIntervals.ui32MMU = ui32MemLeakInterval;
-	}
-	else
-	{
-		return -EINVAL;
-	}
-
-	*pui64Pos += ui64Count;
-	return ui64Count;
-}
-
-#endif /* SUPPORT_VALIDATION */
 
 #if defined(DEBUG) || defined(PVR_DPF_ADHOC_DEBUG_ON)
 
@@ -1440,8 +1297,8 @@ static int VZPriorityDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	PVR_RETURN_IF_FALSE(ui32DriverID < (RGXFW_HOST_DRIVER_ID + RGX_NUM_DRIVERS_SUPPORTED),
 	                    -EINVAL);
 
-	RGXFwSharedMemCacheOpValue(psRuntimeCfg->aui32DriverPriority[ui32DriverID], INVALIDATE);
-	DIPrintf(psEntry, "%u\n", psRuntimeCfg->aui32DriverPriority[ui32DriverID]);
+	RGXFwSharedMemCacheOpValue(psRuntimeCfg->ai32DriverPriority[ui32DriverID], INVALIDATE);
+	DIPrintf(psEntry, "%u\n", psRuntimeCfg->ai32DriverPriority[ui32DriverID]);
 
 	return 0;
 }
@@ -1491,7 +1348,7 @@ static int VZTimeSliceIntervalDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	psRuntimeCfg = psDevInfo->psRGXFWIfRuntimeCfg;
 	PVR_RETURN_IF_FALSE(psRuntimeCfg != NULL, -EIO);
 
-	DIPrintf(psEntry, "%u ms\n", psRuntimeCfg->ui32DriverTimeSliceInterval);
+	DIPrintf(psEntry, "%u ms (0: disable)\n", psRuntimeCfg->ui32TSIntervalMs);
 
 	return 0;
 }
@@ -1501,7 +1358,7 @@ static IMG_INT64 VZTimeSliceIntervalSet(const IMG_CHAR *pcBuffer, IMG_UINT64 ui6
 {
 	const DI_VZ_DATA *psVZDriverData = (const DI_VZ_DATA*)pvData;
 	const IMG_UINT32 uiMaxBufferSize = 12;
-	IMG_UINT32 ui32TimeSliceInterval;
+	IMG_UINT32 ui32TSIntervalMs;
 	PVRSRV_ERROR eError;
 
 	PVR_RETURN_IF_FALSE(pcBuffer != NULL, -EIO);
@@ -1510,13 +1367,13 @@ static IMG_INT64 VZTimeSliceIntervalSet(const IMG_CHAR *pcBuffer, IMG_UINT64 ui6
 	PVR_RETURN_IF_FALSE(psVZDriverData != NULL, -EINVAL);
 	PVR_RETURN_IF_FALSE(psVZDriverData->psDevNode != NULL, -ENXIO);
 
-	if (OSStringToUINT32(pcBuffer, 10, &ui32TimeSliceInterval) != PVRSRV_OK)
+	if (OSStringToUINT32(pcBuffer, 10, &ui32TSIntervalMs) != PVRSRV_OK)
 	{
 		return -EINVAL;
 	}
 
 	eError = PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(NULL, psVZDriverData->psDevNode,
-														  ui32TimeSliceInterval);
+														  ui32TSIntervalMs);
 	if (eError != PVRSRV_OK)
 	{
 		return -EIO;
@@ -1546,7 +1403,7 @@ static int VZTimeSliceDIShow(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	PVR_RETURN_IF_FALSE(ui32DriverID < (RGXFW_HOST_DRIVER_ID + RGX_NUM_DRIVERS_SUPPORTED),
 						-EINVAL);
 
-	DIPrintf(psEntry, "%u (0: disable; 1pc to 100pc)\n", psRuntimeCfg->aui32DriverTimeSlice[ui32DriverID]);
+	DIPrintf(psEntry, "%u (0: auto; 1%% to 100%%)\n", psRuntimeCfg->aui32TSPercentage[ui32DriverID]);
 
 	return 0;
 }
@@ -1556,7 +1413,7 @@ static IMG_INT64 VZTimeSliceSet(const IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
 {
 	const DI_VZ_DATA *psVZDriverData = (const DI_VZ_DATA*)pvData;
 	const IMG_UINT32 uiMaxBufferSize = 12;
-	IMG_UINT32 ui32TimeSlice;
+	IMG_UINT32 ui32TSPercentage;
 	PVRSRV_ERROR eError;
 
 	PVR_RETURN_IF_FALSE(pcBuffer != NULL, -EIO);
@@ -1565,13 +1422,13 @@ static IMG_INT64 VZTimeSliceSet(const IMG_CHAR *pcBuffer, IMG_UINT64 ui64Count,
 	PVR_RETURN_IF_FALSE(psVZDriverData != NULL, -EINVAL);
 	PVR_RETURN_IF_FALSE(psVZDriverData->psDevNode != NULL, -ENXIO);
 
-	if (OSStringToUINT32(pcBuffer, 10, &ui32TimeSlice) != PVRSRV_OK)
+	if (OSStringToUINT32(pcBuffer, 10, &ui32TSPercentage) != PVRSRV_OK)
 	{
 		return -EINVAL;
 	}
 
 	eError = PVRSRVRGXFWDebugSetDriverTimeSliceKM(NULL, psVZDriverData->psDevNode,
-												  psVZDriverData->ui32DriverID, ui32TimeSlice);
+												  psVZDriverData->ui32DriverID, ui32TSPercentage);
 	if (eError != PVRSRV_OK)
 	{
 		return -EIO;
@@ -1736,19 +1593,6 @@ PVRSRV_ERROR DebugCommonInitDriver(void)
 		PVR_GOTO_IF_ERROR(eError, return_error_);
 	}
 
-#ifdef SUPPORT_VALIDATION
-	{
-		DI_ITERATOR_CB sIterator = {
-			.pfnShow = TestMemLeakDIShow,
-			.pfnWrite = TestMemLeakDISet,
-			//Function only allows max 15 chars + Null terminator
-			.ui32WriteLenMax = ((15U)+1U)
-		};
-		eError = DICreateEntry("test_memleak", NULL, &sIterator, psPVRSRVData,
-		                       DI_ENTRY_TYPE_GENERIC, &gpsTestMemLeakDIEntry);
-		PVR_GOTO_IF_ERROR(eError, return_error_);
-	}
-#endif /* SUPPORT_VALIDATION */
 
 #if defined(DEBUG) || defined(PVR_DPF_ADHOC_DEBUG_ON)
 	{
@@ -1781,12 +1625,6 @@ void DebugCommonDeInitDriver(void)
 	}
 #endif /* defined(DEBUG) || defined(PVR_DPF_ADHOC_DEBUG_ON) */
 
-#ifdef SUPPORT_VALIDATION
-	if (gpsTestMemLeakDIEntry != NULL)
-	{
-		DIDestroyEntry(gpsTestMemLeakDIEntry);
-	}
-#endif /* SUPPORT_VALIDATION */
 
 	if (gpsStatusDIEntry != NULL)
 	{
@@ -1804,6 +1642,7 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_DEVICE_DEBUG_INFO *psDebugInfo = &psDeviceNode->sDebugInfo;
 	PVRSRV_ERROR eError;
 	IMG_CHAR pszDeviceId[sizeof("gpu4294967296")];
+	__maybe_unused PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 	OSSNPrintf(pszDeviceId, sizeof(pszDeviceId), "gpu%02d",
 	           psDeviceNode->sDevId.ui32InternalID);
@@ -1824,7 +1663,7 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 #ifdef SUPPORT_RGX
-	if (! PVRSRV_VZ_MODE_IS(GUEST))
+	if (! PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		{
 			DI_ITERATOR_CB sIterator = {.pfnShow = _DebugFWTraceDIShow};
@@ -1850,6 +1689,7 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		}
 #endif /* SUPPORT_FIRMWARE_GCOV */
 
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
 		{
 			DI_ITERATOR_CB sIterator = {.pfnShow = _FirmwareMappingsDIShow};
 			eError = DICreateEntry("firmware_mappings", psDebugInfo->psGroup, &sIterator,
@@ -1857,8 +1697,10 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 			                       &psDebugInfo->psFWMappingsEntry);
 			PVR_GOTO_IF_ERROR(eError, return_error_);
 		}
+#endif
 
-#if defined(SUPPORT_VALIDATION) || defined(SUPPORT_RISCV_GDB)
+#if  defined(SUPPORT_RISCV_GDB)
+		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
 		{
 			DI_ITERATOR_CB sIterator = {
 				.pfnRead = _RiscvDmiRead,
@@ -1873,7 +1715,7 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 #endif /* SUPPORT_VALIDATION || SUPPORT_RISCV_GDB */
 
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-		if (PVRSRV_VZ_MODE_IS(HOST))
+		if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode))
 		{
 			eError = DICreateGroup("vz", psDebugInfo->psGroup, &psDebugInfo->psVZGroup);
 			PVR_GOTO_IF_ERROR(eError, return_error_);
@@ -1918,8 +1760,8 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 				FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 				{
-					IMG_CHAR szDriverID[2];
-					OSSNPrintf(szDriverID, 2, "%u", ui32DriverID);
+					IMG_CHAR szDriverID[4];
+					OSSNPrintf(szDriverID, 4, "%u", ui32DriverID);
 
 					eError = DICreateGroup(szDriverID, psDebugInfo->psVZGroup, &psDebugInfo->apsVZDriverGroups[ui32DriverID]);
 					PVR_GOTO_IF_ERROR(eError, return_error_);
@@ -1960,23 +1802,8 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 				}
 			}
 		}
-#endif
-	}
-#ifdef SUPPORT_VALIDATION
-	{
-		DI_ITERATOR_CB sIterator = {
-			.pfnSeek = _RgxRegsSeek,
-			.pfnRead = _RgxRegsRead,
-			.pfnWrite = _RgxRegsWrite,
-			//Max size of input binary data is 4 bytes (UINT32) or 8 bytes (UINT64)
-			.ui32WriteLenMax = ((8U)+1U)
-		};
-		eError = DICreateEntry("rgxregs", psDebugInfo->psGroup, &sIterator, psDeviceNode,
-		                       DI_ENTRY_TYPE_RANDOM_ACCESS, &psDebugInfo->psRGXRegsEntry);
-
-		PVR_GOTO_IF_ERROR(eError, return_error_);
+#endif /* defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1 */
 	}
-#endif /* SUPPORT_VALIDATION */
 
 #ifdef SUPPORT_POWER_SAMPLING_VIA_DEBUGFS
 	{
@@ -2014,6 +1841,7 @@ PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 void DebugCommonDeInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_DEVICE_DEBUG_INFO *psDebugInfo = &psDeviceNode->sDebugInfo;
+	__maybe_unused PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	if (psDebugInfo->psPowerTimingStatsEntry != NULL)
@@ -2031,17 +1859,10 @@ void DebugCommonDeInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 #endif /* SUPPORT_POWER_SAMPLING_VIA_DEBUGFS */
 
-#ifdef SUPPORT_VALIDATION
-	if (psDebugInfo->psRGXRegsEntry != NULL)
-	{
-		DIDestroyEntry(psDebugInfo->psRGXRegsEntry);
-		psDebugInfo->psRGXRegsEntry = NULL;
-	}
-#endif /* SUPPORT_VALIDATION */
 
 #ifdef SUPPORT_RGX
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	if (PVRSRV_VZ_MODE_IS(HOST))
+	if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode))
 	{
 		IMG_UINT32 ui32DriverID;
 
@@ -2121,8 +1942,9 @@ void DebugCommonDeInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		psDebugInfo->psFWMappingsEntry = NULL;
 	}
 
-#if defined(SUPPORT_VALIDATION) || defined(SUPPORT_RISCV_GDB)
-	if (psDebugInfo->psRiscvDmiDIEntry != NULL)
+#if  defined(SUPPORT_RISCV_GDB)
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR) &&
+		(psDebugInfo->psRiscvDmiDIEntry != NULL))
 	{
 		DIDestroyEntry(psDebugInfo->psRiscvDmiDIEntry);
 		psDebugInfo->psRiscvDmiDIEntry = NULL;
diff --git a/drivers/gpu/drm/img-rogue/debug_common.h b/drivers/gpu/drm/img-rogue/debug_common.h
index c098696f740e..aba576d273a1 100644
--- a/drivers/gpu/drm/img-rogue/debug_common.h
+++ b/drivers/gpu/drm/img-rogue/debug_common.h
@@ -50,6 +50,8 @@ PVRSRV_ERROR DebugCommonInitDriver(void);
 void DebugCommonDeInitDriver(void);
 
 const IMG_CHAR *PVRSRVGetDebugDevStateString(PVRSRV_DEVICE_STATE eDevState);
+const IMG_CHAR *PVRSRVGetDebugHealthStatusString(PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus);
+const IMG_CHAR *PVRSRVGetDebugHealthReasonString(PVRSRV_DEVICE_HEALTH_REASON eHealthReason);
 
 PVRSRV_ERROR DebugCommonInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode);
 void DebugCommonDeInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode);
diff --git a/drivers/gpu/drm/img-rogue/device.h b/drivers/gpu/drm/img-rogue/device.h
index 20e8770aa507..4a6975b023cb 100644
--- a/drivers/gpu/drm/img-rogue/device.h
+++ b/drivers/gpu/drm/img-rogue/device.h
@@ -76,6 +76,7 @@ struct _CONNECTION_DATA_;
 
  @Input         psDeviceNode          Pointer to device node to allocate
                                       the UFO for.
+ @Input         ui32RequestedSize     Minimum size of allocation requested
  @Output        ppsMemDesc            Pointer to pointer for the memdesc of
                                       the allocation
  @Output        pui32SyncAddr         FW Base address of the UFO block
@@ -84,9 +85,10 @@ struct _CONNECTION_DATA_;
  @Return        PVRSRV_OK if allocation was successful
 */ /**************************************************************************/
 typedef PVRSRV_ERROR (*AllocUFOBlockCallback)(struct _PVRSRV_DEVICE_NODE_ *psDeviceNode,
-														DEVMEM_MEMDESC **ppsMemDesc,
-														IMG_UINT32 *pui32SyncAddr,
-														IMG_UINT32 *puiSyncPrimBlockSize);
+											  IMG_UINT32 ui32RequestedSize,
+											  DEVMEM_MEMDESC **ppsMemDesc,
+											  IMG_UINT32 *pui32SyncAddr,
+											  IMG_UINT32 *puiSyncPrimBlockSize);
 
 /*************************************************************************/ /*!
  @Function      FreeUFOBlockCallback
@@ -145,7 +147,7 @@ typedef struct __DEFAULT_PAGE__
 	X(ACTIVE)                    \
 	X(FROZEN)                    \
 	X(DEINIT)                    \
-	X(DEINIT_POWERED_OFF)        \
+	X(DESTRUCTING)               \
 	X(BAD)                       \
 	X(PCI_ERROR)                 \
 	X(LAST)                      \
@@ -158,27 +160,41 @@ typedef enum _PVRSRV_DEVICE_STATE_
 
 } PVRSRV_DEVICE_STATE;
 
+#define PVRSRV_DEVICE_HEALTH_STATUS_LIST \
+	X(UNDEFINED)                         \
+	X(OK)                                \
+	X(NOT_RESPONDING)                    \
+	X(DEAD)                              \
+	X(FAULT)                             \
+	X(LAST)                              \
+
 typedef enum _PVRSRV_DEVICE_HEALTH_STATUS_
 {
-	PVRSRV_DEVICE_HEALTH_STATUS_UNDEFINED = 0,
-	PVRSRV_DEVICE_HEALTH_STATUS_OK,
-	PVRSRV_DEVICE_HEALTH_STATUS_NOT_RESPONDING,
-	PVRSRV_DEVICE_HEALTH_STATUS_DEAD,
-	PVRSRV_DEVICE_HEALTH_STATUS_FAULT
+#define X(_name) PVRSRV_DEVICE_HEALTH_STATUS_ ## _name,
+	PVRSRV_DEVICE_HEALTH_STATUS_LIST
+#undef X
+
 } PVRSRV_DEVICE_HEALTH_STATUS;
 
+#define PVRSRV_DEVICE_HEALTH_REASON_LIST \
+	X(NONE)                              \
+	X(ASSERTED)                          \
+	X(POLL_FAILING)                      \
+	X(TIMEOUTS)                          \
+	X(QUEUE_CORRUPT)                     \
+	X(QUEUE_STALLED)                     \
+	X(IDLING)                            \
+	X(RESTARTING)                        \
+	X(MISSING_INTERRUPTS)                \
+	X(PCI_ERROR)                         \
+	X(LAST)                              \
+
 typedef enum _PVRSRV_DEVICE_HEALTH_REASON_
 {
-	PVRSRV_DEVICE_HEALTH_REASON_NONE = 0,
-	PVRSRV_DEVICE_HEALTH_REASON_ASSERTED,
-	PVRSRV_DEVICE_HEALTH_REASON_POLL_FAILING,
-	PVRSRV_DEVICE_HEALTH_REASON_TIMEOUTS,
-	PVRSRV_DEVICE_HEALTH_REASON_QUEUE_CORRUPT,
-	PVRSRV_DEVICE_HEALTH_REASON_QUEUE_STALLED,
-	PVRSRV_DEVICE_HEALTH_REASON_IDLING,
-	PVRSRV_DEVICE_HEALTH_REASON_RESTARTING,
-	PVRSRV_DEVICE_HEALTH_REASON_MISSING_INTERRUPTS,
-	PVRSRV_DEVICE_HEALTH_REASON_PCI_ERROR
+#define X(_name) PVRSRV_DEVICE_HEALTH_REASON_ ## _name,
+	PVRSRV_DEVICE_HEALTH_REASON_LIST
+#undef X
+
 } PVRSRV_DEVICE_HEALTH_REASON;
 
 typedef enum _PVRSRV_DEVICE_DEBUG_DUMP_STATUS_
@@ -213,16 +229,13 @@ typedef struct _PVRSRV_DEVICE_DEBUG_INFO_
 	DI_ENTRY *psFWGCOVEntry;
 #endif
 	DI_ENTRY *psFWMappingsEntry;
-#if defined(SUPPORT_VALIDATION) || defined(SUPPORT_RISCV_GDB)
+#if  defined(SUPPORT_RISCV_GDB)
 	DI_ENTRY *psRiscvDmiDIEntry;
 	IMG_UINT64 ui64RiscvDmi;
 #endif
 	DI_ENTRY *psDevMemEntry;
 	IMG_HANDLE hGpuUtilUserDebugFS;
 #endif /* SUPPORT_RGX */
-#ifdef SUPPORT_VALIDATION
-	DI_ENTRY *psRGXRegsEntry;
-#endif /* SUPPORT_VALIDATION */
 #ifdef SUPPORT_POWER_SAMPLING_VIA_DEBUGFS
 	DI_ENTRY *psPowerDataEntry;
 #endif
@@ -239,10 +252,6 @@ typedef struct _PVRSRV_DEVICE_DEBUG_INFO_
 	DI_VZ_DATA *apsVZDriverData[RGX_NUM_DRIVERS_SUPPORTED];
 	DI_ENTRY *psVZDriverConnectionCooldownPeriodDIEntry;
 #endif
-#if defined(PVR_TESTING_UTILS)
-	DI_ENTRY *psTestLBistDIEntry;
-	DI_ENTRY *psLBistNumWaitersDIEntry;
-#endif
 } PVRSRV_DEVICE_DEBUG_INFO;
 
 #if defined(PVRSRV_DEBUG_LISR_EXECUTION)
@@ -315,6 +324,14 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	POS_LOCK				hPowerLock;
 	IMG_PID                 uiPwrLockOwnerPID; /* Only valid between lock and corresponding unlock
 	                                              operations of hPowerLock */
+#if defined(DEBUG)
+	struct
+	{
+		const char        *pszFile;			    /* Power lock acquired location (File) */
+		IMG_UINT32         ui32LineNum;		    /* Power lock acquired location (Line number) */
+		IMG_UINT64         ui64Timestamp;       /* Power lock acquired timestamp */
+	} sPowerLockOwner;
+#endif
 
 #if defined(SUPPORT_PMR_DEFERRED_FREE) || defined(SUPPORT_MMU_DEFERRED_FREE)
 	IMG_UINT32              uiPowerOffCounter; /* Counts how many times the device has been powered
@@ -399,6 +416,8 @@ typedef struct _PVRSRV_DEVICE_NODE_
 
 	MMU_DEVICEATTRIBS* (*pfnGetMMUDeviceAttributes)(struct _PVRSRV_DEVICE_NODE_ *psDevNode, IMG_BOOL bKernelMemoryCtx);
 
+	PVRSRV_DEVICE_SNOOP_MODE (*pfnGetDeviceSnoopMode)(struct _PVRSRV_DEVICE_NODE_ *psDevNode);
+
 	PVRSRV_DEVICE_CONFIG	*psDevConfig;
 
 	/* device post-finalise compatibility check */
@@ -408,7 +427,7 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	PVRSRV_ERROR			(*pfnPhysMemDeviceHeapsInit) (struct _PVRSRV_DEVICE_NODE_ *);
 
 	/* determining the appropriate LMA allocation policy */
-	PHYS_HEAP_POLICY		(*pfnPhysHeapGetLMAPolicy) (PHYS_HEAP_USAGE_FLAGS);
+	PHYS_HEAP_POLICY		(*pfnPhysHeapGetLMAPolicy) (PHYS_HEAP_USAGE_FLAGS, struct _PVRSRV_DEVICE_NODE_ *psDevNode);
 
 	/* initialise fw mmu, if FW not using GPU mmu, NULL otherwise. */
 	PVRSRV_ERROR			(*pfnFwMMUInit) (struct _PVRSRV_DEVICE_NODE_ *);
@@ -528,13 +547,17 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	PVRSRV_DEF_PAGE			sScratchPage;
 	PVRSRV_DEF_PAGE			sDevZeroPage;
 
-	POSWR_LOCK				hMemoryContextPageFaultNotifyListLock;
+	/* Lock protects access to sMemoryContextPageFaultNotifyListHead and
+	 * per memory context DEVMEMINT_CTX::sProcessNotifyListHead lists. */
+	POSWR_LOCK				hPageFaultNotifyLock;
 	DLLIST_NODE				sMemoryContextPageFaultNotifyListHead;
 
-	/* System DMA capability */
-	IMG_BOOL				bHasSystemDMA;
+	/* System DMA channels */
+	IMG_UINT32				ui32RefCountDMA;
 	IMG_HANDLE				hDmaTxChan;
 	IMG_HANDLE				hDmaRxChan;
+	POS_LOCK				hDmaTxLock;
+	POS_LOCK				hDmaRxLock;
 
 #if defined(PDUMP)
 	/*
@@ -567,9 +590,6 @@ typedef struct _PVRSRV_DEVICE_NODE_
 
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	POS_LOCK			hValidationLock;
-#endif
 
 	/* Members for linking which connections are open on this device */
 	POS_LOCK                hConnectionsLock;    /*!< Lock protecting sConnections */
@@ -585,6 +605,7 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	IMG_BOOL                bEnablePFDebug;      /*!< EnablePageFaultDebug AppHint setting for device */
 
 	DLLIST_NODE             sCleanupThreadWorkList; /*!< List of work for the cleanup thread associated with the device */
+	ATOMIC_T                i32NumCleanupItems;   /*!< Number of cleanup thread work items. Includes items being freed. */
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
 	/* Data for the deferred freeing of a PMR physical pages for a given device */
 	DLLIST_NODE             sPMRZombieList;       /*!< List of PMRs to free */
@@ -599,6 +620,11 @@ typedef struct _PVRSRV_DEVICE_NODE_
 	ATOMIC_T                iFreezeCount;         /*< Number of blocked on frozen tasks */
 	ATOMIC_T                iTotalFreezes;        /*< Total number of times device frozen */
 	ATOMIC_T                iThreadsActive;       /*< Number of threads active on this device */
+	IMG_UINT64              ui64LastDeviceOffTimestamp; /* Last device power off timestamp */
+	IMG_UINT64              ui64LastDeviceOffHostTimestampNs; /* Last device power off host timestamp */
+#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+	IMG_BOOL bGPUWorkPeriodFTraceEnabled;
+#endif
 } PVRSRV_DEVICE_NODE;
 
 /*
diff --git a/drivers/gpu/drm/img-rogue/devicemem.c b/drivers/gpu/drm/img-rogue/devicemem.c
index 09765b599cc4..916485b77ec1 100644
--- a/drivers/gpu/drm/img-rogue/devicemem.c
+++ b/drivers/gpu/drm/img-rogue/devicemem.c
@@ -163,10 +163,6 @@ DevmemOverrideFlagsOrPassThrough(SHARED_DEV_CONNECTION hDevConnection, PVRSRV_ME
 	 *  Override the requested memory flags of FW allocations only,
 	 *  non-FW allocations pass-through unmodified.
 	 *
-	 *  On fully coherent platforms:
-	 *    - We upgrade uncached, CPU-only cached or GPU-only cached to
-	 *      full coherency. This gives caching improvements for free.
-	 *
 	 *  On ace-lite platforms:
 	 *    - If the allocation is not CPU cached, then there is nothing
 	 *      for the GPU to snoop regardless of the GPU cache setting.
@@ -185,14 +181,7 @@ DevmemOverrideFlagsOrPassThrough(SHARED_DEV_CONNECTION hDevConnection, PVRSRV_ME
 	{
 		if (PVRSRV_CHECK_FW_MAIN(uiFlags))
 		{
-			if (PVRSRVSystemSnoopingOfDeviceCache(psDevNode->psDevConfig) &&
-			    PVRSRVSystemSnoopingOfCPUCache(psDevNode->psDevConfig))
-			{
-				/* Clear existing flags, mark the allocation as fully coherent. */
-				uiFlags &= ~(PVRSRV_MEMALLOCFLAG_CPU_CACHE_MODE_MASK | PVRSRV_MEMALLOCFLAG_GPU_CACHE_MODE_MASK);
-				uiFlags |= PVRSRV_MEMALLOCFLAG_CACHE_COHERENT;
-			}
-			else if ((PVRSRV_CHECK_CPU_CACHE_COHERENT(uiFlags) || PVRSRV_CHECK_CPU_CACHE_INCOHERENT(uiFlags)) &&
+			if ((PVRSRV_CHECK_CPU_CACHE_COHERENT(uiFlags) || PVRSRV_CHECK_CPU_CACHE_INCOHERENT(uiFlags)) &&
 			         (PVRSRV_CHECK_GPU_CACHE_INCOHERENT(uiFlags)) &&
 			         PVRSRVSystemSnoopingOfCPUCache(psDevNode->psDevConfig) &&
 			         psDevNode->eDevFabricType == PVRSRV_DEVICE_FABRIC_ACELITE)
@@ -312,29 +301,29 @@ DeviceMemChangeSparse(DEVMEM_MEMDESC *psMemDesc,
 		SPARSE_MEM_RESIZE_FLAGS uiSparseFlags)
 {
 	PVRSRV_ERROR eError;
-	DEVMEM_IMPORT *psImport = psMemDesc->psImport;
+	DEVMEM_IMPORT *psImport;
 	SHARED_DEV_CONNECTION hDevConnection;
 	IMG_HANDLE hPMR;
 	DEVMEM_HEAP *psHeap;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_CPU_VIRTADDR pvCpuVAddr;
+	IMG_HANDLE hReservation;
 #ifdef PVRSRV_NEED_PVR_ASSERT
 	DEVMEM_PROPERTIES_T uiProperties;
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
-	PVR_ASSERT(psImport != NULL);
+	PVR_ASSERT(psMemDesc != NULL);
+	PVR_ASSERT(psMemDesc->psImport != NULL);
 
+	psImport = psMemDesc->psImport;
 	hDevConnection = psImport->hDevConnection;
 	hPMR = psImport->hPMR;
 	psHeap = psImport->sDeviceImport.psHeap;
-	sDevVAddr = psImport->sDeviceImport.sDevVAddr;
-	pvCpuVAddr = psImport->sCPUImport.pvCPUVAddr;
+	hReservation = psImport->sDeviceImport.hReservation;
 
 	PVR_ASSERT(hDevConnection != NULL);
 	PVR_ASSERT(hPMR != NULL);
 	PVR_ASSERT(psHeap != NULL);
-	PVR_ASSERT(!BITMASK_HAS(uiSparseFlags, SPARSE_RESIZE_BOTH) || (sDevVAddr.uiAddr != 0));
-	PVR_ASSERT(!BITMASK_HAS(uiSparseFlags, SPARSE_MAP_CPU_ADDR) || (pvCpuVAddr == NULL));
+	PVR_ASSERT(BITMASK_ANY(uiSparseFlags, SPARSE_RESIZE_BOTH));
+	PVR_ASSERT(hReservation != LACK_OF_RESERVATION_POISON);
 
 #ifdef PVRSRV_NEED_PVR_ASSERT
 	uiProperties = GetImportProperties(psMemDesc->psImport);
@@ -343,23 +332,17 @@ DeviceMemChangeSparse(DEVMEM_MEMDESC *psMemDesc,
 	PVR_ASSERT(!BITMASK_HAS(uiProperties, DEVMEM_PROPERTIES_NO_LAYOUT_CHANGE));
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
-#ifdef PVRSRV_UNMAP_ON_SPARSE_CHANGE
 	PVR_ASSERT(psMemDesc->sCPUMemDesc.ui32RefCount == 0);
-#endif
 
 	OSLockAcquire(psImport->hLock);
 
 	eError = BridgeChangeSparseMem(GetBridgeHandle(hDevConnection),
-	                               psHeap->hDevMemServerHeap,
-	                               hPMR,
 	                               ui32AllocPageCount,
 	                               paui32AllocPageIndices,
 	                               ui32FreePageCount,
 	                               pauiFreePageIndices,
 	                               uiSparseFlags,
-	                               psImport->uiFlags,
-	                               sDevVAddr,
-	                               (IMG_UINT64) ((uintptr_t) pvCpuVAddr));
+	                               hReservation);
 
 	OSLockRelease(psImport->hLock);
 
@@ -398,9 +381,7 @@ SubAllocImportAlloc(RA_PERARENA_HANDLE hArena,
 		RA_LENGTH_T uBaseAlignment,
 		const IMG_CHAR *pszAnnotation,
 		/* returned data */
-		RA_BASE_T *puiBase,
-		RA_LENGTH_T *puiActualSize,
-		RA_PERISPAN_HANDLE *phImport)
+		RA_IMPORT *psRAImport)
 {
 	/* When suballocations need a new lump of memory, the RA calls
 	   back here.  Later, in the kernel, we must construct a new PMR
@@ -508,9 +489,9 @@ SubAllocImportAlloc(RA_PERARENA_HANDLE hArena,
 	psImport->uiProperties |= DEVMEM_PROPERTIES_IMPORT_IS_CLEAN;
 	OSLockRelease(psImport->hLock);
 
-	*puiBase = psImport->sDeviceImport.sDevVAddr.uiAddr;
-	*puiActualSize = uiSize;
-	*phImport = psImport;
+	psRAImport->base = psImport->sDeviceImport.sDevVAddr.uiAddr;
+	psRAImport->uSize = uiSize;
+	psRAImport->hPriv = psImport;
 
 	return PVRSRV_OK;
 
@@ -965,13 +946,13 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 	PVR_ASSERT(uiReservedRegionLength + DEVMEM_HEAP_MINIMUM_SIZE <= uiLength);
 
 	psHeap = OSAllocMem(sizeof(*psHeap));
-	PVR_GOTO_IF_NOMEM(psHeap, eError, e0);
+	PVR_GOTO_IF_NOMEM(psHeap, eError, HeapAllocError);
 
 	/* Need to keep local copy of heap name, so caller may free theirs */
 	ui32pszStrSize = OSStringLength(pszName) + 1;
 	pszStr = OSAllocMem(ui32pszStrSize);
-	PVR_GOTO_IF_NOMEM(pszStr, eError, e1);
-	OSStringLCopy(pszStr, pszName, ui32pszStrSize);
+	PVR_GOTO_IF_NOMEM(pszStr, eError, SubAllocRANameCopyError);
+	OSStringSafeCopy(pszStr, pszName, ui32pszStrSize);
 	psHeap->pszName = pszStr;
 
 	psHeap->uiSize = uiLength;
@@ -985,8 +966,8 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 			pszName, psCtx);
 	ui32pszStrSize = OSStringLength(aszBuf) + 1;
 	pszStr = OSAllocMem(ui32pszStrSize);
-	PVR_GOTO_IF_NOMEM(pszStr, eError, e2);
-	OSStringLCopy(pszStr, aszBuf, ui32pszStrSize);
+	PVR_GOTO_IF_NOMEM(pszStr, eError, SubAllocRANameError);
+	OSStringSafeCopy(pszStr, aszBuf, ui32pszStrSize);
 	psHeap->pszSubAllocRAName = pszStr;
 
 #if defined(__KERNEL__)
@@ -1036,7 +1017,7 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 	psHeap->psSubAllocRA = RA_Create(psHeap->pszSubAllocRAName,
 			/* Subsequent imports: */
 			ui32Log2Quantum,
-			RA_LOCKCLASS_2,
+			RA_LOCKCLASS_3,
 			SubAllocImportAlloc,
 			SubAllocImportFree,
 			(RA_PERARENA_HANDLE) psHeap,
@@ -1044,7 +1025,7 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 	if (psHeap->psSubAllocRA == NULL)
 	{
 		eError = PVRSRV_ERROR_DEVICEMEM_UNABLE_TO_CREATE_ARENA;
-		goto e3;
+		goto SubAllocRACreateError;
 	}
 
 	psHeap->uiLog2ImportAlignment = ui32Log2ImportAlignment;
@@ -1087,9 +1068,9 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 	if (pszStr == NULL)
 	{
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto e4;
+		goto VMRANameError;
 	}
-	OSStringLCopy(pszStr, aszBuf, ui32pszStrSize);
+	OSStringSafeCopy(pszStr, aszBuf, ui32pszStrSize);
 	psHeap->pszQuantizedVMRAName = pszStr;
 
 	psHeap->psQuantizedVMRA = RA_Create(psHeap->pszQuantizedVMRAName,
@@ -1099,7 +1080,7 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 			ui32PolicyVMRA);
 	if (psHeap->psQuantizedVMRA == NULL)
 	{
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_UNABLE_TO_CREATE_ARENA, e5);
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_UNABLE_TO_CREATE_ARENA, VMRACreateError);
 	}
 
 	if (!RA_Add(psHeap->psQuantizedVMRA,
@@ -1110,7 +1091,7 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 			NULL /* per ispan handle */))
 	{
 		RA_Delete(psHeap->psQuantizedVMRA);
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_UNABLE_TO_CREATE_ARENA, e5);
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_UNABLE_TO_CREATE_ARENA, VMRACreateError);
 	}
 
 	psHeap->psCtx = psCtx;
@@ -1118,48 +1099,40 @@ DevmemCreateHeap(DEVMEM_CONTEXT *psCtx,
 
 	/* Create server-side counterpart of Device Memory heap */
 	eError = BridgeDevmemIntHeapCreate(GetBridgeHandle(psCtx->hDevConnection),
-			psCtx->hDevMemServerContext,
-			uiHeapBlueprintID,
-			uiHeapIndex,
-			sBaseAddress,
-			ui32Log2Quantum,
-			&hDevMemServerHeap);
-	PVR_GOTO_IF_ERROR(eError, e6);
+	                                   psCtx->hDevMemServerContext,
+	                                   uiHeapBlueprintID,
+	                                   uiHeapIndex,
+	                                   &hDevMemServerHeap);
+	PVR_GOTO_IF_ERROR(eError, ServerHeapCreateError);
 
 	psHeap->hDevMemServerHeap = hDevMemServerHeap;
 
 	eError = OSLockCreate(&psHeap->hLock);
-	PVR_GOTO_IF_ERROR(eError, e7);
+	PVR_GOTO_IF_ERROR(eError, LockCreateErr);
 
 	psHeap->psCtx->uiNumHeaps++;
 	*ppsHeapPtr = psHeap;
 
-#if defined(PVRSRV_NEWDEVMEM_SUPPORT_MEM_TRACKING)
-	psHeap->psMemDescList = NULL;
-#endif /* PVRSRV_NEWDEVMEM_SUPPORT_MEM_TRACKING */
-
 	return PVRSRV_OK;
 
 	/* error exit paths */
-e7:
+LockCreateErr:
 	eError2 = BridgeDevmemIntHeapDestroy(GetBridgeHandle(psCtx->hDevConnection),
 			psHeap->hDevMemServerHeap);
 	PVR_ASSERT (eError2 == PVRSRV_OK);
-e6:
-	if (psHeap->psQuantizedVMRA)
-		RA_Delete(psHeap->psQuantizedVMRA);
-e5:
-	if (psHeap->pszQuantizedVMRAName)
-		OSFreeMem(psHeap->pszQuantizedVMRAName);
-e4:
+ServerHeapCreateError:
+	RA_Delete(psHeap->psQuantizedVMRA);
+VMRACreateError:
+	OSFreeMem(psHeap->pszQuantizedVMRAName);
+VMRANameError:
 	RA_Delete(psHeap->psSubAllocRA);
-e3:
+SubAllocRACreateError:
 	OSFreeMem(psHeap->pszSubAllocRAName);
-e2:
+SubAllocRANameError:
 	OSFreeMem(psHeap->pszName);
-e1:
+SubAllocRANameCopyError:
 	OSFreeMem(psHeap);
-e0:
+HeapAllocError:
 	PVR_ASSERT(eError != PVRSRV_OK);
 	return eError;
 }
@@ -1452,7 +1425,7 @@ DevmemSubAllocate(IMG_UINT8 uiPreAllocMultiplier,
 	 * if it is not.
 	 * */
 	OSLockAcquire(psImport->hLock);
-	if (!(uiSize & ((1ULL << psHeap->uiLog2Quantum) - 1)) &&
+	if (!(uiSize & (IMG_PAGE2BYTES64(psHeap->uiLog2Quantum) - 1)) &&
 	    (uiPreAllocMultiplier == RA_NO_IMPORT_MULTIPLIER))
 	{
 		psImport->uiProperties |= DEVMEM_PROPERTIES_EXPORTABLE;
@@ -1557,7 +1530,7 @@ DevmemSubAllocate(IMG_UINT8 uiPreAllocMultiplier,
 	 * the allocation gets mapped/unmapped
 	 */
 	CheckAnnotationLength(pszText);
-	OSStringLCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
+	OSStringSafeCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
 	if (PVRSRVIsBridgeEnabled(GetBridgeHandle(psMemDesc->psImport->hDevConnection), PVRSRV_BRIDGE_RI))
@@ -1569,10 +1542,13 @@ DevmemSubAllocate(IMG_UINT8 uiPreAllocMultiplier,
 				psMemDesc->szText,
 				psMemDesc->uiOffset,
 				uiAllocatedSize,
-				IMG_FALSE,
-				IMG_TRUE,
+				uiFlags | PVRSRV_MEMALLOCFLAG_RI_SUBALLOC,
 				&(psMemDesc->hRIHandle));
-		PVR_LOG_IF_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
+		if (eError != PVRSRV_OK)
+		{
+			PVR_LOG_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
+			psMemDesc->hRIHandle = NULL;
+		}
 	}
 #else /* if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO) */
 	PVR_UNREFERENCED_PARAMETER (pszText);
@@ -1675,7 +1651,7 @@ DevmemAllocateExportable(SHARED_DEV_CONNECTION hDevConnection,
 	 * the allocation gets mapped/unmapped
 	 */
 	CheckAnnotationLength(pszText);
-	OSStringLCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
+	OSStringSafeCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
 	if (PVRSRVIsBridgeEnabled(GetBridgeHandle(psImport->hDevConnection), PVRSRV_BRIDGE_RI))
@@ -1691,8 +1667,7 @@ DevmemAllocateExportable(SHARED_DEV_CONNECTION hDevConnection,
 				"^",
 				psMemDesc->uiOffset,
 				uiSize,
-				IMG_FALSE,
-				IMG_FALSE,
+				uiFlags,
 				&psMemDesc->hRIHandle);
 		PVR_LOG_IF_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
 	}
@@ -1785,7 +1760,7 @@ DevmemAllocateSparse(SHARED_DEV_CONNECTION hDevConnection,
 	 * the allocation gets mapped/unmapped
 	 */
 	CheckAnnotationLength(pszText);
-	OSStringLCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
+	OSStringSafeCopy(psMemDesc->szText, pszText, DEVMEM_ANNOTATION_MAX_LEN);
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
 	if (PVRSRVIsBridgeEnabled(GetBridgeHandle(psImport->hDevConnection), PVRSRV_BRIDGE_RI))
@@ -1801,8 +1776,7 @@ DevmemAllocateSparse(SHARED_DEV_CONNECTION hDevConnection,
 				"^",
 				psMemDesc->uiOffset,
 				uiSize,
-				IMG_FALSE,
-				IMG_FALSE,
+				uiFlags,
 				&psMemDesc->hRIHandle);
 		PVR_LOG_IF_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
 	}
@@ -2036,8 +2010,7 @@ DevmemImport(SHARED_DEV_CONNECTION hDevConnection,
 				"^",
 				psMemDesc->uiOffset,
 				psMemDesc->psImport->uiSize,
-				IMG_TRUE,
-				IMG_TRUE,
+				uiFlags | PVRSRV_MEMALLOCFLAG_RI_IMPORT | PVRSRV_MEMALLOCFLAG_RI_SUBALLOC,
 				&psMemDesc->hRIHandle);
 		PVR_LOG_IF_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
 	}
@@ -2664,8 +2637,7 @@ DevmemLocalImport(SHARED_DEV_CONNECTION hDevConnection,
 				"^",
 				psMemDesc->uiOffset,
 				psMemDesc->psImport->uiSize,
-				IMG_TRUE,
-				IMG_FALSE,
+				uiFlags | PVRSRV_MEMALLOCFLAG_RI_IMPORT,
 				&(psMemDesc->hRIHandle));
 		PVR_LOG_IF_ERROR(eError, "BridgeRIWriteMEMDESCEntry");
 	}
@@ -2676,7 +2648,7 @@ DevmemLocalImport(SHARED_DEV_CONNECTION hDevConnection,
 	 * to DevicememHistory when the allocation gets mapped/unmapped
 	 */
 	CheckAnnotationLength(pszAnnotation);
-	OSStringLCopy(psMemDesc->szText, pszAnnotation, DEVMEM_ANNOTATION_MAX_LEN);
+	OSStringSafeCopy(psMemDesc->szText, pszAnnotation, DEVMEM_ANNOTATION_MAX_LEN);
 
 	return PVRSRV_OK;
 
@@ -2777,3 +2749,7 @@ DevmemHeapSetPremapStatus(DEVMEM_HEAP *psHeap, IMG_BOOL IsPremapped)
 {
 	psHeap->bPremapped = IsPremapped;
 }
+
+/******************************************************************************
+ End of file (devicemem.c)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/devicemem_heapcfg.c b/drivers/gpu/drm/img-rogue/devicemem_heapcfg.c
index 1234f76a60c2..9b53d026bb5d 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_heapcfg.c
+++ b/drivers/gpu/drm/img-rogue/devicemem_heapcfg.c
@@ -123,6 +123,8 @@ HeapCfgHeapCount(CONNECTION_DATA * psConnection,
 				 IMG_UINT32 uiHeapConfigIndex,
 				 IMG_UINT32 *puiNumHeapsOut)
 {
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	if (uiHeapConfigIndex >= psDeviceNode->sDevMemoryInfo.uiNumHeapConfigs)
 	{
 		return PVRSRV_ERROR_DEVICEMEM_INVALID_HEAP_CONFIG_INDEX;
@@ -140,6 +142,8 @@ HeapCfgHeapConfigName(CONNECTION_DATA * psConnection,
 					  IMG_UINT32 uiHeapConfigNameBufSz,
 					  IMG_CHAR *pszHeapConfigNameOut)
 {
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	if (uiHeapConfigIndex >= psDeviceNode->sDevMemoryInfo.uiNumHeapConfigs)
 	{
 		return PVRSRV_ERROR_DEVICEMEM_INVALID_HEAP_CONFIG_INDEX;
@@ -196,6 +200,8 @@ HeapCfgHeapDetails(CONNECTION_DATA * psConnection,
 {
 	DEVMEM_HEAP_BLUEPRINT *psHeapBlueprint;
 
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	if (uiHeapConfigIndex >= psDeviceNode->sDevMemoryInfo.uiNumHeapConfigs)
 	{
 		return PVRSRV_ERROR_DEVICEMEM_INVALID_HEAP_CONFIG_INDEX;
diff --git a/drivers/gpu/drm/img-rogue/devicemem_heapcfg.h b/drivers/gpu/drm/img-rogue/devicemem_heapcfg.h
index bf49a07cbefd..3b8c0aa08921 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_heapcfg.h
+++ b/drivers/gpu/drm/img-rogue/devicemem_heapcfg.h
@@ -49,16 +49,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "img_types.h"
 #include "pvrsrv_error.h"
 
-/*
- *  Supported log2 page size values for RGX_GENERAL_NON_4K_HEAP_ID
- */
-#define RGX_HEAP_4KB_PAGE_SHIFT					(12U)
-#define RGX_HEAP_16KB_PAGE_SHIFT				(14U)
-#define RGX_HEAP_64KB_PAGE_SHIFT				(16U)
-#define RGX_HEAP_256KB_PAGE_SHIFT				(18U)
-#define RGX_HEAP_1MB_PAGE_SHIFT					(20U)
-#define RGX_HEAP_2MB_PAGE_SHIFT					(21U)
-
 struct _PVRSRV_DEVICE_NODE_;
 struct _CONNECTION_DATA_;
 struct _DEVMEMINT_HEAP_;
diff --git a/drivers/gpu/drm/img-rogue/devicemem_history_server.c b/drivers/gpu/drm/img-rogue/devicemem_history_server.c
index e84e75e7c7d8..f28e96fa55e1 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_history_server.c
+++ b/drivers/gpu/drm/img-rogue/devicemem_history_server.c
@@ -772,7 +772,7 @@ static void InitialiseAllocation(RECORD_ALLOCATION *psAlloc,
 							IMG_DEVMEM_SIZE_T uiSize,
 							IMG_UINT32 ui32Log2PageSize)
 {
-	OSStringLCopy(psAlloc->szName, pszName, sizeof(psAlloc->szName));
+	OSStringSafeCopy(psAlloc->szName, pszName, sizeof(psAlloc->szName));
 	psAlloc->ui64Serial = ui64Serial;
 	psAlloc->uiPID = uiPID;
 	psAlloc->sDevVAddr = sDevVAddr;
@@ -792,7 +792,6 @@ static PVRSRV_ERROR CreateAllocation(PVRSRV_DEVICE_NODE *psDeviceNode,
 							IMG_DEV_VIRTADDR sDevVAddr,
 							IMG_DEVMEM_SIZE_T uiSize,
 							IMG_UINT32 ui32Log2PageSize,
-							IMG_BOOL bAutoPurge,
 							IMG_UINT32 *puiAllocationIndex)
 {
 	IMG_UINT32 ui32Alloc;
@@ -841,8 +840,7 @@ static IMG_BOOL MatchAllocation(DEVICEMEM_HISTORY_DATA *psDevHData,
 						IMG_DEV_VIRTADDR sDevVAddr,
 						IMG_DEVMEM_SIZE_T uiSize,
 						const IMG_CHAR *pszName,
-						IMG_UINT32 ui32Log2PageSize,
-						IMG_PID uiPID)
+						IMG_UINT32 ui32Log2PageSize)
 {
 	RECORD_ALLOCATION *psAlloc;
 
@@ -874,7 +872,6 @@ static PVRSRV_ERROR FindOrCreateAllocation(PVRSRV_DEVICE_NODE *psDeviceNode,
 							const char *pszName,
 							IMG_UINT32 ui32Log2PageSize,
 							IMG_PID uiPID,
-							IMG_BOOL bSparse,
 							IMG_UINT32 *pui32AllocationIndexOut,
 							IMG_BOOL *pbCreated)
 {
@@ -895,8 +892,7 @@ static PVRSRV_ERROR FindOrCreateAllocation(PVRSRV_DEVICE_NODE *psDeviceNode,
 								sDevVAddr,
 								uiSize,
 								pszName,
-								ui32Log2PageSize,
-								uiPID);
+								ui32Log2PageSize);
 		if (bHaveAllocation)
 		{
 			*pbCreated = IMG_FALSE;
@@ -915,7 +911,6 @@ static PVRSRV_ERROR FindOrCreateAllocation(PVRSRV_DEVICE_NODE *psDeviceNode,
 					sDevVAddr,
 					uiSize,
 					ui32Log2PageSize,
-					IMG_TRUE,
 					&ui32AllocationIndex);
 
 	if (eError == PVRSRV_OK)
@@ -966,7 +961,7 @@ static void GenerateMapUnmapCommandsForSparsePMR(PMR *psPMR,
 		return;
 	}
 
-	for (i = 0; i < psMappingTable->ui32NumVirtChunks; i++)
+	for (i = 0; i < psMappingTable->ui32NumLogicalChunks; i++)
 	{
 		if (psMappingTable->aui32Translation[i] != TRANSLATION_INVALID)
 		{
@@ -991,7 +986,7 @@ static void GenerateMapUnmapCommandsForSparsePMR(PMR *psPMR,
 			 */
 			if ((psMappingTable->aui32Translation[i] == TRANSLATION_INVALID) ||
 				(ui32RunCount == MAP_RANGE_MAX_RANGE) ||
-				(i == (psMappingTable->ui32NumVirtChunks - 1)))
+				(i == (psMappingTable->ui32NumLogicalChunks - 1)))
 			{
 				if (bMap)
 				{
@@ -1110,12 +1105,14 @@ PVRSRV_ERROR DevicememHistoryMapKM(PMR *psPMR,
 							IMG_UINT32 *pui32AllocationIndexOut)
 {
 	IMG_BOOL bSparse = PMR_IsSparse(psPMR);
-	IMG_UINT64 ui64Serial;
+	IMG_UINT64 ui64Serial = PMRInternalGetUID(psPMR);
 	IMG_PID uiPID = OSGetCurrentClientProcessIDKM();
 	PVRSRV_ERROR eError;
 	IMG_BOOL bCreated;
 	DEVICEMEM_HISTORY_DATA *psDevHData;
 
+	PVR_UNREFERENCED_PARAMETER(ui32Offset);
+
 	if ((ui32AllocationIndex != DEVICEMEM_HISTORY_ALLOC_INDEX_NONE) &&
 		!CHECK_ALLOC_INDEX(ui32AllocationIndex))
 	{
@@ -1125,8 +1122,6 @@ PVRSRV_ERROR DevicememHistoryMapKM(PMR *psPMR,
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	PMRGetUID(psPMR, &ui64Serial);
-
 	psDevHData = DevmemFindDataFromDev(PMR_DeviceNode(psPMR));
 
 	if (psDevHData == NULL)
@@ -1144,7 +1139,6 @@ PVRSRV_ERROR DevicememHistoryMapKM(PMR *psPMR,
 						szName,
 						ui32Log2PageSize,
 						uiPID,
-						bSparse,
 						&ui32AllocationIndex,
 						&bCreated);
 
@@ -1191,6 +1185,8 @@ static void VRangeInsertMapUnmapCommands(PVRSRV_DEVICE_NODE *psDeviceNode,
 							IMG_UINT32 ui32NumPages,
 							const IMG_CHAR *pszName)
 {
+	PVR_UNREFERENCED_PARAMETER(pszName);
+
 	while (ui32NumPages > 0)
 	{
 		IMG_UINT32 ui32PagesToAdd;
@@ -1271,7 +1267,6 @@ PVRSRV_ERROR DevicememHistoryMapVRangeKM(CONNECTION_DATA *psConnection,
 						szName,
 						ui32Log2PageSize,
 						uiPID,
-						IMG_FALSE,
 						&ui32AllocationIndex,
 						&bCreated);
 
@@ -1350,7 +1345,6 @@ PVRSRV_ERROR DevicememHistoryUnmapVRangeKM(CONNECTION_DATA *psConnection,
 						szName,
 						ui32Log2PageSize,
 						uiPID,
-						IMG_FALSE,
 						&ui32AllocationIndex,
 						&bCreated);
 
@@ -1411,12 +1405,14 @@ PVRSRV_ERROR DevicememHistoryUnmapKM(PMR *psPMR,
 							IMG_UINT32 *pui32AllocationIndexOut)
 {
 	IMG_BOOL bSparse = PMR_IsSparse(psPMR);
-	IMG_UINT64 ui64Serial;
+	IMG_UINT64 ui64Serial = PMRInternalGetUID(psPMR);
 	IMG_PID uiPID = OSGetCurrentClientProcessIDKM();
 	PVRSRV_ERROR eError;
 	IMG_BOOL bCreated;
 	DEVICEMEM_HISTORY_DATA *psDevHData;
 
+	PVR_UNREFERENCED_PARAMETER(ui32Offset);
+
 	if ((ui32AllocationIndex != DEVICEMEM_HISTORY_ALLOC_INDEX_NONE) &&
 		!CHECK_ALLOC_INDEX(ui32AllocationIndex))
 	{
@@ -1426,8 +1422,6 @@ PVRSRV_ERROR DevicememHistoryUnmapKM(PMR *psPMR,
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	PMRGetUID(psPMR, &ui64Serial);
-
 	psDevHData = DevmemFindDataFromDev(PMR_DeviceNode(psPMR));
 
 	if (psDevHData == NULL)
@@ -1445,7 +1439,6 @@ PVRSRV_ERROR DevicememHistoryUnmapKM(PMR *psPMR,
 						szName,
 						ui32Log2PageSize,
 						uiPID,
-						bSparse,
 						&ui32AllocationIndex,
 						&bCreated);
 
@@ -1517,12 +1510,14 @@ PVRSRV_ERROR DevicememHistorySparseChangeKM(PMR *psPMR,
 							IMG_UINT32 ui32AllocationIndex,
 							IMG_UINT32 *pui32AllocationIndexOut)
 {
-	IMG_UINT64 ui64Serial;
+	IMG_UINT64 ui64Serial = PMRInternalGetUID(psPMR);
 	IMG_PID uiPID = OSGetCurrentClientProcessIDKM();
 	PVRSRV_ERROR eError;
 	IMG_BOOL bCreated;
 	DEVICEMEM_HISTORY_DATA *psDevHData;
 
+	PVR_UNREFERENCED_PARAMETER(ui32Offset);
+
 	if (!PMRValidateSize((IMG_UINT64) ui32AllocPageCount << ui32Log2PageSize))
 	{
 		PVR_LOG_VA(PVR_DBG_ERROR,
@@ -1541,8 +1536,6 @@ PVRSRV_ERROR DevicememHistorySparseChangeKM(PMR *psPMR,
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	PMRGetUID(psPMR, &ui64Serial);
-
 	psDevHData = DevmemFindDataFromDev(PMR_DeviceNode(psPMR));
 
 	if (psDevHData == NULL)
@@ -1560,7 +1553,6 @@ PVRSRV_ERROR DevicememHistorySparseChangeKM(PMR *psPMR,
 						szName,
 						ui32Log2PageSize,
 						uiPID,
-						IMG_TRUE /* bSparse */,
 						&ui32AllocationIndex,
 						&bCreated);
 
@@ -1901,7 +1893,7 @@ IMG_BOOL DevicememHistoryQuery(DEVICEMEM_HISTORY_QUERY_IN *psQueryIn,
 			{
 				DEVICEMEM_HISTORY_QUERY_OUT_RESULT *psResult = &psQueryOut->sResults[psQueryOut->ui32NumResults];
 
-				OSStringLCopy(psResult->szString, psAlloc->szName, sizeof(psResult->szString));
+				OSStringSafeCopy(psResult->szString, psAlloc->szName, sizeof(psResult->szString));
 				psResult->sBaseDevVAddr = psAlloc->sDevVAddr;
 				psResult->uiSize = psAlloc->uiSize;
 				psResult->bMap = bMap;
@@ -2118,7 +2110,7 @@ static int DevicememHistoryPrintAllWrapper(OSDI_IMPL_ENTRY *psEntry,
 static PVRSRV_ERROR CreateRecords(DEVICEMEM_HISTORY_DATA *psDevHData)
 {
 	psDevHData->sRecords.pasAllocations =
-			OSAllocMemNoStats(sizeof(RECORD_ALLOCATION) * ALLOCATION_LIST_NUM_ENTRIES);
+			OSAllocZMemNoStats(sizeof(RECORD_ALLOCATION) * ALLOCATION_LIST_NUM_ENTRIES);
 
 	PVR_RETURN_IF_NOMEM(psDevHData->sRecords.pasAllocations);
 
diff --git a/drivers/gpu/drm/img-rogue/devicemem_server.c b/drivers/gpu/drm/img-rogue/devicemem_server.c
index e43f686308ce..67e7c4fafbda 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_server.c
+++ b/drivers/gpu/drm/img-rogue/devicemem_server.c
@@ -66,8 +66,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define DEVMEMCTX_FLAGS_FAULT_ADDRESS_AVAILABLE (1 << 0)
 #define DEVMEMHEAP_REFCOUNT_MIN 1
 #define DEVMEMHEAP_REFCOUNT_MAX IMG_INT32_MAX
-#define DEVMEMRESERVATION_REFCOUNT_MIN 0
+#define DEVMEMRESERVATION_REFCOUNT_MIN 1
 #define DEVMEMRESERVATION_REFCOUNT_MAX IMG_INT32_MAX
+#define DEVMEMCTX_REFCOUNT_MIN 1
+#define DEVMEMCTX_REFCOUNT_MAX IMG_INT32_MAX
 
 struct _DEVMEMINT_CTX_
 {
@@ -80,25 +82,30 @@ struct _DEVMEMINT_CTX_
 	   know about us at all. */
 	MMU_CONTEXT *psMMUContext;
 
-	ATOMIC_T hRefCount;
-
 	/* This handle is for devices that require notification when a new
 	   memory context is created and they need to store private data that
 	   is associated with the context. */
 	IMG_HANDLE hPrivData;
 
-	/* Protects access to sProcessNotifyListHead */
-	POSWR_LOCK hListLock;
-
 	/* The following tracks UM applications that need to be notified of a
-	 * page fault */
+	 * page fault.
+	 * Access to this list is protected by lock defined on a device node:
+	 * PVRSRV_DEVICE_NODE::hPageFaultNotifyLock. */
 	DLLIST_NODE sProcessNotifyListHead;
-	/* The following is a node for the list of registered devmem contexts */
+	/* The following is a node for the list of registered devmem contexts.
+	 * Access to this list is protected by lock defined on a device node:
+	 * PVRSRV_DEVICE_NODE::hPageFaultNotifyLock. */
 	DLLIST_NODE sPageFaultNotifyListElem;
 
 	/* Device virtual address of a page fault on this context */
 	IMG_DEV_VIRTADDR sFaultAddress;
 
+	/* Bitfield stating which heaps were created on this context. */
+	IMG_UINT64 uiCreatedHeaps;
+
+	/* Context's reference count */
+	ATOMIC_T hRefCount;
+
 	/* General purpose flags */
 	IMG_UINT32 ui32Flags;
 };
@@ -114,10 +121,8 @@ struct _DEVMEMINT_CTX_EXPORT_
 struct _DEVMEMINT_HEAP_
 {
 	struct _DEVMEMINT_CTX_ *psDevmemCtx;
-	IMG_UINT32 uiLog2PageSize;
 	IMG_DEV_VIRTADDR sBaseAddr;
 	IMG_DEV_VIRTADDR sLastAddr;
-	ATOMIC_T uiRefCount;
 
 	/* Private data for callback functions */
 	IMG_HANDLE hPrivData;
@@ -127,6 +132,15 @@ struct _DEVMEMINT_HEAP_
 
 	/* Callback function deinit */
 	PFN_HEAP_DEINIT pfnDeInit;
+
+	/* Heap's reference count */
+	ATOMIC_T uiRefCount;
+
+	/* Page shift of the heap */
+	IMG_UINT32 uiLog2PageSize;
+
+	/* Copy of the heap index from Device Heap Configuration module */
+	IMG_UINT32 uiHeapIndex;
 };
 
 struct _DEVMEMINT_RESERVATION_
@@ -137,6 +151,22 @@ struct _DEVMEMINT_RESERVATION_
 	/* lock used to guard against potential race when freeing reservation */
 	POS_LOCK hLock;
 	IMG_INT32 i32RefCount;
+	PVRSRV_MEMALLOCFLAGS_T uiFlags;
+
+	/* We keep a reference to the single PMR associated with this reservation
+	 * once mapped. When creating the reservation this is null. Used in
+	 * ChangeSparse to validate parameters. We could have a sparse PMR with
+	 * no backing and have it mapped to a reservation.
+	 */
+	PMR *psMappedPMR;
+
+	/* Array of bitfields of size `uiNumPages / MAP_MASK_SHIFT`.
+	 * This array represents the mapping between a PMR (psMappedPMR) and
+	 * the reservation. Each bit represents an index of a physical page - a value
+	 * 1 means the page is mapped and vice versa.
+	 */
+	IMG_UINT8 *pui8Map;
+	#define MAP_MASK_SHIFT 3
 };
 
 struct _DEVMEMINT_MAPPING_
@@ -174,14 +204,79 @@ struct _DEVMEMINT_PF_NOTIFY_
 	DLLIST_NODE sProcessNotifyListElem;
 };
 
+/** Computes division using log2 of divisor. */
+#define LOG2_DIV(x, log2) ((x) >> (log2))
+
+/** Computes modulo of a power of 2. */
+#define LOG2_MOD(x, log2) ((x) & ((1 << (log2)) - 1))
+
+static INLINE IMG_UINT32 _DevmemReservationPageCount(DEVMEMINT_RESERVATION *psRsrv);
+
+/*************************************************************************/ /*!
+@Function       DevmemIntReservationIsIndexMapped
+@Description    Checks whether a particular index in the reservation has been
+                mapped to a page in psMappedPMR.
+
+@Return         IMG_TRUE if mapped or IMG_FALSE if not.
+*/ /**************************************************************************/
+static INLINE IMG_BOOL DevmemIntReservationIsIndexMapped(DEVMEMINT_RESERVATION *psReservation,
+                                                         IMG_UINT32 ui32Index)
+{
+	IMG_UINT32 ui32MapIndex = LOG2_DIV(ui32Index, MAP_MASK_SHIFT);
+
+	PVR_ASSERT(psReservation != NULL);
+	PVR_ASSERT(ui32Index < _DevmemReservationPageCount(psReservation));
+
+	return BIT_ISSET(psReservation->pui8Map[ui32MapIndex], LOG2_MOD(ui32Index, MAP_MASK_SHIFT));
+}
+
+/*************************************************************************/ /*!
+@Function       DevmemIntReservationSetMappingIndex
+@Description    Sets an index of the reservation map to indicate a mapped or
+                unmapped PMR page.
+
+@Note           The reservations hLock must be acquired before calling this
+                function.
+
+@Return         None
+*/ /**************************************************************************/
+static void DevmemIntReservationSetMappingIndex(DEVMEMINT_RESERVATION *psReservation,
+                                                IMG_UINT32 ui32Index,
+                                                IMG_BOOL bMap)
+{
+	IMG_UINT32 ui32MapIndex = LOG2_DIV(ui32Index, MAP_MASK_SHIFT);
+
+	PVR_ASSERT(psReservation != NULL);
+	PVR_ASSERT(ui32Index < _DevmemReservationPageCount(psReservation));
+
+	if (bMap)
+	{
+		BIT_SET(psReservation->pui8Map[ui32MapIndex], LOG2_MOD(ui32Index, MAP_MASK_SHIFT));
+	}
+	else
+	{
+		BIT_UNSET(psReservation->pui8Map[ui32MapIndex], LOG2_MOD(ui32Index, MAP_MASK_SHIFT));
+	}
+}
+
 /*************************************************************************/ /*!
 @Function       DevmemIntCtxAcquire
 @Description    Acquire a reference to the provided device memory context.
-@Return         None
+@Return         IMG_TRUE on success, IMG_FALSE on overflow
 */ /**************************************************************************/
-static INLINE void DevmemIntCtxAcquire(DEVMEMINT_CTX *psDevmemCtx)
+static INLINE IMG_BOOL DevmemIntCtxAcquire(DEVMEMINT_CTX *psDevmemCtx)
 {
-	OSAtomicIncrement(&psDevmemCtx->hRefCount);
+	IMG_INT32 iOldValue = OSAtomicAddUnless(&psDevmemCtx->hRefCount, 1,
+	                                        DEVMEMCTX_REFCOUNT_MAX);
+
+	if (iOldValue == DEVMEMCTX_REFCOUNT_MAX)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to acquire the device memory "
+		         "context, reference count has overflowed.", __func__));
+		return IMG_FALSE;
+	}
+
+	return IMG_TRUE;
 }
 
 /*************************************************************************/ /*!
@@ -199,6 +294,19 @@ static INLINE void DevmemIntCtxRelease(DEVMEMINT_CTX *psDevmemCtx)
 		PVRSRV_DEVICE_NODE *psDevNode = psDevmemCtx->psDevNode;
 		DLLIST_NODE *psNode, *psNodeNext;
 
+		/* Protect removing the node from the list in case it's being accessed
+		 * by DevmemIntPFNotify(). */
+		OSWRLockAcquireWrite(psDevNode->hPageFaultNotifyLock);
+		/* If this context is in the list registered for a debugger, remove
+		 * from that list */
+		if (dllist_node_is_in_list(&psDevmemCtx->sPageFaultNotifyListElem))
+		{
+			dllist_remove_node(&psDevmemCtx->sPageFaultNotifyListElem);
+		}
+		/* It should be safe to release the lock here (as long as
+		 * DevmemIntPFNotify() protects accessing memory contexts as well). */
+		OSWRLockReleaseWrite(psDevNode->hPageFaultNotifyLock);
+
 		/* If there are any PIDs registered for page fault notification.
 		 * Loop through the registered PIDs and free each one */
 		dllist_foreach_node(&(psDevmemCtx->sProcessNotifyListHead), psNode, psNodeNext)
@@ -209,21 +317,12 @@ static INLINE void DevmemIntCtxRelease(DEVMEMINT_CTX *psDevmemCtx)
 			OSFreeMem(psNotifyNode);
 		}
 
-		/* If this context is in the list registered for a debugger, remove
-		 * from that list */
-		if (dllist_node_is_in_list(&psDevmemCtx->sPageFaultNotifyListElem))
-		{
-			dllist_remove_node(&psDevmemCtx->sPageFaultNotifyListElem);
-		}
-
 		if (psDevNode->pfnUnregisterMemoryContext)
 		{
 			psDevNode->pfnUnregisterMemoryContext(psDevmemCtx->hPrivData);
 		}
 		MMU_ContextDestroy(psDevmemCtx->psMMUContext);
 
-		OSWRLockDestroy(psDevmemCtx->hListLock);
-
 		PVR_DPF((PVR_DBG_MESSAGE, "%s: Freed memory context %p",
 				 __func__, psDevmemCtx));
 		OSFreeMem(psDevmemCtx);
@@ -237,10 +336,10 @@ static INLINE void DevmemIntCtxRelease(DEVMEMINT_CTX *psDevmemCtx)
 */ /**************************************************************************/
 static INLINE IMG_BOOL DevmemIntHeapAcquire(DEVMEMINT_HEAP *psDevmemHeap)
 {
-	IMG_BOOL bSuccess = OSAtomicAddUnless(&psDevmemHeap->uiRefCount, 1,
-	                                      DEVMEMHEAP_REFCOUNT_MAX);
+	IMG_INT32 iOldValue = OSAtomicAddUnless(&psDevmemHeap->uiRefCount, 1,
+	                                        DEVMEMHEAP_REFCOUNT_MAX);
 
-	if (!bSuccess)
+	if (iOldValue == DEVMEMHEAP_REFCOUNT_MAX)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to acquire the device memory "
 		         "heap, reference count has overflowed.", __func__));
@@ -259,16 +358,63 @@ static INLINE IMG_BOOL DevmemIntHeapAcquire(DEVMEMINT_HEAP *psDevmemHeap)
 */ /**************************************************************************/
 static INLINE void DevmemIntHeapRelease(DEVMEMINT_HEAP *psDevmemHeap)
 {
-	IMG_BOOL bSuccess = OSAtomicSubtractUnless(&psDevmemHeap->uiRefCount, 1,
-	                                           DEVMEMHEAP_REFCOUNT_MIN);
+	IMG_INT32 iOldValue = OSAtomicSubtractUnless(&psDevmemHeap->uiRefCount, 1,
+	                                             DEVMEMHEAP_REFCOUNT_MIN);
 
-	if (!bSuccess)
+	if (iOldValue == DEVMEMHEAP_REFCOUNT_MIN)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to acquire the device memory "
 		         "heap, reference count has underflowed.", __func__));
 	}
 }
 
+static IMG_BOOL DevmemIntReservationAcquireUnlocked(DEVMEMINT_RESERVATION *psDevmemReservation)
+{
+#if defined(DEBUG)
+	if (!OSLockIsLocked(psDevmemReservation->hLock))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Reservation is not locked", __func__));
+		return IMG_FALSE;
+	}
+#endif
+
+	if (psDevmemReservation->i32RefCount == DEVMEMRESERVATION_REFCOUNT_MAX)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to acquire the device memory "
+		         "reservation, reference count has overflowed.", __func__));
+
+		return IMG_FALSE;
+	}
+
+	psDevmemReservation->i32RefCount++;
+
+	return IMG_TRUE;
+}
+
+static void DevmemIntReservationReleaseUnlocked(DEVMEMINT_RESERVATION *psDevmemReservation)
+{
+#if defined(DEBUG)
+	if (!OSLockIsLocked(psDevmemReservation->hLock))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Reservation is not locked", __func__));
+		return;
+	}
+#endif
+
+	if (psDevmemReservation->i32RefCount == DEVMEMRESERVATION_REFCOUNT_MIN)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to release the device memory "
+		         "reservation, reference count has underflowed.", __func__));
+
+		/* for better debugging */
+		PVR_ASSERT(psDevmemReservation->i32RefCount == DEVMEMRESERVATION_REFCOUNT_MIN);
+
+		return;
+	}
+
+	psDevmemReservation->i32RefCount--;
+}
+
 /*************************************************************************/ /*!
 @Function       DevmemIntReservationAcquire
 @Description    Acquire a reference to the provided device memory reservation.
@@ -279,20 +425,9 @@ IMG_BOOL DevmemIntReservationAcquire(DEVMEMINT_RESERVATION *psDevmemReservation)
 	IMG_BOOL bSuccess;
 
 	OSLockAcquire(psDevmemReservation->hLock);
-
-	bSuccess = (psDevmemReservation->i32RefCount < DEVMEMRESERVATION_REFCOUNT_MAX);
-
-	if (!bSuccess)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to acquire the device memory "
-		         "reservation, reference count has overflowed.", __func__));
-	}
-	else
-	{
-		psDevmemReservation->i32RefCount++;
-	}
-
+	bSuccess = DevmemIntReservationAcquireUnlocked(psDevmemReservation);
 	OSLockRelease(psDevmemReservation->hLock);
+
 	return bSuccess;
 }
 
@@ -306,30 +441,8 @@ IMG_BOOL DevmemIntReservationAcquire(DEVMEMINT_RESERVATION *psDevmemReservation)
 void DevmemIntReservationRelease(DEVMEMINT_RESERVATION *psDevmemReservation)
 {
 	OSLockAcquire(psDevmemReservation->hLock);
-
-	if (psDevmemReservation->i32RefCount == DEVMEMRESERVATION_REFCOUNT_MIN)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s(): Failed to release the device memory "
-		         "reservation, reference count has underflowed.", __func__));
-	}
-	else
-	{
-		/* Decrement reservation reference count and free it
-		 * if this was the final reference
-		 */
-		if (--psDevmemReservation->i32RefCount == DEVMEMRESERVATION_REFCOUNT_MIN)
-		{
-			/* Destroy lock */
-			OSLockRelease(psDevmemReservation->hLock);
-			OSLockDestroy(psDevmemReservation->hLock);
-			OSFreeMem(psDevmemReservation);
-			goto exit_noderef;
-		}
-	}
-
+	DevmemIntReservationReleaseUnlocked(psDevmemReservation);
 	OSLockRelease(psDevmemReservation->hLock);
-exit_noderef:
-	return;
 }
 
 /*************************************************************************/ /*!
@@ -484,7 +597,6 @@ DevmemIntCtxCreate(CONNECTION_DATA *psConnection,
 	*pui32CPUCacheLineSize = OSCPUCacheAttributeSize(OS_CPU_CACHE_ATTRIBUTE_LINE_SIZE);
 
 	/* Initialise the PID notify list */
-	OSWRLockCreate(&psDevmemCtx->hListLock);
 	dllist_init(&(psDevmemCtx->sProcessNotifyListHead));
 	psDevmemCtx->sPageFaultNotifyListElem.psNextNode = NULL;
 	psDevmemCtx->sPageFaultNotifyListElem.psPrevNode = NULL;
@@ -495,6 +607,8 @@ DevmemIntCtxCreate(CONNECTION_DATA *psConnection,
 	/* Initialise flags */
 	psDevmemCtx->ui32Flags = 0;
 
+	psDevmemCtx->uiCreatedHeaps = 0;
+
 	return PVRSRV_OK;
 
 fail_register:
@@ -516,8 +630,6 @@ PVRSRV_ERROR
 DevmemIntHeapCreate(DEVMEMINT_CTX *psDevmemCtx,
                     IMG_UINT32 uiHeapConfigIndex,
                     IMG_UINT32 uiHeapIndex,
-                    IMG_DEV_VIRTADDR sHeapBaseAddr,
-                    IMG_UINT32 uiLog2DataPageSize,
                     DEVMEMINT_HEAP **ppsDevmemHeapPtr)
 {
 	DEVMEMINT_HEAP *psDevmemHeap;
@@ -530,19 +642,14 @@ DevmemIntHeapCreate(DEVMEMINT_CTX *psDevmemCtx,
 
 	PVR_DPF((PVR_DBG_MESSAGE, "%s", __func__));
 
-	/* allocate a Devmem context */
-	psDevmemHeap = OSAllocMem(sizeof(*psDevmemHeap));
-	PVR_LOG_RETURN_IF_NOMEM(psDevmemHeap, "psDevmemHeap");
-
-	psDevmemHeap->psDevmemCtx = psDevmemCtx;
-
-	DevmemIntCtxAcquire(psDevmemHeap->psDevmemCtx);
-
-	OSAtomicWrite(&psDevmemHeap->uiRefCount, 1);
+	if (!DevmemIntCtxAcquire(psDevmemCtx))
+	{
+		return PVRSRV_ERROR_REFCOUNT_OVERFLOW;
+	}
 
-	/* Check page size and base addr match the heap blueprint */
+	/* Retrieve page size and base addr match the heap blueprint */
 	eError = HeapCfgHeapDetails(NULL,
-	                            psDevmemHeap->psDevmemCtx->psDevNode,
+	                            psDevmemCtx->psDevNode,
 	                            uiHeapConfigIndex,
 	                            uiHeapIndex,
 	                            0, NULL,
@@ -558,32 +665,35 @@ DevmemIntHeapCreate(DEVMEMINT_CTX *psDevmemCtx,
 		goto ErrorCtxRelease;
 	}
 
-	if (uiLog2DataPageSize != ui32BlueprintLog2DataPageSize)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "Incorrect page size passed - Passed: %d, Expected: %d for HeapConfig:%d HeapIndex:%d.",
-					uiLog2DataPageSize, ui32BlueprintLog2DataPageSize, uiHeapConfigIndex, uiHeapIndex));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto ErrorCtxRelease;
-	}
+	/* uiHeapConfigIndex and uiHeapIndex are validated in HeapCfgHeapDetails()
+	 * so it should be safe to use here without additional checks. We must assert
+	 * though that the index is less than the number of bits in uiCreatedHeaps
+	 * bitfield (we assume 8 bits in a byte and bitfield width of 64). */
+	PVR_ASSERT(uiHeapIndex < sizeof(psDevmemCtx->uiCreatedHeaps) * 8);
 
-	if (sHeapBaseAddr.uiAddr != sBlueprintHeapBaseAddr.uiAddr)
+	if (BIT_ISSET(psDevmemCtx->uiCreatedHeaps, uiHeapIndex))
 	{
-		PVR_DPF((PVR_DBG_ERROR, "Incorrect heap address passed - Passed: "IMG_DEV_VIRTADDR_FMTSPEC", Expected: "IMG_DEV_VIRTADDR_FMTSPEC" for HeapConfig: %d HeapIndex: %d.",
-					(IMG_UINT64)sHeapBaseAddr.uiAddr,
-	             (IMG_UINT64)sBlueprintHeapBaseAddr.uiAddr, uiHeapConfigIndex, uiHeapIndex));
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		eError = PVRSRV_ERROR_ALREADY_EXISTS;
 		goto ErrorCtxRelease;
 	}
 
-	psDevmemHeap->uiLog2PageSize = uiLog2DataPageSize;
-	psDevmemHeap->sBaseAddr = sHeapBaseAddr;
-	/* Store the first non-accessible address as our LastAddr. We can access
-	 * every address between sHeapBaseAddr and sHeapBaseAddr + HeapLength - 1
+	/* allocate the heap object */
+	psDevmemHeap = OSAllocMem(sizeof(*psDevmemHeap));
+	PVR_LOG_GOTO_IF_NOMEM(psDevmemHeap, eError, ErrorCtxRelease);
+
+	psDevmemHeap->psDevmemCtx = psDevmemCtx;
+	psDevmemHeap->uiLog2PageSize = ui32BlueprintLog2DataPageSize;
+	psDevmemHeap->sBaseAddr = sBlueprintHeapBaseAddr;
+	/* Store the last accessible address as our LastAddr. We can access
+	 * every address between sBlueprintHeapBaseAddr and
+	 * sBlueprintHeapBaseAddr + uiBlueprintHeapLength - 1
 	 */
-	psDevmemHeap->sLastAddr = sHeapBaseAddr;
-	psDevmemHeap->sLastAddr.uiAddr = sHeapBaseAddr.uiAddr + uiBlueprintHeapLength;
+	psDevmemHeap->sLastAddr.uiAddr = sBlueprintHeapBaseAddr.uiAddr + uiBlueprintHeapLength - 1;
+	psDevmemHeap->uiHeapIndex = uiHeapIndex;
+
+	OSAtomicWrite(&psDevmemHeap->uiRefCount, 1);
 
-	eError = HeapCfgGetCallbacks(psDevmemHeap->psDevmemCtx->psDevNode,
+	eError = HeapCfgGetCallbacks(psDevmemCtx->psDevNode,
 	                             uiHeapConfigIndex,
 	                             uiHeapIndex,
 	                             &psDevmemHeap->pfnInit,
@@ -592,96 +702,152 @@ DevmemIntHeapCreate(DEVMEMINT_CTX *psDevmemCtx,
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to get callbacks for HeapConfig:%d HeapIndex:%d.",
 				 __func__, uiHeapConfigIndex, uiHeapIndex));
-		goto ErrorCtxRelease;
+		goto ErrorFreeDevmemHeap;
 	}
 
 	if (psDevmemHeap->pfnInit != NULL)
 	{
-		eError = psDevmemHeap->pfnInit(psDevmemHeap->psDevmemCtx->psDevNode,
+		eError = psDevmemHeap->pfnInit(psDevmemCtx->psDevNode,
 		                               psDevmemHeap,
 		                               &psDevmemHeap->hPrivData);
-		PVR_GOTO_IF_ERROR(eError, ErrorCtxRelease);
+		PVR_GOTO_IF_ERROR(eError, ErrorFreeDevmemHeap);
 	}
 
 	PVR_DPF((PVR_DBG_VERBOSE, "%s: sBaseAddr = %" IMG_UINT64_FMTSPECX ", "
 	        "sLastAddr = %" IMG_UINT64_FMTSPECX, __func__,
 	        psDevmemHeap->sBaseAddr.uiAddr, psDevmemHeap->sLastAddr.uiAddr));
 
+	BIT_SET(psDevmemCtx->uiCreatedHeaps, uiHeapIndex);
+
 	*ppsDevmemHeapPtr = psDevmemHeap;
 
 	return PVRSRV_OK;
 
-ErrorCtxRelease:
-	DevmemIntCtxRelease(psDevmemHeap->psDevmemCtx);
+ErrorFreeDevmemHeap:
 	OSFreeMem(psDevmemHeap);
+ErrorCtxRelease:
+	DevmemIntCtxRelease(psDevmemCtx);
 
 	return eError;
 }
 
 static INLINE IMG_UINT32
-_ReservationPageCount(DEVMEMXINT_RESERVATION *psRsrv)
+_DevmemXReservationPageCount(DEVMEMXINT_RESERVATION *psRsrv)
 {
 	return psRsrv->uiLength >> psRsrv->psDevmemHeap->uiLog2PageSize;
 }
 
 static INLINE IMG_DEV_VIRTADDR
-_ReservationPageAddress(DEVMEMXINT_RESERVATION *psRsrv, IMG_UINT32 uiVirtPageOffset)
+_DevmemXReservationPageAddress(DEVMEMXINT_RESERVATION *psRsrv, IMG_UINT32 uiVirtPageOffset)
 {
 	IMG_DEV_VIRTADDR sAddr = {
-		.uiAddr = psRsrv->sBase.uiAddr + (uiVirtPageOffset << psRsrv->psDevmemHeap->uiLog2PageSize)
+		.uiAddr = psRsrv->sBase.uiAddr + ((IMG_UINT64)uiVirtPageOffset << psRsrv->psDevmemHeap->uiLog2PageSize)
 	};
 
 	return sAddr;
 }
 
+static INLINE PVRSRV_ERROR ReserveRangeParamValidation(DEVMEMINT_HEAP *psDevmemHeap,
+                                                       IMG_DEV_VIRTADDR sReservationVAddr,
+                                                       IMG_DEVMEM_SIZE_T uiVirtualSize)
+{
+	IMG_DEV_VIRTADDR sLastReserveAddr;
+	IMG_UINT64 ui64InvalidSizeMask = (1 << psDevmemHeap->uiLog2PageSize) - 1;
+
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psDevmemHeap != NULL, "psDevmemHeap");
+
+	sLastReserveAddr.uiAddr = sReservationVAddr.uiAddr + uiVirtualSize - 1;
+
+	/* Check that the requested address is not less than the base address of the heap. */
+	if (sReservationVAddr.uiAddr < psDevmemHeap->sBaseAddr.uiAddr)
+	{
+		PVR_LOG_VA(PVR_DBG_ERROR,
+			"sReservationVAddr ("IMG_DEV_VIRTADDR_FMTSPEC") is invalid! "
+			"Must be greater or equal to "IMG_DEV_VIRTADDR_FMTSPEC,
+			sReservationVAddr.uiAddr,
+			psDevmemHeap->sBaseAddr.uiAddr);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	/* Check the allocation size is valid (must be page granular). */
+	if ((uiVirtualSize & ui64InvalidSizeMask) != 0 || uiVirtualSize == 0)
+	{
+		PVR_LOG_VA(PVR_DBG_ERROR,
+			"uiVirtualSize ("IMG_DEVMEM_SIZE_FMTSPEC") is invalid! Must a multiple of %u and greater than 0",
+			uiVirtualSize,
+			1 << psDevmemHeap->uiLog2PageSize);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if (uiVirtualSize > PMR_MAX_SUPPORTED_SIZE)
+	{
+		PVR_LOG_VA(PVR_DBG_ERROR,
+			"uiVirtualSize must be less than or equal to the max PMR size ("
+			IMG_DEVMEM_SIZE_FMTSPEC")",
+			PMR_MAX_SUPPORTED_SIZE);
+
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	/* Check that requested address + size fits in our heap. */
+	if (sLastReserveAddr.uiAddr > psDevmemHeap->sLastAddr.uiAddr)
+	{
+		PVR_LOG_VA(PVR_DBG_ERROR,
+			"sReservationVAddr ("IMG_DEV_VIRTADDR_FMTSPEC") is invalid! "
+			"Must be lower than "IMG_DEV_VIRTADDR_FMTSPEC,
+			sReservationVAddr.uiAddr,
+			psDevmemHeap->sLastAddr.uiAddr - uiVirtualSize + 1);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	return PVRSRV_OK;
+}
+
 PVRSRV_ERROR
 DevmemXIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
-                       IMG_DEV_VIRTADDR sAllocationDevVAddr,
-                       IMG_DEVMEM_SIZE_T uiAllocationSize,
+                       IMG_DEV_VIRTADDR sReservationVAddr,
+                       IMG_DEVMEM_SIZE_T uiVirtualSize,
                        DEVMEMXINT_RESERVATION **ppsRsrv)
 {
 	DEVMEMXINT_RESERVATION *psRsrv;
 	IMG_UINT32 uiNumPages;
 	PVRSRV_ERROR eError;
 
+	PVR_ASSERT(ppsRsrv != NULL);
+
+	eError = ReserveRangeParamValidation(psDevmemHeap,
+	                                     sReservationVAddr,
+	                                     uiVirtualSize);
+	PVR_LOG_RETURN_IF_ERROR(eError, "ReserveRangeParamValidation");
+
+
 	if (!DevmemIntHeapAcquire(psDevmemHeap))
 	{
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, ErrorReturnError);
 	}
 
-	/* align address to full device page size */
-	uiAllocationSize = PVR_ALIGN(uiAllocationSize, IMG_UINT64_C(1) << psDevmemHeap->uiLog2PageSize);
-	uiNumPages = uiAllocationSize >> psDevmemHeap->uiLog2PageSize;
-
-	/* Check that requested address + size fits in our heap */
-	PVR_LOG_GOTO_IF_INVALID_PARAM(sAllocationDevVAddr.uiAddr >= psDevmemHeap->sBaseAddr.uiAddr,
-	                              eError, ErrorUnreferenceHeap);
-
-	PVR_LOG_GOTO_IF_INVALID_PARAM(sAllocationDevVAddr.uiAddr + uiAllocationSize <= psDevmemHeap->sLastAddr.uiAddr,
-	                              eError, ErrorUnreferenceHeap);
-
+	uiNumPages = uiVirtualSize >> psDevmemHeap->uiLog2PageSize;
 	psRsrv = OSAllocZMem(sizeof(*psRsrv->ppsPMR) * uiNumPages + sizeof(*psRsrv));
 	PVR_LOG_GOTO_IF_NOMEM(psRsrv, eError, ErrorUnreferenceHeap);
 
 	eError = OSLockCreate(&psRsrv->hLock);
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate", ErrorFreeReservation);
 
-	psRsrv->sBase = sAllocationDevVAddr;
-	psRsrv->uiLength = uiAllocationSize;
+	psRsrv->sBase = sReservationVAddr;
+	psRsrv->uiLength = uiVirtualSize;
 	psRsrv->ppsPMR = IMG_OFFSET_ADDR(psRsrv, sizeof(*psRsrv));
 
 	eError = MMU_Alloc(psDevmemHeap->psDevmemCtx->psMMUContext,
-	                   uiAllocationSize,
-	                   &uiAllocationSize,
+	                   uiVirtualSize,
 	                   0, /* IMG_UINT32 uiProtFlags */
 	                   0, /* alignment is n/a since we supply devvaddr */
-	                   &sAllocationDevVAddr,
+	                   &sReservationVAddr,
 	                   psDevmemHeap->uiLog2PageSize);
 	PVR_GOTO_IF_ERROR(eError, ErrorDestroyLock);
 
 	/* since we supplied the virt addr, MMU_Alloc shouldn't have
 	   chosen a new one for us */
-	PVR_ASSERT(sAllocationDevVAddr.uiAddr == psRsrv->sBase.uiAddr);
+	PVR_ASSERT(sReservationVAddr.uiAddr == psRsrv->sBase.uiAddr);
 
 	psRsrv->psDevmemHeap = psDevmemHeap;
 	*ppsRsrv = psRsrv;
@@ -701,26 +867,63 @@ DevmemXIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
 PVRSRV_ERROR
 DevmemXIntUnreserveRange(DEVMEMXINT_RESERVATION *psRsrv)
 {
-	IMG_UINT32 i;
-
-	MMU_Free(psRsrv->psDevmemHeap->psDevmemCtx->psMMUContext,
-	         psRsrv->sBase,
-	         psRsrv->uiLength,
-	         psRsrv->psDevmemHeap->uiLog2PageSize);
+	IMG_UINT32 ui32FirstMappedIdx = IMG_UINT32_MAX; // Initialise with invalid value.
+	IMG_UINT32 ui32ContigPageCount = 0;
+	IMG_UINT32 ui32PageIdx;
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
 	/* No need to lock the mapping here since this is a handle destruction path which can not be
 	 * executed while there are outstanding handle lookups, i.e. other operations are performed
 	 * on the mapping. Bridge and handle framework also make sure this path can also not be executed
 	 * concurrently. */
 
-	for (i = 0; i < _ReservationPageCount(psRsrv); i++)
+	for (ui32PageIdx = 0; ui32PageIdx < _DevmemXReservationPageCount(psRsrv); ui32PageIdx++)
 	{
-		if (psRsrv->ppsPMR[i] != NULL)
+		if (psRsrv->ppsPMR[ui32PageIdx] != NULL)
 		{
-			PMRUnrefPMR2(psRsrv->ppsPMR[i]);
+			if (ui32ContigPageCount == 0)
+			{
+#if defined(DEBUG)
+				if (ui32FirstMappedIdx == IMG_UINT32_MAX)
+				{
+					PVR_DPF((PVR_DBG_WARNING,
+					         "%s: Reservation was not unmapped! The reservation will "
+					         "be unmapped before proceeding.",
+					         __func__));
+				}
+#endif
+				ui32FirstMappedIdx = ui32PageIdx;
+			}
+
+			ui32ContigPageCount++;
+		}
+		else
+		{
+			if (ui32ContigPageCount != 0)
+			{
+				eError = DevmemXIntUnmapPages(psRsrv,
+				                              ui32FirstMappedIdx,
+				                              ui32ContigPageCount);
+				PVR_RETURN_IF_ERROR(eError);
+			}
+
+			ui32ContigPageCount = 0;
 		}
 	}
 
+	if (ui32ContigPageCount != 0)
+	{
+		eError = DevmemXIntUnmapPages(psRsrv,
+		                              ui32FirstMappedIdx,
+		                              ui32ContigPageCount);
+		PVR_RETURN_IF_ERROR(eError);
+	}
+
+	MMU_Free(psRsrv->psDevmemHeap->psDevmemCtx->psMMUContext,
+	         psRsrv->sBase,
+	         psRsrv->uiLength,
+	         psRsrv->psDevmemHeap->uiLog2PageSize);
+
 	/* Don't bother with refcount on reservation, as a reservation only ever
 	 * holds one mapping, so we directly decrement the refcount on the heap
 	 * instead.
@@ -733,6 +936,28 @@ DevmemXIntUnreserveRange(DEVMEMXINT_RESERVATION *psRsrv)
 	return PVRSRV_OK;
 }
 
+static INLINE PVRSRV_ERROR
+DevmemValidateFlags(PMR *psPMR, PVRSRV_MEMALLOCFLAGS_T uiMapFlags)
+{
+	PMR_FLAGS_T uiPMRFlags = PMR_Flags(psPMR);
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (PVRSRV_CHECK_GPU_READABLE(uiMapFlags) && !PVRSRV_CHECK_GPU_READABLE(uiPMRFlags))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: PMR is not GPU readable.", __func__));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_FLAGS, ErrorReturnError);
+	}
+
+	if (PVRSRV_CHECK_GPU_WRITEABLE(uiMapFlags) && !PVRSRV_CHECK_GPU_WRITEABLE(uiPMRFlags))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: PMR is not GPU writeable.", __func__));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_FLAGS, ErrorReturnError);
+	}
+
+ErrorReturnError:
+	return eError;
+}
+
 PVRSRV_ERROR
 DevmemXIntMapPages(DEVMEMXINT_RESERVATION *psRsrv,
                    PMR *psPMR,
@@ -742,18 +967,27 @@ DevmemXIntMapPages(DEVMEMXINT_RESERVATION *psRsrv,
                    IMG_UINT32 uiVirtPageOffset)
 {
 	PVRSRV_ERROR eError;
-	IMG_UINT32 uiPMRMaxChunkCount = PMRGetMaxChunkCount(psPMR);
+	IMG_UINT32 uiPMRMaxChunkCount = PMR_LogicalSize(psPMR) >> PMR_GetLog2Contiguity(psPMR);
 	DEVMEMINT_HEAP *psDevmemHeap = psRsrv->psDevmemHeap;
 	IMG_UINT32 uiLog2PageSize = psDevmemHeap->uiLog2PageSize;
 	IMG_UINT32 i;
 
+	/* Test uiPageCount+uiPhysPageOffset will not exceed IMG_UINT32_MAX (and thereby wrap) */
+	PVR_LOG_RETURN_IF_INVALID_PARAM(((IMG_UINT64)uiPageCount + (IMG_UINT64)uiPhysPageOffset) <= (IMG_UINT64)IMG_UINT32_MAX, "uiPageCount+uiPhysPageOffset exceeds IMG_UINT32_MAX");
+	/* Test we do not exceed the PMR's maximum physical extent (in pages) */
 	PVR_LOG_RETURN_IF_INVALID_PARAM((uiPageCount + uiPhysPageOffset) <= uiPMRMaxChunkCount, "uiPageCount+uiPhysPageOffset");
 
+	/* Test uiVirtPageOffset+uiPageCount will not exceed IMG_UINT32_MAX (and thereby wrap) */
+	PVR_LOG_RETURN_IF_INVALID_PARAM(((IMG_UINT64)uiVirtPageOffset + (IMG_UINT64)uiPageCount) <= (IMG_UINT64)IMG_UINT32_MAX, "uiVirtPageOffset+uiPageCount exceeds IMG_UINT32_MAX");
 	/* The range is not valid for the given virtual descriptor */
-	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _ReservationPageCount(psRsrv),
+	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _DevmemXReservationPageCount(psRsrv),
 	                        "mapping offset out of range", PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE);
 	PVR_LOG_RETURN_IF_FALSE((uiFlags & ~PVRSRV_MEMALLOCFLAGS_DEVMEMX_VIRTUAL_MASK) == 0,
 	                        "invalid flags", PVRSRV_ERROR_INVALID_FLAGS);
+	PVR_LOG_RETURN_IF_FALSE(!PMR_IsSparse(psPMR),
+		                    "PMR is Sparse, devmemx PMRs should be non-sparse", PVRSRV_ERROR_INVALID_FLAGS);
+	PVR_LOG_RETURN_IF_FALSE(!(PMR_Flags(psPMR) & PVRSRV_MEMALLOCFLAG_DEFER_PHYS_ALLOC),
+		                    "PMR allocation is deferred, devmemx PMRs can not be deferred", PVRSRV_ERROR_INVALID_FLAGS);
 
 	if (uiLog2PageSize > PMR_GetLog2Contiguity(psPMR))
 	{
@@ -764,11 +998,19 @@ DevmemXIntMapPages(DEVMEMXINT_RESERVATION *psRsrv,
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	eError = DevmemValidateFlags(psPMR, uiFlags);
+	PVR_LOG_RETURN_IF_ERROR(eError, "DevmemValidateFlags");
+
 	OSLockAcquire(psRsrv->hLock);
 
+	/* Increase map count to ensure page isolation/migration doesn't occur whilst
+	 * we are in process of mapping.
+	 */
+	PMRGpuMapDevPageCountIncr(psPMR, uiPageCount);
+
 	eError = MMU_MapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
 	                      uiFlags,
-	                      _ReservationPageAddress(psRsrv, uiVirtPageOffset),
+	                      _DevmemXReservationPageAddress(psRsrv, uiVirtPageOffset),
 	                      psPMR,
 	                      uiPhysPageOffset,
 	                      uiPageCount,
@@ -782,6 +1024,15 @@ DevmemXIntMapPages(DEVMEMXINT_RESERVATION *psRsrv,
 
 		if (psRsrv->ppsPMR[i] != NULL)
 		{
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+			/* If PMR is allocated on demand the backing memory is freed by
+			 * pfnUnlockPhysAddresses(). */
+			if (!PVRSRV_CHECK_ON_DEMAND(PMR_Flags(psRsrv->ppsPMR[i])))
+			{
+				PMRMarkForDeferFree(psRsrv->ppsPMR[i]);
+			}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+			PMRGpuMapDevPageCountDecr(psRsrv->ppsPMR[i], 1);
 			PMRUnrefPMR2(psRsrv->ppsPMR[i]);
 		}
 
@@ -793,6 +1044,8 @@ DevmemXIntMapPages(DEVMEMXINT_RESERVATION *psRsrv,
 	return PVRSRV_OK;
 
 ErrUnlock:
+	/* Unwind map count if we failed to map. */
+	PMRGpuMapDevPageCountDecr(psPMR, uiPageCount);
 	OSLockRelease(psRsrv->hLock);
 
 	return eError;
@@ -805,20 +1058,24 @@ DevmemXIntUnmapPages(DEVMEMXINT_RESERVATION *psRsrv,
 {
 	DEVMEMINT_HEAP *psDevmemHeap = psRsrv->psDevmemHeap;
 	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
 
-	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _ReservationPageCount(psRsrv),
+	/* Test uiVirtPageOffset+uiPageCount will not exceed IMG_UINT32_MAX (and thereby wrap) */
+	PVR_LOG_RETURN_IF_INVALID_PARAM(((IMG_UINT64)uiVirtPageOffset + (IMG_UINT64)uiPageCount) <= (IMG_UINT64)IMG_UINT32_MAX, "uiVirtPageOffset+uiPageCount exceeds IMG_UINT32_MAX");
+	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _DevmemXReservationPageCount(psRsrv),
 	                        "mapping offset out of range", PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE);
 
 	OSLockAcquire(psRsrv->hLock);
 
 	/* Unmap the pages and mark them invalid in the MMU PTE */
-	MMU_UnmapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
-	               0,
-	               _ReservationPageAddress(psRsrv, uiVirtPageOffset),
-	               uiPageCount,
-	               NULL,
-	               psDevmemHeap->uiLog2PageSize,
-	               0);
+	eError = MMU_UnmapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
+	                        0,
+	                        _DevmemXReservationPageAddress(psRsrv, uiVirtPageOffset),
+	                        uiPageCount,
+	                        NULL,
+	                        psDevmemHeap->uiLog2PageSize,
+	                        0);
+	PVR_LOG_GOTO_IF_ERROR(eError, "MMU_UnmapPages", ErrUnlock);
 
 	for (i = uiVirtPageOffset; i < (uiVirtPageOffset + uiPageCount); i++)
 	{
@@ -832,6 +1089,7 @@ DevmemXIntUnmapPages(DEVMEMXINT_RESERVATION *psRsrv,
 				PMRMarkForDeferFree(psRsrv->ppsPMR[i]);
 			}
 #endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+			PMRGpuMapDevPageCountDecr(psRsrv->ppsPMR[i], 1);
 			PMRUnrefPMR2(psRsrv->ppsPMR[i]);
 			psRsrv->ppsPMR[i] = NULL;
 		}
@@ -840,6 +1098,11 @@ DevmemXIntUnmapPages(DEVMEMXINT_RESERVATION *psRsrv,
 	OSLockRelease(psRsrv->hLock);
 
 	return PVRSRV_OK;
+
+ErrUnlock:
+	OSLockRelease(psRsrv->hLock);
+
+	return eError;
 }
 
 PVRSRV_ERROR
@@ -852,8 +1115,10 @@ DevmemXIntMapVRangeToBackingPage(DEVMEMXINT_RESERVATION *psRsrv,
 	DEVMEMINT_HEAP *psDevmemHeap = psRsrv->psDevmemHeap;
 	IMG_UINT32 i;
 
+	/* Test uiVirtPageOffset+uiPageCount will not exceed IMG_UINT32_MAX (and thereby wrap) */
+	PVR_LOG_RETURN_IF_INVALID_PARAM(((IMG_UINT64)uiVirtPageOffset + (IMG_UINT64)uiPageCount) <= (IMG_UINT64)IMG_UINT32_MAX, "uiVirtPageOffset+uiPageCount exceeds IMG_UINT32_MAX");
 	/* The range is not valid for the given virtual descriptor */
-	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _ReservationPageCount(psRsrv),
+	PVR_LOG_RETURN_IF_FALSE((uiVirtPageOffset + uiPageCount) <= _DevmemXReservationPageCount(psRsrv),
 	                        "mapping offset out of range", PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE);
 	PVR_LOG_RETURN_IF_FALSE((uiFlags & ~(PVRSRV_MEMALLOCFLAGS_DEVMEMX_VIRTUAL_MASK |
 	                                     PVRSRV_MEMALLOCFLAG_ZERO_BACKING)) == 0,
@@ -863,7 +1128,7 @@ DevmemXIntMapVRangeToBackingPage(DEVMEMXINT_RESERVATION *psRsrv,
 
 	eError = MMUX_MapVRangeToBackingPage(psDevmemHeap->psDevmemCtx->psMMUContext,
 	                                     uiFlags,
-	                                     _ReservationPageAddress(psRsrv, uiVirtPageOffset),
+	                                     _DevmemXReservationPageAddress(psRsrv, uiVirtPageOffset),
 	                                     uiPageCount,
 	                                     psDevmemHeap->uiLog2PageSize);
 	if (eError == PVRSRV_OK)
@@ -872,6 +1137,14 @@ DevmemXIntMapVRangeToBackingPage(DEVMEMXINT_RESERVATION *psRsrv,
 		{
 			if (psRsrv->ppsPMR[i] != NULL)
 			{
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+				/* If PMR is allocated on demand the backing memory is freed by
+				 * pfnUnlockPhysAddresses(). */
+				if (!PVRSRV_CHECK_ON_DEMAND(PMR_Flags(psRsrv->ppsPMR[i])))
+				{
+					PMRMarkForDeferFree(psRsrv->ppsPMR[i]);
+				}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
 				PMRUnrefPMR2(psRsrv->ppsPMR[i]);
 				psRsrv->ppsPMR[i] = NULL;
 			}
@@ -883,23 +1156,30 @@ DevmemXIntMapVRangeToBackingPage(DEVMEMXINT_RESERVATION *psRsrv,
 	return eError;
 }
 
+static INLINE IMG_UINT32
+_DevmemReservationPageCount(DEVMEMINT_RESERVATION *psRsrv)
+{
+	return psRsrv->uiLength >> psRsrv->psDevmemHeap->uiLog2PageSize;
+}
+
 PVRSRV_ERROR
-DevmemIntMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
-                DEVMEMINT_RESERVATION *psReservation,
-                PMR *psPMR,
-                PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-                DEVMEMINT_MAPPING **ppsMappingPtr)
+DevmemIntMapPMR(DEVMEMINT_RESERVATION *psReservation, PMR *psPMR)
 {
 	PVRSRV_ERROR eError;
-	DEVMEMINT_MAPPING *psMapping;
 	/* number of pages (device pages) that allocation spans */
 	IMG_UINT32 ui32NumDevPages;
 	/* device virtual address of start of allocation */
-	IMG_DEV_VIRTADDR sAllocationDevVAddr;
+	IMG_DEV_VIRTADDR sReservationVAddr;
 	/* and its length */
-	IMG_DEVMEM_SIZE_T uiAllocationSize;
-	IMG_UINT32 uiLog2HeapContiguity = psDevmemHeap->uiLog2PageSize;
+	IMG_DEVMEM_SIZE_T uiVirtualSize;
+	IMG_UINT32 uiLog2HeapContiguity = psReservation->psDevmemHeap->uiLog2PageSize;
+	PVRSRV_MEMALLOCFLAGS_T uiMapFlags = psReservation->uiFlags;
 	IMG_BOOL bIsSparse = IMG_FALSE;
+	void *pvTmpBuf;
+	IMG_UINT32 i;
+
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psReservation->psMappedPMR == NULL, "psReservation");
+	PVR_LOG_RETURN_IF_INVALID_PARAM(PMR_LogicalSize(psPMR) == psReservation->uiLength, "psPMR logical size");
 
 	if (uiLog2HeapContiguity > PMR_GetLog2Contiguity(psPMR))
 	{
@@ -912,45 +1192,96 @@ DevmemIntMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, ErrorReturnError);
 	}
 
-	if (!DevmemIntReservationAcquire(psReservation))
+	eError = DevmemValidateFlags(psPMR, uiMapFlags);
+	PVR_LOG_GOTO_IF_ERROR(eError, "DevmemValidateFlags", ErrorReturnError);
+
+	OSLockAcquire(psReservation->hLock);
+
+	if (!DevmemIntReservationAcquireUnlocked(psReservation))
 	{
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, ErrorReturnError);
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, ErrorReleaseResLock);
 	}
 
-	/* allocate memory to record the mapping info */
-	psMapping = OSAllocMem(sizeof(*psMapping));
-	PVR_LOG_GOTO_IF_NOMEM(psMapping, eError, ErrorUnreference);
+	uiVirtualSize = psReservation->uiLength;
 
-	uiAllocationSize = psReservation->uiLength;
+	ui32NumDevPages = 0xffffffffU & ( ( (uiVirtualSize - 1) >> uiLog2HeapContiguity) + 1);
+	PVR_ASSERT((IMG_DEVMEM_SIZE_T) ui32NumDevPages << uiLog2HeapContiguity == uiVirtualSize);
 
-	ui32NumDevPages = 0xffffffffU & ( ( (uiAllocationSize - 1) >> uiLog2HeapContiguity) + 1);
-	PVR_ASSERT((IMG_DEVMEM_SIZE_T) ui32NumDevPages << uiLog2HeapContiguity == uiAllocationSize);
+	/* Increase map count to ensure page isolation/migration doesn't occur whilst
+	 * we are in process of mapping. Also ensures we don't lock phys addresses causing allocation
+	 * then migrate before we increase the map count.
+	 */
+	PMRGpuMapDevPageCountIncr(psPMR, ui32NumDevPages);
 
 	eError = PMRLockSysPhysAddresses(psPMR);
-	PVR_GOTO_IF_ERROR(eError, ErrorFreeMapping);
+	PVR_GOTO_IF_ERROR(eError, ErrorUnreference);
 
-	sAllocationDevVAddr = psReservation->sBase;
+	PMRLockPMR(psPMR);
+
+	/* Increase reservation association count so we know if multiple mappings have been created
+	 * on the PMR
+	 */
+	PMRGpuResCountIncr(psPMR);
+
+	sReservationVAddr = psReservation->sBase;
 
 	/*Check if the PMR that needs to be mapped is sparse */
 	bIsSparse = PMR_IsSparse(psPMR);
 	if (bIsSparse)
 	{
+		IMG_DEV_PHYADDR *psDevPAddr;
+		IMG_BOOL *pbValid;
+
+		pvTmpBuf = OSAllocMem((sizeof(IMG_DEV_PHYADDR) + sizeof(IMG_BOOL)) *
+		                      ui32NumDevPages);
+		PVR_LOG_GOTO_IF_NOMEM(pvTmpBuf, eError, ErrorUnlockPhysAddr);
+
+		psDevPAddr = IMG_OFFSET_ADDR(pvTmpBuf, 0);
+		pbValid = IMG_OFFSET_ADDR(pvTmpBuf, ui32NumDevPages * sizeof(IMG_DEV_PHYADDR));
+
 		/* N.B. We pass mapping permission flags to MMU_MapPages and let
 		 * it reject the mapping if the permissions on the PMR are not compatible. */
-		eError = MMU_MapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
+		eError = MMU_MapPages(psReservation->psDevmemHeap->psDevmemCtx->psMMUContext,
 		                      uiMapFlags,
-		                      sAllocationDevVAddr,
+		                      sReservationVAddr,
 		                      psPMR,
 		                      0,
 		                      ui32NumDevPages,
 		                      NULL,
 		                      uiLog2HeapContiguity);
-		PVR_GOTO_IF_ERROR(eError, ErrorUnlockPhysAddr);
+		PVR_GOTO_IF_ERROR(eError, ErrorFreeSparseTmpBuf);
+
+		/* Determine which entries of the PMR are valid */
+		eError = PMR_DevPhysAddr(psPMR,
+		                         uiLog2HeapContiguity,
+		                         ui32NumDevPages,
+		                         0,
+		                         psDevPAddr,
+		                         pbValid,
+		                         DEVICE_USE);
+		PVR_GOTO_IF_ERROR(eError, ErrorUnmapSparseMap);
+
+		for (i = 0; i < ui32NumDevPages; i++)
+		{
+			if (DevmemIntReservationIsIndexMapped(psReservation, i))
+			{
+				PMRUnrefPMR2(psReservation->psMappedPMR);
+				DevmemIntReservationSetMappingIndex(psReservation, i, IMG_FALSE);
+			}
+
+			if (pbValid[i])
+			{
+				PMRRefPMR2(psPMR);
+				DevmemIntReservationSetMappingIndex(psReservation, i, IMG_TRUE);
+			}
+		}
+
+		OSFreeMem(pvTmpBuf);
 	}
 	else
 	{
-		eError = MMU_MapPMRFast(psDevmemHeap->psDevmemCtx->psMMUContext,
-		                        sAllocationDevVAddr,
+		eError = MMU_MapPMRFast(psReservation->psDevmemHeap->psDevmemCtx->psMMUContext,
+		                        sReservationVAddr,
 		                        psPMR,
 		                        (IMG_DEVMEM_SIZE_T) ui32NumDevPages << uiLog2HeapContiguity,
 		                        uiMapFlags,
@@ -958,29 +1289,43 @@ DevmemIntMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
 		PVR_GOTO_IF_ERROR(eError, ErrorUnlockPhysAddr);
 	}
 
-	psMapping->psReservation = psReservation;
-	psMapping->uiNumPages = ui32NumDevPages;
-	psMapping->psPMR = psPMR;
+	psReservation->psMappedPMR = psPMR;
 
-	*ppsMappingPtr = psMapping;
+	PMRUnlockPMR(psPMR);
+	OSLockRelease(psReservation->hLock);
 
 	return PVRSRV_OK;
 
+ErrorUnmapSparseMap:
+	(void) MMU_UnmapPages(psReservation->psDevmemHeap->psDevmemCtx->psMMUContext,
+	                      0,
+	                      sReservationVAddr,
+	                      ui32NumDevPages,
+	                      NULL,
+	                      uiLog2HeapContiguity,
+	                      0);
+ErrorFreeSparseTmpBuf:
+	OSFreeMem(pvTmpBuf);
+
 ErrorUnlockPhysAddr:
+	PMRGpuResCountDecr(psPMR);
+	PMRUnlockPMR(psPMR);
+
 	{
 		PVRSRV_ERROR eError1 = PVRSRV_OK;
 		eError1 = PMRUnlockSysPhysAddresses(psPMR);
 		PVR_LOG_IF_ERROR(eError1, "PMRUnlockSysPhysAddresses");
-
-		*ppsMappingPtr = NULL;
 	}
 
-ErrorFreeMapping:
-	OSFreeMem(psMapping);
-
 ErrorUnreference:
+	/* Unwind map count if we failed to map. */
+	PMRGpuMapDevPageCountDecr(psPMR, ui32NumDevPages);
+
 	/* if fails there's not much to do (the function will print an error) */
-	DevmemIntReservationRelease(psReservation);
+	DevmemIntReservationReleaseUnlocked(psReservation);
+
+ErrorReleaseResLock:
+	OSLockRelease(psReservation->hLock);
 
 ErrorReturnError:
 	PVR_ASSERT (eError != PVRSRV_OK);
@@ -988,116 +1333,151 @@ DevmemIntMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
 }
 
 PVRSRV_ERROR
-DevmemIntReserveRangeAndMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
-							   IMG_DEV_VIRTADDR sAllocationDevVAddr,
-							   IMG_DEVMEM_SIZE_T uiAllocationSize,
-							   PMR *psPMR,
-							   PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-							   DEVMEMINT_MAPPING **ppsMappingPtr)
+DevmemIntGetReservationData(DEVMEMINT_RESERVATION* psReservation, PMR** ppsPMR, IMG_DEV_VIRTADDR* psDevVAddr)
 {
-	PVRSRV_ERROR eError, eUnreserveError;
-
-	DEVMEMINT_RESERVATION* psReservation;
-
-	eError = DevmemIntReserveRange(psDevmemHeap, sAllocationDevVAddr, uiAllocationSize, &psReservation);
-	PVR_GOTO_IF_ERROR(eError, ErrorReturnError);
-
-	eError = DevmemIntMapPMR(psDevmemHeap, psReservation, psPMR, uiMapFlags, ppsMappingPtr);
-	PVR_GOTO_IF_ERROR(eError, ErrorUnreserve);
+	/* Reservation might not have a PMR if a mapping was not yet performed */
+	if (psReservation->psMappedPMR == NULL)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
 
+	psDevVAddr->uiAddr = psReservation->sBase.uiAddr;
+	*ppsPMR = psReservation->psMappedPMR;
 	return PVRSRV_OK;
-
-ErrorUnreserve:
-	eUnreserveError = DevmemIntUnreserveRange(psReservation);
-	PVR_LOG_IF_ERROR(eUnreserveError, "DevmemIntUnreserveRange");
-ErrorReturnError:
-	return eError;
 }
 
 PVRSRV_ERROR
-DevmemIntUnreserveRangeAndUnmapPMR(DEVMEMINT_MAPPING *psMappingPtr)
+DevmemIntReserveRangeAndMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
+                               IMG_DEV_VIRTADDR sReservationVAddr,
+                               IMG_DEVMEM_SIZE_T uiVirtualSize,
+                               PMR *psPMR,
+                               PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                               DEVMEMINT_RESERVATION **ppsReservation)
 {
-	PVRSRV_ERROR eError;
-	DEVMEMINT_RESERVATION *psReservation = psMappingPtr->psReservation;
+	PVRSRV_ERROR eError, eUnreserveError;
 
-	eError = DevmemIntUnmapPMR(psMappingPtr);
-	PVR_GOTO_IF_ERROR(eError, ErrorReturnError);
-	eError = DevmemIntUnreserveRange(psReservation);
+	eError = DevmemIntReserveRange(psDevmemHeap, sReservationVAddr, uiVirtualSize, uiFlags, ppsReservation);
 	PVR_GOTO_IF_ERROR(eError, ErrorReturnError);
 
+	eError = DevmemIntMapPMR(*ppsReservation, psPMR);
+	PVR_GOTO_IF_ERROR(eError, ErrorUnreserve);
+
 	return PVRSRV_OK;
 
+ErrorUnreserve:
+	eUnreserveError = DevmemIntUnreserveRange(*ppsReservation);
+	*ppsReservation = NULL;
+	PVR_LOG_IF_ERROR(eUnreserveError, "DevmemIntUnreserveRange");
 ErrorReturnError:
 	return eError;
 }
 
 PVRSRV_ERROR
-DevmemIntUnmapPMR(DEVMEMINT_MAPPING *psMapping)
+DevmemIntUnmapPMR(DEVMEMINT_RESERVATION *psReservation)
 {
 	PVRSRV_ERROR eError;
-	DEVMEMINT_HEAP *psDevmemHeap = psMapping->psReservation->psDevmemHeap;
+	DEVMEMINT_HEAP *psDevmemHeap = psReservation->psDevmemHeap;
 	/* device virtual address of start of allocation */
-	IMG_DEV_VIRTADDR sAllocationDevVAddr;
+	IMG_DEV_VIRTADDR sReservationVAddr;
 	/* number of pages (device pages) that allocation spans */
 	IMG_UINT32 ui32NumDevPages;
 	IMG_BOOL bIsSparse = IMG_FALSE;
+	IMG_UINT32 i;
 
-	ui32NumDevPages = psMapping->uiNumPages;
-	sAllocationDevVAddr = psMapping->psReservation->sBase;
+	PVR_RETURN_IF_INVALID_PARAM(psReservation->psMappedPMR != NULL);
 
-	/*Check if the PMR that needs to be mapped is sparse */
-	bIsSparse = PMR_IsSparse(psMapping->psPMR);
+	ui32NumDevPages = _DevmemReservationPageCount(psReservation);
+	sReservationVAddr = psReservation->sBase;
+
+	OSLockAcquire(psReservation->hLock);
+	PMRLockPMR(psReservation->psMappedPMR);
+
+	bIsSparse = PMR_IsSparse(psReservation->psMappedPMR);
 
 	if (bIsSparse)
 	{
-		MMU_UnmapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
-				0,
-				sAllocationDevVAddr,
-				ui32NumDevPages,
-				NULL,
-				psDevmemHeap->uiLog2PageSize,
-				0);
+		eError = MMU_UnmapPages(psDevmemHeap->psDevmemCtx->psMMUContext,
+		                        0,
+		                        sReservationVAddr,
+		                        ui32NumDevPages,
+		                        NULL,
+		                        psDevmemHeap->uiLog2PageSize,
+		                        0);
+		PVR_LOG_GOTO_IF_ERROR(eError, "MMU_UnmapPages", ErrUnlock);
+
+		/* We are unmapping the whole PMR */
+		for (i = 0; i < ui32NumDevPages; i++)
+		{
+			if (DevmemIntReservationIsIndexMapped(psReservation, i))
+			{
+				/* All PMRs in the range should be the same, set local PMR
+				 * for Unlocking phys addrs later */
+				PMRUnrefPMR2(psReservation->psMappedPMR);
+				DevmemIntReservationSetMappingIndex(psReservation, i, IMG_FALSE);
+			}
+		}
 	}
 	else
 	{
-		MMU_UnmapPMRFast(psDevmemHeap->psDevmemCtx->psMMUContext,
-		                 sAllocationDevVAddr,
-		                 ui32NumDevPages,
-		                 psDevmemHeap->uiLog2PageSize);
+		eError = MMU_UnmapPMRFast(psDevmemHeap->psDevmemCtx->psMMUContext,
+		                          sReservationVAddr,
+		                          ui32NumDevPages,
+		                          psDevmemHeap->uiLog2PageSize);
+		PVR_LOG_GOTO_IF_ERROR(eError, "MMU_UnmapPMRFast", ErrUnlock);
 	}
 
+	PMRGpuMapDevPageCountDecr(psReservation->psMappedPMR, ui32NumDevPages);
+
+
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
 	/* If PMR is allocated on demand the backing memory is freed by
 	 * pfnUnlockPhysAddresses(). */
-	if (!PVRSRV_CHECK_ON_DEMAND(PMR_Flags(psMapping->psPMR)))
+	if (!PVRSRV_CHECK_ON_DEMAND(PMR_Flags(psReservation->psMappedPMR)))
 	{
-		PMRMarkForDeferFree(psMapping->psPMR);
+		PMRMarkForDeferFree(psReservation->psMappedPMR);
 	}
 #endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
 
-	eError = PMRUnlockSysPhysAddresses(psMapping->psPMR);
+	PMRGpuResCountDecr(psReservation->psMappedPMR);
+
+	PMRUnlockPMR(psReservation->psMappedPMR);
+
+	eError = PMRUnlockSysPhysAddresses(psReservation->psMappedPMR);
 	PVR_ASSERT(eError == PVRSRV_OK);
 
-	DevmemIntReservationRelease(psMapping->psReservation);
+	psReservation->psMappedPMR = NULL;
+
+	DevmemIntReservationReleaseUnlocked(psReservation);
 
-	OSFreeMem(psMapping);
+	OSLockRelease(psReservation->hLock);
 
 	return PVRSRV_OK;
-}
 
+ErrUnlock:
+	PMRUnlockPMR(psReservation->psMappedPMR);
+	OSLockRelease(psReservation->hLock);
+
+	return eError;
+}
 
 PVRSRV_ERROR
 DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
-                      IMG_DEV_VIRTADDR sAllocationDevVAddr,
-                      IMG_DEVMEM_SIZE_T uiAllocationSize,
+                      IMG_DEV_VIRTADDR sReservationVAddr,
+                      IMG_DEVMEM_SIZE_T uiVirtualSize,
+                      PVRSRV_MEMALLOCFLAGS_T uiFlags,
                       DEVMEMINT_RESERVATION **ppsReservationPtr)
 {
 	PVRSRV_ERROR eError;
 	DEVMEMINT_RESERVATION *psReservation;
+	IMG_UINT32 uiNumPages;
+	IMG_UINT64 ui64MapSize;
 
-	PVR_LOG_RETURN_IF_INVALID_PARAM(sAllocationDevVAddr.uiAddr >= psDevmemHeap->sBaseAddr.uiAddr, "sAllocationDevVAddr");
+	PVR_ASSERT(ppsReservationPtr != NULL);
 
-	PVR_LOG_RETURN_IF_INVALID_PARAM((sAllocationDevVAddr.uiAddr + uiAllocationSize) <= psDevmemHeap->sLastAddr.uiAddr, "uiAllocationSize");
+	eError = ReserveRangeParamValidation(psDevmemHeap,
+	                                     sReservationVAddr,
+	                                     uiVirtualSize);
+	PVR_LOG_RETURN_IF_ERROR(eError, "ReserveRangeParamValidation");
 
 	if (!DevmemIntHeapAcquire(psDevmemHeap))
 	{
@@ -1105,31 +1485,41 @@ DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
 		                    ErrorReturnError);
 	}
 
+	uiNumPages = uiVirtualSize >> psDevmemHeap->uiLog2PageSize;
+
 	/* allocate memory to record the reservation info */
-	psReservation = OSAllocMem(sizeof(*psReservation));
+	ui64MapSize = sizeof(*psReservation->pui8Map) * LOG2_DIV(uiNumPages, MAP_MASK_SHIFT);
+	if (LOG2_MOD(uiNumPages, MAP_MASK_SHIFT) != 0)
+	{
+		ui64MapSize += 1;
+	}
+
+	psReservation = OSAllocZMem(sizeof(*psReservation) + ui64MapSize);
 	PVR_LOG_GOTO_IF_NOMEM(psReservation, eError, ErrorUnreference);
 
 	/* Create lock */
 	eError = OSLockCreate(&psReservation->hLock);
+	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate", ErrorFreeReservation);
 
 	/* Initialise refcount */
 	psReservation->i32RefCount = 1;
 
-	psReservation->sBase = sAllocationDevVAddr;
-	psReservation->uiLength = uiAllocationSize;
+	psReservation->uiFlags = uiFlags;
+	psReservation->sBase = sReservationVAddr;
+	psReservation->uiLength = uiVirtualSize;
+	psReservation->pui8Map = IMG_OFFSET_ADDR(psReservation, sizeof(*psReservation));
 
 	eError = MMU_Alloc(psDevmemHeap->psDevmemCtx->psMMUContext,
-	                   uiAllocationSize,
-	                   &uiAllocationSize,
+	                   uiVirtualSize,
 	                   0, /* IMG_UINT32 uiProtFlags */
 	                   0, /* alignment is n/a since we supply devvaddr */
-	                   &sAllocationDevVAddr,
+	                   &sReservationVAddr,
 	                   psDevmemHeap->uiLog2PageSize);
-	PVR_GOTO_IF_ERROR(eError, ErrorFreeReservation);
+	PVR_GOTO_IF_ERROR(eError, ErrorDestroyLock);
 
 	/* since we supplied the virt addr, MMU_Alloc shouldn't have
 	   chosen a new one for us */
-	PVR_ASSERT(sAllocationDevVAddr.uiAddr == psReservation->sBase.uiAddr);
+	PVR_ASSERT(sReservationVAddr.uiAddr == psReservation->sBase.uiAddr);
 
 	psReservation->psDevmemHeap = psDevmemHeap;
 	*ppsReservationPtr = psReservation;
@@ -1140,6 +1530,9 @@ DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
 	 *  error exit paths follow
 	 */
 
+ErrorDestroyLock:
+	OSLockDestroy(psReservation->hLock);
+
 ErrorFreeReservation:
 	OSFreeMem(psReservation);
 
@@ -1155,17 +1548,50 @@ DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
 PVRSRV_ERROR
 DevmemIntUnreserveRange(DEVMEMINT_RESERVATION *psReservation)
 {
-	IMG_DEV_VIRTADDR sBase        = psReservation->sBase;
-	IMG_UINT32 uiLength           = psReservation->uiLength;
-	DEVMEMINT_HEAP *psDevmemHeap  = psReservation->psDevmemHeap;
-	IMG_UINT32 uiLog2DataPageSize = psDevmemHeap->uiLog2PageSize;
+	IMG_UINT32 i;
+	DEVMEMINT_HEAP *psDevmemHeap = psReservation->psDevmemHeap;
+	PVRSRV_ERROR eError;
+
+	if (psReservation->psMappedPMR != NULL)
+	{
+		/* No warning to be emitted as this is expected behaviour for the
+		 * Devmem interface. */
+		eError = DevmemIntUnmapPMR(psReservation);
+		PVR_LOG_RETURN_IF_ERROR(eError, "DevmemIntUnmapPMR");
+	}
+
+	OSLockAcquire(psReservation->hLock);
+
+	if (psReservation->i32RefCount != DEVMEMRESERVATION_REFCOUNT_MIN)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s called but still has existing references "
+		         "(%d), free existing reservations & mappings first.", __func__,
+		         psReservation->i32RefCount));
+
+		OSLockRelease(psReservation->hLock);
+
+		return PVRSRV_ERROR_RETRY;
+	}
+
+	OSLockRelease(psReservation->hLock);
 
 	MMU_Free(psDevmemHeap->psDevmemCtx->psMMUContext,
-	         sBase,
-	         uiLength,
-	         uiLog2DataPageSize);
+	         psReservation->sBase,
+	         psReservation->uiLength,
+	         psDevmemHeap->uiLog2PageSize);
+
+	for (i = 0; i < _DevmemReservationPageCount(psReservation); i++)
+	{
+		if (DevmemIntReservationIsIndexMapped(psReservation, i))
+		{
+			PMRUnrefPMR2(psReservation->psMappedPMR);
+			DevmemIntReservationSetMappingIndex(psReservation, i, IMG_FALSE);
+		}
+	}
+
+	OSLockDestroy(psReservation->hLock);
+	OSFreeMem(psReservation);
 
-	DevmemIntReservationRelease(psReservation);
 	DevmemIntHeapRelease(psDevmemHeap);
 
 	return PVRSRV_OK;
@@ -1183,9 +1609,8 @@ DevmemIntHeapDestroy(DEVMEMINT_HEAP *psDevmemHeap)
 
 	if (OSAtomicRead(&psDevmemHeap->uiRefCount) != DEVMEMHEAP_REFCOUNT_MIN)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "BUG!  %s called but has too many references (%d) "
-		         "which probably means reservations & mappings have been made from "
-		         "the heap and not freed", __func__,
+		PVR_DPF((PVR_DBG_ERROR, "%s called but still has existing references "
+		         "(%d), free existing reservations & mappings first.", __func__,
 		         OSAtomicRead(&psDevmemHeap->uiRefCount)));
 
 		/*
@@ -1204,6 +1629,8 @@ DevmemIntHeapDestroy(DEVMEMINT_HEAP *psDevmemHeap)
 
 	PVR_ASSERT(OSAtomicRead(&psDevmemHeap->uiRefCount) == DEVMEMHEAP_REFCOUNT_MIN);
 
+	BIT_UNSET(psDevmemHeap->psDevmemCtx->uiCreatedHeaps, psDevmemHeap->uiHeapIndex);
+
 	DevmemIntCtxRelease(psDevmemHeap->psDevmemCtx);
 
 	PVR_DPF((PVR_DBG_MESSAGE, "%s: Freed heap %p", __func__, psDevmemHeap));
@@ -1220,170 +1647,349 @@ DevmemIntHeapGetBaseAddr(DEVMEMINT_HEAP *psDevmemHeap)
 	return psDevmemHeap->sBaseAddr;
 }
 
+static PVRSRV_ERROR
+DevmemIntValidateSparsePMRIndices(IMG_UINT32 ui32PMRLogicalChunkCount,
+                                  IMG_UINT32 *paui32LogicalIndices,
+                                  IMG_UINT32 ui32LogicalIndexCount)
+{
+	IMG_UINT32 i;
+	IMG_UINT8 *paui8TrackedIndices;
+	IMG_UINT32 ui32AllocSize;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_ASSERT(ui32PMRLogicalChunkCount != 0);
+	PVR_ASSERT(paui32LogicalIndices != NULL);
+	PVR_ASSERT(ui32LogicalIndexCount != 0 && ui32LogicalIndexCount <= ui32PMRLogicalChunkCount);
+
+	ui32AllocSize = LOG2_DIV(ui32PMRLogicalChunkCount, 3);
+	if (LOG2_MOD(ui32PMRLogicalChunkCount, 3) != 0)
+	{
+		++ui32AllocSize;
+	}
+
+	paui8TrackedIndices = OSAllocZMem(ui32AllocSize);
+	if (paui8TrackedIndices == NULL)
+	{
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+
+	for (i = 0; i < ui32LogicalIndexCount; i++)
+	{
+		IMG_UINT32 ui32LogicalIndex = paui32LogicalIndices[i];
+
+		if (ui32LogicalIndex >= ui32PMRLogicalChunkCount)
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Reservation index %u is OOB",
+			         __func__,
+			         ui32LogicalIndex));
+
+			eError = PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE;
+			break;
+		}
+
+		if (BIT_ISSET(paui8TrackedIndices[LOG2_DIV(ui32LogicalIndex, 3)], LOG2_MOD(ui32LogicalIndex, 3)))
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Duplicate index found: %u",
+			         __func__,
+			         ui32LogicalIndex));
+
+			eError = PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY;
+			break;
+		}
+
+		BIT_SET(paui8TrackedIndices[LOG2_DIV(ui32LogicalIndex, 3)], LOG2_MOD(ui32LogicalIndex, 3));
+	}
+
+	OSFreeMem(paui8TrackedIndices);
+	return eError;
+}
+
+static PVRSRV_ERROR
+DevmemIntComputeVirtualIndicesFromLogical(DEVMEMINT_RESERVATION *psReservation,
+                                          IMG_UINT32 ui32LogicalIndexCount,
+                                          IMG_UINT32 *paui32LogicalIndices,
+                                          IMG_UINT32 *pui32VirtualIndexCount,
+                                          IMG_UINT32 **ppaui32VirtualIndices)
+{
+	IMG_UINT32 ui32OrderDiff = PMR_GetLog2Contiguity(psReservation->psMappedPMR) -
+		psReservation->psDevmemHeap->uiLog2PageSize;
+
+	if (ui32OrderDiff == 0)
+	{
+		*pui32VirtualIndexCount = ui32LogicalIndexCount;
+		*ppaui32VirtualIndices = paui32LogicalIndices;
+		return PVRSRV_OK;
+	}
+	else
+	{
+		IMG_UINT32 ui32PagesPerOrder = 1 << ui32OrderDiff;
+		IMG_UINT32 *paui32VirtualIndices;
+		IMG_UINT32 i = 0;
+
+		paui32VirtualIndices = OSAllocMem(*pui32VirtualIndexCount * sizeof(IMG_UINT32));
+		PVR_RETURN_IF_NOMEM(paui32VirtualIndices);
+
+		for (i = 0; i < ui32LogicalIndexCount; i++)
+		{
+			IMG_UINT32 ui32LogicalIndex = paui32LogicalIndices[i];
+			IMG_UINT32 ui32PageOffset;
+
+			for (ui32PageOffset = 0; ui32PageOffset < ui32PagesPerOrder; ui32PageOffset++)
+			{
+				IMG_UINT32 ui32VirtAddr = ui32LogicalIndex * ui32PagesPerOrder + ui32PageOffset;
+				paui32VirtualIndices[i * ui32PagesPerOrder + ui32PageOffset] = ui32VirtAddr;
+			}
+		}
+
+		*ppaui32VirtualIndices = paui32VirtualIndices;
+	}
+
+	return PVRSRV_OK;
+}
+
 PVRSRV_ERROR
-DevmemIntChangeSparse(DEVMEMINT_HEAP *psDevmemHeap,
-                      PMR *psPMR,
-                      IMG_UINT32 ui32AllocPageCount,
+DevmemIntChangeSparse(IMG_UINT32 ui32AllocPageCount,
                       IMG_UINT32 *pai32AllocIndices,
                       IMG_UINT32 ui32FreePageCount,
                       IMG_UINT32 *pai32FreeIndices,
                       SPARSE_MEM_RESIZE_FLAGS uiSparseFlags,
-                      PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                      IMG_DEV_VIRTADDR sDevVAddrBase,
-                      IMG_UINT64 sCpuVAddrBase)
+                      DEVMEMINT_RESERVATION *psReservation)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 
-	IMG_UINT32 uiLog2PMRContiguity = PMR_GetLog2Contiguity(psPMR);
-	IMG_UINT32 uiLog2HeapContiguity = psDevmemHeap->uiLog2PageSize;
-	IMG_UINT32 uiOrderDiff = uiLog2PMRContiguity - uiLog2HeapContiguity;
-	IMG_UINT32 uiPagesPerOrder = 1 << uiOrderDiff;
+	IMG_UINT32 uiLog2PMRContiguity;
+	IMG_UINT32 uiLog2HeapContiguity;
+	PVRSRV_MEMALLOCFLAGS_T uiFlags = psReservation->uiFlags;
+
+	IMG_UINT32 *pai32MapIndices;
+	IMG_UINT32 *pai32UnmapIndices;
+	IMG_UINT32 uiMapPageCount;
+	IMG_UINT32 uiUnmapPageCount;
+
+	IMG_UINT32 ui32LogicalChunkCount;
+	PMR *psPMR = psReservation->psMappedPMR;
+
+	/* Ensure a PMR has been mapped to this reservation. */
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psPMR != NULL, "psReservation");
+	PVR_LOG_RETURN_IF_INVALID_PARAM(uiSparseFlags & SPARSE_RESIZE_BOTH, "uiSparseFlags");
 
-	IMG_UINT32 *pai32MapIndices = pai32AllocIndices;
-	IMG_UINT32 *pai32UnmapIndices = pai32FreeIndices;
-	IMG_UINT32 uiMapPageCount = ui32AllocPageCount;
-	IMG_UINT32 uiUnmapPageCount = ui32FreePageCount;
+	ui32LogicalChunkCount = PMR_GetLogicalChunkCount(psPMR);
 
-	/* Special case:
-	 * Adjust indices if we map into a heap that uses smaller page sizes
-	 * than the physical allocation itself.
-	 * The incoming parameters are all based on the page size of the PMR
-	 * but the mapping functions expects parameters to be in terms of heap page sizes. */
-	if (uiOrderDiff != 0)
+	if (!PMR_IsSparse(psPMR) || PMR_IsMemLayoutFixed(psPMR) ||
+	    PMR_IsCpuMapped(psPMR))
 	{
-		IMG_UINT32 uiPgIdx, uiPgOffset;
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: PMR cannot be changed because one or more of the following"
+		         " were true: !PMR_IsSparse() = %s, PMR_IsMemLayoutFixed() = %s,"
+		         " PMR_IsCpuMapped() = %s",
+		         __func__,
+		         !PMR_IsSparse(psPMR) ? "true" : "false",
+		         PMR_IsMemLayoutFixed(psPMR) ? "true" : "false",
+		         PMR_IsCpuMapped(psPMR) ? "true" : "false"));
+		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
+	}
 
-		uiMapPageCount = (uiMapPageCount << uiOrderDiff);
-		uiUnmapPageCount = (uiUnmapPageCount << uiOrderDiff);
+	uiLog2PMRContiguity = PMR_GetLog2Contiguity(psPMR);
+	uiLog2HeapContiguity = psReservation->psDevmemHeap->uiLog2PageSize;
 
-		pai32MapIndices = OSAllocMem(uiMapPageCount * sizeof(*pai32MapIndices));
-		PVR_GOTO_IF_NOMEM(pai32MapIndices, eError, e0);
+	/* This is check is made in DevmemIntMapPMR - no need to do it again in release. */
+	PVR_ASSERT(uiLog2HeapContiguity <= uiLog2PMRContiguity);
 
-		pai32UnmapIndices = OSAllocMem(uiUnmapPageCount * sizeof(*pai32UnmapIndices));
-		if (!pai32UnmapIndices)
-		{
-			OSFreeMem(pai32MapIndices);
-			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_OUT_OF_MEMORY, e0);
-		}
+	if (uiSparseFlags & SPARSE_RESIZE_ALLOC)
+	{
+		PVR_LOG_RETURN_IF_INVALID_PARAM(ui32AllocPageCount != 0, "ui32AllocPageCount");
+		PVR_LOG_RETURN_IF_FALSE(ui32AllocPageCount <= ui32LogicalChunkCount,
+		                        "ui32AllocPageCount is invalid",
+		                        PVRSRV_ERROR_PMR_BAD_MAPPINGTABLE_SIZE);
+	}
 
-		/* Every chunk index needs to be translated from physical indices
-		 * into heap based indices. */
-		for (uiPgIdx = 0; uiPgIdx < ui32AllocPageCount; uiPgIdx++)
+	if (uiSparseFlags & SPARSE_RESIZE_FREE)
+	{
+		PVR_LOG_RETURN_IF_INVALID_PARAM(ui32FreePageCount != 0, "ui32FreePageCount");
+		PVR_LOG_RETURN_IF_FALSE(ui32FreePageCount <= ui32LogicalChunkCount,
+		                        "ui32FreePageCount is invalid",
+		                        PVRSRV_ERROR_PMR_BAD_MAPPINGTABLE_SIZE);
+	}
+
+	pai32MapIndices = pai32AllocIndices;
+	pai32UnmapIndices = pai32FreeIndices;
+	uiMapPageCount = ui32AllocPageCount;
+	uiUnmapPageCount = ui32FreePageCount;
+
+	OSLockAcquire(psReservation->hLock);
+
+	PMRLockPMR(psPMR);
+
+	if (PMR_IsGpuMultiMapped(psPMR))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: PMR cannot be changed because PMR_IsGpuMultiMapped() = true",
+		         __func__));
+		PVR_GOTO_WITH_ERROR(eError,
+		                    PVRSRV_ERROR_PMR_NOT_PERMITTED,
+		                    e0);
+	}
+
+	/* Pre check free indices against reservation given */
+	if (uiSparseFlags & SPARSE_RESIZE_FREE)
+	{
+		IMG_UINT32 i;
+
+		eError = DevmemIntValidateSparsePMRIndices(ui32LogicalChunkCount,
+		                                           pai32FreeIndices,
+		                                           ui32FreePageCount);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemIntValidateSparsePMRIndices", e0);
+
+		eError = DevmemIntComputeVirtualIndicesFromLogical(psReservation,
+		                                                   ui32FreePageCount,
+		                                                   pai32FreeIndices,
+		                                                   &uiUnmapPageCount,
+		                                                   &pai32UnmapIndices);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemIntComputeVirtualIndicesFromLogical", e1);
+
+		for (i = 0; i < uiUnmapPageCount; i++)
 		{
-			for (uiPgOffset = 0; uiPgOffset < uiPagesPerOrder; uiPgOffset++)
+			IMG_UINT32 ui32VirtIndex = pai32UnmapIndices[i];
+			IMG_BOOL bIsMapped;
+
+			bIsMapped = DevmemIntReservationIsIndexMapped(psReservation,
+			                                              ui32VirtIndex);
+			if (!bIsMapped)
 			{
-				pai32MapIndices[uiPgIdx*uiPagesPerOrder + uiPgOffset] =
-						pai32AllocIndices[uiPgIdx]*uiPagesPerOrder + uiPgOffset;
+				PVR_DPF((PVR_DBG_ERROR,
+				         "%s: Reservation index %u is not mapped into the reservation",
+				         __func__,
+				         ui32VirtIndex));
+
+				PVR_GOTO_WITH_ERROR(eError,
+				                    PVRSRV_ERROR_DEVICEMEM_NO_MAPPING,
+				                    e1);
 			}
 		}
+	}
+
+	/* Pre check alloc indices against reservation given */
+	if (uiSparseFlags & SPARSE_RESIZE_ALLOC)
+	{
+		IMG_UINT32 i;
+
+		eError = DevmemIntValidateSparsePMRIndices(ui32LogicalChunkCount,
+		                                           pai32AllocIndices,
+		                                           ui32AllocPageCount);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemIntValidateSparsePMRIndices", e1);
 
-		for (uiPgIdx = 0; uiPgIdx < ui32FreePageCount; uiPgIdx++)
+		eError = DevmemIntComputeVirtualIndicesFromLogical(psReservation,
+		                                                   ui32AllocPageCount,
+		                                                   pai32AllocIndices,
+		                                                   &uiMapPageCount,
+		                                                   &pai32MapIndices);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemIntComputeVirtualIndicesFromLogical", e1);
+
+		for (i = 0; i < uiMapPageCount; i++)
 		{
-			for (uiPgOffset = 0; uiPgOffset < uiPagesPerOrder; uiPgOffset++)
+			IMG_UINT32 ui32VirtIndex = pai32MapIndices[i];
+			IMG_BOOL bIsMapped;
+
+			bIsMapped = DevmemIntReservationIsIndexMapped(psReservation,
+			                                              ui32VirtIndex);
+			if (bIsMapped)
 			{
-				pai32UnmapIndices[uiPgIdx*uiPagesPerOrder + uiPgOffset] =
-						pai32FreeIndices[uiPgIdx]*uiPagesPerOrder + uiPgOffset;
+				PVR_DPF((PVR_DBG_ERROR,
+				         "%s: Reservation index %u is mapped into the reservation",
+				         __func__,
+				         ui32VirtIndex));
+
+				PVR_GOTO_WITH_ERROR(eError,
+				                    PVRSRV_ERROR_DEVICEMEM_ALREADY_MAPPED,
+				                    e1);
 			}
 		}
 	}
 
-	/*
-	 * The order of steps in which this request is done is given below. The order of
-	 * operations is very important in this case:
-	 *
-	 * 1. The parameters are validated in function PMR_ChangeSparseMem below.
-	 *    A successful response indicates all the parameters are correct.
-	 *    In failure case we bail out from here without processing further.
-	 * 2. On success, get the PMR specific operations done. this includes page alloc, page free
-	 *    and the corresponding PMR status changes.
-	 *    when this call fails, it is ensured that the state of the PMR before is
-	 *    not disturbed. If it succeeds, then we can go ahead with the subsequent steps.
-	 * 3. Invalidate the GPU page table entries for the pages to be freed.
-	 * 4. Write the GPU page table entries for the pages that got allocated.
-	 * 5. Change the corresponding CPU space map.
-	 *
-	 * The above steps can be selectively controlled using flags.
-	 */
-	if (uiSparseFlags & SPARSE_RESIZE_BOTH)
-	{
-		/* Do the PMR specific changes first */
-		eError = PMR_ChangeSparseMem(psPMR,
-		                             ui32AllocPageCount,
-		                             pai32AllocIndices,
-		                             ui32FreePageCount,
-		                             pai32FreeIndices,
-		                             uiSparseFlags);
-		if (PVRSRV_OK != eError)
-		{
-			PVR_DPF((PVR_DBG_MESSAGE,
-					"%s: Failed to do PMR specific changes.",
-					__func__));
-			goto e1;
-		}
+	/* Invalidate the page table entries before freeing the physical pages. */
+	if (uiSparseFlags & SPARSE_RESIZE_FREE)
+	{
+		PMR_FLAGS_T uiPMRFlags;
+		IMG_UINT32 i;
 
-		/* Invalidate the page table entries for the free pages.
-		 * Optimisation later would be not to touch the ones that gets re-mapped */
-		if ((0 != ui32FreePageCount) && (uiSparseFlags & SPARSE_RESIZE_FREE))
-		{
-			PMR_FLAGS_T uiPMRFlags;
-
-			/*Get the flags*/
-			uiPMRFlags = PMR_Flags(psPMR);
-
-			/* Unmap the pages and mark them invalid in the MMU PTE */
-			MMU_UnmapPages (psDevmemHeap->psDevmemCtx->psMMUContext,
-			                uiFlags,
-			                sDevVAddrBase,
-			                uiUnmapPageCount,
-			                pai32UnmapIndices,
-			                uiLog2HeapContiguity,
-			                uiPMRFlags);
-		}
+		/*Get the flags*/
+		uiPMRFlags = PMR_Flags(psPMR);
+
+		/* Unmap the pages and mark them invalid in the MMU PTE */
+		eError = MMU_UnmapPages(psReservation->psDevmemHeap->psDevmemCtx->psMMUContext,
+		                        uiFlags,
+		                        psReservation->sBase,
+		                        uiUnmapPageCount,
+		                        pai32UnmapIndices,
+		                        uiLog2HeapContiguity,
+		                        uiPMRFlags);
+		PVR_LOG_GOTO_IF_ERROR(eError, "MMU_UnmapPages", e1);
 
-		/* Wire the pages tables that got allocated */
-		if ((0 != ui32AllocPageCount) && (uiSparseFlags & SPARSE_RESIZE_ALLOC))
+		for (i = 0; i < uiUnmapPageCount; i++)
 		{
-			/* Map the pages and mark them Valid in the MMU PTE */
-			eError = MMU_MapPages (psDevmemHeap->psDevmemCtx->psMMUContext,
-			                       uiFlags,
-			                       sDevVAddrBase,
-			                       psPMR,
-			                       0,
-			                       uiMapPageCount,
-			                       pai32MapIndices,
-			                       uiLog2HeapContiguity);
-			if (PVRSRV_OK != eError)
+			IMG_UINT32 uiIndex = pai32UnmapIndices[i];
+
+			if (DevmemIntReservationIsIndexMapped(psReservation, uiIndex))
 			{
-				PVR_DPF((PVR_DBG_MESSAGE,
-						"%s: Failed to map alloc indices.",
-						__func__));
-				goto e1;
+				PMRUnrefPMR2(psReservation->psMappedPMR);
+				DevmemIntReservationSetMappingIndex(psReservation,
+				                                    uiIndex,
+				                                    IMG_FALSE);
 			}
 		}
 	}
 
-#ifndef PVRSRV_UNMAP_ON_SPARSE_CHANGE
-	/* Do the changes in sparse on to the CPU virtual map accordingly */
-	if (uiSparseFlags & SPARSE_MAP_CPU_ADDR)
+	/* Do the PMR specific changes */
+	eError = PMR_ChangeSparseMemUnlocked(psPMR,
+	                                     ui32AllocPageCount,
+	                                     pai32AllocIndices,
+	                                     ui32FreePageCount,
+	                                     pai32FreeIndices,
+	                                     uiSparseFlags);
+	if (PVRSRV_OK != eError)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE,
+		         "%s: Failed to do PMR specific changes.",
+		         __func__));
+		goto e1;
+	}
+
+	/* Wire the pages tables that got allocated */
+	if (uiSparseFlags & SPARSE_RESIZE_ALLOC)
 	{
-		if (sCpuVAddrBase != 0)
+		IMG_UINT32 i;
+		/* Map the pages and mark them Valid in the MMU PTE */
+		eError = MMU_MapPages(psReservation->psDevmemHeap->psDevmemCtx->psMMUContext,
+		                      uiFlags,
+		                      psReservation->sBase,
+		                      psPMR,
+		                      0,
+		                      uiMapPageCount,
+		                      pai32MapIndices,
+		                      uiLog2HeapContiguity);
+		if (PVRSRV_OK != eError)
+		{
+			PVR_DPF((PVR_DBG_MESSAGE,
+			         "%s: Failed to map alloc indices.",
+			         __func__));
+			goto e1;
+		}
+
+		for (i = 0; i < uiMapPageCount; i++)
 		{
-			eError = PMR_ChangeSparseMemCPUMap(psPMR,
-			                                   sCpuVAddrBase,
-			                                   ui32AllocPageCount,
-			                                   pai32AllocIndices,
-			                                   ui32FreePageCount,
-			                                   pai32FreeIndices);
-			if (PVRSRV_OK != eError)
+			IMG_UINT32 uiIndex = pai32MapIndices[i];
+
+			if (!DevmemIntReservationIsIndexMapped(psReservation, uiIndex))
 			{
-				PVR_DPF((PVR_DBG_MESSAGE,
-						"%s: Failed to map to CPU addr space.",
-						__func__));
-				goto e0;
+				PMRRefPMR2(psReservation->psMappedPMR);
+				DevmemIntReservationSetMappingIndex(psReservation,
+				                                    uiIndex,
+				                                    IMG_TRUE);
 			}
 		}
 	}
-#endif
 
 e1:
 	if (pai32MapIndices != pai32AllocIndices)
@@ -1395,6 +2001,8 @@ DevmemIntChangeSparse(DEVMEMINT_HEAP *psDevmemHeap,
 		OSFreeMem(pai32UnmapIndices);
 	}
 e0:
+	PMRUnlockPMR(psPMR);
+	OSLockRelease(psReservation->hLock);
 	return eError;
 }
 
@@ -1424,17 +2032,13 @@ DevmemIntCtxDestroy(DEVMEMINT_CTX *psDevmemCtx)
 /*************************************************************************/ /*!
 @Function       DevmemIntGetVDevAddrPageSize
 @Description    Get the page size for a virtual address.
-@Input          psConnection
 @Input			psDevNode
-@Input			psDevmemCtx			Device Memory context
 @Input			sDevAddr			Get the page size for this virtual address.
 @Output			puiLog2HeapPageSize	On success returns log2 of the page size.
 @Return         Failure code if the virtual address is outside any heap.
 */ /**************************************************************************/
 static
-PVRSRV_ERROR DevmemIntGetVDevAddrPageSize(CONNECTION_DATA * psConnection,
-										  PVRSRV_DEVICE_NODE *psDevNode,
-										  DEVMEMINT_CTX *psDevMemContext,
+PVRSRV_ERROR DevmemIntGetVDevAddrPageSize(PVRSRV_DEVICE_NODE *psDevNode,
 										  IMG_DEV_VIRTADDR sDevAddr,
 										  IMG_PUINT32 puiLog2HeapPageSize)
 {
@@ -1492,9 +2096,10 @@ PVRSRV_ERROR DevmemIntIsVDevAddrValid(CONNECTION_DATA * psConnection,
 {
 	IMG_UINT32 uiLog2HeapPageSize = 0;
 	PVRSRV_ERROR eError;
-	eError = DevmemIntGetVDevAddrPageSize(psConnection,
-										  psDevNode,
-										  psDevMemContext,
+
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
+	eError = DevmemIntGetVDevAddrPageSize(psDevNode,
 										  sDevAddr,
 										  &uiLog2HeapPageSize);
 	if (eError != PVRSRV_OK)
@@ -1529,6 +2134,9 @@ PVRSRV_ERROR DevmemIntGetFaultAddress(CONNECTION_DATA *psConnection,
                                       DEVMEMINT_CTX *psDevMemContext,
                                       IMG_DEV_VIRTADDR *psFaultAddress)
 {
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDevNode);
+
 	if ((psDevMemContext->ui32Flags & DEVMEMCTX_FLAGS_FAULT_ADDRESS_AVAILABLE) == 0)
 	{
 		return PVRSRV_ERROR_RESOURCE_UNAVAILABLE;
@@ -1571,11 +2179,15 @@ DevmemIntExportCtx(DEVMEMINT_CTX *psContext,
                    DEVMEMINT_CTX_EXPORT **ppsContextExport)
 {
 	DEVMEMINT_CTX_EXPORT *psCtxExport;
+	PVRSRV_ERROR eError;
 
 	psCtxExport = OSAllocMem(sizeof(DEVMEMINT_CTX_EXPORT));
 	PVR_LOG_RETURN_IF_NOMEM(psCtxExport, "psCtxExport");
 
-	DevmemIntCtxAcquire(psContext);
+	if (!DevmemIntCtxAcquire(psContext))
+	{
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, ErrorFreeCtxExport);
+	}
 	PMRRefPMR(psPMR);
 	/* Now that the source PMR is exported, the layout
 	 * can't change as there could be outstanding importers
@@ -1591,16 +2203,23 @@ DevmemIntExportCtx(DEVMEMINT_CTX *psContext,
 	*ppsContextExport = psCtxExport;
 
 	return PVRSRV_OK;
+
+ErrorFreeCtxExport:
+	OSFreeMem(psCtxExport);
+
+	return eError;
 }
 
 PVRSRV_ERROR
 DevmemIntUnexportCtx(DEVMEMINT_CTX_EXPORT *psContextExport)
 {
-	PMRUnrefPMR(psContextExport->psPMR);
-	DevmemIntCtxRelease(psContextExport->psDevmemCtx);
 	OSWRLockAcquireWrite(g_hExportCtxListLock);
 	dllist_remove_node(&psContextExport->sNode);
 	OSWRLockReleaseWrite(g_hExportCtxListLock);
+
+	PMRUnrefPMR(psContextExport->psPMR);
+	DevmemIntCtxRelease(psContextExport->psDevmemCtx);
+
 	OSFreeMem(psContextExport);
 
 	/* Unable to find exported context, return error */
@@ -1622,7 +2241,12 @@ DevmemIntAcquireRemoteCtx(PMR *psPMR,
 		psCtxExport = IMG_CONTAINER_OF(psListNode, DEVMEMINT_CTX_EXPORT, sNode);
 		if (psCtxExport->psPMR == psPMR)
 		{
-			DevmemIntCtxAcquire(psCtxExport->psDevmemCtx);
+			if (!DevmemIntCtxAcquire(psCtxExport->psDevmemCtx))
+			{
+				OSWRLockReleaseRead(g_hExportCtxListLock);
+
+				return PVRSRV_ERROR_REFCOUNT_OVERFLOW;
+			}
 			*ppsContext = psCtxExport->psDevmemCtx;
 			*phPrivData = psCtxExport->psDevmemCtx->hPrivData;
 
@@ -1665,24 +2289,28 @@ PVRSRV_ERROR DevmemIntRegisterPFNotifyKM(DEVMEMINT_CTX *psDevmemCtx,
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psDevmemCtx, "psDevmemCtx");
 
-	/* Acquire write lock for the duration, to avoid resource free
-	 * while trying to read (no need to then also acquire the read lock
-	 * as we have exclusive access while holding the write lock)
+	/* We can be certain that the memory context is valid and not freed during
+	 * the call time of this function as it's assured by the handle framework
+	 * (while the handle is looked up it cannot be freed). Therefore we can
+	 * safely retrieve the pointer to the device node and acquire the
+	 * hPageFaultNotifyLock lock.
 	 */
-	OSWRLockAcquireWrite(psDevmemCtx->hListLock);
-
 	psDevNode = psDevmemCtx->psDevNode;
 
+	/* Acquire write lock to avoid resource free while
+	 * sMemoryContextPageFaultNotifyListHead and sProcessNotifyListHead
+	 * are being accessed.
+	 */
+	OSWRLockAcquireWrite(psDevNode->hPageFaultNotifyLock);
+
 	if (bRegister)
 	{
 		/* If this is the first PID in the list, the device memory context
 		 * needs to be registered for notification */
 		if (dllist_is_empty(&psDevmemCtx->sProcessNotifyListHead))
 		{
-			OSWRLockAcquireWrite(psDevNode->hMemoryContextPageFaultNotifyListLock);
 			dllist_add_to_tail(&psDevNode->sMemoryContextPageFaultNotifyListHead,
 			                   &psDevmemCtx->sPageFaultNotifyListElem);
-			OSWRLockReleaseWrite(psDevNode->hMemoryContextPageFaultNotifyListLock);
 		}
 	}
 
@@ -1745,9 +2373,7 @@ PVRSRV_ERROR DevmemIntRegisterPFNotifyKM(DEVMEMINT_CTX *psDevmemCtx,
 		 * unregister the device memory context from the notify list. */
 		if (dllist_is_empty(&psDevmemCtx->sProcessNotifyListHead))
 		{
-			OSWRLockAcquireWrite(psDevNode->hMemoryContextPageFaultNotifyListLock);
 			dllist_remove_node(&psDevmemCtx->sPageFaultNotifyListElem);
-			OSWRLockReleaseWrite(psDevNode->hMemoryContextPageFaultNotifyListLock);
 		}
 	}
 	eError = PVRSRV_OK;
@@ -1755,8 +2381,7 @@ PVRSRV_ERROR DevmemIntRegisterPFNotifyKM(DEVMEMINT_CTX *psDevmemCtx,
 err_already_registered:
 err_out_of_mem:
 err_not_registered:
-
-	OSWRLockReleaseWrite(psDevmemCtx->hListLock);
+	OSWRLockReleaseWrite(psDevNode->hPageFaultNotifyLock);
 	return eError;
 }
 
@@ -1780,10 +2405,14 @@ PVRSRV_ERROR DevmemIntPFNotify(PVRSRV_DEVICE_NODE *psDevNode,
 	DEVMEMINT_CTX       *psDevmemCtx = NULL;
 	IMG_BOOL            bFailed = IMG_FALSE;
 
-	OSWRLockAcquireRead(psDevNode->hMemoryContextPageFaultNotifyListLock);
+	/* Protect access both to sMemoryContextPageFaultNotifyListHead and
+	 * to sProcessNotifyListHead. Those lists must be accessed atomically
+	 * in relation to each other, otherwise we risk accessing context that
+	 * might have already been destroyed. */
+	OSWRLockAcquireRead(psDevNode->hPageFaultNotifyLock);
 	if (dllist_is_empty(&(psDevNode->sMemoryContextPageFaultNotifyListHead)))
 	{
-		OSWRLockReleaseRead(psDevNode->hMemoryContextPageFaultNotifyListLock);
+		OSWRLockReleaseRead(psDevNode->hPageFaultNotifyLock);
 		return PVRSRV_OK;
 	}
 
@@ -1797,7 +2426,7 @@ PVRSRV_ERROR DevmemIntPFNotify(PVRSRV_DEVICE_NODE *psDevNode,
 		if (eError != PVRSRV_OK)
 		{
 			PVR_LOG_ERROR(eError, "MMU_AcquireBaseAddr");
-			OSWRLockReleaseRead(psDevNode->hMemoryContextPageFaultNotifyListLock);
+			OSWRLockReleaseRead(psDevNode->hPageFaultNotifyLock);
 			return eError;
 		}
 
@@ -1807,14 +2436,13 @@ PVRSRV_ERROR DevmemIntPFNotify(PVRSRV_DEVICE_NODE *psDevNode,
 			break;
 		}
 	}
-	OSWRLockReleaseRead(psDevNode->hMemoryContextPageFaultNotifyListLock);
 
 	if (psDevmemCtx == NULL)
 	{
 		/* Not found, just return */
+		OSWRLockReleaseRead(psDevNode->hPageFaultNotifyLock);
 		return PVRSRV_OK;
 	}
-	OSWRLockAcquireRead(psDevmemCtx->hListLock);
 
 	/*
 	 * Store the first occurrence of a page fault address,
@@ -1844,7 +2472,7 @@ PVRSRV_ERROR DevmemIntPFNotify(PVRSRV_DEVICE_NODE *psDevNode,
 			bFailed = IMG_TRUE;
 		}
 	}
-	OSWRLockReleaseRead(psDevmemCtx->hListLock);
+	OSWRLockReleaseRead(psDevNode->hPageFaultNotifyLock);
 
 	if (bFailed)
 	{
@@ -1854,6 +2482,7 @@ PVRSRV_ERROR DevmemIntPFNotify(PVRSRV_DEVICE_NODE *psDevNode,
 	return PVRSRV_OK;
 }
 
+
 #if defined(PDUMP)
 typedef struct _DEVMEMINT_PDUMP_VALID_REGION_
 {
@@ -1883,9 +2512,7 @@ DevmemIntPDumpGetValidRegions(CONNECTION_DATA * psConnection,
 	IMG_DEV_VIRTADDR sValidStart, sValidEnd, sCurrent, sEnd, sStartPage;
 
 	/* Get the page size for heap containing the start virtual address. */
-	eError = DevmemIntGetVDevAddrPageSize(psConnection,
-	                                      psDeviceNode,
-	                                      psDevmemCtx,
+	eError = DevmemIntGetVDevAddrPageSize(psDeviceNode,
 	                                      sDevAddrStart,
 	                                      &uiLog2HeapPageSize);
 	PVR_RETURN_IF_ERROR(eError);
@@ -2082,9 +2709,7 @@ DevmemIntPDumpSaveToFileVirtual(CONNECTION_DATA * psConnection,
 	/*
 	  Get the page size for heap containing the start virtual address.
 	 */
-	eError = DevmemIntGetVDevAddrPageSize(psConnection,
-										  psDeviceNode,
-										  psDevmemCtx,
+	eError = DevmemIntGetVDevAddrPageSize(psDeviceNode,
 										  sDevAddrStart,
 										  &uiLog2HeapPageSize);
 	if (eError != PVRSRV_OK)
diff --git a/drivers/gpu/drm/img-rogue/devicemem_server.h b/drivers/gpu/drm/img-rogue/devicemem_server.h
index 0f893cd9f7b3..8fa2b90cbda8 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_server.h
+++ b/drivers/gpu/drm/img-rogue/devicemem_server.h
@@ -58,6 +58,7 @@ typedef struct _DEVMEMINT_CTX_EXPORT_ DEVMEMINT_CTX_EXPORT;
 typedef struct _DEVMEMINT_HEAP_ DEVMEMINT_HEAP;
 
 typedef struct _DEVMEMINT_RESERVATION_ DEVMEMINT_RESERVATION;
+
 typedef struct _DEVMEMINT_MAPPING_ DEVMEMINT_MAPPING;
 typedef struct _DEVMEMXINT_RESERVATION_ DEVMEMXINT_RESERVATION;
 typedef struct _DEVMEMINT_PF_NOTIFY_ DEVMEMINT_PF_NOTIFY;
@@ -167,8 +168,6 @@ PVRSRV_ERROR
 DevmemIntHeapCreate(DEVMEMINT_CTX *psDevmemCtx,
                     IMG_UINT32 uiHeapConfigIndex,
                     IMG_UINT32 uiHeapIndex,
-                    IMG_DEV_VIRTADDR sHeapBaseAddr,
-                    IMG_UINT32 uiLog2DataPageSize,
                     DEVMEMINT_HEAP **ppsDevmemHeapPtr);
 /*
  * DevmemIntHeapDestroy()
@@ -188,81 +187,136 @@ DevmemIntHeapDestroy(DEVMEMINT_HEAP *psDevmemHeap);
 IMG_DEV_VIRTADDR
 DevmemIntHeapGetBaseAddr(DEVMEMINT_HEAP *psDevmemHeap);
 
-/*
- * DevmemIntMapPMR()
- *
- * Maps the given PMR to the virtual range previously allocated with
- * DevmemIntReserveRange()
- *
- * If appropriate, the PMR must have had its physical backing committed, as
- * this call will call into the MMU code to set up the page tables for this
- * allocation, which shall in turn request the physical addresses from the
- * PMR. Alternatively, the PMR implementation can choose to do so off the
- * the back of the "lock" callback, which it will receive as a result
- * (indirectly) of this call.
- *
- * This function makes no promise w.r.t. the circumstances that it can be
- * called, and these would be "inherited" from the implementation of the PMR.
- * For example if the PMR "lock" callback causes pages to be pinned at that
- * time (which may cause scheduling or disk I/O etc.) then it would not be
- * legal to "Map" the PMR in a context where scheduling events are disallowed.
- *
- * If you call DevmemIntMapPMR() (and the call succeeds) then you are promising
- * that you shall later call DevmemIntUnmapPMR()
- */
-PVRSRV_ERROR
-DevmemIntMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
-                DEVMEMINT_RESERVATION *psReservation,
-                PMR *psPMR,
-                PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-                DEVMEMINT_MAPPING **ppsMappingPtr);
-/*
- * DevmemIntUnmapPMR()
+/*************************************************************************/ /*!
+ * @Function    DevmemIntReserveRange()
+ * @Description Reserves a number of virtual addresses starting sReservationVAddr
+ *              and continuing until sReservationVAddr + uiVirtualSize - 1.
  *
- * Reverses the mapping caused by DevmemIntMapPMR()
- */
+ *              If you call DevmemIntReserveRange() (and the call succeeds)
+ *              then you are promising that you shall later call DevmemIntUnreserveRange()
+ *
+ * @Input       psDevmemHeap        The virtual heap the DevVAddr is within.
+ * @Input       sReservationVAddr   The first virtual address of the range.
+ * @Input       uiVirtualSize       The number of bytes in the virtual range.
+ * @Input       uiFlags             Mem alloc flags
+ * @Output      ppsReservationPtr   A pointer to the created reservation.
+ *
+ * @Return      PVRSRV_ERROR
+*/ /**************************************************************************/
 PVRSRV_ERROR
-DevmemIntUnmapPMR(DEVMEMINT_MAPPING *psMapping);
-
-
+DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
+                      IMG_DEV_VIRTADDR sReservationVAddr,
+                      IMG_DEVMEM_SIZE_T uiVirtualSize,
+                      PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                      DEVMEMINT_RESERVATION **ppsReservationPtr);
 
-/*
- * DevmemIntReserveRangeAndMapPMR()
- * Bundled call to reserve range and map.
- */
+/*************************************************************************/ /*!
+ * @Function    DevmemIntUnreserveRange()
+ * @Description Unreserves the specified virtual range. In the case that the
+ *              virtual range has not been unmapped, it will be unmapped.
+ *              If any references are held on the reservation PVRSRV_ERROR_RETRY
+ *              will be returned.
+ *
+ * @Input       psDevmemReservation The reservation to unreserve
+ *
+ * @Return      PVRSRV_ERROR
+*/ /**************************************************************************/
 PVRSRV_ERROR
-DevmemIntReserveRangeAndMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
-							   IMG_DEV_VIRTADDR sAllocationDevVAddr,
-							   IMG_DEVMEM_SIZE_T uiAllocationSize,
-							   PMR *psPMR,
-							   PVRSRV_MEMALLOCFLAGS_T uiMapFlags,
-							   DEVMEMINT_MAPPING **ppsMappingPtr);
+DevmemIntUnreserveRange(DEVMEMINT_RESERVATION *psDevmemReservation);
 
+/*************************************************************************/ /*!
+ * @Function    DevmemIntMapPMR
+ *
+ * @Description Maps the given PMR to the virtual range previously reserved with
+ *              DevmemIntReserveRange(). When calling this function, the reservation
+ *              must be valid, and not mapped. Additionally, the PMRs logical
+ *              size and the reservations virtual size must be equal.
+ *
+ *              If appropriate, the PMR must have had its physical backing
+ *              committed, as this call will call into the MMU code to set
+ *              up the page tables for this allocation, which shall in turn
+ *              request the physical addresses from the PMR. Alternatively,
+ *              the PMR implementation can choose to do so off the back of
+ *              the "lock" callback, which it will receive as a result
+ *              (indirectly) of this call.
+ *
+ *              If you call DevmemIntMapPMR() (and the call succeeds) then you
+ *              are promising that you shall later call DevmemIntUnmapPMR()
+ *
+ * @Input       psReservation    The reservation the PMR will be mapped into.
+ * @Input       psPMR            The PMR to be mapped.
+ *
+ * @Return      PVRSRV_ERROR failure code
+*/ /**************************************************************************/
 PVRSRV_ERROR
-DevmemIntUnreserveRangeAndUnmapPMR(DEVMEMINT_MAPPING *psMappingPtr);
+DevmemIntMapPMR(DEVMEMINT_RESERVATION *psReservation, PMR *psPMR);
 
-/*
- * DevmemIntReserveRange()
+/*************************************************************************/ /*!
+ * @Function    DevmemIntUnmapPMR()
  *
- * Indicates that the specified range should be reserved from the given heap.
+ * @Description Unmaps a previously mapped virtual range.
  *
- * In turn causes the page tables to be allocated to cover the specified range.
+ * @Input       psReservation   The virtual range to unmap.
  *
- * If you call DevmemIntReserveRange() (and the call succeeds) then you are
- * promising that you shall later call DevmemIntUnreserveRange()
- */
+ * @Return      PVRSRV_ERROR
+*/ /**************************************************************************/
 PVRSRV_ERROR
-DevmemIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
-                      IMG_DEV_VIRTADDR sAllocationDevVAddr,
-                      IMG_DEVMEM_SIZE_T uiAllocationSize,
-                      DEVMEMINT_RESERVATION **ppsReservationPtr);
-/*
- * DevmemIntUnreserveRange()
+DevmemIntUnmapPMR(DEVMEMINT_RESERVATION *psReservation);
+
+
+/*************************************************************************/ /*!
+ * @Function    DevmemIntReserveRangeAndMapPMR()
  *
- * Undoes the state change caused by DevmemIntReserveRage()
- */
+ * @Description Reserve (with DevmemIntReserveRange), and map a virtual range
+ *              to a PMR (with DevmemIntMapPMR).
+ *
+ * @Input       psDevmemHeap        The virtual heap DevVAddr is within.
+ * @Input       sReservationVAddr   The first virtual address of the range.
+ * @Input       uiVirtualSize       The number of bytes in the virtual range.
+ * @Input       psPMR               The PMR to be mapped.
+ * @Input       uiFlags             Mem alloc flags
+ * @Output      ppsReservation      A pointer to the created reservation.
+ *
+ * @Return      PVRSRV_ERROR
+*/ /**************************************************************************/
 PVRSRV_ERROR
-DevmemIntUnreserveRange(DEVMEMINT_RESERVATION *psDevmemReservation);
+DevmemIntReserveRangeAndMapPMR(DEVMEMINT_HEAP *psDevmemHeap,
+                               IMG_DEV_VIRTADDR sReservationVAddr,
+                               IMG_DEVMEM_SIZE_T uiVirtualSize,
+                               PMR *psPMR,
+                               PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                               DEVMEMINT_RESERVATION **ppsReservation);
+
+/*************************************************************************/ /*!
+ * @Function       DevmemIntChangeSparse
+ * @Description    Changes the sparse allocations of a PMR by allocating and freeing
+ *                 pages and changing their corresponding GPU mapping.
+ *
+ *                 Prior to calling this function DevmemIntMapPMR
+ *                 or DevmemIntReserveRangeAndMapPMR must be used.
+ *
+ * @Input          psReservation         The reservation that the PMR is mapped to.
+ * @Input          ui32AllocPageCount    Number of pages to allocate
+ * @Input          pai32AllocIndices     The logical PMR indices where pages will
+ *                                       be allocated. May be NULL.
+ * @Input          ui32FreePageCount     Number of pages to free
+ * @Input          pai32FreeIndices      The logical PMR indices where pages will
+ *                                       be freed. May be NULL.
+ * @Input          uiSparseFlags         Flags passed in to determine which kind
+ *                                       of sparse change the user wanted.
+ *                                       See devicemem_typedefs.h for details.
+ * @Return         PVRSRV_ERROR
+*/ /**************************************************************************/
+PVRSRV_ERROR
+DevmemIntChangeSparse(IMG_UINT32 ui32AllocPageCount,
+                      IMG_UINT32 *pai32AllocIndices,
+                      IMG_UINT32 ui32FreePageCount,
+                      IMG_UINT32 *pai32FreeIndices,
+                      SPARSE_MEM_RESIZE_FLAGS uiSparseFlags,
+                      DEVMEMINT_RESERVATION *psReservation);
+
+PVRSRV_ERROR
+DevmemIntGetReservationData(DEVMEMINT_RESERVATION* psReservation, PMR** ppsPMR, IMG_DEV_VIRTADDR* psDevVAddr);
 
 /*************************************************************************/ /*!
  * @Function    DevmemXIntReserveRange()
@@ -278,16 +332,16 @@ DevmemIntUnreserveRange(DEVMEMINT_RESERVATION *psDevmemReservation);
  *
  * @Input       psDevmemHeap        Pointer to the heap the reservation is made
  *                                  on
- * @Input       sAllocationDevVAddr Virtual address of the reservation
- * @Input       uiAllocationSize    Size of the reservation (in bytes)
+ * @Input       sReservationVAddr   Virtual address of the reservation
+ * @Input       uiVirtualSize       Size of the reservation (in bytes)
  * @Input       ppsRsrv             Return pointer to the reservation object
  *
  * @Return      PVRSRV_ERROR
 */ /**************************************************************************/
 PVRSRV_ERROR
 DevmemXIntReserveRange(DEVMEMINT_HEAP *psDevmemHeap,
-                       IMG_DEV_VIRTADDR sAllocationDevVAddr,
-                       IMG_DEVMEM_SIZE_T uiAllocationSize,
+                       IMG_DEV_VIRTADDR sReservationVAddr,
+                       IMG_DEVMEM_SIZE_T uiVirtualSize,
                        DEVMEMXINT_RESERVATION **ppsRsrv);
 
 /*************************************************************************/ /*!
@@ -380,43 +434,8 @@ DevmemXIntMapVRangeToBackingPage(DEVMEMXINT_RESERVATION *psRsrv,
                                  PVRSRV_MEMALLOCFLAGS_T uiFlags,
                                  IMG_UINT32 uiVirtPageOffset);
 
-/*************************************************************************/ /*!
-@Function       DevmemIntChangeSparse
-@Description    Changes the sparse allocations of a PMR by allocating and freeing
-                pages and changing their corresponding CPU and GPU mappings.
-
-@input          psDevmemHeap          Pointer to the heap we map on
-@input          psPMR                 The PMR we want to map
-@input          ui32AllocPageCount    Number of pages to allocate
-@input          pai32AllocIndices     The logical PMR indices where pages will
-                                      be allocated. May be NULL.
-@input          ui32FreePageCount     Number of pages to free
-@input          pai32FreeIndices      The logical PMR indices where pages will
-                                      be freed. May be NULL.
-@input          uiSparseFlags         Flags passed in to determine which kind
-                                      of sparse change the user wanted.
-                                      See devicemem_typedefs.h for details.
-@input          uiFlags               Memalloc flags for this virtual range.
-@input          sDevVAddrBase         The base address of the virtual range of
-                                      this sparse allocation.
-@input          sCpuVAddrBase         The CPU base address of this allocation.
-                                      May be 0 if not existing.
-@Return         PVRSRV_ERROR failure code
-*/ /**************************************************************************/
-PVRSRV_ERROR
-DevmemIntChangeSparse(DEVMEMINT_HEAP *psDevmemHeap,
-                      PMR *psPMR,
-                      IMG_UINT32 ui32AllocPageCount,
-                      IMG_UINT32 *pai32AllocIndices,
-                      IMG_UINT32 ui32FreePageCount,
-                      IMG_UINT32 *pai32FreeIndices,
-                      SPARSE_MEM_RESIZE_FLAGS uiSparseFlags,
-                      PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                      IMG_DEV_VIRTADDR sDevVAddrBase,
-                      IMG_UINT64 sCpuVAddrBase);
-
 /*
- * DevmemIntRGXInvalidateFBSCTable()
+ * DevmemIntInvalidateFBSCTable()
  *
  * Invalidate selected FBSC table indices.
  *
diff --git a/drivers/gpu/drm/img-rogue/devicemem_server_utils.h b/drivers/gpu/drm/img-rogue/devicemem_server_utils.h
index ad85c07cdcf6..923bfc9a8f18 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_server_utils.h
+++ b/drivers/gpu/drm/img-rogue/devicemem_server_utils.h
@@ -47,8 +47,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_memallocflags.h"
 #include "pvrsrv.h"
 
-static INLINE PVRSRV_ERROR DevmemCPUCacheMode(PVRSRV_DEVICE_NODE *psDeviceNode,
-											  PVRSRV_MEMALLOCFLAGS_T ulFlags,
+static INLINE PVRSRV_ERROR DevmemCPUCacheMode(PVRSRV_MEMALLOCFLAGS_T ulFlags,
 											  IMG_UINT32 *pui32Ret)
 {
 	IMG_UINT32 ui32CPUCacheMode = PVRSRV_CPU_CACHE_MODE(ulFlags);
@@ -79,8 +78,7 @@ static INLINE PVRSRV_ERROR DevmemCPUCacheMode(PVRSRV_DEVICE_NODE *psDeviceNode,
 			 * This avoids errors on arm64 when uncached is turned into ordered device memory
 			 * and suffers from problems with unaligned access.
 			 */
-			if ( (PVRSRV_GPU_CACHE_MODE(ulFlags) == PVRSRV_MEMALLOCFLAG_GPU_CACHE_COHERENT) &&
-				!(PVRSRVSystemSnoopingOfCPUCache(psDeviceNode->psDevConfig) && PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig)) )
+			if (PVRSRV_GPU_CACHE_MODE(ulFlags) == PVRSRV_MEMALLOCFLAG_GPU_CACHE_COHERENT)
 			{
 				ui32Ret = PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC;
 			}
@@ -107,8 +105,7 @@ static INLINE PVRSRV_ERROR DevmemCPUCacheMode(PVRSRV_DEVICE_NODE *psDeviceNode,
 	return eError;
 }
 
-static INLINE PVRSRV_ERROR DevmemDeviceCacheMode(PVRSRV_DEVICE_NODE *psDeviceNode,
-												 PVRSRV_MEMALLOCFLAGS_T ulFlags,
+static INLINE PVRSRV_ERROR DevmemDeviceCacheMode(PVRSRV_MEMALLOCFLAGS_T ulFlags,
 												 IMG_UINT32 *pui32Ret)
 {
 	IMG_UINT32 ui32DeviceCacheMode = PVRSRV_GPU_CACHE_MODE(ulFlags);
@@ -139,8 +136,7 @@ static INLINE PVRSRV_ERROR DevmemDeviceCacheMode(PVRSRV_DEVICE_NODE *psDeviceNod
 			 * This avoids errors on arm64 when uncached is turned into ordered device memory
 			 * and suffers from problems with unaligned access.
 			 */
-			if ( (PVRSRV_CPU_CACHE_MODE(ulFlags) == PVRSRV_MEMALLOCFLAG_CPU_CACHE_COHERENT) &&
-				!(PVRSRVSystemSnoopingOfCPUCache(psDeviceNode->psDevConfig) && PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig)) )
+			if (PVRSRV_CPU_CACHE_MODE(ulFlags) == PVRSRV_MEMALLOCFLAG_CPU_CACHE_COHERENT)
 			{
 				ui32Ret = PVRSRV_MEMALLOCFLAG_GPU_UNCACHED_WC;
 			}
@@ -167,21 +163,6 @@ static INLINE PVRSRV_ERROR DevmemDeviceCacheMode(PVRSRV_DEVICE_NODE *psDeviceNod
 	return eError;
 }
 
-static INLINE IMG_BOOL DevmemCPUCacheCoherency(PVRSRV_DEVICE_NODE *psDeviceNode,
-											   PVRSRV_MEMALLOCFLAGS_T ulFlags)
-{
-	IMG_UINT32 ui32CPUCacheMode = PVRSRV_CPU_CACHE_MODE(ulFlags);
-	IMG_BOOL bRet = IMG_FALSE;
-
-	PVR_ASSERT(ui32CPUCacheMode == PVRSRV_CPU_CACHE_MODE(ulFlags));
-
-	if (ui32CPUCacheMode == PVRSRV_MEMALLOCFLAG_CPU_CACHE_COHERENT)
-	{
-		bRet = PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig);
-	}
-	return bRet;
-}
-
 static INLINE IMG_BOOL DevmemDeviceCacheCoherency(PVRSRV_DEVICE_NODE *psDeviceNode,
 												  PVRSRV_MEMALLOCFLAGS_T ulFlags)
 {
diff --git a/drivers/gpu/drm/img-rogue/devicemem_typedefs.h b/drivers/gpu/drm/img-rogue/devicemem_typedefs.h
index 683af9a04f04..d51c099eed7a 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_typedefs.h
+++ b/drivers/gpu/drm/img-rogue/devicemem_typedefs.h
@@ -112,16 +112,6 @@ typedef IMG_UINT32 SPARSE_MEM_RESIZE_FLAGS;
 
 #define SPARSE_RESIZE_BOTH (SPARSE_RESIZE_ALLOC | SPARSE_RESIZE_FREE)
 
-	/* Should be set to get the sparse changes appear in cpu virtual map */
-#define SPARSE_MAP_CPU_ADDR 8U
-
-
-/* To be used with all the sparse allocations that gets mapped to CPU Virtual
- * space. The sparse allocation CPU mapping is torn down and re-mapped every
- * time the sparse allocation layout changes.
- */
-#define PVRSRV_UNMAP_ON_SPARSE_CHANGE 1
-
 /* To use with DevmemSubAllocate() as the default factor if no over-allocation
  * is desired.
  */
diff --git a/drivers/gpu/drm/img-rogue/devicemem_utils.c b/drivers/gpu/drm/img-rogue/devicemem_utils.c
index 7b60110310c1..741063b8b1aa 100644
--- a/drivers/gpu/drm/img-rogue/devicemem_utils.c
+++ b/drivers/gpu/drm/img-rogue/devicemem_utils.c
@@ -1022,31 +1022,32 @@ PVRSRV_ERROR DevmemImportStructDevMap(DEVMEM_HEAP *psHeap,
 		}
 		else
 		{
+			PVRSRV_MEMALLOCFLAGS_T uiFlags;
+			uiFlags = psImport->uiFlags & PVRSRV_MEMALLOCFLAGS_PERMAPPINGFLAGSMASK;
 			if (bMap)
 			{
-				PVRSRV_MEMALLOCFLAGS_T uiMapFlags;
-				uiMapFlags = psImport->uiFlags & PVRSRV_MEMALLOCFLAGS_PERMAPPINGFLAGSMASK;
-
 				eError = BridgeDevmemIntReserveRangeAndMapPMR(GetBridgeHandle(psHeap->psCtx->hDevConnection),
-						psHeap->hDevMemServerHeap,
-						sBase,
-						uiAllocatedSize,
-						psImport->hPMR,
-						uiMapFlags,
-						&psDeviceImport->hMapping);
+				                                              psHeap->hDevMemServerHeap,
+				                                              sBase,
+				                                              uiAllocatedSize,
+				                                              psImport->hPMR,
+				                                              uiFlags,
+				                                              &psDeviceImport->hReservation);
+
+				psDeviceImport->hMapping = LACK_OF_MAPPING_POISON;
 				PVR_GOTO_IF_ERROR(eError, failReserve);
 
-				psDeviceImport->hReservation = LACK_OF_RESERVATION_POISON;
 				psDeviceImport->bMapped = IMG_TRUE;
 			}
 			else
 			{
 				/* Setup page tables for the allocated VM space */
 				eError = BridgeDevmemIntReserveRange(GetBridgeHandle(psHeap->psCtx->hDevConnection),
-						psHeap->hDevMemServerHeap,
-						sBase,
-						uiAllocatedSize,
-						&psDeviceImport->hReservation);
+				                                     psHeap->hDevMemServerHeap,
+				                                     sBase,
+				                                     uiAllocatedSize,
+				                                     uiFlags,
+				                                     &psDeviceImport->hReservation);
 				PVR_GOTO_IF_ERROR(eError, failReserve);
 			}
 		}
@@ -1117,25 +1118,11 @@ IMG_BOOL DevmemImportStructDevUnmap(DEVMEM_IMPORT *psImport)
 
 		if (!psHeap->bPremapped)
 		{
-			if (psDeviceImport->bMapped)
-			{
-				PVR_ASSERT(psDeviceImport->hReservation == LACK_OF_RESERVATION_POISON);
-
-				eError = DestroyServerResource(psImport->hDevConnection,
-				                               NULL,
-				                               BridgeDevmemIntUnreserveRangeAndUnmapPMR,
-				                               psDeviceImport->hMapping);
-				PVR_ASSERT(eError == PVRSRV_OK);
-			}
-			else
-			{
-				eError = DestroyServerResource(psImport->hDevConnection,
-											NULL,
-											BridgeDevmemIntUnreserveRange,
-											psDeviceImport->hReservation);
-				PVR_ASSERT(eError == PVRSRV_OK);
-			}
-
+			eError = DestroyServerResource(psImport->hDevConnection,
+			                               NULL,
+			                               BridgeDevmemIntUnreserveRange,
+			                               psDeviceImport->hReservation);
+			PVR_ASSERT(eError == PVRSRV_OK);
 		}
 
 		psDeviceImport->bMapped = IMG_FALSE;
diff --git a/drivers/gpu/drm/img-rogue/di_impl_brg.c b/drivers/gpu/drm/img-rogue/di_impl_brg.c
index 5670af07f6d4..811e13b018e0 100644
--- a/drivers/gpu/drm/img-rogue/di_impl_brg.c
+++ b/drivers/gpu/drm/img-rogue/di_impl_brg.c
@@ -65,12 +65,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define STREAM_LINE_LENGTH 512
 
 #if defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
-#define WRITER_THREAD_SLEEP_TIMEOUT 0ull
+#define WRITER_THREAD_SLEEP_TIMEOUT 0ULL
 #else
-#define WRITER_THREAD_SLEEP_TIMEOUT 28800000000ull
+#define WRITER_THREAD_SLEEP_TIMEOUT 28800000000ULL
 #endif
-#define WRITER_THREAD_DESTROY_TIMEOUT 100000ull
-#define WRITER_THREAD_DESTROY_RETRIES 10u
+#define WRITER_THREAD_DESTROY_TIMEOUT 100000ULL
+#define WRITER_THREAD_DESTROY_RETRIES 10U
 
 #define WRITE_RETRY_COUNT 10      /* retry a write to a TL buffer 10 times */
 #define WRITE_RETRY_WAIT_TIME 100 /* wait 10ms between write retries */
@@ -85,7 +85,7 @@ typedef enum THREAD_STATE
 static struct DIIB_IMPL
 {
 	HASH_TABLE *psEntriesTable;    /*!< Table of entries. */
-	POS_LOCK psEntriesLock;        /*!< Protects psEntriesTable. */
+	POSWR_LOCK psEntriesLock;      /*!< Protects psEntriesTable. */
 	IMG_HANDLE hWriterThread;
 	IMG_HANDLE hWriterEventObject;
 	ATOMIC_T eThreadState;
@@ -318,6 +318,8 @@ static void _WriterThread(void *pvArg)
 	IMG_HANDLE hEvent;
 	DLLIST_NODE *psNode;
 
+	PVR_UNREFERENCED_PARAMETER(pvArg);
+
 	eError = OSEventObjectOpen(_g_psImpl->hWriterEventObject, &hEvent);
 	PVR_LOG_RETURN_VOID_IF_ERROR(eError, "OSEventObjectOpen");
 
@@ -425,10 +427,10 @@ DIIB_ENTRY *DIImplBrgFind(const IMG_CHAR *pszPath)
 {
 	DIIB_ENTRY *psEntry;
 
-	OSLockAcquire(_g_psImpl->psEntriesLock);
+	OSWRLockAcquireRead(_g_psImpl->psEntriesLock);
 	psEntry = (void *) HASH_Retrieve_Extended(_g_psImpl->psEntriesTable,
 	                                          (IMG_CHAR *) pszPath);
-	OSLockRelease(_g_psImpl->psEntriesLock);
+	OSWRLockReleaseRead(_g_psImpl->psEntriesLock);
 
 	return psEntry;
 }
@@ -455,7 +457,8 @@ static PVRSRV_ERROR _CreateStream(IMG_CHAR *pszStreamName, IMG_HANDLE *phStream)
 	}
 
 	eError = TLStreamCreate(&hStream, pszStreamName, STREAM_BUFFER_SIZE,
-	                        TL_OPMODE_DROP_NEWER, NULL, NULL, NULL, NULL);
+	                        TL_OPMODE_DROP_NEWER, NULL, NULL, NULL, NULL,
+	                        NULL, NULL);
 	PVR_RETURN_IF_ERROR(eError);
 
 	*phStream = hStream;
@@ -545,7 +548,11 @@ PVRSRV_ERROR DIReadEntryKM(DI_CONTEXT *psContext, const IMG_CHAR *pszEntryPath,
 
 	/* increment ref count on the context so that it doesn't get freed
 	 * before it gets processed by the writer thread. */
-	OSAtomicIncrement(&psContext->iRefCnt);
+	if (OSAtomicAddUnless(&psContext->iRefCnt, 1, IMG_INT32_MAX) == IMG_INT32_MAX)
+	{
+		/* Job is not scheduled to the writer queue; there are too many waiting. */
+		PVR_LOG_GOTO_WITH_ERROR("OSAtomicAddUnless", eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, overflow_);
+	}
 
 	OSLockAcquire(_g_psImpl->psWriterLock);
 	dllist_add_to_head(&_g_psImpl->sWriterQueue, &psItem->sQueueElement);
@@ -558,6 +565,7 @@ PVRSRV_ERROR DIReadEntryKM(DI_CONTEXT *psContext, const IMG_CHAR *pszEntryPath,
 
 free_item_:
 	eError = PVRSRV_ERROR_NOT_FOUND;
+overflow_:
 	OSFreeMemNoStats(psItem);
 return_:
 	return eError;
@@ -621,7 +629,9 @@ PVRSRV_ERROR DIListAllEntriesKM(DI_CONTEXT *psContext)
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psContext != NULL, "psContext");
 
+	OSWRLockAcquireRead(_g_psImpl->psEntriesLock);
 	eError = HASH_Iterate(_g_psImpl->psEntriesTable, _listName, psContext->hStream);
+	OSWRLockReleaseRead(_g_psImpl->psEntriesLock);
 	PVR_LOG_IF_ERROR(eError, "HASH_Iterate_Extended");
 
 	eError = TLStreamMarkEOS(psContext->hStream, IMG_FALSE);
@@ -642,7 +652,7 @@ static PVRSRV_ERROR _Init(void)
 	                                                 _Hash, _Compare);
 	PVR_LOG_GOTO_IF_NOMEM(_g_psImpl->psEntriesTable, eError, free_impl_);
 
-	eError = OSLockCreate(&_g_psImpl->psEntriesLock);
+	eError = OSWRLockCreate(&_g_psImpl->psEntriesLock);
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSCreateLock", free_table_);
 
 	eError = OSLockCreate(&_g_psImpl->psWriterLock);
@@ -662,7 +672,7 @@ static PVRSRV_ERROR _Init(void)
 free_writer_lock_:
 	OSLockDestroy(_g_psImpl->psWriterLock);
 free_entries_lock_:
-	OSLockDestroy(_g_psImpl->psEntriesLock);
+	OSWRLockDestroy(_g_psImpl->psEntriesLock);
 free_table_:
 	HASH_Delete_Extended(_g_psImpl->psEntriesTable, IMG_FALSE);
 free_impl_:
@@ -689,7 +699,7 @@ static void _DeInit(void)
 			PVR_LOG_IF_ERROR(eError, "OSEventObjectSignal");
 		}
 
-		LOOP_UNTIL_TIMEOUT(WRITER_THREAD_DESTROY_TIMEOUT)
+		LOOP_UNTIL_TIMEOUT_US(WRITER_THREAD_DESTROY_TIMEOUT)
 		{
 			eError = OSThreadDestroy(_g_psImpl->hWriterThread);
 			if (eError == PVRSRV_OK)
@@ -697,7 +707,7 @@ static void _DeInit(void)
 				break;
 			}
 			OSWaitus(WRITER_THREAD_DESTROY_TIMEOUT/WRITER_THREAD_DESTROY_RETRIES);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		PVR_LOG_IF_ERROR(eError, "OSThreadDestroy");
 	}
@@ -710,7 +720,7 @@ static void _DeInit(void)
 
 	HASH_Delete_Extended(_g_psImpl->psEntriesTable, IMG_FALSE);
 	OSLockDestroy(_g_psImpl->psWriterLock);
-	OSLockDestroy(_g_psImpl->psEntriesLock);
+	OSWRLockDestroy(_g_psImpl->psEntriesLock);
 	OSFreeMem(_g_psImpl);
 	_g_psImpl = NULL;
 }
@@ -721,27 +731,28 @@ static void _DeInit(void)
  * Returns current offset in the path (the current path length without the
  * NUL character). If there is no more space in the path returns -1
  * to indicate an error (the path is too long to fit into the buffer). */
-static IMG_INT _BuildGroupPath(IMG_CHAR *pszPath, const DIIB_GROUP *psGroup)
+static ssize_t _BuildGroupPath(IMG_CHAR *pszPath, const DIIB_GROUP *psGroup)
 {
-	IMG_INT iOff;
+	ssize_t iOff;
+	ssize_t iCopiedCnt;
+	size_t  uFreeCnt;
 
-	if (psGroup == NULL)
-	{
-		return 0;
-	}
+	PVR_RETURN_IF_FALSE(psGroup != NULL, 0);
 
 	PVR_ASSERT(pszPath != NULL);
 
 	iOff = _BuildGroupPath(pszPath, psGroup->psParentGroup);
 	PVR_RETURN_IF_FALSE(iOff != -1, -1);
 
-	iOff += OSStringLCopy(pszPath + iOff, "/",
-	                      DI_IMPL_BRG_PATH_LEN - iOff);
-	PVR_RETURN_IF_FALSE(iOff < DI_IMPL_BRG_PATH_LEN, -1);
+	uFreeCnt = DI_IMPL_BRG_PATH_LEN - iOff;
+	PVR_RETURN_IF_FALSE(uFreeCnt > 1, -1);
 
-	iOff += OSStringLCopy(pszPath + iOff, psGroup->pszName,
-	                      DI_IMPL_BRG_PATH_LEN - iOff);
-	PVR_RETURN_IF_FALSE(iOff < DI_IMPL_BRG_PATH_LEN, -1);
+	pszPath[iOff++] = '/';
+	--uFreeCnt;
+
+	iCopiedCnt = OSStringSafeCopy(&pszPath[iOff], psGroup->pszName, uFreeCnt);
+	PVR_RETURN_IF_FALSE(iCopiedCnt >= 0, -1);
+	iOff += iCopiedCnt;
 
 	return iOff;
 }
@@ -749,16 +760,20 @@ static IMG_INT _BuildGroupPath(IMG_CHAR *pszPath, const DIIB_GROUP *psGroup)
 static PVRSRV_ERROR _BuildEntryPath(IMG_CHAR *pszPath, const IMG_CHAR *pszName,
                                     const DIIB_GROUP *psGroup)
 {
-	IMG_INT iOff = _BuildGroupPath(pszPath, psGroup);
+	ssize_t iOff = _BuildGroupPath(pszPath, psGroup);
+	ssize_t iCopiedCnt;
+	size_t  uFreeCnt;
+
 	PVR_RETURN_IF_FALSE(iOff != -1, PVRSRV_ERROR_INVALID_OFFSET);
 
-	iOff += OSStringLCopy(pszPath + iOff, "/", DI_IMPL_BRG_PATH_LEN - iOff);
-	PVR_RETURN_IF_FALSE(iOff < DI_IMPL_BRG_PATH_LEN,
-	                    PVRSRV_ERROR_INVALID_OFFSET);
+	uFreeCnt = DI_IMPL_BRG_PATH_LEN - iOff;
+	PVR_RETURN_IF_FALSE(uFreeCnt > 1, PVRSRV_ERROR_OUT_OF_MEMORY);
 
-	iOff += OSStringLCopy(pszPath + iOff, pszName, DI_IMPL_BRG_PATH_LEN - iOff);
-	PVR_RETURN_IF_FALSE(iOff < DI_IMPL_BRG_PATH_LEN,
-	                    PVRSRV_ERROR_INVALID_OFFSET);
+	pszPath[iOff++] = '/';
+	--uFreeCnt;
+
+	iCopiedCnt = OSStringSafeCopy(&pszPath[iOff], pszName, uFreeCnt);
+	PVR_RETURN_IF_FALSE(iCopiedCnt >= 0, PVRSRV_ERROR_OUT_OF_MEMORY);
 
 	return PVRSRV_OK;
 }
@@ -813,12 +828,12 @@ static PVRSRV_ERROR _CreateEntry(const IMG_CHAR *pszName,
 		goto destroy_lock_;
 	}
 
-	OSLockAcquire(_g_psImpl->psEntriesLock);
+	OSWRLockAcquireWrite(_g_psImpl->psEntriesLock);
 	eError = HASH_Insert_Extended(_g_psImpl->psEntriesTable,
 	                              psEntry->pszFullPath,
 	                              (uintptr_t) psEntry) ?
 	         PVRSRV_OK : PVRSRV_ERROR_UNABLE_TO_ADD_HANDLE;
-	OSLockRelease(_g_psImpl->psEntriesLock);
+	OSWRLockReleaseWrite(_g_psImpl->psEntriesLock);
 	PVR_LOG_GOTO_IF_ERROR(eError, "HASH_Insert_Extended failed", destroy_lock_);
 
 	*pvEntry = psEntry;
@@ -838,9 +853,9 @@ static void _DestroyEntry(void *pvEntry)
 	DIIB_ENTRY *psEntry = pvEntry;
 	PVR_ASSERT(psEntry != NULL);
 
-	OSLockAcquire(_g_psImpl->psEntriesLock);
+	OSWRLockAcquireWrite(_g_psImpl->psEntriesLock);
 	HASH_Remove_Extended(_g_psImpl->psEntriesTable, psEntry->pszFullPath);
-	OSLockRelease(_g_psImpl->psEntriesLock);
+	OSWRLockReleaseWrite(_g_psImpl->psEntriesLock);
 
 	OSLockDestroy(psEntry->hLock);
 	OSFreeMem(psEntry);
@@ -887,3 +902,7 @@ PVRSRV_ERROR PVRDIImplBrgRegister(void)
 
 	return DIRegisterImplementation("impl_brg", &sImplCb);
 }
+
+/******************************************************************************
+ End of file (di_impl_brg.c)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/di_impl_brg.h b/drivers/gpu/drm/img-rogue/di_impl_brg.h
index 7d5a6ca757e8..b8cff25d94ec 100644
--- a/drivers/gpu/drm/img-rogue/di_impl_brg.h
+++ b/drivers/gpu/drm/img-rogue/di_impl_brg.h
@@ -44,6 +44,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PVR_IMPL_BRG_H
 
 #include "pvrsrv_error.h"
+#include "lock_types.h"
 
 typedef struct DI_CONTEXT_TAG DI_CONTEXT;
 typedef struct DI_ENTRY_DESC DI_ENTRY_DESC;
@@ -89,4 +90,5 @@ PVRSRV_ERROR DIWriteEntryKM(DI_CONTEXT *psContext, const IMG_CHAR *pszEntryPath,
 
 PVRSRV_ERROR DIListAllEntriesKM(DI_CONTEXT *psContext);
 
+
 #endif /* PVR_IMPL_BRG_H */
diff --git a/drivers/gpu/drm/img-rogue/di_server.c b/drivers/gpu/drm/img-rogue/di_server.c
index 330d35792819..47046d7ec3a2 100644
--- a/drivers/gpu/drm/img-rogue/di_server.c
+++ b/drivers/gpu/drm/img-rogue/di_server.c
@@ -135,7 +135,7 @@ PVRSRV_ERROR DIInit(void)
 
 	_g_psRootGroup->pszName = OSAllocMemNoStats(sizeof(ROOT_GROUP_NAME));
 	PVR_LOG_GOTO_IF_NOMEM(_g_psRootGroup->pszName, eError, cleanup_name_);
-	OSStringLCopy(_g_psRootGroup->pszName, ROOT_GROUP_NAME,
+	OSStringSafeCopy(_g_psRootGroup->pszName, ROOT_GROUP_NAME,
 				  sizeof(ROOT_GROUP_NAME));
 
 	dllist_init(&_g_psRootGroup->sListNode);
@@ -456,7 +456,7 @@ PVRSRV_ERROR DICreateGroup(const IMG_CHAR *pszName,
 	uSize = OSStringLength(pszName) + 1;
 	psGroup->pszName = OSAllocMem(uSize * sizeof(*psGroup->pszName));
 	PVR_LOG_GOTO_IF_NOMEM(psGroup->pszName, eError, cleanup_name_);
-	OSStringLCopy(psGroup->pszName, pszName, uSize);
+	OSStringSafeCopy(psGroup->pszName, pszName, uSize);
 
 	psGroup->psParent = psParent;
 	dllist_init(&psGroup->sGroupList);
diff --git a/drivers/gpu/drm/img-rogue/di_server.h b/drivers/gpu/drm/img-rogue/di_server.h
index a68894b1b430..a797890c069a 100644
--- a/drivers/gpu/drm/img-rogue/di_server.h
+++ b/drivers/gpu/drm/img-rogue/di_server.h
@@ -43,7 +43,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef DI_SERVER_H
 #define DI_SERVER_H
 
-#if defined(__linux__)
+#if defined(__KERNEL__) && defined(__linux__)
  #include <linux/version.h>
 
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
@@ -53,7 +53,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0) */
 #else
  #include <stdarg.h>
-#endif /* __linux__ */
+#endif /* __KERNEL__ && __linux__ */
 
 #include "di_common.h"
 #include "pvrsrv_error.h"
@@ -181,8 +181,8 @@ void DIWrite(const OSDI_IMPL_ENTRY *psEntry, const void *pvData,
  * @Input psEntry pointer to OSDI_IMPL_ENTRY object
  * @Input pszFmt NUL-terminated format string
  */
-void DIPrintf(const OSDI_IMPL_ENTRY *psEntry, const IMG_CHAR *pszFmt, ...)
-	__printf(2, 3);
+__printf(2, 3)
+void DIPrintf(const OSDI_IMPL_ENTRY *psEntry, const IMG_CHAR *pszFmt, ...);
 
 /*! @Function DIVPrintf
  *
@@ -194,6 +194,7 @@ void DIPrintf(const OSDI_IMPL_ENTRY *psEntry, const IMG_CHAR *pszFmt, ...)
  * @Input pszFmt NUL-terminated format string
  * @Input pArgs vs_list object
  */
+__printf(2, 0)
 void DIVPrintf(const OSDI_IMPL_ENTRY *psEntry, const IMG_CHAR *pszFmt,
                va_list pArgs);
 
diff --git a/drivers/gpu/drm/img-rogue/dkf_server.c b/drivers/gpu/drm/img-rogue/dkf_server.c
new file mode 100644
index 000000000000..6136b627d9ae
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/dkf_server.c
@@ -0,0 +1,409 @@
+/*************************************************************************/ /*!
+@File         dkf_server.c
+@Title        DRM Key Framework support routines.
+@Copyright    Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include "dkf_server.h"
+#include "img_types.h"
+#include "device.h"
+#include "pvrsrv_error.h"
+#include "dkp_impl.h"
+#include "osfunc.h"
+#include "pvr_debug.h"
+
+#if defined(SUPPORT_LINUX_FDINFO)
+typedef struct DKF_REGISTERED_DKP_TAG
+{
+	IMG_HANDLE              hPrivHandle;    /*!< Private data - can be NULL */
+	const IMG_CHAR          *pszDKPName;    /*!< DKP provider name */
+	IMG_PID                 pid;            /*!< Process-ID - can be 0 */
+	IMG_UINT32              uiReserved1;    /*!< Reserved field - padding */
+	DKP_PFN_SHOW            *psDKPShowPfn;  /*!< DKP Callback function */
+	DLLIST_NODE             sDKFEntryNode;  /*!< List of DKP entries */
+
+	DKP_CONNECTION_FLAGS    ui32Filter;     /*!< The types of connection to output to */
+} DKF_REGISTERED_DKP;
+
+/* Global sentinel to track all allocated DKP callback key/value pairs */
+typedef struct DKF_TAG
+{
+	POS_LOCK            hDKFListLock;   /*!< Lock for accessing sDKFListNode */
+	IMG_UINT32          ui32NumEntries; /*!< Number of registered DKP entries */
+	IMG_UINT32          uiReserved1;    /*!< Reserved field - padding */
+	DLLIST_NODE         sDKFListNode;   /*!< Head of the DKF_REGISTERED_DKP linked list */
+	DKF_VPRINTF_FUNC    *pfnPrint;  /*!< Default printf-style output fn */
+	void                *pvPrintArg1; /*!< First arg for pfnPrint */
+} DKF;
+
+static DKF *gpsDKF;
+
+static_assert(DKF_CONNECTION_FLAG_INVALID == DKP_CONNECTION_FLAG_INVALID, "DKF and DKP INVALID connection flags do not match");
+static_assert(DKF_CONNECTION_FLAG_SYNC == DKP_CONNECTION_FLAG_SYNC, "DKF and DKP SYNC connection flags do not match");
+static_assert(DKF_CONNECTION_FLAG_SERVICES == DKP_CONNECTION_FLAG_SERVICES, "DKF and DKP SERVICES connection flags do not match");
+
+PVRSRV_ERROR PVRDKFInit(void)
+{
+	DKF *psDKF;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+
+	if (gpsDKF != NULL)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s: gpsDKF = %p, NULL expected",
+		        __func__, gpsDKF));
+
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s called", __func__));
+
+	psDKF = OSAllocZMemNoStats(sizeof(*psDKF));
+	PVR_GOTO_IF_NOMEM(psDKF, eError, Error);
+
+	dllist_init(&psDKF->sDKFListNode);
+	eError = OSLockCreate(&psDKF->hDKFListLock);
+	PVR_GOTO_IF_ERROR(eError, ErrorFree);
+
+	gpsDKF = psDKF;
+
+	return PVRSRV_OK;
+
+ErrorFree:
+	OSFreeMemNoStats(psDKF);
+	/* fallthrough */
+
+Error:
+	PVR_DPF((PVR_DBG_ERROR, "%s: %s", __func__, PVRSRVGetErrorString(eError)));
+	return eError;
+}
+
+
+void PVRDKFDeInit(void)
+{
+	IMG_UINT32 uiNumFreed = 0U;
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s called", __func__));
+
+	if (gpsDKF == NULL)
+	{
+		return;
+	}
+
+	/* Ensure we leave no data allocated. The DKP instances should have
+	 * been cleaned up by their module deInit processing. Handle badly
+	 * behaved clients here.
+	 */
+	if (gpsDKF->ui32NumEntries > 0)
+	{
+		DLLIST_NODE *psThis, *psNext;
+
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Have %u un-freed allocations remaining", __func__,
+		         gpsDKF->ui32NumEntries));
+
+		OSLockAcquire(gpsDKF->hDKFListLock);
+
+		dllist_foreach_node(&gpsDKF->sDKFListNode, psThis, psNext)
+		{
+			DKF_REGISTERED_DKP *psEntry = IMG_CONTAINER_OF(psThis,
+			                                             DKF_REGISTERED_DKP,
+			                                             sDKFEntryNode);
+
+			dllist_remove_node(&psEntry->sDKFEntryNode);
+
+			uiNumFreed++;
+
+			OSFreeMemNoStats(psEntry);
+		}
+
+		if (uiNumFreed != gpsDKF->ui32NumEntries)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Could only free %u out of %u",
+			         uiNumFreed, gpsDKF->ui32NumEntries));
+		}
+
+		dllist_remove_node(&gpsDKF->sDKFListNode);
+
+		OSLockRelease(gpsDKF->hDKFListLock);
+	}
+
+	OSLockDestroy(gpsDKF->hDKFListLock);
+
+	OSFreeMemNoStats(gpsDKF);
+
+	gpsDKF = NULL;
+}
+
+void PVRDKFTraverse(DKF_VPRINTF_FUNC *pfnPrint,
+                    void *pvArg,
+                    struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+                    IMG_PID pid,
+                    DKF_CONNECTION_FLAGS ui32ConnectionType)
+{
+	PDLLIST_NODE pNext, pNode;
+
+	PVR_ASSERT(gpsDKF != NULL);
+	PVR_ASSERT(pfnPrint != NULL);
+	PVR_ASSERT(ui32ConnectionType != DKF_CONNECTION_FLAG_INVALID);
+
+	OSLockAcquire(gpsDKF->hDKFListLock);
+
+	gpsDKF->pfnPrint = pfnPrint;
+	gpsDKF->pvPrintArg1 = pvArg;
+
+	if (dllist_is_empty(&gpsDKF->sDKFListNode))
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s: No DKPs registered", __func__));
+	}
+	else
+	{
+		dllist_foreach_node(&gpsDKF->sDKFListNode, pNode, pNext)
+		{
+			DKF_REGISTERED_DKP *psEntry = IMG_CONTAINER_OF(pNode,
+			                                               DKF_REGISTERED_DKP,
+			                                               sDKFEntryNode);
+
+			if (psEntry->psDKPShowPfn != NULL &&
+			    BITMASK_ANY(psEntry->ui32Filter, ui32ConnectionType))
+			{
+				psEntry->psDKPShowPfn(psDevNode, pid,
+				                      psEntry->hPrivHandle);
+			}
+		}
+	}
+
+	OSLockRelease(gpsDKF->hDKFListLock);
+}
+
+/*
+ * Wrapper function to display data using preconfigured DKF-specific output
+ * function.
+ */
+void PVRDKPOutput(IMG_HANDLE hPrivData, const char *fmt, ...)
+{
+	DKF_REGISTERED_DKP *psDKFEntry = (DKF_REGISTERED_DKP *)hPrivData;
+	IMG_CHAR szBuffer[PVR_MAX_DEBUG_MESSAGE_LEN];
+	va_list Arglist;
+	DLLIST_NODE *pNode, *pNext;
+	IMG_BOOL bFound = IMG_FALSE;
+
+	if (psDKFEntry == NULL || gpsDKF == NULL)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s: NULL DKF entry found (%p, %p)",
+		        __func__, psDKFEntry, gpsDKF));
+		return;
+	}
+
+	PVR_ASSERT(gpsDKF->pfnPrint != NULL);
+
+	/* validate that this is a legitimate output function reference */
+
+	dllist_foreach_node(&gpsDKF->sDKFListNode, pNode, pNext)
+	{
+		DKF_REGISTERED_DKP *psEntry = IMG_CONTAINER_OF(pNode,
+		                                               DKF_REGISTERED_DKP,
+		                                               sDKFEntryNode);
+
+		if (psEntry == psDKFEntry)
+		{
+			bFound = IMG_TRUE;
+			break;
+		}
+	}
+
+	if (!bFound)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s: Handle %p not found.", __func__,
+		         hPrivData));
+		return;
+	}
+
+	OSSNPrintf(szBuffer, PVR_MAX_DEBUG_MESSAGE_LEN, "%s", fmt);
+
+	va_start(Arglist, fmt);
+	gpsDKF->pfnPrint(gpsDKF->pvPrintArg1, szBuffer, &Arglist);
+	va_end(Arglist);
+}
+
+PVRSRV_ERROR PVRSRVRegisterDKP(IMG_HANDLE hPrivData,
+                               const char *pszDKPName,
+                               DKP_PFN_SHOW *psShowPfn,
+                               DKP_CONNECTION_FLAGS ui32Filter,
+                               PPVRDKF_DKP_HANDLE phDkpHandle)
+{
+	DKF_REGISTERED_DKP *psDKFEntry; /* New entry for this DKP */
+	PVRSRV_ERROR eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+
+	/* Check for a NULL argument. Nothing to allocate if we are not provided
+	 * a location to store the DkpHandle reference.
+	 */
+	if (phDkpHandle == NULL || ui32Filter == DKF_CONNECTION_FLAG_INVALID)
+	{
+
+#if defined(DEBUG)
+		PVR_DPF((PVR_DBG_WARNING, "%s(%p, %s, %p, %p) Called", __func__,
+		         hPrivData, pszDKPName, psShowPfn,
+		         phDkpHandle));
+#endif
+
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDKFEntry = OSAllocZMemNoStats(sizeof(*psDKFEntry));
+	PVR_GOTO_IF_NOMEM(psDKFEntry, eError, Error);
+
+	OSLockAcquire(gpsDKF->hDKFListLock);
+
+	psDKFEntry->hPrivHandle = hPrivData;
+	psDKFEntry->pszDKPName = pszDKPName;
+	psDKFEntry->psDKPShowPfn = psShowPfn;
+	psDKFEntry->ui32Filter = ui32Filter;
+	dllist_init(&psDKFEntry->sDKFEntryNode);
+
+	/*
+	 * Append the new entry to the end of the gpsDKF list-head. Return a
+	 * reference to the new entry to the caller.
+	 */
+	dllist_add_to_tail(&gpsDKF->sDKFListNode, &psDKFEntry->sDKFEntryNode);
+
+	gpsDKF->ui32NumEntries++;
+
+	OSLockRelease(gpsDKF->hDKFListLock);
+
+	*phDkpHandle = psDKFEntry;
+
+	return PVRSRV_OK;
+
+
+Error:
+	PVR_DPF((PVR_DBG_ERROR, "%s: Error: '%s'", __func__,
+	         PVRSRVGetErrorString(eError)));
+
+	return eError;
+}
+
+PVRSRV_ERROR PVRSRVUnRegisterDKP(IMG_HANDLE hPrivData, PVRDKF_DKP_HANDLE hDkpHandle)
+{
+	DKF_REGISTERED_DKP *psDKFEntry = (DKF_REGISTERED_DKP *)hDkpHandle;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (psDKFEntry)
+	{
+#if defined(DEBUG)
+		if (psDKFEntry->hPrivHandle == hPrivData)
+		{
+			PVR_DPF((PVR_DBG_VERBOSE, "%s: Matched %p private handle",
+			         __func__, hDkpHandle));
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_VERBOSE,
+			         "%s: Did not find match (%p. vs %p), freeing anyway",
+			         __func__, hPrivData, psDKFEntry->hPrivHandle));
+		}
+#endif	/* DEBUG */
+
+		OSLockAcquire(gpsDKF->hDKFListLock);
+
+		dllist_remove_node(&psDKFEntry->sDKFEntryNode);
+
+		gpsDKF->ui32NumEntries--;
+
+		OSLockRelease(gpsDKF->hDKFListLock);
+
+		OSFreeMemNoStats(psDKFEntry);
+
+	}
+	else
+	{
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	return eError;
+}
+#else
+
+/* Stub routines for earlier kernel versions */
+
+PVRSRV_ERROR PVRDKFInit(void)
+{
+	return PVRSRV_OK;
+}
+
+void PVRDKFDeInit(void)
+{
+}
+
+void PVRDKFTraverse(DKF_VPRINTF_FUNC *pfnPrint,
+                    void *pvArg,
+                    struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+                    IMG_PID pid,
+                    IMG_UINT32 ui32ConnectionType)
+{
+	PVR_UNREFERENCED_PARAMETER(psDevNode);
+	PVR_UNREFERENCED_PARAMETER(pid);
+}
+
+void PVRDKPOutput(IMG_HANDLE hPrivData, const char *fmt, ...)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(fmt);
+}
+
+PVRSRV_ERROR PVRSRVRegisterDKP(IMG_HANDLE hPrivData, const char *pszDKPName,
+                               DKP_PFN_SHOW *psShowPfn,
+                               DKP_CONNECTION_FLAGS ui32Filter,
+                               PPVRDKF_DKP_HANDLE phDkpHandle)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(pszDKPName);
+	PVR_UNREFERENCED_PARAMETER(psShowPfn);
+	PVR_UNREFERENCED_PARAMETER(phDkpHandle);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PVRSRVUnRegisterDKP(IMG_HANDLE hPrivData, PVRDKF_DKP_HANDLE hDkpHandle)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(hDkpHandle);
+
+	return PVRSRV_OK;
+}
+#endif	/* SUPPORT_LINUX_FDINFO */
diff --git a/drivers/gpu/drm/img-rogue/dkf_server.h b/drivers/gpu/drm/img-rogue/dkf_server.h
new file mode 100644
index 000000000000..304d9bc71b60
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/dkf_server.h
@@ -0,0 +1,103 @@
+/**************************************************************************/ /*!
+@File           dkf_server.h
+@Title          Functions for supporting the DRM Key Framework
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /***************************************************************************/
+
+#if !defined(DKF_SERVER_H)
+#define DKF_SERVER_H
+
+#include "img_types.h"
+#include "pvrsrv_error.h"
+
+#if defined(SUPPORT_LINUX_FDINFO)
+
+#include <drm/drm_print.h>
+typedef void (DKF_VPRINTF_FUNC)(struct drm_printer *p, const char *fmt, va_list *va) __printf(2, 0);
+
+#else /* !defined(SUPPORT_LINUX_FDINFO) */
+typedef void (DKF_VPRINTF_FUNC)(void *p, const char *fmt, ...) __printf(2, 3);
+
+#endif	/* defined(SUPPORT_LINUX_FDINFO) */
+struct _PVRSRV_DEVICE_NODE_;
+
+typedef IMG_UINT32 DKF_CONNECTION_FLAGS;
+
+#define DKF_CONNECTION_FLAG_SYNC        BIT(0)
+#define DKF_CONNECTION_FLAG_SERVICES    BIT(1)
+
+#define DKF_CONNECTION_FLAG_INVALID     IMG_UINT32_C(0)
+
+/*! @Function PVRDKFTraverse
+ *
+ * @Description
+ * Outputs the DKP data associated with the given device node's
+ * framework entries.
+ *
+ * @Input   pfnPrint            The print function callback to be used to output.
+ * @Input   pvArg               Print function first argument.
+ * @Input   psDevNode           Device node associated with fdinfo owner.
+ * @Input   pid                 Process ID of the process owning the FD the fdinfo
+ *                              file relates to.
+ * @Input   ui32ConnectionType  A value indicating the PVR connection type
+ *                              (sync or services).
+ */
+void PVRDKFTraverse(DKF_VPRINTF_FUNC *pfnPrint,
+                    void *pvArg,
+                    struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+                    IMG_PID pid,
+                    DKF_CONNECTION_FLAGS ui32ConnectionType);
+
+/* @Function PVRDKFInit
+ *
+ * @Description
+ * Initialises the DKF infrastructure for subsequent usage by the PVR system.
+ *
+ * @Returns  PVRSRV_ERROR.
+ */
+PVRSRV_ERROR PVRDKFInit(void);
+
+/* @Function PVRDKFDeInit
+ *
+ * @Description
+ * Removes and frees all associated system-specific DKF meta-data.
+ */
+void PVRDKFDeInit(void);
+
+#endif
diff --git a/drivers/gpu/drm/img-rogue/dkp_impl.h b/drivers/gpu/drm/img-rogue/dkp_impl.h
new file mode 100644
index 000000000000..b5f47f8910a2
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/dkp_impl.h
@@ -0,0 +1,163 @@
+/**************************************************************************/ /*!
+@File           dkp_impl.h
+@Title          Functions for supporting the DRM Key Provider
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /***************************************************************************/
+
+#ifndef DKP_IMPL_H
+#define DKP_IMPL_H
+
+typedef IMG_HANDLE PVRDKF_DKP_HANDLE;
+typedef PVRDKF_DKP_HANDLE * PPVRDKF_DKP_HANDLE;
+
+/*! @Function DKP_PFN_SHOW
+ *
+ * @Description
+ *
+ * Describes the function called by the DKF infrastructure to request the DKP
+ * outputs all the mandatory and optional keys it supports. Each
+ * key / value pair should be output one per line using the provided
+ * PVRDPFOutput routine.
+ *
+ * The function should check that the passed 'psDevNode' references the
+ * same device as that associated with the module-specific 'hPrivData' handle.
+ * If it doesn't, no data should be displayed.
+ *
+ * @Input psDevNode   Pointer to device node for which data must be shown.
+ * @Input pid         Process-ID for which data must be shown.
+ * @Input hPrivData   Private data passed to DKF from DKP_Register. The DKP
+ *                     must use this within calls to the DKP_PFN_SHOW to limit
+ *                     the data key/value pairs to only those that are relevant
+ *                     to this instance.
+ */
+typedef void (DKP_PFN_SHOW)(struct _PVRSRV_DEVICE_NODE_ *psDevNode, int pid,
+                            IMG_HANDLE hPrivData);
+
+typedef IMG_UINT32 DKP_CONNECTION_FLAGS;
+
+#define DKP_CONNECTION_FLAG_SYNC        BIT(0)
+#define DKP_CONNECTION_FLAG_SERVICES    BIT(1)
+
+#define DKP_CONNECTION_FLAG_INVALID     IMG_UINT32_C(0)
+#define DKP_CONNECTION_FLAG_ALL (DKP_CONNECTION_FLAG_SYNC | DKP_CONNECTION_FLAG_SERVICES)
+
+/* @Function PVRSRVRegisterDKP
+ *
+ * @Description
+ * Registers a DKP with the specified module's DKF entry.
+ *
+ * @Input   hPrivData               DKP Private data handle that the DKF will pass into
+ *                                  the ShowPFN when called. Can be NULL if there is no
+ *                                  DKP instance private data.
+ * @Input   pszDKPName              Provider name associated with the caller.
+ * @Input   psShowPfn               Function to be used when the fdinfo statistics
+ *                                  are queried.
+ * @Input   ui32Filter              The connection types this DKP should be output
+ *                                  on.
+ * @Output  phDkpHandle             Location to store generated handle created by this
+ *                                  function.
+ *
+ * @Returns  PVRSRV_ERROR
+ */
+PVRSRV_ERROR PVRSRVRegisterDKP(IMG_HANDLE hPrivData,
+                               const char *pszDKPName,
+                               DKP_PFN_SHOW *psShowPfn,
+                               DKP_CONNECTION_FLAGS ui32Filter,
+                               PPVRDKF_DKP_HANDLE phDkpHandle);
+
+/* @Function PVRSRVUnRegisterDKP
+ *
+ * @Description
+ * Removes a previously registered key from the device's DKF entry.
+ *
+ * @Input  hPrivData      Private data handle.
+ * @Input  hDkpHandle     Handle to the DKP's registered entry.
+ *                         Obtained from earlier PVRSRV_DKP_Register call.
+ *
+ * @Returns  PVRSRV_ERROR
+ */
+PVRSRV_ERROR PVRSRVUnRegisterDKP(IMG_HANDLE hPrivData,
+                                 PVRDKF_DKP_HANDLE hDkpHandle);
+
+
+/* @Function PVRDKPOutput
+ * Wrapper function which passes the printf-style arguments to the registered
+ * DKF output function associated with the registered DKP handle.
+ *
+ * @Input   hPrivData   Handle for associated DKP instance producing the output.
+ * @Input   fmt         printf-style format string
+ *
+ */
+void PVRDKPOutput(IMG_HANDLE hPrivData, const char *fmt, ...) __printf(2, 3);
+
+
+#if !defined(__linux__) || defined(INTEGRITY_OS) || defined(__QNXNTO__)
+
+/* Stub routines follow */
+static inline PVRSRV_ERROR PVRSRVRegisterDKP(IMG_HANDLE hPrivData,
+                                             const char *pszDKPName,
+                                             DKP_PFN_SHOW *psShowPfn,
+                                             DKP_CONNECTION_FLAGS ui32Filter,
+                                             PPVRDKF_DKP_HANDLE phDkpHandle)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(pszDKPName);
+	PVR_UNREFERENCED_PARAMETER(psShowPfn);
+	PVR_UNREFERENCED_PARAMETER(phDkpHandle);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static inline PVRSRV_ERROR PVRSRVUnRegisterDKP(IMG_HANDLE hPrivData,
+                                               PVRDKF_DKP_HANDLE hDkpHandle)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(hDkpHandle);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+static inline void PVRDKPOutput(IMG_HANDLE hPrivData, const char *fmt, ...) __printf(2, 3)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+	PVR_UNREFERENCED_PARAMETER(fmt);
+}
+#endif /* !__linux__ || INTEGRITY_OS || __QNXNTO__ */
+
+#endif /* DKP_IMPL_H */
diff --git a/drivers/gpu/drm/img-rogue/dma_km.h b/drivers/gpu/drm/img-rogue/dma_km.h
index ce4d1317279b..9bf633dfd98f 100644
--- a/drivers/gpu/drm/img-rogue/dma_km.h
+++ b/drivers/gpu/drm/img-rogue/dma_km.h
@@ -77,7 +77,9 @@ PVRSRV_ERROR DmaTransfer(CONNECTION_DATA *psConnection,
 			IMG_UINT32 uiFlags,
 			PVRSRV_TIMELINE iUpdateTimeline);
 
-PVRSRV_ERROR PVRSRVInitialiseDMA(PVRSRV_DEVICE_NODE *psDeviceNode);
-void PVRSRVDeInitialiseDMA(PVRSRV_DEVICE_NODE *psDeviceNode);
+PVRSRV_ERROR PVRSRVInitialiseDMA(PVRSRV_DEVICE_NODE *psDeviceNode,
+								 CONNECTION_DATA *psConnectionData);
+void PVRSRVDeInitialiseDMA(PVRSRV_DEVICE_NODE *psDeviceNode,
+						   CONNECTION_DATA *psConnectionData);
 
 #endif /* DMA_KM_H */
diff --git a/drivers/gpu/drm/img-rogue/dma_support.c b/drivers/gpu/drm/img-rogue/dma_support.c
index 2058584ddf7c..c561d0622d5f 100644
--- a/drivers/gpu/drm/img-rogue/dma_support.c
+++ b/drivers/gpu/drm/img-rogue/dma_support.c
@@ -380,7 +380,7 @@ PVRSRV_ERROR SysDmaRegisterForIoRemapping(DMA_ALLOC *psDmaAlloc)
  ******************************************************************************/
 void SysDmaDeregisterForIoRemapping(DMA_ALLOC *psDmaAlloc)
 {
-	size_t uiSize;
+	__maybe_unused size_t uiSize;
 	IMG_UINT32 ui32Idx;
 
 	if (psDmaAlloc == NULL ||
diff --git a/drivers/gpu/drm/img-rogue/env_connection.h b/drivers/gpu/drm/img-rogue/env_connection.h
index 2a6c7d05c412..d2e4f9743370 100644
--- a/drivers/gpu/drm/img-rogue/env_connection.h
+++ b/drivers/gpu/drm/img-rogue/env_connection.h
@@ -58,9 +58,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "allocmem.h"
 #endif
 
+struct drm_file;
+
 typedef struct _ENV_CONNECTION_PRIVATE_DATA_
 {
 	PVRSRV_DEVICE_NODE *psDevNode;
+	struct drm_file *psDRMFile;
 } ENV_CONNECTION_PRIVATE_DATA;
 
 #if defined(SUPPORT_ION) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0))
@@ -79,6 +82,7 @@ typedef struct _ENV_CONNECTION_DATA_
 	pid_t owner;
 
 	PVRSRV_DEVICE_NODE *psDevNode;
+	struct drm_file *psDRMFile;
 
 #if defined(SUPPORT_NATIVE_FENCE_SYNC)
 	void *pvPvrSyncPrivateData;
diff --git a/drivers/gpu/drm/img-rogue/event.c b/drivers/gpu/drm/img-rogue/event.c
index e9847ff68b88..98b029c926df 100644
--- a/drivers/gpu/drm/img-rogue/event.c
+++ b/drivers/gpu/drm/img-rogue/event.c
@@ -372,9 +372,11 @@ PVRSRV_ERROR LinuxEventObjectWait(IMG_HANDLE hOSEventObject,
 
 	DEFINE_WAIT(sWait);
 
-	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = (PVRSRV_LINUX_EVENT_OBJECT *) hOSEventObject;
+	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = (PVRSRV_LINUX_EVENT_OBJECT*)hOSEventObject;
 	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList = psLinuxEventObject->psLinuxEventObjectList;
 
+	PVR_ASSERT(psLinuxEventObjectList != NULL);
+
 	/* Check if the driver is good shape */
 	if (psPVRSRVData->eServicesState != PVRSRV_SERVICES_STATE_OK)
 	{
diff --git a/drivers/gpu/drm/img-rogue/fwload.c b/drivers/gpu/drm/img-rogue/fwload.c
index 35e52af56a2e..8c597b3c2e28 100644
--- a/drivers/gpu/drm/img-rogue/fwload.c
+++ b/drivers/gpu/drm/img-rogue/fwload.c
@@ -179,19 +179,23 @@ OSLoadFirmware(PVRSRV_DEVICE_NODE *psDeviceNode, const IMG_CHAR *pszBVNCString,
 	IMG_INT32    res;
 	PVRSRV_ERROR eError;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0))
+	res = firmware_request_nowarn(&psFW, pszBVNCString, psDeviceNode->psDevConfig->pvOSDevice);
+#else
 	res = request_firmware(&psFW, pszBVNCString, psDeviceNode->psDevConfig->pvOSDevice);
+#endif
 	if (res != 0)
 	{
 		release_firmware(psFW);
 		if (res == -ENOENT)
 		{
-			PVR_DPF((PVR_DBG_WARNING, "%s: request_firmware('%s') not found (%d)",
+			PVR_DPF((PVR_DBG_WARNING, "%s: requested firmware('%s') not found (%d)",
 							__func__, pszBVNCString, res));
 			eError = PVRSRV_ERROR_NOT_FOUND;
 		}
 		else
 		{
-			PVR_DPF((PVR_DBG_WARNING, "%s: request_firmware('%s') not ready (%d)",
+			PVR_DPF((PVR_DBG_WARNING, "%s: requested firmware('%s') not ready (%d)",
 							__func__, pszBVNCString, res));
 			eError = PVRSRV_ERROR_NOT_READY;
 		}
diff --git a/drivers/gpu/drm/img-rogue/handle.c b/drivers/gpu/drm/img-rogue/handle.c
index 286cec731fe7..421e8256c86e 100644
--- a/drivers/gpu/drm/img-rogue/handle.c
+++ b/drivers/gpu/drm/img-rogue/handle.c
@@ -1764,6 +1764,7 @@ PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE **ppsBase,
 	return PVRSRV_OK;
 
 ErrorDestroyHandleBase:
+    eError = PVRSRV_ERROR_INVALID_PARAMS;
 	(void)gpsHandleFuncs->pfnDestroyHandleBase(psBase->psImplBase);
 
 ErrorUnlock:
@@ -2046,9 +2047,6 @@ static const PVRSRV_HANDLE_TYPE g_aeOrderedFreeList[] =
 	PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT,
 	PVRSRV_HANDLE_TYPE_RGX_SERVER_RAY_CONTEXT,
 	PVRSRV_HANDLE_TYPE_RGX_SERVER_KICKSYNC_CONTEXT,
-#if defined(PVR_TESTING_UTILS) && defined(SUPPORT_VALIDATION)
-	PVRSRV_HANDLE_TYPE_RGX_SERVER_GPUMAP_CONTEXT,
-#endif
 	PVRSRV_HANDLE_TYPE_RI_HANDLE,
 	PVRSRV_HANDLE_TYPE_SYNC_RECORD_HANDLE,
 	PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
@@ -2206,6 +2204,7 @@ PVRSRV_ERROR PVRSRVAcquireProcessHandleBase(IMG_PID uiPid, PROCESS_HANDLE_BASE *
 	return PVRSRV_OK;
 
 ErrorFreeHandleBase:
+    eError = PVRSRV_ERROR_INVALID_PARAMS;
 	PVRSRVFreeHandleBase(psBase->psHandleBase, 0);
 ErrorFreeProcessHandleBase:
 	OSFreeMem(psBase);
@@ -2496,3 +2495,7 @@ PVRSRV_ERROR PVRSRVHandleDeInit(void)
 
 	return eError;
 }
+
+/******************************************************************************
+ End of file (handle.c)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/handle.h b/drivers/gpu/drm/img-rogue/handle.h
index 92946b6fbb36..27fc7d4fc658 100644
--- a/drivers/gpu/drm/img-rogue/handle.h
+++ b/drivers/gpu/drm/img-rogue/handle.h
@@ -203,4 +203,5 @@ PVRSRV_ERROR PVRSRVReleaseProcessHandleBase(PROCESS_HANDLE_BASE *psBase, IMG_PID
 void LockHandle(PVRSRV_HANDLE_BASE *psBase);
 void UnlockHandle(PVRSRV_HANDLE_BASE *psBase);
 
+
 #endif /* !defined(HANDLE_API_H) */
diff --git a/drivers/gpu/drm/img-rogue/handle_idr.c b/drivers/gpu/drm/img-rogue/handle_idr.c
index c40e096bfaa5..cb448213d6fa 100644
--- a/drivers/gpu/drm/img-rogue/handle_idr.c
+++ b/drivers/gpu/drm/img-rogue/handle_idr.c
@@ -41,7 +41,6 @@ IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ /***************************************************************************/
 
-#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/err.h>
 #include <linux/gfp.h>
@@ -110,29 +109,11 @@ static PVRSRV_ERROR AcquireHandle(HANDLE_IMPL_BASE *psBase,
 	PVR_ASSERT(phHandle != NULL);
 	PVR_ASSERT(pvData != NULL);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
 	idr_preload(GFP_KERNEL);
 	id = idr_alloc(&psBase->sIdr, pvData, ID_VALUE_MIN, psBase->ui32MaxHandleValue + 1, 0);
 	idr_preload_end();
 
 	result = id;
-#else
-	do
-	{
-		if (idr_pre_get(&psBase->sIdr, GFP_KERNEL) == 0)
-		{
-			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
-
-		result = idr_get_new_above(&psBase->sIdr, pvData, ID_VALUE_MIN, &id);
-	} while (result == -EAGAIN);
-
-	if ((IMG_UINT32)id > psBase->ui32MaxHandleValue)
-	{
-		idr_remove(&psBase->sIdr, id);
-		result = -ENOSPC;
-	}
-#endif
 
 	if (result < 0)
 	{
@@ -390,10 +371,6 @@ static PVRSRV_ERROR DestroyHandleBase(HANDLE_IMPL_BASE *psBase)
 {
 	PVR_ASSERT(psBase);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
-	idr_remove_all(&psBase->sIdr);
-#endif
-
 	/* Finally destroy the idr */
 	idr_destroy(&psBase->sIdr);
 
diff --git a/drivers/gpu/drm/img-rogue/handle_types.h b/drivers/gpu/drm/img-rogue/handle_types.h
index 5ccbc607d5df..75ac5c5fa6a0 100644
--- a/drivers/gpu/drm/img-rogue/handle_types.h
+++ b/drivers/gpu/drm/img-rogue/handle_types.h
@@ -64,9 +64,6 @@ HANDLETYPE(RGX_SERVER_TQ_TDM_CONTEXT)
 HANDLETYPE(RGX_SERVER_COMPUTE_CONTEXT)
 HANDLETYPE(RGX_SERVER_RAY_CONTEXT)
 HANDLETYPE(RGX_SERVER_KICKSYNC_CONTEXT)
-#if defined(PVR_TESTING_UTILS) && defined(SUPPORT_VALIDATION)
-HANDLETYPE(RGX_SERVER_GPUMAP_CONTEXT)
-#endif
 HANDLETYPE(SYNC_PRIMITIVE_BLOCK)
 HANDLETYPE(SYNC_RECORD_HANDLE)
 HANDLETYPE(PVRSRV_TIMELINE_SERVER)
diff --git a/drivers/gpu/drm/img-rogue/hash.c b/drivers/gpu/drm/img-rogue/hash.c
index 994ae5871f5f..434c6e967bc4 100644
--- a/drivers/gpu/drm/img-rogue/hash.c
+++ b/drivers/gpu/drm/img-rogue/hash.c
@@ -696,6 +696,19 @@ HASH_Iterate(HASH_TABLE *pHash, HASH_pfnCallback pfnCallback, void* args)
 	return PVRSRV_OK;
 }
 
+/*************************************************************************/ /*!
+@Function       HASH_Count
+@Description    Retrieve the number of entries in the hash table.
+@Input          pHash        The hash table.
+@Return         The number of entries.
+*/ /**************************************************************************/
+IMG_INTERNAL IMG_UINT32
+HASH_Count(HASH_TABLE *pHash)
+{
+	return pHash->uCount;
+}
+
+
 #ifdef HASH_TRACE
 /*************************************************************************/ /*!
 @Function       HASH_Dump
diff --git a/drivers/gpu/drm/img-rogue/hash.h b/drivers/gpu/drm/img-rogue/hash.h
index 92d48990af82..feb879c1489a 100644
--- a/drivers/gpu/drm/img-rogue/hash.h
+++ b/drivers/gpu/drm/img-rogue/hash.h
@@ -227,6 +227,14 @@ uintptr_t HASH_Retrieve(HASH_TABLE *pHash, uintptr_t k);
 */ /**************************************************************************/
 PVRSRV_ERROR HASH_Iterate(HASH_TABLE *pHash, HASH_pfnCallback pfnCallback, void* args);
 
+/*************************************************************************/ /*!
+@Function       HASH_Count
+@Description    Retrieve the number of entries in the hash table.
+@Input          pHash        The hash table.
+@Return         The number of entries.
+*/ /**************************************************************************/
+IMG_UINT32 HASH_Count(HASH_TABLE *pHash);
+
 #ifdef HASH_TRACE
 /*************************************************************************/ /*!
 @Function       HASH_Dump
diff --git a/drivers/gpu/drm/img-rogue/htb_debug.c b/drivers/gpu/drm/img-rogue/htb_debug.c
index 6f0ede57af13..6290fbd30b31 100644
--- a/drivers/gpu/drm/img-rogue/htb_debug.c
+++ b/drivers/gpu/drm/img-rogue/htb_debug.c
@@ -647,10 +647,11 @@ typedef struct _HTB_TRACEBUF_LOG_ {
 	IMG_CHAR      *pszName;
 	IMG_CHAR      *pszFmt;
 	IMG_UINT32    ui32ArgNum;
+	IMG_UINT32    ui32StrArgIdx; /* This is 1 indexed, if 0, there is not a string arg. */
 } HTB_TRACEBUF_LOG;
 
 static const HTB_TRACEBUF_LOG aLogs[] = {
-#define X(a, b, c, d, e) {HTB_LOG_CREATESFID(a,b,e), #c, d, e},
+#define X(a, b, c, d, e, f) {HTB_LOG_CREATESFID(a,b,e,f), #c, d, e, f},
 	HTB_LOG_SFIDLIST
 #undef X
 };
@@ -957,13 +958,21 @@ DecodeHTB(HTB_Sentinel_t *pSentinel, OSDI_IMPL_ENTRY *pvDumpDebugFile,
 		{
 			if (pszFmt)
 			{
-				nPrinted = OSStringLCopy(pszBuffer, pszFmt, uBufBytesAvailable);
-				if (nPrinted >= uBufBytesAvailable)
+				const ssize_t iCopiedCnt =
+					OSStringSafeCopy(pszBuffer, pszFmt, uBufBytesAvailable);
+				if (iCopiedCnt < 0)
 				{
-					PVR_DUMPDEBUG_LOG("Buffer overrun - "IMG_SIZE_FMTSPEC" printed,"
-						" max space "IMG_SIZE_FMTSPEC"\n", nPrinted,
-						uBufBytesAvailable);
-					nPrinted = uBufBytesAvailable;	/* Ensure we don't overflow buffer */
+					PVR_DUMPDEBUG_LOG("Buffer overrun - %zu required,"
+					                  " max space %zu\n",
+					                   OSStringLength(pszFmt),
+					                   uBufBytesAvailable);
+
+					/* Ensure we don't overflow buffer */
+					nPrinted = uBufBytesAvailable;
+				}
+				else
+				{
+					nPrinted = iCopiedCnt;
 				}
 				PVR_DUMPDEBUG_LOG("%s", pszBuffer);
 				pszBuffer += nPrinted;
@@ -1038,8 +1047,20 @@ DecodeHTB(HTB_Sentinel_t *pSentinel, OSDI_IMPL_ENTRY *pvDumpDebugFile,
 							break;
 
 						case TRACEBUF_ARG_TYPE_NONE:
-							nPrinted = OSStringLCopy(pszBuffer, pszFmt,
-								uBufBytesAvailable);
+							{
+								const ssize_t iCopiedCnt =
+									OSStringSafeCopy(pszBuffer,
+									                 pszFmt,
+									                 uBufBytesAvailable);
+								if (iCopiedCnt < 0)
+								{
+									nPrinted = OSStringLength(pszFmt);
+								}
+								else
+								{
+									nPrinted = iCopiedCnt;
+								}
+							}
 							break;
 
 						default:
@@ -1062,13 +1083,21 @@ DecodeHTB(HTB_Sentinel_t *pSentinel, OSDI_IMPL_ENTRY *pvDumpDebugFile,
 				/* Display any remaining text in pszFmt string */
 				if (pszFmt)
 				{
-					nPrinted = OSStringLCopy(pszBuffer, pszFmt, uBufBytesAvailable);
-					if (nPrinted >= uBufBytesAvailable)
+					const ssize_t iCopiedCnt =
+						OSStringSafeCopy(pszBuffer, pszFmt, uBufBytesAvailable);
+					if (iCopiedCnt < 0)
 					{
-						PVR_DUMPDEBUG_LOG("Buffer overrun - "IMG_SIZE_FMTSPEC" printed,"
-							" max space "IMG_SIZE_FMTSPEC"\n", nPrinted,
-							uBufBytesAvailable);
-						nPrinted = uBufBytesAvailable;	/* Ensure we don't overflow buffer */
+						PVR_DUMPDEBUG_LOG("Buffer overrun - %zu required,"
+						                  " max space %zu\n",
+						                   OSStringLength(pszFmt),
+						                   uBufBytesAvailable);
+
+						/* Ensure we don't overflow buffer */
+						nPrinted = uBufBytesAvailable;
+					}
+					else
+					{
+						nPrinted = iCopiedCnt;
 					}
 					PVR_DUMPDEBUG_LOG("%s", pszBuffer);
 					pszBuffer += nPrinted;
diff --git a/drivers/gpu/drm/img-rogue/htbserver.c b/drivers/gpu/drm/img-rogue/htbserver.c
index 168cd01e319a..9ed3283f52b2 100644
--- a/drivers/gpu/drm/img-rogue/htbserver.c
+++ b/drivers/gpu/drm/img-rogue/htbserver.c
@@ -433,7 +433,6 @@ static IMG_BOOL
 _ValidPID( IMG_UINT32 PID )
 {
 	IMG_UINT32 i;
-
 	for (i = 0; i < g_sCtrl.ui32PIDCount; i++)
 	{
 		if ( g_sCtrl.aui32EnablePID[i] == PID )
@@ -473,9 +472,10 @@ HTBLogKM(IMG_UINT32 PID,
 )
 {
 #if defined(PVRSRV_ENABLE_HTB)
+
 	OS_SPINLOCK_FLAGS uiSpinLockFlags;
 	IMG_UINT32 ui32ReturnFlags = 0;
-	IMG_UINT32 i = 0;
+	IMG_UINT32 ui32CurrentArg = 0;
 
 	/* Local snapshot variables of global counters */
 	IMG_UINT64 ui64OSTSSnap;
@@ -497,9 +497,16 @@ HTBLogKM(IMG_UINT32 PID,
 	IMG_UINT32 ui32RetryCount = HTB_LOG_RETRY_COUNT;
 	IMG_UINT32 * pui32Message = aui32MessageBuffer;
 	IMG_UINT32 ui32NumArgs = HTB_SF_PARAMNUM(SF);
+	IMG_UINT32 ui32StrArg = HTB_SF_STRNUM(SF);
+	IMG_UINT32 ui32CurrentStringArg;
 
 	IMG_UINT32 ui32MessageSize = 4 * (HTB_LOG_HEADER_SIZE+ui32NumArgs);
 
+	if (ui32StrArg > 0)
+	{
+		ui32MessageSize += HTB_LOG_STR_ARG_SIZE - sizeof(IMG_UINT32);
+	}
+
 	PVR_ASSERT(ui32NumArgs <= HTB_LOG_MAX_PARAMS);
 	ui32NumArgs = (ui32NumArgs>HTB_LOG_MAX_PARAMS) ?
 			HTB_LOG_MAX_PARAMS : ui32NumArgs;
@@ -510,9 +517,63 @@ HTBLogKM(IMG_UINT32 PID,
 	/* Needs to be set up here because it's accessed from both `if` blocks below
 	 * and it needs to be pre-populated for both of them (pui32Message case and
 	 * HTB_SF_CTRL_FWSYNC_MARK_SCALE case). */
-	for (i = 0; i < ui32NumArgs; i++)
+
+	while (ui32CurrentArg < ui32NumArgs)
 	{
-		aui32Args[i] = va_arg(args, IMG_UINT32);
+		if (ui32StrArg != 0 && ui32CurrentArg == ui32StrArg - 1)
+		{
+			IMG_CHAR* strArg;
+			strArg = va_arg(args, IMG_CHAR*);
+
+			/* if a string is present, it will need more than one UINT32 words. */
+			ui32NumArgs += HTB_LOG_STR_ARG_NUM_WORDS - 1;
+
+			/* Ignore if filename is not supported. */
+			if (strcmp(strArg, "n/a") == 0)
+			{
+				PVR_DPF((PVR_DBG_MESSAGE, "N/A\n"));
+				return PVRSRV_OK;
+			}
+
+			/* looping through the created string to get the substrings to encode. */
+			for (ui32CurrentStringArg = 0; ui32CurrentStringArg < HTB_LOG_STR_ARG_NUM_WORDS; ui32CurrentStringArg++)
+			{
+				IMG_UINT32 encodedString = 0;
+
+				if (*strArg == '\0')
+				{
+					aui32Args[ui32CurrentArg] = encodedString;
+					ui32CurrentArg++;
+				}
+				else
+				{
+					IMG_UINT32 currentSubstring;
+
+					for (currentSubstring = 0; currentSubstring < sizeof(IMG_UINT32); currentSubstring++)
+					{
+						IMG_UINT32 bitPos = currentSubstring * 8;
+
+						if (*strArg == '\0')
+						{
+							break;
+						}
+						else
+						{
+							encodedString |= (IMG_UINT32) *strArg << bitPos;
+							strArg++;
+						}
+					}
+
+					aui32Args[ui32CurrentArg] = encodedString;
+					ui32CurrentArg++;
+				}
+			}
+		}
+		else
+		{
+			aui32Args[ui32CurrentArg] = va_arg(args, IMG_UINT32);
+			ui32CurrentArg++;
+		}
 	}
 
 	if ( g_hTLStream
@@ -526,12 +587,13 @@ HTBLogKM(IMG_UINT32 PID,
 		*pui32Message++ = TID;
 		*pui32Message++ = ((IMG_UINT32)((ui64TimeStamp>>32)&0xffffffff));
 		*pui32Message++ = ((IMG_UINT32)(ui64TimeStamp&0xffffffff));
-		for (i = 0; i < ui32NumArgs; i++)
+		for (ui32CurrentArg = 0; ui32CurrentArg < ui32NumArgs; ui32CurrentArg++)
 		{
-			pui32Message[i] = aui32Args[i];
+			pui32Message[ui32CurrentArg] = aui32Args[ui32CurrentArg];
 		}
 
 		eError = TLStreamWriteRetFlags( g_hTLStream, (IMG_UINT8*)aui32MessageBuffer, ui32MessageSize, &ui32ReturnFlags );
+
 		while ( PVRSRV_ERROR_NOT_READY == eError && ui32RetryCount-- )
 		{
 			OSReleaseThreadQuanta();
@@ -595,6 +657,7 @@ HTBLogKM(IMG_UINT32 PID,
 
 ReturnError:
 	return eError;
+
 #else
 	/* HTB support is disabled. Just return PVRSRV_OK and do nothing. */
 	PVR_UNREFERENCED_PARAMETER(PID);
@@ -602,7 +665,6 @@ HTBLogKM(IMG_UINT32 PID,
 	PVR_UNREFERENCED_PARAMETER(ui64TimeStamp);
 	PVR_UNREFERENCED_PARAMETER(SF);
 	PVR_UNREFERENCED_PARAMETER(args);
-
 	return PVRSRV_OK;
 #endif
 }
@@ -696,7 +758,7 @@ HTBControlKM_Impl(
 				HTB_STREAM_NAME,
 				g_sCtrl.ui32BufferSize,
 				_LookupFlags(HTB_OPMODE_DROPOLDEST) | g_ui32TLBaseFlags,
-				_OnTLReaderOpenCallback, NULL, NULL, NULL);
+				_OnTLReaderOpenCallback, NULL, NULL, NULL, NULL, NULL);
 		PVR_LOG_RETURN_IF_ERROR(eError, "TLStreamCreate");
 		g_bConfigured = IMG_TRUE;
 	}
diff --git a/drivers/gpu/drm/img-rogue/htbuffer_sf.h b/drivers/gpu/drm/img-rogue/htbuffer_sf.h
index 3bfd06398b83..83699a2d9547 100644
--- a/drivers/gpu/drm/img-rogue/htbuffer_sf.h
+++ b/drivers/gpu/drm/img-rogue/htbuffer_sf.h
@@ -99,58 +99,60 @@ extern "C" {
  */
 #define HTB_LOG_SFIDLIST \
 /*id,  gid,             sym name,                       string,                           # arguments */ \
-X( 0,  HTB_GROUP_NONE,  HTB_SF_FIRST,                   "You should not use this string", 0) \
+X( 0,  HTB_GROUP_NONE,  HTB_SF_FIRST,                   "You should not use this string", 0, 0) \
 \
-X( 1,  HTB_GROUP_CTRL,  HTB_SF_CTRL_LOGMODE,            "HTB log mode set to %d (1- all PID, 2 - restricted PID)\n", 1) \
-X( 2,  HTB_GROUP_CTRL,  HTB_SF_CTRL_ENABLE_PID,         "HTB enable logging for PID %d\n", 1) \
-X( 3,  HTB_GROUP_CTRL,  HTB_SF_CTRL_ENABLE_GROUP,       "HTB enable logging groups 0x%08x\n", 1) \
-X( 4,  HTB_GROUP_CTRL,  HTB_SF_CTRL_LOG_LEVEL,          "HTB log level set to %d\n", 1) \
-X( 5,  HTB_GROUP_CTRL,  HTB_SF_CTRL_OPMODE,             "HTB operating mode set to %d (1 - droplatest, 2 - drop oldest, 3 - block)\n", 1) \
-X( 6,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_SCALE,       "HTBFWSync OSTS=%08x%08x CRTS=%08x%08x CalcClkSpd=%d\n", 5) \
-X( 7,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_SCALE_RPT,   "FW Sync scale info OSTS=%08x%08x CRTS=%08x%08x CalcClkSpd=%d\n", 5) \
-X( 8,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK,        "FW Sync Partition marker: %d\n", 1) \
-X( 9,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK_RPT,    "FW Sync Partition repeat: %d\n", 1) \
-X( 10, HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK_SCALE,  "Text not used", 6)\
+X( 1,  HTB_GROUP_CTRL,  HTB_SF_CTRL_LOGMODE,            "HTB log mode set to %d (1- all PID, 2 - restricted PID)\n", 1, 0) \
+X( 2,  HTB_GROUP_CTRL,  HTB_SF_CTRL_ENABLE_PID,         "HTB enable logging for PID %d\n", 1, 0) \
+X( 3,  HTB_GROUP_CTRL,  HTB_SF_CTRL_ENABLE_GROUP,       "HTB enable logging groups 0x%08x\n", 1, 0) \
+X( 4,  HTB_GROUP_CTRL,  HTB_SF_CTRL_LOG_LEVEL,          "HTB log level set to %d\n", 1, 0) \
+X( 5,  HTB_GROUP_CTRL,  HTB_SF_CTRL_OPMODE,             "HTB operating mode set to %d (1 - droplatest, 2 - drop oldest, 3 - block)\n", 1, 0) \
+X( 6,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_SCALE,       "HTBFWSync OSTS=%08x%08x CRTS=%08x%08x CalcClkSpd=%d\n", 5, 0) \
+X( 7,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_SCALE_RPT,   "FW Sync scale info OSTS=%08x%08x CRTS=%08x%08x CalcClkSpd=%d\n", 5, 0) \
+X( 8,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK,        "FW Sync Partition marker: %d\n", 1, 0) \
+X( 9,  HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK_RPT,    "FW Sync Partition repeat: %d\n", 1, 0) \
+X( 10, HTB_GROUP_CTRL,  HTB_SF_CTRL_FWSYNC_MARK_SCALE,  "Text not used", 6, 0)\
 \
-X( 1,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_TABLE,       "MMU page op table entry page_id=%08x%08x index=%d level=%d val=%08x%08x map=%d\n", 7) \
-X( 2,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_ALLOC,       "MMU allocating DevVAddr from %08x%08x to %08x%08x\n", 4) \
-X( 3,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_FREE,        "MMU freeing DevVAddr from %08x%08x to %08x%08x\n", 4) \
-X( 4,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_MAP,         "MMU mapping DevVAddr %08x%08x to DevPAddr %08x%08x\n", 4) \
-X( 5,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_PMRMAP,      "MMU mapping PMR DevVAddr %08x%08x to DevPAddr %08x%08x\n", 4) \
-X( 6,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_UNMAP,       "MMU unmapping DevVAddr %08x%08x\n", 2) \
+X( 1,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_TABLE,       "MMU page op table entry page_id=%08x%08x index=%d level=%d val=%08x%08x map=%d\n", 7, 0) \
+X( 2,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_ALLOC,       "MMU allocating DevVAddr from %08x%08x to %08x%08x\n", 4, 0) \
+X( 3,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_FREE,        "MMU freeing DevVAddr from %08x%08x to %08x%08x\n", 4, 0) \
+X( 4,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_MAP,         "MMU mapping DevVAddr %08x%08x to DevPAddr %08x%08x\n", 4, 0) \
+X( 5,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_PMRMAP,      "MMU mapping PMR DevVAddr %08x%08x to DevPAddr %08x%08x\n", 4, 0)  \
+X( 6,  HTB_GROUP_MMU,   HTB_SF_MMU_PAGE_OP_UNMAP,       "MMU unmapping DevVAddr %08x%08x\n", 2, 0) \
 \
-X( 1,  HTB_GROUP_SYNC,  HTB_SF_SYNC_SERVER_ALLOC,       "Server sync allocation [%08X]\n", 1) \
-X( 2,  HTB_GROUP_SYNC,  HTB_SF_SYNC_SERVER_UNREF,       "Server sync unreferenced [%08X]\n", 1) \
-X( 3,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_CREATE,     "Sync OP create 0x%08x, block count=%d, server syncs=%d, client syncs=%d\n", 4) \
-X( 4,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_TAKE,       "Sync OP take 0x%08x server syncs=%d, client syncs=%d\n", 3) \
-X( 5,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_COMPLETE,   "Sync OP complete 0x%08x\n", 1) \
-X( 6,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_DESTROY,    "Sync OP destroy 0x%08x\n", 1) \
+X( 1,  HTB_GROUP_SYNC,  HTB_SF_SYNC_SERVER_ALLOC,       "Server sync allocation [%08X]\n", 1, 0) \
+X( 2,  HTB_GROUP_SYNC,  HTB_SF_SYNC_SERVER_UNREF,       "Server sync unreferenced [%08X]\n", 1, 0) \
+X( 3,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_CREATE,     "Sync OP create 0x%08x, block count=%d, server syncs=%d, client syncs=%d\n", 4, 0) \
+X( 4,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_TAKE,       "Sync OP take 0x%08x server syncs=%d, client syncs=%d\n", 3, 0) \
+X( 5,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_COMPLETE,   "Sync OP complete 0x%08x\n", 1, 0) \
+X( 6,  HTB_GROUP_SYNC,  HTB_SF_SYNC_PRIM_OP_DESTROY,    "Sync OP destroy 0x%08x\n", 1, 0) \
 \
-X( 1,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_TA_DEPRECATED, "Kick TA: FWCtx %08X @ %d\n", 2) \
-X( 2,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_3D_DEPRECATED, "Kick 3D: FWCtx %08X @ %d\n", 2) \
-X( 3,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_CDM_DEPRECATED,"Kick CDM: FWCtx %08X @ %d\n", 2) \
-X( 4,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_RTU,           "Kick RTU: FWCtx %08X @ %d\n", 2) \
-X( 5,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_SHG,           "Kick SHG: FWCtx %08X @ %d\n", 2) \
-X( 6,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_2D_DEPRECATED, "Kick 2D: FWCtx %08X @ %d\n", 2) \
-X( 7,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_UNCOUNTED,     "Kick (uncounted) for all DMs\n", 0) \
-X( 8,  HTB_GROUP_MAIN,  HTB_SF_MAIN_FWCCB_CMD,          "FW CCB Cmd: %d\n", 1) \
-X( 9,  HTB_GROUP_MAIN,  HTB_SF_MAIN_PRE_POWER,          "Pre-power duration @ phase [%d] (0-shutdown,1-startup) RGX: %llu ns SYS: %llu ns\n", 3) \
-X(10,  HTB_GROUP_MAIN,  HTB_SF_MAIN_POST_POWER,         "Post-power duration @ phase [%d] (0-shutdown,1-startup) SYS: %llu ns RGX: %llu ns\n", 3) \
-X(11,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_TA,            "Kick TA: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5) \
-X(12,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_3D,            "Kick 3D: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5) \
-X(13,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_CDM,           "Kick CDM: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5) \
-X(14,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_2D,            "Kick 2D: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5) \
-X(15,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_ERROR,          "Error: (%u) @ line: %u\n", 2) \
-X(16,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_COND_ERROR_T,   "Error: (%u) Conditional is unexpectedly true @ line: %u\n", 2) \
-X(17,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_COND_ERROR_F,   "Error: (%u) Conditional is unexpectedly false @ line: %u\n", 2) \
-X(18,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_WARNING,        "Warning: (%u) in file: @ line: %u\n", 2) \
+X( 1,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_TA_DEPRECATED, "Kick TA: FWCtx %08X @ %d\n", 2, 0) \
+X( 2,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_3D_DEPRECATED, "Kick 3D: FWCtx %08X @ %d\n", 2, 0) \
+X( 3,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_CDM_DEPRECATED,"Kick CDM: FWCtx %08X @ %d\n", 2, 0) \
+X( 4,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_RTU,           "Kick RTU: FWCtx %08X @ %d\n", 2, 0) \
+X( 5,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_SHG,           "Kick SHG: FWCtx %08X @ %d\n", 2, 0) \
+X( 6,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_2D_DEPRECATED, "Kick 2D: FWCtx %08X @ %d\n", 2, 0) \
+X( 7,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_UNCOUNTED,     "Kick (uncounted) for all DMs\n", 0, 0) \
+X( 8,  HTB_GROUP_MAIN,  HTB_SF_MAIN_FWCCB_CMD,          "FW CCB Cmd: %d\n", 1, 0) \
+X( 9,  HTB_GROUP_MAIN,  HTB_SF_MAIN_PRE_POWER,          "Pre-power duration @ phase [%d] (0-shutdown,1-startup) RGX: %llu ns SYS: %llu ns\n", 3, 0) \
+X(10,  HTB_GROUP_MAIN,  HTB_SF_MAIN_POST_POWER,         "Post-power duration @ phase [%d] (0-shutdown,1-startup) SYS: %llu ns RGX: %llu ns\n", 3, 0) \
+X(11,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_TA,            "Kick TA: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5, 0) \
+X(12,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_3D,            "Kick 3D: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5, 0) \
+X(13,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_CDM,           "Kick CDM: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5, 0) \
+X(14,  HTB_GROUP_MAIN,  HTB_SF_MAIN_KICK_2D,            "Kick 2D: FWCtx %08x @ %d (frame:%d, ext:0x%08x, int:0x%08x)\n", 5, 0) \
+X(15,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_ERROR,          "Error: (%u) in file: %s:%u\n", 3, 2) \
+X(16,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_MSGLVL_ERROR,   "Log error in file: %s:%u\n", 2, 1) \
+X(17,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_COND_ERROR_T,   "Error: (%u) Conditional is unexpectedly true in file: %s:%u\n", 3, 2) \
+X(18,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_COND_ERROR_F,   "Error: (%u) Conditional is unexpectedly false in file: %s:%u\n", 3, 2) \
+X(19,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_WARNING,        "Warning: (%u) in file: %s @ line: %u\n", 3, 2) \
+X(20,  HTB_GROUP_MAIN,  HTB_SF_MAIN_DBG_MSGLVL_WARN,    "Log warning in file: %s:%u\n", 2, 1) \
 \
-X( 1,  HTB_GROUP_BRG,   HTB_SF_BRG_BRIDGE_CALL,         "Bridge call: start: %010u: bid %03d fid %d\n", 3) \
-X( 2,  HTB_GROUP_BRG,   HTB_SF_BRG_BRIDGE_CALL_ERR,     "Bridge call: start: %010u: bid %03d fid %d error %d\n", 4) \
+X( 1,  HTB_GROUP_BRG,   HTB_SF_BRG_BRIDGE_CALL,         "Bridge call: start: %010u: bid %03d fid %d\n", 3, 0) \
+X( 2,  HTB_GROUP_BRG,   HTB_SF_BRG_BRIDGE_CALL_ERR,     "Bridge call: start: %010u: bid %03d fid %d error %d\n", 4, 0) \
 \
-X( 1,  HTB_GROUP_DBG,   HTB_SF_DBG_INTPAIR,             "0x%8.8x 0x%8.8x\n", 2) \
+X( 1,  HTB_GROUP_DBG,   HTB_SF_DBG_INTPAIR,             "0x%8.8x 0x%8.8x\n", 2, 0) \
 \
-X( 65535, HTB_GROUP_NONE, HTB_SF_LAST,                  "You should not use this string\n", 15)
+X( 65535, HTB_GROUP_NONE, HTB_SF_LAST,                  "You should not use this string\n", 15, 0)
 
 
 
@@ -188,20 +190,22 @@ typedef enum _HTB_LOG_TYPE {
  *    0-11: id number
  *   12-15: group id number
  *   16-19: number of parameters
- *   20-27: unused
+ *   20-24: If the format contains a string argument, argument
+ *          index is passed. If there isn't a string argument, 0 is passed
+ *   25-27: unused
  *   28-30: active: identify SF packet, otherwise regular int32
  *      31: reserved for signed/unsigned compatibility
  *
  * The following macro assigns those values to the enum generated SF ids list.
  */
 #define HTB_LOG_IDMARKER            (0x70000000)
-#define HTB_LOG_CREATESFID(a,b,e)   (((a) | (b << 12) | (e << 16)) | HTB_LOG_IDMARKER)
+#define HTB_LOG_CREATESFID(a,b,e,f)   (((a) | (b << 12) | (e << 16)) | (f << 20) | HTB_LOG_IDMARKER)
 
 #define HTB_LOG_IDMASK              (0xFFF00000)
 #define HTB_LOG_VALIDID(I)          ( ((I) & HTB_LOG_IDMASK) == HTB_LOG_IDMARKER )
 
 typedef enum HTB_LOG_SFids {
-#define X(a, b, c, d, e) c = HTB_LOG_CREATESFID(a,b,e),
+#define X(a, b, c, d, e, f) c = HTB_LOG_CREATESFID(a,b,e,f),
 	HTB_LOG_SFIDLIST
 #undef X
 } HTB_LOG_SFids;
@@ -214,6 +218,9 @@ typedef enum HTB_LOG_SFids {
  * (enum generated) id requires.
  */
 #define HTB_SF_PARAMNUM(x) (((x)>>16) & 0xf)
+/* Returns the index of the argument that contains a string, 1 indexed so 0 means no string argument.
+ */
+#define HTB_SF_STRNUM(x) (((x)>>20) & 0xf)
 /* Returns the id of given enum */
 #define HTB_SF_ID(x) (x & 0xfff)
 
@@ -222,10 +229,30 @@ typedef enum HTB_LOG_SFids {
 #define HTB_LOG_HEADER_SIZE         5
 #define HTB_LOG_MAX_PARAMS          15
 
+/* HTB supports string lengths of up to 23 characters + \0 */
+#define HTB_LOG_STR_ARG_NUM_WORDS         (6)
+#define HTB_LOG_STR_ARG_SIZE              (HTB_LOG_STR_ARG_NUM_WORDS * sizeof(IMG_UINT32))
+
 #if defined(__cplusplus)
 }
 #endif
 
+#if defined(__GNUC__)
+#if GCC_VERSION_AT_LEAST(12, 1)
+#define HTB_FILE_NAME __FILE_NAME__
+#else
+#define HTB_FILE_NAME "n/a"
+#endif
+#elif defined(__clang__)
+#if CLANG_VERSION_AT_LEAST(10)
+#define HTB_FILE_NAME __FILE_NAME__
+#else
+#define HTB_FILE_NAME "n/a"
+#endif
+#else
+#define HTB_FILE_NAME "n/a"
+#endif
+
 /* Defines for handling MARK_SCALE special case */
 #define HTB_GID_CTRL 1
 #define HTB_ID_MARK_SCALE 10
diff --git a/drivers/gpu/drm/img-rogue/img_defs.h b/drivers/gpu/drm/img-rogue/img_defs.h
index 0a755ae134c4..b0992b7188c9 100644
--- a/drivers/gpu/drm/img-rogue/img_defs.h
+++ b/drivers/gpu/drm/img-rogue/img_defs.h
@@ -210,11 +210,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 /*! Macro to calculate the n-byte aligned value from that supplied rounding up.
  * n must be a power of two.
- *
- * Both arguments should be of a type with the same size otherwise the macro may
- * cut off digits, e.g. imagine a 64 bit address in _x and a 32 bit value in _n.
  */
-#define PVR_ALIGN(_x, _n)	(((_x)+((_n)-1U)) & ~((_n)-1U))
+#define PVR_ALIGN(_x, _n)	((((_x)+((_n)-1U))|((_n)-1U))^((_n)-1U))
 
 #if defined(_WIN32)
 
@@ -282,7 +279,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 		#define IMG_INTERNAL
 		#define IMG_EXPORT
 		#define IMG_CALLCONV
-	#elif defined(__linux__) || defined(__METAG) || defined(__mips) || defined(__QNXNTO__) || defined(__riscv) || defined(__APPLE__)
+	#elif defined(__linux__) || defined(__METAG) || defined(__mips) || defined(__QNXNTO__) || defined(__riscv) || defined(__APPLE__) || defined(TEE_DDK)
 		#define IMG_CALLCONV
 		#define C_CALLCONV
 
@@ -553,6 +550,29 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define IMG_CONCATENATE_IMPL(x,y) x ## y
 #define IMG_CONCATENATE(x,y) IMG_CONCATENATE_IMPL(x,y)
 
+#if defined(DEBUG) && !defined(INTEGRITY_OS)
+#define IMG_PAGESLOG2BYTES(_tcast, _npages, _log2) \
+	({ \
+		PVR_ASSERT( ((IMG_UINT64)(1ULL) << (sizeof(_tcast)*8UL)) >= ((IMG_UINT64)(_npages) << (_log2)) ); \
+		(_tcast)(_npages) << (_log2); \
+	})
+#else
+#define IMG_PAGESLOG2BYTES(_tcast, _npages, _log2) ((_npages) << (_log2))
+#endif
+
+#define IMG_PAGE2BYTES32(logsize) IMG_PAGESLOG2BYTES(IMG_UINT32,IMG_UINT32_C(1),logsize)
+#define IMG_PAGE2BYTES64(logsize) ((IMG_UINT64)IMG_UINT64_C(1) << (logsize))
+
+#define IMG_PAGES2BYTES32(pages,logsize) IMG_PAGESLOG2BYTES(IMG_UINT32,pages,logsize)
+#define IMG_PAGES2BYTES64(pages,logsize) ((IMG_UINT64)(pages) << (logsize))
+
+#define IMG_PAGE_SHIFT_4KB   12U
+#define IMG_PAGE_SHIFT_16KB  14U
+#define IMG_PAGE_SHIFT_64KB  16U
+#define IMG_PAGE_SHIFT_256KB 18U
+#define IMG_PAGE_SHIFT_1MB   20U
+#define IMG_PAGE_SHIFT_2MB   21U
+
 #if defined(INTEGRITY_OS)
 	/* Definitions not present in INTEGRITY. */
 	#define PATH_MAX	200
@@ -593,6 +613,16 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define PVR_PRE_DPF (void) printf
 
+/* C STD >= C99 */
+#if !defined(INTEGRITY_OS) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#define IMG_FLEX_ARRAY_MEMBER
+#define IMG_FLEX_ARRAY_SIZE(size, count) ((size) * (count))
+#else
+/* In C STD prior to C99 flexible array members are an extension feature and syntax requires alternative approach */
+#define IMG_FLEX_ARRAY_MEMBER (1)
+#define IMG_FLEX_ARRAY_SIZE(size, count) ((size) * ((count) - 1))
+#endif
+
 #endif /* IMG_DEFS_H */
 /*****************************************************************************
  End of file (img_defs.h)
diff --git a/drivers/gpu/drm/img-rogue/img_types.h b/drivers/gpu/drm/img-rogue/img_types.h
index 7b4eb6415515..1ceebc5d5552 100644
--- a/drivers/gpu/drm/img-rogue/img_types.h
+++ b/drivers/gpu/drm/img-rogue/img_types.h
@@ -69,7 +69,8 @@ extern "C" {
 	#include <linux/types.h>
 	#include "kernel_types.h"
 #elif defined(__linux__) || defined(__METAG) || defined(__MINGW32__) || \
-	defined(__QNXNTO__) || defined(INTEGRITY_OS) || defined(__riscv) || defined(__APPLE__)
+	defined(__QNXNTO__) || defined(INTEGRITY_OS) || defined(__riscv) || \
+	defined(__APPLE__) || defined(TEE_DDK)
 	#include <stddef.h>			/* NULL */
 	#include <stdint.h>
 #if defined(__riscv)
@@ -78,6 +79,7 @@ extern "C" {
 #endif
 	#include <inttypes.h>		/* intX_t/uintX_t, format specifiers */
 	#include <limits.h>			/* INT_MIN, etc */
+	#include <sys/types.h>		/* ssize_t */
 #if defined(__riscv)
 #pragma GCC diagnostic pop
 #endif
@@ -176,9 +178,7 @@ typedef bool*     IMG_PBOOL;
 #define IMG_FALSE ((bool) 0)
 #define IMG_TRUE  ((bool) 1)
 
-#if defined(UNDER_WDDM) || defined(WINDOWS_WDF)
 typedef IMG_CHAR const* IMG_PCCHAR;
-#endif
 
 /* Format specifiers for 'size_t' type */
 #if defined(_MSC_VER)
diff --git a/drivers/gpu/drm/img-rogue/info_page_client.h b/drivers/gpu/drm/img-rogue/info_page_client.h
index 9df2461b55fb..56d394dd99a3 100644
--- a/drivers/gpu/drm/img-rogue/info_page_client.h
+++ b/drivers/gpu/drm/img-rogue/info_page_client.h
@@ -65,9 +65,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 static INLINE IMG_PUINT32 GetInfoPage(SHARED_DEV_CONNECTION hDevConnection)
 {
 #if defined(__KERNEL__)
+	PVR_UNREFERENCED_PARAMETER(hDevConnection);
+
 	return (PVRSRVGetPVRSRVData())->pui32InfoPage;
 #else
-    return hDevConnection->pui32InfoPage;
+	return hDevConnection->pui32InfoPage;
 #endif
 }
 
diff --git a/drivers/gpu/drm/img-rogue/kernel_compatibility.h b/drivers/gpu/drm/img-rogue/kernel_compatibility.h
index aab3dc1ef1e2..048f4449ae68 100644
--- a/drivers/gpu/drm/img-rogue/kernel_compatibility.h
+++ b/drivers/gpu/drm/img-rogue/kernel_compatibility.h
@@ -46,6 +46,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <linux/version.h>
 #include <linux/compiler.h>
 
+/* Explicitly error out if DDK is built against out-of-support Linux kernel */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
+#error Linux kernels older than 4.9.0 are not supported
+#endif
+
 /*
  * Stop supporting an old kernel? Remove the top block.
  * New incompatible kernel?       Append a new block at the bottom.
@@ -58,239 +63,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * included after it.
  */
 
-/* Linux 3.6 introduced seq_vprintf(). Earlier versions don't have this
- * so we work around the limitation by vsnprintf() + seq_puts().
- */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
-#define seq_vprintf(seq_file, fmt, args) \
-do { \
-	char aszBuffer[512]; /* maximum message buffer size */ \
-	vsnprintf(aszBuffer, sizeof(aszBuffer), fmt, args); \
-	seq_puts(seq_file, aszBuffer); \
-} while (0)
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-
-/* Linux 3.7 split VM_RESERVED into VM_DONTDUMP and VM_DONTEXPAND */
-#define VM_DONTDUMP VM_RESERVED
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)) */
-
-/*
- * Note: this fix had to be written backwards because get_unused_fd_flags
- * was already defined but not exported on kernels < 3.7
- *
- * When removing support for kernels < 3.7, this block should be removed
- * and all `get_unused_fd()` should be manually replaced with
- * `get_unused_fd_flags(0)`
- */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
-
-/* Linux 3.19 removed get_unused_fd() */
-/* get_unused_fd_flags was introduced in 3.7 */
-#define get_unused_fd() get_unused_fd_flags(0)
-
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
-
-/*
- * Headers shouldn't normally be included by this file but this is a special
- * case as it's not obvious from the name that devfreq_add_device needs this
- * include.
- */
-#include <linux/string.h>
-
-#define devfreq_add_device(dev, profile, name, data) \
-	({ \
-		struct devfreq *__devfreq; \
-		if (name && !strcmp(name, "simple_ondemand")) \
-			__devfreq = devfreq_add_device(dev, profile, \
-							   &devfreq_simple_ondemand, data); \
-		else \
-			__devfreq = ERR_PTR(-EINVAL); \
-		__devfreq; \
-	})
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0))
-
-#define DRIVER_RENDER 0
-#define DRM_RENDER_ALLOW 0
-
-/* Linux 3.12 introduced a new shrinker API */
-#define SHRINK_STOP (~0UL)
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
-
-#define dev_pm_opp_get_opp_count(dev) opp_get_opp_count(dev)
-#define dev_pm_opp_get_freq(opp) opp_get_freq(opp)
-#define dev_pm_opp_get_voltage(opp) opp_get_voltage(opp)
-#define dev_pm_opp_add(dev, freq, u_volt) opp_add(dev, freq, u_volt)
-#define dev_pm_opp_find_freq_ceil(dev, freq) opp_find_freq_ceil(dev, freq)
-
-#if defined(CONFIG_ARM)
-/* Linux 3.13 renamed ioremap_cached to ioremap_cache */
-#define ioremap_cache(cookie, size) ioremap_cached(cookie, size)
-#endif /* defined(CONFIG_ARM) */
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
-
-/* Linux 3.14 introduced a new set of sized min and max defines */
-#ifndef U32_MAX
-#define U32_MAX ((u32)UINT_MAX)
-#endif
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0))
-
-/* Linux 3.17 changed the 3rd argument from a `struct page ***pages` to
- * `struct page **pages` */
-#define map_vm_area(area, prot, pages) map_vm_area(area, prot, &pages)
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))
-
-/*
- * Linux 4.7 removed this function but its replacement was available since 3.19.
- */
-#define drm_crtc_send_vblank_event(crtc, e) drm_send_vblank_event((crtc)->dev, drm_crtc_index(crtc), e)
-
-/* seq_has_overflowed() was introduced in 3.19 but the structure elements
- * have been available since 2.x
- */
-#include <linux/seq_file.h>
-static inline bool seq_has_overflowed(struct seq_file *m)
-{
-	return m->count == m->size;
-}
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
-
-#define debugfs_create_file_size(name, mode, parent, data, fops, file_size) \
-	({ \
-		struct dentry *de; \
-		de = debugfs_create_file(name, mode, parent, data, fops); \
-		if (de) \
-			de->d_inode->i_size = file_size; \
-		de; \
-	})
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0))
-#define drm_fb_helper_unregister_fbi(fb_helper) \
-	({ \
-		if ((fb_helper) && (fb_helper)->fbdev) \
-			unregister_framebuffer((fb_helper)->fbdev); \
-	})
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
-
-/* Linux 4.4 renamed GFP_WAIT to GFP_RECLAIM */
-#define __GFP_RECLAIM __GFP_WAIT
-
-#if !defined(CHROMIUMOS_KERNEL) || (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-#define dev_pm_opp_of_add_table(dev) of_init_opp_table(dev)
-#define dev_pm_opp_of_remove_table(dev) of_free_opp_table(dev)
-#else
-#define sync_fence_create(data_name, sync_pt) sync_fence_create(data_name, &(sync_pt)->base)
-#endif
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)) && \
-	(!defined(CHROMIUMOS_KERNEL) || (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)))
-
-/* Linux 4.5 added a new printf-style parameter for debug messages */
-
-#define drm_encoder_init(dev, encoder, funcs, encoder_type, name, ...) \
-	drm_encoder_init(dev, encoder, funcs, encoder_type)
-
-#define drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, format_modifiers, type, name, ...) \
-	({ (void) format_modifiers; drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, type); })
-
-#define drm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs, name, ...) \
-	drm_crtc_init_with_planes(dev, crtc, primary, cursor, funcs)
-
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
-
-#define drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, format_modifiers, type, name, ...) \
-	({ (void) format_modifiers; drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, type, name, ##__VA_ARGS__); })
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
-
-/*
- * Linux 4.6 removed the first two parameters, the "struct task_struct" type
- * pointer "current" is defined in asm/current.h, which makes it pointless
- * to pass it on every function call.
-*/
-#define get_user_pages(start, nr_pages, gup_flags, pages, vmas) \
-	get_user_pages(current, current->mm, start, nr_pages, gup_flags & FOLL_WRITE, gup_flags & FOLL_FORCE, pages, vmas)
-
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
-
-/* Linux 4.9 replaced the write/force parameters with "gup_flags" */
-#define get_user_pages(start, nr_pages, gup_flags, pages, vmas) \
-	get_user_pages(start, nr_pages, gup_flags & FOLL_WRITE, gup_flags & FOLL_FORCE, pages, vmas)
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)) */
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)) && \
-	(!defined(CHROMIUMOS_KERNEL) || (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)))
-
-/*
- * Linux 4.6 removed the start and end arguments as it now always maps
- * the entire DMA-BUF.
- * Additionally, dma_buf_end_cpu_access() now returns an int error.
- */
-#define dma_buf_begin_cpu_access(DMABUF, DIRECTION) dma_buf_begin_cpu_access(DMABUF, 0, DMABUF->size, DIRECTION)
-#define dma_buf_end_cpu_access(DMABUF, DIRECTION) ({ dma_buf_end_cpu_access(DMABUF, 0, DMABUF->size, DIRECTION); 0; })
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)) && \
-		  (!defined(CHROMIUMOS_KERNEL) || (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0))
-
-/* Linux 4.7 removed the first arguments as it's never been used */
-#define drm_gem_object_lookup(filp, handle) drm_gem_object_lookup((filp)->minor->dev, filp, handle)
-
-/* Linux 4.7 replaced nla_put_u64 with nla_put_u64_64bit */
-#define nla_put_u64_64bit(skb, attrtype, value, padattr) nla_put_u64(skb, attrtype, value)
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
-
-/* Linux 4.9 changed the second argument to a drm_file pointer */
-#define drm_vma_node_is_allowed(node, file_priv) drm_vma_node_is_allowed(node, (file_priv)->filp)
-#define drm_vma_node_allow(node, file_priv) drm_vma_node_allow(node, (file_priv)->filp)
-#define drm_vma_node_revoke(node, file_priv) drm_vma_node_revoke(node, (file_priv)->filp)
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)) */
-
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
 #define refcount_read(r) atomic_read(r)
 #define drm_mm_insert_node(mm, node, size) drm_mm_insert_node(mm, node, size, 0, DRM_MM_SEARCH_DEFAULT)
@@ -327,6 +99,15 @@ static inline bool seq_has_overflowed(struct seq_file *m)
 
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)) */
 
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
+
+#define drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, format_modifiers, type, name, ...) \
+	({ (void) format_modifiers; drm_universal_plane_init(dev, plane, possible_crtcs, funcs, formats, format_count, type, name, ##__VA_ARGS__); })
+
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)) */
+
+
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
 
 #define drm_dev_put(dev) drm_dev_unref(dev)
@@ -537,6 +318,7 @@ struct dma_buf_map {
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0))
 #define iosys_map dma_buf_map
+#define iosys_map_set_vaddr dma_buf_map_set_vaddr
 #define iosys_map_set_vaddr_iomem dma_buf_map_set_vaddr_iomem
 #define iosys_map_clear dma_buf_map_clear
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)) */
@@ -574,11 +356,28 @@ static inline void pvr_vm_flags_init(struct vm_area_struct *vma,
 {
 	vma->vm_flags = flags;
 }
+static inline void pvr_vm_flags_clear(struct vm_area_struct *vma,
+				vm_flags_t flags)
+{
+	vma->vm_flags &= ~flags;
+}
 #else
 #define pvr_vm_flags_set  vm_flags_set
 #define pvr_vm_flags_init vm_flags_init
+#define pvr_vm_flags_clear vm_flags_clear
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)) */
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0))
+#define pvr_class_create(name) class_create(THIS_MODULE, name)
+#else
+#define pvr_class_create(name) class_create(name)
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+#define thermal_tripless_zone_device_register(type, devdata, ops, tzp) \
+	thermal_zone_device_register((type), 0, 0, (devdata), (ops), (tzp), 0, 0)
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)) */
+
 #if defined(__GNUC__)
 #define GCC_VERSION_AT_LEAST(major, minor) \
 	(__GNUC__ > (major) || \
diff --git a/drivers/gpu/drm/img-rogue/kernel_nospec.h b/drivers/gpu/drm/img-rogue/kernel_nospec.h
index e27a3ebc2ac6..ef6fee368327 100644
--- a/drivers/gpu/drm/img-rogue/kernel_nospec.h
+++ b/drivers/gpu/drm/img-rogue/kernel_nospec.h
@@ -49,9 +49,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) &&		\
 	 LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 18)) ||		\
 	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0) &&		\
-	 LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 81)) ||		\
-	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0) &&		\
-	 LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 118)))
+	 LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 81)))
 #include <linux/kernel.h>
 #include <linux/bug.h>
 #include <linux/nospec.h>
diff --git a/drivers/gpu/drm/img-rogue/km/rgx_bvnc_defs_km.h b/drivers/gpu/drm/img-rogue/km/rgx_bvnc_defs_km.h
index 798c36305261..73c44b77f498 100644
--- a/drivers/gpu/drm/img-rogue/km/rgx_bvnc_defs_km.h
+++ b/drivers/gpu/drm/img-rogue/km/rgx_bvnc_defs_km.h
@@ -75,164 +75,122 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_FEATURE_COMPUTE_MORTON_CAPABLE_POS                          (3U)
 #define RGX_FEATURE_COMPUTE_MORTON_CAPABLE_BIT_MASK                     (IMG_UINT64_C(0x0000000000000008))
 
-#define RGX_FEATURE_COMPUTE_ONLY_POS                                    (4U)
-#define RGX_FEATURE_COMPUTE_ONLY_BIT_MASK                               (IMG_UINT64_C(0x0000000000000010))
+#define RGX_FEATURE_COMPUTE_OVERLAP_POS                                 (4U)
+#define RGX_FEATURE_COMPUTE_OVERLAP_BIT_MASK                            (IMG_UINT64_C(0x0000000000000010))
 
-#define RGX_FEATURE_COMPUTE_OVERLAP_POS                                 (5U)
-#define RGX_FEATURE_COMPUTE_OVERLAP_BIT_MASK                            (IMG_UINT64_C(0x0000000000000020))
+#define RGX_FEATURE_COREID_PER_OS_POS                                   (5U)
+#define RGX_FEATURE_COREID_PER_OS_BIT_MASK                              (IMG_UINT64_C(0x0000000000000020))
 
-#define RGX_FEATURE_COMPUTE_OVERLAP_WITH_BARRIERS_POS                   (6U)
-#define RGX_FEATURE_COMPUTE_OVERLAP_WITH_BARRIERS_BIT_MASK              (IMG_UINT64_C(0x0000000000000040))
+#define RGX_FEATURE_DYNAMIC_DUST_POWER_POS                              (6U)
+#define RGX_FEATURE_DYNAMIC_DUST_POWER_BIT_MASK                         (IMG_UINT64_C(0x0000000000000040))
 
-#define RGX_FEATURE_COREID_PER_OS_POS                                   (7U)
-#define RGX_FEATURE_COREID_PER_OS_BIT_MASK                              (IMG_UINT64_C(0x0000000000000080))
+#define RGX_FEATURE_FASTRENDER_DM_POS                                   (7U)
+#define RGX_FEATURE_FASTRENDER_DM_BIT_MASK                              (IMG_UINT64_C(0x0000000000000080))
 
-#define RGX_FEATURE_DUST_POWER_ISLAND_S7_POS                            (8U)
-#define RGX_FEATURE_DUST_POWER_ISLAND_S7_BIT_MASK                       (IMG_UINT64_C(0x0000000000000100))
+#define RGX_FEATURE_GPU_MULTICORE_SUPPORT_POS                           (8U)
+#define RGX_FEATURE_GPU_MULTICORE_SUPPORT_BIT_MASK                      (IMG_UINT64_C(0x0000000000000100))
 
-#define RGX_FEATURE_DYNAMIC_DUST_POWER_POS                              (9U)
-#define RGX_FEATURE_DYNAMIC_DUST_POWER_BIT_MASK                         (IMG_UINT64_C(0x0000000000000200))
+#define RGX_FEATURE_GPU_VIRTUALISATION_POS                              (9U)
+#define RGX_FEATURE_GPU_VIRTUALISATION_BIT_MASK                         (IMG_UINT64_C(0x0000000000000200))
 
-#define RGX_FEATURE_FASTRENDER_DM_POS                                   (10U)
-#define RGX_FEATURE_FASTRENDER_DM_BIT_MASK                              (IMG_UINT64_C(0x0000000000000400))
+#define RGX_FEATURE_GS_RTA_SUPPORT_POS                                  (10U)
+#define RGX_FEATURE_GS_RTA_SUPPORT_BIT_MASK                             (IMG_UINT64_C(0x0000000000000400))
 
-#define RGX_FEATURE_GPU_MULTICORE_SUPPORT_POS                           (11U)
-#define RGX_FEATURE_GPU_MULTICORE_SUPPORT_BIT_MASK                      (IMG_UINT64_C(0x0000000000000800))
+#define RGX_FEATURE_IRQ_PER_OS_POS                                      (11U)
+#define RGX_FEATURE_IRQ_PER_OS_BIT_MASK                                 (IMG_UINT64_C(0x0000000000000800))
 
-#define RGX_FEATURE_GPU_VIRTUALISATION_POS                              (12U)
-#define RGX_FEATURE_GPU_VIRTUALISATION_BIT_MASK                         (IMG_UINT64_C(0x0000000000001000))
+#define RGX_FEATURE_MIPS_POS                                            (12U)
+#define RGX_FEATURE_MIPS_BIT_MASK                                       (IMG_UINT64_C(0x0000000000001000))
 
-#define RGX_FEATURE_GS_RTA_SUPPORT_POS                                  (13U)
-#define RGX_FEATURE_GS_RTA_SUPPORT_BIT_MASK                             (IMG_UINT64_C(0x0000000000002000))
+#define RGX_FEATURE_PBE2_IN_XE_POS                                      (13U)
+#define RGX_FEATURE_PBE2_IN_XE_BIT_MASK                                 (IMG_UINT64_C(0x0000000000002000))
 
-#define RGX_FEATURE_IRQ_PER_OS_POS                                      (14U)
-#define RGX_FEATURE_IRQ_PER_OS_BIT_MASK                                 (IMG_UINT64_C(0x0000000000004000))
+#define RGX_FEATURE_PBE_CHECKSUM_2D_POS                                 (14U)
+#define RGX_FEATURE_PBE_CHECKSUM_2D_BIT_MASK                            (IMG_UINT64_C(0x0000000000004000))
 
-#define RGX_FEATURE_META_DMA_POS                                        (15U)
-#define RGX_FEATURE_META_DMA_BIT_MASK                                   (IMG_UINT64_C(0x0000000000008000))
+#define RGX_FEATURE_PBVNC_COREID_REG_POS                                (15U)
+#define RGX_FEATURE_PBVNC_COREID_REG_BIT_MASK                           (IMG_UINT64_C(0x0000000000008000))
 
-#define RGX_FEATURE_MIPS_POS                                            (16U)
-#define RGX_FEATURE_MIPS_BIT_MASK                                       (IMG_UINT64_C(0x0000000000010000))
+#define RGX_FEATURE_PERFBUS_POS                                         (16U)
+#define RGX_FEATURE_PERFBUS_BIT_MASK                                    (IMG_UINT64_C(0x0000000000010000))
 
-#define RGX_FEATURE_PBE2_IN_XE_POS                                      (17U)
-#define RGX_FEATURE_PBE2_IN_XE_BIT_MASK                                 (IMG_UINT64_C(0x0000000000020000))
+#define RGX_FEATURE_PERF_COUNTER_BATCH_POS                              (17U)
+#define RGX_FEATURE_PERF_COUNTER_BATCH_BIT_MASK                         (IMG_UINT64_C(0x0000000000020000))
 
-#define RGX_FEATURE_PBE_CHECKSUM_2D_POS                                 (18U)
-#define RGX_FEATURE_PBE_CHECKSUM_2D_BIT_MASK                            (IMG_UINT64_C(0x0000000000040000))
+#define RGX_FEATURE_PM_MMU_VFP_POS                                      (18U)
+#define RGX_FEATURE_PM_MMU_VFP_BIT_MASK                                 (IMG_UINT64_C(0x0000000000040000))
 
-#define RGX_FEATURE_PBVNC_COREID_REG_POS                                (19U)
-#define RGX_FEATURE_PBVNC_COREID_REG_BIT_MASK                           (IMG_UINT64_C(0x0000000000080000))
+#define RGX_FEATURE_RISCV_FW_PROCESSOR_POS                              (19U)
+#define RGX_FEATURE_RISCV_FW_PROCESSOR_BIT_MASK                         (IMG_UINT64_C(0x0000000000080000))
 
-#define RGX_FEATURE_PDS_PER_DUST_POS                                    (20U)
-#define RGX_FEATURE_PDS_PER_DUST_BIT_MASK                               (IMG_UINT64_C(0x0000000000100000))
+#define RGX_FEATURE_ROGUEXE_POS                                         (20U)
+#define RGX_FEATURE_ROGUEXE_BIT_MASK                                    (IMG_UINT64_C(0x0000000000100000))
 
-#define RGX_FEATURE_PDS_TEMPSIZE8_POS                                   (21U)
-#define RGX_FEATURE_PDS_TEMPSIZE8_BIT_MASK                              (IMG_UINT64_C(0x0000000000200000))
+#define RGX_FEATURE_SAFETY_IRQ_POS                                      (21U)
+#define RGX_FEATURE_SAFETY_IRQ_BIT_MASK                                 (IMG_UINT64_C(0x0000000000200000))
 
-#define RGX_FEATURE_PERFBUS_POS                                         (22U)
-#define RGX_FEATURE_PERFBUS_BIT_MASK                                    (IMG_UINT64_C(0x0000000000400000))
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_POS                (22U)
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_BIT_MASK           (IMG_UINT64_C(0x0000000000400000))
 
-#define RGX_FEATURE_PERF_COUNTER_BATCH_POS                              (23U)
-#define RGX_FEATURE_PERF_COUNTER_BATCH_BIT_MASK                         (IMG_UINT64_C(0x0000000000800000))
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V1_POS             (23U)
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V1_BIT_MASK        (IMG_UINT64_C(0x0000000000800000))
 
-#define RGX_FEATURE_PM_MMU_VFP_POS                                      (24U)
-#define RGX_FEATURE_PM_MMU_VFP_BIT_MASK                                 (IMG_UINT64_C(0x0000000001000000))
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V2_POS             (24U)
+#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V2_BIT_MASK        (IMG_UINT64_C(0x0000000001000000))
 
-#define RGX_FEATURE_RISCV_FW_PROCESSOR_POS                              (25U)
-#define RGX_FEATURE_RISCV_FW_PROCESSOR_BIT_MASK                         (IMG_UINT64_C(0x0000000002000000))
+#define RGX_FEATURE_SINGLE_BIF_POS                                      (25U)
+#define RGX_FEATURE_SINGLE_BIF_BIT_MASK                                 (IMG_UINT64_C(0x0000000002000000))
 
-#define RGX_FEATURE_ROGUEXE_POS                                         (26U)
-#define RGX_FEATURE_ROGUEXE_BIT_MASK                                    (IMG_UINT64_C(0x0000000004000000))
+#define RGX_FEATURE_SLC_SIZE_CONFIGURABLE_POS                           (26U)
+#define RGX_FEATURE_SLC_SIZE_CONFIGURABLE_BIT_MASK                      (IMG_UINT64_C(0x0000000004000000))
 
-#define RGX_FEATURE_S7_CACHE_HIERARCHY_POS                              (27U)
-#define RGX_FEATURE_S7_CACHE_HIERARCHY_BIT_MASK                         (IMG_UINT64_C(0x0000000008000000))
+#define RGX_FEATURE_SOC_TIMER_POS                                       (27U)
+#define RGX_FEATURE_SOC_TIMER_BIT_MASK                                  (IMG_UINT64_C(0x0000000008000000))
 
-#define RGX_FEATURE_S7_TOP_INFRASTRUCTURE_POS                           (28U)
-#define RGX_FEATURE_S7_TOP_INFRASTRUCTURE_BIT_MASK                      (IMG_UINT64_C(0x0000000010000000))
+#define RGX_FEATURE_SYS_BUS_SECURE_RESET_POS                            (28U)
+#define RGX_FEATURE_SYS_BUS_SECURE_RESET_BIT_MASK                       (IMG_UINT64_C(0x0000000010000000))
 
-#define RGX_FEATURE_SCALABLE_VDM_GPP_POS                                (29U)
-#define RGX_FEATURE_SCALABLE_VDM_GPP_BIT_MASK                           (IMG_UINT64_C(0x0000000020000000))
+#define RGX_FEATURE_TDM_PDS_CHECKSUM_POS                                (29U)
+#define RGX_FEATURE_TDM_PDS_CHECKSUM_BIT_MASK                           (IMG_UINT64_C(0x0000000020000000))
 
-#define RGX_FEATURE_SIGNAL_SNOOPING_POS                                 (30U)
-#define RGX_FEATURE_SIGNAL_SNOOPING_BIT_MASK                            (IMG_UINT64_C(0x0000000040000000))
+#define RGX_FEATURE_TFBC_DELTA_CORRELATION_POS                          (30U)
+#define RGX_FEATURE_TFBC_DELTA_CORRELATION_BIT_MASK                     (IMG_UINT64_C(0x0000000040000000))
 
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_POS                (31U)
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_BIT_MASK           (IMG_UINT64_C(0x0000000080000000))
+#define RGX_FEATURE_TFBC_LOSSY_37_PERCENT_POS                           (31U)
+#define RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK                      (IMG_UINT64_C(0x0000000080000000))
 
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V1_POS             (32U)
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V1_BIT_MASK        (IMG_UINT64_C(0x0000000100000000))
+#define RGX_FEATURE_TFBC_NATIVE_YUV10_POS                               (32U)
+#define RGX_FEATURE_TFBC_NATIVE_YUV10_BIT_MASK                          (IMG_UINT64_C(0x0000000100000000))
 
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V2_POS             (33U)
-#define RGX_FEATURE_SIMPLE_INTERNAL_PARAMETER_FORMAT_V2_BIT_MASK        (IMG_UINT64_C(0x0000000200000000))
+#define RGX_FEATURE_TILE_REGION_PROTECTION_POS                          (33U)
+#define RGX_FEATURE_TILE_REGION_PROTECTION_BIT_MASK                     (IMG_UINT64_C(0x0000000200000000))
 
-#define RGX_FEATURE_SINGLE_BIF_POS                                      (34U)
-#define RGX_FEATURE_SINGLE_BIF_BIT_MASK                                 (IMG_UINT64_C(0x0000000400000000))
+#define RGX_FEATURE_TLA_POS                                             (34U)
+#define RGX_FEATURE_TLA_BIT_MASK                                        (IMG_UINT64_C(0x0000000400000000))
 
-#define RGX_FEATURE_SLC_HYBRID_CACHELINE_64_128_POS                     (35U)
-#define RGX_FEATURE_SLC_HYBRID_CACHELINE_64_128_BIT_MASK                (IMG_UINT64_C(0x0000000800000000))
+#define RGX_FEATURE_TPU_CEM_DATAMASTER_GLOBAL_REGISTERS_POS             (35U)
+#define RGX_FEATURE_TPU_CEM_DATAMASTER_GLOBAL_REGISTERS_BIT_MASK        (IMG_UINT64_C(0x0000000800000000))
 
-#define RGX_FEATURE_SLC_SIZE_CONFIGURABLE_POS                           (36U)
-#define RGX_FEATURE_SLC_SIZE_CONFIGURABLE_BIT_MASK                      (IMG_UINT64_C(0x0000001000000000))
+#define RGX_FEATURE_TPU_DM_GLOBAL_REGISTERS_POS                         (36U)
+#define RGX_FEATURE_TPU_DM_GLOBAL_REGISTERS_BIT_MASK                    (IMG_UINT64_C(0x0000001000000000))
 
-#define RGX_FEATURE_SLC_VIVT_POS                                        (37U)
-#define RGX_FEATURE_SLC_VIVT_BIT_MASK                                   (IMG_UINT64_C(0x0000002000000000))
+#define RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_POS                      (37U)
+#define RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_BIT_MASK                 (IMG_UINT64_C(0x0000002000000000))
 
-#define RGX_FEATURE_SOC_TIMER_POS                                       (38U)
-#define RGX_FEATURE_SOC_TIMER_BIT_MASK                                  (IMG_UINT64_C(0x0000004000000000))
+#define RGX_FEATURE_VOLCANIC_TB_POS                                     (38U)
+#define RGX_FEATURE_VOLCANIC_TB_BIT_MASK                                (IMG_UINT64_C(0x0000004000000000))
 
-#define RGX_FEATURE_SYS_BUS_SECURE_RESET_POS                            (39U)
-#define RGX_FEATURE_SYS_BUS_SECURE_RESET_BIT_MASK                       (IMG_UINT64_C(0x0000008000000000))
+#define RGX_FEATURE_WATCHDOG_TIMER_POS                                  (39U)
+#define RGX_FEATURE_WATCHDOG_TIMER_BIT_MASK                             (IMG_UINT64_C(0x0000008000000000))
 
-#define RGX_FEATURE_TDM_PDS_CHECKSUM_POS                                (40U)
-#define RGX_FEATURE_TDM_PDS_CHECKSUM_BIT_MASK                           (IMG_UINT64_C(0x0000010000000000))
+#define RGX_FEATURE_WORKGROUP_PROTECTION_POS                            (40U)
+#define RGX_FEATURE_WORKGROUP_PROTECTION_BIT_MASK                       (IMG_UINT64_C(0x0000010000000000))
 
-#define RGX_FEATURE_TESSELLATION_POS                                    (41U)
-#define RGX_FEATURE_TESSELLATION_BIT_MASK                               (IMG_UINT64_C(0x0000020000000000))
+#define RGX_FEATURE_XE_MEMORY_HIERARCHY_POS                             (41U)
+#define RGX_FEATURE_XE_MEMORY_HIERARCHY_BIT_MASK                        (IMG_UINT64_C(0x0000020000000000))
 
-#define RGX_FEATURE_TFBC_DELTA_CORRELATION_POS                          (42U)
-#define RGX_FEATURE_TFBC_DELTA_CORRELATION_BIT_MASK                     (IMG_UINT64_C(0x0000040000000000))
-
-#define RGX_FEATURE_TFBC_LOSSY_37_PERCENT_POS                           (43U)
-#define RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK                      (IMG_UINT64_C(0x0000080000000000))
-
-#define RGX_FEATURE_TFBC_NATIVE_YUV10_POS                               (44U)
-#define RGX_FEATURE_TFBC_NATIVE_YUV10_BIT_MASK                          (IMG_UINT64_C(0x0000100000000000))
-
-#define RGX_FEATURE_TILE_REGION_PROTECTION_POS                          (45U)
-#define RGX_FEATURE_TILE_REGION_PROTECTION_BIT_MASK                     (IMG_UINT64_C(0x0000200000000000))
-
-#define RGX_FEATURE_TLA_POS                                             (46U)
-#define RGX_FEATURE_TLA_BIT_MASK                                        (IMG_UINT64_C(0x0000400000000000))
-
-#define RGX_FEATURE_TPU_CEM_DATAMASTER_GLOBAL_REGISTERS_POS             (47U)
-#define RGX_FEATURE_TPU_CEM_DATAMASTER_GLOBAL_REGISTERS_BIT_MASK        (IMG_UINT64_C(0x0000800000000000))
-
-#define RGX_FEATURE_TPU_DM_GLOBAL_REGISTERS_POS                         (48U)
-#define RGX_FEATURE_TPU_DM_GLOBAL_REGISTERS_BIT_MASK                    (IMG_UINT64_C(0x0001000000000000))
-
-#define RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_POS                      (49U)
-#define RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_BIT_MASK                 (IMG_UINT64_C(0x0002000000000000))
-
-#define RGX_FEATURE_VDM_DRAWINDIRECT_POS                                (50U)
-#define RGX_FEATURE_VDM_DRAWINDIRECT_BIT_MASK                           (IMG_UINT64_C(0x0004000000000000))
-
-#define RGX_FEATURE_VDM_OBJECT_LEVEL_LLS_POS                            (51U)
-#define RGX_FEATURE_VDM_OBJECT_LEVEL_LLS_BIT_MASK                       (IMG_UINT64_C(0x0008000000000000))
-
-#define RGX_FEATURE_VOLCANIC_TB_POS                                     (52U)
-#define RGX_FEATURE_VOLCANIC_TB_BIT_MASK                                (IMG_UINT64_C(0x0010000000000000))
-
-#define RGX_FEATURE_WATCHDOG_TIMER_POS                                  (53U)
-#define RGX_FEATURE_WATCHDOG_TIMER_BIT_MASK                             (IMG_UINT64_C(0x0020000000000000))
-
-#define RGX_FEATURE_WORKGROUP_PROTECTION_POS                            (54U)
-#define RGX_FEATURE_WORKGROUP_PROTECTION_BIT_MASK                       (IMG_UINT64_C(0x0040000000000000))
-
-#define RGX_FEATURE_XE_MEMORY_HIERARCHY_POS                             (55U)
-#define RGX_FEATURE_XE_MEMORY_HIERARCHY_BIT_MASK                        (IMG_UINT64_C(0x0080000000000000))
-
-#define RGX_FEATURE_XT_TOP_INFRASTRUCTURE_POS                           (56U)
-#define RGX_FEATURE_XT_TOP_INFRASTRUCTURE_BIT_MASK                      (IMG_UINT64_C(0x0100000000000000))
+#define RGX_FEATURE_XT_TOP_INFRASTRUCTURE_POS                           (42U)
+#define RGX_FEATURE_XT_TOP_INFRASTRUCTURE_BIT_MASK                      (IMG_UINT64_C(0x0000040000000000))
 
 
 /******************************************************************************
@@ -240,38 +198,36 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * for handling the corresponding values
  *****************************************************************************/
 
-#define RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_MAX_VALUE_IDX             (3U)
+#define RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_MAX_VALUE_IDX             (2U)
 #define RGX_FEATURE_ECC_RAMS_MAX_VALUE_IDX                              (3U)
+#define RGX_FEATURE_FAULT_DECODE_VERSION_MAX_VALUE_IDX                  (2U)
 #define RGX_FEATURE_FBCDC_MAX_VALUE_IDX                                 (4U)
 #define RGX_FEATURE_FBCDC_ALGORITHM_MAX_VALUE_IDX                       (6U)
-#define RGX_FEATURE_FBCDC_ARCHITECTURE_MAX_VALUE_IDX                    (5U)
+#define RGX_FEATURE_FBCDC_ARCHITECTURE_MAX_VALUE_IDX                    (4U)
 #define RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_MAX_VALUE_IDX           (2U)
 #define RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_MAX_VALUE_IDX             (2U)
 #define RGX_FEATURE_LAYOUT_MARS_MAX_VALUE_IDX                           (3U)
-#define RGX_FEATURE_META_MAX_VALUE_IDX                                  (5U)
-#define RGX_FEATURE_META_COREMEM_BANKS_MAX_VALUE_IDX                    (2U)
-#define RGX_FEATURE_META_COREMEM_SIZE_MAX_VALUE_IDX                     (4U)
-#define RGX_FEATURE_META_DMA_CHANNEL_COUNT_MAX_VALUE_IDX                (2U)
+#define RGX_FEATURE_META_MAX_VALUE_IDX                                  (4U)
+#define RGX_FEATURE_META_COREMEM_SIZE_MAX_VALUE_IDX                     (3U)
 #define RGX_FEATURE_NUM_CLUSTERS_MAX_VALUE_IDX                          (5U)
 #define RGX_FEATURE_NUM_ISP_IPP_PIPES_MAX_VALUE_IDX                     (9U)
 #define RGX_FEATURE_NUM_MEMBUS_MAX_VALUE_IDX                            (2U)
 #define RGX_FEATURE_NUM_OSIDS_MAX_VALUE_IDX                             (3U)
-#define RGX_FEATURE_NUM_RASTER_PIPES_MAX_VALUE_IDX                      (4U)
+#define RGX_FEATURE_NUM_RASTER_PIPES_MAX_VALUE_IDX                      (3U)
 #define RGX_FEATURE_PHYS_BUS_WIDTH_MAX_VALUE_IDX                        (4U)
-#define RGX_FEATURE_SCALABLE_TE_ARCH_MAX_VALUE_IDX                      (2U)
-#define RGX_FEATURE_SCALABLE_VCE_MAX_VALUE_IDX                          (2U)
 #define RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_MAX_VALUE_IDX       (3U)
 #define RGX_FEATURE_SLC_BANKS_MAX_VALUE_IDX                             (4U)
 #define RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_MAX_VALUE_IDX              (2U)
-#define RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_MAX_VALUE_IDX                 (7U)
+#define RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_MAX_VALUE_IDX                 (6U)
+#define RGX_FEATURE_TB_GPU_COUNT_MAX_VALUE_IDX                          (2U)
 #define RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX                          (4U)
 #define RGX_FEATURE_TILE_SIZE_X_MAX_VALUE_IDX                           (3U)
 #define RGX_FEATURE_TILE_SIZE_Y_MAX_VALUE_IDX                           (3U)
 #define RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS_MAX_VALUE_IDX            (2U)
 #define RGX_FEATURE_XE_ARCHITECTURE_MAX_VALUE_IDX                       (2U)
 #define RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_MAX_VALUE_IDX           (2U)
-#define RGX_FEATURE_XPU_MAX_SLAVES_MAX_VALUE_IDX                        (3U)
-#define RGX_FEATURE_XPU_REGISTER_BROADCAST_MAX_VALUE_IDX                (3U)
+#define RGX_FEATURE_XPU_MAX_SLAVES_MAX_VALUE_IDX                        (2U)
+#define RGX_FEATURE_XPU_REGISTER_BROADCAST_MAX_VALUE_IDX                (2U)
 
 /******************************************************************************
  * Features with values indexes
@@ -280,6 +236,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 typedef enum _RGX_FEATURE_WITH_VALUE_INDEX_ {
 	RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_IDX,
 	RGX_FEATURE_ECC_RAMS_IDX,
+	RGX_FEATURE_FAULT_DECODE_VERSION_IDX,
 	RGX_FEATURE_FBCDC_IDX,
 	RGX_FEATURE_FBCDC_ALGORITHM_IDX,
 	RGX_FEATURE_FBCDC_ARCHITECTURE_IDX,
@@ -287,21 +244,18 @@ typedef enum _RGX_FEATURE_WITH_VALUE_INDEX_ {
 	RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_IDX,
 	RGX_FEATURE_LAYOUT_MARS_IDX,
 	RGX_FEATURE_META_IDX,
-	RGX_FEATURE_META_COREMEM_BANKS_IDX,
 	RGX_FEATURE_META_COREMEM_SIZE_IDX,
-	RGX_FEATURE_META_DMA_CHANNEL_COUNT_IDX,
 	RGX_FEATURE_NUM_CLUSTERS_IDX,
 	RGX_FEATURE_NUM_ISP_IPP_PIPES_IDX,
 	RGX_FEATURE_NUM_MEMBUS_IDX,
 	RGX_FEATURE_NUM_OSIDS_IDX,
 	RGX_FEATURE_NUM_RASTER_PIPES_IDX,
 	RGX_FEATURE_PHYS_BUS_WIDTH_IDX,
-	RGX_FEATURE_SCALABLE_TE_ARCH_IDX,
-	RGX_FEATURE_SCALABLE_VCE_IDX,
 	RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_IDX,
 	RGX_FEATURE_SLC_BANKS_IDX,
 	RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_IDX,
 	RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_IDX,
+	RGX_FEATURE_TB_GPU_COUNT_IDX,
 	RGX_FEATURE_TFBC_VERSION_IDX,
 	RGX_FEATURE_TILE_SIZE_X_IDX,
 	RGX_FEATURE_TILE_SIZE_Y_IDX,
@@ -330,59 +284,53 @@ typedef enum _RGX_FEATURE_WITH_VALUE_INDEX_ {
 #define HW_ERN_42606_POS                                                (3U)
 #define HW_ERN_42606_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000008))
 
-#define HW_ERN_46066_POS                                                (4U)
-#define HW_ERN_46066_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000010))
-
-#define HW_ERN_47025_POS                                                (5U)
-#define HW_ERN_47025_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000020))
-
-#define HW_ERN_50539_POS                                                (6U)
-#define HW_ERN_50539_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000040))
+#define HW_ERN_47025_POS                                                (4U)
+#define HW_ERN_47025_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000010))
 
-#define FIX_HW_BRN_50767_POS                                            (7U)
-#define FIX_HW_BRN_50767_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000080))
+#define FIX_HW_BRN_50767_POS                                            (5U)
+#define FIX_HW_BRN_50767_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000020))
 
-#define HW_ERN_57596_POS                                                (8U)
-#define HW_ERN_57596_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000100))
+#define HW_ERN_57596_POS                                                (6U)
+#define HW_ERN_57596_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000040))
 
-#define FIX_HW_BRN_60084_POS                                            (9U)
-#define FIX_HW_BRN_60084_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000200))
+#define FIX_HW_BRN_60084_POS                                            (7U)
+#define FIX_HW_BRN_60084_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000080))
 
-#define HW_ERN_61389_POS                                                (10U)
-#define HW_ERN_61389_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000400))
+#define HW_ERN_61389_POS                                                (8U)
+#define HW_ERN_61389_BIT_MASK                                           (IMG_UINT64_C(0x0000000000000100))
 
-#define FIX_HW_BRN_61450_POS                                            (11U)
-#define FIX_HW_BRN_61450_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000800))
+#define FIX_HW_BRN_61450_POS                                            (9U)
+#define FIX_HW_BRN_61450_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000200))
 
-#define FIX_HW_BRN_63142_POS                                            (12U)
-#define FIX_HW_BRN_63142_BIT_MASK                                       (IMG_UINT64_C(0x0000000000001000))
+#define FIX_HW_BRN_63142_POS                                            (10U)
+#define FIX_HW_BRN_63142_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000400))
 
-#define FIX_HW_BRN_63553_POS                                            (13U)
-#define FIX_HW_BRN_63553_BIT_MASK                                       (IMG_UINT64_C(0x0000000000002000))
+#define FIX_HW_BRN_63553_POS                                            (11U)
+#define FIX_HW_BRN_63553_BIT_MASK                                       (IMG_UINT64_C(0x0000000000000800))
 
-#define FIX_HW_BRN_64502_POS                                            (14U)
-#define FIX_HW_BRN_64502_BIT_MASK                                       (IMG_UINT64_C(0x0000000000004000))
+#define FIX_HW_BRN_64502_POS                                            (12U)
+#define FIX_HW_BRN_64502_BIT_MASK                                       (IMG_UINT64_C(0x0000000000001000))
 
-#define FIX_HW_BRN_65101_POS                                            (15U)
-#define FIX_HW_BRN_65101_BIT_MASK                                       (IMG_UINT64_C(0x0000000000008000))
+#define FIX_HW_BRN_65101_POS                                            (13U)
+#define FIX_HW_BRN_65101_BIT_MASK                                       (IMG_UINT64_C(0x0000000000002000))
 
-#define FIX_HW_BRN_65273_POS                                            (16U)
-#define FIX_HW_BRN_65273_BIT_MASK                                       (IMG_UINT64_C(0x0000000000010000))
+#define FIX_HW_BRN_65273_POS                                            (14U)
+#define FIX_HW_BRN_65273_BIT_MASK                                       (IMG_UINT64_C(0x0000000000004000))
 
-#define HW_ERN_66622_POS                                                (17U)
-#define HW_ERN_66622_BIT_MASK                                           (IMG_UINT64_C(0x0000000000020000))
+#define HW_ERN_66622_POS                                                (15U)
+#define HW_ERN_66622_BIT_MASK                                           (IMG_UINT64_C(0x0000000000008000))
 
-#define FIX_HW_BRN_66927_POS                                            (18U)
-#define FIX_HW_BRN_66927_BIT_MASK                                       (IMG_UINT64_C(0x0000000000040000))
+#define FIX_HW_BRN_66927_POS                                            (16U)
+#define FIX_HW_BRN_66927_BIT_MASK                                       (IMG_UINT64_C(0x0000000000010000))
 
-#define FIX_HW_BRN_68186_POS                                            (19U)
-#define FIX_HW_BRN_68186_BIT_MASK                                       (IMG_UINT64_C(0x0000000000080000))
+#define FIX_HW_BRN_68186_POS                                            (17U)
+#define FIX_HW_BRN_68186_BIT_MASK                                       (IMG_UINT64_C(0x0000000000020000))
 
-#define FIX_HW_BRN_71317_POS                                            (20U)
-#define FIX_HW_BRN_71317_BIT_MASK                                       (IMG_UINT64_C(0x0000000000100000))
+#define FIX_HW_BRN_71242_POS                                            (18U)
+#define FIX_HW_BRN_71242_BIT_MASK                                       (IMG_UINT64_C(0x0000000000040000))
 
-#define FIX_HW_BRN_73472_POS                                            (21U)
-#define FIX_HW_BRN_73472_BIT_MASK                                       (IMG_UINT64_C(0x0000000000200000))
+#define FIX_HW_BRN_71317_POS                                            (19U)
+#define FIX_HW_BRN_71317_BIT_MASK                                       (IMG_UINT64_C(0x0000000000080000))
 
 /* Macro used for padding the unavailable values for features with values */
 #define RGX_FEATURE_VALUE_INVALID	(0xFFFFFFFEU)
diff --git a/drivers/gpu/drm/img-rogue/km/rgx_bvnc_table_km.h b/drivers/gpu/drm/img-rogue/km/rgx_bvnc_table_km.h
index ada0efbf0bca..d10a0a1ab22d 100644
--- a/drivers/gpu/drm/img-rogue/km/rgx_bvnc_table_km.h
+++ b/drivers/gpu/drm/img-rogue/km/rgx_bvnc_table_km.h
@@ -66,15 +66,17 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * for handling the corresponding values
  *****************************************************************************/
 
-static const IMG_UINT16 aui16_RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_values[RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, };
+static const IMG_UINT16 aui16_RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_values[RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_ECC_RAMS_values[RGX_FEATURE_ECC_RAMS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 2, };
 
+static const IMG_UINT16 aui16_RGX_FEATURE_FAULT_DECODE_VERSION_values[RGX_FEATURE_FAULT_DECODE_VERSION_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, };
+
 static const IMG_UINT16 aui16_RGX_FEATURE_FBCDC_values[RGX_FEATURE_FBCDC_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 3, 4, 50, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_FBCDC_ALGORITHM_values[RGX_FEATURE_FBCDC_ALGORITHM_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, 3, 4, 50, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_FBCDC_ARCHITECTURE_values[RGX_FEATURE_FBCDC_ARCHITECTURE_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, 3, 7, };
+static const IMG_UINT16 aui16_RGX_FEATURE_FBCDC_ARCHITECTURE_values[RGX_FEATURE_FBCDC_ARCHITECTURE_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, 7, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_values[RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, };
 
@@ -82,13 +84,9 @@ static const IMG_UINT16 aui16_RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_values[RGX_F
 
 static const IMG_UINT16 aui16_RGX_FEATURE_LAYOUT_MARS_values[RGX_FEATURE_LAYOUT_MARS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 1, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_META_values[RGX_FEATURE_META_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, LTP217, LTP218, MTP218, MTP219, };
-
-static const IMG_UINT16 aui16_RGX_FEATURE_META_COREMEM_BANKS_values[RGX_FEATURE_META_COREMEM_BANKS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 8, };
-
-static const IMG_UINT16 aui16_RGX_FEATURE_META_COREMEM_SIZE_values[RGX_FEATURE_META_COREMEM_SIZE_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 32, 256, };
+static const IMG_UINT16 aui16_RGX_FEATURE_META_values[RGX_FEATURE_META_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, LTP217, LTP218, MTP218, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_META_DMA_CHANNEL_COUNT_values[RGX_FEATURE_META_DMA_CHANNEL_COUNT_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 4, };
+static const IMG_UINT16 aui16_RGX_FEATURE_META_COREMEM_SIZE_values[RGX_FEATURE_META_COREMEM_SIZE_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 32, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_NUM_CLUSTERS_values[RGX_FEATURE_NUM_CLUSTERS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, 4, 6, };
 
@@ -98,21 +96,19 @@ static const IMG_UINT16 aui16_RGX_FEATURE_NUM_MEMBUS_values[RGX_FEATURE_NUM_MEMB
 
 static const IMG_UINT16 aui16_RGX_FEATURE_NUM_OSIDS_values[RGX_FEATURE_NUM_OSIDS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 2, 8, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_NUM_RASTER_PIPES_values[RGX_FEATURE_NUM_RASTER_PIPES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 1, 2, };
+static const IMG_UINT16 aui16_RGX_FEATURE_NUM_RASTER_PIPES_values[RGX_FEATURE_NUM_RASTER_PIPES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_PHYS_BUS_WIDTH_values[RGX_FEATURE_PHYS_BUS_WIDTH_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 32, 36, 40, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_SCALABLE_TE_ARCH_values[RGX_FEATURE_SCALABLE_TE_ARCH_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, };
-
-static const IMG_UINT16 aui16_RGX_FEATURE_SCALABLE_VCE_values[RGX_FEATURE_SCALABLE_VCE_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, };
-
 static const IMG_UINT16 aui16_RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_values[RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_SLC_BANKS_values[RGX_FEATURE_SLC_BANKS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, 2, 4, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_values[RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 512, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_values[RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 2, 8, 16, 64, 128, 512, };
+static const IMG_UINT16 aui16_RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_values[RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 2, 8, 16, 64, 128, };
+
+static const IMG_UINT16 aui16_RGX_FEATURE_TB_GPU_COUNT_values[RGX_FEATURE_TB_GPU_COUNT_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, };
 
 static const IMG_UINT16 aui16_RGX_FEATURE_TFBC_VERSION_values[RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 10, 11, 20, };
 
@@ -126,9 +122,9 @@ static const IMG_UINT16 aui16_RGX_FEATURE_XE_ARCHITECTURE_values[RGX_FEATURE_XE_
 
 static const IMG_UINT16 aui16_RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_values[RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 19, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_XPU_MAX_SLAVES_values[RGX_FEATURE_XPU_MAX_SLAVES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 2, 3, };
+static const IMG_UINT16 aui16_RGX_FEATURE_XPU_MAX_SLAVES_values[RGX_FEATURE_XPU_MAX_SLAVES_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 3, };
 
-static const IMG_UINT16 aui16_RGX_FEATURE_XPU_REGISTER_BROADCAST_values[RGX_FEATURE_XPU_REGISTER_BROADCAST_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 0, 1, };
+static const IMG_UINT16 aui16_RGX_FEATURE_XPU_REGISTER_BROADCAST_values[RGX_FEATURE_XPU_REGISTER_BROADCAST_MAX_VALUE_IDX] = {(IMG_UINT16)RGX_FEATURE_VALUE_DISABLED, 1, };
 
 
 /******************************************************************************
@@ -140,6 +136,7 @@ static const IMG_UINT16 aui16_RGX_FEATURE_XPU_REGISTER_BROADCAST_values[RGX_FEAT
 static const void * const gaFeaturesValues[RGX_FEATURE_WITH_VALUES_MAX_IDX] = {
 	aui16_RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_values,
 	aui16_RGX_FEATURE_ECC_RAMS_values,
+	aui16_RGX_FEATURE_FAULT_DECODE_VERSION_values,
 	aui16_RGX_FEATURE_FBCDC_values,
 	aui16_RGX_FEATURE_FBCDC_ALGORITHM_values,
 	aui16_RGX_FEATURE_FBCDC_ARCHITECTURE_values,
@@ -147,21 +144,18 @@ static const void * const gaFeaturesValues[RGX_FEATURE_WITH_VALUES_MAX_IDX] = {
 	aui16_RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_values,
 	aui16_RGX_FEATURE_LAYOUT_MARS_values,
 	aui16_RGX_FEATURE_META_values,
-	aui16_RGX_FEATURE_META_COREMEM_BANKS_values,
 	aui16_RGX_FEATURE_META_COREMEM_SIZE_values,
-	aui16_RGX_FEATURE_META_DMA_CHANNEL_COUNT_values,
 	aui16_RGX_FEATURE_NUM_CLUSTERS_values,
 	aui16_RGX_FEATURE_NUM_ISP_IPP_PIPES_values,
 	aui16_RGX_FEATURE_NUM_MEMBUS_values,
 	aui16_RGX_FEATURE_NUM_OSIDS_values,
 	aui16_RGX_FEATURE_NUM_RASTER_PIPES_values,
 	aui16_RGX_FEATURE_PHYS_BUS_WIDTH_values,
-	aui16_RGX_FEATURE_SCALABLE_TE_ARCH_values,
-	aui16_RGX_FEATURE_SCALABLE_VCE_values,
 	aui16_RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_values,
 	aui16_RGX_FEATURE_SLC_BANKS_values,
 	aui16_RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_values,
 	aui16_RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_values,
+	aui16_RGX_FEATURE_TB_GPU_COUNT_values,
 	aui16_RGX_FEATURE_TFBC_VERSION_values,
 	aui16_RGX_FEATURE_TILE_SIZE_X_values,
 	aui16_RGX_FEATURE_TILE_SIZE_Y_values,
@@ -182,6 +176,7 @@ static const void * const gaFeaturesValues[RGX_FEATURE_WITH_VALUES_MAX_IDX] = {
 static const IMG_UINT16 gaFeaturesValuesMaxIndexes[] = {
 	RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_MAX_VALUE_IDX,
 	RGX_FEATURE_ECC_RAMS_MAX_VALUE_IDX,
+	RGX_FEATURE_FAULT_DECODE_VERSION_MAX_VALUE_IDX,
 	RGX_FEATURE_FBCDC_MAX_VALUE_IDX,
 	RGX_FEATURE_FBCDC_ALGORITHM_MAX_VALUE_IDX,
 	RGX_FEATURE_FBCDC_ARCHITECTURE_MAX_VALUE_IDX,
@@ -189,21 +184,18 @@ static const IMG_UINT16 gaFeaturesValuesMaxIndexes[] = {
 	RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_MAX_VALUE_IDX,
 	RGX_FEATURE_LAYOUT_MARS_MAX_VALUE_IDX,
 	RGX_FEATURE_META_MAX_VALUE_IDX,
-	RGX_FEATURE_META_COREMEM_BANKS_MAX_VALUE_IDX,
 	RGX_FEATURE_META_COREMEM_SIZE_MAX_VALUE_IDX,
-	RGX_FEATURE_META_DMA_CHANNEL_COUNT_MAX_VALUE_IDX,
 	RGX_FEATURE_NUM_CLUSTERS_MAX_VALUE_IDX,
 	RGX_FEATURE_NUM_ISP_IPP_PIPES_MAX_VALUE_IDX,
 	RGX_FEATURE_NUM_MEMBUS_MAX_VALUE_IDX,
 	RGX_FEATURE_NUM_OSIDS_MAX_VALUE_IDX,
 	RGX_FEATURE_NUM_RASTER_PIPES_MAX_VALUE_IDX,
 	RGX_FEATURE_PHYS_BUS_WIDTH_MAX_VALUE_IDX,
-	RGX_FEATURE_SCALABLE_TE_ARCH_MAX_VALUE_IDX,
-	RGX_FEATURE_SCALABLE_VCE_MAX_VALUE_IDX,
 	RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_MAX_VALUE_IDX,
 	RGX_FEATURE_SLC_BANKS_MAX_VALUE_IDX,
 	RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_MAX_VALUE_IDX,
 	RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_MAX_VALUE_IDX,
+	RGX_FEATURE_TB_GPU_COUNT_MAX_VALUE_IDX,
 	RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX,
 	RGX_FEATURE_TILE_SIZE_X_MAX_VALUE_IDX,
 	RGX_FEATURE_TILE_SIZE_Y_MAX_VALUE_IDX,
@@ -225,36 +217,34 @@ static const IMG_UINT16 gaFeaturesValuesMaxIndexes[] = {
 static const IMG_UINT16 aui16FeaturesWithValuesBitPositions[] = {
 	(0U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_POS */
 	(2U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_ECC_RAMS_POS */
-	(4U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_POS */
-	(7U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_ALGORITHM_POS */
-	(10U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_ARCHITECTURE_POS */
-	(13U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_POS */
-	(15U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_POS */
-	(17U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_LAYOUT_MARS_POS */
-	(19U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_META_POS */
-	(22U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_META_COREMEM_BANKS_POS */
+	(4U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FAULT_DECODE_VERSION_POS */
+	(6U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_POS */
+	(9U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_ALGORITHM_POS */
+	(12U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBCDC_ARCHITECTURE_POS */
+	(15U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_POS */
+	(17U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_POS */
+	(19U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_LAYOUT_MARS_POS */
+	(21U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_META_POS */
 	(24U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_META_COREMEM_SIZE_POS */
-	(27U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_META_DMA_CHANNEL_COUNT_POS */
-	(29U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_CLUSTERS_POS */
-	(32U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_ISP_IPP_PIPES_POS */
-	(36U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_MEMBUS_POS */
-	(38U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_OSIDS_POS */
-	(40U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_RASTER_PIPES_POS */
-	(43U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_PHYS_BUS_WIDTH_POS */
-	(46U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SCALABLE_TE_ARCH_POS */
-	(48U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SCALABLE_VCE_POS */
-	(50U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_POS */
-	(52U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_BANKS_POS */
-	(55U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_POS */
-	(57U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_POS */
-	(60U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TFBC_VERSION_POS */
-	(64U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TILE_SIZE_X_POS */
-	(66U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TILE_SIZE_Y_POS */
-	(68U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS_POS */
-	(70U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XE_ARCHITECTURE_POS */
-	(72U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_POS */
-	(74U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_MAX_SLAVES_POS */
-	(76U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_REGISTER_BROADCAST_POS */
+	(26U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_CLUSTERS_POS */
+	(29U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_ISP_IPP_PIPES_POS */
+	(33U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_MEMBUS_POS */
+	(35U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_OSIDS_POS */
+	(37U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_NUM_RASTER_PIPES_POS */
+	(39U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_PHYS_BUS_WIDTH_POS */
+	(42U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_POS */
+	(44U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_BANKS_POS */
+	(47U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_POS */
+	(49U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_POS */
+	(52U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TB_GPU_COUNT_POS */
+	(54U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TFBC_VERSION_POS */
+	(57U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TILE_SIZE_X_POS */
+	(59U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_TILE_SIZE_Y_POS */
+	(61U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS_POS */
+	(64U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XE_ARCHITECTURE_POS */
+	(66U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_POS */
+	(68U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_MAX_SLAVES_POS */
+	(70U) | RGX_FEATURE_VALUE_TYPE_UINT16, /* RGX_FEATURE_XPU_REGISTER_BROADCAST_POS */
 };
 
 
@@ -265,36 +255,34 @@ static const IMG_UINT16 aui16FeaturesWithValuesBitPositions[] = {
 static const IMG_UINT64 aui64FeaturesWithValuesBitMasks[] = {
 	(IMG_UINT64_C(0x0000000000000003)), /* RGX_FEATURE_CDM_CONTROL_STREAM_FORMAT_BIT_MASK */
 	(IMG_UINT64_C(0x000000000000000C)), /* RGX_FEATURE_ECC_RAMS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000070)), /* RGX_FEATURE_FBCDC_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000380)), /* RGX_FEATURE_FBCDC_ALGORITHM_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000001C00)), /* RGX_FEATURE_FBCDC_ARCHITECTURE_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000006000)), /* RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000018000)), /* RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000060000)), /* RGX_FEATURE_LAYOUT_MARS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000380000)), /* RGX_FEATURE_META_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000C00000)), /* RGX_FEATURE_META_COREMEM_BANKS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000007000000)), /* RGX_FEATURE_META_COREMEM_SIZE_BIT_MASK */
-	(IMG_UINT64_C(0x0000000018000000)), /* RGX_FEATURE_META_DMA_CHANNEL_COUNT_BIT_MASK */
-	(IMG_UINT64_C(0x00000000E0000000)), /* RGX_FEATURE_NUM_CLUSTERS_BIT_MASK */
-	(IMG_UINT64_C(0x0000000F00000000)), /* RGX_FEATURE_NUM_ISP_IPP_PIPES_BIT_MASK */
-	(IMG_UINT64_C(0x0000003000000000)), /* RGX_FEATURE_NUM_MEMBUS_BIT_MASK */
-	(IMG_UINT64_C(0x000000C000000000)), /* RGX_FEATURE_NUM_OSIDS_BIT_MASK */
-	(IMG_UINT64_C(0x0000070000000000)), /* RGX_FEATURE_NUM_RASTER_PIPES_BIT_MASK */
-	(IMG_UINT64_C(0x0000380000000000)), /* RGX_FEATURE_PHYS_BUS_WIDTH_BIT_MASK */
-	(IMG_UINT64_C(0x0000C00000000000)), /* RGX_FEATURE_SCALABLE_TE_ARCH_BIT_MASK */
-	(IMG_UINT64_C(0x0003000000000000)), /* RGX_FEATURE_SCALABLE_VCE_BIT_MASK */
-	(IMG_UINT64_C(0x000C000000000000)), /* RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_BIT_MASK */
-	(IMG_UINT64_C(0x0070000000000000)), /* RGX_FEATURE_SLC_BANKS_BIT_MASK */
-	(IMG_UINT64_C(0x0180000000000000)), /* RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_BIT_MASK */
-	(IMG_UINT64_C(0x0E00000000000000)), /* RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_BIT_MASK */
-	(IMG_UINT64_C(0x7000000000000000)), /* RGX_FEATURE_TFBC_VERSION_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000003)), /* RGX_FEATURE_TILE_SIZE_X_BIT_MASK */
-	(IMG_UINT64_C(0x000000000000000C)), /* RGX_FEATURE_TILE_SIZE_Y_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000030)), /* RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS_BIT_MASK */
-	(IMG_UINT64_C(0x00000000000000C0)), /* RGX_FEATURE_XE_ARCHITECTURE_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000300)), /* RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000000C00)), /* RGX_FEATURE_XPU_MAX_SLAVES_BIT_MASK */
-	(IMG_UINT64_C(0x0000000000003000)), /* RGX_FEATURE_XPU_REGISTER_BROADCAST_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000000030)), /* RGX_FEATURE_FAULT_DECODE_VERSION_BIT_MASK */
+	(IMG_UINT64_C(0x00000000000001C0)), /* RGX_FEATURE_FBCDC_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000000E00)), /* RGX_FEATURE_FBCDC_ALGORITHM_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000007000)), /* RGX_FEATURE_FBCDC_ARCHITECTURE_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000018000)), /* RGX_FEATURE_FBC_MAX_DEFAULT_DESCRIPTORS_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000060000)), /* RGX_FEATURE_FBC_MAX_LARGE_DESCRIPTORS_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000180000)), /* RGX_FEATURE_LAYOUT_MARS_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000E00000)), /* RGX_FEATURE_META_BIT_MASK */
+	(IMG_UINT64_C(0x0000000003000000)), /* RGX_FEATURE_META_COREMEM_SIZE_BIT_MASK */
+	(IMG_UINT64_C(0x000000001C000000)), /* RGX_FEATURE_NUM_CLUSTERS_BIT_MASK */
+	(IMG_UINT64_C(0x00000001E0000000)), /* RGX_FEATURE_NUM_ISP_IPP_PIPES_BIT_MASK */
+	(IMG_UINT64_C(0x0000000600000000)), /* RGX_FEATURE_NUM_MEMBUS_BIT_MASK */
+	(IMG_UINT64_C(0x0000001800000000)), /* RGX_FEATURE_NUM_OSIDS_BIT_MASK */
+	(IMG_UINT64_C(0x0000006000000000)), /* RGX_FEATURE_NUM_RASTER_PIPES_BIT_MASK */
+	(IMG_UINT64_C(0x0000038000000000)), /* RGX_FEATURE_PHYS_BUS_WIDTH_BIT_MASK */
+	(IMG_UINT64_C(0x00000C0000000000)), /* RGX_FEATURE_SIMPLE_PARAMETER_FORMAT_VERSION_BIT_MASK */
+	(IMG_UINT64_C(0x0000700000000000)), /* RGX_FEATURE_SLC_BANKS_BIT_MASK */
+	(IMG_UINT64_C(0x0001800000000000)), /* RGX_FEATURE_SLC_CACHE_LINE_SIZE_BITS_BIT_MASK */
+	(IMG_UINT64_C(0x000E000000000000)), /* RGX_FEATURE_SLC_SIZE_IN_KILOBYTES_BIT_MASK */
+	(IMG_UINT64_C(0x0030000000000000)), /* RGX_FEATURE_TB_GPU_COUNT_BIT_MASK */
+	(IMG_UINT64_C(0x01C0000000000000)), /* RGX_FEATURE_TFBC_VERSION_BIT_MASK */
+	(IMG_UINT64_C(0x0600000000000000)), /* RGX_FEATURE_TILE_SIZE_X_BIT_MASK */
+	(IMG_UINT64_C(0x1800000000000000)), /* RGX_FEATURE_TILE_SIZE_Y_BIT_MASK */
+	(IMG_UINT64_C(0x6000000000000000)), /* RGX_FEATURE_VIRTUAL_ADDRESS_SPACE_BITS_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000000003)), /* RGX_FEATURE_XE_ARCHITECTURE_BIT_MASK */
+	(IMG_UINT64_C(0x000000000000000C)), /* RGX_FEATURE_XPU_MAX_REGBANKS_ADDR_WIDTH_BIT_MASK */
+	(IMG_UINT64_C(0x0000000000000030)), /* RGX_FEATURE_XPU_MAX_SLAVES_BIT_MASK */
+	(IMG_UINT64_C(0x00000000000000C0)), /* RGX_FEATURE_XPU_REGISTER_BROADCAST_BIT_MASK */
 };
 
 
@@ -305,41 +293,41 @@ static const IMG_UINT64 aui64FeaturesWithValuesBitMasks[] = {
 
 static const IMG_UINT64 gaFeatures[][4]=
 {
-	{ IMG_UINT64_C(0x000100000002001e), IMG_UINT64_C(0x0000400000402025), IMG_UINT64_C(0x0a801a03411aa481), IMG_UINT64_C(0x000000000000001a) },	/* 1.0.2.30 */
-	{ IMG_UINT64_C(0x0001000000040005), IMG_UINT64_C(0x0000400000402024), IMG_UINT64_C(0x0a801a03611aa481), IMG_UINT64_C(0x000000000000001a) },	/* 1.0.4.5 */
-	{ IMG_UINT64_C(0x0001000000040013), IMG_UINT64_C(0x0000400000402025), IMG_UINT64_C(0x0a801a03611aa481), IMG_UINT64_C(0x000000000000001a) },	/* 1.0.4.19 */
-	{ IMG_UINT64_C(0x0004000000020033), IMG_UINT64_C(0x0102c04000c0222f), IMG_UINT64_C(0x0a801a074212a901), IMG_UINT64_C(0x000000000000001a) },	/* 4.0.2.51 */
-	{ IMG_UINT64_C(0x000400000002003a), IMG_UINT64_C(0x0102c04000c0322f), IMG_UINT64_C(0x0a801a874212a901), IMG_UINT64_C(0x000000000000001a) },	/* 4.0.2.58 */
-	{ IMG_UINT64_C(0x0004000000040037), IMG_UINT64_C(0x0102c04000c0222e), IMG_UINT64_C(0x0a801a076212a901), IMG_UINT64_C(0x000000000000001a) },	/* 4.0.4.55 */
-	{ IMG_UINT64_C(0x000400000006003e), IMG_UINT64_C(0x0102c04000c0322f), IMG_UINT64_C(0x0ab01b878212a901), IMG_UINT64_C(0x000000000000001a) },	/* 4.0.6.62 */
-	{ IMG_UINT64_C(0x000500000001002e), IMG_UINT64_C(0x0000004004402205), IMG_UINT64_C(0x06901a01210aa501), IMG_UINT64_C(0x000000000000005a) },	/* 5.0.1.46 */
-	{ IMG_UINT64_C(0x0006000000040023), IMG_UINT64_C(0x0102c04000c0222f), IMG_UINT64_C(0x0a801a076212a901), IMG_UINT64_C(0x000000000000001a) },	/* 6.0.4.35 */
-	{ IMG_UINT64_C(0x000f000000010040), IMG_UINT64_C(0x0000004004403205), IMG_UINT64_C(0x08901a82210aa501), IMG_UINT64_C(0x000000000000005a) },	/* 15.0.1.64 */
-	{ IMG_UINT64_C(0x0016000000150010), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x04940a8220020001), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.21.16 */
-	{ IMG_UINT64_C(0x0016000000360019), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x08940a8320020001), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.54.25 */
-	{ IMG_UINT64_C(0x001600000036001e), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x08940a8420020001), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.54.30 */
-	{ IMG_UINT64_C(0x0016000000360026), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x0894128420020001), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.54.38 */
-	{ IMG_UINT64_C(0x001600000036014a), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x08940a842002a591), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.54.330 */
-	{ IMG_UINT64_C(0x0016000000680012), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x0894128620020001), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.104.18 */
-	{ IMG_UINT64_C(0x00160000006800da), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x089412862002a591), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.104.218 */
-	{ IMG_UINT64_C(0x0016000000d0013e), IMG_UINT64_C(0x000000c5844b3025), IMG_UINT64_C(0x08a413884002a591), IMG_UINT64_C(0x0000000000000055) },	/* 22.0.208.318 */
-	{ IMG_UINT64_C(0x00180000003600cc), IMG_UINT64_C(0x008001c2844f7425), IMG_UINT64_C(0x089812842002a591), IMG_UINT64_C(0x0000000000000055) },	/* 24.0.54.204 */
-	{ IMG_UINT64_C(0x00180000006801f8), IMG_UINT64_C(0x008001c2844f7425), IMG_UINT64_C(0x089812852002a591), IMG_UINT64_C(0x0000000000000055) },	/* 24.0.104.504 */
-	{ IMG_UINT64_C(0x0018000000d001f8), IMG_UINT64_C(0x008001c2844f7425), IMG_UINT64_C(0x0aa813884002a591), IMG_UINT64_C(0x0000000000000055) },	/* 24.0.208.504 */
-	{ IMG_UINT64_C(0x0018000000d001f9), IMG_UINT64_C(0x008001c2844f7425), IMG_UINT64_C(0x0aa813884002a591), IMG_UINT64_C(0x0000000000000055) },	/* 24.0.208.505 */
-	{ IMG_UINT64_C(0x001d0000003400ca), IMG_UINT64_C(0x008181c2844f74a5), IMG_UINT64_C(0x069812822002a621), IMG_UINT64_C(0x0000000000000055) },	/* 29.0.52.202 */
-	{ IMG_UINT64_C(0x001d0000006c00d0), IMG_UINT64_C(0x008181c2844f74a5), IMG_UINT64_C(0x0aa813874002a621), IMG_UINT64_C(0x0000000000000055) },	/* 29.0.108.208 */
-	{ IMG_UINT64_C(0x00210000000b0003), IMG_UINT64_C(0x00800092844b5085), IMG_UINT64_C(0x0298124120020001), IMG_UINT64_C(0x0000000000000055) },	/* 33.0.11.3 */
-	{ IMG_UINT64_C(0x0021000000160001), IMG_UINT64_C(0x008180c2854b70a5), IMG_UINT64_C(0x0698128220020001), IMG_UINT64_C(0x0000000000000055) },	/* 33.0.22.1 */
-	{ IMG_UINT64_C(0x00240000003400b6), IMG_UINT64_C(0x008000d2844b78a5), IMG_UINT64_C(0x169812822004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.52.182 */
-	{ IMG_UINT64_C(0x0024000000360067), IMG_UINT64_C(0x008180d2844b38a5), IMG_UINT64_C(0x169812842002b2b1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.54.103 */
-	{ IMG_UINT64_C(0x00240000003600b6), IMG_UINT64_C(0x008180d2844b78a5), IMG_UINT64_C(0x169812842004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.54.182 */
-	{ IMG_UINT64_C(0x00240000003600b7), IMG_UINT64_C(0x008180d2844b78a5), IMG_UINT64_C(0x169812842004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.54.183 */
-	{ IMG_UINT64_C(0x0024000000360118), IMG_UINT64_C(0x00819cd2844b78a5), IMG_UINT64_C(0x269812842004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.54.280 */
-	{ IMG_UINT64_C(0x00240000006800b6), IMG_UINT64_C(0x008180d2844b78a5), IMG_UINT64_C(0x169812852004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.104.182 */
-	{ IMG_UINT64_C(0x00240000006800b7), IMG_UINT64_C(0x008180d2844b78a5), IMG_UINT64_C(0x169812852004b2b1), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.104.183 */
-	{ IMG_UINT64_C(0x002400000068031c), IMG_UINT64_C(0x00e1a0d2864a78a5), IMG_UINT64_C(0x169812852004b2b9), IMG_UINT64_C(0x0000000000002955) },	/* 36.0.104.796 */
-	{ IMG_UINT64_C(0x002e000000660185), IMG_UINT64_C(0x00901cd2844b78a5), IMG_UINT64_C(0x389812922004b2b5), IMG_UINT64_C(0x0000000000002955) },	/* 46.0.102.389 */
+	{ IMG_UINT64_C(0x0001000000040005), IMG_UINT64_C(0x0000000400010414), IMG_UINT64_C(0x340a81a06d6a9211), IMG_UINT64_C(0x0000000000000000) },	/* 1.0.4.5 */
+	{ IMG_UINT64_C(0x0001000000040013), IMG_UINT64_C(0x0000000400010415), IMG_UINT64_C(0x340a81a06d6a9211), IMG_UINT64_C(0x0000000000000000) },	/* 1.0.4.19 */
+	{ IMG_UINT64_C(0x0004000000020033), IMG_UINT64_C(0x0000042c0803045f), IMG_UINT64_C(0x340a81a0ea4aa411), IMG_UINT64_C(0x0000000000000000) },	/* 4.0.2.51 */
+	{ IMG_UINT64_C(0x000400000002003a), IMG_UINT64_C(0x0000042c0803065f), IMG_UINT64_C(0x340a81b0ea4aa411), IMG_UINT64_C(0x0000000000000000) },	/* 4.0.2.58 */
+	{ IMG_UINT64_C(0x0004000000040037), IMG_UINT64_C(0x0000042c0803045e), IMG_UINT64_C(0x340a81a0ee4aa411), IMG_UINT64_C(0x0000000000000000) },	/* 4.0.4.55 */
+	{ IMG_UINT64_C(0x000400000006003e), IMG_UINT64_C(0x0000042c0803065f), IMG_UINT64_C(0x340ab1d0f24aa411), IMG_UINT64_C(0x0000000000000000) },	/* 4.0.6.62 */
+	{ IMG_UINT64_C(0x000500000001002e), IMG_UINT64_C(0x0000000008110445), IMG_UINT64_C(0x340691a0252a9411), IMG_UINT64_C(0x0000000000000001) },	/* 5.0.1.46 */
+	{ IMG_UINT64_C(0x0006000000040023), IMG_UINT64_C(0x0000042c0803045f), IMG_UINT64_C(0x340a81a0ee4aa411), IMG_UINT64_C(0x0000000000000000) },	/* 6.0.4.35 */
+	{ IMG_UINT64_C(0x000f000000010040), IMG_UINT64_C(0x0000000008110645), IMG_UINT64_C(0x340891b0452a9411), IMG_UINT64_C(0x0000000000000001) },	/* 15.0.1.64 */
+	{ IMG_UINT64_C(0x0016000000150010), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a0494b044080011), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.21.16 */
+	{ IMG_UINT64_C(0x0016000000360019), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a0894b064080011), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.54.25 */
+	{ IMG_UINT64_C(0x001600000036001e), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a0894b084080011), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.54.30 */
+	{ IMG_UINT64_C(0x0016000000360026), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a08953084080011), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.54.38 */
+	{ IMG_UINT64_C(0x001600000036014a), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a0894b0840a9651), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.54.330 */
+	{ IMG_UINT64_C(0x0016000000680012), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a089530c4080011), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.104.18 */
+	{ IMG_UINT64_C(0x00160000006800da), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a089530c40a9651), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.104.218 */
+	{ IMG_UINT64_C(0x0016000000d0013e), IMG_UINT64_C(0x000000001ad1b615), IMG_UINT64_C(0x2a08a551080a9651), IMG_UINT64_C(0x0000000000000001) },	/* 22.0.208.318 */
+	{ IMG_UINT64_C(0x00180000003600cc), IMG_UINT64_C(0x000002003951fe95), IMG_UINT64_C(0x2a089930840a9651), IMG_UINT64_C(0x0000000000000001) },	/* 24.0.54.204 */
+	{ IMG_UINT64_C(0x00180000006801f8), IMG_UINT64_C(0x000002003951fe95), IMG_UINT64_C(0x2a089930a40a9651), IMG_UINT64_C(0x0000000000000001) },	/* 24.0.104.504 */
+	{ IMG_UINT64_C(0x0018000000d001f8), IMG_UINT64_C(0x000002003951fe95), IMG_UINT64_C(0x2a0aa951080a9651), IMG_UINT64_C(0x0000000000000001) },	/* 24.0.208.504 */
+	{ IMG_UINT64_C(0x0018000000d001f9), IMG_UINT64_C(0x000002003951fe95), IMG_UINT64_C(0x2a0aa951080a9651), IMG_UINT64_C(0x0000000000000001) },	/* 24.0.208.505 */
+	{ IMG_UINT64_C(0x001d0000003400ca), IMG_UINT64_C(0x000002183951feb5), IMG_UINT64_C(0x2a069930440a9891), IMG_UINT64_C(0x0000000000000001) },	/* 29.0.52.202 */
+	{ IMG_UINT64_C(0x001d0000006c00d0), IMG_UINT64_C(0x000002183951feb5), IMG_UINT64_C(0x2a0aa950e80a9891), IMG_UINT64_C(0x0000000000000001) },	/* 29.0.108.208 */
+	{ IMG_UINT64_C(0x00210000000b0003), IMG_UINT64_C(0x000002001551ba25), IMG_UINT64_C(0x2a02992824080011), IMG_UINT64_C(0x0000000000000001) },	/* 33.0.11.3 */
+	{ IMG_UINT64_C(0x0021000000160001), IMG_UINT64_C(0x000002181955be35), IMG_UINT64_C(0x2a06993044080011), IMG_UINT64_C(0x0000000000000001) },	/* 33.0.22.1 */
+	{ IMG_UINT64_C(0x00240000003400b6), IMG_UINT64_C(0x000002001d51bf35), IMG_UINT64_C(0x2a4699304412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.52.182 */
+	{ IMG_UINT64_C(0x0024000000360067), IMG_UINT64_C(0x000002181d51b735), IMG_UINT64_C(0x2a469930840abad1), IMG_UINT64_C(0x0000000000000001) },	/* 36.0.54.103 */
+	{ IMG_UINT64_C(0x00240000003600b6), IMG_UINT64_C(0x000002181d51bf35), IMG_UINT64_C(0x2a4699308412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.54.182 */
+	{ IMG_UINT64_C(0x00240000003600b7), IMG_UINT64_C(0x000002181d51bf35), IMG_UINT64_C(0x2a4699308412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.54.183 */
+	{ IMG_UINT64_C(0x0024000000360118), IMG_UINT64_C(0x00000219dd51bf35), IMG_UINT64_C(0x2a8699308412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.54.280 */
+	{ IMG_UINT64_C(0x00240000006800b6), IMG_UINT64_C(0x000002181d51bf35), IMG_UINT64_C(0x2a469930a412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.104.182 */
+	{ IMG_UINT64_C(0x00240000006800b7), IMG_UINT64_C(0x000002181d51bf35), IMG_UINT64_C(0x2a469930a412bad1), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.104.183 */
+	{ IMG_UINT64_C(0x002400000068031c), IMG_UINT64_C(0x0000039a1d79af35), IMG_UINT64_C(0x2a469930a412bad9), IMG_UINT64_C(0x0000000000000055) },	/* 36.0.104.796 */
+	{ IMG_UINT64_C(0x002e000000660185), IMG_UINT64_C(0x00000241dd51bf35), IMG_UINT64_C(0x2ad899324412bad5), IMG_UINT64_C(0x0000000000000055) },	/* 46.0.102.389 */
+	{ IMG_UINT64_C(0x002e000000cc0186), IMG_UINT64_C(0x00000259dd51bf35), IMG_UINT64_C(0x2ad89932c412bad5), IMG_UINT64_C(0x0000000000000055) },	/* 46.0.204.390 */
 };
 
 /******************************************************************************
@@ -350,49 +338,48 @@ static const IMG_UINT64 gaFeatures[][4]=
 static const IMG_UINT64 gaErnsBrns[][2]=
 {
 	{ IMG_UINT64_C(0x0001002700040013), IMG_UINT64_C(0x0000000000000005) },	/* 1.39.4.19 */
-	{ IMG_UINT64_C(0x0001004b0002001e), IMG_UINT64_C(0x0000000000000004) },	/* 1.75.2.30 */
 	{ IMG_UINT64_C(0x0001005200040005), IMG_UINT64_C(0x0000000000000000) },	/* 1.82.4.5 */
-	{ IMG_UINT64_C(0x0004001f00040037), IMG_UINT64_C(0x000000000000108a) },	/* 4.31.4.55 */
-	{ IMG_UINT64_C(0x0004002800020033), IMG_UINT64_C(0x000000000000108a) },	/* 4.40.2.51 */
-	{ IMG_UINT64_C(0x0004002b0006003e), IMG_UINT64_C(0x000000000000508a) },	/* 4.43.6.62 */
-	{ IMG_UINT64_C(0x0004002d0002003a), IMG_UINT64_C(0x000000000000500a) },	/* 4.45.2.58 */
-	{ IMG_UINT64_C(0x0004002e0006003e), IMG_UINT64_C(0x000000000000508a) },	/* 4.46.6.62 */
+	{ IMG_UINT64_C(0x0004001f00040037), IMG_UINT64_C(0x000000000000042a) },	/* 4.31.4.55 */
+	{ IMG_UINT64_C(0x0004002800020033), IMG_UINT64_C(0x000000000000042a) },	/* 4.40.2.51 */
+	{ IMG_UINT64_C(0x0004002b0006003e), IMG_UINT64_C(0x000000000000142a) },	/* 4.43.6.62 */
+	{ IMG_UINT64_C(0x0004002d0002003a), IMG_UINT64_C(0x000000000000140a) },	/* 4.45.2.58 */
+	{ IMG_UINT64_C(0x0004002e0006003e), IMG_UINT64_C(0x000000000000142a) },	/* 4.46.6.62 */
 	{ IMG_UINT64_C(0x000500090001002e), IMG_UINT64_C(0x0000000000000001) },	/* 5.9.1.46 */
-	{ IMG_UINT64_C(0x0006002200040023), IMG_UINT64_C(0x000000000000100a) },	/* 6.34.4.35 */
-	{ IMG_UINT64_C(0x000f000500010040), IMG_UINT64_C(0x0000000000004008) },	/* 15.5.1.64 */
-	{ IMG_UINT64_C(0x0016001e00360019), IMG_UINT64_C(0x0000000000116b08) },	/* 22.30.54.25 */
-	{ IMG_UINT64_C(0x001600280036001e), IMG_UINT64_C(0x0000000000116b08) },	/* 22.40.54.30 */
-	{ IMG_UINT64_C(0x0016002e0036014a), IMG_UINT64_C(0x000000000011ea0a) },	/* 22.46.54.330 */
-	{ IMG_UINT64_C(0x0016003100150010), IMG_UINT64_C(0x0000000000116b08) },	/* 22.49.21.16 */
-	{ IMG_UINT64_C(0x001600430036001e), IMG_UINT64_C(0x0000000000116708) },	/* 22.67.54.30 */
-	{ IMG_UINT64_C(0x001600440036001e), IMG_UINT64_C(0x0000000000116508) },	/* 22.68.54.30 */
-	{ IMG_UINT64_C(0x00160056006800da), IMG_UINT64_C(0x000000000010e408) },	/* 22.86.104.218 */
-	{ IMG_UINT64_C(0x0016005700680012), IMG_UINT64_C(0x0000000000106508) },	/* 22.87.104.18 */
-	{ IMG_UINT64_C(0x0016006600360026), IMG_UINT64_C(0x0000000000106508) },	/* 22.102.54.38 */
-	{ IMG_UINT64_C(0x0016006800d0013e), IMG_UINT64_C(0x000000000010e40a) },	/* 22.104.208.318 */
-	{ IMG_UINT64_C(0x0016006900d0013e), IMG_UINT64_C(0x000000000010e40a) },	/* 22.105.208.318 */
-	{ IMG_UINT64_C(0x0018003200d001f8), IMG_UINT64_C(0x000000000012210a) },	/* 24.50.208.504 */
-	{ IMG_UINT64_C(0x0018003800d001f9), IMG_UINT64_C(0x000000000012210a) },	/* 24.56.208.505 */
-	{ IMG_UINT64_C(0x00180042003600cc), IMG_UINT64_C(0x000000000012210a) },	/* 24.66.54.204 */
-	{ IMG_UINT64_C(0x00180043006801f8), IMG_UINT64_C(0x000000000012210a) },	/* 24.67.104.504 */
-	{ IMG_UINT64_C(0x001d000e006c00d0), IMG_UINT64_C(0x00000000001a212a) },	/* 29.14.108.208 */
-	{ IMG_UINT64_C(0x001d0013003400ca), IMG_UINT64_C(0x00000000001a212a) },	/* 29.19.52.202 */
-	{ IMG_UINT64_C(0x0021000800160001), IMG_UINT64_C(0x000000000010212a) },	/* 33.8.22.1 */
-	{ IMG_UINT64_C(0x0021000f000b0003), IMG_UINT64_C(0x000000000010212a) },	/* 33.15.11.3 */
-	{ IMG_UINT64_C(0x0024001d003400b6), IMG_UINT64_C(0x000000000010212a) },	/* 36.29.52.182 */
-	{ IMG_UINT64_C(0x00240032003600b6), IMG_UINT64_C(0x000000000010212a) },	/* 36.50.54.182 */
-	{ IMG_UINT64_C(0x00240034006800b6), IMG_UINT64_C(0x000000000010212a) },	/* 36.52.104.182 */
-	{ IMG_UINT64_C(0x002400350068031c), IMG_UINT64_C(0x000000000010012a) },	/* 36.53.104.796 */
-	{ IMG_UINT64_C(0x00240036003600b7), IMG_UINT64_C(0x000000000010212a) },	/* 36.54.54.183 */
-	{ IMG_UINT64_C(0x0024003700360067), IMG_UINT64_C(0x000000000010212a) },	/* 36.55.54.103 */
-	{ IMG_UINT64_C(0x00240038006800b7), IMG_UINT64_C(0x000000000010212a) },	/* 36.56.104.183 */
-	{ IMG_UINT64_C(0x0024003c00360118), IMG_UINT64_C(0x000000000010212a) },	/* 36.60.54.280 */
-	{ IMG_UINT64_C(0x002e004800660185), IMG_UINT64_C(0x000000000014212a) },	/* 46.72.102.389 */
+	{ IMG_UINT64_C(0x0006002200040023), IMG_UINT64_C(0x000000000000040a) },	/* 6.34.4.35 */
+	{ IMG_UINT64_C(0x000f000500010040), IMG_UINT64_C(0x0000000000001008) },	/* 15.5.1.64 */
+	{ IMG_UINT64_C(0x0016001e00360019), IMG_UINT64_C(0x0000000000085ac8) },	/* 22.30.54.25 */
+	{ IMG_UINT64_C(0x001600280036001e), IMG_UINT64_C(0x0000000000085ac8) },	/* 22.40.54.30 */
+	{ IMG_UINT64_C(0x0016002e0036014a), IMG_UINT64_C(0x0000000000087a8a) },	/* 22.46.54.330 */
+	{ IMG_UINT64_C(0x0016003100150010), IMG_UINT64_C(0x0000000000085ac8) },	/* 22.49.21.16 */
+	{ IMG_UINT64_C(0x001600430036001e), IMG_UINT64_C(0x00000000000859c8) },	/* 22.67.54.30 */
+	{ IMG_UINT64_C(0x001600440036001e), IMG_UINT64_C(0x0000000000085948) },	/* 22.68.54.30 */
+	{ IMG_UINT64_C(0x00160056006800da), IMG_UINT64_C(0x0000000000083908) },	/* 22.86.104.218 */
+	{ IMG_UINT64_C(0x0016005700680012), IMG_UINT64_C(0x0000000000081948) },	/* 22.87.104.18 */
+	{ IMG_UINT64_C(0x0016006600360026), IMG_UINT64_C(0x0000000000081948) },	/* 22.102.54.38 */
+	{ IMG_UINT64_C(0x0016006800d0013e), IMG_UINT64_C(0x000000000008390a) },	/* 22.104.208.318 */
+	{ IMG_UINT64_C(0x0018003200d001f8), IMG_UINT64_C(0x000000000008884a) },	/* 24.50.208.504 */
+	{ IMG_UINT64_C(0x0018003800d001f9), IMG_UINT64_C(0x000000000008884a) },	/* 24.56.208.505 */
+	{ IMG_UINT64_C(0x00180042003600cc), IMG_UINT64_C(0x000000000008884a) },	/* 24.66.54.204 */
+	{ IMG_UINT64_C(0x00180043006801f8), IMG_UINT64_C(0x000000000008884a) },	/* 24.67.104.504 */
+	{ IMG_UINT64_C(0x001d000e006c00d0), IMG_UINT64_C(0x00000000000a885a) },	/* 29.14.108.208 */
+	{ IMG_UINT64_C(0x001d0013003400ca), IMG_UINT64_C(0x00000000000a885a) },	/* 29.19.52.202 */
+	{ IMG_UINT64_C(0x0021000800160001), IMG_UINT64_C(0x000000000008085a) },	/* 33.8.22.1 */
+	{ IMG_UINT64_C(0x0021000f000b0003), IMG_UINT64_C(0x00000000000c085a) },	/* 33.15.11.3 */
+	{ IMG_UINT64_C(0x0024001d003400b6), IMG_UINT64_C(0x000000000008085a) },	/* 36.29.52.182 */
+	{ IMG_UINT64_C(0x00240032003600b6), IMG_UINT64_C(0x00000000000c085a) },	/* 36.50.54.182 */
+	{ IMG_UINT64_C(0x00240034006800b6), IMG_UINT64_C(0x00000000000c085a) },	/* 36.52.104.182 */
+	{ IMG_UINT64_C(0x002400350068031c), IMG_UINT64_C(0x000000000008005a) },	/* 36.53.104.796 */
+	{ IMG_UINT64_C(0x00240036003600b7), IMG_UINT64_C(0x000000000008085a) },	/* 36.54.54.183 */
+	{ IMG_UINT64_C(0x0024003700360067), IMG_UINT64_C(0x000000000008085a) },	/* 36.55.54.103 */
+	{ IMG_UINT64_C(0x00240038006800b7), IMG_UINT64_C(0x000000000008085a) },	/* 36.56.104.183 */
+	{ IMG_UINT64_C(0x0024003c00360118), IMG_UINT64_C(0x000000000008085a) },	/* 36.60.54.280 */
+	{ IMG_UINT64_C(0x002e004800660185), IMG_UINT64_C(0x000000000009085a) },	/* 46.72.102.389 */
+	{ IMG_UINT64_C(0x002e005e00cc0186), IMG_UINT64_C(0x000000000009085a) },	/* 46.94.204.390 */
 };
 
 #if defined(DEBUG)
 
-#define FEATURE_NO_VALUES_NAMES_MAX_IDX (57U)
+#define FEATURE_NO_VALUES_NAMES_MAX_IDX (43U)
 
 static const IMG_CHAR * const gaszFeaturesNoValuesNames[FEATURE_NO_VALUES_NAMES_MAX_IDX] =
 {
@@ -400,44 +387,32 @@ static const IMG_CHAR * const gaszFeaturesNoValuesNames[FEATURE_NO_VALUES_NAMES_
 	"CLUSTER_GROUPING",
 	"COMPUTE",
 	"COMPUTE_MORTON_CAPABLE",
-	"COMPUTE_ONLY",
 	"COMPUTE_OVERLAP",
-	"COMPUTE_OVERLAP_WITH_BARRIERS",
 	"COREID_PER_OS",
-	"DUST_POWER_ISLAND_S7",
 	"DYNAMIC_DUST_POWER",
 	"FASTRENDER_DM",
 	"GPU_MULTICORE_SUPPORT",
 	"GPU_VIRTUALISATION",
 	"GS_RTA_SUPPORT",
 	"IRQ_PER_OS",
-	"META_DMA",
 	"MIPS",
 	"PBE2_IN_XE",
 	"PBE_CHECKSUM_2D",
 	"PBVNC_COREID_REG",
-	"PDS_PER_DUST",
-	"PDS_TEMPSIZE8",
 	"PERFBUS",
 	"PERF_COUNTER_BATCH",
 	"PM_MMU_VFP",
 	"RISCV_FW_PROCESSOR",
 	"ROGUEXE",
-	"S7_CACHE_HIERARCHY",
-	"S7_TOP_INFRASTRUCTURE",
-	"SCALABLE_VDM_GPP",
-	"SIGNAL_SNOOPING",
+	"SAFETY_IRQ",
 	"SIMPLE_INTERNAL_PARAMETER_FORMAT",
 	"SIMPLE_INTERNAL_PARAMETER_FORMAT_V1",
 	"SIMPLE_INTERNAL_PARAMETER_FORMAT_V2",
 	"SINGLE_BIF",
-	"SLC_HYBRID_CACHELINE_64_128",
 	"SLC_SIZE_CONFIGURABLE",
-	"SLC_VIVT",
 	"SOC_TIMER",
 	"SYS_BUS_SECURE_RESET",
 	"TDM_PDS_CHECKSUM",
-	"TESSELLATION",
 	"TFBC_DELTA_CORRELATION",
 	"TFBC_LOSSY_37_PERCENT",
 	"TFBC_NATIVE_YUV10",
@@ -446,8 +421,6 @@ static const IMG_CHAR * const gaszFeaturesNoValuesNames[FEATURE_NO_VALUES_NAMES_
 	"TPU_CEM_DATAMASTER_GLOBAL_REGISTERS",
 	"TPU_DM_GLOBAL_REGISTERS",
 	"TPU_FILTERING_MODE_CONTROL",
-	"VDM_DRAWINDIRECT",
-	"VDM_OBJECT_LEVEL_LLS",
 	"VOLCANIC_TB",
 	"WATCHDOG_TIMER",
 	"WORKGROUP_PROTECTION",
@@ -455,7 +428,7 @@ static const IMG_CHAR * const gaszFeaturesNoValuesNames[FEATURE_NO_VALUES_NAMES_
 	"XT_TOP_INFRASTRUCTURE",
 };
 
-#define ERNSBRNS_IDS_MAX_IDX (22U)
+#define ERNSBRNS_IDS_MAX_IDX (20U)
 
 static const IMG_UINT32 gaui64ErnsBrnsIDs[ERNSBRNS_IDS_MAX_IDX] =
 {
@@ -463,9 +436,7 @@ static const IMG_UINT32 gaui64ErnsBrnsIDs[ERNSBRNS_IDS_MAX_IDX] =
 	42290,
 	42321,
 	42606,
-	46066,
 	47025,
-	50539,
 	50767,
 	57596,
 	60084,
@@ -479,8 +450,8 @@ static const IMG_UINT32 gaui64ErnsBrnsIDs[ERNSBRNS_IDS_MAX_IDX] =
 	66622,
 	66927,
 	68186,
+	71242,
 	71317,
-	73472,
 };
 
 #endif /* defined(DEBUG) */
diff --git a/drivers/gpu/drm/img-rogue/km/rgxdefs_km.h b/drivers/gpu/drm/img-rogue/km/rgxdefs_km.h
index 31a550ab9364..dbaaa5faaf97 100644
--- a/drivers/gpu/drm/img-rogue/km/rgxdefs_km.h
+++ b/drivers/gpu/drm/img-rogue/km/rgxdefs_km.h
@@ -48,7 +48,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif
 
 #define IMG_EXPLICIT_INCLUDE_HWDEFS
-#if defined(__KERNEL__)
+#if defined(__KERNEL__) || defined(TEE_DDK)
 #include "rgx_cr_defs_km.h"
 #endif
 #undef IMG_EXPLICIT_INCLUDE_HWDEFS
@@ -151,7 +151,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_META_COREMEM_128K     (128*1024)
 #define RGX_META_COREMEM_256K     (256*1024)
 
-#if !defined(__KERNEL__)
+#if !(defined(__KERNEL__) || defined(TEE_DDK))
 #if (!defined(SUPPORT_TRUSTED_DEVICE) || defined(RGX_FEATURE_META_DMA)) && \
     (defined(RGX_FEATURE_META_COREMEM_SIZE) && RGX_FEATURE_META_COREMEM_SIZE != 0)
 #define RGX_META_COREMEM_SIZE     (RGX_FEATURE_META_COREMEM_SIZE*1024U)
@@ -171,6 +171,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define GET_ROGUE_CACHE_LINE_SIZE(x)    ((((IMG_UINT32)(x)) > 0U) ? ((IMG_UINT32)(x)/8U) : (0U))
 
+#if defined(RGX_FEATURE_META_DMA)
+#define RGX_META_DMA_BLOCK_SIZE (32U)
+#else
+#define RGX_META_DMA_BLOCK_SIZE (0U)
+#endif
 
 #if defined(SUPPORT_AGP)
 #define MAX_HW_TA3DCONTEXTS	3U
@@ -221,6 +226,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                             RGX_CR_SOFT_RESET2_VERTEX_EN)
 
 
+/* PM interactive mode enabled default for all rogue cores */
+#define PM_INTERACTIVE_MODE
 
 #define RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT		(12U)
 #define RGX_BIF_PM_PHYSICAL_PAGE_SIZE			(1UL << RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT)
@@ -242,7 +249,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_REQ_NUM_BERNADOS(CLUSTERS) (((CLUSTERS) + 3U) / 4U)
 #define RGX_REQ_NUM_BLACKPEARLS(CLUSTERS) (((CLUSTERS) + 3U) / 4U)
 
-#if !defined(__KERNEL__)
+#if !(defined(__KERNEL__) || defined(TEE_DDK))
 # define RGX_NUM_PHANTOMS (RGX_REQ_NUM_PHANTOMS(RGX_FEATURE_NUM_CLUSTERS))
 #endif
 
@@ -286,7 +293,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_CR_JONES_IDLE_MASKFULL                        (IMG_UINT64_C(0x0000000000003FFF))
 #endif
 
-#if !defined(__KERNEL__)
+#if !(defined(__KERNEL__) || defined(TEE_DDK))
 
 #if defined(RGX_FEATURE_ROGUEXE)
 #define RGX_NUM_RASTERISATION_MODULES	RGX_FEATURE_NUM_CLUSTERS
@@ -294,7 +301,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_NUM_RASTERISATION_MODULES	RGX_NUM_PHANTOMS
 #endif
 
-#endif /* defined(__KERNEL__) */
+#endif /* !(defined(__KERNEL__) || defined(TEE_DDK)) */
 
 /* GPU CR timer tick in GPU cycles */
 #define RGX_CRTIME_TICK_IN_CYCLES					(256U)
@@ -338,6 +345,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_HOST_SECURE_REGBANK_OFFSET				(0xF0000U)
 #define RGX_HOST_SECURE_REGBANK_SIZE				(0x10000U)
 
+/*
+	Maximum number of render targets in array
+*/
+#define RGX_MAX_TA_RENDER_TARGETS					(2048U)
+
 /*
  * Macro used to indicate which version of HWPerf is active
  */
diff --git a/drivers/gpu/drm/img-rogue/km_apphint.c b/drivers/gpu/drm/img-rogue/km_apphint.c
index e8d69e21bd2e..6e9bfd6f07d4 100644
--- a/drivers/gpu/drm/img-rogue/km_apphint.c
+++ b/drivers/gpu/drm/img-rogue/km_apphint.c
@@ -635,7 +635,7 @@ static int apphint_read(char *buffer, size_t count, APPHINT_ID ue,
 			goto err_exit;
 		}
 
-		OSStringLCopy(value->STRING, string, len);
+		OSStringSafeCopy(value->STRING, string, len);
 		break;
 	}
 	default:
@@ -854,25 +854,33 @@ static int apphint_kparam_set(const char *val, const struct kernel_param *kp)
 	char val_copy[APPHINT_BUFFER_SIZE];
 	APPHINT_ID id;
 	union apphint_value value;
-	int result;
+	ssize_t result = OSStringSafeCopy(val_copy, val, APPHINT_BUFFER_SIZE);
 
-	/* need to discard const in case of string comparison */
-	result = strlcpy(val_copy, val, APPHINT_BUFFER_SIZE);
+	/* Document the assumption - we can safely store the result of
+	 * apphint_read() in a ssize_t variable, no need for a separate one */
+#ifndef SSIZE_MAX
+#define SSIZE_MAX ((~(size_t)0) >> 1)
+#endif
+	BUILD_BUG_ON(INT_MAX > SSIZE_MAX);
 
-	get_apphint_id_from_action_addr(kp->arg, &id);
-	if (result < APPHINT_BUFFER_SIZE) {
-		result = apphint_read(val_copy, result, id, &value);
-		if (result >= 0) {
-			((struct apphint_action *)kp->arg)->stored = value;
-			((struct apphint_action *)kp->arg)->initialised = true;
-			if (param_lookup[id].data_type == APPHINT_DATA_TYPE_STRING) {
-				((struct apphint_action *)kp->arg)->free = true;
-			}
-		}
-	} else {
+	if (result < 0) {
 		PVR_DPF((PVR_DBG_ERROR, "%s: String too long", __func__));
+		return (int)result;
+	}
+
+	get_apphint_id_from_action_addr(kp->arg, &id);
+	result = apphint_read(val_copy, result, id, &value);
+	if (result < 0) {
+		return (int)result;
+	}
+
+	((struct apphint_action *)kp->arg)->stored = value;
+	((struct apphint_action *)kp->arg)->initialised = true;
+	if (param_lookup[id].data_type == APPHINT_DATA_TYPE_STRING) {
+		((struct apphint_action *)kp->arg)->free = true;
 	}
-	return (result > 0) ? 0 : result;
+
+	return 0;
 }
 
 /*
@@ -1022,8 +1030,9 @@ static int apphint_debuginfo_init(const char *sub_dir,
 		.pfnNext  = apphint_di_next,  .pfnShow = apphint_di_show,
 		.pfnWrite = apphint_set,      .ui32WriteLenMax = APPHINT_BUFFER_SIZE
 	};
+
 	/* Determine if we're booted as a GUEST VZ OS */
-	IMG_BOOL bIsGUEST = PVRSRV_VZ_MODE_IS(GUEST);
+	IMG_BOOL bIsGUEST = PVRSRV_VZ_MODE_IS(GUEST, DEVID, device_num);
 
 	if (*rootdir) {
 		PVR_DPF((PVR_DBG_WARNING,
@@ -1492,13 +1501,13 @@ int pvr_apphint_get_string(PVRSRV_DEVICE_NODE *device, APPHINT_ID ue, IMG_CHAR *
 	if (ue < APPHINT_ID_MAX && apphint.val[ue].stored.STRING) {
 		if ((int)ue > APPHINT_DEBUGINFO_DEVICE_ID_OFFSET) // From this point, we're in the device apphints
 		{
-			if (OSStringLCopy(pBuffer, apphint.val[ue + device_offset].stored.STRING, size) < size) {
+			if (OSStringSafeCopy(pBuffer, apphint.val[ue + device_offset].stored.STRING, size) >= 0) {
 				error = 0;
 			}
 		}
 		else
 		{
-			if (OSStringLCopy(pBuffer, apphint.val[ue].stored.STRING, size) < size) {
+			if (OSStringSafeCopy(pBuffer, apphint.val[ue].stored.STRING, size) >= 0) {
 				error = 0;
 			}
 		}
@@ -1585,10 +1594,8 @@ int pvr_apphint_set_string(PVRSRV_DEVICE_NODE *device, APPHINT_ID ue, IMG_CHAR *
 			error = apphint.val[ue + device_offset].set.STRING(apphint.val[ue + device_offset].device,
 															 apphint.val[ue + device_offset].private_data,
 															 pBuffer);
-		} else {
-			if (strlcpy(apphint.val[ue + device_offset].stored.STRING, pBuffer, size) < size) {
-				error = 0;
-			}
+		} else if (OSStringSafeCopy(apphint.val[ue + device_offset].stored.STRING, pBuffer, size) >= 0) {
+			error = 0;
 		}
 		apphint.val[ue].device = device;
 	}
diff --git a/drivers/gpu/drm/img-rogue/km_apphint_defs_common.h b/drivers/gpu/drm/img-rogue/km_apphint_defs_common.h
index 3bc19a75ac2b..b3087e79d73a 100644
--- a/drivers/gpu/drm/img-rogue/km_apphint_defs_common.h
+++ b/drivers/gpu/drm/img-rogue/km_apphint_defs_common.h
@@ -80,8 +80,9 @@ X(FWContextSwitchProfile,           UINT32,         VALIDATION,  PVRSRV_APPHINT_
 \
 X(EnableRDPowerIsland,              UINT32,         ALWAYS,      PVRSRV_APPHINT_ENABLERDPOWERISLAND,           NO_PARAM_TABLE,   ALWAYS   ) \
 \
-X(DriverMode,                       UINT32,         ALWAYS,      PVRSRV_APPHINT_DRIVERMODE,                    NO_PARAM_TABLE,   ALWAYS   ) \
-X(AutoVzGPUPowerdown,               BOOL,           ALWAYS,      0,                                            NO_PARAM_TABLE,   ALWAYS   ) \
+X(DriverMode,                       STRING,         ALWAYS,      PVRSRV_APPHINT_DRIVERMODE,                    NO_PARAM_TABLE,   ALWAYS   ) \
+X(AutoVzGPUPowerdown,               BOOL,           ALWAYS,      PVRSRV_APPHINT_AUTOVZGPUPOWERDOWN,            NO_PARAM_TABLE,   ALWAYS   ) \
+X(GuestFWHeapStride,                UINT64,         ALWAYS,      PVRSRV_APPHINT_GUESTFWHEAPSTRIDE,             NO_PARAM_TABLE,   ALWAYS   ) \
 \
 X(FirmwarePerf,                     UINT32,         VALIDATION,  PVRSRV_APPHINT_FIRMWAREPERF,                  NO_PARAM_TABLE,   ALWAYS   ) \
 \
@@ -89,7 +90,6 @@ X(HWPerfFWBufSizeInKB,              UINT32,         PDUMP,       PVRSRV_APPHINT_
 X(HWPerfHostBufSizeInKB,            UINT32,         VALIDATION,  PVRSRV_APPHINT_HWPERFHOSTBUFSIZEINKB,         NO_PARAM_TABLE,   ALWAYS   ) \
 X(HWPerfHostThreadTimeoutInMS,      UINT32,         VALIDATION,  PVRSRV_APPHINT_HWPERFHOSTTHREADTIMEOUTINMS,   NO_PARAM_TABLE,   ALWAYS   ) \
 \
-X(JonesDisableMask,                 UINT32,         VALIDATION,  PVRSRV_APPHINT_JONESDISABLEMASK,              NO_PARAM_TABLE,   ALWAYS   ) \
 X(NewFilteringMode,                 BOOL,           VALIDATION,  PVRSRV_APPHINT_NEWFILTERINGMODE,              NO_PARAM_TABLE,   ALWAYS   ) \
 X(TruncateMode,                     UINT32,         VALIDATION,  PVRSRV_APPHINT_TRUNCATEMODE,                  NO_PARAM_TABLE,   ALWAYS   ) \
 X(EmuMaxFreq,                       UINT32,         ALWAYS,      PVRSRV_APPHINT_EMUMAXFREQ,                    NO_PARAM_TABLE,   ALWAYS   ) \
@@ -99,11 +99,11 @@ X(RGXBVNC,                          STRING,         ALWAYS,      PVRSRV_APPHINT_
 X(FWContextSwitchCrossDM,           UINT32,         ALWAYS,      0,                                            NO_PARAM_TABLE,   ALWAYS   ) \
 X(ValidateIrq,                      BOOL,           VALIDATION,  PVRSRV_APPHINT_VALIDATEIRQ,                   NO_PARAM_TABLE,   ALWAYS   ) \
 \
-X(TPUTrilinearFracMaskPDM,          UINT32,         VALIDATION,  0xF,                                          NO_PARAM_TABLE,   ALWAYS   ) \
-X(TPUTrilinearFracMaskVDM,          UINT32,         VALIDATION,  0xF,                                          NO_PARAM_TABLE,   ALWAYS   ) \
-X(TPUTrilinearFracMaskCDM,          UINT32,         VALIDATION,  0xF,                                          NO_PARAM_TABLE,   ALWAYS   ) \
-X(TPUTrilinearFracMaskTDM,          UINT32,         VALIDATION,  0xF,                                          NO_PARAM_TABLE,   ALWAYS   ) \
-X(TPUTrilinearFracMaskRDM,          UINT32,         VALIDATION,  0xF,                                          NO_PARAM_TABLE,   ALWAYS   ) \
+X(TPUTrilinearFracMaskPDM,          UINT32,         VALIDATION,  0x7,                                          NO_PARAM_TABLE,   ALWAYS   ) \
+X(TPUTrilinearFracMaskVDM,          UINT32,         VALIDATION,  0x7,                                          NO_PARAM_TABLE,   ALWAYS   ) \
+X(TPUTrilinearFracMaskCDM,          UINT32,         VALIDATION,  0x7,                                          NO_PARAM_TABLE,   ALWAYS   ) \
+X(TPUTrilinearFracMaskTDM,          UINT32,         VALIDATION,  0x7,                                          NO_PARAM_TABLE,   ALWAYS   ) \
+X(TPUTrilinearFracMaskRDM,          UINT32,         VALIDATION,  0x7,                                          NO_PARAM_TABLE,   ALWAYS   ) \
 X(HTBufferSizeInKB,                 UINT32,         ALWAYS,      PVRSRV_APPHINT_HTBUFFERSIZE,                  NO_PARAM_TABLE,   ALWAYS   ) \
 X(FWTraceBufSizeInDWords,           UINT32,         ALWAYS,      PVRSRV_APPHINT_FWTRACEBUFSIZEINDWORDS,        NO_PARAM_TABLE,   ALWAYS   ) \
 \
@@ -129,8 +129,17 @@ X(PhysHeapMinMemOnConnection,       UINT32,         ALWAYS,      PVRSRV_APPHINT_
 X(RestrictGpuLocalPhysHeapSizeMB,   UINT32,         VALIDATION,  0,                                            NO_PARAM_TABLE,   ALWAYS   ) \
 X(PhysHeapHybridDefault2CpuLocal,   BOOL,           ALWAYS,      0,                                            NO_PARAM_TABLE,   ALWAYS   ) \
 \
-X(DebugDumpFWTLogType,              UINT32,         ALWAYS,      PVRSRV_APPHINT_DEBUGDUMPFWTLOGTYPE,           NO_PARAM_TABLE,   ALWAYS   )
-
+X(DebugDumpFWTLogType,              UINT32,         ALWAYS,      PVRSRV_APPHINT_DEBUGDUMPFWTLOGTYPE,           NO_PARAM_TABLE,   ALWAYS   ) \
+\
+X(EnableIdleCycleStealing,          UINT32,         ALWAYS,      PVRSRV_APPHINT_ENABLEIDLECYCLESTEALING,       NO_PARAM_TABLE,   ALWAYS   ) \
+\
+X(FaultDetectionTimeInterval,       UINT32,         ALWAYS,      PVRSRV_APPHINT_FAULTDETECTIONTIMEINTERVAL_USEC, NO_PARAM_TABLE,   ALWAYS   ) \
+\
+X(ICSTimeIntervalThreshold,         UINT32,         ALWAYS,      PVRSRV_APPHINT_ICSTIMEINTERVAL_THRESHOLD,     NO_PARAM_TABLE,   ALWAYS   ) \
+\
+X(ICSTestModeOn,                    BOOL,           ALWAYS,      0,                                            NO_PARAM_TABLE,   ALWAYS   ) \
+\
+X(FaultInjection,                   UINT32,         ALWAYS,      0,                                            NO_PARAM_TABLE,   ALWAYS   )
 
 /*
 *******************************************************************************
@@ -231,13 +240,8 @@ X(NEVER)
 	#define APPHINT_ENABLED_CLASS_PDUMP IMG_FALSE
 	#define apphint_modparam_class_PDUMP(a, b, c)
 #endif
-#if defined(SUPPORT_VALIDATION)
-	#define APPHINT_ENABLED_CLASS_VALIDATION IMG_TRUE
-	#define apphint_modparam_class_VALIDATION(a, b, c) apphint_modparam_enable(a, b, c)
-#else
 	#define APPHINT_ENABLED_CLASS_VALIDATION IMG_FALSE
 	#define apphint_modparam_class_VALIDATION(a, b, c)
-#endif
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 	#define APPHINT_ENABLED_CLASS_GPUVIRT_VAL IMG_TRUE
 	#define apphint_modparam_class_GPUVIRT_VAL(a, b, c) apphint_modparam_enable(a, b, c)
@@ -267,7 +271,7 @@ X(NEVER)
 #else
 #define APPHNT_BLDVAR_ENABLESIGNATURECHECKS     IMG_FALSE
 #endif
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 #define APPHNT_BLDVAR_ENABLEPAGEFAULTDEBUG      IMG_TRUE
 #else
 #define APPHNT_BLDVAR_ENABLEPAGEFAULTDEBUG      IMG_FALSE
diff --git a/drivers/gpu/drm/img-rogue/lock.h b/drivers/gpu/drm/img-rogue/lock.h
index 87953ab84707..72997df1107e 100644
--- a/drivers/gpu/drm/img-rogue/lock.h
+++ b/drivers/gpu/drm/img-rogue/lock.h
@@ -53,6 +53,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "allocmem.h"
 #include <linux/atomic.h>
+#include <linux/version.h>
 
 #define OSLockCreateNoStats(phLock) ({ \
 	PVRSRV_ERROR e = PVRSRV_ERROR_OUT_OF_MEMORY; \
@@ -114,7 +115,11 @@ static inline IMG_INT OSAtomicOr(ATOMIC_T *pCounter, IMG_INT iVal)
 }
 
 #define OSAtomicAdd(pCounter, incr) atomic_add_return(incr,pCounter)
-#define OSAtomicAddUnless(pCounter, incr, test) atomic_add_unless(pCounter, (incr), (test))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+#define OSAtomicAddUnless(pCounter, incr, test) atomic_fetch_add_unless(pCounter, (incr), (test))
+#else
+#define OSAtomicAddUnless(pCounter, incr, test) __atomic_add_unless(pCounter,incr,test)
+#endif
 
 #define OSAtomicSubtract(pCounter, incr) atomic_add_return(-(incr),pCounter)
 #define OSAtomicSubtractUnless(pCounter, incr, test) OSAtomicAddUnless(pCounter, -(incr), (test))
@@ -136,7 +141,7 @@ static inline IMG_INT OSAtomicOr(ATOMIC_T *pCounter, IMG_INT iVal)
  */ /**************************************************************************/
 IMG_INTERNAL
 PVRSRV_ERROR OSLockCreate(POS_LOCK *phLock);
-#if defined(INTEGRITY_OS)
+#if defined(INTEGRITY_OS) || defined(__QNXNTO__)
 #define OSLockCreateNoStats OSLockCreate
 #endif
 
@@ -149,7 +154,7 @@ PVRSRV_ERROR OSLockCreate(POS_LOCK *phLock);
 IMG_INTERNAL
 void OSLockDestroy(POS_LOCK hLock);
 
-#if defined(INTEGRITY_OS)
+#if defined(INTEGRITY_OS) || defined(__QNXNTO__)
 #define OSLockDestroyNoStats OSLockDestroy
 #endif
 /**************************************************************************/ /*!
diff --git a/drivers/gpu/drm/img-rogue/mem_utils.c b/drivers/gpu/drm/img-rogue/mem_utils.c
index b88537ea3aed..59f808cfcb20 100644
--- a/drivers/gpu/drm/img-rogue/mem_utils.c
+++ b/drivers/gpu/drm/img-rogue/mem_utils.c
@@ -381,65 +381,65 @@ void DeviceMemSetBytes(void *pvDst, unsigned char ui8Value, size_t uSize)
 	}
 }
 
-#if !defined(__QNXNTO__) /* Ignore Neutrino as it uses strlcpy */
-
-#if defined(__KERNEL__) && defined(__linux__)
+#if defined(__linux__) && defined(__KERNEL__)
+#if defined(DEBUG)
 /*
- * In case of Linux kernel-mode in a debug build, choose the variant
- * of StringLCopy that uses strlcpy and logs truncation via a stack dump.
- * For Linux kernel-mode in a release build, strlcpy alone is used.
+ * In case of Linux kernel-mode in a debug build, choose the variant of
+ * OSStringSafeCopy that uses strscpy and logs truncation via a stack dump. For
+ * Linux kernel-mode in a release build, strscpy alone is used.
  */
-#if defined(DEBUG)
 IMG_INTERNAL
-size_t StringLCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize)
+ssize_t OSStringSafeCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize)
 {
 	/*
-	 * Let strlcpy handle any truncation cases correctly.
+	 * Let strscpy handle any truncation cases correctly.
 	 * We will definitely get a NUL-terminated string set in pszDest
 	 */
-	size_t  uSrcSize = strlcpy(pszDest, pszSrc, uDataSize);
+	ssize_t sCopiedCnt = strscpy(pszDest, pszSrc, uDataSize);
 
 #if defined(PVR_DEBUG_STRLCPY)
 	/* Handle truncation by dumping calling stack if debug allows */
-	if (uSrcSize >= uDataSize)
+	if (sCopiedCnt < 0)
 	{
 		PVR_DPF((PVR_DBG_WARNING,
-			"%s: String truncated Src = '<%s>' %ld bytes, Dest = '%s'",
-			__func__, pszSrc, (long)uDataSize, pszDest));
+			"%s: String truncated Src = '<%s>' %zu bytes, Dest = '%s'",
+			__func__, pszSrc, uDataSize, pszDest));
 		OSDumpStack();
 	}
 #endif /* defined(PVR_DEBUG_STRLCPY) && defined(DEBUG) */
 
-	return uSrcSize;
+	return sCopiedCnt;
 }
 #endif /* defined(DEBUG) */
-
-#else /* defined(__KERNEL__) && defined(__linux__) */
+#else /* defined(__linux__) && defined(__KERNEL__) */
 /*
- * For every other platform, make use of the strnlen and strncpy
- * implementation of StringLCopy.
+ * For every other platform, make use of the strnlen and strncpy implementation
+ * of OSStringSafeCopy.
+ *
  * NOTE: It is crucial to avoid memcpy as this has a hidden side-effect of
  * dragging in whatever the build-environment flavour of GLIBC is which can
  * cause unexpected failures for host-side command execution.
  */
 IMG_INTERNAL
-size_t StringLCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize)
+ssize_t OSStringSafeCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize)
 {
-	size_t uSrcSize = strnlen(pszSrc, uDataSize);
-
-	(void)strncpy(pszDest, pszSrc, uSrcSize);
-	if (uSrcSize == uDataSize)
+	/* Match the specification of Linux strscpy - if destination size is 0,
+	 * return negative value (-E2BIG to be precise, but it's probably best
+	 * not to use Linux-specific return values, so -1 will do). */
+	if (uDataSize && (uDataSize <= SSIZE_MAX))
 	{
-		pszDest[uSrcSize-1] = '\0';
-	}
-	else
-	{
-		pszDest[uSrcSize] = '\0';
-	}
+		size_t uSrcSize = strnlen(pszSrc, uDataSize);
 
-	return uSrcSize;
-}
+		(void)strncpy(pszDest, pszSrc, MIN(uSrcSize + 1, uDataSize));
+		if (uSrcSize == uDataSize)
+		{
+			pszDest[uSrcSize-1] = '\0';
+			return -1;
+		}
 
-#endif /* defined(__KERNEL__) && defined(__linux__) */
+		return (ssize_t)uSrcSize;
+	}
 
-#endif /* !defined(__QNXNTO__) */
+	return -1;
+}
+#endif /* defined(__linux__) && defined(__KERNEL__) */
diff --git a/drivers/gpu/drm/img-rogue/mmu_common.c b/drivers/gpu/drm/img-rogue/mmu_common.c
index 6a063742c7be..3c402ec25c8e 100644
--- a/drivers/gpu/drm/img-rogue/mmu_common.c
+++ b/drivers/gpu/drm/img-rogue/mmu_common.c
@@ -100,8 +100,12 @@ Let's keep this graph up-to-date:
 #define MMU_OBJ_DBG(x)
 #endif
 
-#define SCRATCH_PAGE              "SCRATCH_PAGE"
-#define DEV_ZERO_PAGE             "DEV_ZERO_PAGE"
+#define SCRATCH_PAGE 1
+#define DEV_ZERO_PAGE 2
+#if defined(PDUMP)
+#define SCRATCH_PAGE_STR "SCRATCH_PAGE"
+#define DEV_ZERO_PAGE_STR "DEV_ZERO_PAGE"
+#endif
 #define PVR_SCRATCH_PAGE_INIT_VALUE 0
 #define PVR_ZERO_PAGE_INIT_VALUE  0
 
@@ -261,7 +265,7 @@ typedef struct _MMU_Levelx_INFO_
 	MMU_MEMORY_DESC sMemDesc;
 
 	/*! Array of infos for the next level. Must be last member in structure */
-	struct _MMU_Levelx_INFO_ *apsNextLevel[1];
+	struct _MMU_Levelx_INFO_ *apsNextLevel[IMG_FLEX_ARRAY_MEMBER];
 } MMU_Levelx_INFO;
 
 /*!
@@ -315,7 +319,7 @@ struct _MMU_CONTEXT_
  * Used to determine if the MMU Ctx provided is the FWKM memory context
  * and if it belongs to the VZ Guest.
  */
-#define _MMU_IS_FWKM_CTX_VZGUEST(_ctx) (PVRSRV_VZ_MODE_IS(GUEST) && _MMU_IS_FWKM_CTX(_ctx))
+#define _MMU_IS_FWKM_CTX_VZGUEST(_ctx) (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, _ctx->psPhysMemCtx->psDevNode) && _MMU_IS_FWKM_CTX(_ctx))
 
 static const IMG_DEV_PHYADDR gsBadDevPhyAddr = {MMU_BAD_PHYS_ADDR};
 
@@ -323,10 +327,21 @@ static const IMG_DEV_PHYADDR gsBadDevPhyAddr = {MMU_BAD_PHYS_ADDR};
 #include "log2.h"
 #endif
 
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION) && defined(__linux__)
-static IMG_UINT32 g_ui32MMULeakCounter = 0;
-static DEFINE_MUTEX(g_sMMULeakMutex);
-#endif
+
+static PVRSRV_ERROR
+MMU_UnmapPagesUnlocked(MMU_CONTEXT *psMMUContext,
+                       PVRSRV_MEMALLOCFLAGS_T uiMappingFlags,
+                       IMG_DEV_VIRTADDR sDevVAddrBase,
+                       IMG_UINT32 ui32PageCount,
+                       IMG_UINT32 *pai32FreeIndices,
+                       IMG_UINT32 uiLog2PageSize,
+                       PVRSRV_MEMALLOCFLAGS_T uiMemAllocFlags);
+
+static PVRSRV_ERROR
+MMU_UnmapPMRFastUnlocked(MMU_CONTEXT *psMMUContext,
+                         IMG_DEV_VIRTADDR sDevVAddrBase,
+                         IMG_UINT32 ui32PageCount,
+                         IMG_UINT32 uiLog2PageSize);
 
 /*****************************************************************************
  *                          Utility functions                                *
@@ -701,6 +716,27 @@ static IMG_UINT32 _CalcPTEIdx(IMG_DEV_VIRTADDR sDevVAddr,
 	return ui32RetVal;
 }
 
+/*************************************************************************/ /*!
+@Function       _GetParityBit
+
+@Description    Calculate parity bit
+
+@Input          uiSrc           Value to calculate the parity bit from.
+
+@Return         The parity bit
+ */
+/*****************************************************************************/
+static inline IMG_UINT64 _GetParityBit(IMG_UINT64 uiSrc)
+{
+	uiSrc ^= uiSrc >> 32U;
+	uiSrc ^= uiSrc >> 16U;
+	uiSrc ^= uiSrc >> 8U;
+	uiSrc ^= uiSrc >> 4U;
+	uiSrc ^= uiSrc >> 2U;
+	uiSrc ^= uiSrc >> 1U;
+
+	return (uiSrc & 1U);
+}
 
 /*****************************************************************************
  *         MMU memory allocation/management functions (mem desc)             *
@@ -737,9 +773,7 @@ static PVRSRV_ERROR _MMU_PhysMem_RAImportAlloc(RA_PERARENA_HANDLE hArenaHandle,
                                                RA_FLAGS_T uiFlags,
                                                RA_LENGTH_T uBaseAlignment,
                                                const IMG_CHAR *pszAnnotation,
-                                               RA_BASE_T *puiBase,
-                                               RA_LENGTH_T *puiActualSize,
-                                               RA_PERISPAN_HANDLE *phPriv)
+                                               RA_IMPORT *psImport)
 {
 	MMU_PHYSMEM_CONTEXT *psPhysMemCtx = (MMU_PHYSMEM_CONTEXT *)hArenaHandle;
 	PVRSRV_DEVICE_NODE *psDevNode = (PVRSRV_DEVICE_NODE *)psPhysMemCtx->psDevNode;
@@ -795,11 +829,11 @@ static PVRSRV_ERROR _MMU_PhysMem_RAImportAlloc(RA_PERARENA_HANDLE hArenaHandle,
 
 	psMapping->uiCpuVAddrRefCount = 0;
 
-	*phPriv = (RA_PERISPAN_HANDLE) psMapping;
+	psImport->hPriv = (RA_PERISPAN_HANDLE) psMapping;
 
 	/* Note: This assumes this memory never gets paged out */
-	*puiBase = (RA_BASE_T)psMapping->sDevPAddr.uiAddr;
-	*puiActualSize = uiSize;
+	psImport->base = (RA_BASE_T)psMapping->sDevPAddr.uiAddr;
+	psImport->uSize = uiSize;
 
 	return PVRSRV_OK;
 
@@ -978,7 +1012,7 @@ static INLINE PVRSRV_ERROR _MMU_ConvertDevMemFlags(IMG_BOOL bInvalidate,
 		*puiMMUProtFlags |= MMU_PROTFLAGS_WRITEABLE;
 	}
 
-	eError = DevmemDeviceCacheMode(psDevNode, uiMappingFlags, &uiGPUCacheMode);
+	eError = DevmemDeviceCacheMode(uiMappingFlags, &uiGPUCacheMode);
 	PVR_RETURN_IF_ERROR(eError);
 
 	switch (uiGPUCacheMode)
@@ -1033,6 +1067,10 @@ static PVRSRV_ERROR _PxMemAlloc(MMU_CONTEXT *psMMUContext,
                                 const MMU_PxE_CONFIG *psConfig,
                                 MMU_LEVEL eMMULevel,
                                 MMU_MEMORY_DESC *psMemDesc,
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+                                IMG_DEV_VIRTADDR* psRunningDevVAddr,
+                                IMG_UINT32 uiLog2DataPageSize,
+#endif
                                 IMG_UINT32 uiLog2Align)
 {
 	PVRSRV_ERROR eError;
@@ -1068,14 +1106,31 @@ static PVRSRV_ERROR _PxMemAlloc(MMU_CONTEXT *psMMUContext,
 		PVR_LOG_GOTO_WITH_ERROR("_MMU_PhysMemAlloc", eError, PVRSRV_ERROR_OUT_OF_MEMORY, e0);
 	}
 
-	/*
-		Clear the object
-		Note: if any MMUs are cleared with non-zero values then will need a
-		custom clear function
-		Note: 'Cached' is wrong for the LMA + ARM64 combination, but this is
-		unlikely
-	 */
-	OSCachedMemSet(psMemDesc->pvCpuVAddr, 0, uiBytes);
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	/* If parity bit is needed, set it accordingly to avoid parity errors along with page-faults. */
+	if (psConfig->uiParityBitMask && eMMULevel == MMU_LEVEL_1 && psRunningDevVAddr != NULL)
+	{
+		IMG_UINT32 uiParity = (IMG_UINT32)_GetParityBit(psRunningDevVAddr->uiAddr ^ 0ULL);
+
+		/* Only calculate parity for first address in the PT.
+		   This tells us which of the two patterns to use for the rest of the PT. */
+		OSCachedMemCopy(psMemDesc->pvCpuVAddr, psMMUContext->psDevAttrs->pui64PrecomputedAllocParity[uiParity], uiBytes);
+
+		/* Increment running dev virtual address */
+		psRunningDevVAddr->uiAddr += (1 << uiLog2DataPageSize) * uiNumEntries;
+	}
+	else
+#endif
+	{
+		/*
+			Clear the object
+			Note: if any MMUs are cleared with non-zero values then will need a
+			custom clear function
+			Note: 'Cached' is wrong for the LMA + ARM64 combination, but this is
+			unlikely
+		*/
+		OSCachedMemSet(psMemDesc->pvCpuVAddr, 0, uiBytes);
+	}
 
 	eError = PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
 	                            &psMemDesc->psMapping->sMemHandle,
@@ -1109,7 +1164,12 @@ static PVRSRV_ERROR _PxMemAlloc(MMU_CONTEXT *psMMUContext,
 	                      psConfig->uiProtMask,
 	                      psConfig->uiValidEnMask,
 	                      0,
+	                      0, /* Unused - Parity bit values are taken directly from PTE memory when PTE is 0-initialised or invalid */
+	                      0, /* Unused */
+	                      0, /* Unused */
 	                      psMMUContext->psDevAttrs->eMMUType);
+#else
+	PVR_UNREFERENCED_PARAMETER(eMMULevel);
 #endif
 
 	return PVRSRV_OK;
@@ -1170,6 +1230,7 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
                                      IMG_UINT32 uiIndex,
                                      const MMU_PxE_CONFIG *psConfig,
                                      const IMG_DEV_PHYADDR *psDevPAddr,
+                                     const IMG_DEV_VIRTADDR *psDevVAddr,
                                      IMG_BOOL bUnmap,
 #if defined(PDUMP)
                                      const IMG_CHAR *pszMemspaceName,
@@ -1183,6 +1244,15 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 	IMG_UINT64 uiAddr = psDevPAddr->uiAddr;
 	PVRSRV_DEVICE_NODE *psDevNode = psMMUContext->psPhysMemCtx->psDevNode;
 
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	IMG_BOOL bParity = psConfig->uiParityBitMask;
+#else
+	IMG_BOOL bParity = psConfig->uiParityBitMask && !bUnmap;
+#if !defined(PDUMP)
+	PVR_UNREFERENCED_PARAMETER(bParity);
+#endif
+#endif
+
 	if (psDevNode->pfnValidateOrTweakPhysAddrs)
 	{
 		PVRSRV_ERROR eErr = psDevNode->pfnValidateOrTweakPhysAddrs(psDevNode,
@@ -1197,8 +1267,15 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 			>> psConfig->uiAddrLog2Align /* Shift away the useless bits, because the alignment is very coarse and we address by alignment */
 			<< psConfig->uiAddrShift /* Shift back to fit address in the Px entry */
 			& psConfig->uiAddrMask; /* Delete unused bits */
+
 	ui64PxE64 |= uiProtFlags;
 
+	/* Add parity */
+	if (bParity)
+	{
+		ui64PxE64 |= _GetParityBit(psDevVAddr->uiAddr ^ psDevPAddr->uiAddr) << psConfig->uiParityBitShift;
+	}
+
 	/* Set the entry */
 	if (psConfig->uiBytesPerEntry == 8)
 	{
@@ -1213,6 +1290,7 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 		/* assert that the result fits into 32 bits before writing
 		   it into the 32-bit array with a cast */
 		PVR_ASSERT(ui64PxE64 == (ui64PxE64 & 0xffffffffU));
+		PVR_ASSERT(!bParity);
 
 		pui32Px[uiIndex] = (IMG_UINT32) ui64PxE64;
 	}
@@ -1221,7 +1299,6 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 		return PVRSRV_ERROR_MMU_CONFIG_IS_WRONG;
 	}
 
-
 	/* Log modification */
 	HTBLOGK(HTB_SF_MMU_PAGE_OP_TABLE,
 	        HTBLOG_PTR_BITS_HIGH(psLevel), HTBLOG_PTR_BITS_LOW(psLevel),
@@ -1229,6 +1306,8 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 	        HTBLOG_U64_BITS_HIGH(ui64PxE64), HTBLOG_U64_BITS_LOW(ui64PxE64),
 	        !bUnmap);
 
+	PVR_UNREFERENCED_PARAMETER(bUnmap); /* when HTBLOGK is disabled */
+
 #if defined(PDUMP)
 	PDumpMMUDumpPxEntries(psDevNode,
 	                      MMU_LEVEL_1,
@@ -1247,6 +1326,9 @@ static INLINE PVRSRV_ERROR _SetupPTE(MMU_CONTEXT *psMMUContext,
 	                      psConfig->uiProtMask,
 	                      psConfig->uiValidEnMask,
 	                      0,
+	                      bParity ? _GetParityBit(psDevVAddr->uiAddr ^ 0) : 0,
+	                      psConfig->uiParityBitShift,
+	                      bParity ? psConfig->uiParityBitMask : 0,
 	                      psMMUContext->psDevAttrs->eMMUType);
 #endif /*PDUMP*/
 
@@ -1422,6 +1504,9 @@ static PVRSRV_ERROR _SetupPxE(MMU_CONTEXT *psMMUContext,
 	                      psConfig->uiProtMask,
 	                      psConfig->uiValidEnMask,
 	                      0,
+	                      0, /* Unused */
+	                      0, /* Unused */
+	                      0, /* Unused */
 	                      psMMUContext->psDevAttrs->eMMUType);
 #endif
 
@@ -1506,15 +1591,22 @@ static IMG_BOOL _MMU_FreeLevel(MMU_CONTEXT *psMMUContext,
 	IMG_BOOL bFreed = IMG_FALSE;
 	PVRSRV_DEVICE_NODE *psDevNode = psMMUContext->psPhysMemCtx->psDevNode;
 
+	/* Call before parameter check for debugging purposes. */
+	MMU_OBJ_DBG((PVR_DBG_ERROR,
+	             "_MMU_FreeLevel: level = %u, range %u - %u, refcount = %u",
+	             aeMMULevel[uiThisLevel], uiStartIndex, uiEndIndex,
+	             (psLevel != NULL ? psLevel->ui32RefCount : IMG_UINT32_MAX)));
+
 	/* Parameter checks */
 	PVR_ASSERT(*pui32CurrentLevel < MMU_MAX_LEVEL);
-	PVR_ASSERT(psLevel != NULL);
 
-	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_FreeLevel: level = %d, range %d - %d, refcount = %d",
-			aeMMULevel[uiThisLevel], uiStartIndex,
-			uiEndIndex, psLevel->ui32RefCount));
+	if (psLevel == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: invalid MMU level data", __func__));
+		goto ErrReturn;
+	}
 
-	for (i = uiStartIndex;(i < uiEndIndex) && (psLevel != NULL);i++)
+	for (i = uiStartIndex; i < uiEndIndex; i++)
 	{
 		if (aeMMULevel[uiThisLevel] != MMU_LEVEL_1)
 		{
@@ -1607,16 +1699,20 @@ static IMG_BOOL _MMU_FreeLevel(MMU_CONTEXT *psMMUContext,
 	}
 
 	/* Level one flushing is done when we actually write the table entries */
-	if ((aeMMULevel[uiThisLevel] != MMU_LEVEL_1) && (psLevel != NULL))
+	if (aeMMULevel[uiThisLevel] != MMU_LEVEL_1)
 	{
-		PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
+		PVRSRV_ERROR eError;
+		eError = PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
 		                   &psLevel->sMemDesc.psMapping->sMemHandle,
 		                   uiStartIndex * psConfig->uiBytesPerEntry + psLevel->sMemDesc.uiOffset,
 		                   (uiEndIndex - uiStartIndex) * psConfig->uiBytesPerEntry);
+		PVR_LOG_IF_ERROR(eError, "PhysHeapPagesClean");
 	}
 
-	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_FreeLevel end: level = %d, refcount = %d",
-			aeMMULevel[uiThisLevel], bFreed?0: (psLevel)?psLevel->ui32RefCount:-1));
+ErrReturn:
+	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_FreeLevel end: level = %u, refcount = %u",
+	             aeMMULevel[uiThisLevel],
+	             bFreed ? 0 : (psLevel != NULL ? psLevel->ui32RefCount : IMG_UINT32_MAX)));
 
 	return bFreed;
 }
@@ -1680,6 +1776,9 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
                                     IMG_UINT32 *pui32CurrentLevel,
                                     IMG_UINT32 uiStartIndex,
                                     IMG_UINT32 uiEndIndex,
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+                                    IMG_DEV_VIRTADDR* psRunningDevVAddr,
+#endif
                                     IMG_BOOL bFirst,
                                     IMG_BOOL bLast,
                                     IMG_UINT32 uiLog2DataPageSize)
@@ -1694,9 +1793,10 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 	/* Parameter check */
 	PVR_ASSERT(*pui32CurrentLevel < MMU_MAX_LEVEL);
 
-	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_AllocLevel: level = %d, range %d - %d, refcount = %d",
-			aeMMULevel[uiThisLevel], uiStartIndex,
-			uiEndIndex, psLevel->ui32RefCount));
+	MMU_OBJ_DBG((PVR_DBG_ERROR,
+	             "_MMU_AllocLevel: level = %u, range %u - %u, refcount = %u",
+	             aeMMULevel[uiThisLevel], uiStartIndex, uiEndIndex,
+	             psLevel != NULL ? psLevel->ui32RefCount : IMG_UINT32_MAX));
 
 	/* Go from uiStartIndex to uiEndIndex through the Px */
 	for (i = uiStartIndex;i < uiEndIndex;i++)
@@ -1722,7 +1822,7 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 				ui32AllocSize = sizeof(MMU_Levelx_INFO);
 				if (aeMMULevel[uiThisLevel + 1] != MMU_LEVEL_1)
 				{
-					ui32AllocSize += sizeof(MMU_Levelx_INFO *) * (uiNextEntries - 1);
+					ui32AllocSize += IMG_FLEX_ARRAY_SIZE(sizeof(MMU_Levelx_INFO *), uiNextEntries);
 				}
 				psNextLevel = OSAllocZMem(ui32AllocSize);
 				if (psNextLevel == NULL)
@@ -1740,7 +1840,12 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 				eError = _PxMemAlloc(psMMUContext, uiNextEntries, apsConfig[uiThisLevel + 1],
 				                     aeMMULevel[uiThisLevel + 1],
 				                     &psNextLevel->sMemDesc,
-				                     psConfig->uiAddrLog2Align);
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+				                     psRunningDevVAddr,
+				                     uiLog2DataPageSize,
+#endif
+				                     psConfig->uiAddrLog2Align
+);
 				if (eError != PVRSRV_OK)
 				{
 					uiAllocState = 1;
@@ -1770,6 +1875,17 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 
 				psLevel->ui32RefCount++;
 			}
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+			else
+			{
+				/* The level structure already exists, increment running device virtual address
+				   This is necessary for correct parity bit calculation on further allocated page tables */
+				if (apsConfig[aeMMULevel[MMU_LEVEL_1]]->uiParityBitMask && aeMMULevel[uiThisLevel+1] == MMU_LEVEL_1)
+				{
+					psRunningDevVAddr->uiAddr += psLevel->apsNextLevel[i]->ui32NumOfEntries * (1 << uiLog2DataPageSize);
+				}
+			}
+#endif
 
 			/* If we're crossing a Px then the start index changes */
 			if (bFirst && (i == uiStartIndex))
@@ -1806,13 +1922,17 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 			                         pui32CurrentLevel,
 			                         uiNextStartIndex,
 			                         uiNextEndIndex,
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+
+			                         psRunningDevVAddr,
+#endif
 			                         bNextFirst,
 			                         bNextLast,
 			                         uiLog2DataPageSize);
 			(*pui32CurrentLevel)--;
 			if (eError != PVRSRV_OK)
 			{
-				uiAllocState = 2;
+				uiAllocState = 3;
 				goto e0;
 			}
 		}
@@ -1821,7 +1941,17 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 			/* All we need to do for level 1 is bump the refcount */
 			psLevel->ui32RefCount++;
 		}
-		PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
+
+		if (psLevel->ui32RefCount > psLevel->ui32NumOfEntries)
+		{
+			/* Given how the reference counting is implemented for MMU_LEVEL_2
+			 * and MMU_LEVEL_3 this should never happen for those levels. Only
+			 * in case of MMU_LEVEL_1 this should be possible (e.g. when someone
+			 * takes multiple reservations of the same range). In such case
+			 * return error to prevent reference count to rollover. */
+			uiAllocState = 4;
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_BAD_MAPPING, e0);
+		}
 	}
 
 	/* Level one flushing is done when we actually write the table entries */
@@ -1831,11 +1961,11 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 		                            &psLevel->sMemDesc.psMapping->sMemHandle,
 		                            uiStartIndex * psConfig->uiBytesPerEntry + psLevel->sMemDesc.uiOffset,
 		                            (uiEndIndex - uiStartIndex) * psConfig->uiBytesPerEntry);
-		PVR_GOTO_IF_ERROR(eError, e0);
+		PVR_GOTO_IF_ERROR(eError, e1);
 	}
 
-	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_AllocLevel end: level = %d, refcount = %d",
-			aeMMULevel[uiThisLevel], psLevel->ui32RefCount));
+	MMU_OBJ_DBG((PVR_DBG_ERROR, "_MMU_AllocLevel end: level = %u, refcount = %u",
+	             aeMMULevel[uiThisLevel], psLevel->ui32RefCount));
 	return PVRSRV_OK;
 
 e0:
@@ -1844,96 +1974,133 @@ static PVRSRV_ERROR _MMU_AllocLevel(MMU_CONTEXT *psMMUContext,
 	PVR_DPF((PVR_DBG_ERROR, "_MMU_AllocLevel: Error %d allocating Px for level %d in stage %d"
 			,eError, aeMMULevel[uiThisLevel], uiAllocState));
 
+	/* In case of an error process current `i` in special way without
+	 * recursively calling `_MMU_FreeLevel()`. */
+
+	if (aeMMULevel[uiThisLevel] != MMU_LEVEL_1)
+	{
+		/* If this is not a PT (so it's a PC or PD) it means that an error
+		 * happened either during PT or PD allocation/setup.
+		 *
+		 * - If the error happened during PT allocation/setup it means that
+		 *   we're at the PD level now and we already run below `else` clause
+		 *   for the failing PT and the `for` loop below for the other PTs. This
+		 *   means that all of the PTs that have been referenced during this
+		 *   operation have been dereferenced. So we just need to free that
+		 *   failing PT here and the rest of them in the loop below.
+		 * - If the error happened during PD allocation/setup it means that
+		 *   we're at the PC level now and we already run below `else` clause
+		 *   for the failing PD and the `for` loop below for the other PDs. This
+		 *   means that all of the PTs that have been allocated during this
+		 *   operation for the failing PD have been freed. So we just need to
+		 *   free that failing PD and the rest of them in a recursive manner
+		 *   in the loop below. */
+		if (uiAllocState >= 3)
+		{
+			if (psLevel->apsNextLevel[i] != NULL &&
+			    psLevel->apsNextLevel[i]->ui32RefCount == 0)
+			{
+				psLevel->ui32RefCount--;
+			}
+		}
+		if (uiAllocState >= 2)
+		{
+			if (psLevel->apsNextLevel[i] != NULL &&
+			    psLevel->apsNextLevel[i]->ui32RefCount == 0)
+			{
+				_PxMemFree(psMMUContext, &psLevel->apsNextLevel[i]->sMemDesc,
+				           aeMMULevel[uiThisLevel + 1]);
+			}
+		}
+		if (psLevel->apsNextLevel[i] != NULL &&
+		    psLevel->apsNextLevel[i]->ui32RefCount == 0)
+		{
+			OSFreeMem(psLevel->apsNextLevel[i]);
+			psLevel->apsNextLevel[i] = NULL;
+		}
+	}
+	else
+	{
+		/* This is a PT which means that we just need to dereference it. It's
+		 * going to be freed on the PD level in this error path in the `if`
+		 * clause above. */
+		psLevel->ui32RefCount--;
+	}
+
+	/* Check we haven't wrapped around */
+	PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
+
+e1:
+	i--;
+
 	/* The start value of index variable i is not initialised on purpose.
 	 * This clean-up loop deinitialises what was already initialised in
 	 * reverse order, so the i index already has the correct value.
 	 */
-	for (/* i already set */; i>= uiStartIndex && i< uiEndIndex; i--)
+	for (/* i already set */; i >= uiStartIndex && i < uiEndIndex; i--)
 	{
-		switch (uiAllocState)
+		if (aeMMULevel[uiThisLevel] != MMU_LEVEL_1)
 		{
 			IMG_UINT32 uiNextStartIndex;
 			IMG_UINT32 uiNextEndIndex;
 			IMG_BOOL bNextFirst;
 			IMG_BOOL bNextLast;
 
-			case 3:
-				/* If we're crossing a Px then the start index changes */
-				if (bFirst && (i == uiStartIndex))
-				{
-					uiNextStartIndex = auiStartArray[uiThisLevel + 1];
-					bNextFirst = IMG_TRUE;
-				}
-				else
-				{
-					uiNextStartIndex = 0;
-					bNextFirst = IMG_FALSE;
-				}
-
-				/* If we're crossing a Px then the end index changes */
-				if (bLast && (i == (uiEndIndex - 1)))
-				{
-					uiNextEndIndex = auiEndArray[uiThisLevel + 1];
-					bNextLast = IMG_TRUE;
-				}
-				else
-				{
-					uiNextEndIndex = auiEntriesPerPxArray[uiThisLevel + 1];
-					bNextLast = IMG_FALSE;
-				}
-
-				if (aeMMULevel[uiThisLevel] != MMU_LEVEL_1)
-				{
-					(*pui32CurrentLevel)++;
-					if (_MMU_FreeLevel(psMMUContext, psLevel->apsNextLevel[i],
-					                   auiStartArray, auiEndArray,
-					                   auiEntriesPerPxArray, apsConfig,
-					                   aeMMULevel, pui32CurrentLevel,
-					                   uiNextStartIndex, uiNextEndIndex,
-					                   bNextFirst, bNextLast, uiLog2DataPageSize))
-					{
-						psLevel->ui32RefCount--;
-						psLevel->apsNextLevel[i] = NULL;
+			/* If we're crossing a Px then the start index changes */
+			if (bFirst && (i == uiStartIndex))
+			{
+				uiNextStartIndex = auiStartArray[uiThisLevel + 1];
+				bNextFirst = IMG_TRUE;
+			}
+			else
+			{
+				uiNextStartIndex = 0;
+				bNextFirst = IMG_FALSE;
+			}
 
-						/* Check we haven't wrapped around */
-						PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
-					}
-					(*pui32CurrentLevel)--;
-				}
-				else
-				{
-					/* We should never come down this path, but it's here
-					   for completeness */
-					psLevel->ui32RefCount--;
+			/* If we're crossing a Px then the end index changes */
+			if (bLast && (i == (uiEndIndex - 1)))
+			{
+				uiNextEndIndex = auiEndArray[uiThisLevel + 1];
+				bNextLast = IMG_TRUE;
+			}
+			else
+			{
+				uiNextEndIndex = auiEntriesPerPxArray[uiThisLevel + 1];
+				bNextLast = IMG_FALSE;
+			}
 
-					/* Check we haven't wrapped around */
-					PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
-				}
+			(*pui32CurrentLevel)++;
+			if (_MMU_FreeLevel(psMMUContext, psLevel->apsNextLevel[i],
+			                   auiStartArray, auiEndArray,
+			                   auiEntriesPerPxArray, apsConfig,
+			                   aeMMULevel, pui32CurrentLevel,
+			                   uiNextStartIndex, uiNextEndIndex,
+			                   bNextFirst, bNextLast, uiLog2DataPageSize))
+			{
+				_PxMemFree(psMMUContext, &psLevel->apsNextLevel[i]->sMemDesc,
+				           aeMMULevel[uiThisLevel + 1]);
+				OSFreeMem(psLevel->apsNextLevel[i]);
+				psLevel->apsNextLevel[i] = NULL;
 
-				__fallthrough;
-			case 2:
-				if (psLevel->apsNextLevel[i] != NULL  &&
-						psLevel->apsNextLevel[i]->ui32RefCount == 0)
-				{
-					_PxMemFree(psMMUContext, &psLevel->sMemDesc,
-					           aeMMULevel[uiThisLevel]);
-				}
+				psLevel->ui32RefCount--;
 
-				__fallthrough;
-			case 1:
-				if (psLevel->apsNextLevel[i] != NULL  &&
-						psLevel->apsNextLevel[i]->ui32RefCount == 0)
-				{
-					OSFreeMem(psLevel->apsNextLevel[i]);
-					psLevel->apsNextLevel[i] = NULL;
-				}
+				/* Check we haven't wrapped around */
+				PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
+			}
+			(*pui32CurrentLevel)--;
+		}
+		else
+		{
+			/* We should never come down this path, but it's here
+			   for completeness */
+			psLevel->ui32RefCount--;
 
-				__fallthrough;
-			case 0:
-				uiAllocState = 3;
-				break;
+			/* Check we haven't wrapped around */
+			PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
 		}
 	}
+
 	return eError;
 }
 
@@ -2101,6 +2268,10 @@ _AllocPageTables(MMU_CONTEXT *psMMUContext,
 	const MMU_DEVVADDR_CONFIG	*psDevVAddrConfig;
 	IMG_HANDLE hPriv;
 	IMG_UINT32 ui32CurrentLevel = 0;
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	IMG_DEV_VIRTADDR sRunningDevVAddrStart;
+	IMG_BOOL bSetParity;
+#endif
 
 	PVR_DPF((PVR_DBG_ALLOC,
 			"_AllocPageTables: vaddr range: "IMG_DEV_VIRTADDR_FMTSPEC":"IMG_DEV_VIRTADDR_FMTSPEC,
@@ -2122,6 +2293,16 @@ _AllocPageTables(MMU_CONTEXT *psMMUContext,
 	                  auiEntriesPerPx, apsConfig, aeMMULevel,
 	                  &psDevVAddrConfig, &hPriv);
 
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	bSetParity = apsConfig[aeMMULevel[MMU_LEVEL_1]]->uiParityBitMask != 0;
+	if (bSetParity)
+	{
+		/* If parity bit needs to be written for PTEs save the first VA of the PT */
+		sRunningDevVAddrStart.uiAddr = sDevVAddrStart.uiAddr & ~((IMG_UINT64)(auiEntriesPerPx[MMU_LEVEL_1] * (1 << uiLog2DataPageSize)) - 1);
+	}
+
+#endif
+
 	HTBLOGK(HTB_SF_MMU_PAGE_OP_ALLOC,
 	        HTBLOG_U64_BITS_HIGH(sDevVAddrStart.uiAddr), HTBLOG_U64_BITS_LOW(sDevVAddrStart.uiAddr),
 	        HTBLOG_U64_BITS_HIGH(sDevVAddrEnd.uiAddr), HTBLOG_U64_BITS_LOW(sDevVAddrEnd.uiAddr));
@@ -2130,8 +2311,18 @@ _AllocPageTables(MMU_CONTEXT *psMMUContext,
 	                         auiStartArray, auiEndArray, auiEntriesPerPx,
 	                         apsConfig, aeMMULevel, &ui32CurrentLevel,
 	                         auiStartArray[0], auiEndArray[0],
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	                         &sRunningDevVAddrStart,
+#endif
 	                         IMG_TRUE, IMG_TRUE, uiLog2DataPageSize);
 
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP) && defined(DEBUG)
+	if (bSetParity)
+	{
+		PVR_ASSERT(sRunningDevVAddrStart.uiAddr >= sDevVAddrEnd.uiAddr);
+	}
+#endif
+
 	_MMU_PutLevelData(psMMUContext, hPriv);
 
 	return eError;
@@ -2216,17 +2407,18 @@ static void _FreePageTables(MMU_CONTEXT *psMMUContext,
 
 @Output         pui32PTEIndex           Index into the PT the address corresponds to
 
-@Return         None
+@Return         IMG_TRUE if the operation was successful and IMG_FALSE otherwise
  */
 /*****************************************************************************/
-static INLINE void _MMU_GetPTInfo(MMU_CONTEXT                *psMMUContext,
-                                  IMG_DEV_VIRTADDR            sDevVAddr,
-                                  const MMU_DEVVADDR_CONFIG  *psDevVAddrConfig,
-                                  MMU_Levelx_INFO           **ppsLevel,
-                                  IMG_UINT32                 *pui32PTEIndex)
+static INLINE IMG_BOOL _MMU_GetPTInfo(MMU_CONTEXT                *psMMUContext,
+                                      IMG_DEV_VIRTADDR            sDevVAddr,
+                                      const MMU_DEVVADDR_CONFIG  *psDevVAddrConfig,
+                                      MMU_Levelx_INFO           **ppsLevel,
+                                      IMG_UINT32                 *pui32PTEIndex)
 {
 	MMU_Levelx_INFO *psLocalLevel = NULL;
 	MMU_LEVEL eMMULevel = psMMUContext->psDevAttrs->psBaseConfig->ePxLevel;
+	const MMU_LEVEL eMMUBaseLevel = eMMULevel;
 	IMG_UINT32 uiPCEIndex;
 	IMG_UINT32 uiPDEIndex;
 
@@ -2240,7 +2432,7 @@ static INLINE void _MMU_GetPTInfo(MMU_CONTEXT                *psMMUContext,
 	{
 		if (eMMULevel == MMU_LEVEL_3)
 		{
-			/* find the page directory containing the PCE */
+			/* find the page directory pointed by the PCE */
 			uiPCEIndex = _CalcPCEIdx (sDevVAddr, psDevVAddrConfig,
 			                          IMG_FALSE);
 			psLocalLevel = psMMUContext->sBaseLevelInfo.apsNextLevel[uiPCEIndex];
@@ -2248,32 +2440,39 @@ static INLINE void _MMU_GetPTInfo(MMU_CONTEXT                *psMMUContext,
 
 		if (eMMULevel == MMU_LEVEL_2)
 		{
-			/* find the page table containing the PDE */
-			uiPDEIndex = _CalcPDEIdx (sDevVAddr, psDevVAddrConfig,
-			                          IMG_FALSE);
-			if (psLocalLevel != NULL)
-			{
-				psLocalLevel = psLocalLevel->apsNextLevel[uiPDEIndex];
-			}
-			else
+			/* find the page table pointed by the PDE */
+			uiPDEIndex = _CalcPDEIdx(sDevVAddr, psDevVAddrConfig, IMG_FALSE);
+			if (psLocalLevel == NULL)
 			{
-				psLocalLevel =
-						psMMUContext->sBaseLevelInfo.apsNextLevel[uiPDEIndex];
+				return IMG_FALSE;
 			}
+
+			psLocalLevel = psLocalLevel->apsNextLevel[uiPDEIndex];
 		}
 
 		if (eMMULevel == MMU_LEVEL_1)
 		{
 			/* find PTE index into page table */
-			*pui32PTEIndex = _CalcPTEIdx (sDevVAddr, psDevVAddrConfig,
-			                              IMG_FALSE);
+			*pui32PTEIndex = _CalcPTEIdx(sDevVAddr, psDevVAddrConfig, IMG_FALSE);
+
 			if (psLocalLevel == NULL)
 			{
-				psLocalLevel = &psMMUContext->sBaseLevelInfo;
+				if (eMMUBaseLevel == eMMULevel)
+				{
+					/* if the MMU only supports one level return the base level */
+					psLocalLevel = &psMMUContext->sBaseLevelInfo;
+				}
+				else
+				{
+					return IMG_FALSE;
+				}
 			}
 		}
 	}
+
 	*ppsLevel = psLocalLevel;
+
+	return IMG_TRUE;
 }
 
 /*************************************************************************/ /*!
@@ -2355,14 +2554,52 @@ static INLINE void _MMU_PutPTConfig(MMU_CONTEXT *psMMUContext,
 
 /* scratch / zero pages */
 
-static PVRSRV_ERROR _MMU_GetBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
-                                        PVRSRV_DEF_PAGE *psDefPage,
-                                        IMG_INT uiInitValue,
-                                        IMG_CHAR *pcDefPageName,
-                                        IMG_BOOL bInitPage)
+static INLINE PVRSRV_ERROR _MMU_GetDefPage(PVRSRV_DEVICE_NODE *psDevNode,
+                                           IMG_INT uiDefPage,
+                                           PVRSRV_DEF_PAGE **ppsDefPage,
+                                           IMG_CHAR **ppcDefPageName)
+{
+	switch (uiDefPage)
+	{
+		case SCRATCH_PAGE:
+		{
+			*ppsDefPage = &psDevNode->sScratchPage;
+#if defined(PDUMP)
+			*ppcDefPageName = SCRATCH_PAGE_STR;
+#endif
+			break;
+		}
+		case DEV_ZERO_PAGE:
+		{
+			*ppsDefPage = &psDevNode->sDevZeroPage;
+#if defined(PDUMP)
+			*ppcDefPageName = DEV_ZERO_PAGE_STR;
+#endif
+			break;
+		}
+		default:
+		{
+			/* Invalid pcDefPageName */
+			return PVRSRV_ERROR_INVALID_PARAMS;
+		}
+	}
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR _MMU_AllocBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
+                                          IMG_INT uiInitValue,
+                                          IMG_INT uiDefPage)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_DEV_PHYADDR	sDevPAddr = {0};
+	PVRSRV_DEF_PAGE *psDefPage;
+	IMG_CHAR *pcDefPageName;
+
+	eError = _MMU_GetDefPage(psDevNode,
+	                         uiDefPage,
+	                         &psDefPage,
+	                         &pcDefPageName);
+	PVR_RETURN_IF_ERROR(eError);
 
 	OSLockAcquire(psDefPage->psPgLock);
 
@@ -2382,7 +2619,7 @@ static PVRSRV_ERROR _MMU_GetBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
 	                         (1 << psDefPage->ui32Log2PgSize),
 	                         0,
 	                         uiInitValue,
-	                         bInitPage,
+	                         IMG_TRUE,
 #if defined(PDUMP)
 	                         psDevNode->psMMUDevAttrs->pszMMUPxPDumpMemSpaceName,
 	                         pcDefPageName,
@@ -2391,7 +2628,6 @@ static PVRSRV_ERROR _MMU_GetBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
 	                         PVR_SYS_ALLOC_PID,
 	                         &psDefPage->sPageHandle,
 	                         &sDevPAddr);
-	PVR_GOTO_IF_ERROR(eError, UnlockAndReturn);
 
 	psDefPage->ui64PgPhysAddr = sDevPAddr.uiAddr;
 
@@ -2401,10 +2637,53 @@ static PVRSRV_ERROR _MMU_GetBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
 	return eError;
 }
 
+static PVRSRV_ERROR _MMU_GetBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
+                                        IMG_UINT64 *pui64PgPhysAddr,
+                                        IMG_INT uiDefPage)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_DEF_PAGE *psDefPage;
+	IMG_CHAR *pcDefPageName;
+
+	eError = _MMU_GetDefPage(psDevNode,
+	                         uiDefPage,
+	                         &psDefPage,
+	                         &pcDefPageName);
+	PVR_RETURN_IF_ERROR(eError);
+
+	OSLockAcquire(psDefPage->psPgLock);
+
+	if (psDefPage->ui64PgPhysAddr == MMU_BAD_PHYS_ADDR)
+	{
+		eError = PVRSRV_ERROR_NOT_FOUND;
+		PVR_DPF((PVR_DBG_ERROR,"%s: %s (uiDefPage=%d)",
+		         __func__, PVRSRVGetErrorString(eError), uiDefPage));
+		goto UnlockAndReturn;
+	}
+
+	if (pui64PgPhysAddr)
+		*pui64PgPhysAddr = psDefPage->ui64PgPhysAddr;
+
+UnlockAndReturn:
+	OSLockRelease(psDefPage->psPgLock);
+
+	return eError;
+}
+
 static void _MMU_FreeBackingPage(PVRSRV_DEVICE_NODE *psDevNode,
-                                 PVRSRV_DEF_PAGE *psDefPage,
-                                 IMG_CHAR *pcDefPageName)
+                                 IMG_INT uiDefPage)
 {
+	PVRSRV_DEF_PAGE *psDefPage;
+	IMG_CHAR *pcDefPageName;
+	PVRSRV_ERROR eErr;
+
+	eErr = _MMU_GetDefPage(psDevNode,
+	                       uiDefPage,
+	                       &psDefPage,
+	                       &pcDefPageName);
+	if (eErr != PVRSRV_OK)
+		return;
+
 	OSLockAcquire(psDefPage->psPgLock);
 
 	if (psDefPage->ui64PgPhysAddr == MMU_BAD_PHYS_ADDR)
@@ -2476,31 +2755,25 @@ PVRSRV_ERROR MMU_InitDevice(struct _PVRSRV_DEVICE_NODE_ *psDevNode)
 #ifdef PDUMP
 	psDevNode->sScratchPage.hPdumpPg = NULL;
 	psDevNode->sDevZeroPage.hPdumpPg = NULL;
-
-	eError = _MMU_GetBackingPage(psDevNode,
-	                             &psDevNode->sScratchPage,
-	                             PVR_SCRATCH_PAGE_INIT_VALUE,
-	                             SCRATCH_PAGE,
-	                             IMG_TRUE);
-	PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage.Scratch", ErrFreeZeroPageLock);
-
-	eError = _MMU_GetBackingPage(psDevNode,
-	                             &psDevNode->sDevZeroPage,
-	                             PVR_ZERO_PAGE_INIT_VALUE,
-	                             DEV_ZERO_PAGE,
-	                             IMG_TRUE);
-	PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage.Zero", ErrFreeScratchPage);
 #endif /* PDUMP */
 
+	eError = _MMU_AllocBackingPage(psDevNode,
+	                               PVR_SCRATCH_PAGE_INIT_VALUE,
+	                               SCRATCH_PAGE);
+	PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_AllocBackingPage.Scratch", ErrFreeZeroPageLock);
+
+	eError = _MMU_AllocBackingPage(psDevNode,
+	                               PVR_ZERO_PAGE_INIT_VALUE,
+	                               DEV_ZERO_PAGE);
+	PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_AllocBackingPage.Zero", ErrFreeScratchPage);
+
 	return PVRSRV_OK;
 
-#ifdef PDUMP
 ErrFreeScratchPage:
-	_MMU_FreeBackingPage(psDevNode, &psDevNode->sScratchPage, SCRATCH_PAGE);
+	_MMU_FreeBackingPage(psDevNode, SCRATCH_PAGE);
 ErrFreeZeroPageLock:
 	OSLockDestroy(psDevNode->sDevZeroPage.psPgLock);
 	psDevNode->sDevZeroPage.psPgLock = NULL;
-#endif /* PDUMP */
 ErrFreeScratchPageLock:
 	OSLockDestroy(psDevNode->sScratchPage.psPgLock);
 	psDevNode->sScratchPage.psPgLock = NULL;
@@ -2515,7 +2788,7 @@ void MMU_DeInitDevice(struct _PVRSRV_DEVICE_NODE_ *psDevNode)
 {
 	if (psDevNode->sScratchPage.psPgLock != NULL)
 	{
-		_MMU_FreeBackingPage(psDevNode, &psDevNode->sScratchPage, SCRATCH_PAGE);
+		_MMU_FreeBackingPage(psDevNode, SCRATCH_PAGE);
 
 		OSLockDestroy(psDevNode->sScratchPage.psPgLock);
 		psDevNode->sScratchPage.psPgLock = NULL;
@@ -2523,7 +2796,7 @@ void MMU_DeInitDevice(struct _PVRSRV_DEVICE_NODE_ *psDevNode)
 
 	if (psDevNode->sDevZeroPage.psPgLock)
 	{
-		_MMU_FreeBackingPage(psDevNode, &psDevNode->sDevZeroPage, DEV_ZERO_PAGE);
+		_MMU_FreeBackingPage(psDevNode, DEV_ZERO_PAGE);
 
 
 		OSLockDestroy(psDevNode->sDevZeroPage.psPgLock);
@@ -2622,12 +2895,12 @@ MMU_ContextCreate(CONNECTION_DATA *psConnection,
 	psPhysMemCtx->pszPhysMemRAName = OSAllocMem(psPhysMemCtx->uiPhysMemRANameAllocSize);
 	PVR_LOG_GOTO_IF_NOMEM(psPhysMemCtx->pszPhysMemRAName, eError, e2);
 
-	OSStringLCopy(psPhysMemCtx->pszPhysMemRAName, sBuf, psPhysMemCtx->uiPhysMemRANameAllocSize);
+	OSStringSafeCopy(psPhysMemCtx->pszPhysMemRAName, sBuf, psPhysMemCtx->uiPhysMemRANameAllocSize);
 
 	psPhysMemCtx->psPhysMemRA = RA_Create(psPhysMemCtx->pszPhysMemRAName,
 	                                      /* subsequent import */
 	                                      PhysHeapGetPageShift(psDevNode->psMMUPhysHeap),
-	                                      RA_LOCKCLASS_1,
+	                                      RA_LOCKCLASS_2,
 	                                      _MMU_PhysMem_RAImportAlloc,
 	                                      _MMU_PhysMem_RAImportFree,
 	                                      psPhysMemCtx, /* priv */
@@ -2660,16 +2933,26 @@ MMU_ContextCreate(CONNECTION_DATA *psConnection,
 	         might request the base object address so we allocate
 	         it up front.
 	         In VZ we only need to allocate the FW/KM ctx on the
-	         Host machine as all Guest tables are alloc'd and pre-mapped into
-	         the host FW Memory Context.
+	         Host Driver as all Guest tables are allocated and
+	         pre-mapped into the host FW Memory Context.
+	         Drivers with security support and premapped heaps
+	         rely on the TEE to manage the Firmware mappings.
 	 */
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	if (!_MMU_IS_FWKM_CTX(psMMUContext))
+#else
 	if (!_MMU_IS_FWKM_CTX_VZGUEST(psMMUContext))
+#endif
 	{
 		if (_PxMemAlloc(psMMUContext,
 						ui32BaseObjects,
 						psConfig,
 						psDevAttrs->psBaseConfig->ePxLevel,
 						&psMMUContext->sBaseLevelInfo.sMemDesc,
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+						NULL,
+						0U,
+#endif
 						psDevAttrs->ui32BaseAlign))
 		{
 			PVR_LOG_GOTO_WITH_ERROR("_PxMemAlloc", eError, PVRSRV_ERROR_OUT_OF_MEMORY, e5);
@@ -2752,7 +3035,12 @@ MMU_ContextDestroy (MMU_CONTEXT *psMMUContext)
 	/* Free the top level MMU object - will be put on defer free list.
 	 * This has to be done before the step below that will empty the
 	 * defer-free list. */
+
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	if (!_MMU_IS_FWKM_CTX(psMMUContext))
+#else
 	if (!_MMU_IS_FWKM_CTX_VZGUEST(psMMUContext))
+#endif
 	{
 		_PxMemFree(psMMUContext,
 		           &psMMUContext->sBaseLevelInfo.sMemDesc,
@@ -2814,7 +3102,6 @@ MMU_ContextDestroy (MMU_CONTEXT *psMMUContext)
 PVRSRV_ERROR
 MMU_Alloc (MMU_CONTEXT *psMMUContext,
            IMG_DEVMEM_SIZE_T uSize,
-           IMG_DEVMEM_SIZE_T *puActualSize,
            IMG_UINT32 uiProtFlags,
            IMG_DEVMEM_SIZE_T uDevVAddrAlignment,
            IMG_DEV_VIRTADDR *psDevVAddr,
@@ -2831,6 +3118,7 @@ MMU_Alloc (MMU_CONTEXT *psMMUContext,
 	IMG_HANDLE hPriv;
 
 #if !defined(DEBUG)
+	PVR_UNREFERENCED_PARAMETER(uiProtFlags);
 	PVR_UNREFERENCED_PARAMETER(uDevVAddrAlignment);
 #endif
 
@@ -2842,7 +3130,6 @@ MMU_Alloc (MMU_CONTEXT *psMMUContext,
 	/* check params */
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psMMUContext, "psMMUContext");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psDevVAddr, "psDevVAddr");
-	PVR_LOG_RETURN_IF_INVALID_PARAM(puActualSize, "puActualSize");
 
 	psDevAttrs = psMMUContext->psDevAttrs;
 
@@ -2869,17 +3156,13 @@ MMU_Alloc (MMU_CONTEXT *psMMUContext,
 	OSLockAcquire(psMMUContext->hLock);
 
 
-	/* This is to divert generation of firmware pre-mapped page
-	 * tables to a stand alone MMU driver. */
-	if ((psDevAttrs->pfnTestPremapConfigureMMU != NULL) &&
-			_MMU_IS_FWKM_CTX(psMMUContext))
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	if (_MMU_IS_FWKM_CTX(psMMUContext))
 	{
-		eError = psDevAttrs->pfnTestPremapConfigureMMU(
-				psMMUContext->psPhysMemCtx->psDevNode, psMMUContext,
-				*psDevVAddr, sDevVAddrEnd,
-				uiLog2PageSize);
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: Driver relying on firmware mappings created by the TEE.", __func__));
 	}
 	else
+#endif
 	{
 		eError = _AllocPageTables(psMMUContext, *psDevVAddr, sDevVAddrEnd, uiLog2PageSize);
 	}
@@ -2912,27 +3195,6 @@ MMU_Free (MMU_CONTEXT *psMMUContext,
 	PVRSRV_ERROR eError;
 #endif
 
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION) && defined(__linux__)
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-	IMG_UINT32 ui32MMULeakMax = psPVRSRVData->sMemLeakIntervals.ui32MMU;
-
-	mutex_lock(&g_sMMULeakMutex);
-
-	g_ui32MMULeakCounter++;
-	if (ui32MMULeakMax && g_ui32MMULeakCounter >= ui32MMULeakMax)
-	{
-		g_ui32MMULeakCounter = 0;
-		mutex_unlock(&g_sMMULeakMutex);
-
-		PVR_DPF((PVR_DBG_WARNING,
-		         "%s: Skipped MMU free for address 0x%016" IMG_UINT64_FMTSPECx " to trigger memory leak.",
-		         __func__,
-		         sDevVAddr.uiAddr));
-		return;
-	}
-
-	mutex_unlock(&g_sMMULeakMutex);
-#endif
 
 	PVR_ASSERT(psMMUContext != NULL);
 	PVR_LOG_RETURN_VOID_IF_FALSE(psMMUContext != NULL, "psMMUContext");
@@ -2953,10 +3215,15 @@ MMU_Free (MMU_CONTEXT *psMMUContext,
 
 	OSLockAcquire(psMMUContext->hLock);
 
-	_FreePageTables(psMMUContext,
-	                sDevVAddr,
-	                sDevVAddrEnd,
-	                uiLog2DataPageSize);
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	if (!_MMU_IS_FWKM_CTX(psMMUContext))
+#endif
+	{
+		_FreePageTables(psMMUContext,
+		                sDevVAddr,
+		                sDevVAddrEnd,
+		                uiLog2DataPageSize);
+	}
 
 #if defined(SUPPORT_MMU_DEFERRED_FREE)
 	eError = PVRSRVGetDevicePowerState(psPhysMemCtx->psDevNode, &ePowerState);
@@ -3112,21 +3379,6 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 		{
 			bZeroBacking = PVRSRV_IS_ZERO_BACKING_REQUIRED(PMR_Flags(psPMR));
 		}
-
-		if (PVRSRV_CHECK_GPU_CACHE_COHERENT(uiMappingFlags))
-		{
-			/* Obtain non-coherent protection flags as we cannot have multiple coherent
-			   virtual pages pointing to the same physical page so all scratch page
-			   mappings have to be non-coherent even in a coherent allocation */
-			eError = _MMU_ConvertDevMemFlags(IMG_FALSE,
-									uiMappingFlags & ~PVRSRV_MEMALLOCFLAG_GPU_CACHE_COHERENT,
-									&uiMMUProtFlags,
-									psMMUContext);
-			PVR_GOTO_IF_ERROR(eError, ErrPutPTConfig);
-
-			/* We've already validated possible values of uiBytesPerEntry at the start of this function */
-			PVR_ASSERT(psConfig->uiBytesPerEntry == 4 || psConfig->uiBytesPerEntry == 8);
-		}
 	}
 
 	OSLockAcquire(psMMUContext->hLock);
@@ -3174,28 +3426,21 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 				if (bZeroBacking)
 				{
 					eError = _MMU_GetBackingPage(psDevNode,
-					                             &psDevNode->sDevZeroPage,
-					                             PVR_ZERO_PAGE_INIT_VALUE,
-					                             DEV_ZERO_PAGE,
-					                             IMG_TRUE);
+					                             &sDevPAddr.uiAddr,
+					                             DEV_ZERO_PAGE);
 					PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage",
 					                      ErrUnlockAndUnmapPages);
 
-					sDevPAddr.uiAddr = psDevNode->sDevZeroPage.ui64PgPhysAddr;
 					/* Ensure the zero back page PTE is read only */
 					uiDefProtFlags = uiProtFlagsReadOnly;
 				}
 				else
 				{
 					eError = _MMU_GetBackingPage(psDevNode,
-					                             &psDevNode->sScratchPage,
-					                             PVR_SCRATCH_PAGE_INIT_VALUE,
-					                             SCRATCH_PAGE,
-					                             IMG_TRUE);
+					                             &sDevPAddr.uiAddr,
+					                             SCRATCH_PAGE);
 					PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage",
 					                      ErrUnlockAndUnmapPages);
-
-					sDevPAddr.uiAddr = psDevNode->sScratchPage.ui64PgPhysAddr;
 				}
 			}
 			else
@@ -3216,14 +3461,14 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 					if (0 > i32FeatureVal)
 						break;
 
-					if (ui32BitLength > i32FeatureVal)
+					if (ui32BitLength > (IMG_UINT32) i32FeatureVal)
 					{
 						PVR_DPF((PVR_DBG_ERROR,
-								"%s Failed. The physical address bitlength (%d)"
+								"%s Failed. The physical address bitlength (%u)"
 								" is greater than the chip can handle (%d).",
 								__func__, ui32BitLength, i32FeatureVal));
 
-						PVR_ASSERT(ui32BitLength <= i32FeatureVal);
+						PVR_ASSERT(ui32BitLength <= (IMG_UINT32) i32FeatureVal);
 						eError = PVRSRV_ERROR_INVALID_PARAMS;
 						goto ErrUnlockAndUnmapPages;
 					}
@@ -3245,8 +3490,12 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 
 			psPrevLevel = psLevel;
 			/* Calculate PT index and get new table descriptor */
-			_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
-			               &psLevel, &uiPTEIndex);
+			if (!_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
+			                    &psLevel, &uiPTEIndex))
+			{
+				PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_MAPPING_NOT_FOUND,
+				                    ErrUnlockAndUnmapPages);
+			}
 
 			if (psPrevLevel == psLevel)
 			{
@@ -3286,10 +3535,11 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 			                   uiPTEIndex,
 			                   psConfig,
 			                   &sDevPAddr,
+			                   &sDevVAddr,
 			                   IMG_FALSE,
 #if defined(PDUMP)
 			                   (bValid)?aszMemspaceName:(psMMUContext->psDevAttrs->pszMMUPxPDumpMemSpaceName),
-			                          ((bValid)?aszSymbolicAddress:((bZeroBacking)?DEV_ZERO_PAGE:SCRATCH_PAGE)),
+			                          ((bValid)?aszSymbolicAddress:((bZeroBacking)?DEV_ZERO_PAGE_STR:SCRATCH_PAGE_STR)),
 			                          (bValid)?uiSymbolicAddrOffset:0,
 #endif /*PDUMP*/
 			                    uiDefProtFlags);
@@ -3345,20 +3595,20 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 	return PVRSRV_OK;
 
 ErrUnlockAndUnmapPages:
-	OSLockRelease(psMMUContext->hLock);
-
 	if (PMR_IsSparse(psPMR) && PVRSRV_IS_SPARSE_SCRATCH_BACKING_REQUIRED(uiMappingFlags))
 	{
 		bNeedBacking = IMG_TRUE;
 	}
 
-	MMU_UnmapPages(psMMUContext,
-	               (bNeedBacking) ? uiMappingFlags : 0,
-	               sDevVAddrBase,
-	               uiLoop,
-	               paui32MapIndices,
-	               uiLog2HeapPageSize,
-	               uiMappingFlags);
+	(void) MMU_UnmapPagesUnlocked(psMMUContext,
+	                              (bNeedBacking) ? uiMappingFlags : 0,
+	                              sDevVAddrBase,
+	                              uiLoop,
+	                              paui32MapIndices,
+	                              uiLog2HeapPageSize,
+	                              uiMappingFlags);
+
+	OSLockRelease(psMMUContext->hLock);
 ErrPutPTConfig:
 	_MMU_PutPTConfig(psMMUContext, hPriv);
 ErrFreeValidArray:
@@ -3375,18 +3625,16 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 	return eError;
 }
 
-/*
-	MMU_UnmapPages
- */
-void
-MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
-               PVRSRV_MEMALLOCFLAGS_T uiMappingFlags,
-               IMG_DEV_VIRTADDR sDevVAddrBase,
-               IMG_UINT32 ui32PageCount,
-               IMG_UINT32 *pai32FreeIndices,
-               IMG_UINT32 uiLog2PageSize,
-               PVRSRV_MEMALLOCFLAGS_T uiMemAllocFlags)
+static PVRSRV_ERROR
+MMU_UnmapPagesUnlocked(MMU_CONTEXT *psMMUContext,
+                       PVRSRV_MEMALLOCFLAGS_T uiMappingFlags,
+                       IMG_DEV_VIRTADDR sDevVAddrBase,
+                       IMG_UINT32 ui32PageCount,
+                       IMG_UINT32 *pai32FreeIndices,
+                       IMG_UINT32 uiLog2PageSize,
+                       PVRSRV_MEMALLOCFLAGS_T uiMemAllocFlags)
 {
+	PVRSRV_ERROR eError;
 	IMG_UINT32 uiPTEIndex = 0, ui32Loop=0;
 	IMG_UINT32 uiPageSize = 1 << uiLog2PageSize;
 	IMG_UINT32 uiFlushEnd = 0, uiFlushStart = 0;
@@ -3411,22 +3659,33 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 	             (IMG_UINT64)sDevVAddr.uiAddr,
 	             ((IMG_UINT64)sDevVAddr.uiAddr) + (uiPageSize*ui32PageCount)-1);
 #endif
+
+	PVR_ASSERT(OSLockIsLocked(psMMUContext->hLock));
+
 	bScratchBacking = PVRSRV_IS_SPARSE_SCRATCH_BACKING_REQUIRED(uiMemAllocFlags);
 	bZeroBacking = PVRSRV_IS_ZERO_BACKING_REQUIRED(uiMemAllocFlags);
 
 	if (bZeroBacking)
 	{
-		sBackingPgDevPhysAddr.uiAddr = psDevNode->sDevZeroPage.ui64PgPhysAddr;
+		/* Ensure the zero backing page has been created */
+		eError = _MMU_GetBackingPage(psDevNode,
+		                             &sBackingPgDevPhysAddr.uiAddr,
+		                             DEV_ZERO_PAGE);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_MMU_GetBackingPage (zero)");
 	}
 	else
 	{
-		sBackingPgDevPhysAddr.uiAddr = psDevNode->sScratchPage.ui64PgPhysAddr;
+		/* Ensure the scratch backing page has been created */
+		eError = _MMU_GetBackingPage(psDevNode,
+		                             &sBackingPgDevPhysAddr.uiAddr,
+		                             SCRATCH_PAGE);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_MMU_GetBackingPage (scratch)");
 	}
 
 #if defined(PDUMP)
 	if (bScratchBacking)
 	{
-		pcBackingPageName = bZeroBacking ? DEV_ZERO_PAGE : SCRATCH_PAGE;
+		pcBackingPageName = bZeroBacking ? DEV_ZERO_PAGE_STR : SCRATCH_PAGE_STR;
 	}
 #endif
 
@@ -3435,13 +3694,11 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 	_MMU_GetPTConfig(psMMUContext, (IMG_UINT32) uiLog2PageSize,
 	                 &psConfig, &hPriv, &psDevVAddrConfig);
 
-	if (_MMU_ConvertDevMemFlags(bUnmap,
-	                            uiMappingFlags,
-	                            &uiMMUProtFlags,
-	                            psMMUContext) != PVRSRV_OK)
-	{
-		return;
-	}
+	eError = _MMU_ConvertDevMemFlags(bUnmap,
+	                                 uiMappingFlags,
+	                                 &uiMMUProtFlags,
+	                                 psMMUContext);
+	PVR_RETURN_IF_ERROR(eError);
 
 	uiMMUReadOnlyProtFlags = (uiMMUProtFlags & ~MMU_PROTFLAGS_WRITEABLE) | MMU_PROTFLAGS_READABLE;
 
@@ -3457,9 +3714,6 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 		uiProtFlagsReadOnly = psMMUContext->psDevAttrs->pfnDerivePTEProt8(uiMMUReadOnlyProtFlags, uiLog2PageSize);
 	}
 
-
-	OSLockAcquire(psMMUContext->hLock);
-
 	/* Unmap page by page */
 	while (ui32Loop < ui32PageCount)
 	{
@@ -3472,8 +3726,11 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 
 		psPrevLevel = psLevel;
 		/* Calculate PT index and get new table descriptor */
-		_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
-		               &psLevel, &uiPTEIndex);
+		if (!_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
+		                    &psLevel, &uiPTEIndex))
+		{
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_MAPPING_NOT_FOUND, e0);
+		}
 
 		if (psPrevLevel == psLevel)
 		{
@@ -3492,10 +3749,12 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 			/* Flush if we moved to another psLevel, i.e. page table */
 			if (psPrevLevel != NULL)
 			{
-				PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
+				PVRSRV_ERROR eError;
+				eError = PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
 				                   &psPrevLevel->sMemDesc.psMapping->sMemHandle,
 				                   uiFlushStart * psConfig->uiBytesPerEntry + psPrevLevel->sMemDesc.uiOffset,
 				                   (uiFlushEnd+1 - uiFlushStart) * psConfig->uiBytesPerEntry);
+				PVR_LOG_IF_ERROR(eError, "PhysHeapPagesClean");
 			}
 
 			uiFlushStart = uiPTEIndex;
@@ -3506,21 +3765,20 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 		        HTBLOG_U64_BITS_HIGH(sDevVAddr.uiAddr), HTBLOG_U64_BITS_LOW(sDevVAddr.uiAddr));
 
 		/* Set the PT entry to invalid and poison it with a bad address */
-		if (_SetupPTE(psMMUContext,
-		              psLevel,
-		              uiPTEIndex,
-		              psConfig,
-		              (bScratchBacking)? &sBackingPgDevPhysAddr : &gsBadDevPhyAddr,
-		              bUnmap,
+		eError = _SetupPTE(psMMUContext,
+		                   psLevel,
+		                   uiPTEIndex,
+		                   psConfig,
+		                   (bScratchBacking)? &sBackingPgDevPhysAddr : &gsBadDevPhyAddr,
+		                   &sDevVAddr,
+		                   bUnmap,
 #if defined(PDUMP)
-		              (bScratchBacking)? (psMMUContext->psDevAttrs->pszMMUPxPDumpMemSpaceName): NULL,
-		              pcBackingPageName,
-		              0U,
+		                   (bScratchBacking)? (psMMUContext->psDevAttrs->pszMMUPxPDumpMemSpaceName): NULL,
+		                   pcBackingPageName,
+		                   0U,
 #endif
-		              (bZeroBacking)? uiProtFlagsReadOnly: uiProtFlags) != PVRSRV_OK)
-		{
-			goto e0;
-		}
+		                   (bZeroBacking)? uiProtFlagsReadOnly: uiProtFlags);
+		PVR_GOTO_IF_ERROR(eError, e0);
 
 		/* Check we haven't wrapped around */
 		PVR_ASSERT(psLevel->ui32RefCount <= psLevel->ui32NumOfEntries);
@@ -3531,14 +3789,14 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 	/* Flush the last level we touched */
 	if (psLevel != NULL)
 	{
-		PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
+		PVRSRV_ERROR eError;
+		eError = PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
 		                   &psLevel->sMemDesc.psMapping->sMemHandle,
 		                   uiFlushStart * psConfig->uiBytesPerEntry + psLevel->sMemDesc.uiOffset,
 		                   (uiFlushEnd+1 - uiFlushStart) * psConfig->uiBytesPerEntry);
+		PVR_LOG_IF_ERROR(eError, "PhysHeapPagesClean");
 	}
 
-	OSLockRelease(psMMUContext->hLock);
-
 	_MMU_PutPTConfig(psMMUContext, hPriv);
 
 	/* Flush TLB for PTs*/
@@ -3547,14 +3805,43 @@ MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
 	                                 MMU_LEVEL_1,
 	                                 IMG_TRUE);
 
-	return;
+	return PVRSRV_OK;
 
 e0:
 	_MMU_PutPTConfig(psMMUContext, hPriv);
-	PVR_DPF((PVR_DBG_ERROR, "MMU_UnmapPages: Failed to map/unmap page table"));
-	PVR_ASSERT(0);
+	PVR_DPF((PVR_DBG_ERROR, "%s: Failed to map/unmap page table "
+	         "with error %u", __func__, eError));
+
+	return eError;
+}
+
+/*
+	MMU_UnmapPages
+ */
+PVRSRV_ERROR
+MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
+               PVRSRV_MEMALLOCFLAGS_T uiMappingFlags,
+               IMG_DEV_VIRTADDR sDevVAddrBase,
+               IMG_UINT32 ui32PageCount,
+               IMG_UINT32 *pai32FreeIndices,
+               IMG_UINT32 uiLog2PageSize,
+               PVRSRV_MEMALLOCFLAGS_T uiMemAllocFlags)
+{
+	PVRSRV_ERROR eError;
+
+	OSLockAcquire(psMMUContext->hLock);
+
+	eError = MMU_UnmapPagesUnlocked(psMMUContext,
+	                                uiMappingFlags,
+	                                sDevVAddrBase,
+	                                ui32PageCount,
+	                                pai32FreeIndices,
+	                                uiLog2PageSize,
+	                                uiMemAllocFlags);
+
 	OSLockRelease(psMMUContext->hLock);
-	return;
+
+	return eError;
 }
 
 PVRSRV_ERROR
@@ -3620,42 +3907,21 @@ MMUX_MapVRangeToBackingPage(MMU_CONTEXT *psMMUContext,
 		PVR_LOG_GOTO_WITH_ERROR("psConfig->uiBytesPerEntry", eError, PVRSRV_ERROR_INVALID_PARAMS, ErrPutPTConfig);
 	}
 
-	if (PVRSRV_CHECK_GPU_CACHE_COHERENT(uiMappingFlags))
-	{
-		/* Obtain non-coherent protection flags as we cannot have multiple coherent
-		   virtual pages pointing to the same physical page so all scratch page
-		   mappings have to be non-coherent even in a coherent allocation */
-		eError = _MMU_ConvertDevMemFlags(IMG_FALSE,
-								uiMappingFlags & ~PVRSRV_MEMALLOCFLAG_GPU_CACHE_COHERENT,
-								&uiMMUProtFlags,
-								psMMUContext);
-		PVR_GOTO_IF_ERROR(eError, ErrPutPTConfig);
-
-		/* We've already validated possible values of uiBytesPerEntry at the start of this function */
-		PVR_ASSERT(psConfig->uiBytesPerEntry == 4 || psConfig->uiBytesPerEntry == 8);
-	}
-
 	if (bZeroBacking)
 	{
 		eError = _MMU_GetBackingPage(psDevNode,
-		                             &psDevNode->sDevZeroPage,
-		                             PVR_ZERO_PAGE_INIT_VALUE,
-		                             DEV_ZERO_PAGE,
-		                             IMG_TRUE);
+		                             &sDevPAddr.uiAddr,
+		                             DEV_ZERO_PAGE);
 		PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage",
 		                      ErrPutPTConfig);
-		sDevPAddr.uiAddr = psDevNode->sDevZeroPage.ui64PgPhysAddr;
 	}
 	else
 	{
 		eError = _MMU_GetBackingPage(psDevNode,
-									 &psDevNode->sScratchPage,
-									 PVR_SCRATCH_PAGE_INIT_VALUE,
-									 SCRATCH_PAGE,
-									 IMG_TRUE);
+									 &sDevPAddr.uiAddr,
+									 SCRATCH_PAGE);
 		PVR_LOG_GOTO_IF_ERROR(eError, "_MMU_GetBackingPage",
 							  ErrPutPTConfig);
-		sDevPAddr.uiAddr = psDevNode->sScratchPage.ui64PgPhysAddr;
 	}
 
 #if defined(DEBUG)
@@ -3670,14 +3936,14 @@ MMUX_MapVRangeToBackingPage(MMU_CONTEXT *psMMUContext,
 			if (0 > i32FeatureVal)
 				break;
 
-			if (ui32BitLength > i32FeatureVal)
+			if (ui32BitLength > (IMG_UINT32) i32FeatureVal)
 			{
 				PVR_DPF((PVR_DBG_ERROR,
-						"%s Failed. The physical address bitlength (%d)"
+						"%s Failed. The physical address bitlength (%u)"
 						" is greater than the chip can handle (%d).",
 						__func__, ui32BitLength, i32FeatureVal));
 
-				PVR_ASSERT(ui32BitLength <= i32FeatureVal);
+				PVR_ASSERT(ui32BitLength <= (IMG_UINT32) i32FeatureVal);
 				eError = PVRSRV_ERROR_INVALID_PARAMS;
 				goto ErrPutPTConfig;
 			}
@@ -3691,8 +3957,12 @@ MMUX_MapVRangeToBackingPage(MMU_CONTEXT *psMMUContext,
 	{
 		psPrevLevel = psLevel;
 		/* Calculate PT index and get new table descriptor */
-		_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
-		               &psLevel, &uiPTEIndex);
+		if (!_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
+		                    &psLevel, &uiPTEIndex))
+		{
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_MAPPING_NOT_FOUND,
+			                    ErrUnlockAndUnmapPages);
+		}
 
 		if (psPrevLevel == psLevel)
 		{
@@ -3732,10 +4002,11 @@ MMUX_MapVRangeToBackingPage(MMU_CONTEXT *psMMUContext,
 		                   uiPTEIndex,
 		                   psConfig,
 		                   &sDevPAddr,
+		                   &sDevVAddr,
 		                   IMG_FALSE,
 #if defined(PDUMP)
 		                   psMMUContext->psDevAttrs->pszMMUPxPDumpMemSpaceName,
-		                   bZeroBacking ? DEV_ZERO_PAGE : SCRATCH_PAGE,
+		                   bZeroBacking ? DEV_ZERO_PAGE_STR : SCRATCH_PAGE_STR,
 		                   0,
 #endif /*PDUMP*/
 		                   bZeroBacking ? uiProtFlagsReadOnly : uiProtFlags);
@@ -3767,15 +4038,15 @@ MMUX_MapVRangeToBackingPage(MMU_CONTEXT *psMMUContext,
 	return PVRSRV_OK;
 
 ErrUnlockAndUnmapPages:
-	OSLockRelease(psMMUContext->hLock);
+	(void) MMU_UnmapPagesUnlocked(psMMUContext,
+	                              0,
+	                              sDevVAddrBase,
+	                              uiLoop,
+	                              NULL,
+	                              uiLog2HeapPageSize,
+	                              uiMappingFlags);
 
-	MMU_UnmapPages(psMMUContext,
-				   0,
-				   sDevVAddrBase,
-				   uiLoop,
-				   NULL,
-				   uiLog2HeapPageSize,
-				   uiMappingFlags);
+	OSLockRelease(psMMUContext->hLock);
 ErrPutPTConfig:
 	_MMU_PutPTConfig(psMMUContext, hPriv);
 	return eError;
@@ -3799,9 +4070,12 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 	IMG_UINT32 i, uiChunkStart, uiLastPTEIndex, uiNumEntriesToWrite;
 	IMG_UINT32 ui32PagesDone=0, uiPTEIndex=0;
 
-	IMG_UINT8 uiAddrLog2Align, uiAddrShift;
+	IMG_UINT8 uiAddrLog2Align, uiAddrShift, uiParityShift;
 	IMG_UINT64 uiAddrMask, uiProtFlags;
 	IMG_UINT32 uiBytesPerEntry;
+	IMG_UINT64 uiParityBit = 0;
+	IMG_BOOL bSetParity = IMG_FALSE;
+	IMG_DEV_VIRTADDR sDevVAddrRunning, sDevVAddrBaseCopy = sDevVAddrBase;
 
 	IMG_UINT64* pui64LevelBase;
 	IMG_UINT32* pui32LevelBase;
@@ -3812,6 +4086,7 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 	IMG_BOOL abValid[PMR_MAX_TRANSLATION_STACK_ALLOC];
 	IMG_UINT32 uiNumPages = uiSizeBytes >> uiLog2HeapPageSize;
 
+
 #if defined(PVRSRV_ENABLE_HTB)
 	IMG_BOOL bHTBLog =
 	    HTB_GROUP_ENABLED(HTB_SF_MMU_PAGE_OP_PMRMAP) ||
@@ -3825,6 +4100,7 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 	IMG_CHAR aszSymbolicAddress[PHYSMEM_PDUMP_SYMNAME_MAX_LENGTH];
 	IMG_DEVMEM_OFFSET_T uiSymbolicAddrOffset;
 	IMG_UINT32 ui32MappedCount = 0;
+	IMG_DEV_VIRTADDR sDevVAddrRunningPdump;
 	PDUMPCOMMENT(psDevNode, "Wire up Page Table entries to point to the Data Pages (%d bytes)", uiNumPages << uiLog2HeapPageSize);
 #endif /*PDUMP*/
 
@@ -3847,6 +4123,13 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 	uiAddrMask = psConfig->uiAddrMask;
 	uiBytesPerEntry = psConfig->uiBytesPerEntry;
 
+	bSetParity = psConfig->uiParityBitMask;
+	uiParityShift = psConfig->uiParityBitShift;
+
+	sDevVAddrRunning.uiAddr = sDevVAddrBase.uiAddr;
+#if defined(PDUMP)
+	sDevVAddrRunningPdump.uiAddr = sDevVAddrBase.uiAddr;
+#endif
 	if (uiBytesPerEntry == 8)
 	{
 		uiProtFlags = psMMUContext->psDevAttrs->pfnDerivePTEProt8(uiMMUProtFlags , uiLog2HeapPageSize);
@@ -3860,12 +4143,17 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 		PVR_LOG_GOTO_WITH_ERROR("psConfig->uiBytesPerEntry", eError, PVRSRV_ERROR_MMU_CONFIG_IS_WRONG, put_mmu_context);
 	}
 
+
 	OSLockAcquire(psMMUContext->hLock);
 
 	do
 	{
-		_MMU_GetPTInfo(psMMUContext, sDevVAddrBase, psDevVAddrConfig,
-		               &psLevel, &uiPTEIndex);
+		if (!_MMU_GetPTInfo(psMMUContext, sDevVAddrBase, psDevVAddrConfig,
+		                    &psLevel, &uiPTEIndex))
+		{
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_MAPPING_NOT_FOUND,
+			                    unlock_mmu_context);
+		}
 
 		pui64LevelBase = (IMG_UINT64*)psLevel->sMemDesc.pvCpuVAddr;
 		pui32LevelBase = (IMG_UINT32*)psLevel->sMemDesc.pvCpuVAddr;
@@ -3907,14 +4195,14 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 					{
 						IMG_UINT32 ui32BitLength = FloorLog2(asDevPAddr[i].uiAddr);
 
-						if (ui32BitLength > i32FeatureVal)
+						if (ui32BitLength > (IMG_UINT32) i32FeatureVal)
 						{
 							PVR_DPF((PVR_DBG_ERROR,
-							        "%s Failed. The physical address bitlength (%d)"
+							        "%s Failed. The physical address bitlength (%u)"
 							        " is greater than the chip can handle (%d).",
 							        __func__, ui32BitLength, i32FeatureVal));
 
-							PVR_ASSERT(ui32BitLength <= i32FeatureVal);
+							PVR_ASSERT(ui32BitLength <= (IMG_UINT32) i32FeatureVal);
 							PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, unlock_mmu_context);
 						}
 					}
@@ -3926,8 +4214,16 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 			{
 				for (i=0; i<uiNumPagesInBlock; i++)
 				{
+					if (bSetParity)
+					{
+						uiParityBit = _GetParityBit(sDevVAddrRunning.uiAddr ^ asDevPAddr[i].uiAddr);
+						uiParityBit <<= uiParityShift;
+
+						sDevVAddrRunning.uiAddr += (1 << uiLog2HeapPageSize);
+					}
+
 					pui64LevelBase[uiPTEIndex + uiChunkStart + i] =
-					    (((asDevPAddr[i].uiAddr >> uiAddrLog2Align) << uiAddrShift) & uiAddrMask) | uiProtFlags;
+						(((asDevPAddr[i].uiAddr >> uiAddrLog2Align) << uiAddrShift) & uiAddrMask) | uiProtFlags | uiParityBit;
 				}
 			}
 			else if (uiBytesPerEntry == 4)
@@ -3940,6 +4236,7 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 					IMG_UINT64 ui64PxE64 =
 					    (((asDevPAddr[i].uiAddr >> uiAddrLog2Align) << uiAddrShift) & uiAddrMask) | uiProtFlags;
 					PVR_ASSERT(ui64PxE64 == (ui64PxE64 & 0xffffffffU));
+					PVR_ASSERT(!bSetParity);
 #endif
 
 					pui32LevelBase[uiPTEIndex + uiChunkStart + i] =
@@ -3951,6 +4248,7 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 			for (i=0; i<uiNumPagesInBlock; i++)
 			{
 				IMG_DEVMEM_OFFSET_T uiNextSymName;
+				IMG_UINT64 uiParityBit = psConfig->uiParityBitMask ? _GetParityBit(sDevVAddrRunningPdump.uiAddr ^ 0ULL) : 0;
 
 				eError = PMR_PDumpSymbolicAddr(psPMR, (ui32PagesDone + uiChunkStart + i) << uiLog2HeapPageSize,
 				                               sizeof(aszMemspaceName), &aszMemspaceName[0],
@@ -3977,7 +4275,12 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 				                      psConfig->uiProtMask,
 				                      psConfig->uiValidEnMask,
 				                      0,
+				                      uiParityBit,
+				                      psConfig->uiParityBitShift,
+				                      psConfig->uiParityBitMask,
 				                      psMMUContext->psDevAttrs->eMMUType);
+
+				sDevVAddrRunningPdump.uiAddr += (1 << uiLog2HeapPageSize);
 			}
 #endif /*PDUMP*/
 
@@ -3990,6 +4293,11 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 					IMG_UINT64 ui64PxE64 = (((asDevPAddr[i].uiAddr >> uiAddrLog2Align) << uiAddrShift) & uiAddrMask) | uiProtFlags;
 					sDevVAddr.uiAddr = sDevVAddrBase.uiAddr + (ui32PagesDone + uiChunkStart + i)  * (1 << uiLog2HeapPageSize);
 
+					if (bSetParity)
+					{
+						ui64PxE64 |= _GetParityBit(sDevVAddr.uiAddr ^ asDevPAddr[i].uiAddr) << uiParityShift;
+					}
+
 					HTBLOGK(HTB_SF_MMU_PAGE_OP_PMRMAP,
 					        HTBLOG_U64_BITS_HIGH(sDevVAddr.uiAddr), HTBLOG_U64_BITS_LOW(sDevVAddr.uiAddr),
 					        HTBLOG_U64_BITS_HIGH(asDevPAddr[i].uiAddr), HTBLOG_U64_BITS_LOW(asDevPAddr[i].uiAddr));
@@ -4032,26 +4340,25 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 	return PVRSRV_OK;
 
 unlock_mmu_context:
+	/* Unmap starting from the address passed as an argument. */
+	(void) MMU_UnmapPMRFastUnlocked(psMMUContext,
+	                                sDevVAddrBaseCopy,
+	                                uiNumPages,
+	                                uiLog2HeapPageSize);
 	OSLockRelease(psMMUContext->hLock);
-	MMU_UnmapPMRFast(psMMUContext,
-	                 sDevVAddrBase,
-	                 uiNumPages,
-	                 uiLog2HeapPageSize);
 put_mmu_context:
 	_MMU_PutPTConfig(psMMUContext, hPriv);
-	PVR_ASSERT(eError == PVRSRV_OK);
+
 	return eError;
 }
 
-/*
-    MMU_UnmapPMRFast
- */
-void
-MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
-                 IMG_DEV_VIRTADDR sDevVAddrBase,
-                 IMG_UINT32 ui32PageCount,
-                 IMG_UINT32 uiLog2PageSize)
+static PVRSRV_ERROR
+MMU_UnmapPMRFastUnlocked(MMU_CONTEXT *psMMUContext,
+                         IMG_DEV_VIRTADDR sDevVAddrBase,
+                         IMG_UINT32 ui32PageCount,
+                         IMG_UINT32 uiLog2PageSize)
 {
+	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_UINT32 uiPTEIndex = 0, uiLastPTEIndex = 0, ui32PagesDone=0, i, uiNumEntriesToWrite;
 	IMG_UINT32 uiPageSize = 1 << uiLog2PageSize;
 	MMU_Levelx_INFO *psLevel = NULL;
@@ -4063,35 +4370,58 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 	IMG_UINT64 uiProtFlags = 0;
 	MMU_PROTFLAGS_T uiMMUProtFlags = 0;
 	IMG_UINT64 uiEntry = 0;
+
+	IMG_UINT64 uiParityBit = 0;
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	IMG_DEV_VIRTADDR sDevVAddrStartOfTable;
+	IMG_UINT32 uiParityPatternIdx;
+	IMG_BOOL bSetParity = IMG_FALSE;
+	IMG_DEV_VIRTADDR sDevVAddrRunning;
+	IMG_UINT64 ui64BadPhysAddrParity = 0;
+#endif
+	IMG_UINT64 ui64BadPhysAddr = 0;
+
+#if defined(PVRSRV_ENABLE_HTB)
 	IMG_BOOL bLog;
+#endif
 
 	PVRSRV_DEVICE_NODE *psDevNode = psMMUContext->psPhysMemCtx->psDevNode;
 
+	PVR_ASSERT(OSLockIsLocked(psMMUContext->hLock));
+
 	/* Get PT and address configs */
 	_MMU_GetPTConfig(psMMUContext, (IMG_UINT32) uiLog2PageSize,
 	                 &psConfig, &hPriv, &psDevVAddrConfig);
 
-	if (_MMU_ConvertDevMemFlags(IMG_TRUE,
-	                            0,
-	                            &uiMMUProtFlags,
-	                            psMMUContext) != PVRSRV_OK)
-	{
-		return;
-	}
+	eError = _MMU_ConvertDevMemFlags(IMG_TRUE,
+	                                 0,
+	                                 &uiMMUProtFlags,
+	                                 psMMUContext);
+	PVR_RETURN_IF_ERROR(eError);
+
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	bSetParity = psConfig->uiParityBitMask != 0;
+	sDevVAddrRunning.uiAddr = sDevVAddrBase.uiAddr;
+#endif
 
 	/* Callback to get device specific protection flags */
 
 	if (psConfig->uiBytesPerEntry == 8)
 	{
 		uiProtFlags = psMMUContext->psDevAttrs->pfnDerivePTEProt8(uiMMUProtFlags , uiLog2PageSize);
-
-		/* Fill the entry with a bad address but leave space for protection flags */
-		uiEntry = (gsBadDevPhyAddr.uiAddr & ~psConfig->uiProtMask) | uiProtFlags;
+		ui64BadPhysAddr = gsBadDevPhyAddr.uiAddr & ~(psConfig->uiProtMask | psConfig->uiParityBitMask);
+		/* Fill the entry with a bad address but leave space for protection flags and parity bit */
+		uiEntry = ui64BadPhysAddr | uiProtFlags;
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+		ui64BadPhysAddrParity = _GetParityBit(ui64BadPhysAddr) << psConfig->uiParityBitShift;
+#endif
 	}
 	else if (psConfig->uiBytesPerEntry == 4)
 	{
 		uiProtFlags = psMMUContext->psDevAttrs->pfnDerivePTEProt4(uiMMUProtFlags);
-
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+		PVR_ASSERT(!bSetParity);
+#endif
 		/* Fill the entry with a bad address but leave space for protection flags */
 		uiEntry = (((IMG_UINT32) gsBadDevPhyAddr.uiAddr) & ~psConfig->uiProtMask) | (IMG_UINT32) uiProtFlags;
 	}
@@ -4103,16 +4433,23 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 		goto e0;
 	}
 
+#if defined(PVRSRV_ENABLE_HTB)
 	bLog = HTB_GROUP_ENABLED(HTB_SF_MMU_PAGE_OP_UNMAP) ||
 		   HTB_GROUP_ENABLED(HTB_SF_MMU_PAGE_OP_TABLE);
-
-	OSLockAcquire(psMMUContext->hLock);
+#endif
 
 	do
 	{
-		_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
-					   &psLevel, &uiPTEIndex);
+		if (!_MMU_GetPTInfo(psMMUContext, sDevVAddr, psDevVAddrConfig,
+		                    &psLevel, &uiPTEIndex))
+		{
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_MAPPING_NOT_FOUND, e0);
+		}
 
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+		sDevVAddrStartOfTable.uiAddr = sDevVAddr.uiAddr - uiPTEIndex * (1 << uiLog2PageSize);
+		uiParityPatternIdx = _GetParityBit(sDevVAddrStartOfTable.uiAddr);
+#endif
 		pvPTStart = psLevel->sMemDesc.pvCpuVAddr;
 
 		uiLastPTEIndex = MIN(uiPTEIndex + ui32PageCount - ui32PagesDone, psDevVAddrConfig->uiNumEntriesPT);
@@ -4122,13 +4459,23 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 		{
 			for (i=uiPTEIndex; i<uiLastPTEIndex; i++)
 			{
-				((IMG_UINT64*)pvPTStart)[i] = uiEntry;
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+				if (bSetParity)
+				{
+					uiParityBit = psMMUContext->psDevAttrs->pui64PrecomputedAllocParity[uiParityPatternIdx][i] ^ ui64BadPhysAddrParity;
+					sDevVAddrRunning.uiAddr += (1 << uiLog2PageSize);
+				}
+#endif
+				((IMG_UINT64*)pvPTStart)[i] = uiEntry | uiParityBit;
 			}
 		}
 		else
 		{
 #if defined(PVRSRV_NEED_PVR_ASSERT)
 			PVR_ASSERT(psConfig->uiBytesPerEntry == 4);
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+			PVR_ASSERT(!bSetParity);
+#endif
 #endif
 			for (i=uiPTEIndex; i<uiLastPTEIndex; i++)
 			{
@@ -4136,6 +4483,7 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 			}
 		}
 
+#if defined(PVRSRV_ENABLE_HTB)
 		/* Log separately to avoid polluting the fast path */
 		if (bLog)
 		{
@@ -4155,6 +4503,7 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 						IMG_FALSE);
 			}
 		}
+#endif
 
 #if defined(PDUMP)
 		PDumpMMUDumpPxEntries(psDevNode,
@@ -4174,21 +4523,23 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 		                      psConfig->uiProtMask,
 		                      psConfig->uiValidEnMask,
 		                      0,
+		                      0, /* Unused - Parity bit values are taken directly from PTE memory when bad phys addr is used */
+		                      0, /* Unused */
+		                      0, /* Unused */
 		                      psMMUContext->psDevAttrs->eMMUType);
 #endif /*PDUMP*/
 
-		PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
+		eError = PhysHeapPagesClean(psDevNode->psMMUPhysHeap,
 						&psLevel->sMemDesc.psMapping->sMemHandle,
 						uiPTEIndex * psConfig->uiBytesPerEntry + psLevel->sMemDesc.uiOffset,
 						(uiNumEntriesToWrite) * psConfig->uiBytesPerEntry);
+		PVR_LOG_IF_ERROR(eError, "PhysHeapPagesClean");
 
 		sDevVAddr.uiAddr += uiNumEntriesToWrite * uiPageSize;
 		ui32PagesDone += uiNumEntriesToWrite;
 
 	} while (ui32PagesDone < ui32PageCount);
 
-	OSLockRelease(psMMUContext->hLock);
-
 	_MMU_PutPTConfig(psMMUContext, hPriv);
 
 	/* Flush TLB for PTs*/
@@ -4197,12 +4548,36 @@ MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
 	                                 MMU_LEVEL_1,
 	                                 IMG_TRUE);
 
-	return;
+	return PVRSRV_OK;
 
 e0:
-	PVR_DPF((PVR_DBG_ERROR, "%s: Failed to map/unmap page table", __func__));
-	PVR_ASSERT(0);
-	return;
+	PVR_DPF((PVR_DBG_ERROR, "%s: Failed to map/unmap page table with error %u",
+	         __func__, eError));
+
+	return eError;
+}
+
+/*
+    MMU_UnmapPMRFast
+ */
+PVRSRV_ERROR
+MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
+                 IMG_DEV_VIRTADDR sDevVAddrBase,
+                 IMG_UINT32 ui32PageCount,
+                 IMG_UINT32 uiLog2PageSize)
+{
+	PVRSRV_ERROR eError;
+
+	OSLockAcquire(psMMUContext->hLock);
+
+	eError = MMU_UnmapPMRFastUnlocked(psMMUContext,
+                                      sDevVAddrBase,
+                                      ui32PageCount,
+                                      uiLog2PageSize);
+
+	OSLockRelease(psMMUContext->hLock);
+
+	return eError;
 }
 
 /*
@@ -4574,7 +4949,6 @@ void MMU_CheckFaultAddress(MMU_CONTEXT *psMMUContext,
 static IMG_UINT64 MMU_GetVDevAddrPTE(MMU_CONTEXT *psMMUContext,
                                      const MMU_PxE_CONFIG *psConfig,
                                      const MMU_DEVVADDR_CONFIG *psDevVAddrConfig,
-                                     IMG_UINT32 uiLog2PageSize,
                                      IMG_DEV_VIRTADDR sDevVAddr,
                                      IMG_BOOL *pbStatusOut)
 {
@@ -4642,7 +5016,6 @@ IMG_BOOL MMU_IsVDevAddrValid(MMU_CONTEXT *psMMUContext,
 	MMU_GetVDevAddrPTE(psMMUContext,
 	                   psConfig,
 	                   psDevVAddrConfig,
-	                   uiLog2PageSize,
 	                   sDevVAddr,
 	                   &bStatus);
 
diff --git a/drivers/gpu/drm/img-rogue/mmu_common.h b/drivers/gpu/drm/img-rogue/mmu_common.h
index 51218556a5a5..f88d80a5dda4 100644
--- a/drivers/gpu/drm/img-rogue/mmu_common.h
+++ b/drivers/gpu/drm/img-rogue/mmu_common.h
@@ -142,6 +142,8 @@ typedef struct _MMU_PxE_CONFIG_
 	IMG_UINT64	uiPendingEnMask; /*! Entry pending bit mask */
 	IMG_UINT64	uiValidEnMask;   /*! Entry valid bit mask */
 	IMG_UINT8	uiValidEnShift;  /*! Entry valid bit shift */
+	IMG_UINT64	uiParityBitMask;   /*! Entry parity bit mask */
+	IMG_UINT8	uiParityBitShift;  /*! Entry parity bit shift */
 } MMU_PxE_CONFIG;
 
 /*!
@@ -201,12 +203,12 @@ typedef struct _MMU_DEVICEATTRIBS_
 	/*! Address split for the base object */
 	const struct _MMU_DEVVADDR_CONFIG_ *psTopLevelDevVAddrConfig;
 
-	/* Optional, test feature used to generate the pre-mapped page tables in a stand alone MMU driver.*/
-	PVRSRV_ERROR (*pfnTestPremapConfigureMMU)(struct _PVRSRV_DEVICE_NODE_ *psDevNode,
-			MMU_CONTEXT *psMMUContext,
-			IMG_DEV_VIRTADDR sDevVAddrStart,
-			IMG_DEV_VIRTADDR sDevVAddrEnd,
-			IMG_UINT32 ui32Log2PageSize);
+	/*! Supported page sizes validation mask */
+	IMG_UINT32 ui32ValidPageSizeMask;
+
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+	IMG_UINT64* pui64PrecomputedAllocParity[2];
+#endif
 
 	/*! Callback for creating protection bits for the page catalogue entry with 8 byte entry */
 	IMG_UINT64 (*pfnDerivePCEProt8)(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2DataPageSize);
@@ -349,8 +351,6 @@ MMU_ContextDestroy(MMU_CONTEXT *psMMUContext);
 
 @Input          uSize                   The size of the allocation
 
-@Output         puActualSize            Actual size of allocation
-
 @Input          uiProtFlags             Generic MMU protection flags
 
 @Input          uDevVAddrAlignment      Alignment requirement of the virtual
@@ -365,7 +365,6 @@ MMU_ContextDestroy(MMU_CONTEXT *psMMUContext);
 PVRSRV_ERROR
 MMU_Alloc(MMU_CONTEXT *psMMUContext,
           IMG_DEVMEM_SIZE_T uSize,
-          IMG_DEVMEM_SIZE_T *puActualSize,
           IMG_UINT32 uiProtFlags,
           IMG_DEVMEM_SIZE_T uDevVAddrAlignment,
           IMG_DEV_VIRTADDR *psDevVAddr,
@@ -453,10 +452,10 @@ MMU_MapPages(MMU_CONTEXT *psMMUContext,
 @Input          uiMemAllocFlags         Indicates if the unmapped regions need
                                         to be backed by dummy or zero page
 
-@Return         None
+@Return         PVRSRV_OK if the unmap operation was successful
 */
 /*****************************************************************************/
-void
+PVRSRV_ERROR
 MMU_UnmapPages(MMU_CONTEXT *psMMUContext,
                PVRSRV_MEMALLOCFLAGS_T uiMappingFlags,
                IMG_DEV_VIRTADDR sDevVAddr,
@@ -531,10 +530,10 @@ MMU_MapPMRFast(MMU_CONTEXT *psMMUContext,
 
 @Input          uiLog2PageSize          log2 size of the page
 
-@Return         None
+@Return         PVRSRV_OK if the PMR was successfully unmapped
 */
 /*****************************************************************************/
-void
+PVRSRV_ERROR
 MMU_UnmapPMRFast(MMU_CONTEXT *psMMUContext,
                  IMG_DEV_VIRTADDR sDevVAddrBase,
                  IMG_UINT32 ui32PageCount,
diff --git a/drivers/gpu/drm/img-rogue/module_common.c b/drivers/gpu/drm/img-rogue/module_common.c
index bd6a6e9ebcc9..8df0593db286 100644
--- a/drivers/gpu/drm/img-rogue/module_common.c
+++ b/drivers/gpu/drm/img-rogue/module_common.c
@@ -80,6 +80,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "pvr_ion_stats.h"
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+#include "physmem_osmem_linux.h"
+#endif
+#endif
+
+#include "dkf_server.h"
+
 #if defined(SUPPORT_DISPLAY_CLASS)
 /* Display class interface */
 #include "kerneldisplay.h"
@@ -118,9 +126,6 @@ EXPORT_SYMBOL(PVRSRVGetDeviceInstance);
 
 #if defined(SUPPORT_RGX)
 #include "rgxapi_km.h"
-#if defined(SUPPORT_SHARED_SLC)
-EXPORT_SYMBOL(RGXInitSLC);
-#endif
 EXPORT_SYMBOL(RGXHWPerfConnect);
 EXPORT_SYMBOL(RGXHWPerfDisconnect);
 EXPORT_SYMBOL(RGXHWPerfControl);
@@ -197,6 +202,14 @@ int PVRSRVDriverInit(void)
 		return -ENOMEM;
 	}
 
+#if defined(SUPPORT_LINUX_FDINFO)
+	error = PVRDKFInit();
+	if (error != PVRSRV_OK)
+	{
+		return -ENODEV;
+	}
+#endif	/* SUPPORT_LINUX_FDINFO */
+
 	error = PVRSRVCommonDriverInit();
 	if (error != PVRSRV_OK)
 	{
@@ -300,6 +313,10 @@ void PVRSRVDriverDeinit(void)
 
 	PVRSRVCommonDriverDeInit();
 
+#if defined(SUPPORT_LINUX_FDINFO)
+	PVRDKFDeInit();
+#endif	/* SUPPORT_LINUX_FDINFO */
+
 	PVROSFuncDeInit();
 }
 
@@ -356,11 +373,9 @@ void PVRSRVDeviceDeinit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	pvr_sync_device_deinit(psDeviceNode->psDevConfig->pvOSDevice);
 #endif
 
-#if defined(SUPPORT_DMA_TRANSFER)
-	PVRSRVDeInitialiseDMA(psDeviceNode);
-#endif
-
+#if defined(SUPPORT_NATIVE_FENCE_SYNC) || defined(SUPPORT_BUFFER_SYNC)
 	pvr_fence_cleanup();
+#endif
 }
 
 /**************************************************************************/ /*!
@@ -511,6 +526,7 @@ int PVRSRVDeviceServicesOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 			mutex_unlock(&sDeviceInitMutex);
 			goto fail_alloc_connection_priv;
 		}
+		psConnectionPriv->ui32Type = DKF_CONNECTION_FLAG_SERVICES;
 	}
 	else
 	{
@@ -536,6 +552,7 @@ int PVRSRVDeviceServicesOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 	mutex_unlock(&sDeviceInitMutex);
 
 	sPrivData.psDevNode = psDeviceNode;
+	sPrivData.psDRMFile = psDRMFile;
 
 	/*
 	 * Here we pass the file pointer which will passed through to our
@@ -555,15 +572,6 @@ int PVRSRVDeviceServicesOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 #endif
 	psDRMFile->driver_priv = (void*)psConnectionPriv;
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	eError = PVRSRVGpuTraceWorkPeriodEventStatsRegister(
-			&psConnectionPriv->pvGpuWorkPeriodEventStats);
-	if (eError != PVRSRV_OK)
-	{
-		iErr = -ENOMEM;
-		goto fail_connect;
-	}
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
 	goto out;
 
 fail_connect:
@@ -586,6 +594,7 @@ int PVRSRVDeviceServicesOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 static int PVRSRVDeviceSyncOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
                                 struct drm_file *psDRMFile)
 {
+#if defined(SUPPORT_NATIVE_FENCE_SYNC)
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 	CONNECTION_DATA *psConnection = NULL;
 	ENV_CONNECTION_PRIVATE_DATA sPrivData;
@@ -624,14 +633,16 @@ static int PVRSRVDeviceSyncOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 		iErr = -ENOMEM;
 		goto fail_alloc_connection;
 	}
-	psConnection->bSyncConnection = IMG_TRUE;
 #if (PVRSRV_DEVICE_INIT_MODE == PVRSRV_LINUX_DEV_INIT_ON_CONNECT)
 	psConnectionPriv->pvConnectionData = (void*)psConnection;
 #else
 	psConnectionPriv->pvSyncConnectionData = (void*)psConnection;
 #endif
 
+	psConnectionPriv->ui32Type = DKF_CONNECTION_FLAG_SYNC;
+
 	sPrivData.psDevNode = psDeviceNode;
+	sPrivData.psDRMFile = psDRMFile;
 
 	/* Call environment specific connection data init function */
 	eError = OSConnectionPrivateDataInit(&psConnection->hOsPrivateData, &sPrivData);
@@ -674,6 +685,11 @@ static int PVRSRVDeviceSyncOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 	kfree(psConnectionPriv);
 out:
 	return iErr;
+#else /* if defined(SUPPORT_NATIVE_FENCE_SYNC) */
+	/* Ioctl should not be being called (no DDK support for native sync) */
+	PVR_DPF((PVR_DBG_ERROR, "%s: only supported when SUPPORT_NATIVE_FENCE_SYNC=1", __func__));
+	return -ENOTTY;
+#endif /* if defined(SUPPORT_NATIVE_FENCE_SYNC) */
 }
 
 /**************************************************************************/ /*!
@@ -687,7 +703,6 @@ static int PVRSRVDeviceSyncOpen(PVRSRV_DEVICE_NODE *psDeviceNode,
 void PVRSRVDeviceRelease(PVRSRV_DEVICE_NODE *psDeviceNode,
                          struct drm_file *psDRMFile)
 {
-	CONNECTION_DATA *psConnection = NULL;
 	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 
 	if (psDRMFile->driver_priv)
@@ -696,15 +711,6 @@ void PVRSRVDeviceRelease(PVRSRV_DEVICE_NODE *psDeviceNode,
 
 		if (psConnectionPriv->pvConnectionData)
 		{
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-			if (psConnectionPriv->pvGpuWorkPeriodEventStats)
-			{
-				PVRSRVGpuTraceWorkPeriodEventStatsUnregister(
-						psConnectionPriv->pvGpuWorkPeriodEventStats);
-				psConnectionPriv->pvGpuWorkPeriodEventStats = NULL;
-			}
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
-
 #if (PVRSRV_DEVICE_INIT_MODE == PVRSRV_LINUX_DEV_INIT_ON_CONNECT)
 			if (psConnectionPriv->pfDeviceRelease)
 			{
@@ -719,18 +725,14 @@ void PVRSRVDeviceRelease(PVRSRV_DEVICE_NODE *psDeviceNode,
 				pvr_sync_close(psConnectionPriv->pvSyncConnectionData);
 #endif
 #endif
-			psConnection = psConnectionPriv->pvConnectionData;
-			if (psConnection && psConnection->bSyncConnection == IMG_TRUE)
-			{
-				if (psConnection->hOsPrivateData != NULL)
-				{
-					OSConnectionPrivateDataDeInit(psConnection->hOsPrivateData);
-					psConnection->hOsPrivateData = NULL;
-				}
-				kfree(psConnection);
-				psConnection = NULL;
-			}
 		}
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+		LinuxDeregisterMigrateCallbacks(psDRMFile->filp);
+#endif
+#endif
+
 		kfree(psDRMFile->driver_priv);
 		psDRMFile->driver_priv = NULL;
 	}
@@ -753,8 +755,26 @@ drm_pvr_srvkm_init(struct drm_device *dev, void *arg, struct drm_file *psDRMFile
 		case PVR_SRVKM_SERVICES_INIT:
 		{
 			iErr = PVRSRVDeviceServicesOpen(priv->dev_node, psDRMFile);
+			if (iErr)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: PVRSRVDeviceServicesOpen() failed(%d)",
+						__func__, iErr));
+				break;
+			}
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+			iErr = LinuxRegisterMigrateCallbacks(psDRMFile->filp);
+#endif
+#endif
 			break;
 		}
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+		case PVR_SRVKM_SERVICES_PAGE_MIGRATE_INIT:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+			iErr = LinuxRegisterMigrateCallbacks(psDRMFile->filp);
+#endif
+#endif
+			break;
 		default:
 		{
 			PVR_DPF((PVR_DBG_ERROR, "%s: invalid init_module (%d)",
diff --git a/drivers/gpu/drm/img-rogue/module_common.h b/drivers/gpu/drm/img-rogue/module_common.h
index 811cacdd98ac..35f33770e2e5 100644
--- a/drivers/gpu/drm/img-rogue/module_common.h
+++ b/drivers/gpu/drm/img-rogue/module_common.h
@@ -80,12 +80,10 @@ typedef struct
 	 */
 	void *pvSyncConnectionData;
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	/* hGpuWorkPeriodEventStats is used to hold gpu work period event stats
-	 * private data for each apps which have been working with GPU.
+	/* An integer representing the type of connection (indicated by the
+	 * DKF_CONNECTION_FLAGS).
 	 */
-	void *pvGpuWorkPeriodEventStats;
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
+	uint32_t ui32Type;
 
 } PVRSRV_CONNECTION_PRIV;
 
diff --git a/drivers/gpu/drm/img-rogue/osconnection_server.c b/drivers/gpu/drm/img-rogue/osconnection_server.c
index 3fcf43ca777d..543b4d8ddabf 100644
--- a/drivers/gpu/drm/img-rogue/osconnection_server.c
+++ b/drivers/gpu/drm/img-rogue/osconnection_server.c
@@ -84,6 +84,7 @@ PVRSRV_ERROR OSConnectionPrivateDataInit(IMG_HANDLE *phOsPrivateData, void *pvOS
 	psEnvConnection->owner = current->tgid;
 
 	psEnvConnection->psDevNode = psPrivData->psDevNode;
+	psEnvConnection->psDRMFile = psPrivData->psDRMFile;
 
 #if defined(SUPPORT_NATIVE_FENCE_SYNC)
 	psEnvConnection->pvPvrSyncPrivateData = NULL;
@@ -155,3 +156,13 @@ PVRSRV_DEVICE_NODE *OSGetDevNode(CONNECTION_DATA *psConnection)
 
 	return psEnvConnection->psDevNode;
 }
+
+struct drm_file *OSGetDRMFile(CONNECTION_DATA *psConnection)
+{
+	ENV_CONNECTION_DATA *psEnvConnection;
+
+	psEnvConnection = PVRSRVConnectionPrivateData(psConnection);
+	PVR_ASSERT(psEnvConnection);
+
+	return psEnvConnection->psDRMFile;
+}
diff --git a/drivers/gpu/drm/img-rogue/osconnection_server.h b/drivers/gpu/drm/img-rogue/osconnection_server.h
index 28a6dd3825fb..88f7aab29dca 100644
--- a/drivers/gpu/drm/img-rogue/osconnection_server.h
+++ b/drivers/gpu/drm/img-rogue/osconnection_server.h
@@ -60,6 +60,10 @@ PVRSRV_ERROR OSConnectionSetHandleOptions(PVRSRV_HANDLE_BASE *psHandleBase);
 
 PVRSRV_DEVICE_NODE* OSGetDevNode(CONNECTION_DATA *psConnection);
 
+struct drm_file;
+
+struct drm_file* OSGetDRMFile(CONNECTION_DATA *psConnection);
+
 #else	/* defined(__linux__) || defined(__QNXNTO__) || defined(INTEGRITY_OS) */
 #ifdef INLINE_IS_PRAGMA
 #pragma inline(OSConnectionPrivateDataInit)
diff --git a/drivers/gpu/drm/img-rogue/osdi_impl.h b/drivers/gpu/drm/img-rogue/osdi_impl.h
index 65507feea59b..5be78d6c2b62 100644
--- a/drivers/gpu/drm/img-rogue/osdi_impl.h
+++ b/drivers/gpu/drm/img-rogue/osdi_impl.h
@@ -43,7 +43,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef OSDI_IMPL_H
 #define OSDI_IMPL_H
 
-#if defined(__linux__)
+#if defined(__KERNEL__) && defined(__linux__)
  #include <linux/version.h>
 
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
@@ -53,10 +53,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0) */
 #else
  #include <stdarg.h>
-#endif /* __linux__ */
+#endif /* __KERNEL__ && __linux__ */
 
 #include "di_common.h"
 #include "pvrsrv_error.h"
+#include "img_defs.h"
 
 /*! Implementation callbacks. Those operations are performed on native
  * implementation handles. */
@@ -84,6 +85,7 @@ typedef struct OSDI_IMPL_ENTRY_CB
      * @Input pszFmt NUL-terminated format string
      * @Input va_list variable length argument list
      */
+    __printf(2, 0)
     void (*pfnVPrintf)(void *pvNativeHandle, const IMG_CHAR *pszFmt, va_list pArgs);
 
     /*! @Function pfnPuts
diff --git a/drivers/gpu/drm/img-rogue/osfunc.c b/drivers/gpu/drm/img-rogue/osfunc.c
index 4935536cd631..efa06b112bb3 100644
--- a/drivers/gpu/drm/img-rogue/osfunc.c
+++ b/drivers/gpu/drm/img-rogue/osfunc.c
@@ -68,10 +68,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <linux/kthread.h>
 #include <linux/utsname.h>
 #include <linux/scatterlist.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
+#include <linux/interrupt.h>
 #include <linux/pfn_t.h>
 #include <linux/pfn.h>
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
 #include <linux/sched/clock.h>
 #include <linux/sched/signal.h>
@@ -88,6 +87,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif
 
 #include "log2.h"
+#include "sysinfo.h"
 #include "osfunc.h"
 #include "cache_km.h"
 #include "img_defs.h"
@@ -115,14 +115,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "kernel_compatibility.h"
 
-#if defined(VIRTUAL_PLATFORM)
-#define EVENT_OBJECT_TIMEOUT_US		(120000000ULL)
-#else
-#if defined(EMULATOR) || defined(TC_APOLLO_TCF5)
-#define EVENT_OBJECT_TIMEOUT_US		(2000000ULL)
-#else
-#define EVENT_OBJECT_TIMEOUT_US		(100000ULL)
-#endif /* EMULATOR */
+#if !defined(EVENT_OBJECT_TIMEOUT_US)
+#error EVENT_OBJECT_TIMEOUT_US should be defined sysinfo.h
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
@@ -151,6 +145,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #endif
 
+#define _FREEZABLE IMG_TRUE
+#define _NON_FREEZABLE IMG_FALSE
 
 typedef struct {
 	struct task_struct *kthread;
@@ -195,6 +191,8 @@ void OSThreadDumpInfo(DUMPDEBUG_PRINTF_FUNC* pfnDumpDebugPrintf,
                       void *pvDumpDebugFile)
 {
 	PDLLIST_NODE psNodeCurr, psNodeNext;
+	LINUX_THREAD_ACTIVITY_STATS sThreadStats;
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
 	dllist_foreach_node(&gsThreadListHead, psNodeCurr, psNodeNext)
 	{
@@ -210,6 +208,21 @@ void OSThreadDumpInfo(DUMPDEBUG_PRINTF_FUNC* pfnDumpDebugPrintf,
 			psThreadListNode->pfnDebugDumpCB(pfnDumpDebugPrintf, pvDumpDebugFile);
 		}
 	}
+
+	eError = LinuxGetThreadActivityStats(&sThreadStats);
+	if (eError == PVRSRV_OK)
+	{
+		PVR_DUMPDEBUG_LOG("Active Threads (UM/KM): %d / %d",
+		                  sThreadStats.i32DriverThreadCount,
+		                  sThreadStats.i32KernelThreadCount);
+
+		PVR_DUMPDEBUG_LOG("Suspended Threads: %d",
+		                  sThreadStats.i32SuspendedThreadCount);
+	}
+	else
+	{
+		PVR_LOG_ERROR(eError, "LinuxGetThreadActivityStats");
+	}
 }
 
 PVRSRV_ERROR OSPhyContigPagesAlloc(PHYS_HEAP *psPhysHeap, size_t uiSize,
@@ -640,9 +653,10 @@ struct workqueue_struct *NativeSyncGetFenceCtxDestroyWq(void)
 
 PVRSRV_ERROR OSInitEnvData(void)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_ERROR eError;
 
-	LinuxInitPhysmem();
+	eError = LinuxInitPhysmem();
+	PVR_GOTO_IF_ERROR(eError, error_out);
 
 	_OSInitThreadList();
 
@@ -650,6 +664,7 @@ PVRSRV_ERROR OSInitEnvData(void)
 	eError = _NativeSyncInit();
 #endif
 
+error_out:
 	return eError;
 }
 
@@ -913,7 +928,8 @@ typedef struct
 	X(PVRSRV_ERROR_PMR_NOT_PERMITTED, EACCES) \
 	X(PVRSRV_ERROR_INVALID_PARAMS, EINVAL) \
 	X(PVRSRV_ERROR_PMR_NO_KERNEL_MAPPING, EPERM) \
-	X(PVRSRV_ERROR_NOT_IMPLEMENTED, ENOSYS)
+	X(PVRSRV_ERROR_NOT_IMPLEMENTED, ENOSYS) \
+	X(PVRSRV_ERROR_BAD_MAPPING, EINVAL)
 
 /* return -ve versions of POSIX errors as they are used in this form */
 int PVRSRVToNativeError(PVRSRV_ERROR eError)
@@ -1024,6 +1040,11 @@ PVRSRV_ERROR OSScheduleMISR(IMG_HANDLE hMISRData)
 #endif
 }
 
+void OSSyncIRQ(IMG_UINT32 ui32IRQ)
+{
+	synchronize_irq(ui32IRQ);
+}
+
 /* OS specific values for thread priority */
 static const IMG_INT32 ai32OSPriorityValues[OS_THREAD_LAST_PRIORITY] =
 {
@@ -1293,27 +1314,26 @@ OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr,
 		return NULL;
 	}
 
-	if (! PVRSRV_VZ_MODE_IS(NATIVE))
-	{
-		/*
-		  This is required to support DMA physheaps for GPU virtualization.
-		  Unfortunately, if a region of kernel managed memory is turned into
-		  a DMA buffer, conflicting mappings can come about easily on Linux
-		  as the original memory is mapped by the kernel as normal cached
-		  memory whilst DMA buffers are mapped mostly as uncached device or
-		  cache-coherent device memory. In both cases the system will have
-		  two conflicting mappings for the same memory region and will have
-		  "undefined behaviour" for most processors notably ARMv6 onwards
-		  and some x86 micro-architectures. As a result, perform ioremapping
-		  manually for DMA physheap allocations by translating from CPU/VA
-		  to BUS/PA thereby preventing the creation of conflicting mappings.
-		*/
-		pvLinAddr = (void __iomem *) SysDmaDevPAddrToCpuVAddr(BasePAddr.uiAddr, ui32Bytes);
-		if (pvLinAddr != NULL)
-		{
-			return (void __force *) pvLinAddr;
-		}
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	/*
+	  This is required to support DMA physheaps for GPU virtualization.
+	  Unfortunately, if a region of kernel managed memory is turned into
+	  a DMA buffer, conflicting mappings can come about easily on Linux
+	  as the original memory is mapped by the kernel as normal cached
+	  memory whilst DMA buffers are mapped mostly as uncached device or
+	  cache-coherent device memory. In both cases the system will have
+	  two conflicting mappings for the same memory region and will have
+	  "undefined behaviour" for most processors notably ARMv6 onwards
+	  and some x86 micro-architectures. As a result, perform ioremapping
+	  manually for DMA physheap allocations by translating from CPU/VA
+	  to BUS/PA thereby preventing the creation of conflicting mappings.
+	*/
+	pvLinAddr = (void __iomem *) SysDmaDevPAddrToCpuVAddr(BasePAddr.uiAddr, ui32Bytes);
+	if (pvLinAddr != NULL)
+	{
+		return (void __force *) pvLinAddr;
 	}
+#endif
 
 	switch (uiMappingFlags)
 	{
@@ -1354,13 +1374,12 @@ OSUnMapPhysToLin(void *pvLinAddr, size_t ui32Bytes)
 {
 	PVR_UNREFERENCED_PARAMETER(ui32Bytes);
 
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	if (SysDmaCpuVAddrToDevPAddr(pvLinAddr))
 	{
-		if (SysDmaCpuVAddrToDevPAddr(pvLinAddr))
-		{
-			return IMG_TRUE;
-		}
+		return IMG_TRUE;
 	}
+#endif
 
 	iounmap((void __iomem *) pvLinAddr);
 
@@ -1582,14 +1601,7 @@ PVRSRV_ERROR OSEventObjectDestroy(IMG_HANDLE hEventObject)
 	return LinuxEventObjectListDestroy(hEventObject);
 }
 
-#define _FREEZABLE IMG_TRUE
-#define _NON_FREEZABLE IMG_FALSE
-
-/*
- * EventObjectWaitTimeout()
- */
-static PVRSRV_ERROR EventObjectWaitTimeout(IMG_HANDLE hOSEventKM,
-										   IMG_UINT64 uiTimeoutus)
+PVRSRV_ERROR OSEventObjectWaitTimeout(IMG_HANDLE hOSEventKM, IMG_UINT64 uiTimeoutus)
 {
 	PVRSRV_ERROR eError;
 
@@ -1606,11 +1618,6 @@ static PVRSRV_ERROR EventObjectWaitTimeout(IMG_HANDLE hOSEventKM,
 	return eError;
 }
 
-PVRSRV_ERROR OSEventObjectWaitTimeout(IMG_HANDLE hOSEventKM, IMG_UINT64 uiTimeoutus)
-{
-	return EventObjectWaitTimeout(hOSEventKM, uiTimeoutus);
-}
-
 PVRSRV_ERROR OSEventObjectWait(IMG_HANDLE hOSEventKM)
 {
 	return OSEventObjectWaitTimeout(hOSEventKM, EVENT_OBJECT_TIMEOUT_US);
@@ -1621,20 +1628,14 @@ PVRSRV_ERROR OSEventObjectWaitKernel(IMG_HANDLE hOSEventKM,
 {
 	PVRSRV_ERROR eError;
 
-#if defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
-	if (hOSEventKM)
+	if (hOSEventKM != NULL && uiTimeoutus > 0)
 	{
-		if (uiTimeoutus > 0)
-			eError = LinuxEventObjectWait(hOSEventKM, uiTimeoutus,
-			                              _FREEZABLE);
-		else
-			eError = LinuxEventObjectWaitUntilSignalled(hOSEventKM);
+		eError = LinuxEventObjectWait(hOSEventKM, uiTimeoutus, _FREEZABLE);
 	}
-#else /* defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP) */
-	if (hOSEventKM && uiTimeoutus > 0)
+#if defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
+	else if (hOSEventKM != NULL)
 	{
-		eError = LinuxEventObjectWait(hOSEventKM, uiTimeoutus,
-		                              _FREEZABLE);
+		eError = LinuxEventObjectWaitUntilSignalled(hOSEventKM);
 	}
 #endif /* defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP) */
 	else
@@ -1769,181 +1770,6 @@ void OSDumpStack(void)
 	dump_stack();
 }
 
-PVRSRV_ERROR OSChangeSparseMemCPUAddrMap(void **psPageArray,
-                                         IMG_UINT64 sCpuVAddrBase,
-                                         IMG_CPU_PHYADDR sCpuPAHeapBase,
-                                         IMG_UINT32 ui32AllocPageCount,
-                                         IMG_UINT32 *pai32AllocIndices,
-                                         IMG_UINT32 ui32FreePageCount,
-                                         IMG_UINT32 *pai32FreeIndices,
-                                         IMG_BOOL bIsLMA)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
-	pfn_t sPFN;
-#else
-	IMG_UINT64 uiPFN;
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
-
-	PVRSRV_ERROR eError;
-
-	struct mm_struct *psMM = current->mm;
-	struct vm_area_struct *psVMA = NULL;
-	struct address_space *psMapping = NULL;
-	struct page *psPage = NULL;
-
-	IMG_UINT64 uiCPUVirtAddr = 0;
-	IMG_UINT32 ui32Loop = 0;
-	IMG_UINT32 ui32PageSize = OSGetPageSize();
-	IMG_BOOL bMixedMap = IMG_FALSE;
-
-	/*
-	 * Acquire the lock before manipulating the VMA
-	 * In this case only mmap_sem lock would suffice as the pages associated with this VMA
-	 * are never meant to be swapped out.
-	 *
-	 * In the future, in case the pages are marked as swapped, page_table_lock needs
-	 * to be acquired in conjunction with this to disable page swapping.
-	 */
-
-	/* Find the Virtual Memory Area associated with the user base address */
-	psVMA = find_vma(psMM, (uintptr_t)sCpuVAddrBase);
-	if (NULL == psVMA)
-	{
-		eError = PVRSRV_ERROR_PMR_NO_CPU_MAP_FOUND;
-		return eError;
-	}
-
-	/* Acquire the memory sem */
-	mmap_write_lock(psMM);
-
-	psMapping = psVMA->vm_file->f_mapping;
-
-	/* Set the page offset to the correct value as this is disturbed in MMAP_PMR func */
-	psVMA->vm_pgoff = (psVMA->vm_start >>  PAGE_SHIFT);
-
-	/* Delete the entries for the pages that got freed */
-	if (ui32FreePageCount && (pai32FreeIndices != NULL))
-	{
-		for (ui32Loop = 0; ui32Loop < ui32FreePageCount; ui32Loop++)
-		{
-			uiCPUVirtAddr = (uintptr_t)(sCpuVAddrBase + (pai32FreeIndices[ui32Loop] * ui32PageSize));
-
-			unmap_mapping_range(psMapping, uiCPUVirtAddr, ui32PageSize, 1);
-
-#ifndef PVRSRV_UNMAP_ON_SPARSE_CHANGE
-			/*
-			 * Still need to map pages in case remap flag is set.
-			 * That is not done until the remap case succeeds
-			 */
-#endif
-		}
-		eError = PVRSRV_OK;
-	}
-
-	if ((psVMA->vm_flags & VM_MIXEDMAP) || bIsLMA)
-	{
-		pvr_vm_flags_set(psVMA, VM_MIXEDMAP);
-		bMixedMap = IMG_TRUE;
-	}
-	else
-	{
-		if (ui32AllocPageCount && (NULL != pai32AllocIndices))
-		{
-			for (ui32Loop = 0; ui32Loop < ui32AllocPageCount; ui32Loop++)
-			{
-
-				psPage = (struct page *)psPageArray[pai32AllocIndices[ui32Loop]];
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
-				sPFN = page_to_pfn_t(psPage);
-
-				if (!pfn_t_valid(sPFN) || page_count(pfn_t_to_page(sPFN)) == 0)
-#else
-				uiPFN = page_to_pfn(psPage);
-
-				if (!pfn_valid(uiPFN) || (page_count(pfn_to_page(uiPFN)) == 0))
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
-				{
-					bMixedMap = IMG_TRUE;
-					pvr_vm_flags_set(psVMA, VM_MIXEDMAP);
-					break;
-				}
-			}
-		}
-	}
-
-	/* Map the pages that got allocated */
-	if (ui32AllocPageCount && (NULL != pai32AllocIndices))
-	{
-		for (ui32Loop = 0; ui32Loop < ui32AllocPageCount; ui32Loop++)
-		{
-			int err;
-
-			uiCPUVirtAddr = (uintptr_t)(sCpuVAddrBase + (pai32AllocIndices[ui32Loop] * ui32PageSize));
-			unmap_mapping_range(psMapping, uiCPUVirtAddr, ui32PageSize, 1);
-
-			if (bIsLMA)
-			{
-				phys_addr_t uiAddr = sCpuPAHeapBase.uiAddr +
-				                     ((IMG_DEV_PHYADDR *)psPageArray)[pai32AllocIndices[ui32Loop]].uiAddr;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
-				sPFN = phys_to_pfn_t(uiAddr, 0);
-				psPage = pfn_t_to_page(sPFN);
-#else
-				uiPFN = uiAddr >> PAGE_SHIFT;
-				psPage = pfn_to_page(uiPFN);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
-			}
-			else
-			{
-				psPage = (struct page *)psPageArray[pai32AllocIndices[ui32Loop]];
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
-				sPFN = page_to_pfn_t(psPage);
-#else
-				uiPFN = page_to_pfn(psPage);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
-			}
-
-			if (bMixedMap)
-			{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))
-				vm_fault_t vmf;
-
-				vmf = vmf_insert_mixed(psVMA, uiCPUVirtAddr, sPFN);
-				if (vmf & VM_FAULT_ERROR)
-				{
-					err = vm_fault_to_errno(vmf, 0);
-				}
-				else
-				{
-					err = 0;
-				}
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
-				err = vm_insert_mixed(psVMA, uiCPUVirtAddr, sPFN);
-#else
-				err = vm_insert_mixed(psVMA, uiCPUVirtAddr, uiPFN);
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)) */
-			}
-			else
-			{
-				err = vm_insert_page(psVMA, uiCPUVirtAddr, psPage);
-			}
-
-			if (err)
-			{
-				PVR_DPF((PVR_DBG_MESSAGE, "Remap failure error code: %d", err));
-				eError = PVRSRV_ERROR_PMR_CPU_PAGE_MAP_FAILED;
-				goto eFailed;
-			}
-		}
-	}
-
-	eError = PVRSRV_OK;
-eFailed:
-	mmap_write_unlock(psMM);
-
-	return eError;
-}
-
 /*************************************************************************/ /*!
 @Function       OSDebugSignalPID
 @Description    Sends a SIGTRAP signal to a specific PID in user mode for
@@ -2188,7 +2014,7 @@ static void dma_callback(void *pvOSCleanup)
 	spin_unlock_irqrestore(&psOSCleanup->spinlock, flags);
 }
 
-#if defined(SUPPORT_VALIDATION) && defined(PVRSRV_DEBUG_DMA)
+#if defined(PVRSRV_DEBUG_DMA)
 static void
 DMADumpPhysicalAddresses(struct page **ppsHostMemPages,
 						 IMG_UINT32 uiNumPages,
@@ -2207,16 +2033,20 @@ DMADumpPhysicalAddresses(struct page **ppsHostMemPages,
 		if (uiIdx == 0)
 		{
 			sPagePhysAddr.uiAddr += ui64Offset;
-			PVR_DPF((PVR_DBG_MESSAGE, "\tHost mem start at 0x%llX", sPagePhysAddr.uiAddr));
+			PVR_DPF((PVR_DBG_MESSAGE,
+					 "\tHost mem start at 0x%" IMG_UINT64_FMTSPECx,
+					 (IMG_UINT64)sPagePhysAddr.uiAddr));
 		}
 		else
 		{
-			PVR_DPF((PVR_DBG_MESSAGE, "\tHost Mem Page %d at 0x%llX", uiIdx,
-					 sPagePhysAddr.uiAddr));
+			PVR_DPF((PVR_DBG_MESSAGE,
+					 "\tHost Mem Page %d at 0x%" IMG_UINT64_FMTSPECx,
+					 uiIdx, (IMG_UINT64)sPagePhysAddr.uiAddr));
 		}
 	}
-	PVR_DPF((PVR_DBG_MESSAGE, "Devmem CPU phys address: 0x%llX",
-			 sDmaAddr->uiAddr));
+	PVR_DPF((PVR_DBG_MESSAGE,
+			 "Devmem CPU phys address: 0x%" IMG_UINT64_FMTSPECx,
+			 (IMG_UINT64)sDmaAddr->uiAddr));
 }
 #endif
 
@@ -2421,25 +2251,24 @@ PVRSRV_ERROR OSDmaPrepareTransfer(PVRSRV_DEVICE_NODE *psDevNode,
 		!bMemToDev,
 		psOSCleanupData->pages[psOSCleanupData->uiCount]);
 
+	psOSCleanupData->puiNumPages[psOSCleanupData->uiCount] = num_pinned_pages;
 	if (num_pinned_pages != num_pages)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "get_user_pages_fast failed: (%d - %u)", num_pinned_pages, num_pages));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto e2;
+		goto e2; /* Unpin what was pinned and return error */
 	}
 
-#if defined(SUPPORT_VALIDATION) && defined(PVRSRV_DEBUG_DMA)
+#if defined(PVRSRV_DEBUG_DMA)
 	DMADumpPhysicalAddresses(psOSCleanupData->pages[psOSCleanupData->uiCount],
 							 num_pages, psDmaAddr, offset);
 #endif
 
-	psOSCleanupData->puiNumPages[psOSCleanupData->uiCount] = num_pinned_pages;
-
 	if (sg_alloc_table_from_pages(psSg, psOSCleanupData->pages[psOSCleanupData->uiCount], num_pages, offset, uiSize, GFP_KERNEL) != 0)
 	{
 		eError = PVRSRV_ERROR_BAD_MAPPING;
 		PVR_DPF((PVR_DBG_ERROR, "sg_alloc_table_from_pages failed"));
-		goto e3;
+		goto e2;
 	}
 
 	if (bMemToDev)
@@ -2461,7 +2290,7 @@ PVRSRV_ERROR OSDmaPrepareTransfer(PVRSRV_DEVICE_NODE *psDevNode,
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Error mapping SG list", __func__));
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto e4;
+		goto e3;
 	}
 
 	dma_sync_sg_for_device(psDevConfig->pvOSDevice, psSg->sgl,(unsigned int)iRet, eDataDirection);
@@ -2471,7 +2300,7 @@ PVRSRV_ERROR OSDmaPrepareTransfer(PVRSRV_DEVICE_NODE *psDevNode,
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: dmaengine_prep_slave_sg failed", __func__));
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
-		goto e5;
+		goto e4;
 	}
 
 	psOSCleanupData->eDirection = eDataDirection;
@@ -2482,22 +2311,19 @@ PVRSRV_ERROR OSDmaPrepareTransfer(PVRSRV_DEVICE_NODE *psDevNode,
 	psDesc->callback_param = psOSCleanupData;
 	psDesc->callback = dma_callback;
 
-	if	(bFirst)
-	{
-		struct task_struct* t1;
-		t1 = kthread_run(cleanup_thread, psOSCleanupData, "dma-cleanup-thread");
-	}
+	if (bFirst)
+		kthread_run(cleanup_thread, psOSCleanupData, "dma-cleanup-thread");
 	psOSCleanupData->ppsDescriptors[psOSCleanupData->uiCount] = psDesc;
 
 	psOSCleanupData->uiCount++;
 
 	return PVRSRV_OK;
 
-e5:
-	dma_unmap_sg(psDevConfig->pvOSDevice, psSg->sgl, psSg->nents, eDataDirection);
 e4:
-	sg_free_table(psSg);
+	dma_unmap_sg(psDevConfig->pvOSDevice, psSg->sgl, psSg->nents, eDataDirection);
 e3:
+	sg_free_table(psSg);
+e2:
 	{
 		IMG_UINT32 i;
 		/* Unpin pages */
@@ -2506,7 +2332,6 @@ PVRSRV_ERROR OSDmaPrepareTransfer(PVRSRV_DEVICE_NODE *psDevNode,
 			pvr_unpin_user_page_for_dma(psOSCleanupData->pages[psOSCleanupData->uiCount][i]);
 		}
 	}
-e2:
 	OSFreeMem(psOSCleanupData->pages[psOSCleanupData->uiCount]);
 e1:
 	OSFreeMem(psSg);
@@ -2648,7 +2473,7 @@ PVRSRV_ERROR OSDmaPrepareTransferSparse(PVRSRV_DEVICE_NODE *psDevNode,
 			goto e2;
 		}
 
-#if defined(SUPPORT_VALIDATION) && defined(PVRSRV_DEBUG_DMA)
+#if defined(PVRSRV_DEBUG_DMA)
 		DMADumpPhysicalAddresses(next_pages, num_pages,
 								 &psDmaAddr[ui32Idx],
 								 (unsigned long)pvNextAddress & (ui32PageSize - 1));
@@ -2712,13 +2537,11 @@ PVRSRV_ERROR OSDmaPrepareTransferSparse(PVRSRV_DEVICE_NODE *psDevNode,
 
 			if (bFirst)
 			{
-				struct task_struct* t1;
-
 				psOSCleanupData->eDirection = eDataDirection;
 				psOSCleanupData->pfnServerCleanup = pfnServerCleanup;
 				psOSCleanupData->pvServerCleanupData = pvServerCleanupParam;
 
-				t1 = kthread_run(cleanup_thread, psOSCleanupData, "dma-cleanup-thread");
+				kthread_run(cleanup_thread, psOSCleanupData, "dma-cleanup-thread");
 			}
 
 			psOSCleanupData->uiCount++;
diff --git a/drivers/gpu/drm/img-rogue/osfunc.h b/drivers/gpu/drm/img-rogue/osfunc.h
index 550dfa69ccd5..15ce5e6728b0 100644
--- a/drivers/gpu/drm/img-rogue/osfunc.h
+++ b/drivers/gpu/drm/img-rogue/osfunc.h
@@ -270,41 +270,6 @@ typedef void (*PFN_MISR)(void *pvData);
 */ /**************************************************************************/
 typedef void (*PFN_THREAD)(void *pvData);
 
-/*************************************************************************/ /*!
-@Function       OSChangeSparseMemCPUAddrMap
-@Description    This function changes the CPU mapping of the underlying
-                sparse allocation. It is used by a PMR 'factory'
-                implementation if that factory supports sparse
-                allocations.
-@Input          psPageArray        array representing the pages in the
-                                   sparse allocation
-@Input          sCpuVAddrBase      the virtual base address of the sparse
-                                   allocation ('first' page)
-@Input          sCpuPAHeapBase     the physical address of the virtual
-                                   base address 'sCpuVAddrBase'
-@Input          ui32AllocPageCount the number of pages referenced in
-                                   'pai32AllocIndices'
-@Input          pai32AllocIndices  list of indices of pages within
-                                   'psPageArray' that we now want to
-                                   allocate and map
-@Input          ui32FreePageCount  the number of pages referenced in
-                                   'pai32FreeIndices'
-@Input          pai32FreeIndices   list of indices of pages within
-                                   'psPageArray' we now want to
-                                   unmap and free
-@Input          bIsLMA             flag indicating if the sparse allocation
-                                   is from LMA or UMA memory
-@Return         PVRSRV_OK on success, a failure code otherwise.
-*/ /**************************************************************************/
-PVRSRV_ERROR OSChangeSparseMemCPUAddrMap(void **psPageArray,
-                                         IMG_UINT64 sCpuVAddrBase,
-                                         IMG_CPU_PHYADDR sCpuPAHeapBase,
-                                         IMG_UINT32 ui32AllocPageCount,
-                                         IMG_UINT32 *pai32AllocIndices,
-                                         IMG_UINT32 ui32FreePageCount,
-                                         IMG_UINT32 *pai32FreeIndices,
-                                         IMG_BOOL bIsLMA);
-
 /*************************************************************************/ /*!
 @Function       OSInstallMISR
 @Description    Installs a Mid-level Interrupt Service Routine (MISR)
@@ -350,6 +315,15 @@ PVRSRV_ERROR OSUninstallMISR(IMG_HANDLE hMISRData);
 */ /**************************************************************************/
 PVRSRV_ERROR OSScheduleMISR(IMG_HANDLE hMISRData);
 
+/*************************************************************************/ /*!
+@Function       OSSyncIRQ
+@Description    Wait for LISR to complete. If you use this function while
+                holding a resource which the IRQ handler also requires,
+                you will deadlock.
+@Input          ui32IRQ     IRQ number
+*/ /**************************************************************************/
+void OSSyncIRQ(IMG_UINT32 ui32IRQ);
+
 /*************************************************************************/ /*!
 @Description    Pointer to a function implementing debug dump of thread-specific
                 data.
@@ -603,6 +577,7 @@ typedef enum
                 This is used to infer whether the virtual or physical address
                 supplied to the OSCPUCacheXXXRangeKM functions can be omitted
                 when called.
+@Input          psDevNode   device on which the allocation was made
 @Return         OS_CACHE_OP_ADDR_TYPE
 */ /**************************************************************************/
 OS_CACHE_OP_ADDR_TYPE OSCPUCacheOpAddressType(PVRSRV_DEVICE_NODE *psDevNode);
@@ -1084,37 +1059,27 @@ void OSWriteMemoryBarrier(volatile void *hReadback);
 	} while (0)
 
 #if defined(NO_HARDWARE)
-	/* OSReadHWReg operations skipped in no hardware builds */
-	#define OSReadUncheckedHWReg8(addr, off)  ((void)(addr), 0x4eU)
-	#define OSReadUncheckedHWReg16(addr, off) ((void)(addr), 0x3a4eU)
-	#define OSReadUncheckedHWReg32(addr, off) ((void)(addr), 0x30f73a4eU)
+	/* OSReadHWReg and OSWriteHWReg operations are skipped to no-op in nohw builds */
+	#define OSReadUncheckedHWReg32(addr, off) ((void)(addr), (void)(off), 0x30f73a4eU)
 #if defined(__QNXNTO__) && __SIZEOF_LONG__ == 8
 	/* This is needed for 64-bit QNX builds where the size of a long is 64 bits */
-	#define OSReadUncheckedHWReg64(addr, off) ((void)(addr), 0x5b376c9d30f73a4eUL)
+	#define OSReadUncheckedHWReg64(addr, off) ((void)(addr), (void)(off), 0x5b376c9d30f73a4eUL)
 #else
-	#define OSReadUncheckedHWReg64(addr, off) ((void)(addr), 0x5b376c9d30f73a4eULL)
+	#define OSReadUncheckedHWReg64(addr, off) ((void)(addr), (void)(off), 0x5b376c9d30f73a4eULL)
 #endif
 
-	#define OSWriteUncheckedHWReg8(addr, off, val)
-	#define OSWriteUncheckedHWReg16(addr, off, val)
-	#define OSWriteUncheckedHWReg32(addr, off, val)
-	#define OSWriteUncheckedHWReg64(addr, off, val) ((void)(val))
+	#define OSWriteUncheckedHWReg32(addr, off, val) ((void)(addr), (void)(off), (void)(val))
+	#define OSWriteUncheckedHWReg64(addr, off, val) ((void)(addr), (void)(off), (void)(val))
 
-	#define OSReadHWReg8(addr, off)  OSReadUncheckedHWReg8(addr, off)
-	#define OSReadHWReg16(addr, off) OSReadUncheckedHWReg16(addr, off)
 	#define OSReadHWReg32(addr, off) OSReadUncheckedHWReg32(addr, off)
 	#define OSReadHWReg64(addr, off) OSReadUncheckedHWReg64(addr, off)
 
-	#define OSWriteHWReg8(addr, off, val)  OSWriteUncheckedHWReg8(addr, off, val)
-	#define OSWriteHWReg16(addr, off, val) OSWriteUncheckedHWReg16(addr, off, val)
 	#define OSWriteHWReg32(addr, off, val) OSWriteUncheckedHWReg32(addr, off, val)
 	#define OSWriteHWReg64(addr, off, val) OSWriteUncheckedHWReg64(addr, off, val)
 
 #else
 
 #if defined(__linux__) && defined(__KERNEL__)
-	#define OSReadUncheckedHWReg8(addr, off)  ((IMG_UINT8)readb((IMG_BYTE __iomem *)(addr) + (off)))
-	#define OSReadUncheckedHWReg16(addr, off) ((IMG_UINT16)readw((IMG_BYTE __iomem *)(addr) + (off)))
 	#define OSReadUncheckedHWReg32(addr, off) ((IMG_UINT32)readl((IMG_BYTE __iomem *)(addr) + (off)))
 
 	/* Little endian support only */
@@ -1129,8 +1094,6 @@ void OSWriteMemoryBarrier(volatile void *hReadback);
 				); \
 			})
 
-	#define OSWriteUncheckedHWReg8(addr, off, val)  writeb((IMG_UINT8)(val), (IMG_BYTE __iomem *)(addr) + (off))
-	#define OSWriteUncheckedHWReg16(addr, off, val) writew((IMG_UINT16)(val), (IMG_BYTE __iomem *)(addr) + (off))
 	#define OSWriteUncheckedHWReg32(addr, off, val) writel((IMG_UINT32)(val), (IMG_BYTE __iomem *)(addr) + (off))
 	/* Little endian support only */
 	#define OSWriteUncheckedHWReg64(addr, off, val) do \
@@ -1143,40 +1106,6 @@ void OSWriteMemoryBarrier(volatile void *hReadback);
 			} while (0)
 
 #else /* defined(__linux__) && defined(__KERNEL__) */
-/*************************************************************************/ /*!
-@Function       OSReadUncheckedHWReg8
-@Description    Read from an 8-bit memory-mapped device register.
-                The implementation should not permit the compiler to
-                reorder the I/O sequence.
-                The implementation should ensure that for a NO_HARDWARE
-                build the code does not attempt to read from a location
-                but instead returns a constant value.
-@Input          pvLinRegBaseAddr   The virtual base address of the register
-                                   block.
-@Input          ui32Offset         The byte offset from the base address of
-                                   the register to be read.
-@Return         The byte read.
-*/ /**************************************************************************/
-	IMG_UINT8 OSReadUncheckedHWReg8(volatile void *pvLinRegBaseAddr,
-									IMG_UINT32 ui32Offset);
-
-/*************************************************************************/ /*!
-@Function       OSReadUncheckedHWReg16
-@Description    Read from a 16-bit memory-mapped device register.
-                The implementation should not permit the compiler to
-                reorder the I/O sequence.
-                The implementation should ensure that for a NO_HARDWARE
-                build the code does not attempt to read from a location
-                but instead returns a constant value.
-@Input          pvLinRegBaseAddr   The virtual base address of the register
-                                   block.
-@Input          ui32Offset         The byte offset from the base address of
-                                   the register to be read.
-@Return         The word read.
-*/ /**************************************************************************/
-	IMG_UINT16 OSReadUncheckedHWReg16(volatile void *pvLinRegBaseAddr,
-									  IMG_UINT32 ui32Offset);
-
 /*************************************************************************/ /*!
 @Function       OSReadUncheckedHWReg32
 @Description    Read from a 32-bit memory-mapped device register.
@@ -1210,42 +1139,6 @@ void OSWriteMemoryBarrier(volatile void *hReadback);
 */ /**************************************************************************/
 	IMG_UINT64 OSReadUncheckedHWReg64(volatile void *pvLinRegBaseAddr,
 									  IMG_UINT32 ui32Offset);
-
-/*************************************************************************/ /*!
-@Function       OSWriteUncheckedHWReg8
-@Description    Write to an 8-bit memory-mapped device register.
-                The implementation should not permit the compiler to
-                reorder the I/O sequence.
-                The implementation should ensure that for a NO_HARDWARE
-                build the code does not attempt to write to a location.
-@Input          pvLinRegBaseAddr   The virtual base address of the register
-                                   block.
-@Input          ui32Offset         The byte offset from the base address of
-                                   the register to be written to.
-@Input          ui8Value           The byte to be written to the register.
-@Return         None.
-*/ /**************************************************************************/
-	void OSWriteUncheckedHWReg8(volatile void *pvLinRegBaseAddr,
-								IMG_UINT32 ui32Offset, IMG_UINT8 ui8Value);
-
-/*************************************************************************/ /*!
-@Function       OSWriteUncheckedHWReg16
-@Description    Write to a 16-bit memory-mapped device register.
-                The implementation should not permit the compiler to
-                reorder the I/O sequence.
-                The implementation should ensure that for a NO_HARDWARE
-                build the code does not attempt to write to a location.
-@Input          pvLinRegBaseAddr   The virtual base address of the register
-                                   block.
-@Input          ui32Offset         The byte offset from the base address of
-                                   the register to be written to.
-@Input          ui16Value          The word to be written to the register.
-@Return         None.
-*/ /**************************************************************************/
-	void OSWriteUncheckedHWReg16(volatile void *pvLinRegBaseAddr,
-								 IMG_UINT32 ui32Offset,
-								 IMG_UINT16 ui16Value);
-
 /*************************************************************************/ /*!
 @Function       OSWriteUncheckedHWReg32
 @Description    Write to a 32-bit memory-mapped device register.
@@ -1313,20 +1206,6 @@ static INLINE bool _NonSecureRegister(IMG_UINT32 ui32Offset)
 
 	/* systems using real hardware must check that regular register
 	 * operations don't attempt to access secure registers */
-	static INLINE IMG_UINT8 OSReadHWReg8(volatile void __iomem *pvLinRegBaseAddr,
-										 IMG_UINT32 ui32Offset)
-	{
-		PVR_ASSERT(_NonSecureRegister(ui32Offset));
-		return OSReadUncheckedHWReg8(pvLinRegBaseAddr, ui32Offset);
-	}
-
-	static INLINE IMG_UINT16 OSReadHWReg16(volatile void __iomem *pvLinRegBaseAddr,
-										   IMG_UINT32 ui32Offset)
-	{
-		PVR_ASSERT(_NonSecureRegister(ui32Offset));
-		return OSReadUncheckedHWReg16(pvLinRegBaseAddr, ui32Offset);
-	}
-
 	static INLINE IMG_UINT32 OSReadHWReg32(volatile void __iomem *pvLinRegBaseAddr,
 										   IMG_UINT32 ui32Offset)
 	{
@@ -1341,22 +1220,6 @@ static INLINE bool _NonSecureRegister(IMG_UINT32 ui32Offset)
 		return OSReadUncheckedHWReg64(pvLinRegBaseAddr, ui32Offset);
 	}
 
-	static INLINE void OSWriteHWReg8(volatile void __iomem *pvLinRegBaseAddr,
-									 IMG_UINT32 ui32Offset,
-									 IMG_UINT8 ui8Value)
-	{
-		PVR_ASSERT(_NonSecureRegister(ui32Offset));
-		OSWriteUncheckedHWReg8(pvLinRegBaseAddr, ui32Offset, ui8Value);
-	}
-
-	static INLINE void OSWriteHWReg16(volatile void __iomem *pvLinRegBaseAddr,
-									  IMG_UINT32 ui32Offset,
-									  IMG_UINT16 ui16Value)
-	{
-		PVR_ASSERT(_NonSecureRegister(ui32Offset));
-		OSWriteUncheckedHWReg16(pvLinRegBaseAddr, ui32Offset, ui16Value);
-	}
-
 	static INLINE void OSWriteHWReg32(volatile void __iomem *pvLinRegBaseAddr,
 									  IMG_UINT32 ui32Offset,
 									  IMG_UINT32 ui32Value)
@@ -1429,7 +1292,7 @@ PVRSRV_ERROR OSDisableTimer(IMG_HANDLE hTimer);
  @Description   Take action in response to an unrecoverable driver error
  @Return        None
 */ /**************************************************************************/
-void OSPanic(void);
+void __noreturn OSPanic(void);
 
 /*************************************************************************/ /*!
 @Function       OSCopyToUser
diff --git a/drivers/gpu/drm/img-rogue/osfunc_arm.c b/drivers/gpu/drm/img-rogue/osfunc_arm.c
index a249bef51e9a..d3d3ab9f83fa 100644
--- a/drivers/gpu/drm/img-rogue/osfunc_arm.c
+++ b/drivers/gpu/drm/img-rogue/osfunc_arm.c
@@ -46,9 +46,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #else
  #include <linux/dma-mapping.h>
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0) */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0))
- #include <asm/system.h>
-#endif
 #include <asm/cacheflush.h>
 
 #include "pvrsrv_error.h"
@@ -80,16 +77,10 @@ void OSCPUCacheFlushRangeKM(PVRSRV_DEVICE_NODE *psDevNode,
 		                        sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr,
 		                        DMA_FROM_DEVICE);
 	}
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
-	arm_dma_ops.sync_single_for_device(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_TO_DEVICE);
-	arm_dma_ops.sync_single_for_cpu(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_FROM_DEVICE);
 #else
 	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	/* Inner cache */
-	dmac_flush_range(pvVirtStart, pvVirtEnd);
-
-	/* Outer cache */
-	outer_flush_range(sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr);
+	arm_dma_ops.sync_single_for_device(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_TO_DEVICE);
+	arm_dma_ops.sync_single_for_cpu(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_FROM_DEVICE);
 #endif
 }
 
@@ -107,16 +98,9 @@ void OSCPUCacheCleanRangeKM(PVRSRV_DEVICE_NODE *psDevNode,
 		                           sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr,
 		                           DMA_TO_DEVICE);
 	}
-
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
-	arm_dma_ops.sync_single_for_device(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_TO_DEVICE);
 #else
 	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	/* Inner cache */
-	dmac_map_area(pvVirtStart, pvr_dmac_range_len(pvVirtStart, pvVirtEnd), DMA_TO_DEVICE);
-
-	/* Outer cache */
-	outer_clean_range(sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr);
+	arm_dma_ops.sync_single_for_device(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_TO_DEVICE);
 #endif
 }
 
@@ -134,26 +118,16 @@ void OSCPUCacheInvalidateRangeKM(PVRSRV_DEVICE_NODE *psDevNode,
 		                        sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr,
 		                        DMA_FROM_DEVICE);
 	}
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
-	arm_dma_ops.sync_single_for_cpu(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_FROM_DEVICE);
 #else
 	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	/* Inner cache */
-	dmac_map_area(pvVirtStart, pvr_dmac_range_len(pvVirtStart, pvVirtEnd), DMA_FROM_DEVICE);
-
-	/* Outer cache */
-	outer_inv_range(sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr);
+	arm_dma_ops.sync_single_for_cpu(psDevNode->psDevConfig->pvOSDevice, sCPUPhysStart.uiAddr, sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr, DMA_FROM_DEVICE);
 #endif
 }
 
 OS_CACHE_OP_ADDR_TYPE OSCPUCacheOpAddressType(PVRSRV_DEVICE_NODE *psDevNode)
 {
 	PVR_UNREFERENCED_PARAMETER(psDevNode);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
 	return OS_CACHE_OP_ADDR_TYPE_PHYSICAL;
-#else
-	return OS_CACHE_OP_ADDR_TYPE_BOTH;
-#endif
 }
 
 /* User Enable Register */
diff --git a/drivers/gpu/drm/img-rogue/osfunc_arm64.c b/drivers/gpu/drm/img-rogue/osfunc_arm64.c
index 9b5f5fad35b5..4722e3d3b34b 100644
--- a/drivers/gpu/drm/img-rogue/osfunc_arm64.c
+++ b/drivers/gpu/drm/img-rogue/osfunc_arm64.c
@@ -114,11 +114,6 @@ static inline void FlushRange(void *pvRangeAddrStart,
 			}
 			break;
 		case PVRSRV_CACHE_OP_INVALIDATE:
-			for (pbBase = pbStart; pbBase < pbEnd; pbBase += ui32CacheLineSize)
-			{
-				asm volatile ("dc ivac, %0" :: "r" (pbBase));
-			}
-			break;
 		case PVRSRV_CACHE_OP_FLUSH:
 			for (pbBase = pbStart; pbBase < pbEnd; pbBase += ui32CacheLineSize)
 			{
@@ -145,28 +140,22 @@ void OSCPUCacheFlushRangeKM(PVRSRV_DEVICE_NODE *psDevNode,
 							IMG_CPU_PHYADDR sCPUPhysEnd)
 {
 	struct device *dev;
+	PVR_UNREFERENCED_PARAMETER(dev);
 
-	if (pvVirtStart)
+	if (pvVirtStart == NULL)
 	{
-		FlushRange(pvVirtStart, pvVirtEnd, PVRSRV_CACHE_OP_FLUSH);
-		return;
+		/*
+		 * Converting the physical addresses to virtual addresses allows us to
+		 * utilize the assembly instruction that makes the Flush + Invalidate
+		 * cache operation atomic.
+		 * There is no state in-between the flush and the invalidate operation.
+		 */
+		pvVirtStart = phys_to_virt(sCPUPhysStart.uiAddr);
+		pvVirtEnd = phys_to_virt(sCPUPhysEnd.uiAddr);
 	}
 
-	dev = psDevNode->psDevConfig->pvOSDevice;
-
-	if (dev)
-	{
-		dma_sync_single_for_device(dev, sCPUPhysStart.uiAddr,
-								   sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr,
-								   DMA_TO_DEVICE);
-		dma_sync_single_for_cpu(dev, sCPUPhysStart.uiAddr,
-								sCPUPhysEnd.uiAddr - sCPUPhysStart.uiAddr,
-								DMA_FROM_DEVICE);
-	}
-	else
-	{
-		PVR_DPF((PVR_DBG_ERROR, "Cache operation cannot be completed!"));
-	}
+	FlushRange(pvVirtStart, pvVirtEnd, PVRSRV_CACHE_OP_FLUSH);
+	return;
 
 }
 
diff --git a/drivers/gpu/drm/img-rogue/osfunc_common.h b/drivers/gpu/drm/img-rogue/osfunc_common.h
index bc47e3bc7a25..d93cb6d61aba 100644
--- a/drivers/gpu/drm/img-rogue/osfunc_common.h
+++ b/drivers/gpu/drm/img-rogue/osfunc_common.h
@@ -110,19 +110,28 @@ void DeviceMemSetBytes(void *pvDest, IMG_UINT8 ui8Value, size_t ui32Size);
 void DeviceMemCopyBytes(void *pvDst, const void *pvSrc, size_t ui32Size);
 
 /**************************************************************************/ /*!
-@Function       StringLCopy
-@Description    Copy at most uDataSize-1 bytes from pszSrc to pszDest.
-                If no null byte ('\0') is contained within the first uDataSize-1
-                characters of the source string, the destination string will be
-                truncated. If the length of the source string is less than uDataSize
-                an additional NUL byte will be copied to the destination string
-                to ensure that the string is NUL-terminated.
-@Input          pszDest       char pointer to the destination string
-@Input          pszSrc        const char pointer to the source string
-@Input          uDataSize     the maximum number of bytes to be copied
-@Return         Size of the source string
+@Function       OSStringSafeCopy
+@Description    Copy at most uDataSize-1 bytes from pszSrc to pszDest. pszDest
+                is always null-terminated. If no null byte ('\0') is contained
+                within the first uDataSize-1 characters of the source string,
+                the destination will contain the truncated source string,
+                otherwise pszDest will contain the entire source string.
+@Input          pszDest    char pointer to the destination string
+@Input          pszSrc     const char pointer to the source string
+@Input          uDataSize  the maximum number of bytes to be copied; this
+                           should normally be the size of the destination
+                           buffer
+@Return         Number of bytes copied if uDataSize > strlen(pszSrc), negative
+                value otherwise
  */ /**************************************************************************/
-size_t StringLCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize);
+#if defined(__linux__) && defined(__KERNEL__) && !defined(DEBUG)
+static inline ssize_t OSStringSafeCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize)
+{
+	return strscpy(pszDest, pszSrc, uDataSize);
+}
+#else
+ssize_t OSStringSafeCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize);
+#endif
 
 #if defined(__arm64__) || defined(__aarch64__) || defined(PVRSRV_DEVMEM_TEST_SAFE_MEMSETCPY)
 #if defined(__GNUC__)
@@ -254,25 +263,6 @@ size_t StringLCopy(IMG_CHAR *pszDest, const IMG_CHAR *pszSrc, size_t uDataSize);
 	} while (false)
 #endif /* defined(__KERNEL__) */
 
-/**************************************************************************/ /*!
-@Function       OSStringLCopy
-@Description    Copy at most uDataSize-1 bytes from pszSrc to pszDest.
-                If no null byte ('\0') is contained within the first uDataSize-1
-                characters of the source string, the destination string will be
-                truncated. If the length of the source string is less than uDataSize
-                an additional NUL byte will be copied to the destination string
-                to ensure that the string is NUL-terminated.
-@Input          a     char pointer to the destination string
-@Input          b     const char pointer to the source string
-@Input          c     the maximum number of bytes to be copied
-@Return         Size of the source string
- */ /**************************************************************************/
-#if defined(__QNXNTO__) || (defined(__linux__) && defined(__KERNEL__) && !defined(DEBUG))
-#define OSStringLCopy(a,b,c) strlcpy((a), (b), (c))
-#else /* defined(__QNXNTO__) ... */
-#define OSStringLCopy(a,b,c) StringLCopy((a), (b), (c))
-#endif /* defined(__QNXNTO__) ... */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/gpu/drm/img-rogue/osfunc_x86.c b/drivers/gpu/drm/img-rogue/osfunc_x86.c
index cd9c70eb988d..2c5c145e268f 100644
--- a/drivers/gpu/drm/img-rogue/osfunc_x86.c
+++ b/drivers/gpu/drm/img-rogue/osfunc_x86.c
@@ -61,18 +61,14 @@ static void x86_flush_cache_range(const void *pvStart, const void *pvEnd)
 
 	mb();
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,168))
 	__uaccess_begin();
-#endif
 
 	for (pbBase = pbStart; pbBase < pbEnd; pbBase += boot_cpu_data.x86_clflush_size)
 	{
 		clflush(pbBase);
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,168))
 	__uaccess_end();
-#endif
 
 	mb();
 }
diff --git a/drivers/gpu/drm/img-rogue/ospvr_gputrace.h b/drivers/gpu/drm/img-rogue/ospvr_gputrace.h
index 038b3b889468..6bafc4d6042f 100644
--- a/drivers/gpu/drm/img-rogue/ospvr_gputrace.h
+++ b/drivers/gpu/drm/img-rogue/ospvr_gputrace.h
@@ -49,7 +49,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxdevice.h"
 #include "device.h"
 
-#if defined(__linux__) && defined(CONFIG_EVENT_TRACING)
+#if defined(__linux__) && defined(CONFIG_EVENT_TRACING) && \
+	(defined(PVRSRV_TRACE_ROGUE_EVENTS) || \
+	 defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD))
 
 /* Early initialisation of GPU Trace events logic.
  * This function is called on *driver* initialisation. */
diff --git a/drivers/gpu/drm/img-rogue/pci_support.c b/drivers/gpu/drm/img-rogue/pci_support.c
index c3bbcc46cb2c..a8321a493e3e 100644
--- a/drivers/gpu/drm/img-rogue/pci_support.c
+++ b/drivers/gpu/drm/img-rogue/pci_support.c
@@ -54,9 +54,7 @@ typedef	struct _PVR_PCI_DEV_TAG
 	struct pci_dev		*psPCIDev;
 	HOST_PCI_INIT_FLAGS	ePCIFlags;
 	IMG_BOOL		abPCIResourceInUse[DEVICE_COUNT_RESOURCE];
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	int			iMTRR[DEVICE_COUNT_RESOURCE];
-#endif
 } PVR_PCI_DEV;
 
 /*************************************************************************/ /*!
@@ -113,9 +111,7 @@ PVRSRV_PCI_DEV_HANDLE OSPCISetDev(void *pvPCICookie, HOST_PCI_INIT_FLAGS eFlags)
 	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
 	{
 		psPVRPCI->abPCIResourceInUse[i] = IMG_FALSE;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 		psPVRPCI->iMTRR[i] = -1;
-#endif
 	}
 
 	return (PVRSRV_PCI_DEV_HANDLE)psPVRPCI;
@@ -602,91 +598,19 @@ PVRSRV_ERROR OSPCIClearResourceMTRRs(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 u
 	start = pci_resource_start(psPVRPCI->psPCIDev, ui32Index);
 	end = pci_resource_end(psPVRPCI->psPCIDev, ui32Index) + 1;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	res = arch_io_reserve_memtype_wc(start, end - start);
 	if (res)
 	{
 		return PVRSRV_ERROR_PCI_CALL_FAILED;
 	}
-#endif
 	res = arch_phys_wc_add(start, end - start);
 	if (res < 0)
 	{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 		arch_io_free_memtype_wc(start, end - start);
-#endif
 
 		return PVRSRV_ERROR_PCI_CALL_FAILED;
 	}
 	psPVRPCI->iMTRR[ui32Index] = res;
-#else
-
-	res = mtrr_add(start, end - start, MTRR_TYPE_UNCACHABLE, 0);
-	if (res < 0)
-	{
-		printk(KERN_ERR "OSPCIClearResourceMTRRs: mtrr_add failed (%d)", res);
-		return PVRSRV_ERROR_PCI_CALL_FAILED;
-	}
-
-	res = mtrr_del(res, start, end - start);
-	if (res < 0)
-	{
-		printk(KERN_ERR "OSPCIClearResourceMTRRs: mtrr_del failed (%d)", res);
-		return PVRSRV_ERROR_PCI_CALL_FAILED;
-	}
-
-	/* Workaround for overlapping MTRRs. */
-	{
-		IMG_BOOL bGotMTRR0 = IMG_FALSE;
-
-		/* Current mobo BIOSes will normally set up a WRBACK MTRR spanning
-		 * 0->4GB, and then another 4GB->6GB. If the PCI card's automatic &
-		 * overlapping UNCACHABLE MTRR is deleted, we see WRBACK behaviour.
-		 *
-		 * WRBACK is incompatible with some PCI devices, so try to split
-		 * the UNCACHABLE regions up and insert a WRCOMB region instead.
-		 */
-		res = mtrr_add(start, end - start, MTRR_TYPE_WRBACK, 0);
-		if (res < 0)
-		{
-			/* If this fails, services has probably run before and created
-			 * a write-combined MTRR for the test chip. Assume it has, and
-			 * don't return an error here.
-			 */
-			return PVRSRV_OK;
-		}
-
-		if (res == 0)
-			bGotMTRR0 = IMG_TRUE;
-
-		res = mtrr_del(res, start, end - start);
-		if (res < 0)
-		{
-			printk(KERN_ERR "OSPCIClearResourceMTRRs: mtrr_del failed (%d)", res);
-			return PVRSRV_ERROR_PCI_CALL_FAILED;
-		}
-
-		if (bGotMTRR0)
-		{
-			/* Replace 0 with a non-overlapping WRBACK MTRR */
-			res = mtrr_add(0, start, MTRR_TYPE_WRBACK, 0);
-			if (res < 0)
-			{
-				printk(KERN_ERR "OSPCIClearResourceMTRRs: mtrr_add failed (%d)", res);
-				return PVRSRV_ERROR_PCI_CALL_FAILED;
-			}
-
-			/* Add a WRCOMB MTRR for the PCI device memory bar */
-			res = mtrr_add(start, end - start, MTRR_TYPE_WRCOMB, 0);
-			if (res < 0)
-			{
-				printk(KERN_ERR "OSPCIClearResourceMTRRs: mtrr_add failed (%d)", res);
-				return PVRSRV_ERROR_PCI_CALL_FAILED;
-			}
-		}
-	}
-#endif
 
 	return PVRSRV_OK;
 }
@@ -699,7 +623,6 @@ PVRSRV_ERROR OSPCIClearResourceMTRRs(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 u
 */ /**************************************************************************/
 void OSPCIReleaseResourceMTRRs(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Index)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	PVR_PCI_DEV *psPVRPCI = (PVR_PCI_DEV *)hPVRPCI;
 
 	if (psPVRPCI->iMTRR[ui32Index] >= 0)
@@ -707,7 +630,6 @@ void OSPCIReleaseResourceMTRRs(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Ind
 		arch_phys_wc_del(psPVRPCI->iMTRR[ui32Index]);
 		psPVRPCI->iMTRR[ui32Index] = -1;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 		{
 			resource_size_t start, end;
 
@@ -716,11 +638,6 @@ void OSPCIReleaseResourceMTRRs(PVRSRV_PCI_DEV_HANDLE hPVRPCI, IMG_UINT32 ui32Ind
 
 			arch_io_free_memtype_wc(start, end - start);
 		}
-#endif
 	}
-#else
-	PVR_UNREFERENCED_PARAMETER(hPVRPCI);
-	PVR_UNREFERENCED_PARAMETER(ui32Index);
-#endif
 }
 #endif /* defined(CONFIG_MTRR) */
diff --git a/drivers/gpu/drm/img-rogue/pdump_km.h b/drivers/gpu/drm/img-rogue/pdump_km.h
index 7066f1dec5e8..58713cdfa17d 100644
--- a/drivers/gpu/drm/img-rogue/pdump_km.h
+++ b/drivers/gpu/drm/img-rogue/pdump_km.h
@@ -90,6 +90,16 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PDUMP_PD_UNIQUETAG	(IMG_HANDLE)0
 #define PDUMP_PT_UNIQUETAG	(IMG_HANDLE)0
 
+/* Defines for CMD:SetParity's state word */
+#define PDUMP_SET_PARITY_STATE_WORD_VERSION_SHIFT		(0U)
+#define PDUMP_SET_PARITY_STATE_WORD_VERSION_MASK		(0x00000007U)
+
+#define PDUMP_SET_PARITY_STATE_WORD_PARITY_SHIFT_SHIFT	(3U)
+#define PDUMP_SET_PARITY_STATE_WORD_PARITY_SHIFT_MASK	(0x000001F8U)
+
+#define PDUMP_SET_PARITY_STATE_WORD_VA_PARITY_SHIFT		(9U)
+#define PDUMP_SET_PARITY_STATE_WORD_VA_PARITY_MASK		(0x00000200U)
+
 /* Invalid value for PDump block number */
 #define PDUMP_BLOCKNUM_INVALID      IMG_UINT32_MAX
 
@@ -102,6 +112,7 @@ typedef enum _PDUMP_TRANSITION_EVENT_
 	PDUMP_TRANSITION_EVENT_BLOCK_FINISHED,    /* Block mode event, current PDump-block has finished */
 	PDUMP_TRANSITION_EVENT_BLOCK_STARTED,     /* Block mode event, new PDump-block has started */
 	PDUMP_TRANSITION_EVENT_RANGE_ENTERED,     /* Transition into capture range */
+	PDUMP_TRANSITION_EVENT_RANGE_APPEND,      /* Append to an already entered capture range */
 	PDUMP_TRANSITION_EVENT_RANGE_EXITED,      /* Transition out of capture range */
 } PDUMP_TRANSITION_EVENT;
 
@@ -227,8 +238,8 @@ PVRSRV_ERROR PDumpSetFrameKM(CONNECTION_DATA *psConnection,
                              PVRSRV_DEVICE_NODE *psDeviceNode,
                              IMG_UINT32 ui32Frame);
 PVRSRV_ERROR PDumpGetFrameKM(CONNECTION_DATA *psConnection,
-                             PVRSRV_DEVICE_NODE * psDeviceNode,
-                             IMG_UINT32* pui32Frame);
+                             PVRSRV_DEVICE_NODE *psDeviceNode,
+                             IMG_UINT32 *pui32Frame);
 PVRSRV_ERROR PDumpCommentKM(CONNECTION_DATA *psConnection,
                             PVRSRV_DEVICE_NODE *psDeviceNode,
                             IMG_UINT32 ui32CommentSize,
@@ -817,10 +828,11 @@ PDumpStopInitPhase(PVRSRV_DEVICE_NODE *psDeviceNode)
 #endif
 static INLINE PVRSRV_ERROR
 PDumpSetFrameKM(CONNECTION_DATA *psConnection,
-                PVRSRV_DEVICE_NODE *psDevNode,
+                PVRSRV_DEVICE_NODE *psDeviceNode,
                 IMG_UINT32 ui32Frame)
 {
 	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 	PVR_UNREFERENCED_PARAMETER(ui32Frame);
 	return PVRSRV_OK;
 }
@@ -831,9 +843,10 @@ PDumpSetFrameKM(CONNECTION_DATA *psConnection,
 static INLINE PVRSRV_ERROR
 PDumpGetFrameKM(CONNECTION_DATA *psConnection,
                 PVRSRV_DEVICE_NODE *psDeviceNode,
-                IMG_UINT32* pui32Frame)
+                IMG_UINT32 *pui32Frame)
 {
 	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 	PVR_UNREFERENCED_PARAMETER(pui32Frame);
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/pdump_mmu.h b/drivers/gpu/drm/img-rogue/pdump_mmu.h
index 4f3b2cc90b94..5d03e430febd 100644
--- a/drivers/gpu/drm/img-rogue/pdump_mmu.h
+++ b/drivers/gpu/drm/img-rogue/pdump_mmu.h
@@ -99,6 +99,9 @@ PDumpMMUDumpPxEntries(PPVRSRV_DEVICE_NODE psDeviceNode,
                       IMG_UINT64 uiPxEProtMask,
                       IMG_UINT64 uiDataValidEnable,
                       IMG_UINT32 ui32Flags,
+                      IMG_UINT32 ui32VAParity,
+                      IMG_UINT32 ui32ParityShift,
+                      IMG_UINT64 ui64ParityMask,
                       PDUMP_MMU_TYPE eMMUType);
 
 PVRSRV_ERROR
diff --git a/drivers/gpu/drm/img-rogue/physheap.c b/drivers/gpu/drm/img-rogue/physheap.c
index 4b57898da80d..999f469bfcf3 100644
--- a/drivers/gpu/drm/img-rogue/physheap.c
+++ b/drivers/gpu/drm/img-rogue/physheap.c
@@ -54,6 +54,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "physmem.h"
 #include "physmem_hostmem.h"
 #include "physmem_lma.h"
+#include "physmem_dlm.h"
+#include "physmem_ima.h"
 #include "physmem_osmem.h"
 #include "debug_common.h"
 
@@ -94,7 +96,7 @@ struct _PHYS_HEAP_
 	/*! Pointer to next physical heap */
 	struct _PHYS_HEAP_		*psNext;
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	/*! IPA Policy value from Heap Config */
 	IMG_UINT32                  ui32IPAPolicyValue;
 
@@ -103,7 +105,7 @@ struct _PHYS_HEAP_
 
 	/*! IPA Bit Shift value from Heap Config */
 	IMG_UINT32                  ui32IPAShift;
-#endif /* defined(PVRSRV_SUPPORT_IPA_FEATURE) */
+#endif /* defined(SUPPORT_STATIC_IPA) */
 };
 
 #if defined(REFCOUNT_DEBUG)
@@ -195,7 +197,8 @@ static const IMG_FLAGS2DESC g_asPhysHeapUsageFlagStrings[] =
 	{PHYS_HEAP_USAGE_FW_PREMAP_PT,	"FW_PREMAP_PT"},
 	{PHYS_HEAP_USAGE_FW_PREMAP,		"FW_PREMAP"},
 	{PHYS_HEAP_USAGE_WRAP,			"WRAP"},
-	{PHYS_HEAP_USAGE_DISPLAY,		"DISPLAY"}
+	{PHYS_HEAP_USAGE_DISPLAY,		"DISPLAY"},
+	{PHYS_HEAP_USAGE_DLM,			"DLM"}
 };
 
 /*************************************************************************/ /*!
@@ -237,12 +240,12 @@ static PVRSRV_ERROR GetPhysHeapUsageString(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags,
 	PVR_LOG_RETURN_IF_INVALID_PARAM(ui32Size > 0, "ui32Size");
 
 	/* Initialise the string to be null terminated at the beginning */
-	uiSize = OSStringLCopy(pszUsageString, "\0", sizeof(IMG_CHAR));
+	pszUsageString[0] = '\0';
 
 	if (ui32UsageFlags == 0)
 	{
-		uiSize = OSStringLCopy(pszUsageString, "NONE", (size_t)ui32Size);
-		PVR_LOG_RETURN_IF_FALSE((uiSize < ui32Size), "OSStringLCopy", PVRSRV_ERROR_OUT_OF_MEMORY);
+		const ssize_t iCopiedCnt = OSStringSafeCopy(pszUsageString, "NONE", (size_t)ui32Size);
+		PVR_LOG_RETURN_IF_FALSE((iCopiedCnt >= 0), "OSStringSafeCopy", PVRSRV_ERROR_OUT_OF_MEMORY);
 
 		return PVRSRV_OK;
 	}
@@ -295,36 +298,33 @@ static PVRSRV_ERROR GetPhysHeapUsageString(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags,
 }
 
 /*************************************************************************/ /*!
-@Function       PhysHeapCreatePropertiesString
-@Description    This function is used to create a string containing properties
+@Function       PhysHeapPrintHeapProperties
+@Description    This function is used to print properties
                 of the specified physheap.
 
 @Input          psPhysHeap          The physheap to create the string from.
-@Input          ui32Size            The size of the memory pointed to by
-                                    pszPhysHeapString.
-@Output         pszPhysHeapString   A pointer to memory where the created string
-                                    will be stored.
+@Input          pfnDumpDebugPrintf  The specified print function that should be
+                                    used to dump any debug information
+                                    (see PVRSRVDebugRequest).
+@Input          pvDumpDebugFile     Optional file identifier to be passed to
+                                    the print function if required.
 
 @Return         If successful PVRSRV_OK, else a PVRSRV_ERROR.
 */ /**************************************************************************/
-static PVRSRV_ERROR PhysHeapCreatePropertiesString(PHYS_HEAP *psPhysHeap,
-                                                   IMG_UINT32 ui32Size,
-                                                   IMG_CHAR *pszPhysHeapString)
+static PVRSRV_ERROR PhysHeapPrintHeapProperties(PHYS_HEAP *psPhysHeap,
+                                                IMG_BOOL bDefaultHeap,
+                                                DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+                                                void *pvDumpDebugFile)
 {
 	static const IMG_CHAR *const pszTypeStrings[] = {
-		"UNKNOWN",
-		"UMA",
-		"LMA",
-		"DMA",
-#if defined(SUPPORT_WRAP_EXTMEMOBJECT)
-		"WRAP"
-#endif
+	#define X(_name) #_name,
+		PHYS_HEAP_TYPE_LIST
+	#undef X
 	};
 
 	IMG_UINT64 ui64TotalSize;
 	IMG_UINT64 ui64FreeSize;
 	IMG_CHAR pszUsageString[127] = "\0";
-	IMG_INT32 iCount;
 	PVRSRV_ERROR eError;
 
 	if (psPhysHeap->eType >= ARRAY_SIZE(pszTypeStrings))
@@ -335,16 +335,17 @@ static PVRSRV_ERROR PhysHeapCreatePropertiesString(PHYS_HEAP *psPhysHeap,
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_HEAPINFO, failure);
 	}
 
-	psPhysHeap->psImplFuncs->pfnGetPMRFactoryMemStats(psPhysHeap->pvImplData,
-	                                                  &ui64TotalSize,
-	                                                  &ui64FreeSize);
+	psPhysHeap->psImplFuncs->pfnGetFactoryMemStats(psPhysHeap->pvImplData,
+	                                               &ui64TotalSize,
+	                                               &ui64FreeSize);
 
 	eError = GetPhysHeapUsageString(psPhysHeap->ui32UsageFlags,
 	                                sizeof(pszUsageString),
 	                                pszUsageString);
 	PVR_LOG_GOTO_IF_ERROR(eError, "GetPhysHeapUsageString", failure);
 
-	if (psPhysHeap->eType == PHYS_HEAP_TYPE_LMA)
+	if ((psPhysHeap->eType == PHYS_HEAP_TYPE_LMA) ||
+	    (psPhysHeap->eType == PHYS_HEAP_TYPE_DLM))
 	{
 		IMG_CPU_PHYADDR sCPUPAddr;
 		IMG_DEV_PHYADDR sGPUPAddr;
@@ -368,52 +369,71 @@ static PVRSRV_ERROR PhysHeapCreatePropertiesString(PHYS_HEAP *psPhysHeap,
 			sGPUPAddr.uiAddr = IMG_UINT64_MAX;
 		}
 
-		iCount = OSSNPrintf(pszPhysHeapString,
-		                    ui32Size,
-		                    "0x%p -> PdMs: %s, Type: %s, "
-		                    "CPU PA Base: " CPUPHYADDR_UINT_FMTSPEC", "
-		                    "GPU PA Base: 0x%08"IMG_UINT64_FMTSPECx", "
-		                    "Usage Flags: 0x%08x (%s), Refs: %d, "
-		                    "Free Size: %"IMG_UINT64_FMTSPEC"B, "
-		                    "Total Size: %"IMG_UINT64_FMTSPEC"B",
-		                    psPhysHeap,
-		                    psPhysHeap->pszPDumpMemspaceName,
-		                    pszTypeStrings[psPhysHeap->eType],
-		                    CPUPHYADDR_FMTARG(sCPUPAddr.uiAddr),
-		                    sGPUPAddr.uiAddr,
-		                    psPhysHeap->ui32UsageFlags,
-		                    pszUsageString,
-		                    psPhysHeap->ui32RefCount,
-		                    ui64FreeSize,
-		                    ui64TotalSize);
+		PVR_DUMPDEBUG_LOG("0x%p -> PdMs: %s, Type: %s, %s, "
+		                  "CPU PA Base: " CPUPHYADDR_UINT_FMTSPEC", "
+		                  "GPU PA Base: 0x%08"IMG_UINT64_FMTSPECx", "
+		                  "Usage Flags: 0x%08x (%s), Refs: %d, "
+		                  "Free Size: %"IMG_UINT64_FMTSPEC"B, "
+		                  "Total Size: %"IMG_UINT64_FMTSPEC"B",
+		                  psPhysHeap,
+		                  psPhysHeap->pszPDumpMemspaceName,
+		                  pszTypeStrings[psPhysHeap->eType],
+		                  bDefaultHeap ? "default" : "-",
+		                  CPUPHYADDR_FMTARG(sCPUPAddr.uiAddr),
+		                  sGPUPAddr.uiAddr,
+		                  psPhysHeap->ui32UsageFlags,
+		                  pszUsageString,
+		                  psPhysHeap->ui32RefCount,
+		                  ui64FreeSize,
+		                  ui64TotalSize);
+	}
+	else if (psPhysHeap->eType == PHYS_HEAP_TYPE_IMA)
+	{
+		IMG_CHAR pszSpanString[128] = "\0";
+		void *pvIterHandle = NULL;
+
+		PVR_DUMPDEBUG_LOG("0x%p -> PdMs: %s, Type: %s, %s, "
+		                  "Usage Flags: 0x%08x (%s), Refs: %d, "
+		                  "Free Size: %"IMG_UINT64_FMTSPEC"B, "
+		                  "Total Size: %"IMG_UINT64_FMTSPEC"B Spans:",
+		                  psPhysHeap,
+		                  psPhysHeap->pszPDumpMemspaceName,
+		                  pszTypeStrings[psPhysHeap->eType],
+		                  bDefaultHeap ? "default" : "-",
+		                  psPhysHeap->ui32UsageFlags,
+		                  pszUsageString,
+		                  psPhysHeap->ui32RefCount,
+		                  ui64FreeSize,
+		                  ui64TotalSize);
+
+		while (psPhysHeap->psImplFuncs->pfnGetHeapSpansStringIter(psPhysHeap->pvImplData,
+		                                                                   pszSpanString,
+		                                                                   sizeof(pszSpanString),
+		                                                                   &pvIterHandle))
+		{
+			PVR_DUMPDEBUG_LOG("%s", pszSpanString);
+		}
 	}
 	else
 	{
-		iCount = OSSNPrintf(pszPhysHeapString,
-		                    ui32Size,
-		                    "0x%p -> PdMs: %s, Type: %s, "
-		                    "Usage Flags: 0x%08x (%s), Refs: %d, "
-		                    "Free Size: %"IMG_UINT64_FMTSPEC"B, "
-		                    "Total Size: %"IMG_UINT64_FMTSPEC"B",
-		                    psPhysHeap,
-		                    psPhysHeap->pszPDumpMemspaceName,
-		                    pszTypeStrings[psPhysHeap->eType],
-		                    psPhysHeap->ui32UsageFlags,
-		                    pszUsageString,
-		                    psPhysHeap->ui32RefCount,
-		                    ui64FreeSize,
-		                    ui64TotalSize);
+		PVR_DUMPDEBUG_LOG("0x%p -> PdMs: %s, Type: %s, %s, "
+		                  "Usage Flags: 0x%08x (%s), Refs: %d, "
+		                  "Free Size: %"IMG_UINT64_FMTSPEC"B, "
+		                  "Total Size: %"IMG_UINT64_FMTSPEC"B",
+		                  psPhysHeap,
+		                  psPhysHeap->pszPDumpMemspaceName,
+		                  pszTypeStrings[psPhysHeap->eType],
+		                  bDefaultHeap ? "default" : "-",
+		                  psPhysHeap->ui32UsageFlags,
+		                  pszUsageString,
+		                  psPhysHeap->ui32RefCount,
+		                  ui64FreeSize,
+		                  ui64TotalSize);
 	}
 
-	if (0 < iCount && iCount < (IMG_INT32)ui32Size)
-	{
-		return PVRSRV_OK;
-	}
-
-	eError = PVRSRV_ERROR_INVALID_PARAMS;
+	return PVRSRV_OK;
 
 failure:
-	OSStringLCopy(pszPhysHeapString, "\0", ui32Size);
 	return eError;
 }
 
@@ -440,6 +460,8 @@ static void PhysHeapDebugRequest(PVRSRV_DBGREQ_HANDLE pfnDbgRequestHandle,
 	PPVRSRV_DEVICE_NODE psDeviceNode = (PPVRSRV_DEVICE_NODE)pfnDbgRequestHandle;
 	PHYS_HEAP *psPhysHeap;
 
+	PVR_UNREFERENCED_PARAMETER(ui32VerbLevel);
+
 	PVR_LOG_RETURN_VOID_IF_FALSE(psDeviceNode != NULL,
 	                             "Phys Heap debug request failed. psDeviceNode was NULL");
 
@@ -448,19 +470,18 @@ static void PhysHeapDebugRequest(PVRSRV_DBGREQ_HANDLE pfnDbgRequestHandle,
 
 	for (psPhysHeap = psDeviceNode->psPhysHeapList; psPhysHeap != NULL; psPhysHeap = psPhysHeap->psNext)
 	{
-		IMG_CHAR pszPhysHeapString[256] = "\0";
 		PVRSRV_ERROR eError = PVRSRV_OK;
+		IMG_BOOL bDefaultHeap = psPhysHeap == psDeviceNode->apsPhysHeap[psDeviceNode->psDevConfig->eDefaultHeap];
 
-		eError = PhysHeapCreatePropertiesString(psPhysHeap,
-		                                         sizeof(pszPhysHeapString),
-		                                         pszPhysHeapString);
+		eError = PhysHeapPrintHeapProperties(psPhysHeap,
+		                                     bDefaultHeap,
+		                                     pfnDumpDebugPrintf,
+		                                     pvDumpDebugFile);
 		if (eError != PVRSRV_OK)
 		{
-			PVR_LOG_ERROR(eError, "PhysHeapCreatePropertiesString");
+			PVR_LOG_ERROR(eError, "PhysHeapCreateProperties");
 			continue;
 		}
-
-		PVR_DUMPDEBUG_LOG("%s", pszPhysHeapString);
 	}
 
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
@@ -490,8 +511,8 @@ static IMG_BOOL HeapCfgUsedByPVRLayer(PHYS_HEAP_CONFIG *psConfig)
 		 eHeap < PVRSRV_PHYS_HEAP_LAST;
 		 eHeap++)
 	{
-		if (BIT_ISSET(psConfig->ui32UsageFlags, eHeap) &&
-			PhysHeapCreatedByPVRLayer(eHeap))
+		if ((BIT_ISSET(psConfig->ui32UsageFlags, eHeap) &&
+		     PhysHeapCreatedByPVRLayer(eHeap)))
 		{
 			bPVRHeap = IMG_TRUE;
 			break;
@@ -501,6 +522,109 @@ static IMG_BOOL HeapCfgUsedByPVRLayer(PHYS_HEAP_CONFIG *psConfig)
 	return bPVRHeap;
 }
 
+#if defined(PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS)
+/*************************************************************************/ /*!
+@Function       PhysHeapCreateDLMIMAHeapsFromConfig
+@Description    Create new heaps for a device from DLM and IMA configs.
+                This function will both create and construct the link
+                between them.
+@Input          psDevNode      Pointer to device node struct
+@Input          pasConfigs     Pointer to array of Heap configurations.
+@Input          ui32NumConfigs Number of configurations in array.
+@Return         PVRSRV_ERROR PVRSRV_OK or error code
+*/ /**************************************************************************/
+static PVRSRV_ERROR
+PhysHeapCreateDLMIMAHeapsFromConfig(PVRSRV_DEVICE_NODE *psDevNode,
+                                    PHYS_HEAP_CONFIG *pasConfigs,
+                                    IMG_UINT32 ui32NumConfigs)
+{
+	/* The DLM heaps must be created before IMA heaps and the config order is not well-defined.
+	 * So for each DLM heap create it and then create the IMA heaps associated. */
+
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiDLMIdx, uiIMAIdx;
+	PHYS_HEAP_POLICY uiIMAPolicy = OSIsMapPhysNonContigSupported() ? PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG : PHYS_HEAP_POLICY_DEFAULT;
+	PHYS_HEAP *psDLMHeap;
+
+	/* Iterate and create the DLM heaps */
+	for (uiDLMIdx = 0; uiDLMIdx < ui32NumConfigs; uiDLMIdx++)
+	{
+		if (pasConfigs[uiDLMIdx].eType == PHYS_HEAP_TYPE_DLM)
+		{
+			IMG_UINT32 uiHeapCount = 0;
+			eError = PhysmemCreateHeapDLM(psDevNode,
+			                               PHYS_HEAP_POLICY_DEFAULT,
+			                               &pasConfigs[uiDLMIdx],
+			                               pasConfigs[uiDLMIdx].uConfig.sDLM.pszHeapName,
+			                               &psDLMHeap);
+			PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemCreateHeapDLM");
+
+			/* Then iterate and create the IMA heaps linked to this DLM heap */
+			for (uiIMAIdx = 0; uiIMAIdx < ui32NumConfigs; uiIMAIdx++)
+			{
+				if (pasConfigs[uiIMAIdx].eType == PHYS_HEAP_TYPE_IMA &&
+				    pasConfigs[uiIMAIdx].uConfig.sIMA.uiDLMHeapIdx == uiDLMIdx)
+				{
+					PhysmemCreateHeapIMA(psDevNode,
+					                     uiIMAPolicy,
+					                     &pasConfigs[uiIMAIdx],
+					                     pasConfigs[uiIMAIdx].uConfig.sIMA.pszHeapName,
+					                     psDLMHeap,
+					                     pasConfigs[uiDLMIdx].uConfig.sDLM.ui32Log2PMBSize,
+					                     NULL);
+					PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemCreateHeapIMA");
+					uiHeapCount++;
+				}
+			}
+
+			if (uiHeapCount == 0)
+			{
+				PVR_DPF((PVR_DBG_WARNING, "DLM phys heap config %d: No connected IMA heaps. Phys heap will go unused.", uiDLMIdx));
+			}
+		}
+	}
+
+	return PVRSRV_OK;
+}
+
+static void
+PhysHeapDestroyDLMIMAHeaps(PVRSRV_DEVICE_NODE *psDevNode)
+{
+	PHYS_HEAP *psNode = psDevNode->psPhysHeapList;
+
+	/* We need to ensure IMA heaps are destroyed before DLM so that
+	 * we don't cause RA leaks by freeing the DLM first.
+	 */
+	while (psNode)
+	{
+		PHYS_HEAP *psTmp = psNode;
+
+		psNode = psNode->psNext;
+
+		if (psTmp->eType == PHYS_HEAP_TYPE_IMA)
+		{
+			PhysHeapDestroy(psTmp);
+		}
+	}
+
+	/* Reset the loop */
+	psNode = psDevNode->psPhysHeapList;
+
+	while (psNode)
+	{
+		PHYS_HEAP *psTmp = psNode;
+
+		psNode = psNode->psNext;
+
+		if (psTmp->eType == PHYS_HEAP_TYPE_DLM)
+		{
+			PhysHeapDestroy(psTmp);
+		}
+	}
+}
+
+#endif
+
 /*************************************************************************/ /*!
 @Function       PhysHeapCreateDeviceHeapsFromConfigs
 @Description    Create new heaps for a device from configs.
@@ -519,6 +643,15 @@ PhysHeapCreateDeviceHeapsFromConfigs(PPVRSRV_DEVICE_NODE psDevNode,
 
 	psDevNode->psPhysHeapList = NULL;
 
+#if defined(PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS)
+	/* DLM/IMA heaps must be constructed in a specific order */
+	eError = PhysHeapCreateDLMIMAHeapsFromConfig(psDevNode,
+	                                             pasConfigs,
+	                                             ui32NumConfigs);
+	PVR_LOG_RETURN_IF_ERROR(eError, "PhysHeapCreateDLMIMAHeapsFromConfig");
+#endif
+
+
 	for (i = 0; i < ui32NumConfigs; i++)
 	{
 		/* A PhysHeapConfig can have multiple usage flags. If any flag in a
@@ -526,7 +659,10 @@ PhysHeapCreateDeviceHeapsFromConfigs(PPVRSRV_DEVICE_NODE psDevNode,
 		 * then we assume that a single heap is shared between multiple
 		 * allocators and it is safe to instantiate it here. If the heap
 		 * is not marked to be initialised by the PVR Layer, leave it
-		 * to the device specific handler. */
+		 * to the device specific handler.
+		 * DLM Heaps have usage flags but don't have element in the
+		 * fallback table, this check will prevent instantiate them twice.
+		 */
 		if (HeapCfgUsedByPVRLayer(&pasConfigs[i]))
 		{
 			eError = PhysHeapCreateHeapFromConfig(psDevNode, &pasConfigs[i], NULL);
@@ -576,7 +712,7 @@ PhysHeapCreateHeapFromConfig(PVRSRV_DEVICE_NODE *psDevNode,
 
 		if (psDevNode->pfnPhysHeapGetLMAPolicy != NULL)
 		{
-			uiHeapPolicy = psDevNode->pfnPhysHeapGetLMAPolicy(psConfig->ui32UsageFlags);
+			uiHeapPolicy = psDevNode->pfnPhysHeapGetLMAPolicy(psConfig->ui32UsageFlags, psDevNode);
 		}
 		else
 		{
@@ -593,6 +729,14 @@ PhysHeapCreateHeapFromConfig(PVRSRV_DEVICE_NODE *psDevNode,
 		                                "GPU LMA DMA (Sys)",
 		                               ppsPhysHeap);
 	}
+	else if ((psConfig->eType == PHYS_HEAP_TYPE_DLM) ||
+	         (psConfig->eType == PHYS_HEAP_TYPE_IMA))
+	{
+		/* These heaps have already been instantiated in
+		 * PhysHeapCreateDLMIMAHeapsFromConfig
+		 */
+		eResult = PVRSRV_OK;
+	}
 	else
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s Invalid phys heap type: %d",
@@ -603,7 +747,7 @@ PhysHeapCreateHeapFromConfig(PVRSRV_DEVICE_NODE *psDevNode,
 	return eResult;
 }
 
-#define PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE (0x100000ULL * 32ULL) /* 32MB */
+#define PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE (IMG_UINT64_C(0x100000) * IMG_UINT64_C(32)) /* 32MB */
 
 static PVRSRV_ERROR PVRSRVValidatePhysHeapConfig(PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
@@ -616,36 +760,113 @@ static PVRSRV_ERROR PVRSRVValidatePhysHeapConfig(PVRSRV_DEVICE_CONFIG *psDevConf
 
 	for (i = 0; i < psDevConfig->ui32PhysHeapCount; i++)
 	{
+		/* Flags that may be used by multiple heaps. */
+		const PHYS_HEAP_USAGE_FLAGS uiDuplicateFlags = PHYS_HEAP_USAGE_DLM;
 		PHYS_HEAP_CONFIG *psHeapConf = &psDevConfig->pasPhysHeaps[i];
 
 		PVR_LOG_RETURN_IF_FALSE_VA(psHeapConf->ui32UsageFlags != 0,
-								   PVRSRV_ERROR_PHYSHEAP_CONFIG,
-								   "Phys heap config %d: must specify usage flags.", i);
+		                           PVRSRV_ERROR_PHYSHEAP_CONFIG,
+		                           "Phys heap config %d: must specify usage flags.", i);
 
-		PVR_LOG_RETURN_IF_FALSE_VA((ui32FlagsAccumulate & psHeapConf->ui32UsageFlags) == 0,
-								PVRSRV_ERROR_PHYSHEAP_CONFIG,
-								"Phys heap config %d: duplicate usage flags.", i);
+		PVR_LOG_RETURN_IF_FALSE_VA(((ui32FlagsAccumulate & ~uiDuplicateFlags) & psHeapConf->ui32UsageFlags) == 0,
+		                             PVRSRV_ERROR_PHYSHEAP_CONFIG,
+		                             "Phys heap config %d: duplicate usage flags.", i);
 
 		ui32FlagsAccumulate |= psHeapConf->ui32UsageFlags;
 
-		/* Output message if default heap is LMA and smaller than recommended minimum */
 		if (BITMASK_ANY((1U << psDevConfig->eDefaultHeap), PHYS_HEAP_USAGE_MASK) &&
-			BITMASK_ANY((1U << psDevConfig->eDefaultHeap), psHeapConf->ui32UsageFlags) &&
+		    BITMASK_ANY((1U << psDevConfig->eDefaultHeap), psHeapConf->ui32UsageFlags))
+		{
+			switch (psHeapConf->eType)
+			{
 #if defined(__KERNEL__)
-		    ((psHeapConf->eType == PHYS_HEAP_TYPE_LMA) ||
-		     (psHeapConf->eType == PHYS_HEAP_TYPE_DMA)) &&
-#else
-		    (psHeapConf->eType == PHYS_HEAP_TYPE_LMA) &&
+				case PHYS_HEAP_TYPE_DMA:
 #endif
-		    (psHeapConf->uiSize < PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE))
+				case PHYS_HEAP_TYPE_LMA:
+				{
+					if (psHeapConf->uConfig.sLMA.uiSize < PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE)
+					{
+						/* Output message if default heap is LMA and smaller than recommended minimum. */
+						PVR_DPF((PVR_DBG_ERROR, "%s: Size of default heap is 0x%" IMG_UINT64_FMTSPECX
+						         " (recommended minimum heap size is 0x%" IMG_UINT64_FMTSPECX ")",
+						         __func__, psHeapConf->uConfig.sLMA.uiSize,
+						         PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE));
+					}
+					break;
+				}
+				case PHYS_HEAP_TYPE_IMA:
+				{
+					/* Check if chained DLM has more than default LMA size.
+					 * This is not perfect as other connected IMAs could reserve all the memory. */
+					IMG_UINT64 uiSize = psDevConfig->pasPhysHeaps[psHeapConf->uConfig.sIMA.uiDLMHeapIdx].uConfig.sDLM.uiSize;
+
+					if (uiSize < PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE)
+					{
+						PVR_DPF((PVR_DBG_ERROR, "%s: Default heap has access to 0x%" IMG_UINT64_FMTSPECX
+						         " (recommended minimum heap size is 0x%" IMG_UINT64_FMTSPECX ")",
+						         __func__, uiSize,
+						         PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE));
+					}
+					break;
+				}
+				case PHYS_HEAP_TYPE_DLM:
+				{
+					PVR_DPF((PVR_DBG_ERROR, "%s: Phys heap config %d: "
+					         "A DLM heap cannot be the default heap.",
+					         __func__, i));
+					return PVRSRV_ERROR_PHYSHEAP_CONFIG;
+				}
+				default:
+					break;
+			}
+		}
+
+#if !defined(PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS)
+		if ((psHeapConf->eType == PHYS_HEAP_TYPE_IMA) || (psHeapConf->eType == PHYS_HEAP_TYPE_DLM))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: Phys heap config %d: "
+			         "Dynamic phys heaps are not supported! "
+			         "Please enable PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS",
+			         __func__, i));
+			return PVRSRV_ERROR_PHYSHEAP_CONFIG;
+		}
+#else /* PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS */
+		if (psHeapConf->eType == PHYS_HEAP_TYPE_DLM)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Size of default heap is 0x%" IMG_UINT64_FMTSPECX
-			         " (recommended minimum heap size is 0x%llx)",
-			         __func__, psHeapConf->uiSize,
-			         PVRSRV_MIN_DEFAULT_LMA_PHYS_HEAP_SIZE));
+			PVR_LOG_RETURN_IF_FALSE_VA((psHeapConf->ui32UsageFlags & PHYS_HEAP_USAGE_DLM) == PHYS_HEAP_USAGE_DLM,
+			                            PVRSRV_ERROR_PHYSHEAP_CONFIG,
+			                            "Phys heap config %d: DLM heap must specify the DLM usage flag.", i);
+
+			/* If a DLM heap has less space than a PMB, it cannot export a single PMB. The PMB size should be lowered. */
+			PVR_LOG_RETURN_IF_FALSE_VA(psHeapConf->uConfig.sDLM.uiSize >= psHeapConf->uConfig.sDLM.ui32Log2PMBSize,
+			                           PVRSRV_ERROR_PHYSHEAP_CONFIG,
+			                           "Phys heap config %d: Size of DLM heap is 0x%" IMG_UINT64_FMTSPECX
+			                           " but the PMB size is 0x%" IMG_UINT64_FMTSPECX
+			                           ". The total size must be greater than or equal to the PMB size.",
+			                           i, psHeapConf->uConfig.sDLM.uiSize,
+			                           IMG_UINT64_C(1) << psHeapConf->uConfig.sDLM.ui32Log2PMBSize);
 		}
+
+		/* IMA heaps must point to a DLM heap. */
+		if (psHeapConf->eType == PHYS_HEAP_TYPE_IMA)
+		{
+			PVR_LOG_RETURN_IF_FALSE_VA(psHeapConf->uConfig.sIMA.uiDLMHeapIdx < psDevConfig->ui32PhysHeapCount,
+			                           PVRSRV_ERROR_PHYSHEAP_CONFIG,
+			                           "Phys heap config %d: IMA heap is trying to link to a DLM heap out of bounds. "
+			                           "Requested Heap Index: %d, Heap Array Count: %d",
+			                           i, psHeapConf->uConfig.sIMA.uiDLMHeapIdx, psDevConfig->ui32PhysHeapCount);
+			PVR_LOG_RETURN_IF_FALSE_VA(psDevConfig->pasPhysHeaps[psHeapConf->uConfig.sIMA.uiDLMHeapIdx].eType == PHYS_HEAP_TYPE_DLM,
+			                           PVRSRV_ERROR_PHYSHEAP_CONFIG,
+			                           "Phys heap config %d: IMA heap is trying to link to a NON-DLM heap type. "
+			                           "Requested Heap Idx: %d, Heap Type: %d",
+			                           i, psHeapConf->uConfig.sIMA.uiDLMHeapIdx,
+			                           psDevConfig->pasPhysHeaps[psHeapConf->uConfig.sIMA.uiDLMHeapIdx].eType);
+		}
+#endif /* PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS */
+
 	}
 
+
 	if (psDevConfig->eDefaultHeap == PVRSRV_PHYS_HEAP_GPU_LOCAL)
 	{
 		PVR_LOG_RETURN_IF_FALSE(((ui32FlagsAccumulate & PHYS_HEAP_USAGE_GPU_LOCAL) != 0) ,
@@ -663,6 +884,8 @@ static PVRSRV_ERROR PVRSRVValidatePhysHeapConfig(PVRSRV_DEVICE_CONFIG *psDevConf
 }
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
+static void DestroyGpuVirtValArenas(PVRSRV_DEVICE_NODE *psDeviceNode);
+
 /*************************************************************************/ /*!
 @Function       CreateGpuVirtValArenas
 @Description    Create virtualization validation arenas
@@ -676,106 +899,191 @@ static PVRSRV_ERROR CreateGpuVirtValArenas(PVRSRV_DEVICE_NODE *psDeviceNode)
 	IMG_UINT64 aui64OSidMin[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS];
 	IMG_UINT64 aui64OSidMax[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS];
 	PHYS_HEAP_CONFIG *psGPULocalHeap = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig, PHYS_HEAP_USAGE_GPU_LOCAL);
+	IMG_DEV_PHYADDR sGPULocalCardBase = PhysHeapConfigGetCardBase(psGPULocalHeap);
+	IMG_UINT64 uiGPULocalSize = PhysHeapConfigGetSize(psGPULocalHeap);
 	PHYS_HEAP_CONFIG *psDisplayHeap = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig, PHYS_HEAP_USAGE_DISPLAY);
-	IMG_UINT64 uBase;
-	IMG_UINT64 uSize;
-	IMG_UINT64 uBaseShared;
-	IMG_UINT64 uSizeShared;
-	IMG_UINT64 uSizeSharedReg;
+
+	IMG_UINT64 uPrivateRABase;
+	IMG_UINT64 uPrivateRASize;
+	IMG_UINT64 uSharedRABase;
+	IMG_UINT64 uSharedRASize;
+	IMG_UINT64 uSharedRegionBase;
+	IMG_UINT64 uSharedRegionSize;
 	IMG_UINT32 i;
 
-	/* Shared region is fixed size, the remaining space is divided amongst OSes */
-	uSizeShared = PVR_ALIGN(GPUVIRT_SIZEOF_SHARED, (IMG_DEVMEM_SIZE_T)OSGetPageSize());
-	uSize = psGPULocalHeap->uiSize - uSizeShared;
-	uSize /= GPUVIRT_VALIDATION_NUM_OS;
-	uSize = uSize & ~((IMG_UINT64)OSGetPageSize() - 1ULL); /* Align, round down */
+	//PVR_LOG_RETURN_IF_FALSE((psDeviceNode->psOSSharedArena == NULL), "Validation RAs already created.", PVRSRV_OK);
 
-	uBase = psGPULocalHeap->sCardBase.uiAddr;
-	uBaseShared = uBase + uSize * GPUVIRT_VALIDATION_NUM_OS;
-	uSizeShared = psGPULocalHeap->uiSize - (uBaseShared - uBase);
+	/* Shared region is fixed size, the remaining space is divided amongst OSes */
+	uPrivateRASize = uiGPULocalSize - PVR_ALIGN(GPUVIRT_SIZEOF_SHARED, (IMG_DEVMEM_SIZE_T)OSGetPageSize());
+	uPrivateRASize /= GPUVIRT_VALIDATION_NUM_OS;
+	uPrivateRASize = uPrivateRASize & ~((IMG_UINT64)OSGetPageSize() - 1ULL); /* Align, round down */
+	uSharedRASize = uiGPULocalSize - uPrivateRASize * GPUVIRT_VALIDATION_NUM_OS;
 
-	PVR_LOG(("GPUVIRT_VALIDATION split GPU_LOCAL base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".",
-			 psGPULocalHeap->sCardBase.uiAddr,
-			 psGPULocalHeap->uiSize));
+	PVR_LOG(("GPUVIRT_VALIDATION: GPU_LOCAL heap base (base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ")"
+			 " split into %u private regions of size 0x%" IMG_UINT64_FMTSPECX " and one shared region of size 0x%" IMG_UINT64_FMTSPECX " ",
+			 sGPULocalCardBase.uiAddr, uiGPULocalSize, GPUVIRT_VALIDATION_NUM_OS, uPrivateRASize, uSharedRASize));
 
 	/* If a display heap config exists, include the display heap in the non-secure regions */
 	if (psDisplayHeap)
 	{
-		/* Only works when DISPLAY heap follows GPU_LOCAL heap. */
-		PVR_LOG(("GPUVIRT_VALIDATION include DISPLAY in shared, base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".",
-				 psDisplayHeap->sCardBase.uiAddr,
-				 psDisplayHeap->uiSize));
+		IMG_DEV_PHYADDR sGPUDisplayCardBase = PhysHeapConfigGetCardBase(psDisplayHeap);
+		IMG_UINT64 uiGPUDisplaySize = PhysHeapConfigGetSize(psDisplayHeap);
+
+		PVR_LOG(("GPUVIRT_VALIDATION: DISPLAY heap (base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ") merged into shared region.",
+		         sGPUDisplayCardBase.uiAddr,
+		         uiGPUDisplaySize));
+
+		if (sGPUDisplayCardBase.uiAddr > sGPULocalCardBase.uiAddr)
+		{
+			/*
+			 * ---------------------------------------------------------------------------------------------------
+			 * |        .        .        .     GPU LOCAL HEAP       .        .        .        |  DISPLAY HEAP  |
+			 * ---------------------------------------------------------------------------------------------------
+			 *  \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/ \_______________/
+			 *   OSID 0   OSID 1   OSID 2   OSID 3   OSID 4   OSID 5   OSID 6   OSID 7   SHARED      DISPLAY
+			 *                                                                            \____SHARED REGION____/
+			 *  OSID 0 has full access over everything
+			 *  Shared RA of the GPU Local heap is accessible to all OSIDs for special purpose allocations.
+			 */
+			if ((sGPULocalCardBase.uiAddr + uiGPULocalSize) != sGPUDisplayCardBase.uiAddr)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: GPU Local heap and display heap must be adjacent in physical memory.", __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+
+			uPrivateRABase = sGPULocalCardBase.uiAddr;
+			uSharedRABase = sGPULocalCardBase.uiAddr + uiGPULocalSize - uSharedRASize;
+			uSharedRegionBase = uSharedRABase;
+		}
+		else
+		{
+			/*
+			 * ---------------------------------------------------------------------------------------------------
+			 * |  DISPLAY HEAP   |        .        .        .     GPU LOCAL HEAP       .        .        .       |
+			 * ---------------------------------------------------------------------------------------------------
+			 *  \_______________/ \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/
+			 *        DISPLAY      SHARED   OSID 0   OSID 1   OSID 2   OSID 3   OSID 4   OSID 5   OSID 6   OSID 7
+			 *   \____SHARED REGION____/
+			 *
+			 *  OSID 0 has full access over everything
+			 *  Shared RA of the GPU Local heap is accessible to all OSIDs for special purpose allocations.
+			 */
+			if ((sGPUDisplayCardBase.uiAddr + uiGPUDisplaySize) != sGPULocalCardBase.uiAddr)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: GPU Local heap and display heap must be adjacent in physical memory.", __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
 
-		uSizeSharedReg = uSizeShared + psDisplayHeap->uiSize;
+			uSharedRABase = sGPULocalCardBase.uiAddr;
+			uPrivateRABase = sGPULocalCardBase.uiAddr + uSharedRASize;
+			uSharedRegionBase = sGPUDisplayCardBase.uiAddr;
+		}
+
+		uSharedRegionSize = uSharedRASize + uiGPUDisplaySize;
 	}
 	else
 	{
-		uSizeSharedReg = uSizeShared;
+		/*
+		 * ----------------------------------------------------------------------------------
+		 * |        .        .        .     GPU LOCAL HEAP       .        .        .        |
+		 * ----------------------------------------------------------------------------------
+		 *  \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/ \______/
+		 *   OSID 0   OSID 1   OSID 2   OSID 3   OSID 4   OSID 5   OSID 6   OSID 7   SHARED
+		 *
+		 *  OSID 0 has full access over everything
+		 *  Shared RA of the GPU Local heap is accessible to all OSIDs for special purpose allocations.
+		 */
+		uPrivateRABase = sGPULocalCardBase.uiAddr;
+		uSharedRABase = uPrivateRABase + uPrivateRASize * GPUVIRT_VALIDATION_NUM_OS;
+		uSharedRASize = uiGPULocalSize - (uSharedRABase - uPrivateRABase);
+		uSharedRegionSize = uSharedRASize;
+		uSharedRegionBase = uSharedRABase;
+	}
+
+	if (uPrivateRASize < GPUVIRT_MIN_SIZE)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Per-OSID private memory regions are too small (current: 0x%" IMG_UINT64_FMTSPECX ""
+								" required: 0x%" IMG_UINT64_FMTSPECX "). Increase GPU Local heap size.",
+								__func__, uPrivateRASize, GPUVIRT_MIN_SIZE));
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	PVR_ASSERT(uSize >= GPUVIRT_MIN_SIZE);
-	PVR_ASSERT(uSizeSharedReg >= GPUVIRT_SIZEOF_SHARED);
+	if (uSharedRASize < GPUVIRT_SIZEOF_SHARED)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Memory region shared between all OSIDs is too small (current: 0x%" IMG_UINT64_FMTSPECX ""
+								" required: 0x%" IMG_UINT64_FMTSPECX "). Increase GPU Local heap size.",
+								__func__, uSharedRASize, GPUVIRT_SIZEOF_SHARED));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
 
 	FOREACH_VALIDATION_OSID(i)
 	{
 		IMG_CHAR aszOSRAName[RA_MAX_NAME_LENGTH];
 
-		PVR_LOG(("GPUVIRT_VALIDATION create arena OS: %d, base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".", i, uBase, uSize));
+		PVR_LOG(("GPUVIRT_VALIDATION: create arena Private OSID: %u, base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".", i, uPrivateRABase, uPrivateRASize));
 
-		OSSNPrintf(aszOSRAName, RA_MAX_NAME_LENGTH, "GPUVIRT_OS%d", i);
+		OSSNPrintf(aszOSRAName, RA_MAX_NAME_LENGTH, "GPUVIRT_OS%u", i);
 
 		psDeviceNode->psOSidSubArena[i] = RA_Create_With_Span(aszOSRAName,
 		                                                      OSGetPageShift(),
 		                                                      0,
-		                                                      uBase,
-		                                                      uSize,
+		                                                      uPrivateRABase,
+		                                                      uPrivateRASize,
 		                                                      RA_POLICY_DEFAULT);
-		PVR_LOG_RETURN_IF_NOMEM(psDeviceNode->psOSidSubArena[i], "RA_Create_With_Span");
-
-		aui64OSidMin[GPUVIRT_VAL_REGION_SECURE][i] = uBase;
+		PVR_GOTO_IF_FALSE(psDeviceNode->psOSidSubArena[i] != NULL, FreeArenas);
+		aui64OSidMin[GPUVIRT_VAL_REGION_SECURE][i] = uPrivateRABase;
 
 		if (i == 0)
 		{
-			/* OSid0 has access to all regions */
-			aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i] = psGPULocalHeap->uiSize - 1ULL;
+			/* Host OSID0 has access to all regions */
+			aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i] = uiGPULocalSize - 1ULL;
 		}
 		else
 		{
-			aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i] = uBase + uSize - 1ULL;
+			/* Guest OSIDs are limited to their private range */
+			aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i] = uPrivateRABase + uPrivateRASize - 1ULL;
 		}
 
-		/* uSizeSharedReg includes display heap */
-		aui64OSidMin[GPUVIRT_VAL_REGION_SHARED][i] = uBaseShared;
-		aui64OSidMax[GPUVIRT_VAL_REGION_SHARED][i] = uBaseShared + uSizeSharedReg - 1ULL;
+		/* uSharedRegionSize includes display heap */
+		aui64OSidMin[GPUVIRT_VAL_REGION_SHARED][i] = uSharedRegionBase;
+		aui64OSidMax[GPUVIRT_VAL_REGION_SHARED][i] = uSharedRegionBase + uSharedRegionSize - 1ULL;
 
-		PVR_LOG(("GPUVIRT_VALIDATION HW reg regions %d: min[0]: 0x%" IMG_UINT64_FMTSPECX ", max[0]: 0x%" IMG_UINT64_FMTSPECX ", min[1]: 0x%" IMG_UINT64_FMTSPECX ", max[1]: 0x%" IMG_UINT64_FMTSPECX ",",
-				 i,
-				 aui64OSidMin[GPUVIRT_VAL_REGION_SECURE][i],
-				 aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i],
-				 aui64OSidMin[GPUVIRT_VAL_REGION_SHARED][i],
-				 aui64OSidMax[GPUVIRT_VAL_REGION_SHARED][i]));
-		uBase += uSize;
+		uPrivateRABase += uPrivateRASize;
 	}
 
-	PVR_LOG(("GPUVIRT_VALIDATION create arena Shared, base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".", uBaseShared, uSizeShared));
+	PVR_LOG(("GPUVIRT_VALIDATION: create arena Shared, base: 0x%" IMG_UINT64_FMTSPECX ", size: 0x%" IMG_UINT64_FMTSPECX ".", uSharedRABase, uSharedRASize));
 
-	PVR_ASSERT(uSizeShared >= GPUVIRT_SIZEOF_SHARED);
-
-	/* uSizeShared does not include  display heap */
+	/* uSharedRASize does not include display heap */
 	psDeviceNode->psOSSharedArena = RA_Create_With_Span("GPUVIRT_SHARED",
 	                                                    OSGetPageShift(),
 	                                                    0,
-	                                                    uBaseShared,
-	                                                    uSizeShared,
+	                                                    uSharedRABase,
+	                                                    uSharedRASize,
 	                                                    RA_POLICY_DEFAULT);
-	PVR_LOG_RETURN_IF_NOMEM(psDeviceNode->psOSSharedArena, "RA_Create_With_Span");
+	PVR_GOTO_IF_FALSE(psDeviceNode->psOSSharedArena != NULL, FreeArenas);
 
-	if (psDeviceNode->psDevConfig->pfnSysDevVirtInit != NULL)
+	FOREACH_VALIDATION_OSID(i)
 	{
-		psDeviceNode->psDevConfig->pfnSysDevVirtInit(psDeviceNode->psDevConfig->hSysData, aui64OSidMin, aui64OSidMax);
+		PVR_LOG(("GPUVIRT_VALIDATION: HW regions OSID %u: Private Region = [0x%" IMG_UINT64_FMTSPECX "..0x%" IMG_UINT64_FMTSPECX "]"
+														" Shared Region = [0x%" IMG_UINT64_FMTSPECX "..0x%" IMG_UINT64_FMTSPECX "]",
+				 i,
+				 aui64OSidMin[GPUVIRT_VAL_REGION_SECURE][i],
+				 aui64OSidMax[GPUVIRT_VAL_REGION_SECURE][i],
+				 aui64OSidMin[GPUVIRT_VAL_REGION_SHARED][i],
+				 aui64OSidMax[GPUVIRT_VAL_REGION_SHARED][i]));
+	}
+
+	if (psDeviceNode->psDevConfig->pfnSysInitFirewall != NULL)
+	{
+		psDeviceNode->psDevConfig->pfnSysInitFirewall(psDeviceNode->psDevConfig->hSysData, aui64OSidMin, aui64OSidMax);
 	}
 
 	return PVRSRV_OK;
+
+FreeArenas:
+	DestroyGpuVirtValArenas(psDeviceNode);
+
+	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
 /*
@@ -967,26 +1275,87 @@ PVRSRV_ERROR PhysHeapCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	}
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psImplFuncs != NULL, "psImplFuncs");
-	PVR_LOG_RETURN_IF_INVALID_PARAM(psImplFuncs->pfnCreatePMR != NULL, "psImplFuncs->pfnCreatePMR");
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psImplFuncs->pfnCreatePMR != NULL ||
+	                                psImplFuncs->pfnCreatePMB,
+	                                "psImplFuncs->pfnCreatePMR || psImplFuncs->pfnCreatePMB");
 
 	psNew = OSAllocMem(sizeof(PHYS_HEAP));
 	PVR_RETURN_IF_NOMEM(psNew);
-	psNew->psDevNode = psDevNode;
+
+	switch (psConfig->eType)
+	{
+	case PHYS_HEAP_TYPE_LMA:
+		psNew->psMemFuncs = psConfig->uConfig.sLMA.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sLMA.hPrivData;
+		psNew->pszPDumpMemspaceName = psConfig->uConfig.sLMA.pszPDumpMemspaceName;
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sLMA.pszHeapName) ? psConfig->uConfig.sLMA.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+	case PHYS_HEAP_TYPE_IMA:
+		psNew->psMemFuncs = psConfig->uConfig.sIMA.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sIMA.hPrivData;
+		psNew->pszPDumpMemspaceName = psConfig->uConfig.sIMA.pszPDumpMemspaceName;
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sIMA.pszHeapName) ? psConfig->uConfig.sIMA.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+	case PHYS_HEAP_TYPE_DMA:
+		psNew->psMemFuncs = psConfig->uConfig.sDMA.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sDMA.hPrivData;
+		psNew->pszPDumpMemspaceName = psConfig->uConfig.sDMA.pszPDumpMemspaceName;
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sDMA.pszHeapName) ? psConfig->uConfig.sDMA.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+	case PHYS_HEAP_TYPE_UMA:
+		psNew->psMemFuncs = psConfig->uConfig.sUMA.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sUMA.hPrivData;
+		psNew->pszPDumpMemspaceName = psConfig->uConfig.sUMA.pszPDumpMemspaceName;
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sUMA.pszHeapName) ? psConfig->uConfig.sUMA.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+	case PHYS_HEAP_TYPE_DLM:
+		psNew->psMemFuncs = psConfig->uConfig.sDLM.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sDLM.hPrivData;
+		psNew->pszPDumpMemspaceName = "None";
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sDLM.pszHeapName) ? psConfig->uConfig.sDLM.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+#if defined(SUPPORT_WRAP_EXTMEMOBJECT)
+	case PHYS_HEAP_TYPE_WRAP:
+		psNew->psMemFuncs = psConfig->uConfig.sWRAP.psMemFuncs;
+		psNew->hPrivData = psConfig->uConfig.sWRAP.hPrivData;
+		psNew->pszPDumpMemspaceName = psConfig->uConfig.sWRAP.pszPDumpMemspaceName;
+		OSStringSafeCopy(psNew->aszName,
+		                 (psConfig->uConfig.sWRAP.pszHeapName) ? psConfig->uConfig.sWRAP.pszHeapName :
+		                                                        "Unknown PhysHeap",
+		                 PHYS_HEAP_NAME_SIZE);
+		break;
+#endif
+	default:
+		PVR_LOG_ERROR(PVRSRV_ERROR_NOT_IMPLEMENTED, "psConfig->eType not implemented");
+	}
+
 	psNew->eType = psConfig->eType;
+	psNew->ui32UsageFlags = psConfig->ui32UsageFlags;
 	psNew->uiPolicy = uiPolicy;
-	psNew->psMemFuncs = psConfig->psMemFuncs;
-	psNew->hPrivData = psConfig->hPrivData;
 	psNew->ui32RefCount = 0;
-	psNew->pszPDumpMemspaceName = psConfig->pszPDumpMemspaceName;
-	psNew->ui32UsageFlags = psConfig->ui32UsageFlags;
+	psNew->psDevNode = psDevNode;
 #if !defined(PVRSRV_PHYSHEAP_DISABLE_OOM_DEMOTION)
 	OSAtomicWrite(&psNew->sOOMDetected, IMG_FALSE);
 #endif
-
 	psNew->pvImplData = pvImplData;
 	psNew->psImplFuncs = psImplFuncs;
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	{
 		IMG_UINT8  ui8Val;
 
@@ -1008,10 +1377,6 @@ PVRSRV_ERROR PhysHeapCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	}
 #endif
 
-	OSStringLCopy(psNew->aszName,
-				  (psConfig->pszHeapName) ? psConfig->pszHeapName : "Unknown PhysHeap",
-				  PHYS_HEAP_NAME_SIZE);
-
 	if (ppsPhysHeap != NULL)
 	{
 		*ppsPhysHeap = psNew;
@@ -1025,13 +1390,20 @@ PVRSRV_ERROR PhysHeapCreate(PPVRSRV_DEVICE_NODE psDevNode,
 
 void PhysHeapDestroyDeviceHeaps(PPVRSRV_DEVICE_NODE psDevNode)
 {
-	PHYS_HEAP *psNode = psDevNode->psPhysHeapList;
+	PHYS_HEAP *psNode;
 
 	if (psDevNode->hPhysHeapDbgReqNotify)
 	{
 		PVRSRVUnregisterDeviceDbgRequestNotify(psDevNode->hPhysHeapDbgReqNotify);
 	}
 
+#if defined(PVRSRV_ENABLE_DYNAMIC_PHYSHEAPS)
+	/* DLM/IMA heaps must be destroyed in a specific order */
+	PhysHeapDestroyDLMIMAHeaps(psDevNode);
+#endif
+
+	psNode = psDevNode->psPhysHeapList;
+
 	while (psNode)
 	{
 		PHYS_HEAP *psTmp = psNode;
@@ -1170,8 +1542,10 @@ static PHYS_HEAP* _PhysHeapFindRealHeapNoFallback(PVRSRV_PHYS_HEAP ePhysHeap,
 		ePhysHeap = psDevNode->psDevConfig->eDefaultHeap;
 	}
 
-	/* Check cache of PhysHeaps to see if it has been resolved before */
-	if (BIT_ISSET(psDevNode->apsPhysHeap[ePhysHeap]->ui32UsageFlags, ePhysHeap))
+	/* Check cache of PhysHeaps to see if it has been resolved before.
+	 * The physheap must initialised to access its cache. */
+	if (psDevNode->apsPhysHeap[ePhysHeap] != NULL &&
+	    BIT_ISSET(psDevNode->apsPhysHeap[ePhysHeap]->ui32UsageFlags, ePhysHeap))
 	{
 		return psDevNode->apsPhysHeap[ePhysHeap];
 	}
@@ -1277,7 +1651,7 @@ IMG_BOOL PhysHeapValidateDefaultHeapExists(PPVRSRV_DEVICE_NODE psDevNode)
 			  psDevNode->apsPhysHeap[eDefaultHeap])));
 }
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 IMG_UINT32 PhysHeapGetIPAValue(PHYS_HEAP *psPhysHeap)
 {
 	return psPhysHeap->ui32IPAPolicyValue;
@@ -1349,6 +1723,51 @@ PVRSRV_ERROR PhysHeapGetSize(PHYS_HEAP *psPhysHeap,
 	return eResult;
 }
 
+/* Used to add the total and free sizes of an IMA heap and the backing
+ * DLM heap
+ */
+static void PhysHeapIMAGetMemInfo(PHYS_HEAP *psPhysHeap,
+                                  IMG_UINT64 *puiTotalSize,
+                                  IMG_UINT64 *puiFreeSize)
+{
+	PHYS_HEAP *psDLMHeap;
+	IMG_UINT64 ui64TotalSize;
+	IMG_UINT64 ui64FreeSize;
+	IMG_UINT64 ui64DLMTotalSize;
+	IMG_UINT64 ui64DLMFreeSize;
+
+	PVR_LOG_RETURN_VOID_IF_FALSE(
+		psPhysHeap->eType == PHYS_HEAP_TYPE_IMA,
+		"Physheap type not IMA");
+
+	/* Obtain the DLM heap chained to this IMA heap */
+	PVR_ASSERT(psPhysHeap->psImplFuncs->pfnGetHeapDLMBacking);
+	psPhysHeap->psImplFuncs->pfnGetHeapDLMBacking(psPhysHeap->pvImplData,
+	                                              &psDLMHeap);
+	PVR_LOG_RETURN_VOID_IF_FALSE(psDLMHeap != NULL, "pfnGetHeapDLMBacking");
+
+	/* Obtain the memstats for the current IMA heap */
+	PVR_ASSERT(psPhysHeap->psImplFuncs->pfnGetFactoryMemStats);
+	psPhysHeap->psImplFuncs->pfnGetFactoryMemStats(psPhysHeap->pvImplData,
+	                                               &ui64TotalSize,
+	                                               &ui64FreeSize);
+
+	/* Obtain the memstats for the chained DLM heap */
+	PVR_ASSERT(psDLMHeap->psImplFuncs->pfnGetFactoryMemStats);
+	psDLMHeap->psImplFuncs->pfnGetFactoryMemStats(psDLMHeap->pvImplData,
+	                                              &ui64DLMTotalSize,
+	                                              &ui64DLMFreeSize);
+
+	/* Total size is just the DLM heap size as the IMA heap imports a
+	 * subset of that total size.
+	 * Free size is a combination of the two because DLM heap may
+	 * have spare PMBs to provide and the IMA heap may have space
+	 * in an imported PMB.
+	 */
+	*puiTotalSize = ui64DLMTotalSize;
+	*puiFreeSize = ui64FreeSize + ui64DLMFreeSize;
+}
+
 PVRSRV_ERROR
 PhysHeapGetMemInfo(PVRSRV_DEVICE_NODE *psDevNode,
                    IMG_UINT32 ui32PhysHeapCount,
@@ -1375,22 +1794,33 @@ PhysHeapGetMemInfo(PVRSRV_DEVICE_NODE *psDevNode,
 		paPhysHeapMemStats[i].ui32PhysHeapFlags = 0;
 
 		if (psPhysHeap && PhysHeapUserModeAlloc(paePhysHeapID[i])
-				&& psPhysHeap->psImplFuncs->pfnGetPMRFactoryMemStats)
+				&& psPhysHeap->psImplFuncs->pfnGetFactoryMemStats)
 		{
-			psPhysHeap->psImplFuncs->pfnGetPMRFactoryMemStats(psPhysHeap->pvImplData,
-					&paPhysHeapMemStats[i].ui64TotalSize,
-					&paPhysHeapMemStats[i].ui64FreeSize);
-			paPhysHeapMemStats[i].ui32PhysHeapFlags |= PhysHeapGetType(psPhysHeap);
+			if (psPhysHeap->eType == PHYS_HEAP_TYPE_IMA)
+			{
+				PhysHeapIMAGetMemInfo(psPhysHeap,
+				                      &paPhysHeapMemStats[i].ui64TotalSize,
+				                      &paPhysHeapMemStats[i].ui64FreeSize);
+			}
+			else
+			{
+				psPhysHeap->psImplFuncs->pfnGetFactoryMemStats(psPhysHeap->pvImplData,
+				                                               &paPhysHeapMemStats[i].ui64TotalSize,
+				                                               &paPhysHeapMemStats[i].ui64FreeSize);
+			}
 
 			if (paePhysHeapID[i] == psDevNode->psDevConfig->eDefaultHeap)
 			{
 				paPhysHeapMemStats[i].ui32PhysHeapFlags |= PVRSRV_PHYS_HEAP_FLAGS_IS_DEFAULT;
 			}
+
+			paPhysHeapMemStats[i].ePhysHeapType = psPhysHeap->eType;
 		}
 		else
 		{
 			paPhysHeapMemStats[i].ui64TotalSize = 0;
 			paPhysHeapMemStats[i].ui64FreeSize = 0;
+			paPhysHeapMemStats[i].ePhysHeapType = PHYS_HEAP_TYPE_UNKNOWN;
 		}
 	}
 
@@ -1574,6 +2004,30 @@ PVRSRV_ERROR PhysHeapCreatePMR(PHYS_HEAP *psPhysHeap,
 	return eError;
 }
 
+PVRSRV_ERROR PhysHeapCreatePMB(PHYS_HEAP *psPhysHeap,
+                               IMG_DEVMEM_SIZE_T uiSize,
+                               const IMG_CHAR *pszAnnotation,
+                               PMB **ppsPMRPtr,
+                               RA_BASE_T *puiBase,
+                               RA_LENGTH_T *puiSize)
+{
+	PHEAP_IMPL_FUNCS *psImplFuncs = psPhysHeap->psImplFuncs;
+
+	PVR_LOG_RETURN_IF_FALSE(
+		psPhysHeap->eType == PHYS_HEAP_TYPE_DLM,
+		"Physheap type not DLM",
+		PVRSRV_ERROR_INVALID_PARAMS);
+
+	PVR_ASSERT(psImplFuncs->pfnCreatePMB);
+
+	return psImplFuncs->pfnCreatePMB(psPhysHeap,
+	                                 uiSize,
+	                                 pszAnnotation,
+	                                 ppsPMRPtr,
+	                                 puiBase,
+	                                 puiSize);
+}
+
 PPVRSRV_DEVICE_NODE PhysHeapDeviceNode(PHYS_HEAP *psPhysHeap)
 {
 	PVR_ASSERT(psPhysHeap != NULL);
@@ -1721,9 +2175,19 @@ PVRSRV_ERROR PhysHeapFreeMemCheck(PHYS_HEAP *psPhysHeap,
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psPhysHeap != NULL, "psPhysHeap");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(pui64FreeMem != NULL, "pui64FreeMem");
 
-	psPhysHeap->psImplFuncs->pfnGetPMRFactoryMemStats(psPhysHeap->pvImplData,
-	                                                  &ui64TotalSize,
-	                                                  &ui64FreeSize);
+
+	if (psPhysHeap->eType == PHYS_HEAP_TYPE_IMA)
+	{
+		PhysHeapIMAGetMemInfo(psPhysHeap->pvImplData,
+		                            &ui64TotalSize,
+		                            &ui64FreeSize);
+	}
+	else
+	{
+		psPhysHeap->psImplFuncs->pfnGetFactoryMemStats(psPhysHeap->pvImplData,
+		                                               &ui64TotalSize,
+		                                               &ui64FreeSize);
+	}
 
 	*pui64FreeMem = ui64FreeSize;
 	if (ui64MinRequiredMem >= *pui64FreeMem)
@@ -1733,3 +2197,7 @@ PVRSRV_ERROR PhysHeapFreeMemCheck(PHYS_HEAP *psPhysHeap,
 
 	return eError;
 }
+
+/******************************************************************************
+ End of file (physheap.c)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/physheap.h b/drivers/gpu/drm/img-rogue/physheap.h
index 3d9c0f415dba..f5e03c655278 100644
--- a/drivers/gpu/drm/img-rogue/physheap.h
+++ b/drivers/gpu/drm/img-rogue/physheap.h
@@ -49,6 +49,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pmr_impl.h"
 #include "physheap_config.h"
 #include "pvrsrv_device.h"
+#include "ra.h"
 
 #ifndef PHYSHEAP_H
 #define PHYSHEAP_H
@@ -62,6 +63,9 @@ static inline IMG_UINT64 MB2B(IMG_UINT64 ui64Megabytes) { return ui64Megabytes <
 typedef struct _PHYS_HEAP_ PHYS_HEAP;
 #define INVALID_PHYS_HEAP 0xDEADDEAD
 
+/* PMB (Physical Memory Block) */
+typedef struct _PMB_ PMB;
+
 typedef IMG_UINT32 PHYS_HEAP_POLICY;
 
 /* Heap has default allocation policy and does not require
@@ -76,7 +80,7 @@ typedef IMG_UINT32 PHYS_HEAP_POLICY;
  * is required to map these allocations into the kernel.
  */
 #define PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG      (1U)
-#define PHYS_HEAP_POLOCY_ALLOC_ALLOW_NONCONTIG_MASK (1U)
+#define PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG_MASK (1U)
 
 struct _CONNECTION_DATA_;
 
@@ -157,6 +161,29 @@ typedef IMG_UINT32 (*PFN_GET_PAGE_SHIFT)(void);
 */ /**************************************************************************/
 typedef void (*PFN_GET_MEM_STATS)(PHEAP_IMPL_DATA, IMG_UINT64 *, IMG_UINT64 *);
 
+/*************************************************************************/ /*!
+@Function       Callback function PFN_GET_HEAP_STATS_STR_ITER
+@Description    Get string of heap memory spans constituting the heap. This
+                function can be iterated on to print sequential lines of the
+                heap data. Iterate until IMG_FALSE is returned
+@Input          PHEAP_IMPL_DATA    Pointer to implementation data.
+@InOut          IMG_CHAR           Pointer to string buffer to be populated
+                                   with sequential heap data.
+@Input          IMG_UINT32         Size of the string buffer.
+@InOut          void**             Iter handle.
+@Return         IMG_BOOL
+*/ /**************************************************************************/
+typedef IMG_BOOL (*PFN_GET_HEAP_SPANS_STR_ITER)(PHEAP_IMPL_DATA, IMG_CHAR *, IMG_UINT32, void **);
+
+/*************************************************************************/ /*!
+@Function       Callback function PFN_GET_HEAP_DLM_BACKING
+@Description    Extract reference to DLM heap backing the current IMA heap.
+@Input          PHEAP_IMPL_DATA    Pointer to implementation data.
+@InOut          PHYS_HEAP**        Pointer to DLM backing heap.
+@Return         void
+*/ /**************************************************************************/
+typedef void (*PFN_GET_HEAP_DLM_BACKING)(PHEAP_IMPL_DATA, PHYS_HEAP **);
+
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 typedef PVRSRV_ERROR (*PFN_PAGES_ALLOC_GPV)(PHYS_HEAP *psPhysHeap, size_t uiSize,
                                             PG_HANDLE *psMemHandle, IMG_DEV_PHYADDR *psDevPAddr,
@@ -212,6 +239,27 @@ typedef PVRSRV_ERROR (*PFN_CREATE_PMR)(PHYS_HEAP *psPhysHeap,
 									   PMR **ppsPMRPtr,
 									   IMG_UINT32 ui32PDumpFlags);
 
+/*************************************************************************/ /*!
+@Function       Callback function PFN_CREATE_PMB
+@Description    Create a PMB physical allocation and back with Card memory
+                on creation, if required. The card memory comes
+                directly from the DLM Phys Heap's associated pool of memory.
+@Input          psPhysHeap         Pointer to Phys Heap to create the PMB on,
+                                   physheap should be DLM type.
+@Input          uiSize             Allocation size.
+@Input          pszAnnotation      Annotation.
+@Output         ppsPMBPtr          Pointer to PMB created.
+@Output         puiBase            Out pointer to RA Base of PMB.
+@Output         puiSize            Out pointer to size of PMB
+@Return         PVRSRV_ERROR       PVRSRV_OK or error code
+*/ /**************************************************************************/
+typedef PVRSRV_ERROR (*PFN_CREATE_PMB)(PHYS_HEAP *psPhysHeap,
+                                       IMG_DEVMEM_SIZE_T uiSize,
+                                       const IMG_CHAR *pszAnnotation,
+                                       PMB **ppsPMBPtr,
+                                       RA_BASE_T *puiBase,
+                                       RA_LENGTH_T *puiSize);
+
 /*! Implementation specific function table */
 typedef struct PHEAP_IMPL_FUNCS_TAG
 {
@@ -220,8 +268,11 @@ typedef struct PHEAP_IMPL_FUNCS_TAG
 	PFN_GET_CPU_PADDR pfnGetCPUPAddr;
 	PFN_GET_SIZE pfnGetSize;
 	PFN_GET_PAGE_SHIFT pfnGetPageShift;
-	PFN_GET_MEM_STATS pfnGetPMRFactoryMemStats;
+	PFN_GET_MEM_STATS pfnGetFactoryMemStats;
+	PFN_GET_HEAP_SPANS_STR_ITER pfnGetHeapSpansStringIter;
+	PFN_GET_HEAP_DLM_BACKING pfnGetHeapDLMBacking;
 	PFN_CREATE_PMR pfnCreatePMR;
+	PFN_CREATE_PMB pfnCreatePMB;
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 	PFN_PAGES_ALLOC_GPV pfnPagesAllocGPV;
 #endif
@@ -338,7 +389,7 @@ PHYS_HEAP_USAGE_FLAGS PhysHeapGetFlags(PHYS_HEAP *psPhysHeap);
 
 IMG_BOOL PhysHeapValidateDefaultHeapExists(PPVRSRV_DEVICE_NODE psDevNode);
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 IMG_UINT32 PhysHeapGetIPAValue(PHYS_HEAP *psPhysHeap);
 
 IMG_UINT32 PhysHeapGetIPAMask(PHYS_HEAP *psPhysHeap);
@@ -405,6 +456,19 @@ PVRSRV_ERROR PhysHeapCreatePMR(PHYS_HEAP *psPhysHeap,
 							   IMG_UINT32 ui32PDumpFlags,
 							   PVRSRV_MEMALLOCFLAGS_T *uiOutFlags);
 
+/*************************************************************************/ /*!
+@Function       PhysHeapCreatePMB
+@Description    Function calls an implementation-specific function pointer.
+                See @Ref PFN_CREATE_PMB "PFN_CREATE_PMB" for details.
+@Return         PVRSRV_ERROR       PVRSRV_OK or error code
+*/ /**************************************************************************/
+PVRSRV_ERROR PhysHeapCreatePMB(PHYS_HEAP *psPhysHeap,
+                               IMG_DEVMEM_SIZE_T uiSize,
+                               const IMG_CHAR *pszAnnotation,
+                               PMB **ppsPMRPtr,
+                               RA_BASE_T *puiBase,
+                               RA_LENGTH_T *puiSize);
+
 /*************************************************************************/ /*!
 @Function       PhysHeapDeviceNode
 @Description    Get pointer to the device node this heap belongs to.
@@ -483,4 +547,5 @@ PVRSRV_ERROR PhysHeapFreeMemCheck(PHYS_HEAP *psPhysHeap,
                                   IMG_UINT64 ui64MinRequiredMem,
                                   IMG_UINT64 *pui64FreeMem);
 
+
 #endif /* PHYSHEAP_H */
diff --git a/drivers/gpu/drm/img-rogue/physheap_config.h b/drivers/gpu/drm/img-rogue/physheap_config.h
index 0ca695652de1..eb1de937a9c6 100644
--- a/drivers/gpu/drm/img-rogue/physheap_config.h
+++ b/drivers/gpu/drm/img-rogue/physheap_config.h
@@ -47,6 +47,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PHYSHEAP_CONFIG_H
 
 #include "img_types.h"
+#include "pvr_debug.h"
+#include "pvrsrv_error.h"
 #include "pvrsrv_memallocflags.h"
 #include "pvrsrv_memalloc_physheap.h"
 
@@ -70,6 +72,7 @@ typedef IMG_UINT32 PHYS_HEAP_USAGE_FLAGS;
 #define PHYS_HEAP_USAGE_FW_PREMAP      (1U <<PVRSRV_PHYS_HEAP_FW_PREMAP0)
 #define PHYS_HEAP_USAGE_WRAP           (1U <<PVRSRV_PHYS_HEAP_WRAP)
 #define PHYS_HEAP_USAGE_DISPLAY        (1U <<PVRSRV_PHYS_HEAP_DISPLAY)
+#define PHYS_HEAP_USAGE_DLM            (1U <<29)
 #define PHYS_HEAP_USAGE_FW_SHARED      (1U <<30)
 #define PHYS_HEAP_USAGE_FW_PRIVATE     (1U <<31)
 
@@ -86,7 +89,8 @@ typedef IMG_UINT32 PHYS_HEAP_USAGE_FLAGS;
                               PHYS_HEAP_USAGE_FW_PREMAP    | \
                               PHYS_HEAP_USAGE_FW_PREMAP_PT | \
                               PHYS_HEAP_USAGE_WRAP         | \
-                              PHYS_HEAP_USAGE_DISPLAY)
+                              PHYS_HEAP_USAGE_DISPLAY      | \
+                              PHYS_HEAP_USAGE_DLM)
 
 #define FIRST_PHYSHEAP_MAPPED_TO_FW_MAIN_DEVMEM    PVRSRV_PHYS_HEAP_FW_CODE
 
@@ -127,38 +131,169 @@ typedef struct _IPA_CONFIG_
 	IMG_UINT8             ui8IPAPolicyReserved;
 } IPA_CONFIG;
 
-/*! Structure used to describe a physical Heap supported by a system. A
- * system layer module can declare multiple physical heaps for different
- * purposes. At a minimum a system must provide one physical heap tagged for
- * PHYS_HEAP_USAGE_GPU_LOCAL use.
- * A heap represents a discrete pool of physical memory and how it is managed,
- * as well as associating other properties and address translation logic.
- * The structure fields sStartAddr, sCardBase and uiSize must be given valid
- * values for LMA and DMA physical heaps types.
- */
-typedef struct _PHYS_HEAP_CONFIG_
+typedef struct _PHYS_HEAP_CONFIG_LMA_
 {
-	PHYS_HEAP_TYPE        eType;                /*!< Class of heap and PMR factory used */
 	IMG_CHAR*             pszPDumpMemspaceName; /*!< Name given to the heap's symbolic memory
-	                                                 space in a PDUMP enabled driver */
+													 space in a PDUMP enabled driver */
+	PHYS_HEAP_FUNCTIONS*  psMemFuncs;           /*!< Physical address translation functions */
+	IMG_CHAR*             pszHeapName;          /*!< Name given to the heap */
+	IMG_CPU_PHYADDR       sStartAddr;           /*!< CPU Physical base address of memory region */
+	IMG_DEV_PHYADDR       sCardBase;            /*!< Device physical base address of memory
+													 region as seen from the PoV of the GPU */
+	IMG_UINT64            uiSize;               /*!< Size of memory region in bytes */
+	IMG_HANDLE            hPrivData;            /*!< System layer private data shared with
+													 psMemFuncs */
+} PHYS_HEAP_CONFIG_LMA;
+
+typedef struct _PHYS_HEAP_CONFIG_UMA_
+{
+	IMG_CHAR*             pszPDumpMemspaceName; /*!< Name given to the heap's symbolic memory
+													 space in a PDUMP enabled driver */
 	PHYS_HEAP_FUNCTIONS*  psMemFuncs;           /*!< Physical address translation functions */
+	IMG_CHAR*             pszHeapName;          /*!< Name given to the heap */
+	IMG_DEV_PHYADDR       sCardBase;            /*!< Optional Device physical base address of memory
+													 region as seen from the PoV of the GPU */
+	IMG_HANDLE            hPrivData;            /*!< System layer private data shared with
+													 psMemFuncs */
+} PHYS_HEAP_CONFIG_UMA;
 
+typedef struct _PHYS_HEAP_CONFIG_DLM_
+{
+	IMG_CHAR*             pszHeapName;          /*!< Name given to the heap */
+	IMG_UINT32            ui32Log2PMBSize;      /*!< PMB (Physical Memory Block) Log 2 size in bytes
+	                                                 for DLM heap. */
+	PHYS_HEAP_FUNCTIONS*  psMemFuncs;           /*!< Physical address translation functions */
 	IMG_CPU_PHYADDR       sStartAddr;           /*!< CPU Physical base address of memory region */
 	IMG_DEV_PHYADDR       sCardBase;            /*!< Device physical base address of memory
 	                                                 region as seen from the PoV of the GPU */
 	IMG_UINT64            uiSize;               /*!< Size of memory region in bytes */
+	IMG_HANDLE            hPrivData;            /*!< System layer private data shared with
+                                                     psMemFuncs */
+} PHYS_HEAP_CONFIG_DLM;
 
+typedef struct _PHYS_HEAP_CONFIG_IMA_
+{
+	IMG_CHAR*             pszPDumpMemspaceName; /*!< Name given to the heap's symbolic memory
+	                                                 space in a PDUMP enabled driver */
+	PHYS_HEAP_FUNCTIONS*  psMemFuncs;           /*!< Physical address translation functions */
 	IMG_CHAR*             pszHeapName;          /*!< Name given to the heap */
 	IMG_HANDLE            hPrivData;            /*!< System layer private data shared with
 	                                                 psMemFuncs */
+	IMG_UINT32            ui32PMBStartingMultiple; /*!< Multiple of PMB size defined in DLM heap
+	                                                    to be allocated on creation */
+	IMG_UINT32            uiDLMHeapIdx;         /*!< The index in the array of physheaps to a
+	                                                 DLM heap to import PMBs from. */
+} PHYS_HEAP_CONFIG_IMA;
 
+/*! Structure used to describe a physical Heap supported by a system. A
+ * system layer module can declare multiple physical heaps for different
+ * purposes. At a minimum a system must provide one physical heap tagged for
+ * PHYS_HEAP_USAGE_GPU_LOCAL use.
+ * A heap represents a discrete pool of physical memory and how it is managed,
+ * as well as associating other properties and address translation logic.
+ * The structure fields sStartAddr, sCardBase and uiSize must be given valid
+ * values for LMA and DMA physical heaps types.
+ */
+typedef struct _PHYS_HEAP_CONFIG_
+{
+	PHYS_HEAP_TYPE        eType;                /*!< Class of heap and PMR factory used */
 	PHYS_HEAP_USAGE_FLAGS ui32UsageFlags;       /*!< Supported uses flags, conveys the type of
 	                                                 buffers the physical heap can be used for */
 	IPA_CONFIG            sIPAConfig;           /*!< IPA configuration to be applied to all
 	                                                 requested physical addresses when physically
 	                                                 backed */
+	union {
+		PHYS_HEAP_CONFIG_LMA sLMA;
+		PHYS_HEAP_CONFIG_LMA sDMA;
+		PHYS_HEAP_CONFIG_UMA sUMA;
+		PHYS_HEAP_CONFIG_DLM sDLM;
+		PHYS_HEAP_CONFIG_IMA sIMA;
+#if defined(SUPPORT_WRAP_EXTMEMOBJECT)
+		PHYS_HEAP_CONFIG_UMA sWRAP;
+#endif
+	} uConfig;
 } PHYS_HEAP_CONFIG;
 
+/* Code throughout the driver sometimes relies on the fact that the backing for
+ * LMA and DMA heaps are the same struct, this check is not comprehensive as the structs
+ * could have changed but kept the same overall size, although this is unlikely.
+ */
+static_assert(sizeof(((PHYS_HEAP_CONFIG*)0)->uConfig.sLMA) == sizeof(((PHYS_HEAP_CONFIG*)0)->uConfig.sDMA),
+              "PHYS_HEAP_CONFIG sizeof sLMA != sDMA, Type has potentially changed");
+
+static INLINE IMG_UINT64 PhysHeapConfigGetSize(PHYS_HEAP_CONFIG *psConfig)
+{
+	switch (psConfig->eType)
+	{
+	case PHYS_HEAP_TYPE_LMA:
+		return psConfig->uConfig.sLMA.uiSize;
+	case PHYS_HEAP_TYPE_IMA:
+		PVR_ASSERT(!"IMA Config has no size member");
+		return 0;
+#if defined(__KERNEL__)
+	case PHYS_HEAP_TYPE_DMA:
+		return psConfig->uConfig.sDMA.uiSize;
+#endif
+	case PHYS_HEAP_TYPE_DLM:
+		return psConfig->uConfig.sDLM.uiSize;
+	case PHYS_HEAP_TYPE_UMA:
+		PVR_ASSERT(!"UMA Config has no size member");
+		return 0;
+	default:
+		PVR_ASSERT(!"Not Implemented for Config Type");
+		return 0;
+	}
+}
+
+static INLINE IMG_CPU_PHYADDR PhysHeapConfigGetStartAddr(PHYS_HEAP_CONFIG *psConfig)
+{
+	IMG_CPU_PHYADDR sUnsupportedPhyAddr = {0};
+	switch (psConfig->eType)
+	{
+	case PHYS_HEAP_TYPE_LMA:
+		return psConfig->uConfig.sLMA.sStartAddr;
+	case PHYS_HEAP_TYPE_IMA:
+		PVR_ASSERT(!"IMA Config has no StartAddr member");
+		return sUnsupportedPhyAddr;
+#if defined(__KERNEL__)
+	case PHYS_HEAP_TYPE_DMA:
+		return psConfig->uConfig.sDMA.sStartAddr;
+#endif
+	case PHYS_HEAP_TYPE_DLM:
+		return psConfig->uConfig.sDLM.sStartAddr;
+	case PHYS_HEAP_TYPE_UMA:
+		PVR_ASSERT(!"UMA Config has no StartAddr member");
+		return sUnsupportedPhyAddr;
+	default:
+		PVR_ASSERT(!"Not Implemented for Config Type");
+		return sUnsupportedPhyAddr;
+	}
+}
+
+static INLINE IMG_DEV_PHYADDR PhysHeapConfigGetCardBase(PHYS_HEAP_CONFIG *psConfig)
+{
+	IMG_DEV_PHYADDR sUnsupportedPhyAddr = {0};
+	switch (psConfig->eType)
+	{
+	case PHYS_HEAP_TYPE_LMA:
+		return psConfig->uConfig.sLMA.sCardBase;
+	case PHYS_HEAP_TYPE_IMA:
+		PVR_ASSERT(!"IMA Config has no CardBase member");
+		return sUnsupportedPhyAddr;
+#if defined(__KERNEL__)
+	case PHYS_HEAP_TYPE_DMA:
+		return psConfig->uConfig.sDMA.sCardBase;
+#endif
+	case PHYS_HEAP_TYPE_UMA:
+		return psConfig->uConfig.sUMA.sCardBase;
+	case PHYS_HEAP_TYPE_DLM:
+		return psConfig->uConfig.sDLM.sCardBase;
+	default:
+		PVR_ASSERT(!"Not Implemented for Config Type");
+		return sUnsupportedPhyAddr;
+	}
+}
+
 #define PHYS_HEAP_NAME_SIZE 24
 
 #endif
diff --git a/drivers/gpu/drm/img-rogue/physmem.c b/drivers/gpu/drm/img-rogue/physmem.c
index 96deb42f2f5a..b04ced3638ad 100644
--- a/drivers/gpu/drm/img-rogue/physmem.c
+++ b/drivers/gpu/drm/img-rogue/physmem.c
@@ -50,8 +50,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "osfunc.h"
 #include "pdump_physmem.h"
 #include "pdump_km.h"
-#include "rgx_heaps.h"
 #include "pvr_ricommon.h"
+#include "allocmem.h"
 
 #include "physmem_lma.h"
 #include "physmem_osmem.h"
@@ -74,6 +74,12 @@ MODULE_PARM_DESC(PMRAllocFail, "When number of PMR allocs reaches "
 #include "proc_stats.h"
 #endif
 
+/** Computes division using log2 of divisor. */
+#define LOG2_DIV(x, log2) ((x) >> (log2))
+
+/** Computes modulo of a power of 2. */
+#define LOG2_MOD(x, log2) ((x) & ((1 << (log2)) - 1))
+
 PVRSRV_ERROR DevPhysMemAlloc(PVRSRV_DEVICE_NODE	*psDevNode,
                              IMG_UINT32 ui32MemSize,
                              IMG_UINT32 ui32Log2Align,
@@ -114,7 +120,7 @@ PVRSRV_ERROR DevPhysMemAlloc(PVRSRV_DEVICE_NODE	*psDevNode,
 	/* Check to see if the page allocator returned pages with our desired
 	 * alignment, which is not unlikely
 	 */
-	uiMask = (1 << ui32Log2Align) - 1;
+	uiMask = IMG_PAGE2BYTES32(ui32Log2Align) - 1;
 	if (ui32Log2Align && (sDevPhysAddr_int.uiAddr & uiMask))
 	{
 		/* use over allocation instead */
@@ -134,7 +140,7 @@ PVRSRV_ERROR DevPhysMemAlloc(PVRSRV_DEVICE_NODE	*psDevNode,
 	*psDevPhysAddr = sDevPhysAddr_int;
 
 #if defined(PDUMP)
-	ui32PageSize = ui32Log2Align? (1 << ui32Log2Align) : OSGetPageSize();
+	ui32PageSize = ui32Log2Align? IMG_PAGE2BYTES32(ui32Log2Align) : OSGetPageSize();
 	eError = PDumpMalloc(psDevNode,
 	                     pszDevSpace,
 	                     pszSymbolicAddress,
@@ -267,15 +273,75 @@ void DevPhysMemFree(PVRSRV_DEVICE_NODE *psDevNode,
 
 }
 
+PVRSRV_ERROR PhysMemValidateMappingTable(IMG_UINT32 ui32TotalNumVirtChunks,
+                                         IMG_UINT32 ui32IndexCount,
+                                         const IMG_UINT32 *pui32MappingTable)
+{
+	IMG_UINT8 *paui8TrackedIndices;
+	IMG_UINT32 ui32BytesToTrackIndicies;
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	/* Allocate memory for a bitmask to track indices.
+	 * We allocate 'n' bytes with 1 bit representing each index, to allow
+	 * us to check for any repeated entries in pui32MappingTable.
+	 */
+	ui32BytesToTrackIndicies = LOG2_DIV(ui32TotalNumVirtChunks, 3);
+	if (LOG2_MOD(ui32TotalNumVirtChunks, 3) != 0)
+	{
+		++ui32BytesToTrackIndicies;
+	}
+	paui8TrackedIndices = OSAllocZMem(ui32BytesToTrackIndicies);
+	if (paui8TrackedIndices == NULL)
+	{
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+
+	for (i = 0; i < ui32IndexCount; i++)
+	{
+		IMG_UINT32 ui32LogicalIndex = pui32MappingTable[i];
+
+		/* Check that index is within the bounds of the allocation */
+		if (ui32LogicalIndex >= ui32TotalNumVirtChunks)
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Index %u is OOB",
+			         __func__,
+			         ui32LogicalIndex));
+			eError = PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY;
+			break;
+		}
+
+		/* Check that index is not repeated */
+		if (BIT_ISSET(paui8TrackedIndices[LOG2_DIV(ui32LogicalIndex, 3)], LOG2_MOD(ui32LogicalIndex, 3)))
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Duplicate index found: %u",
+			         __func__,
+			         ui32LogicalIndex));
+
+			eError = PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY;
+			break;
+		}
+		BIT_SET(paui8TrackedIndices[LOG2_DIV(ui32LogicalIndex, 3)], LOG2_MOD(ui32LogicalIndex, 3));
+	}
+
+	OSFreeMem(paui8TrackedIndices);
+
+	return eError;
+}
 
 /* Checks the input parameters and adjusts them if possible and necessary */
-static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
-                                           IMG_UINT32 ui32NumVirtChunks,
-                                           PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                                           IMG_UINT32 *puiLog2AllocPageSize,
-                                           IMG_DEVMEM_SIZE_T *puiSize)
+PVRSRV_ERROR PhysMemValidateParams(PVRSRV_DEVICE_NODE *psDevNode,
+                                   IMG_UINT32 ui32NumPhysChunks,
+                                   IMG_UINT32 ui32NumVirtChunks,
+                                   IMG_UINT32 *pui32MappingTable,
+                                   PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                                   IMG_UINT32 *puiLog2AllocPageSize,
+                                   IMG_DEVMEM_SIZE_T *puiSize)
 {
 	IMG_UINT32 uiLog2AllocPageSize = *puiLog2AllocPageSize;
+	IMG_UINT32 ui32PageSize = IMG_PAGE2BYTES32(uiLog2AllocPageSize);
 	IMG_DEVMEM_SIZE_T uiSize = *puiSize;
 	/* Sparse if we have different number of virtual and physical chunks plus
 	 * in general all allocations with more than one virtual chunk */
@@ -289,20 +355,28 @@ static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
 		return PVRSRV_ERROR_INVALID_FLAGS;
 	}
 
-	if (ui32NumPhysChunks == 0 && ui32NumVirtChunks == 0)
+	/* Sparse allocations must be backed immediately as the requested
+	 * pui32MappingTable is not retained in any structure if not immediately
+	 * actioned on allocation.
+	 */
+	if (PVRSRV_CHECK_ON_DEMAND(uiFlags) && bIsSparse)
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-				"%s: Number of physical chunks and number of virtual chunks "
-				"cannot be both 0",
-				__func__));
+		PVR_DPF((PVR_DBG_ERROR, "%s: Invalid to specify ON_DEMAND for a sparse allocation: 0x%" IMG_UINT64_FMTSPECX, __func__, uiFlags));
+		return PVRSRV_ERROR_INVALID_FLAGS;
+	}
+
+	if (ui32NumVirtChunks == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Number of virtual chunks cannot be 0",
+		         __func__));
 
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	/* Protect against ridiculous page sizes */
-	if (uiLog2AllocPageSize > RGX_HEAP_2MB_PAGE_SHIFT || uiLog2AllocPageSize < RGX_HEAP_4KB_PAGE_SHIFT)
+	/* Protect against invalid page sizes */
+	if ((ui32PageSize & psDevNode->psMMUDevAttrs->ui32ValidPageSizeMask) == 0)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "Page size is out of range: 2^%u.", uiLog2AllocPageSize));
+		PVR_LOG_VA(PVR_DBG_ERROR, "Page size of %u is invalid", ui32PageSize);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -310,9 +384,9 @@ static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
 	if (!PMRValidateSize(uiSize))
 	{
 		PVR_LOG_VA(PVR_DBG_ERROR,
-				 "PMR size exceeds limit #Chunks: %u ChunkSz %"IMG_UINT64_FMTSPECX"",
-				 ui32NumVirtChunks,
-				 (IMG_UINT64) 1ULL << uiLog2AllocPageSize);
+				   "PMR size exceeds limit #Chunks: %u ChunkSz 0x%08X",
+				   ui32NumVirtChunks,
+				   IMG_PAGE2BYTES32(uiLog2AllocPageSize));
 		return PVRSRV_ERROR_PMR_TOO_LARGE;
 	}
 
@@ -356,13 +430,15 @@ static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
 			return PVRSRV_ERROR_INVALID_PARAMS;
 		}
 
-		if (ui32NumVirtChunks * (1 << uiLog2AllocPageSize) != uiSize)
+		if (IMG_PAGES2BYTES64(ui32NumVirtChunks, uiLog2AllocPageSize) != uiSize)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
 					 "%s: Total alloc size (%#" IMG_UINT64_FMTSPECx ") "
 					 "is not equal to virtual chunks * chunk size "
 					 "(%#" IMG_UINT64_FMTSPECx ")",
-					 __func__, uiSize, (IMG_UINT64) (ui32NumVirtChunks * (1ULL << uiLog2AllocPageSize))));
+					 __func__,
+					 uiSize,
+					 IMG_PAGES2BYTES64(ui32NumVirtChunks, uiLog2AllocPageSize)));
 
 			return PVRSRV_ERROR_PMR_NOT_PAGE_MULTIPLE;
 		}
@@ -393,16 +469,25 @@ static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
 		uiSize = PVR_ALIGN(uiSize, (IMG_DEVMEM_SIZE_T)OSGetPageSize());
 	}
 
-	if ((uiSize & ((1ULL << uiLog2AllocPageSize) - 1)) != 0)
+	if ((uiSize & (IMG_PAGE2BYTES32(uiLog2AllocPageSize) - 1)) != 0)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 		        "%s: Total size (%#" IMG_UINT64_FMTSPECx ") "
-		        "must be a multiple of the requested contiguity (%"
-		        IMG_UINT64_FMTSPEC ")", __func__, uiSize,
-		        (IMG_UINT64) (1ULL << uiLog2AllocPageSize)));
+		        "must be a multiple of the requested contiguity (%u)",
+		        __func__,
+		        uiSize,
+		        IMG_PAGE2BYTES32(uiLog2AllocPageSize)));
 		return PVRSRV_ERROR_PMR_NOT_PAGE_MULTIPLE;
 	}
 
+	/* Parameter validation - Mapping table entries */
+	{
+		PVRSRV_ERROR eErr = PhysMemValidateMappingTable(ui32NumVirtChunks,
+		                                                ui32NumPhysChunks,
+		                                                pui32MappingTable);
+		PVR_RETURN_IF_ERROR(eErr);
+	}
+
 	*puiLog2AllocPageSize = uiLog2AllocPageSize;
 	*puiSize = uiSize;
 
@@ -410,7 +495,8 @@ static inline PVRSRV_ERROR _ValidateParams(IMG_UINT32 ui32NumPhysChunks,
 }
 
 static PVRSRV_ERROR _DevPhysHeapFromFlags(PVRSRV_MEMALLOCFLAGS_T uiFlags,
-										  PVRSRV_PHYS_HEAP *peDevPhysHeap)
+										  PVRSRV_PHYS_HEAP *peDevPhysHeap,
+										  PVRSRV_DEVICE_NODE *psDevNode)
 {
 	PVRSRV_PHYS_HEAP eHeap = PVRSRV_GET_PHYS_HEAP_HINT(uiFlags);
 
@@ -426,7 +512,7 @@ static PVRSRV_ERROR _DevPhysHeapFromFlags(PVRSRV_MEMALLOCFLAGS_T uiFlags,
 		case PVRSRV_PHYS_HEAP_FW_PREMAP7:
 		{
 			/* keep heap (with check) */
-			PVR_RETURN_IF_INVALID_PARAM(!PVRSRV_VZ_MODE_IS(GUEST));
+			PVR_RETURN_IF_INVALID_PARAM(!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode));
 			break;
 		}
 		case PVRSRV_PHYS_HEAP_LAST:
@@ -444,6 +530,23 @@ static PVRSRV_ERROR _DevPhysHeapFromFlags(PVRSRV_MEMALLOCFLAGS_T uiFlags,
 	return PVRSRV_OK;
 }
 
+static INLINE void _PromoteToCpuCached(PVRSRV_MEMALLOCFLAGS_T *puiFlags)
+{
+	if ((*puiFlags & (PVRSRV_MEMALLOCFLAG_CPU_READABLE |
+	                  PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE |
+	                  PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE)) == 0)
+	{
+		/* We don't need to upgrade if we don't map into the CPU */
+		return;
+	}
+
+	/* Clear the existing CPU cache flags */
+	*puiFlags &= ~(PVRSRV_MEMALLOCFLAG_CPU_CACHE_MODE_MASK);
+
+	/* Add CPU cached flags */
+	*puiFlags |= PVRSRV_MEMALLOCFLAG_CPU_CACHE_INCOHERENT;
+}
+
 PVRSRV_ERROR
 PhysmemNewRamBackedPMR_direct(CONNECTION_DATA *psConnection,
                        PVRSRV_DEVICE_NODE *psDevNode,
@@ -475,14 +578,22 @@ PhysmemNewRamBackedPMR_direct(CONNECTION_DATA *psConnection,
 	 */
 	PVR_UNREFERENCED_PARAMETER(uiAnnotationLength);
 
-	eError = _ValidateParams(ui32NumPhysChunks,
-	                         ui32NumVirtChunks,
-	                         uiFlags,
-	                         &uiLog2AllocPageSize,
-	                         &uiSize);
+	if (PVRSRVSystemSnoopingOfCPUCache(psDevNode->psDevConfig) &&
+		psDevNode->pfnGetDeviceSnoopMode(psDevNode) == PVRSRV_DEVICE_SNOOP_CPU_ONLY)
+	{
+		_PromoteToCpuCached(&uiPMRFlags);
+	}
+
+	eError = PhysMemValidateParams(psDevNode,
+	                               ui32NumPhysChunks,
+	                               ui32NumVirtChunks,
+	                               pui32MappingTable,
+	                               uiFlags,
+	                               &uiLog2AllocPageSize,
+	                               &uiSize);
 	PVR_RETURN_IF_ERROR(eError);
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 #if !defined(PVRSRV_INTERNAL_IPA_FEATURE_TESTING)
 	/* Do not permit IPA PMR allocation flags to be passed through to the
 	 * new PMR.
@@ -503,7 +614,7 @@ PhysmemNewRamBackedPMR_direct(CONNECTION_DATA *psConnection,
 		                        PVRSRV_ERROR_INVALID_PARAMS);
 	}
 
-	eError = _DevPhysHeapFromFlags(uiFlags, &ePhysHeapIdx);
+	eError = _DevPhysHeapFromFlags(uiFlags, &ePhysHeapIdx, psDevNode);
 	PVR_RETURN_IF_ERROR(eError);
 
 	if (ePhysHeapIdx == PVRSRV_PHYS_HEAP_DEFAULT)
@@ -635,6 +746,7 @@ PhysmemNewRamBackedPMR(CONNECTION_DATA *psConnection,
 	PVRSRV_PHYS_HEAP ePhysHeap = PVRSRV_GET_PHYS_HEAP_HINT(uiFlags);
 	PVRSRV_ERROR eError;
 
+	PVR_LOG_RETURN_IF_INVALID_PARAM(ePhysHeap < PVRSRV_PHYS_HEAP_LAST, "uiFlags");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(uiAnnotationLength != 0, "uiAnnotationLength");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(pszAnnotation != NULL, "pszAnnotation");
 
diff --git a/drivers/gpu/drm/img-rogue/physmem.h b/drivers/gpu/drm/img-rogue/physmem.h
index d36a73627330..9730aad07684 100644
--- a/drivers/gpu/drm/img-rogue/physmem.h
+++ b/drivers/gpu/drm/img-rogue/physmem.h
@@ -234,4 +234,53 @@ PVRSRVPhysHeapGetMemInfoKM(CONNECTION_DATA *psConnection,
                            PVRSRV_PHYS_HEAP *paePhysHeapID,
                            PHYS_HEAP_MEM_STATS *paPhysHeapMemStats);
 
+/*************************************************************************/ /*!
+@Function       PhysMemValidateMappingTable
+@Description    Checks the PMR mapping table provided is valid (ie has
+                no entries with an index value outside the valid range
+                of indices for the allocation and has no repeated indices)
+
+@Input          ui32TotalNumVirtChunks Total number of virtual chunks
+                                       the allocation has.
+@Input          ui32IndexCount         Number of entries in the mapping
+                                       table.
+@Input          pui32MappingTable      Mapping Table.
+@Return         PVRSRV_OK              if parameters are valid.
+                PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY if mapping table
+                                       contains an index out of range or a
+                                       repeated index
+                PVRSRV_ERROR_OUT_OF_MEMORY if unable to allocate memory
+                                       for the index tracking table
+                                       (used internally in this function)
+*/ /**************************************************************************/
+PVRSRV_ERROR
+PhysMemValidateMappingTable(IMG_UINT32 ui32TotalNumVirtChunks,
+                            IMG_UINT32 ui32IndexCount,
+                            const IMG_UINT32 *pui32MappingTable);
+
+/*************************************************************************/ /*!
+@Function       PhysMemValidateParams
+@Description    Checks the PMR creation parameters and adjusts them
+                if possible and necessary
+
+@Input          psDevNode              The associated device node.
+@Input          ui32NumPhysChunks      Number of physical chunks.
+@Input          ui32NumVirtChunks      Number of virtual chunks.
+@Input          pui32MappingTable      Mapping Table.
+@Input          uiFlags                Allocation flags.
+@Inout          puiLog2AllocPageSize   Log2 of allocation page size.
+                                       May be adjusted.
+@Inout          puiSize                Size of the allocation.
+                                       May be adjusted.
+@Return         PVRSRV_OK if parameters are valid.
+*/ /**************************************************************************/
+PVRSRV_ERROR
+PhysMemValidateParams(PVRSRV_DEVICE_NODE *psDevNode,
+                      IMG_UINT32 ui32NumPhysChunks,
+                      IMG_UINT32 ui32NumVirtChunks,
+                      IMG_UINT32 *pui32MappingTable,
+                      PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                      IMG_UINT32 *puiLog2AllocPageSize,
+                      IMG_DEVMEM_SIZE_T *puiSize);
+
 #endif /* SRVSRV_PHYSMEM_H */
diff --git a/drivers/gpu/drm/img-rogue/physmem_dlm.h b/drivers/gpu/drm/img-rogue/physmem_dlm.h
new file mode 100644
index 000000000000..7d18fd781f2f
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/physmem_dlm.h
@@ -0,0 +1,88 @@
+/*************************************************************************/ /*!
+@File           physmem_dlm.h
+@Title          Dedicated Local Memory allocator for Physical Memory Blocks
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Part of the memory management. This module is responsible for
+                implementing the function callbacks for dedicated local memory.
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#ifndef PHYSMEM_DLM_H
+#define PHYSMEM_DLM_H
+
+#include "img_types.h"
+#include "physheap.h"
+#include "physheap_config.h"
+#include "device.h"
+
+/* PMBDestroy
+ *
+ * Destroys a given PMB used to represent a block of memory
+ * obtained from a DLM heap.
+ */
+void
+PMBDestroy(PMB *psPMB);
+
+/* PMBGetAnnotation
+ *
+ * Obtain the annotation of the allocation represented
+ * by this PMB
+ */
+const IMG_CHAR *
+PMBGetAnnotation(PMB *psPMB);
+
+/* DLM */
+
+/*************************************************************************/ /*!
+@Function       PhysmemCreateHeapDLM
+@Description    Create and register new DLM heap.
+@Input          psDevNode    Pointer to device node struct.
+@Input          uiPolicy     Heap allocation policy flags
+@Input          psConfig     Heap configuration.
+@Input          pszLabel     Debug identifier label
+@Output         ppsPhysHeap  Pointer to the created heap.
+@Return         PVRSRV_ERROR PVRSRV_OK or error code
+*/ /**************************************************************************/
+PVRSRV_ERROR
+PhysmemCreateHeapDLM(PVRSRV_DEVICE_NODE *psDevNode,
+                     PHYS_HEAP_POLICY uiPolicy,
+                     PHYS_HEAP_CONFIG *psConfig,
+                     IMG_CHAR *pszLabel,
+                     PHYS_HEAP **ppsPhysHeap);
+
+#endif /* #ifndef PHYSMEM_DLM_H */
diff --git a/drivers/gpu/drm/img-rogue/physmem_dmabuf.c b/drivers/gpu/drm/img-rogue/physmem_dmabuf.c
index d11e71f7b299..af1dcd9963e8 100644
--- a/drivers/gpu/drm/img-rogue/physmem_dmabuf.c
+++ b/drivers/gpu/drm/img-rogue/physmem_dmabuf.c
@@ -45,15 +45,21 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <linux/version.h>
 
 #include "physmem_dmabuf.h"
+#include "physmem_dmabuf_internal.h"
+#include "physmem.h"
 #include "pvrsrv.h"
 #include "pmr.h"
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)) || defined(SUPPORT_ION) || defined(KERNEL_HAS_DMABUF_VMAP_MMAP)
-
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/dma-buf.h>
 #include <linux/scatterlist.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0))
+#include <drm/drm_prime.h>
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_gem.h>
 
 #include "img_types.h"
 #include "img_defs.h"
@@ -64,10 +70,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "allocmem.h"
 #include "osfunc.h"
 #include "pmr_impl.h"
+#include "pmr_env.h"
 #include "hash.h"
 #include "private_data.h"
 #include "module_common.h"
 #include "pvr_ion_stats.h"
+#include "cache_km.h"
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
 #include "ri_server.h"
@@ -83,12 +91,558 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "kernel_compatibility.h"
 
+typedef struct _PMR_DMA_BUF_WRAPPER_
+{
+	PMR *psPMR;
+
+	/*
+	 * Set if the PMR has been exported via GEM. This field should only
+	 * be accessed using smp_store_release and smp_load_acquire.
+	 * In general, the field is not safe to access, as the wrapper doesn't
+	 * hold a reference on the GEM object.
+	 */
+	struct drm_gem_object *psObj;
+
+	struct dma_resv sDmaResv;
+
+	/* kernel mapping */
+	IMG_UINT32 uiKernelMappingRefCnt;
+	IMG_HANDLE hKernelMappingHandle;
+	void *pvKernelMappingAddr;
+	PMR_SIZE_T uiKernelMappingLen;
+	POS_LOCK hKernelMappingLock;
+
+	/* device mapping */
+	IMG_UINT32 uiDeviceMappingRefCnt;
+	POS_LOCK hDeviceMappingLock;
+	struct sg_table *psTable;
+} PMR_DMA_BUF_WRAPPER;
+
+typedef struct _PMR_DMA_BUF_GEM_OBJ {
+	struct drm_gem_object sBase;
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper;
+} PMR_DMA_BUF_GEM_OBJ;
+
+#define TO_PMR_DMA_BUF_GEM_OBJ(psObj) IMG_CONTAINER_OF((psObj), PMR_DMA_BUF_GEM_OBJ, sBase)
+
+static PVRSRV_ERROR _PMRKMap(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+                             size_t uiSize,
+                             void **pvAddr)
+{
+	IMG_HANDLE hKernelMapping;
+	void *pvAddrOut = NULL;
+	size_t uiLengthOut = 0;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	OSLockAcquire(psPMRWrapper->hKernelMappingLock);
+
+	if (psPMRWrapper->uiKernelMappingRefCnt++ == 0)
+	{
+		PVR_ASSERT(psPMRWrapper->hKernelMappingHandle == NULL);
+		PVR_ASSERT(psPMRWrapper->pvKernelMappingAddr == NULL);
+
+		if (PMR_IsSparse(psPMRWrapper->psPMR))
+		{
+			eError = PMRAcquireSparseKernelMappingData(psPMRWrapper->psPMR,
+			                                           0,
+			                                           uiSize,
+			                                           &pvAddrOut,
+			                                           &uiLengthOut,
+			                                           &hKernelMapping);
+			PVR_LOG_GOTO_IF_ERROR(eError, "PMRAcquireSparseKernelMappingData",
+			                      ErrReleaseLock);
+		}
+		else
+		{
+			eError = PMRAcquireKernelMappingData(psPMRWrapper->psPMR,
+			                                     0,
+			                                     uiSize,
+			                                     &pvAddrOut,
+			                                     &uiLengthOut,
+			                                     &hKernelMapping);
+			PVR_LOG_GOTO_IF_ERROR(eError, "PMRAcquireKernelMappingData",
+			                      ErrReleaseLock);
+		}
+
+		psPMRWrapper->hKernelMappingHandle = hKernelMapping;
+		psPMRWrapper->pvKernelMappingAddr = pvAddrOut;
+		psPMRWrapper->uiKernelMappingLen = uiLengthOut;
+	}
+
+	*pvAddr = psPMRWrapper->pvKernelMappingAddr;
+	goto ExitUnlock;
+
+ErrReleaseLock:
+	psPMRWrapper->uiKernelMappingRefCnt--;
+
+ExitUnlock:
+	OSLockRelease(psPMRWrapper->hKernelMappingLock);
+	return eError;
+}
+
+static void _PMRKUnmap(PMR_DMA_BUF_WRAPPER *psPMRWrapper)
+{
+	OSLockAcquire(psPMRWrapper->hKernelMappingLock);
+
+	if (--psPMRWrapper->uiKernelMappingRefCnt == 0)
+	{
+		PVRSRV_ERROR eError;
+
+		PVR_ASSERT(psPMRWrapper->hKernelMappingHandle != NULL);
+		PVR_ASSERT(psPMRWrapper->pvKernelMappingAddr != NULL);
+
+		eError = PMRReleaseKernelMappingData(psPMRWrapper->psPMR,
+		                                     psPMRWrapper->hKernelMappingHandle);
+		PVR_LOG_IF_ERROR(eError, "PMRReleaseKernelMappingData");
+
+		psPMRWrapper->hKernelMappingHandle = NULL;
+		psPMRWrapper->pvKernelMappingAddr = NULL;
+		psPMRWrapper->uiKernelMappingLen = 0;
+	}
+
+	OSLockRelease(psPMRWrapper->hKernelMappingLock);
+}
+
+static PVRSRV_ERROR _PMRInvalidateCache(PMR_DMA_BUF_WRAPPER *psPMRWrapper)
+{
+	PVRSRV_ERROR eError;
+
+	OSLockAcquire(psPMRWrapper->hKernelMappingLock);
+
+	if (psPMRWrapper->uiKernelMappingRefCnt == 0) {
+		OSLockRelease(psPMRWrapper->hKernelMappingLock);
+		return PVRSRV_ERROR_PMR_NO_KERNEL_MAPPING;
+	}
+
+	eError = CacheOpValExec(psPMRWrapper->psPMR,
+	                        (IMG_UINT64) (uintptr_t) psPMRWrapper->pvKernelMappingAddr,
+	                        0,
+	                        psPMRWrapper->uiKernelMappingLen,
+	                        PVRSRV_CACHE_OP_INVALIDATE);
+	PVR_LOG_IF_ERROR(eError, "CacheOpValExec");
+
+	OSLockRelease(psPMRWrapper->hKernelMappingLock);
+
+	return eError;
+}
+
+static PVRSRV_ERROR _PMRCleanCache(PMR_DMA_BUF_WRAPPER *psPMRWrapper)
+{
+	PVRSRV_ERROR eError;
+
+	OSLockAcquire(psPMRWrapper->hKernelMappingLock);
+
+	if (psPMRWrapper->uiKernelMappingRefCnt == 0) {
+		OSLockRelease(psPMRWrapper->hKernelMappingLock);
+		return PVRSRV_ERROR_PMR_NO_KERNEL_MAPPING;
+	}
+
+	eError = CacheOpValExec(psPMRWrapper->psPMR,
+	                        (IMG_UINT64) (uintptr_t) psPMRWrapper->pvKernelMappingAddr,
+	                        0,
+	                        psPMRWrapper->uiKernelMappingLen,
+	                        PVRSRV_CACHE_OP_FLUSH);
+	PVR_LOG_IF_ERROR(eError, "CacheOpValExec");
+
+	OSLockRelease(psPMRWrapper->hKernelMappingLock);
+
+	return eError;
+}
+
 /*
- * dma_buf_ops
+ * dma_buf_ops common code
  *
- * These are all returning errors if used.
- * The point is to prevent anyone outside of our driver from importing
- * and using our dmabuf.
+ * Implementation of below callbacks adds the ability to export DmaBufs to other
+ * drivers.
+ * The following common functions are used by both the dma_buf and GEM
+ * callbacks.
+ */
+
+static int PVRDmaBufOpsAttachCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+							  struct dma_buf_attachment *psAttachment)
+{
+	PMR *psPMR = psPMRWrapper->psPMR;
+
+	if (PMR_GetType(psPMR) == PMR_TYPE_DMABUF)
+	{
+		// don't support exporting PMRs that are itself created from imported
+		// DmaBufs
+		PVR_DPF((PVR_DBG_ERROR, "exporting PMRs of type DMABUF not supported"));
+
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static struct sg_table *PVRDmaBufOpsMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+                                              struct dma_buf_attachment *psAttachment,
+                                              enum dma_data_direction eDirection)
+{
+	PVRSRV_ERROR eError;
+	PMR *psPMR = psPMRWrapper->psPMR;
+	IMG_UINT uiNents;
+	IMG_DEVMEM_SIZE_T uiPhysSize, uiVirtSize;
+	IMG_UINT32 uiNumVirtPages;
+	void *pvPAddrData = NULL;
+	IMG_DEV_PHYADDR asPAddr[PMR_MAX_TRANSLATION_STACK_ALLOC], *psPAddr = asPAddr;
+	IMG_BOOL abValid[PMR_MAX_TRANSLATION_STACK_ALLOC], *pbValid = abValid;
+	IMG_UINT32 i;
+	IMG_DEV_PHYADDR sPAddrPrev, sPAddrCurr;
+	struct sg_table *psTable;
+	struct scatterlist *psSg;
+	int iRet = 0;
+	IMG_UINT32 uiDevPageShift, uiDevPageSize;
+
+	OSLockAcquire(psPMRWrapper->hDeviceMappingLock);
+
+	psPMRWrapper->uiDeviceMappingRefCnt++;
+
+	if (psPMRWrapper->uiDeviceMappingRefCnt > 1)
+	{
+		goto OkUnlock;
+	}
+
+	PVR_ASSERT(psPMRWrapper->psTable == NULL);
+
+	uiDevPageShift = PMR_GetLog2Contiguity(psPMR);
+	uiDevPageSize = 1u << uiDevPageShift;
+	uiVirtSize = PMR_LogicalSize(psPMR);
+	uiPhysSize = PMR_PhysicalSize(psPMR);
+	if (uiPhysSize == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "invalid PMR size"));
+		iRet = PVRSRVToNativeError(PVRSRV_ERROR_BAD_MAPPING);
+		goto ErrUnlockMapping;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s(): mapping pmr: 0x%p@0x%" IMG_UINT64_FMTSPECx
+	         " from heap: \"%s\" with page size: 0x%x", __func__, psPMR,
+	         uiPhysSize, PhysHeapName(PMR_PhysHeap(psPMR)), uiDevPageSize));
+
+	uiNumVirtPages = uiVirtSize >> uiDevPageShift;
+
+	eError = PMRLockSysPhysAddresses(psPMR);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_LOG_IF_ERROR(eError, "PMRLockSysPhysAddresses");
+		iRet = PVRSRVToNativeError(eError);
+		goto ErrUnlockMapping;
+	}
+
+	PMR_SetLayoutFixed(psPMR, IMG_TRUE);
+
+	psTable = OSAllocZMem(sizeof(*psTable));
+	if (psTable == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "OSAllocMem.1() failed"));
+		iRet = -ENOMEM;
+		goto ErrUnlockPhysAddresses;
+	}
+
+	if (uiNumVirtPages > PMR_MAX_TRANSLATION_STACK_ALLOC)
+	{
+		pvPAddrData = OSAllocMem(uiNumVirtPages * (sizeof(*psPAddr) + sizeof(*pbValid)));
+		if (pvPAddrData == NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "OSAllocMem.2() failed"));
+			iRet = -ENOMEM;
+			goto ErrFreeTable;
+		}
+
+		psPAddr = IMG_OFFSET_ADDR(pvPAddrData, 0);
+		pbValid = IMG_OFFSET_ADDR(pvPAddrData, uiNumVirtPages * sizeof(*psPAddr));
+	}
+
+	eError = PMR_DevPhysAddr(psPMR,
+	                         uiDevPageShift,
+	                         uiNumVirtPages,
+	                         0,
+	                         psPAddr,
+	                         pbValid,
+	                         DEVICE_USE);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_LOG_ERROR(eError, "PMR_DevPhysAddr");
+		iRet = PVRSRVToNativeError(eError);
+		goto ErrFreePAddrData;
+	}
+
+	/* Calculate how many contiguous regions there are in the PMR. This
+	 * value will be used to allocate one scatter list for every region. */
+
+	/* Find first valid physical address. */
+	for (i = 0; i < uiNumVirtPages && !pbValid[i]; i++);
+
+	sPAddrPrev = psPAddr[i];
+	uiNents = 1;
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s(): %03u paddr: 0x%" IMG_UINT64_FMTSPECx,
+	         __func__, i, sPAddrPrev.uiAddr));
+
+	/* Find the rest of the addresses. */
+	for (i = i + 1; i < uiNumVirtPages; i++)
+	{
+		if (!pbValid[i])
+		{
+			continue;
+		}
+
+		sPAddrCurr = psPAddr[i];
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s(): %03u paddr: 0x%" IMG_UINT64_FMTSPECx
+		         ", pprev: 0x%" IMG_UINT64_FMTSPECx ", valid: %u", __func__,
+		         i, sPAddrCurr.uiAddr, sPAddrPrev.uiAddr, pbValid[i]));
+
+		if (sPAddrCurr.uiAddr != (sPAddrPrev.uiAddr + uiDevPageSize))
+		{
+			uiNents++;
+		}
+
+		sPAddrPrev = sPAddrCurr;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s(): found %u contiguous regions", __func__,
+	         uiNents));
+
+	/* Allocate scatter lists from all of the contiguous regions. */
+
+	iRet = sg_alloc_table(psTable, uiNents, GFP_KERNEL);
+	if (iRet != 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "sg_alloc_table() failed with error %d", iRet));
+		goto ErrFreePAddrData;
+	}
+
+	/* Fill in all of the physical addresses and sizes for all of the
+	 * contiguous regions that were calculated. */
+
+	for (i = 0; i < uiNumVirtPages && !pbValid[i]; i++);
+
+	psSg = psTable->sgl;
+	sPAddrPrev = psPAddr[i];
+
+	sg_dma_address(psSg) = sPAddrPrev.uiAddr;
+	sg_dma_len(psSg) = uiDevPageSize;
+
+	for (i = i + 1; i < uiNumVirtPages; i++)
+	{
+		if (!pbValid[i])
+		{
+			continue;
+		}
+
+		sPAddrCurr = psPAddr[i];
+
+		if (sPAddrCurr.uiAddr != (sPAddrPrev.uiAddr + uiDevPageSize))
+		{
+			psSg = sg_next(psSg);
+			PVR_ASSERT(psSg != NULL);
+
+			sg_dma_address(psSg) = sPAddrCurr.uiAddr;
+			sg_dma_len(psSg) = uiDevPageSize;
+		}
+		else
+		{
+			sg_dma_len(psSg) += uiDevPageSize;
+		}
+
+		sPAddrPrev = sPAddrCurr;
+	}
+
+	if (pvPAddrData != NULL)
+	{
+		OSFreeMem(pvPAddrData);
+	}
+
+	psPMRWrapper->psTable = psTable;
+
+OkUnlock:
+	OSLockRelease(psPMRWrapper->hDeviceMappingLock);
+
+	return psPMRWrapper->psTable;
+
+ErrFreePAddrData:
+	if (pvPAddrData != NULL)
+	{
+		OSFreeMem(pvPAddrData);
+	}
+ErrFreeTable:
+	OSFreeMem(psTable);
+ErrUnlockPhysAddresses:
+	{
+		PVRSRV_ERROR eError2 = PMRUnlockSysPhysAddresses(psPMR);
+		PVR_LOG_IF_ERROR(eError2, "PMRUnlockSysPhysAddresses");
+	}
+ErrUnlockMapping:
+	psPMRWrapper->uiDeviceMappingRefCnt--;
+	OSLockRelease(psPMRWrapper->hDeviceMappingLock);
+
+	return ERR_PTR(iRet);
+}
+
+static void PVRDmaBufOpsUnmapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+                              struct dma_buf_attachment *psAttachment,
+                              struct sg_table *psTable,
+                              enum dma_data_direction eDirection)
+{
+	PVRSRV_ERROR eError;
+
+	OSLockAcquire(psPMRWrapper->hDeviceMappingLock);
+
+	if (psPMRWrapper->uiDeviceMappingRefCnt == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "reference count on mapping already 0"));
+		goto ErrUnlock;
+	}
+
+	psPMRWrapper->uiDeviceMappingRefCnt--;
+
+	if (psPMRWrapper->uiDeviceMappingRefCnt > 0)
+	{
+		goto ErrUnlock;
+	}
+
+	dma_unmap_sg(psAttachment->dev, psTable->sgl, psTable->nents, eDirection);
+	sg_free_table(psTable);
+
+	eError = PMRUnlockSysPhysAddresses(psPMRWrapper->psPMR);
+	PVR_LOG_IF_ERROR(eError, "PMRUnlockSysPhysAddresses");
+
+	OSFreeMem(psPMRWrapper->psTable);
+	psPMRWrapper->psTable = NULL;
+
+ErrUnlock:
+	OSLockRelease(psPMRWrapper->hDeviceMappingLock);
+}
+
+static int PVRDmaBufOpsBeginCpuAccessCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+                                      enum dma_data_direction eDirection)
+{
+	if (PVRSRV_CHECK_CPU_CACHED(PMR_Flags(psPMRWrapper->psPMR)))
+	{
+		PVRSRV_ERROR eError = _PMRInvalidateCache(psPMRWrapper);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_LOG_ERROR(eError, "_PMRInvalidateCache");
+			return OSPVRSRVToNativeError(eError);
+		}
+	}
+
+	return 0;
+}
+
+static int PVRDmaBufOpsEndCpuAccessCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper,
+                                    enum dma_data_direction eDirection)
+{
+	if (PVRSRV_CHECK_CPU_CACHED(PMR_Flags(psPMRWrapper->psPMR)))
+	{
+		PVRSRV_ERROR eError = _PMRCleanCache(psPMRWrapper);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_LOG_ERROR(eError, "_PMRCleanCache");
+			return OSPVRSRVToNativeError(eError);
+		}
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+static void *PVRDmaBufOpsKMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, unsigned long uiPageNum)
+{
+	return NULL;
+}
+
+static void PVRDmaBufOpsKUnMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, unsigned long uiPageNum, void *pvMem)
+{
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void *PVRDmaBufOpsVMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper)
+{
+	void *pvAddrOut = NULL;
+	PVRSRV_ERROR eError;
+
+	eError = _PMRKMap(psPMRWrapper, 0, &pvAddrOut);
+
+	return eError == PVRSRV_OK ? pvAddrOut : NULL;
+}
+#else
+static int PVRDmaBufOpsVMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, struct iosys_map *psMap)
+{
+	void *pvAddrOut = NULL;
+	PVRSRV_ERROR eError;
+
+	eError = _PMRKMap(psPMRWrapper, 0, &pvAddrOut);
+
+	if (eError != PVRSRV_OK)
+	{
+		return OSPVRSRVToNativeError(eError);
+	}
+
+	if (PhysHeapGetType(PMR_PhysHeap(psPMRWrapper->psPMR)) == PHYS_HEAP_TYPE_UMA)
+	{
+		iosys_map_set_vaddr(psMap, pvAddrOut);
+	}
+	else
+	{
+		iosys_map_set_vaddr_iomem(psMap, pvAddrOut);
+	}
+
+	return 0;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void PVRDmaBufOpsVUnMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, void *pvAddr)
+{
+	_PMRKUnmap(psPMRWrapper);
+}
+#else
+static void PVRDmaBufOpsVUnMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, struct iosys_map *psMap)
+{
+	_PMRKUnmap(psPMRWrapper);
+
+	iosys_map_clear(psMap);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
+static int PVRDmaBufOpsMMapCommon(PMR_DMA_BUF_WRAPPER *psPMRWrapper, struct vm_area_struct *psVMA)
+{
+	PMR *psPMR = psPMRWrapper->psPMR;
+	PVRSRV_MEMALLOCFLAGS_T uiProtFlags =
+	    (BITMASK_HAS(psVMA->vm_flags, VM_READ) ? PVRSRV_MEMALLOCFLAG_CPU_READABLE : 0) |
+	    (BITMASK_HAS(psVMA->vm_flags, VM_WRITE) ? PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE : 0);
+	PVRSRV_ERROR eError;
+
+	/* Forcibly clear the VM_MAYWRITE flag as this is inherited from the
+	 * kernel mmap code and we do not want to produce a potentially writable
+	 * mapping from a read-only mapping.
+	 */
+	if (!BITMASK_HAS(psVMA->vm_flags, VM_WRITE))
+	{
+		pvr_vm_flags_clear(psVMA, VM_MAYWRITE);
+	}
+
+	eError = PMRMMapPMR(psPMR, psVMA, uiProtFlags);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_LOG_IF_ERROR(eError, "PMRMMapPMR");
+		return OSPVRSRVToNativeError(eError);
+	}
+
+	return 0;
+}
+
+/* end of dma_buf_ops common code*/
+
+/*
+ * dma_buf_ops (non-GEM)
+ *
+ * Implementation of below callbacks adds the ability to export DmaBufs to other
+ * drivers.
  */
 
 static int PVRDmaBufOpsAttach(struct dma_buf *psDmaBuf,
@@ -98,63 +652,309 @@ static int PVRDmaBufOpsAttach(struct dma_buf *psDmaBuf,
 #endif
 							  struct dma_buf_attachment *psAttachment)
 {
-	return -ENOSYS;
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsAttachCommon(psPMRWrapper, psAttachment);
 }
 
 static struct sg_table *PVRDmaBufOpsMap(struct dma_buf_attachment *psAttachment,
                                         enum dma_data_direction eDirection)
 {
-	/* Attach hasn't been called yet */
-	return ERR_PTR(-EINVAL);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psAttachment->dmabuf->priv;
+
+	return PVRDmaBufOpsMapCommon(psPMRWrapper, psAttachment, eDirection);
 }
 
 static void PVRDmaBufOpsUnmap(struct dma_buf_attachment *psAttachment,
                               struct sg_table *psTable,
                               enum dma_data_direction eDirection)
 {
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psAttachment->dmabuf->priv;
+
+	PVRDmaBufOpsUnmapCommon(psPMRWrapper, psAttachment, psTable, eDirection);
 }
 
 static void PVRDmaBufOpsRelease(struct dma_buf *psDmaBuf)
 {
-	PMR *psPMR = (PMR *) psDmaBuf->priv;
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+	PMR *psPMR = psPMRWrapper->psPMR;
 
 	PMRUnrefPMR(psPMR);
 }
 
+static int PVRDmaBufOpsBeginCpuAccess(struct dma_buf *psDmaBuf,
+                                      enum dma_data_direction eDirection)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsBeginCpuAccessCommon(psPMRWrapper, eDirection);
+}
+
+static int PVRDmaBufOpsEndCpuAccess(struct dma_buf *psDmaBuf,
+                                    enum dma_data_direction eDirection)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+	int iErr;
+
+	iErr = PVRDmaBufOpsEndCpuAccessCommon(psPMRWrapper, eDirection);
+
+	return iErr;
+}
+
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
 static void *PVRDmaBufOpsKMap(struct dma_buf *psDmaBuf, unsigned long uiPageNum)
 {
-	return ERR_PTR(-ENOSYS);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsKMapCommon(psPMRWrapper, uiPageNum);
+}
+
+static void PVRDmaBufOpsKUnMap(struct dma_buf *psDmaBuf, unsigned long uiPageNum, void *pvMem)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsKUnMapCommon(psPMRWrapper, uiPageNum, pvMem);
 }
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void *PVRDmaBufOpsVMap(struct dma_buf *psDmaBuf)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsVMapCommon(psPMRWrapper);
+}
+#else
+static int PVRDmaBufOpsVMap(struct dma_buf *psDmaBuf, struct iosys_map *psMap)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	return PVRDmaBufOpsVMapCommon(psPMRWrapper, psMap);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void PVRDmaBufOpsVUnMap(struct dma_buf *psDmaBuf, void *pvAddr)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	PVRDmaBufOpsVUnMapCommon(psPMRWrapper, pvAddr);
+}
+#else
+static void PVRDmaBufOpsVUnMap(struct dma_buf *psDmaBuf, struct iosys_map *psMap)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	PVRDmaBufOpsVUnMapCommon(psPMRWrapper, psMap);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
 static int PVRDmaBufOpsMMap(struct dma_buf *psDmaBuf, struct vm_area_struct *psVMA)
 {
-	return -ENOSYS;
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s(): psDmaBuf = %px, psPMR = %px", __func__,
+	         psDmaBuf, psPMRWrapper->psPMR));
+
+	return PVRDmaBufOpsMMapCommon(psPMRWrapper, psVMA);
+}
+
+static const struct dma_buf_ops sPVRDmaBufOps =
+{
+	.attach        = PVRDmaBufOpsAttach,
+	.map_dma_buf   = PVRDmaBufOpsMap,
+	.unmap_dma_buf = PVRDmaBufOpsUnmap,
+	.release       = PVRDmaBufOpsRelease,
+	.begin_cpu_access = PVRDmaBufOpsBeginCpuAccess,
+	.end_cpu_access   = PVRDmaBufOpsEndCpuAccess,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)) && \
+	!((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)) && (defined(CHROMIUMOS_KERNEL))))
+	.map_atomic    = PVRDmaBufOpsKMap,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+	.map           = PVRDmaBufOpsKMap,
+	.unmap         = PVRDmaBufOpsKUnMap,
+#endif
+#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)) */
+	.kmap_atomic   = PVRDmaBufOpsKMap,
+	.kmap          = PVRDmaBufOpsKMap,
+	.kunmap        = PVRDmaBufOpsKUnMap,
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)) */
+	.mmap          = PVRDmaBufOpsMMap,
+
+	.vmap          = PVRDmaBufOpsVMap,
+	.vunmap        = PVRDmaBufOpsVUnMap,
+};
+
+/* end of dma_buf_ops (non-GEM) */
+
+/*
+ * dma_buf_ops (GEM)
+ *
+ * Implementation of below callbacks adds the ability to export DmaBufs to other
+ * drivers.
+ */
+
+static int PVRDmaBufOpsAttachGEM(struct dma_buf *psDmaBuf,
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)) && \
+	!((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)) && (defined(CHROMIUMOS_KERNEL))))
+							  struct device *psDev,
+#endif
+							  struct dma_buf_attachment *psAttachment)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsAttachCommon(psPMRWrapper, psAttachment);
+}
+
+static struct sg_table *PVRDmaBufOpsMapGEM(struct dma_buf_attachment *psAttachment,
+                                        enum dma_data_direction eDirection)
+{
+	struct drm_gem_object *psObj = psAttachment->dmabuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsMapCommon(psPMRWrapper, psAttachment, eDirection);
+}
+
+static void PVRDmaBufOpsUnmapGEM(struct dma_buf_attachment *psAttachment,
+                              struct sg_table *psTable,
+                              enum dma_data_direction eDirection)
+{
+	struct drm_gem_object *psObj = psAttachment->dmabuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	PVRDmaBufOpsUnmapCommon(psPMRWrapper, psAttachment, psTable, eDirection);
+}
+
+static int PVRDmaBufOpsBeginCpuAccessGEM(struct dma_buf *psDmaBuf,
+                                      enum dma_data_direction eDirection)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsBeginCpuAccessCommon(psPMRWrapper, eDirection);
+}
+
+static int PVRDmaBufOpsEndCpuAccessGEM(struct dma_buf *psDmaBuf,
+                                    enum dma_data_direction eDirection)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+	int iErr;
+
+	iErr = PVRDmaBufOpsEndCpuAccessCommon(psPMRWrapper, eDirection);
+
+	return iErr;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+static void *PVRDmaBufOpsKMapGEM(struct dma_buf *psDmaBuf, unsigned long uiPageNum)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsKMapCommon(psPMRWrapper, uiPageNum);
+}
+
+static void PVRDmaBufOpsKUnMapGEM(struct dma_buf *psDmaBuf, unsigned long uiPageNum, void *pvMem)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsKUnMapCommon(psPMRWrapper, uiPageNum, pvMem);
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void *PVRDmaBufOpsVMapGEM(struct dma_buf *psDmaBuf)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsVMapCommon(psPMRWrapper);
+}
+#else
+static int PVRDmaBufOpsVMapGEM(struct dma_buf *psDmaBuf, struct iosys_map *psMap)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	return PVRDmaBufOpsVMapCommon(psPMRWrapper, psMap);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+static void PVRDmaBufOpsVUnMapGEM(struct dma_buf *psDmaBuf, void *pvAddr)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	PVRDmaBufOpsVUnMapCommon(psPMRWrapper, pvAddr);
+}
+#else
+static void PVRDmaBufOpsVUnMapGEM(struct dma_buf *psDmaBuf, struct iosys_map *psMap)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	PVRDmaBufOpsVUnMapCommon(psPMRWrapper, psMap);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0) */
+
+static int PVRDmaBufOpsMMapGEM(struct dma_buf *psDmaBuf, struct vm_area_struct *psVMA)
+{
+	struct drm_gem_object *psObj = psDmaBuf->priv;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	PVR_DPF((PVR_DBG_MESSAGE, "%s(): psDmaBuf = %px, psPMR = %px", __func__,
+	         psDmaBuf, psPMRWrapper->psPMR));
+
+	return PVRDmaBufOpsMMapCommon(psPMRWrapper, psVMA);
 }
 
-static const struct dma_buf_ops sPVRDmaBufOps =
+static const struct dma_buf_ops sPVRDmaBufOpsGEM =
 {
-	.attach        = PVRDmaBufOpsAttach,
-	.map_dma_buf   = PVRDmaBufOpsMap,
-	.unmap_dma_buf = PVRDmaBufOpsUnmap,
-	.release       = PVRDmaBufOpsRelease,
+	.attach        = PVRDmaBufOpsAttachGEM,
+	.map_dma_buf   = PVRDmaBufOpsMapGEM,
+	.unmap_dma_buf = PVRDmaBufOpsUnmapGEM,
+	.release       = drm_gem_dmabuf_release,
+	.begin_cpu_access = PVRDmaBufOpsBeginCpuAccessGEM,
+	.end_cpu_access   = PVRDmaBufOpsEndCpuAccessGEM,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 #if ((LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)) && \
 	!((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)) && (defined(CHROMIUMOS_KERNEL))))
-	.map_atomic    = PVRDmaBufOpsKMap,
+	.map_atomic    = PVRDmaBufOpsKMapGEM,
 #endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
-	.map           = PVRDmaBufOpsKMap,
-#endif
-#else
-	.kmap_atomic   = PVRDmaBufOpsKMap,
-	.kmap          = PVRDmaBufOpsKMap,
+	.map           = PVRDmaBufOpsKMapGEM,
+	.unmap         = PVRDmaBufOpsKUnMapGEM,
 #endif
-	.mmap          = PVRDmaBufOpsMMap,
+#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)) */
+	.kmap_atomic   = PVRDmaBufOpsKMapGEM,
+	.kmap          = PVRDmaBufOpsKMapGEM,
+	.kunmap        = PVRDmaBufOpsKUnMapGEM,
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)) */
+	.mmap          = PVRDmaBufOpsMMapGEM,
+
+	.vmap          = PVRDmaBufOpsVMapGEM,
+	.vunmap        = PVRDmaBufOpsVUnMapGEM,
 };
 
-/* end of dma_buf_ops */
+/* end of dma_buf_ops (GEM) */
 
 
 typedef struct _PMR_DMA_BUF_DATA_
@@ -164,6 +964,7 @@ typedef struct _PMR_DMA_BUF_DATA_
 	struct dma_buf_attachment *psAttachment;
 	PFN_DESTROY_DMABUF_PMR pfnDestroy;
 	IMG_BOOL bPoisonOnFree;
+	IMG_PID uiOriginPID;
 
 	/* Mapping information. */
 	struct iosys_map sMap;
@@ -278,7 +1079,7 @@ static void PMRFinalizeDmaBuf(PMR_IMPL_PRIVDATA pvPriv)
 	struct dma_buf *psDmaBuf = psAttachment->dmabuf;
 	struct sg_table *psSgTable = psPrivData->psSgTable;
 
-	if (psDmaBuf->ops != &sPVRDmaBufOps)
+	if (psDmaBuf->ops != &sPVRDmaBufOps && psDmaBuf->ops != &sPVRDmaBufOpsGEM)
 	{
 		if (g_psDmaBufHash)
 		{
@@ -304,20 +1105,24 @@ static void PMRFinalizeDmaBuf(PMR_IMPL_PRIVDATA pvPriv)
 	{
 		PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE,
 		                            psPrivData->ui32PhysPageCount << PAGE_SHIFT,
-		                            OSGetCurrentClientProcessIDKM());
+		                            psPrivData->uiOriginPID);
 	}
 	else
 #endif
 	{
 		PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT,
 		                            psPrivData->ui32PhysPageCount << PAGE_SHIFT,
-		                            OSGetCurrentClientProcessIDKM());
+		                            psPrivData->uiOriginPID);
 	}
 #endif
 
 	psPrivData->ui32PhysPageCount = 0;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 36))
 	dma_buf_unmap_attachment_unlocked(psAttachment, psSgTable, DMA_BIDIRECTIONAL);
+#else
+	dma_buf_unmap_attachment(psAttachment, psSgTable, DMA_BIDIRECTIONAL);
+#endif
 
 	if (psPrivData->bPoisonOnFree)
 	{
@@ -351,10 +1156,10 @@ static PVRSRV_ERROR PMRZombifyDmaBufMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT,
 	                            psPrivData->ui32PhysPageCount << PAGE_SHIFT,
-	                            OSGetCurrentClientProcessIDKM());
+	                            psPrivData->uiOriginPID);
 	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE,
 	                            psPrivData->ui32PhysPageCount << PAGE_SHIFT,
-	                            OSGetCurrentClientProcessIDKM());
+	                            psPrivData->uiOriginPID);
 #else
 	PVR_UNREFERENCED_PARAMETER(pvPriv);
 #endif
@@ -367,13 +1172,25 @@ static PVRSRV_ERROR PMRZombifyDmaBufMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 
 static PVRSRV_ERROR PMRLockPhysAddressesDmaBuf(PMR_IMPL_PRIVDATA pvPriv)
 {
+	/* The imported memory is assumed to be backed by a permanent allocation.
+	 * The PMR does not need to be (un)locked */
 	PVR_UNREFERENCED_PARAMETER(pvPriv);
 	return PVRSRV_OK;
 }
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static PVRSRV_ERROR PMRUnlockPhysAddressesDmaBuf(PMR_IMPL_PRIVDATA pvPriv,
+                                                 PMR_IMPL_ZOMBIEPAGES *ppvZombiePages)
+#else
 static PVRSRV_ERROR PMRUnlockPhysAddressesDmaBuf(PMR_IMPL_PRIVDATA pvPriv)
+#endif
 {
+	/* The imported memory is assumed to be backed by a permanent allocation.
+	 * The PMR does not need to be (un)locked */
 	PVR_UNREFERENCED_PARAMETER(pvPriv);
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	*ppvZombiePages = NULL;
+#endif
 	return PVRSRV_OK;
 }
 
@@ -391,7 +1208,7 @@ static PVRSRV_ERROR PMRDevPhysAddrDmaBuf(PMR_IMPL_PRIVDATA pvPriv,
 					 IMG_UINT32 ui32Log2PageSize,
 					 IMG_UINT32 ui32NumOfPages,
 					 IMG_DEVMEM_OFFSET_T *puiOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 					 IMG_UINT64 ui64IPAPolicyValue,
 					 IMG_UINT64 ui64IPAClearMask,
 #endif
@@ -402,7 +1219,7 @@ static PVRSRV_ERROR PMRDevPhysAddrDmaBuf(PMR_IMPL_PRIVDATA pvPriv,
 	IMG_UINT32 ui32PageIndex;
 	IMG_UINT32 idx;
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	PVR_UNREFERENCED_PARAMETER(ui64IPAPolicyValue);
 	PVR_UNREFERENCED_PARAMETER(ui64IPAClearMask);
 #endif
@@ -426,7 +1243,7 @@ static PVRSRV_ERROR PMRDevPhysAddrDmaBuf(PMR_IMPL_PRIVDATA pvPriv,
 
 			PVR_ASSERT(ui32InPageOffset < PAGE_SIZE);
 			psDevPAddr[idx].uiAddr = psPrivData->pasDevPhysAddr[ui32PageIndex].uiAddr + ui32InPageOffset;
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 			/* Modify the physical address with the associated IPA values */
 			psDevPAddr[idx].uiAddr &= ~ui64IPAClearMask;
 			psDevPAddr[idx].uiAddr |= ui64IPAPolicyValue;
@@ -577,6 +1394,7 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 	struct sg_table *table;
 	IMG_UINT32 uiSglOffset;
 	IMG_CHAR pszAnnotation[DEVMEM_ANNOTATION_MAX_LEN];
+	IMG_UINT32 ui32ActualDmaBufPageCount;
 
 	bZeroOnAlloc = PVRSRV_CHECK_ZERO_ON_ALLOC(uiFlags);
 	bPoisonOnAlloc = PVRSRV_CHECK_POISON_ON_ALLOC(uiFlags);
@@ -613,6 +1431,7 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 	psPrivData->psAttachment = psAttachment;
 	psPrivData->pfnDestroy = pfnDestroy;
 	psPrivData->bPoisonOnFree = bPoisonOnFree;
+	psPrivData->uiOriginPID = OSGetCurrentClientProcessIDKM();
 	psPrivData->ui32VirtPageCount =
 			(ui32NumVirtChunks * uiChunkSize) >> PAGE_SHIFT;
 
@@ -644,8 +1463,12 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 			goto errFreePhysAddr;
 		}
 	}
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 36))
 	table = dma_buf_map_attachment_unlocked(psAttachment, DMA_BIDIRECTIONAL);
+#else
+
+	table = dma_buf_map_attachment(psAttachment, DMA_BIDIRECTIONAL);
+#endif
 	if (IS_ERR_OR_NULL(table))
 	{
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -669,16 +1492,19 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 		goto errUnmap;
 	}
 
-	if (WARN_ON(ui32PageCount != ui32NumPhysChunks * uiPagesPerChunk))
+	/* Obtain actual page count of dma buf */
+	ui32ActualDmaBufPageCount = psAttachment->dmabuf->size / PAGE_SIZE;
+
+	if (WARN_ON(ui32ActualDmaBufPageCount < ui32NumPhysChunks * uiPagesPerChunk))
 	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Requested physical chunks and actual "
-				"number of physical dma buf pages don't match",
+		PVR_DPF((PVR_DBG_ERROR, "%s: Requested physical chunks greater than "
+				"number of physical dma buf pages",
 				 __func__));
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto errUnmap;
 	}
 
-	psPrivData->ui32PhysPageCount = ui32PageCount;
+	psPrivData->ui32PhysPageCount = ui32ActualDmaBufPageCount;
 	psPrivData->psSgTable = table;
 	ui32PageCount = 0;
 	sg = table->sgl;
@@ -718,7 +1544,7 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT,
 	                            psPrivData->ui32PhysPageCount << PAGE_SHIFT,
-	                            OSGetCurrentClientProcessIDKM());
+	                            psPrivData->uiOriginPID);
 #endif
 
 	uiPMRFlags = (PMR_FLAGS_T)(uiFlags & PVRSRV_MEMALLOCFLAGS_PMRFLAGSMASK);
@@ -761,7 +1587,12 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 	return PVRSRV_OK;
 
 errUnmap:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 36))
 	dma_buf_unmap_attachment_unlocked(psAttachment, table, DMA_BIDIRECTIONAL);
+#else
+
+	dma_buf_unmap_attachment(psAttachment, table, DMA_BIDIRECTIONAL);
+#endif
 errFreePhysAddr:
 	OSFreeMem(psPrivData->pasDevPhysAddr);
 errFreePrivData:
@@ -778,6 +1609,9 @@ static void PhysmemDestroyDmaBuf(PHYS_HEAP *psHeap,
 
 	PVR_UNREFERENCED_PARAMETER(psHeap);
 
+	/* PMRUnlockSysPhysAddresses(psPMR) is redundant.
+	 * See PMRUnlockPhysAddressesDmaBuf */
+
 	dma_buf_detach(psDmaBuf, psAttachment);
 	dma_buf_put(psDmaBuf);
 }
@@ -796,48 +1630,153 @@ PhysmemGetDmaBuf(PMR *psPMR)
 	return NULL;
 }
 
+struct dma_resv *
+PhysmemGetDmaResv(PMR *psPMR)
+{
+	struct dma_buf *psDmaBuf = PhysmemGetDmaBuf(psPMR);
+
+	if (psDmaBuf)
+	{
+		return psDmaBuf->resv;
+	}
+	else
+	{
+		PMR_DMA_BUF_WRAPPER *psPMRWrapper = PMREnvDmaBufGetExportData(psPMR);
+
+		if (psPMRWrapper)
+		{
+			return &psPMRWrapper->sDmaResv;
+
+		}
+
+		return NULL;
+	}
+}
+
+static void
+PhysmemDestroyPMRWrapper(PMR_DMA_BUF_WRAPPER *psPMRWrapper)
+{
+	dma_resv_fini(&psPMRWrapper->sDmaResv);
+
+	OSLockDestroy(psPMRWrapper->hKernelMappingLock);
+	OSLockDestroy(psPMRWrapper->hDeviceMappingLock);
+	OSFreeMem(psPMRWrapper);
+}
+
+void
+PhysmemDmaBufExportFinalize(void *pvDmaBufExportData)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = pvDmaBufExportData;
+
+	PhysmemDestroyPMRWrapper(psPMRWrapper);
+}
+
+static PVRSRV_ERROR
+PhysmemCreatePMRWrapper(PMR *psPMR, PMR_DMA_BUF_WRAPPER **ppsPMRWrapper)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper;
+	PVRSRV_ERROR eError;
+
+	psPMRWrapper = OSAllocZMem(sizeof(*psPMRWrapper));
+	PVR_LOG_GOTO_IF_NOMEM(psPMRWrapper, eError, fail_alloc_mem);
+
+	psPMRWrapper->psPMR = psPMR;
+
+	eError = OSLockCreate(&psPMRWrapper->hKernelMappingLock);
+	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate.1",
+	                      fail_kernel_mapping_lock_create);
+
+	eError = OSLockCreate(&psPMRWrapper->hDeviceMappingLock);
+	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate.2",
+	                      fail_device_mapping_lock_create);
+
+	dma_resv_init(&psPMRWrapper->sDmaResv);
+
+	*ppsPMRWrapper = psPMRWrapper;
+
+	return PVRSRV_OK;
+fail_device_mapping_lock_create:
+	OSLockDestroy(psPMRWrapper->hKernelMappingLock);
+fail_kernel_mapping_lock_create:
+	OSFreeMem(psPMRWrapper);
+fail_alloc_mem:
+	return eError;
+}
+
+static PVRSRV_ERROR
+PhysmemGetOrCreatePMRWrapper(PMR *psPMR, PMR_DMA_BUF_WRAPPER **ppsPMRWrapper)
+{
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper;
+	PVRSRV_ERROR eError;
+
+	psPMRWrapper = PMREnvDmaBufGetExportData(psPMR);
+	if (!psPMRWrapper)
+	{
+		PMRFactoryLock();
+
+		/* Check again with the factory lock held */
+		psPMRWrapper = PMREnvDmaBufGetExportData(psPMR);
+		if (!psPMRWrapper)
+		{
+			eError = PhysmemCreatePMRWrapper(psPMR, &psPMRWrapper);
+			PVR_LOG_GOTO_IF_ERROR(eError, "PhysmemCreatePMRWrapper", fail_create_pmr_wrapper);
+
+			/*
+			 * A PMR memory layout can't change once exported.
+			 * This makes sure the exported and imported parties
+			 * see the same layout of the memory.
+			 */
+			PMR_SetLayoutFixed(psPMR, IMG_TRUE);
+
+			PMREnvDmaBufSetExportData(psPMR, psPMRWrapper);
+		}
+
+		PMRFactoryUnlock();
+	}
+
+	*ppsPMRWrapper = psPMRWrapper;
+
+	return PVRSRV_OK;
+
+fail_create_pmr_wrapper:
+	PMRFactoryUnlock();
+	return eError;
+}
+
 PVRSRV_ERROR
 PhysmemExportDmaBuf(CONNECTION_DATA *psConnection,
                     PVRSRV_DEVICE_NODE *psDevNode,
                     PMR *psPMR,
                     IMG_INT *piFd)
 {
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper;
 	struct dma_buf *psDmaBuf;
-	IMG_DEVMEM_SIZE_T uiPMRSize;
 	PVRSRV_ERROR eError;
 	IMG_INT iFd;
 
-	PMRFactoryLock();
+	eError = PhysmemGetOrCreatePMRWrapper(psPMR, &psPMRWrapper);
+	PVR_LOG_GOTO_IF_ERROR(eError, "PhysmemExportDmaBuf", fail_get_pmr_wrapper);
 
 	PMRRefPMR(psPMR);
 
-	PMR_LogicalSize(psPMR, &uiPMRSize);
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	{
 		DEFINE_DMA_BUF_EXPORT_INFO(sDmaBufExportInfo);
 
-		sDmaBufExportInfo.priv  = psPMR;
+		sDmaBufExportInfo.priv  = psPMRWrapper;
 		sDmaBufExportInfo.ops   = &sPVRDmaBufOps;
-		sDmaBufExportInfo.size  = uiPMRSize;
+		sDmaBufExportInfo.size  = PMR_LogicalSize(psPMR);
 		sDmaBufExportInfo.flags = O_RDWR;
+		sDmaBufExportInfo.resv  = &psPMRWrapper->sDmaResv;
 
 		psDmaBuf = dma_buf_export(&sDmaBufExportInfo);
 	}
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
-	psDmaBuf = dma_buf_export(psPMR, &sPVRDmaBufOps,
-	                          uiPMRSize, O_RDWR, NULL);
-#else
-	psDmaBuf = dma_buf_export(psPMR, &sPVRDmaBufOps,
-	                          uiPMRSize, O_RDWR);
-#endif
 
 	if (IS_ERR_OR_NULL(psDmaBuf))
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to export buffer (err=%ld)",
 		         __func__, psDmaBuf ? PTR_ERR(psDmaBuf) : -ENOMEM));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto fail_pmr_ref;
+		goto fail_export;
 	}
 
 	iFd = dma_buf_fd(psDmaBuf, O_RDWR);
@@ -849,24 +1788,145 @@ PhysmemExportDmaBuf(CONNECTION_DATA *psConnection,
 		goto fail_dma_buf;
 	}
 
-	PMRFactoryUnlock();
 	*piFd = iFd;
 
-	/* A PMR memory lay out can't change once exported
-	 * This makes sure the exported and imported parties see
-	 * the same layout of the memory */
-	PMR_SetLayoutFixed(psPMR, IMG_TRUE);
-
 	return PVRSRV_OK;
 
 fail_dma_buf:
 	dma_buf_put(psDmaBuf);
+	return eError;
 
-fail_pmr_ref:
+fail_export:
 	PMRUnrefPMR(psPMR);
+
+fail_get_pmr_wrapper:
+	return eError;
+}
+
+struct dma_buf *
+PhysmemGEMPrimeExport(
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+			struct drm_device *psDev,
+#endif
+
+			struct drm_gem_object *psObj,
+			int iFlags)
+{
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+	struct dma_buf *psDmaBuf = NULL;
+	DEFINE_DMA_BUF_EXPORT_INFO(sDmaBufExportInfo);
+
+
+	sDmaBufExportInfo.priv  = psObj;
+	sDmaBufExportInfo.ops   = &sPVRDmaBufOpsGEM;
+	sDmaBufExportInfo.size  = PMR_LogicalSize(psPMRWrapper->psPMR);
+	sDmaBufExportInfo.flags = iFlags;
+	sDmaBufExportInfo.resv  = &psPMRWrapper->sDmaResv;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+	psDmaBuf = drm_gem_dmabuf_export(psObj->dev, &sDmaBufExportInfo);
+#else
+	psDmaBuf = drm_gem_dmabuf_export(psDev, &sDmaBufExportInfo);
+#endif
+	if (IS_ERR(psDmaBuf))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to export buffer (err=%ld)",
+		         __func__, PTR_ERR(psDmaBuf)));
+	}
+
+	return psDmaBuf;
+}
+
+void
+PhysmemGEMObjectFree(struct drm_gem_object *psObj)
+{
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+	drm_gem_object_release(psObj);
+
+	if (smp_load_acquire(&psPMRWrapper->psObj) == psObj)
+	{
+		smp_store_release(&psPMRWrapper->psObj, NULL);
+	}
+
+	PMRUnrefPMR(psPMRWrapper->psPMR);
+
+	OSFreeMem(psGEMObj);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+static const struct drm_gem_object_funcs sPhysmemGEMObjFuncs = {
+	.export = PhysmemGEMPrimeExport,
+	.free = PhysmemGEMObjectFree,
+};
+#endif
+
+PVRSRV_ERROR
+PhysmemExportGemHandle(CONNECTION_DATA *psConnection,
+		       PVRSRV_DEVICE_NODE *psDevNode,
+		       PMR *psPMR,
+		       IMG_UINT32 *puHandle)
+{
+	struct device *psDev = psDevNode->psDevConfig->pvOSDevice;
+	struct drm_device *psDRMDev = dev_get_drvdata(psDev);
+	struct drm_file *psDRMFile = OSGetDRMFile(psConnection);
+	PMR_DMA_BUF_WRAPPER *psPMRWrapper;
+	PMR_DMA_BUF_GEM_OBJ *psGEMObj;
+	bool bAlreadyExported;
+	PVRSRV_ERROR eError;
+	int iErr;
+
+	eError = PhysmemGetOrCreatePMRWrapper(psPMR, &psPMRWrapper);
+	PVR_LOG_GOTO_IF_ERROR(eError, "PhysmemExportGemHandle", fail_get_pmr_wrapper);
+
+	psGEMObj = OSAllocZMem(sizeof(*psGEMObj));
+	PVR_LOG_GOTO_IF_NOMEM(psGEMObj, eError, fail_alloc_mem);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+	psGEMObj->sBase.funcs = &sPhysmemGEMObjFuncs;
+#endif
+	psGEMObj->psPMRWrapper = psPMRWrapper;
+
+	PMRRefPMR(psPMR);
+
+	drm_gem_private_object_init(psDRMDev, &psGEMObj->sBase,
+	                            PMR_LogicalSize(psPMR));
+
+	PMRFactoryLock();
+	bAlreadyExported = smp_load_acquire(&psPMRWrapper->psObj) != NULL;
+	if (!bAlreadyExported)
+	{
+		smp_store_release(&psPMRWrapper->psObj, &psGEMObj->sBase);
+	}
 	PMRFactoryUnlock();
 
-	PVR_ASSERT(eError != PVRSRV_OK);
+	if (bAlreadyExported)
+	{
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_STILL_REFERENCED,
+					    fail_export_check);
+	}
+
+	iErr = drm_gem_handle_create(psDRMFile, &psGEMObj->sBase, puHandle);
+	if (iErr)
+	{
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_OUT_OF_MEMORY,
+				    fail_handle_create);
+	}
+
+	/* The handle holds a reference on the object, so drop ours */
+	drm_gem_object_put(&psGEMObj->sBase);
+
+	return PVRSRV_OK;
+
+fail_export_check:
+fail_handle_create:
+	drm_gem_object_put(&psGEMObj->sBase);
+	return eError;
+
+fail_alloc_mem:
+fail_get_pmr_wrapper:
 	return eError;
 }
 
@@ -917,46 +1977,6 @@ PhysmemImportDmaBuf(CONNECTION_DATA *psConnection,
 	return eError;
 }
 
-PVRSRV_ERROR
-PhysmemImportDmaBufLocked(CONNECTION_DATA *psConnection,
-                          PVRSRV_DEVICE_NODE *psDevNode,
-                          IMG_INT fd,
-                          PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                          IMG_UINT32 ui32NameSize,
-                          const IMG_CHAR pszName[DEVMEM_ANNOTATION_MAX_LEN],
-                          PMR **ppsPMRPtr,
-                          IMG_DEVMEM_SIZE_T *puiSize,
-                          IMG_DEVMEM_ALIGN_T *puiAlign)
-{
-	PMR *psPMRPtr;
-	PVRSRV_ERROR eError;
-
-	eError = PhysmemImportDmaBuf(psConnection,
-	                             psDevNode,
-	                             fd,
-	                             uiFlags,
-	                             ui32NameSize,
-	                             pszName,
-	                             &psPMRPtr,
-	                             puiSize,
-	                             puiAlign);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemImportDmaBuf");
-
-	if (!PVRSRV_CHECK_PHYS_ALLOC_NOW(PMR_Flags(psPMRPtr)))
-	{
-		eError = PMRLockSysPhysAddresses(psPMRPtr);
-		PVR_LOG_GOTO_IF_ERROR(eError, "PMRLockSysPhysAddresses", error_unref);
-	}
-
-	*ppsPMRPtr = psPMRPtr;
-	return eError;
-
-error_unref:
-	/* Undo the reference taken on the PMR in PhysmemImportDmaBuf */
-	PMRUnrefPMR(psPMRPtr);
-	return eError;
-}
-
 PVRSRV_ERROR
 PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
                           PVRSRV_DEVICE_NODE *psDevNode,
@@ -1000,10 +2020,23 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_BAD_MAPPING, errUnlockReturn);
 	}
 
-	if (psDmaBuf->ops == &sPVRDmaBufOps)
+	if (psDmaBuf->ops == &sPVRDmaBufOps || psDmaBuf->ops == &sPVRDmaBufOpsGEM)
 	{
 		/* We exported this dma_buf, so we can just get its PMR. */
-		psPMR = psDmaBuf->priv;
+		if (psDmaBuf->ops == &sPVRDmaBufOps)
+		{
+			PMR_DMA_BUF_WRAPPER *psPMRWrapper = psDmaBuf->priv;
+
+			psPMR = psPMRWrapper->psPMR;
+		}
+		else
+		{
+			struct drm_gem_object *psObj = psDmaBuf->priv;
+			PMR_DMA_BUF_GEM_OBJ *psGEMObj = TO_PMR_DMA_BUF_GEM_OBJ(psObj);
+			PMR_DMA_BUF_WRAPPER *psPMRWrapper = psGEMObj->psPMRWrapper;
+
+			psPMR = psPMRWrapper->psPMR;
+		}
 
 		/* However, we can't import it if it belongs to a different device. */
 		if (PMR_DeviceNode(psPMR) != psDevNode)
@@ -1047,7 +2080,7 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 		}
 
 		*ppsPMRPtr = psPMR;
-		PMR_LogicalSize(psPMR, puiSize);
+		*puiSize = PMR_LogicalSize(psPMR);
 		*puiAlign = PAGE_SIZE;
 
 		PMRFactoryUnlock();
@@ -1065,51 +2098,30 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 	/* Do we want this to be a sparse PMR? */
 	if (ui32NumVirtChunks > 1)
 	{
-		IMG_UINT32 i;
-
 		/* Parameter validation */
-		if (psDmaBuf->size != (uiChunkSize * ui32NumPhysChunks) ||
-		    uiChunkSize != PAGE_SIZE ||
-		    ui32NumPhysChunks > ui32NumVirtChunks)
+		if (psDmaBuf->size < (uiChunkSize * ui32NumPhysChunks) ||
+		    uiChunkSize != PAGE_SIZE)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
 					"%s: Requesting sparse buffer: "
 					"uiChunkSize ("IMG_DEVMEM_SIZE_FMTSPEC") must be equal to "
 					"OS page size (%lu). uiChunkSize * ui32NumPhysChunks "
 					"("IMG_DEVMEM_SIZE_FMTSPEC") must"
-					" be equal to the buffer size ("IMG_SIZE_FMTSPEC"). "
-					"ui32NumPhysChunks (%u) must be lesser or equal to "
-					"ui32NumVirtChunks (%u)",
+					" not be greater than the buffer size ("IMG_SIZE_FMTSPEC").",
 					 __func__,
 					uiChunkSize,
 					PAGE_SIZE,
 					uiChunkSize * ui32NumPhysChunks,
-					psDmaBuf->size,
-					ui32NumPhysChunks,
-					ui32NumVirtChunks));
+					psDmaBuf->size));
 			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS,
 			                    errUnlockAndDMAPut);
 		}
-
-		/* Parameter validation - Mapping table entries*/
-		for (i = 0; i < ui32NumPhysChunks; i++)
-		{
-			if (pui32MappingTable[i] > ui32NumVirtChunks)
-			{
-				PVR_DPF((PVR_DBG_ERROR, "%s: Requesting sparse buffer: "
-				        "Entry in mapping table (%u) is out of allocation "
-				        "bounds (%u)", __func__,
-				        (IMG_UINT32) pui32MappingTable[i],
-				        (IMG_UINT32) ui32NumVirtChunks));
-				PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS,
-				                    errUnlockAndDMAPut);
-			}
-		}
 	}
 	else
 	{
-		/* if ui32NumPhysChunks == 0 pui32MappingTable is NULL and because
-		 * is ui32NumPhysChunks is set to 1 below we don't allow NULL array */
+		/* if ui32NumPhysChunks == 0 then pui32MappingTable == NULL
+		 * this is handled by the generated bridge code.
+		 * Because ui32NumPhysChunks is set to 1 below, we don't allow NULL array */
 		if (pui32MappingTable == NULL)
 		{
 			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS,
@@ -1122,6 +2134,18 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 		ui32NumVirtChunks = 1;
 	}
 
+	{
+		IMG_DEVMEM_SIZE_T uiSize = ui32NumVirtChunks * uiChunkSize;
+		IMG_UINT32 uiLog2PageSize = PAGE_SHIFT; /* log2(uiChunkSize) */
+		eError = PhysMemValidateParams(psDevNode,
+		                               ui32NumPhysChunks,
+		                               ui32NumVirtChunks,
+		                               pui32MappingTable,
+		                               uiFlags,
+		                               &uiLog2PageSize,
+		                               &uiSize);
+		PVR_LOG_GOTO_IF_ERROR(eError, "PhysMemValidateParams", errUnlockAndDMAPut);
+	}
 
 	psAttachment = dma_buf_attach(psDmaBuf, psDevNode->psDevConfig->pvOSDevice);
 	if (IS_ERR_OR_NULL(psAttachment))
@@ -1150,6 +2174,10 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 	                                         &psPMR);
 	PVR_GOTO_IF_ERROR(eError, errDMADetach);
 
+	/* The imported memory is assumed to be backed by a permanent allocation. */
+	/* PMRLockSysPhysAddresses(psPMR) is redundant.
+	 * See PMRLockPhysAddressesDmaBuf */
+
 	/* First time we've seen this dmabuf so store it in the hash table */
 	HASH_Insert(g_psDmaBufHash, (uintptr_t) psDmaBuf, (uintptr_t) psPMR);
 	g_ui32HashRefCount++;
@@ -1186,112 +2214,3 @@ PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
 	PVR_ASSERT(eError != PVRSRV_OK);
 	return eError;
 }
-
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0) || defined(SUPPORT_ION) */
-
-PVRSRV_ERROR
-PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
-                                struct dma_buf_attachment *psAttachment,
-                                PFN_DESTROY_DMABUF_PMR pfnDestroy,
-                                PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                                IMG_DEVMEM_SIZE_T uiChunkSize,
-                                IMG_UINT32 ui32NumPhysChunks,
-                                IMG_UINT32 ui32NumVirtChunks,
-                                IMG_UINT32 *pui32MappingTable,
-                                IMG_UINT32 ui32NameSize,
-                                const IMG_CHAR pszName[DEVMEM_ANNOTATION_MAX_LEN],
-                                PMR **ppsPMRPtr)
-{
-	PVR_UNREFERENCED_PARAMETER(psHeap);
-	PVR_UNREFERENCED_PARAMETER(psAttachment);
-	PVR_UNREFERENCED_PARAMETER(pfnDestroy);
-	PVR_UNREFERENCED_PARAMETER(uiFlags);
-	PVR_UNREFERENCED_PARAMETER(uiChunkSize);
-	PVR_UNREFERENCED_PARAMETER(ui32NumPhysChunks);
-	PVR_UNREFERENCED_PARAMETER(ui32NumVirtChunks);
-	PVR_UNREFERENCED_PARAMETER(pui32MappingTable);
-	PVR_UNREFERENCED_PARAMETER(ui32NameSize);
-	PVR_UNREFERENCED_PARAMETER(pszName);
-	PVR_UNREFERENCED_PARAMETER(ppsPMRPtr);
-
-	return PVRSRV_ERROR_NOT_SUPPORTED;
-}
-
-struct dma_buf *
-PhysmemGetDmaBuf(PMR *psPMR)
-{
-	PVR_UNREFERENCED_PARAMETER(psPMR);
-
-	return NULL;
-}
-
-PVRSRV_ERROR
-PhysmemExportDmaBuf(CONNECTION_DATA *psConnection,
-                    PVRSRV_DEVICE_NODE *psDevNode,
-                    PMR *psPMR,
-                    IMG_INT *piFd)
-{
-	PVR_UNREFERENCED_PARAMETER(psConnection);
-	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	PVR_UNREFERENCED_PARAMETER(psPMR);
-	PVR_UNREFERENCED_PARAMETER(piFd);
-
-	return PVRSRV_ERROR_NOT_SUPPORTED;
-}
-
-PVRSRV_ERROR
-PhysmemImportDmaBuf(CONNECTION_DATA *psConnection,
-                    PVRSRV_DEVICE_NODE *psDevNode,
-                    IMG_INT fd,
-                    PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                    IMG_UINT32 ui32NameSize,
-                    const IMG_CHAR pszName[DEVMEM_ANNOTATION_MAX_LEN],
-                    PMR **ppsPMRPtr,
-                    IMG_DEVMEM_SIZE_T *puiSize,
-                    IMG_DEVMEM_ALIGN_T *puiAlign)
-{
-	PVR_UNREFERENCED_PARAMETER(psConnection);
-	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	PVR_UNREFERENCED_PARAMETER(fd);
-	PVR_UNREFERENCED_PARAMETER(uiFlags);
-	PVR_UNREFERENCED_PARAMETER(ui32NameSize);
-	PVR_UNREFERENCED_PARAMETER(pszName);
-	PVR_UNREFERENCED_PARAMETER(ppsPMRPtr);
-	PVR_UNREFERENCED_PARAMETER(puiSize);
-	PVR_UNREFERENCED_PARAMETER(puiAlign);
-
-	return PVRSRV_ERROR_NOT_SUPPORTED;
-}
-
-PVRSRV_ERROR
-PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
-                          PVRSRV_DEVICE_NODE *psDevNode,
-                          IMG_INT fd,
-                          PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                          IMG_DEVMEM_SIZE_T uiChunkSize,
-                          IMG_UINT32 ui32NumPhysChunks,
-                          IMG_UINT32 ui32NumVirtChunks,
-                          IMG_UINT32 *pui32MappingTable,
-                          IMG_UINT32 ui32NameSize,
-                          const IMG_CHAR pszName[DEVMEM_ANNOTATION_MAX_LEN],
-                          PMR **ppsPMRPtr,
-                          IMG_DEVMEM_SIZE_T *puiSize,
-                          IMG_DEVMEM_ALIGN_T *puiAlign)
-{
-	PVR_UNREFERENCED_PARAMETER(psConnection);
-	PVR_UNREFERENCED_PARAMETER(psDevNode);
-	PVR_UNREFERENCED_PARAMETER(fd);
-	PVR_UNREFERENCED_PARAMETER(uiFlags);
-	PVR_UNREFERENCED_PARAMETER(ppsPMRPtr);
-	PVR_UNREFERENCED_PARAMETER(puiSize);
-	PVR_UNREFERENCED_PARAMETER(puiAlign);
-	PVR_UNREFERENCED_PARAMETER(uiChunkSize);
-	PVR_UNREFERENCED_PARAMETER(ui32NumPhysChunks);
-	PVR_UNREFERENCED_PARAMETER(ui32NumVirtChunks);
-	PVR_UNREFERENCED_PARAMETER(pui32MappingTable);
-	PVR_UNREFERENCED_PARAMETER(ui32NameSize);
-	PVR_UNREFERENCED_PARAMETER(pszName);
-
-	return PVRSRV_ERROR_NOT_SUPPORTED;
-}
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0) || defined(SUPPORT_ION) || defined(KERNEL_HAS_DMABUF_VMAP_MMAP) */
diff --git a/drivers/gpu/drm/img-rogue/physmem_dmabuf.h b/drivers/gpu/drm/img-rogue/physmem_dmabuf.h
index c36cdecf5c21..ccb8c087eac6 100644
--- a/drivers/gpu/drm/img-rogue/physmem_dmabuf.h
+++ b/drivers/gpu/drm/img-rogue/physmem_dmabuf.h
@@ -47,6 +47,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include <linux/dma-buf.h>
 
+#include "pvr_dma_resv.h"
+
 #if defined(__KERNEL__) && defined(__linux__) && !defined(__GENKSYMS__)
 #define __pvrsrv_defined_struct_enum__
 #include <services_kernel_client.h>
@@ -78,12 +80,21 @@ PhysmemCreateNewDmaBufBackedPMR(PHYS_HEAP *psHeap,
 struct dma_buf *
 PhysmemGetDmaBuf(PMR *psPMR);
 
+struct dma_resv *
+PhysmemGetDmaResv(PMR *psPMR);
+
 PVRSRV_ERROR
 PhysmemExportDmaBuf(CONNECTION_DATA *psConnection,
                     PVRSRV_DEVICE_NODE *psDevNode,
                     PMR *psPMR,
                     IMG_INT *piFd);
 
+PVRSRV_ERROR
+PhysmemExportGemHandle(CONNECTION_DATA *psConnection,
+		       PVRSRV_DEVICE_NODE *psDevNode,
+		       PMR *psPMR,
+		       IMG_UINT32 *puHandle);
+
 PVRSRV_ERROR
 PhysmemImportDmaBuf(CONNECTION_DATA *psConnection,
                     PVRSRV_DEVICE_NODE *psDevNode,
@@ -95,17 +106,6 @@ PhysmemImportDmaBuf(CONNECTION_DATA *psConnection,
                     IMG_DEVMEM_SIZE_T *puiSize,
                     IMG_DEVMEM_ALIGN_T *puiAlign);
 
-PVRSRV_ERROR
-PhysmemImportDmaBufLocked(CONNECTION_DATA *psConnection,
-                          PVRSRV_DEVICE_NODE *psDevNode,
-                          IMG_INT fd,
-                          PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                          IMG_UINT32 ui32NameSize,
-                          const IMG_CHAR pszName[DEVMEM_ANNOTATION_MAX_LEN],
-                          PMR **ppsPMRPtr,
-                          IMG_DEVMEM_SIZE_T *puiSize,
-                          IMG_DEVMEM_ALIGN_T *puiAlign);
-
 PVRSRV_ERROR
 PhysmemImportSparseDmaBuf(CONNECTION_DATA *psConnection,
                           PVRSRV_DEVICE_NODE *psDevNode,
diff --git a/drivers/gpu/drm/img-rogue/physmem_dmabuf_internal.h b/drivers/gpu/drm/img-rogue/physmem_dmabuf_internal.h
new file mode 100644
index 000000000000..50a8ab37f442
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/physmem_dmabuf_internal.h
@@ -0,0 +1,69 @@
+/**************************************************************************/ /*!
+@File           physmem_dmabuf_internal.h
+@Title          Internal header for dmabuf PMR factory
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Part of the memory management. This module is responsible for
+                implementing the function callbacks importing Ion allocations
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /***************************************************************************/
+
+#if !defined(PHYSMEM_DMABUF_INTERNAL_H)
+#define PHYSMEM_DMABUF_INTERNAL_H
+
+#include <linux/version.h>
+
+struct dma_buf;
+struct drm_device;
+struct drm_gem_object;
+
+struct dma_buf *
+PhysmemGEMPrimeExport(
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+			struct drm_device *psDev,
+#endif
+
+			struct drm_gem_object *psObj,
+			int iFlags);
+
+void
+PhysmemGEMObjectFree(struct drm_gem_object *psObj);
+
+void
+PhysmemDmaBufExportFinalize(void *pvDmaBufExportData);
+
+#endif /* !defined(PHYSMEM_DMABUF_INTERNAL_H) */
diff --git a/drivers/gpu/drm/img-rogue/physmem_extmem.c b/drivers/gpu/drm/img-rogue/physmem_extmem.c
index 4ca2c56903c0..d365524f9a9c 100644
--- a/drivers/gpu/drm/img-rogue/physmem_extmem.c
+++ b/drivers/gpu/drm/img-rogue/physmem_extmem.c
@@ -46,12 +46,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv.h"
 #include "physmem_extmem.h"
 
-#if 0
+
 #if defined(LMA)
 #pragma message "WARNING! You are compiling SUPPORT_WRAP_EXTMEM on a platform with LMA. " \
 	"Make sure the memory you wrap is actually accessible by the GPU!"
 #endif
-#endif
 
 PVRSRV_ERROR
 PhysmemWrapExtMem(CONNECTION_DATA * psConnection,
diff --git a/drivers/gpu/drm/img-rogue/physmem_extmem_linux.c b/drivers/gpu/drm/img-rogue/physmem_extmem_linux.c
index c18acd751913..66265c266f22 100644
--- a/drivers/gpu/drm/img-rogue/physmem_extmem_linux.c
+++ b/drivers/gpu/drm/img-rogue/physmem_extmem_linux.c
@@ -71,6 +71,7 @@ static void _FreeWrapData(PMR_WRAP_DATA *psPrivData)
 {
 	OSFreeMem(psPrivData->ppsPageArray);
 	OSFreeMem(psPrivData->ppvPhysAddr);
+	psPrivData->psVMArea = NULL;
 	OSFreeMem(psPrivData);
 }
 
@@ -78,7 +79,7 @@ static void _FreeWrapData(PMR_WRAP_DATA *psPrivData)
 /* Allocate the PMR private data */
 static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
                             PVRSRV_DEVICE_NODE *psDevNode,
-                            IMG_DEVMEM_SIZE_T uiSize,
+                             IMG_DEVMEM_SIZE_T uiSize,
                             IMG_CPU_VIRTADDR pvCpuVAddr,
                             PVRSRV_MEMALLOCFLAGS_T uiFlags)
 {
@@ -87,6 +88,12 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 	struct vm_area_struct *psVMArea;
 	IMG_UINT32 ui32CPUCacheMode;
 
+	/* Obtain a reader lock on the process mmap lock while we are using
+	 * the psVMArea.
+	 */
+
+	mmap_read_lock(current->mm);
+
 	/* Find the VMA */
 	psVMArea = find_vma(current->mm, (uintptr_t)pvCpuVAddr);
 	if (psVMArea == NULL)
@@ -95,7 +102,8 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 				"%s: Couldn't find memory region containing start address %p",
 				__func__,
 				(void*) pvCpuVAddr));
-		return PVRSRV_ERROR_INVALID_CPU_ADDR;
+		eError = PVRSRV_ERROR_INVALID_CPU_ADDR;
+		goto eUnlockReturn;
 	}
 
 	/* If requested size is larger than actual allocation
@@ -108,7 +116,8 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 				"%s: End address %p is outside of the region returned by find_vma",
 				__func__,
 				(void*) (uintptr_t)((uintptr_t)pvCpuVAddr + uiSize)));
-		return PVRSRV_ERROR_BAD_PARAM_SIZE;
+		eError = PVRSRV_ERROR_BAD_PARAM_SIZE;
+		goto eUnlockReturn;
 	}
 
 	/* Find_vma locates a region with an end point past a given
@@ -119,27 +128,27 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 				"%s: Start address %p is outside of the region returned by find_vma",
 				__func__,
 				(void*) pvCpuVAddr));
-		return PVRSRV_ERROR_INVALID_CPU_ADDR;
+		eError = PVRSRV_ERROR_INVALID_CPU_ADDR;
+		goto eUnlockReturn;
 	}
 
-	eError = DevmemCPUCacheMode(psDevNode,
-	                            uiFlags,
-	                            &ui32CPUCacheMode);
+	eError = DevmemCPUCacheMode(uiFlags, &ui32CPUCacheMode);
 	if (eError != PVRSRV_OK)
 	{
-		return eError;
+		goto eUnlockReturn;
 	}
 
 	/* Allocate and initialise private factory data */
 	psPrivData = OSAllocZMem(sizeof(*psPrivData));
 	if (psPrivData == NULL)
 	{
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto eUnlockReturn;
 	}
 
 	psPrivData->ui32CPUCacheFlags = ui32CPUCacheMode;
 
-	/* Assign the VMA area structure if needed later */
+	/* Track the VMA area structure so that it can be checked later */
 	psPrivData->psVMArea = psVMArea;
 
 	psPrivData->psDevNode = psDevNode;
@@ -150,8 +159,8 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 	if (psPrivData == NULL)
 	{
 		OSFreeMem(psPrivData);
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
-
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto eUnlockReturn;
 	}
 
 	psPrivData->ppvPhysAddr = OSAllocZMem(sizeof(*(psPrivData->ppvPhysAddr)) * psPrivData->uiTotalNumPages);
@@ -159,7 +168,8 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 	{
 		OSFreeMem(psPrivData->ppsPageArray);
 		OSFreeMem(psPrivData);
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto eUnlockReturn;
 	}
 
 	if (uiFlags & (PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE |
@@ -170,7 +180,11 @@ static PVRSRV_ERROR _AllocWrapData(PMR_WRAP_DATA **ppsPrivData,
 
 	*ppsPrivData = psPrivData;
 
-	return PVRSRV_OK;
+	eError = PVRSRV_OK;
+eUnlockReturn:
+	mmap_read_unlock(current->mm);
+
+	return eError;
 }
 
 #if defined(SUPPORT_LINUX_WRAP_EXTMEM_PAGE_TABLE_WALK)
@@ -222,6 +236,7 @@ static PVRSRV_ERROR _TryGetUserPages(PVRSRV_DEVICE_NODE *psDevNode,
                                 PMR_WRAP_DATA *psPrivData)
 {
 	IMG_INT32 iMappedPages, i;
+
 	IMG_UINT64 ui64DmaMask = dma_get_mask(psDevNode->psDevConfig->pvOSDevice);
 
 	/* Do the actual call */
@@ -250,12 +265,13 @@ static PVRSRV_ERROR _TryGetUserPages(PVRSRV_DEVICE_NODE *psDevNode,
 			psPrivData->ppvPhysAddr[i].uiAddr = 0;
 		}
 
-		/* APOLLO test chips TCF5 or ES2 can only access 4G maximum memory from the card.
-		 * This is due to the 32 bit PCI card interface to the host
-		 * Hence pages with physical address beyond 4G range cannot be accessed by the device
-		 * An error is reported in such a case
+
+		/* Check the data transfer capability of the DMA.
 		 *
-		 * The same restriction may apply on to platforms as well*/
+		 * For instance:
+		 * APOLLO test chips TCF5 or ES2 can only access 4G maximum memory from the card.
+		 * Hence pages with a physical address beyond 4G range cannot be accessed by the
+		 * device. An error is reported in such a case. */
 		if (psPrivData->ppvPhysAddr[i].uiAddr & ~ui64DmaMask)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
@@ -361,7 +377,7 @@ PMRSysPhysAddrExtMem(PMR_IMPL_PRIVDATA pvPriv,
                      IMG_UINT32 ui32Log2PageSize,
                      IMG_UINT32 ui32NumOfPages,
                      IMG_DEVMEM_OFFSET_T *puiOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
                      IMG_UINT64 ui64IPAPolicyValue,
                      IMG_UINT64 ui64IPAClearMask,
 #endif
@@ -374,7 +390,7 @@ PMRSysPhysAddrExtMem(PMR_IMPL_PRIVDATA pvPriv,
 	IMG_UINT32 uiPageIndex;
 	IMG_UINT32 uiIdx;
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	PVR_UNREFERENCED_PARAMETER(ui64IPAPolicyValue);
 	PVR_UNREFERENCED_PARAMETER(ui64IPAClearMask);
 #endif
@@ -401,20 +417,18 @@ PMRSysPhysAddrExtMem(PMR_IMPL_PRIVDATA pvPriv,
 
 		PVR_ASSERT(uiInPageOffset < uiPageSize);
 
-		/* We always handle CPU physical addresses in this PMR factory
-		 * but this callback expects device physical addresses so we have to translate. */
-		PhysHeapCpuPAddrToDevPAddr(psWrapData->psDevNode->apsPhysHeap[PVRSRV_PHYS_HEAP_CPU_LOCAL],
-		                           1,
-		                           &psDevPAddr[uiIdx],
-		                           &psWrapData->ppvPhysAddr[uiPageIndex]);
+		/* The ExtMem is only enabled in UMA mode, in that mode, the device physical
+		 * address translation will be handled by the PRM factory after this call.
+		 * Here we just copy the physical address like other callback implementations. */
+		psDevPAddr[uiIdx].uiAddr = psWrapData->ppvPhysAddr[uiPageIndex].uiAddr;
 
 		pbValid[uiIdx] = (psDevPAddr[uiIdx].uiAddr)? IMG_TRUE:IMG_FALSE;
 
 		psDevPAddr[uiIdx].uiAddr += uiInPageOffset;
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 		psDevPAddr[uiIdx].uiAddr &= ~ui64IPAClearMask;
 		psDevPAddr[uiIdx].uiAddr |= ui64IPAPolicyValue;
-#endif	/* PVRSRV_SUPPORT_IPA_FEATURE */
+#endif	/* SUPPORT_STATIC_IPA */
 	}
 
 	return PVRSRV_OK;
@@ -710,7 +724,7 @@ static inline void begin_user_mode_access(IMG_UINT *uiState)
 #elif defined(CONFIG_ARM64) && defined(CONFIG_ARM64_SW_TTBR0_PAN)
 	PVR_UNREFERENCED_PARAMETER(uiState);
 	uaccess_enable_privileged();
-#elif defined(CONFIG_X86) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,168))
+#elif defined(CONFIG_X86)
 	PVR_UNREFERENCED_PARAMETER(uiState);
 	__uaccess_begin();
 #else
@@ -726,7 +740,7 @@ static inline void end_user_mode_access(IMG_UINT uiState)
 #elif defined(CONFIG_ARM64) && defined(CONFIG_ARM64_SW_TTBR0_PAN)
 	PVR_UNREFERENCED_PARAMETER(uiState);
 	uaccess_disable_privileged();
-#elif defined(CONFIG_X86) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,168))
+#elif defined(CONFIG_X86)
 	PVR_UNREFERENCED_PARAMETER(uiState);
 	__uaccess_end();
 #else
@@ -745,8 +759,19 @@ static PVRSRV_ERROR _FlushUMVirtualRange(PVRSRV_DEVICE_NODE *psDevNode,
 
 	mmap_read_lock(current->mm);
 
-	/* Check the addr space is not torn down in the mean time */
-	psVMArea = psPrivData->psVMArea;
+	/* Check that the recorded psVMArea matches the one associated with
+	 * this request. If not, fail the request.
+	 */
+	psVMArea = find_vma(current->mm, (uintptr_t)pvCpuVAddr);
+	if ((psVMArea != psPrivData->psVMArea) || (psVMArea == NULL))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Couldn't find memory region containing start address %p",
+		         __func__, (void *)pvCpuVAddr));
+		eError = PVRSRV_ERROR_INVALID_CPU_ADDR;
+		goto UMFlushUnlockReturn;
+	}
+
 
 	/*
 	 * Latest kernels enable "Privileged access never" feature in the kernel
@@ -761,16 +786,70 @@ static PVRSRV_ERROR _FlushUMVirtualRange(PVRSRV_DEVICE_NODE *psDevNode,
 	 * */
 	begin_user_mode_access(&uiUserAccessState);
 	{
-#if defined(CONFIG_X86) || defined(CONFIG_MIPS) || defined(CONFIG_METAG)
+		if (OSCPUCacheOpAddressType(psDevNode) == OS_CACHE_OP_ADDR_TYPE_VIRTUAL)
+		{
+			IMG_CPU_PHYADDR sCPUPhysStart = {0};
+
+			eError = CacheOpExec(psDevNode,
+								pvCpuVAddr,
+								((IMG_UINT8 *)pvCpuVAddr + uiSize),
+								sCPUPhysStart,
+								sCPUPhysStart,
+								PVRSRV_CACHE_OP_FLUSH);
+		}
+		else if (OSCPUCacheOpAddressType(psDevNode) == OS_CACHE_OP_ADDR_TYPE_PHYSICAL)
+		{
+			IMG_CPU_PHYADDR sCPUPhysStart, sCPUPhysEnd;
+			IMG_UINT i = 0;
 
-		IMG_CPU_PHYADDR sCPUPhysStart = {0};
+			for (i = 0; i < psPrivData->uiTotalNumPages; i++)
+			{
+				if (NULL != psPrivData->ppsPageArray[i])
+				{
+					sCPUPhysStart.uiAddr = psPrivData->ppvPhysAddr[i].uiAddr;
+					sCPUPhysEnd.uiAddr = sCPUPhysStart.uiAddr + PAGE_SIZE;
+
+					eError = CacheOpExec(psDevNode,
+										NULL,
+										NULL,
+										sCPUPhysStart,
+										sCPUPhysEnd,
+										PVRSRV_CACHE_OP_FLUSH);
+					if (eError != PVRSRV_OK)
+					{
+						break;
+					}
+				}
+			}
+		}
+		else if (OSCPUCacheOpAddressType(psDevNode) == OS_CACHE_OP_ADDR_TYPE_BOTH)
+		{
+			IMG_CPU_PHYADDR sCPUPhysStart, sCPUPhysEnd;
+			void *pvVirtStart, *pvVirtEnd;
+			IMG_UINT i = 0;
 
-		eError = CacheOpExec (psDevNode,
-		                      pvCpuVAddr,
-		                      ((IMG_UINT8 *)pvCpuVAddr + uiSize),
-		                      sCPUPhysStart,
-		                      sCPUPhysStart,
-		                      PVRSRV_CACHE_OP_CLEAN);
+			for (i = 0; i < psPrivData->uiTotalNumPages; i++)
+			{
+				if (NULL != psPrivData->ppsPageArray[i])
+				{
+					pvVirtStart = pvCpuVAddr + (i * PAGE_SIZE);
+					pvVirtEnd = pvVirtStart + PAGE_SIZE;
+					sCPUPhysStart.uiAddr = psPrivData->ppvPhysAddr[i].uiAddr;
+					sCPUPhysEnd.uiAddr = sCPUPhysStart.uiAddr + PAGE_SIZE;
+
+					eError = CacheOpExec(psDevNode,
+										pvVirtStart,
+										pvVirtEnd,
+										sCPUPhysStart,
+										sCPUPhysEnd,
+										PVRSRV_CACHE_OP_FLUSH);
+					if (eError != PVRSRV_OK)
+					{
+						break;
+					}
+				}
+			}
+		}
 
 		if (PVRSRV_OK != eError)
 		{
@@ -780,44 +859,12 @@ static PVRSRV_ERROR _FlushUMVirtualRange(PVRSRV_DEVICE_NODE *psDevNode,
 					pvCpuVAddr));
 			goto UMFlushFailed;
 		}
-#else
-		IMG_CPU_PHYADDR sCPUPhysStart, sCPUPhysEnd;
-		void *pvVirtStart, *pvVirtEnd;
-		IMG_UINT	i = 0;
-
-		for (i = 0; i < psPrivData->uiTotalNumPages; i++)
-		{
-			if (NULL != psPrivData->ppsPageArray[i])
-			{
-				pvVirtStart = pvCpuVAddr + (i * PAGE_SIZE);
-				pvVirtEnd = pvVirtStart + PAGE_SIZE;
-
-				sCPUPhysStart.uiAddr = psPrivData->ppvPhysAddr[i].uiAddr;
-				sCPUPhysEnd.uiAddr = sCPUPhysStart.uiAddr + PAGE_SIZE;
-
-				eError = CacheOpExec (psDevNode,
-				                      pvVirtStart,
-				                      pvVirtEnd,
-				                      sCPUPhysStart,
-				                      sCPUPhysEnd,
-				                      PVRSRV_CACHE_OP_CLEAN);
-
-				if (PVRSRV_OK != eError)
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							"%s: Failed to clean the virtual region cache %p",
-							__func__,
-							pvCpuVAddr));
-					goto UMFlushFailed;
-				}
-			}
-		}
-#endif
 	}
 
 UMFlushFailed:
 	end_user_mode_access(uiUserAccessState);
 
+UMFlushUnlockReturn:
 	mmap_read_unlock(current->mm);
 	return eError;
 }
@@ -831,7 +878,6 @@ static PMR_IMPL_FUNCTAB _sPMRWrapPFuncTab = {
     .pfnReadBytes = PMRReadBytesExtMem,
     .pfnWriteBytes = PMRWriteBytesExtMem,
     .pfnChangeSparseMem = NULL,
-    .pfnChangeSparseMemCPUMap = NULL,
     .pfnFinalize = &PMRFinalizeExtMem,
 };
 
diff --git a/drivers/gpu/drm/img-rogue/physmem_extmem_wrap.h b/drivers/gpu/drm/img-rogue/physmem_extmem_wrap.h
index 5e0480efef50..015360736d03 100644
--- a/drivers/gpu/drm/img-rogue/physmem_extmem_wrap.h
+++ b/drivers/gpu/drm/img-rogue/physmem_extmem_wrap.h
@@ -86,7 +86,7 @@ typedef struct _PMR_WRAP_DATA_
 	 * for pfn mappings this stays empty */
 	struct page **ppsPageArray;
 
-	/* VM Area structure */
+	/* VM Area structure reference */
 	struct vm_area_struct *psVMArea;
 
 	/* This should always be filled and hold the physical addresses */
diff --git a/drivers/gpu/drm/img-rogue/physmem_hostmem.c b/drivers/gpu/drm/img-rogue/physmem_hostmem.c
index 3b8cd6b5f4b8..9b1bbe850b9f 100644
--- a/drivers/gpu/drm/img-rogue/physmem_hostmem.c
+++ b/drivers/gpu/drm/img-rogue/physmem_hostmem.c
@@ -78,15 +78,12 @@ static PVRSRV_DEVICE_CONFIG gsHostMemDevConfig[];
 static PHYS_HEAP_CONFIG gsPhysHeapConfigHostMemDevice[] =
 {
 	{
-		PHYS_HEAP_TYPE_UMA,
-		"SYSMEM",
-		&gsHostMemDevPhysHeapFuncs,
-		{0},
-		{0},
-		0,
-		"uma_cpu_local",
-		(IMG_HANDLE)&gsHostMemDevConfig[0],
-		PHYS_HEAP_USAGE_CPU_LOCAL,
+		.eType = PHYS_HEAP_TYPE_UMA,
+		.ui32UsageFlags = PHYS_HEAP_USAGE_CPU_LOCAL,
+		.uConfig.sUMA.pszPDumpMemspaceName = "SYSMEM",
+		.uConfig.sUMA.psMemFuncs = &gsHostMemDevPhysHeapFuncs,
+		.uConfig.sUMA.pszHeapName = "uma_cpu_local",
+		.uConfig.sUMA.hPrivData = (IMG_HANDLE)&gsHostMemDevConfig[0]
 	}
 };
 
@@ -107,7 +104,6 @@ static void HostMemCpuPAddrToDevPAddr(IMG_HANDLE hPrivData,
                                       IMG_CPU_PHYADDR *psCpuPAddr)
 {
 	PVR_UNREFERENCED_PARAMETER(hPrivData);
-
 	/* Optimise common case */
 	psDevPAddr[0].uiAddr = phys_cpu2gpu(psCpuPAddr[0].uiAddr);
 	if (ui32NumOfAddr > 1)
@@ -126,7 +122,6 @@ static void HostMemDevPAddrToCpuPAddr(IMG_HANDLE hPrivData,
                                       IMG_DEV_PHYADDR *psDevPAddr)
 {
 	PVR_UNREFERENCED_PARAMETER(hPrivData);
-
 	/* Optimise common case */
 	psCpuPAddr[0].uiAddr = phys_gpu2cpu(psDevPAddr[0].uiAddr);
 	if (ui32NumOfAddr > 1)
@@ -156,7 +151,7 @@ PVRSRV_ERROR HostMemDeviceCreate(PVRSRV_DEVICE_NODE **ppsDeviceNode)
 	/* N.B.- In case of any failures in this function, we just return error to
 	   the caller, as clean-up is taken care by _HostMemDeviceDestroy function */
 
-	psDeviceNode = OSAllocZMem(sizeof(*psDeviceNode));
+	psDeviceNode = OSAllocZMem(sizeof(*psDeviceNode) + sizeof(*psDeviceNode->psMMUDevAttrs));
 	PVR_LOG_RETURN_IF_NOMEM(psDeviceNode, "OSAllocZMem");
 
 	/* early save return pointer to aid clean-up */
@@ -167,22 +162,34 @@ PVRSRV_ERROR HostMemDeviceCreate(PVRSRV_DEVICE_NODE **ppsDeviceNode)
 	psDeviceNode->psPhysHeapList = NULL;
 
 	eError = OSLockCreate(&psDeviceNode->hPhysHeapLock);
-	PVR_LOG_RETURN_IF_ERROR(eError, "OSLockCreate");
+	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate", LockCreateErr);
 
 	eError = PhysHeapCreateHeapFromConfig(psDeviceNode,
 										  &psDevConfig->pasPhysHeaps[0],
 										  NULL);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PhysHeapCreateHeapFromConfig");
+	PVR_LOG_GOTO_IF_ERROR(eError, "PhysHeapCreateHeapFromConfig", PhysHeapCreateErr);
 
 	/* Only CPU local heap is valid on host-mem DevNode, so enable minimal callbacks */
 	eError = PhysHeapAcquireByID(PVRSRV_PHYS_HEAP_CPU_LOCAL,
 								 psDeviceNode,
 								 &psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_CPU_LOCAL]);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PhysHeapAcquire");
+	PVR_LOG_GOTO_IF_ERROR(eError, "PhysHeapAcquire", AcquirePhysHeapErr);
+
+	psDeviceNode->psMMUDevAttrs = (MMU_DEVICEATTRIBS*)(psDeviceNode + 1);
+	psDeviceNode->psMMUDevAttrs->ui32ValidPageSizeMask = OSGetPageSize();
 
 	dllist_init(&psDeviceNode->sCleanupThreadWorkList);
 
 	return PVRSRV_OK;
+
+AcquirePhysHeapErr:
+	PhysHeapDestroyDeviceHeaps(psDeviceNode);
+PhysHeapCreateErr:
+	OSLockDestroy(psDeviceNode->hPhysHeapLock);
+LockCreateErr:
+	OSFreeMem(psDeviceNode);
+
+	return eError;
 }
 
 void HostMemDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
diff --git a/drivers/gpu/drm/img-rogue/physmem_ima.h b/drivers/gpu/drm/img-rogue/physmem_ima.h
new file mode 100644
index 000000000000..4744dacacb31
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/physmem_ima.h
@@ -0,0 +1,77 @@
+/**************************************************************************/ /*!
+@File
+@Title          Header import memory allocator
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Part of memory management. This module is responsible for
+                implementing the function callbacks for local card memory when
+                used under a shared heap system.
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /***************************************************************************/
+
+#ifndef PHYSMEM_IMA_H
+#define PHYSMEM_IMA_H
+
+#include "img_types.h"
+#include "pvrsrv_error.h"
+#include "physheap.h"
+#include "physheap_config.h"
+#include "device.h"
+
+/*************************************************************************/ /*!
+@Function       PhysmemCreateHeapIMA
+@Description    Create and register new IMA heap with IMA specific details and
+                a DLM heap backing.
+@Input          psDevNode     Pointer to device node struct.
+@Input          uiPolicy      Heap allocation policy flags
+@Input          psConfig      Heap configuration.
+@Input          pszLabel      Debug identifier label
+@Input          psDLMHeap     DLM heap backing this LMA heap.
+@Input          uiLog2PMBSize Log 2 of PMB Size in bytes supported by DLM heap.
+@Output         ppsPhysHeap   Pointer to the created heap.
+@Return         PVRSRV_ERROR  PVRSRV_OK or error code
+*/ /**************************************************************************/
+PVRSRV_ERROR
+PhysmemCreateHeapIMA(PVRSRV_DEVICE_NODE *psDevNode,
+                     PHYS_HEAP_POLICY uiPolicy,
+                     PHYS_HEAP_CONFIG *psConfig,
+                     IMG_CHAR *pszLabel,
+                     PHYS_HEAP *psDLMHeap,
+                     IMG_UINT32 uiLog2PMBSize,
+                     PHYS_HEAP **ppsPhysHeap);
+
+#endif /* PHYSMEM_IMA_H_ */
diff --git a/drivers/gpu/drm/img-rogue/physmem_lma.c b/drivers/gpu/drm/img-rogue/physmem_lma.c
index ea1e3d1624a6..6a67f3673978 100644
--- a/drivers/gpu/drm/img-rogue/physmem_lma.c
+++ b/drivers/gpu/drm/img-rogue/physmem_lma.c
@@ -42,139 +42,22 @@ IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ /**************************************************************************/
 
-#include "img_types.h"
-#include "img_defs.h"
+#include "physmem_lma.h"
 #include "pvr_debug.h"
-#include "pvrsrv_error.h"
-#include "pvrsrv_memallocflags.h"
-#include "rgx_pdump_panics.h"
+#include "pvrsrv_memalloc_physheap.h"
+#include "physheap.h"
+#include "physheap_config.h"
 #include "allocmem.h"
+#include "ra.h"
+#include "device.h"
 #include "osfunc.h"
+#include "physmem_ramem.h"
 #include "pvrsrv.h"
-#include "devicemem_server_utils.h"
-#include "physmem_lma.h"
-#include "pdump_km.h"
-#include "pmr.h"
-#include "pmr_impl.h"
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#include "process_stats.h"
-#endif
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 #include "rgxutils.h"
 #endif
 
-#if defined(INTEGRITY_OS)
-#include "mm.h"
-#include "integrity_memobject.h"
-#endif
-
-/* Assert that the conversions between the RA base type and the device
- * physical address are safe.
- */
-static_assert(sizeof(IMG_DEV_PHYADDR) == sizeof(RA_BASE_T),
-              "Size IMG_DEV_PHYADDR != RA_BASE_T");
-
-/* Since 0x0 is a valid DevPAddr, we rely on max 64-bit value to be an invalid
- * page address */
-#define INVALID_PAGE_ADDR ~((IMG_UINT64)0x0)
-#define ZERO_PAGE_VALUE 0
-
-typedef struct _PMR_KERNEL_MAP_HANDLE_ {
-	void *vma;
-	void *pvKernelAddress;
-	/* uiSize has 2 uses:
-	 * In Physically contiguous case it is used to track size of the mapping
-	 * for free.
-	 * In Physically sparse case it is used to determine free path to use, single page
-	 * sparse mapping or multi page
-	 */
-	size_t uiSize;
-} PMR_KERNEL_MAPPING;
-
-typedef struct _PMR_LMALLOCARRAY_DATA_ {
-
-#define FLAG_ZERO              (0U)
-#define FLAG_POISON_ON_FREE    (1U)
-#define FLAG_POISON_ON_ALLOC   (2U)
-#define FLAG_ONDEMAND          (3U)
-#define FLAG_SPARSE            (4U)
-#define FLAG_PHYS_CONTIG       (5U)
-#define FLAG_ZOMBIE            (6U)
-
-	IMG_PID uiPid;
-
-	/*
-	 * N.B Chunks referenced in this struct commonly are
-	 * to OS page sized. But in reality it is dependent on
-	 * the uiLog2ChunkSize.
-	 * Chunks will always be one 1 << uiLog2ChunkSize in size.
-	 * */
-
-	/*
-	 * The number of chunks currently allocated in the PMR.
-	 */
-	IMG_INT32 iNumChunksAllocated;
-
-	/*
-	 * Total number of (Virtual) chunks supported by this PMR.
-	 */
-	IMG_UINT32 uiTotalNumChunks;
-
-	/* The number of chunks to next be allocated for the PMR.
-	 * This will initially be the number allocated at first alloc
-	 * but may be changed in later calls to change sparse.
-	 * It represents the number of chunks to next be allocated.
-	 * This is used to store this value because we have the ability to
-	 * defer allocation.
-	 */
-	IMG_UINT32 uiChunksToAlloc;
-
-	/*
-	 * Log2 representation of the chunksize.
-	 */
-	IMG_UINT32 uiLog2ChunkSize;
-
-	/* Physical heap and arena pointers for this allocation */
-	PHYS_HEAP* psPhysHeap;
-	RA_ARENA* psArena;
-	PVRSRV_MEMALLOCFLAGS_T uiAllocFlags;
-
-	/*
-	   Connection data for this requests' originating process. NULL for
-	   direct-bridge originating calls
-	 */
-	CONNECTION_DATA *psConnection;
-
-	/*
-	 * Allocation flags related to the pages:
-	 * Zero              - Should we Zero memory on alloc
-	 * Poison on free    - Should we Poison the memory on free.
-	 * Poison on alloc   - Should we Poison the memory on alloc.
-	 * On demand         - Is the allocation on Demand i.e Do we defer allocation to time of use.
-	 * Sparse            - Is the PMR sparse.
-	 * Phys Contig       - Is the alloc Physically contiguous
-	 * Zombie            - Is zombie
-	 * */
-	IMG_UINT32 ui32Flags;
-
-	RA_BASE_ARRAY_T aBaseArray; /* Array of RA Bases */
-
-} PMR_LMALLOCARRAY_DATA;
-
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION) && defined(__linux__)
-/* Global structure to manage GPU memory leak */
-static DEFINE_MUTEX(g_sLMALeakMutex);
-static IMG_UINT32 g_ui32LMALeakCounter = 0;
-#endif
-
-#if defined(PVRSRV_PHYSHEAP_DISABLE_OOM_DEMOTION)
-#define PHYSHEAP_DPF_LVL PVR_DBG_ERROR
-#else
-#define PHYSHEAP_DPF_LVL PVR_DBG_WARNING
-#endif
-
-
 typedef struct PHYSMEM_LMA_DATA_TAG {
 	RA_ARENA           *psRA;
 	IMG_CPU_PHYADDR    sStartAddr;
@@ -225,13 +108,7 @@ _GetSize(PHEAP_IMPL_DATA pvImplData,
 	return PVRSRV_OK;
 }
 
-static IMG_UINT32
-_GetPageShift(void)
-{
-	return PVRSRV_4K_PAGE_SIZE_ALIGNSHIFT;
-}
-
-static void PhysmemGetLocalRamMemStats(PHEAP_IMPL_DATA pvImplData,
+static void PhysmemGetRAMemRamMemStats(PHEAP_IMPL_DATA pvImplData,
 		 IMG_UINT64 *pui64TotalSize,
 		 IMG_UINT64 *pui64FreeSize)
 {
@@ -244,7 +121,6 @@ static void PhysmemGetLocalRamMemStats(PHEAP_IMPL_DATA pvImplData,
 	*pui64FreeSize = sRAUsageStats.ui64FreeArenaSize;
 }
 
-#if !defined(SUPPORT_GPUVIRT_VALIDATION)
 static PVRSRV_ERROR
 PhysmemGetArenaLMA(PHYS_HEAP *psPhysHeap,
 				   RA_ARENA **ppsArena)
@@ -257,7 +133,6 @@ PhysmemGetArenaLMA(PHYS_HEAP *psPhysHeap,
 
 	return PVRSRV_OK;
 }
-#endif
 
 static PVRSRV_ERROR
 _CreateArenas(PHEAP_IMPL_DATA pvImplData, IMG_CHAR *pszLabel, PHYS_HEAP_POLICY uiPolicy)
@@ -265,7 +140,7 @@ _CreateArenas(PHEAP_IMPL_DATA pvImplData, IMG_CHAR *pszLabel, PHYS_HEAP_POLICY u
 	PHYSMEM_LMA_DATA *psLMAData = (PHYSMEM_LMA_DATA*)pvImplData;
 
 	IMG_UINT32 ui32RAPolicy =
-	    ((uiPolicy & PHYS_HEAP_POLOCY_ALLOC_ALLOW_NONCONTIG_MASK) == PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG)
+	    ((uiPolicy & PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG_MASK) == PHYS_HEAP_POLICY_ALLOC_ALLOW_NONCONTIG)
 	    ? RA_POLICY_ALLOC_ALLOW_NONCONTIG : RA_POLICY_DEFAULT;
 
 	psLMAData->psRA = RA_Create_With_Span(pszLabel,
@@ -419,100 +294,6 @@ PVRSRV_ERROR LMA_HeapIteratorGetHeapStats(PHYS_HEAP_ITERATOR *psIter,
 	return PVRSRV_OK;
 }
 
-
-static PVRSRV_ERROR
-_LMA_DoPhyContigPagesAlloc(RA_ARENA *pArena,
-                           size_t uiSize,
-                           PG_HANDLE *psMemHandle,
-                           IMG_DEV_PHYADDR *psDevPAddr,
-                           IMG_PID uiPid)
-{
-	RA_BASE_T uiCardAddr = 0;
-	RA_LENGTH_T uiActualSize;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 ui32Log2NumPages;
-
-#if defined(DEBUG)
-#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	static IMG_UINT32	ui32MaxLog2NumPages = 7;	/* 128 pages => 512KB */
-#else
-	static IMG_UINT32	ui32MaxLog2NumPages = 4;	/*  16 pages =>  64KB */
-#endif
-#endif	/* defined(DEBUG) */
-
-	PVR_ASSERT(uiSize != 0);
-	ui32Log2NumPages = OSGetOrder(uiSize);
-	uiSize = (1 << ui32Log2NumPages) * OSGetPageSize();
-
-	eError = RA_Alloc(pArena,
-	                  uiSize,
-	                  RA_NO_IMPORT_MULTIPLIER,
-	                  0,                         /* No flags */
-	                  uiSize,
-	                  "LMA_PhyContigPagesAlloc",
-	                  &uiCardAddr,
-	                  &uiActualSize,
-	                  NULL);                     /* No private handle */
-
-	if (eError != PVRSRV_OK)
-	{
-		RA_USAGE_STATS sRAStats;
-		RA_Get_Usage_Stats(pArena, &sRAStats);
-
-		PVR_DPF((PVR_DBG_ERROR,
-				"Failed to Allocate size = 0x"IMG_SIZE_FMTSPECX", align = 0x"
-				IMG_SIZE_FMTSPECX" Arena Free Space 0x%"IMG_UINT64_FMTSPECX,
-				uiSize, uiSize,	sRAStats.ui64FreeArenaSize));
-		return eError;
-	}
-
-	PVR_ASSERT(uiSize == uiActualSize);
-
-	psMemHandle->u.ui64Handle = uiCardAddr;
-	psDevPAddr->uiAddr = (IMG_UINT64) uiCardAddr;
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsIncrMemAllocStatAndTrack(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
-	                                    uiSize,
-	                                    uiCardAddr,
-	                                    uiPid);
-#else
-	{
-		IMG_CPU_PHYADDR sCpuPAddr;
-		sCpuPAddr.uiAddr = psDevPAddr->uiAddr;
-
-		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
-									 NULL,
-									 sCpuPAddr,
-									 uiSize,
-									 uiPid
-									 DEBUG_MEMSTATS_VALUES);
-	}
-#endif
-#endif
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-	PVR_DPF((PVR_DBG_MESSAGE,
-	        "%s: (GPU Virtualisation) Allocated 0x" IMG_SIZE_FMTSPECX " at 0x%"
-	        IMG_UINT64_FMTSPECX ", Arena ID %u",
-	        __func__, uiSize, psDevPAddr->uiAddr, psMemHandle->uiOSid));
-#endif
-
-#if defined(DEBUG)
-	PVR_ASSERT((ui32Log2NumPages <= ui32MaxLog2NumPages));
-	if (ui32Log2NumPages > ui32MaxLog2NumPages)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-		        "%s: ui32MaxLog2NumPages = %u, increasing to %u", __func__,
-		        ui32MaxLog2NumPages, ui32Log2NumPages ));
-		ui32MaxLog2NumPages = ui32Log2NumPages;
-	}
-#endif	/* defined(DEBUG) */
-	psMemHandle->uiOrder = ui32Log2NumPages;
-
-	return eError;
-}
-
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 static PVRSRV_ERROR
 LMA_PhyContigPagesAllocGPV(PHYS_HEAP *psPhysHeap,
@@ -529,7 +310,7 @@ LMA_PhyContigPagesAllocGPV(PHYS_HEAP *psPhysHeap,
 
 	PVR_ASSERT(uiSize != 0);
 	ui32Log2NumPages = OSGetOrder(uiSize);
-	uiSize = (1 << ui32Log2NumPages) * OSGetPageSize();
+	uiSize = IMG_PAGES2BYTES64(OSGetPageSize(),ui32Log2NumPages);
 
 	PVR_ASSERT(ui32OSid < GPUVIRT_VALIDATION_NUM_OS);
 	if (ui32OSid >= GPUVIRT_VALIDATION_NUM_OS)
@@ -549,9 +330,9 @@ LMA_PhyContigPagesAllocGPV(PHYS_HEAP *psPhysHeap,
 
 	psMemHandle->uiOSid = ui32OSid;		/* For Free() use */
 
-	eError =  _LMA_DoPhyContigPagesAlloc(pArena, uiSize, psMemHandle,
+	eError =  RAMemDoPhyContigPagesAlloc(pArena, uiSize, psDevNode, psMemHandle,
 	                                     psDevPAddr, uiPid);
-	PVR_LOG_IF_ERROR(eError, "_LMA_DoPhyContigPagesAlloc");
+	PVR_LOG_IF_ERROR(eError, "RAMemDoPhyContigPagesAlloc");
 
 	return eError;
 }
@@ -559,10 +340,10 @@ LMA_PhyContigPagesAllocGPV(PHYS_HEAP *psPhysHeap,
 
 static PVRSRV_ERROR
 LMA_PhyContigPagesAlloc(PHYS_HEAP *psPhysHeap,
-                        size_t uiSize,
-                        PG_HANDLE *psMemHandle,
-                        IMG_DEV_PHYADDR *psDevPAddr,
-                        IMG_PID uiPid)
+                         size_t uiSize,
+                         PG_HANDLE *psMemHandle,
+                         IMG_DEV_PHYADDR *psDevPAddr,
+                         IMG_PID uiPid)
 {
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 	IMG_UINT32 ui32OSid = 0;
@@ -573,17 +354,18 @@ LMA_PhyContigPagesAlloc(PHYS_HEAP *psPhysHeap,
 
 	RA_ARENA *pArena;
 	IMG_UINT32 ui32Log2NumPages = 0;
+	PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPhysHeap);
 
 	eError = PhysmemGetArenaLMA(psPhysHeap, &pArena);
 	PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemGetArenaLMA");
 
 	PVR_ASSERT(uiSize != 0);
 	ui32Log2NumPages = OSGetOrder(uiSize);
-	uiSize = (1 << ui32Log2NumPages) * OSGetPageSize();
+	uiSize = IMG_PAGES2BYTES64(OSGetPageSize(),ui32Log2NumPages);
 
-	eError = _LMA_DoPhyContigPagesAlloc(pArena, uiSize, psMemHandle,
+	eError = RAMemDoPhyContigPagesAlloc(pArena, uiSize, psDevNode, psMemHandle,
 	                                    psDevPAddr, uiPid);
-	PVR_LOG_IF_ERROR(eError, "_LMA_DoPhyContigPagesAlloc");
+	PVR_LOG_IF_ERROR(eError, "RAMemDoPhyContigPagesAlloc");
 
 	return eError;
 #endif
@@ -591,12 +373,12 @@ LMA_PhyContigPagesAlloc(PHYS_HEAP *psPhysHeap,
 
 static void
 LMA_PhyContigPagesFree(PHYS_HEAP *psPhysHeap,
-					   PG_HANDLE *psMemHandle)
+                       PG_HANDLE *psMemHandle)
 {
-	RA_BASE_T uiCardAddr = (RA_BASE_T) psMemHandle->u.ui64Handle;
 	RA_ARENA	*pArena;
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
+	RA_BASE_T uiCardAddr = (RA_BASE_T) psMemHandle->u.ui64Handle;
 	PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPhysHeap);
 	IMG_UINT32	ui32OSid = psMemHandle->uiOSid;
 
@@ -630,90 +412,44 @@ LMA_PhyContigPagesFree(PHYS_HEAP *psPhysHeap,
 	PhysmemGetArenaLMA(psPhysHeap, &pArena);
 #endif
 
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsDecrMemAllocStatAndUntrack(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
-	                                      (IMG_UINT64)uiCardAddr);
-#else
-	PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
-									(IMG_UINT64)uiCardAddr,
-									OSGetCurrentClientProcessIDKM());
-#endif
-#endif
-
-	RA_Free(pArena, uiCardAddr);
-	psMemHandle->uiOrder = 0;
+	RAMemDoPhyContigPagesFree(pArena,
+	                          psMemHandle);
 }
 
 static PVRSRV_ERROR
-LMA_PhyContigPagesMap(PHYS_HEAP *psPhysHeap,
-                      PG_HANDLE *psMemHandle,
-                      size_t uiSize, IMG_DEV_PHYADDR *psDevPAddr,
-                      void **pvPtr)
-{
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_UINT32 ui32NumPages = (1 << psMemHandle->uiOrder);
-	PVR_UNREFERENCED_PARAMETER(uiSize);
-
-	PhysHeapDevPAddrToCpuPAddr(psPhysHeap, 1, &sCpuPAddr, psDevPAddr);
-	*pvPtr = OSMapPhysToLin(sCpuPAddr,
-							ui32NumPages * OSGetPageSize(),
-							PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC);
-	PVR_RETURN_IF_NOMEM(*pvPtr);
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
-	                            ui32NumPages * OSGetPageSize(),
-	                            OSGetCurrentClientProcessIDKM());
-#else
-	{
-		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
-									 *pvPtr,
-									 sCpuPAddr,
-									 ui32NumPages * OSGetPageSize(),
-									 OSGetCurrentClientProcessIDKM()
-									 DEBUG_MEMSTATS_VALUES);
-	}
-#endif
-#endif
-	return PVRSRV_OK;
-}
-
-static void
-LMA_PhyContigPagesUnmap(PHYS_HEAP *psPhysHeap,
-                        PG_HANDLE *psMemHandle,
-                        void *pvPtr)
+LMAPhysmemNewRAMemRamBackedPMR(PHYS_HEAP *psPhysHeap,
+                               CONNECTION_DATA *psConnection,
+                               IMG_DEVMEM_SIZE_T uiSize,
+                               IMG_UINT32 ui32NumPhysChunks,
+                               IMG_UINT32 ui32NumVirtChunks,
+                               IMG_UINT32 *pui32MappingTable,
+                               IMG_UINT32 uiLog2AllocPageSize,
+                               PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                               const IMG_CHAR *pszAnnotation,
+                               IMG_PID uiPid,
+                               PMR **ppsPMRPtr,
+                               IMG_UINT32 ui32PDumpFlags)
 {
-	IMG_UINT32 ui32NumPages = (1 << psMemHandle->uiOrder);
-	PVR_UNREFERENCED_PARAMETER(psPhysHeap);
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
-		                            ui32NumPages * OSGetPageSize(),
-		                            OSGetCurrentClientProcessIDKM());
-#else
-	PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
-	                                (IMG_UINT64)(uintptr_t)pvPtr,
-	                                OSGetCurrentClientProcessIDKM());
-#endif
-#endif
+	PVRSRV_ERROR eError;
+	RA_ARENA *pArena;
 
-	OSUnMapPhysToLin(pvPtr, ui32NumPages * OSGetPageSize());
-}
+	eError = PhysmemGetArenaLMA(psPhysHeap, &pArena);
+	PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemGetArenaLMA");
 
-static PVRSRV_ERROR
-LMA_PhyContigPagesClean(PHYS_HEAP *psPhysHeap,
-						PG_HANDLE *psMemHandle,
-						IMG_UINT32 uiOffset,
-						IMG_UINT32 uiLength)
-{
-	/* No need to flush because we map as uncached */
-	PVR_UNREFERENCED_PARAMETER(psPhysHeap);
-	PVR_UNREFERENCED_PARAMETER(psMemHandle);
-	PVR_UNREFERENCED_PARAMETER(uiOffset);
-	PVR_UNREFERENCED_PARAMETER(uiLength);
+	eError = PhysmemNewRAMemRamBackedPMR(psPhysHeap,
+	                                     pArena,
+	                                     psConnection,
+	                                     uiSize,
+	                                     ui32NumPhysChunks,
+	                                     ui32NumVirtChunks,
+	                                     pui32MappingTable,
+	                                     uiLog2AllocPageSize,
+	                                     uiFlags,
+	                                     pszAnnotation,
+	                                     uiPid,
+	                                     ppsPMRPtr,
+	                                     ui32PDumpFlags);
+	PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemNewLocalRamBackedPMR");
 
 	return PVRSRV_OK;
 }
@@ -724,17 +460,17 @@ static PHEAP_IMPL_FUNCS _sPHEAPImplFuncs =
 	.pfnGetDevPAddr = &_GetDevPAddr,
 	.pfnGetCPUPAddr = &_GetCPUPAddr,
 	.pfnGetSize = &_GetSize,
-	.pfnGetPageShift = &_GetPageShift,
-	.pfnGetPMRFactoryMemStats = &PhysmemGetLocalRamMemStats,
-	.pfnCreatePMR = &PhysmemNewLocalRamBackedPMR,
+	.pfnGetPageShift = &RAMemGetPageShift,
+	.pfnGetFactoryMemStats = &PhysmemGetRAMemRamMemStats,
+	.pfnCreatePMR = &LMAPhysmemNewRAMemRamBackedPMR,
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 	.pfnPagesAllocGPV = &LMA_PhyContigPagesAllocGPV,
 #endif
 	.pfnPagesAlloc = &LMA_PhyContigPagesAlloc,
 	.pfnPagesFree = &LMA_PhyContigPagesFree,
-	.pfnPagesMap = &LMA_PhyContigPagesMap,
-	.pfnPagesUnMap = &LMA_PhyContigPagesUnmap,
-	.pfnPagesClean = &LMA_PhyContigPagesClean,
+	.pfnPagesMap = &RAMemPhyContigPagesMap,
+	.pfnPagesUnMap = &RAMemPhyContigPagesUnmap,
+	.pfnPagesClean = &RAMemPhyContigPagesClean,
 };
 
 PVRSRV_ERROR
@@ -745,2190 +481,43 @@ PhysmemCreateHeapLMA(PVRSRV_DEVICE_NODE *psDevNode,
                      PHYS_HEAP **ppsPhysHeap)
 {
 	PHYSMEM_LMA_DATA *psLMAData;
+	PHYS_HEAP *psPhysHeap;
 	PVRSRV_ERROR eError;
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(pszLabel != NULL, "pszLabel");
 
+	PVR_ASSERT(psConfig->eType == PHYS_HEAP_TYPE_LMA ||
+	           psConfig->eType == PHYS_HEAP_TYPE_DMA);
+
 	psLMAData = OSAllocMem(sizeof(*psLMAData));
 	PVR_LOG_RETURN_IF_NOMEM(psLMAData, "OSAllocMem");
 
-	psLMAData->sStartAddr = psConfig->sStartAddr;
-	psLMAData->sCardBase = psConfig->sCardBase;
-	psLMAData->uiSize = psConfig->uiSize;
+	psLMAData->sStartAddr = PhysHeapConfigGetStartAddr(psConfig);
+	psLMAData->sCardBase = PhysHeapConfigGetCardBase(psConfig);
+	psLMAData->uiSize = PhysHeapConfigGetSize(psConfig);
 
 	eError = PhysHeapCreate(psDevNode,
 							psConfig,
 							uiPolicy,
 							(PHEAP_IMPL_DATA)psLMAData,
 							&_sPHEAPImplFuncs,
-							ppsPhysHeap);
-	if (eError != PVRSRV_OK)
-	{
-		OSFreeMem(psLMAData);
-		return eError;
-	}
+							&psPhysHeap);
+	PVR_LOG_GOTO_IF_ERROR(eError, "PhysHeapCreate", err_free_lma_data);
 
 	eError = _CreateArenas(psLMAData, pszLabel, uiPolicy);
-	PVR_LOG_RETURN_IF_ERROR(eError, "_CreateArenas");
-
-
-	return eError;
-}
-
-static PVRSRV_ERROR _MapPhysicalContigAlloc(PHYS_HEAP *psPhysHeap,
-                                            RA_BASE_ARRAY_T paBaseArray,
-                                            size_t uiSize,
-                                            PMR_FLAGS_T ulFlags,
-                                            PMR_KERNEL_MAPPING *psMapping)
-{
-	IMG_UINT32 ui32CPUCacheFlags;
-	PVRSRV_ERROR eError;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	sDevPAddr.uiAddr = RA_BASE_STRIP_GHOST_BIT(*paBaseArray);
-
-	eError = DevmemCPUCacheMode(PhysHeapDeviceNode(psPhysHeap), ulFlags, &ui32CPUCacheFlags);
-	PVR_RETURN_IF_ERROR(eError);
-
-	PhysHeapDevPAddrToCpuPAddr(psPhysHeap,
-	                           1,
-	                           &sCpuPAddr,
-	                           &sDevPAddr);
-
-	psMapping->pvKernelAddress = OSMapPhysToLin(sCpuPAddr, uiSize, ui32CPUCacheFlags);
-	PVR_LOG_RETURN_IF_FALSE(psMapping->pvKernelAddress,
-	                        "OSMapPhyToLin: out of VM Mem",
-	                        PVRSRV_ERROR_PMR_NO_KERNEL_MAPPING);
-	psMapping->vma = NULL;
-	psMapping->uiSize = uiSize;
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR _MapPhysicalSparseAlloc(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
-                                            RA_BASE_ARRAY_T paBaseArray,
-                                            size_t uiSize,
-                                            PMR_FLAGS_T ulFlags,
-                                            PMR_KERNEL_MAPPING *psMapping)
-{
-	IMG_UINT32 uiChunkCount = uiSize >> psLMAllocArrayData->uiLog2ChunkSize;
-	IMG_CPU_PHYADDR uiPages[PMR_MAX_TRANSLATION_STACK_ALLOC], *puiPages;
-	PVRSRV_ERROR eError;
-	size_t uiPageShift = OSGetPageShift();
-	IMG_UINT32 uiOSPageCnt = psLMAllocArrayData->uiLog2ChunkSize - uiPageShift;
-
-	if ((uiChunkCount << uiOSPageCnt) > PMR_MAX_TRANSLATION_STACK_ALLOC)
-	{
-		puiPages = OSAllocZMem(sizeof(IMG_CPU_PHYADDR) * (uiChunkCount << uiOSPageCnt));
-		PVR_RETURN_IF_NOMEM(puiPages);
-	}
-	else
-	{
-		puiPages = &uiPages[0];
-	}
-
-	if (uiOSPageCnt == 0)
-	{
-		IMG_UINT32 i;
-		PhysHeapDevPAddrToCpuPAddr(psLMAllocArrayData->psPhysHeap,
-								   uiChunkCount,
-								   puiPages,
-								   (IMG_DEV_PHYADDR *)paBaseArray);
-
-		/* If the ghost bit is present then the addrs returned will be off by 1
-		 * Strip the ghost bit to correct to real page aligned addresses.
-		 * */
-		for (i = 0; i < uiChunkCount; i++)
-		{
-			puiPages[i].uiAddr = RA_BASE_STRIP_GHOST_BIT(puiPages[i].uiAddr);
-		}
-	}
-	else
-	{
-		IMG_UINT32 i = 0, j = 0, index = 0;
-		for (i = 0; i < uiChunkCount; i++)
-		{
-			IMG_UINT32 ui32OSPagesPerDeviceChunk = (1 << uiOSPageCnt);
-			IMG_DEV_PHYADDR uiDevAddr;
-			uiDevAddr.uiAddr = RA_BASE_STRIP_GHOST_BIT(paBaseArray[i]);
-			for (j = 0; j < ui32OSPagesPerDeviceChunk; j++)
-			{
-				uiDevAddr.uiAddr += (1ULL << uiPageShift);
-				PhysHeapDevPAddrToCpuPAddr(psLMAllocArrayData->psPhysHeap,
-										   1,
-										   &puiPages[index],
-										   &uiDevAddr);
-				index++;
-			}
-		}
-	}
+	PVR_LOG_GOTO_IF_ERROR(eError, "_CreateArenas", err_free_physheap);
 
-	eError = OSMapPhysArrayToLin(puiPages,
-	                             uiChunkCount,
-	                             &psMapping->pvKernelAddress,
-	                             &psMapping->vma);
-	if (eError == PVRSRV_OK)
+	if (ppsPhysHeap != NULL)
 	{
-		psMapping->uiSize = uiSize;
+		*ppsPhysHeap = psPhysHeap;
 	}
 
-	if (puiPages != &uiPages[0])
-	{
-		OSFreeMem(puiPages);
-	}
-
-	return eError;
-}
-
-static PVRSRV_ERROR _MapPMRKernel(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
-                                  RA_BASE_ARRAY_T paBaseArray,
-                                  size_t uiSize,
-                                  PMR_FLAGS_T ulFlags,
-                                  PMR_KERNEL_MAPPING *psMapping)
-{
-	PVRSRV_ERROR eError;
-	PHYS_HEAP *psPhysHeap = psLMAllocArrayData->psPhysHeap;
-	if (!BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		/* Physically Contig */
-		if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-		{
-			eError = _MapPhysicalContigAlloc(psPhysHeap,
-			                                 paBaseArray,
-			                                 uiSize,
-			                                 ulFlags,
-			                                 psMapping);
-		}
-		/* Physically Sparse */
-		else
-		{
-			eError = _MapPhysicalSparseAlloc(psLMAllocArrayData,
-			                                 paBaseArray,
-			                                 uiSize,
-			                                 ulFlags,
-			                                 psMapping);
-		}
-	}
-	else
-	{
-		/* Sparse Alloc Single Chunk */
-		if (uiSize == (1 << psLMAllocArrayData->uiLog2ChunkSize))
-		{
-			eError = _MapPhysicalContigAlloc(psPhysHeap,
-			                                 paBaseArray,
-			                                 uiSize,
-			                                 ulFlags,
-			                                 psMapping);
-		}
-		/* Sparse Alloc Multi Chunk */
-		else
-		{
-			eError = _MapPhysicalSparseAlloc(psLMAllocArrayData,
-			                                 paBaseArray,
-			                                 uiSize,
-			                                 ulFlags,
-			                                 psMapping);
-		}
-	}
-
-	return eError;
-}
-
-static void _UnMapPhysicalContigAlloc(PMR_KERNEL_MAPPING *psKernelMapping)
-{
-	OSUnMapPhysToLin(psKernelMapping->pvKernelAddress, psKernelMapping->uiSize);
-}
-
-static void _UnMapPhysicalSparseAlloc(PMR_KERNEL_MAPPING *psKernelMapping)
-{
-	OSUnMapPhysArrayToLin(psKernelMapping->pvKernelAddress,
-	                   psKernelMapping->vma);
-}
-
-static void _UnMapPMRKernel(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
-                            PMR_KERNEL_MAPPING *psKernelMapping)
-{
-	if (!BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		/* Physically Contig */
-		if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-		{
-			_UnMapPhysicalContigAlloc(psKernelMapping);
-		}
-		/* Physically Sparse */
-		else
-		{
-			_UnMapPhysicalSparseAlloc(psKernelMapping);
-		}
-	}
-	else
-	{
-		/* Sparse Alloc Single Chunk */
-		if (psKernelMapping->uiSize == (1 << psLMAllocArrayData->uiLog2ChunkSize))
-		{
-			_UnMapPhysicalContigAlloc(psKernelMapping);
-		}
-		/* Sparse Alloc Multi Chunk */
-		else
-		{
-			_UnMapPhysicalSparseAlloc(psKernelMapping);
-		}
-	}
-}
-
-static PVRSRV_ERROR
-_PhysPgMemSet(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
-              RA_BASE_ARRAY_T paBaseArray,
-              size_t uiSize,
-              IMG_BYTE ui8SetValue)
-{
-	PVRSRV_ERROR eError;
-	PMR_KERNEL_MAPPING sKernelMapping;
-
-	eError = _MapPMRKernel(psLMAllocArrayData,
-	                       paBaseArray,
-	                       uiSize,
-	                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
-	                       &sKernelMapping);
-	PVR_GOTO_IF_ERROR(eError, map_failed);
-
-	OSCachedMemSetWMB(sKernelMapping.pvKernelAddress, ui8SetValue, uiSize);
-
-	_UnMapPMRKernel(psLMAllocArrayData, &sKernelMapping);
-
-	return PVRSRV_OK;
-
-map_failed:
-	PVR_DPF((PVR_DBG_ERROR, "Failed to poison/zero allocation"));
-	return eError;
-}
-
-static PVRSRV_ERROR
-_AllocLMPageArray(PMR_SIZE_T uiSize,
-                  IMG_UINT32 ui32NumPhysChunks,
-                  IMG_UINT32 ui32NumVirtChunks,
-                  IMG_UINT32 uiLog2AllocPageSize,
-                  IMG_UINT32 ui32Flags,
-                  PHYS_HEAP* psPhysHeap,
-                  PVRSRV_MEMALLOCFLAGS_T uiAllocFlags,
-                  IMG_PID uiPid,
-                  PMR_LMALLOCARRAY_DATA **ppsPageArrayDataPtr,
-                  CONNECTION_DATA *psConnection)
-{
-	PMR_LMALLOCARRAY_DATA *psPageArrayData = NULL;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 uiNumPages;
-
-	PVR_ASSERT(!BIT_ISSET(ui32Flags, FLAG_ZERO) || !BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC));
-	PVR_ASSERT(OSGetPageShift() <= uiLog2AllocPageSize);
-
-	/* Use of cast below is justified by the assertion that follows to
-	prove that no significant bits have been truncated */
-	uiNumPages = (IMG_UINT32)(((uiSize - 1) >> uiLog2AllocPageSize) + 1);
-	PVR_ASSERT(((PMR_SIZE_T)uiNumPages << uiLog2AllocPageSize) == uiSize);
-
-	psPageArrayData = OSAllocMem(sizeof(PMR_LMALLOCARRAY_DATA) + (sizeof(RA_BASE_T) * uiNumPages));
-	PVR_GOTO_IF_NOMEM(psPageArrayData, eError, errorOnAllocArray);
-
-	if (BIT_ISSET(ui32Flags, FLAG_SPARSE))
-	{
-		/* Since no pages are allocated yet, initialise page addresses to INVALID_PAGE_ADDR */
-		OSCachedMemSet(psPageArrayData->aBaseArray,
-					   0xFF,
-					   sizeof(RA_BASE_T) *
-					   uiNumPages);
-	}
-	else
-	{
-		/* Base pointers have been allocated for the full PMR in case we require a non
-		 * physically contiguous backing for the virtually contiguous allocation but the most
-		 * common case will be contiguous and so only require the first Base to be present
-		 */
-		psPageArrayData->aBaseArray[0] = INVALID_BASE_ADDR;
-	}
-
-	psPageArrayData->uiTotalNumChunks = uiNumPages;
-	psPageArrayData->uiChunksToAlloc = BIT_ISSET(ui32Flags, FLAG_SPARSE) ? ui32NumPhysChunks : uiNumPages;
-	psPageArrayData->uiLog2ChunkSize = uiLog2AllocPageSize;
-
-	psPageArrayData->psConnection = psConnection;
-	psPageArrayData->uiPid = uiPid;
-	psPageArrayData->iNumChunksAllocated = 0;
-	psPageArrayData->ui32Flags = ui32Flags;
-	psPageArrayData->psPhysHeap = psPhysHeap;
-	psPageArrayData->uiAllocFlags = uiAllocFlags;
-
-	*ppsPageArrayDataPtr = psPageArrayData;
-
-	return PVRSRV_OK;
-
-/*
-  error exit path follows:
-*/
-
-errorOnAllocArray:
-	PVR_ASSERT(eError != PVRSRV_OK);
-	return eError;
-}
-
-static PVRSRV_ERROR
-_AllocLMPagesContig(PMR_LMALLOCARRAY_DATA *psPageArrayData)
-{
-	PVRSRV_ERROR eError;
-	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
-	IMG_UINT64 uiPhysSize = (IMG_UINT64) psPageArrayData->uiChunksToAlloc << uiLog2ChunkSize;
-	IMG_BOOL bPhysContig;
-	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
-
-
-	eError = RA_AllocMulti(psPageArrayData->psArena,
-	                  uiPhysSize,
-	                  uiLog2ChunkSize,
-	                  RA_NO_IMPORT_MULTIPLIER,
-	                  0,                       /* No flags */
-	                  "LMA_Page_Alloc",
-	                  psPageArrayData->aBaseArray,
-	                  psPageArrayData->uiTotalNumChunks,
-	                  &bPhysContig);
-
-	if (PVRSRV_OK != eError)
-	{
-		RA_USAGE_STATS sRAStats;
-		IMG_CHAR *pszArenaName;
-		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
-		pszArenaName = RA_GetArenaName(psPageArrayData->psArena);
-
-		PVR_DPF((PHYSHEAP_DPF_LVL,
-				"Contig: Failed to Allocate size = 0x%llx, align = 0x%llx"
-				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
-				" Arena Name: '%s'",
-				(unsigned long long)uiPhysSize,
-				1ULL << uiLog2ChunkSize,
-				sRAStats.ui64FreeArenaSize,
-				pszArenaName));
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
-	}
-
-	if (bPhysContig)
-	{
-		BIT_SET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG);
-	}
-
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-{
-	PVR_DPF((PVR_DBG_MESSAGE,
-			"(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
-			psPageArrayData->aBaseArray[0]));
-}
-#endif
-
-	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC))
-	{
-		eError = _PhysPgMemSet(psPageArrayData,
-		                       psPageArrayData->aBaseArray,
-		                       uiPhysSize,
-		                       PVRSRV_POISON_ON_ALLOC_VALUE);
-		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoison);
-	}
-
-	if (BIT_ISSET(ui32Flags, FLAG_ZERO))
-	{
-		eError = _PhysPgMemSet(psPageArrayData,
-		                       psPageArrayData->aBaseArray,
-		                       uiPhysSize,
-		                       ZERO_PAGE_VALUE);
-		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnZero);
-	}
-
-	psPageArrayData->iNumChunksAllocated += psPageArrayData->uiChunksToAlloc;
-
-	/* We have alloc'd the previous request, set 0 for book keeping */
-	psPageArrayData->uiChunksToAlloc = 0;
-
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, uiPhysSize, psPageArrayData->uiPid);
-#else
-	if (bPhysContig)
-	{
-		IMG_CPU_PHYADDR sLocalCpuPAddr;
-		sLocalCpuPAddr.uiAddr = (IMG_UINT64) psPageArrayData->aBaseArray[0];
-		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-								 NULL,
-								 sLocalCpuPAddr,
-								 psPageArrayData->uiTotalNumChunks << uiLog2ChunkSize,
-								 psPageArrayData->uiPid
-								 DEBUG_MEMSTATS_VALUES);
-	}
-	else
-	{
-		IMG_UINT32 i, j;
-		IMG_CPU_PHYADDR sLocalCpuPAddr;
-
-		for (i = 0; i < psPageArrayData->uiTotalNumChunks;)
-		{
-			IMG_UINT32 ui32AllocSizeInChunks = 1;
-
-			for (j = i;
-			     j + 1 != psPageArrayData->uiTotalNumChunks &&
-			     RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
-			     j++)
-			{
-				ui32AllocSizeInChunks++;
-			}
-
-			sLocalCpuPAddr.uiAddr = (IMG_UINT64) psPageArrayData->aBaseArray[i];
-			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-									 NULL,
-									 sLocalCpuPAddr,
-									 ui32AllocSizeInChunks << uiLog2ChunkSize,
-									 psPageArrayData->uiPid
-									 DEBUG_MEMSTATS_VALUES);
-
-			i += ui32AllocSizeInChunks;
-		}
-	}
-#endif
-#endif
-
 	return PVRSRV_OK;
 
-	/*
-	  error exit paths follow:
-	*/
-errorOnZero:
-errorOnPoison:
-	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
-
-	RA_FreeMulti(psPageArrayData->psArena,
-	              psPageArrayData->aBaseArray,
-	              psPageArrayData->uiTotalNumChunks);
-
-errorOnRAAlloc:
-	PVR_ASSERT(eError != PVRSRV_OK);
+err_free_physheap:
+	PhysHeapDestroy(psPhysHeap);
+err_free_lma_data:
+	OSFreeMem(psLMAData);
 	return eError;
-}
-
-/*
- * Fully allocated variant of sparse allocation does not take in as argument an
- * array of indices. It is used in cases where the amount of chunks to allocate is
- * the same as the total the PMR can represent. I.E when we want to fully populate
- * a sparse PMR.
- */
-static PVRSRV_ERROR
-_AllocLMPagesSparseFull(PMR_LMALLOCARRAY_DATA *psPageArrayData)
-{
-	PVRSRV_ERROR eError;
-	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
-	IMG_UINT64 uiPhysSize = (IMG_UINT64) psPageArrayData->uiChunksToAlloc << uiLog2ChunkSize;
-	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
-
-
-	eError = RA_AllocMultiSparse(psPageArrayData->psArena,
-	                  uiLog2ChunkSize,
-	                  RA_NO_IMPORT_MULTIPLIER,
-	                  0,                       /* No flags */
-	                  "LMA_Page_Alloc",
-	                  psPageArrayData->aBaseArray,
-	                  psPageArrayData->uiTotalNumChunks,
-	                  NULL, /* No indices given meaning allocate full base array using chunk count below */
-	                  psPageArrayData->uiChunksToAlloc);
-	if (PVRSRV_OK != eError)
-	{
-		RA_USAGE_STATS sRAStats;
-		IMG_CHAR *pszArenaName;
-		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
-		pszArenaName = RA_GetArenaName(psPageArrayData->psArena);
-
-		PVR_DPF((PHYSHEAP_DPF_LVL,
-				"SparseFull: Failed to Allocate size = 0x%llx, align = 0x%llx"
-				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
-				" Arena Name: '%s'",
-				(unsigned long long)uiPhysSize,
-				1ULL << uiLog2ChunkSize,
-				sRAStats.ui64FreeArenaSize,
-				pszArenaName));
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
-	}
-
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-{
-	PVR_DPF((PVR_DBG_MESSAGE,
-		"(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
-		psPageArrayData->aBaseArray[0]));
-}
-#endif
-
-	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC))
-	{
-		eError = _PhysPgMemSet(psPageArrayData,
-		                       psPageArrayData->aBaseArray,
-		                       uiPhysSize,
-		                       PVRSRV_POISON_ON_ALLOC_VALUE);
-		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoison);
-	}
-
-	if (BIT_ISSET(ui32Flags, FLAG_ZERO))
-	{
-		eError = _PhysPgMemSet(psPageArrayData,
-		                       psPageArrayData->aBaseArray,
-		                       uiPhysSize,
-		                       ZERO_PAGE_VALUE);
-		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnZero);
-	}
-
-	psPageArrayData->iNumChunksAllocated += psPageArrayData->uiChunksToAlloc;
-
-	/* We have alloc'd the previous request, set 0 for book keeping */
-	psPageArrayData->uiChunksToAlloc = 0;
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, uiPhysSize, psPageArrayData->uiPid);
-#else
-	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
-		{
-			IMG_CPU_PHYADDR sLocalCpuPAddr;
-			sLocalCpuPAddr.uiAddr =
-				(IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[i]);
-			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-									 NULL,
-									 sLocalCpuPAddr,
-									 1 << uiLog2ChunkSize,
-									 psPageArrayData->uiPid
-									 DEBUG_MEMSTATS_VALUES);
-		}
-	}
-#endif
-#endif
-
-	return PVRSRV_OK;
 
-	/*
-	  error exit paths follow:
-	*/
-errorOnZero:
-errorOnPoison:
-	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
-
-	RA_FreeMulti(psPageArrayData->psArena,
-	              psPageArrayData->aBaseArray,
-	              psPageArrayData->uiTotalNumChunks);
-
-errorOnRAAlloc:
-	PVR_ASSERT(eError != PVRSRV_OK);
-	return eError;
-}
-
-static PVRSRV_ERROR
-_AllocLMPagesSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData, IMG_UINT32 *pui32MapTable)
-{
-	PVRSRV_ERROR eError;
-	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
-	IMG_UINT32 uiChunkSize = 1ULL << uiLog2ChunkSize;
-	IMG_UINT32 uiChunksToAlloc = psPageArrayData->uiChunksToAlloc;
-	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
-
-	if (!pui32MapTable)
-	{
-		PVR_LOG_GOTO_WITH_ERROR("pui32MapTable", eError, PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY, errorOnRAAlloc);
-	}
-
-#if defined(DEBUG)
-	/*
-	 * This block performs validation of the mapping table input in the following ways:
-	 * Check that each index in the mapping table does not exceed the number of the chunks
-	 * the whole PMR supports.
-	 * Check that each index given by the mapping table is not already allocated.
-	 * Check that there are no duplicated indices given in the mapping table.
-	 */
-	{
-		IMG_UINT32 i;
-		IMG_BOOL bIssueDetected = IMG_FALSE;
-		PVRSRV_ERROR eMapCheckError;
-
-		for (i = 0; i < uiChunksToAlloc; i++)
-		{
-			if (pui32MapTable[i] >= psPageArrayData->uiTotalNumChunks)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-						"%s: Page alloc request Index out of bounds for PMR @0x%p",
-						__func__,
-						psPageArrayData));
-				eMapCheckError = PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE;
-				bIssueDetected = IMG_TRUE;
-				break;
-			}
-
-			if (!RA_BASE_IS_INVALID(psPageArrayData->aBaseArray[pui32MapTable[i]]))
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-						"%s: Mapping already exists Index %u Mapping index %u",
-						__func__,
-						i,
-						pui32MapTable[i]));
-				eMapCheckError = PVRSRV_ERROR_PMR_MAPPING_ALREADY_EXISTS;
-				bIssueDetected = IMG_TRUE;
-				break;
-			}
-
-			if (RA_BASE_IS_SPARSE_PREP(psPageArrayData->aBaseArray[pui32MapTable[i]]))
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-						"%s: Mapping already exists in mapping table given Index %u Mapping index %u",
-						__func__,
-						i,
-						pui32MapTable[i]));
-				eMapCheckError = PVRSRV_ERROR_PMR_MAPPING_ALREADY_EXISTS;
-				bIssueDetected = IMG_TRUE;
-				break;
-			}
-			else
-			{
-				/* Set the To Prep value so we can detect duplicated map indices */
-				psPageArrayData->aBaseArray[pui32MapTable[i]] = RA_BASE_SPARSE_PREP_ALLOC_ADDR;
-			}
-		}
-		/* Unwind the Alloc Prep Values */
-		if (bIssueDetected)
-		{
-			/* We don't want to affect the index of the issue seen
-			 * as it could be a valid mapping. If it is a duplicated
-			 * mapping in the given table then we will clean-up the
-			 * previous instance anyway.
-			 */
-			IMG_UINT32 uiUnwind = i;
-
-			for (i = 0; i < uiUnwind; i++)
-			{
-				psPageArrayData->aBaseArray[pui32MapTable[i]] = INVALID_BASE_ADDR;
-			}
-
-			PVR_GOTO_WITH_ERROR(eError, eMapCheckError, errorOnRAAlloc);
-		}
-	}
-#endif
-
-	eError = RA_AllocMultiSparse(psPageArrayData->psArena,
-	                              psPageArrayData->uiLog2ChunkSize,
-	                              RA_NO_IMPORT_MULTIPLIER,
-	                              0,
-	                              "LMA_Page_Alloc",
-	                              psPageArrayData->aBaseArray,
-	                              psPageArrayData->uiTotalNumChunks,
-	                              pui32MapTable,
-	                              uiChunksToAlloc);
-	if (PVRSRV_OK != eError)
-	{
-		RA_USAGE_STATS sRAStats;
-		IMG_CHAR *pszArenaName;
-		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
-		pszArenaName = RA_GetArenaName(psPageArrayData->psArena);
-
-		PVR_DPF((PHYSHEAP_DPF_LVL,
-				"Sparse: Failed to Allocate size = 0x%llx, align = 0x%llx"
-				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
-				" Arena Name: '%s'",
-				(unsigned long long) uiChunksToAlloc << uiLog2ChunkSize,
-				1ULL << uiLog2ChunkSize,
-				sRAStats.ui64FreeArenaSize,
-				pszArenaName));
-		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
-	}
-
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-{
-	PVR_DPF((PVR_DBG_MESSAGE,
-	        "(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
-	        psPageArrayData->aBaseArray[pui32MapTable[0]]));
-}
-#endif
-
-	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC) || BIT_ISSET(ui32Flags, FLAG_ZERO))
-	{
-		IMG_UINT32 i, ui32Index = 0;
-		for (i = 0; i < uiChunksToAlloc; i++)
-		{
-			ui32Index = pui32MapTable[i];
-
-			eError = _PhysPgMemSet(psPageArrayData,
-			                       &psPageArrayData->aBaseArray[ui32Index],
-			                       uiChunkSize,
-			                       BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC) ? PVRSRV_POISON_ON_ALLOC_VALUE :
-			                                                                    ZERO_PAGE_VALUE);
-			PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoisonZero);
-		}
-	}
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-	                            uiChunksToAlloc << uiLog2ChunkSize,
-	                            psPageArrayData->uiPid);
-#else
-	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < psPageArrayData->uiChunksToAlloc; i++)
-		{
-			IMG_UINT32 ui32Index = pui32MapTable[i];
-			IMG_CPU_PHYADDR sLocalCpuPAddr;
-			sLocalCpuPAddr.uiAddr =
-				(IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[ui32Index]);
-			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-									 NULL,
-									 sLocalCpuPAddr,
-									 uiChunkSize,
-									 psPageArrayData->uiPid
-									 DEBUG_MEMSTATS_VALUES);
-		}
-	}
-#endif
-#endif
-
-	psPageArrayData->iNumChunksAllocated += uiChunksToAlloc;
-
-	/* We have alloc'd the previous request, set 0 for book keeping */
-	psPageArrayData->uiChunksToAlloc = 0;
-
-	return PVRSRV_OK;
-
-	/*
-	  error exit paths follow:
-	*/
-errorOnPoisonZero:
-	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
-
-	RA_FreeMultiSparse(psPageArrayData->psArena,
-	                    psPageArrayData->aBaseArray,
-	                    psPageArrayData->uiTotalNumChunks,
-	                    psPageArrayData->uiLog2ChunkSize,
-	                    pui32MapTable,
-	                    &uiChunksToAlloc);
-
-errorOnRAAlloc:
-	PVR_ASSERT(eError != PVRSRV_OK);
-	return eError;
-
-}
-
-static PVRSRV_ERROR
-_AllocLMPages(PMR_LMALLOCARRAY_DATA *psPageArrayData, IMG_UINT32 *pui32MapTable)
-{
-	PVRSRV_ERROR eError;
-	RA_ARENA *pArena;
-
-	PVR_ASSERT(NULL != psPageArrayData);
-	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
-
-	if (psPageArrayData->uiTotalNumChunks <
-			(psPageArrayData->iNumChunksAllocated + psPageArrayData->uiChunksToAlloc))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "Pages requested to allocate don't fit PMR alloc Size. "
-				"Allocated: %u + Requested: %u > Total Allowed: %u",
-				psPageArrayData->iNumChunksAllocated,
-				psPageArrayData->uiChunksToAlloc,
-				psPageArrayData->uiTotalNumChunks));
-		return PVRSRV_ERROR_PMR_BAD_MAPPINGTABLE_SIZE;
-	}
-
-	/* If we have a non-backed sparse PMR then we can just return */
-	if (psPageArrayData->uiChunksToAlloc == 0)
-	{
-		PVR_DPF((PVR_DBG_MESSAGE,
-							"%s: Non-Backed Sparse PMR Created: %p.",
-							__func__,
-							psPageArrayData));
-		return PVRSRV_OK;
-	}
-
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-	{
-		IMG_UINT32 ui32OSid=0;
-		PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPageArrayData->psPhysHeap);
-
-		/* Obtain the OSid specific data from our connection handle */
-		if (psPageArrayData->psConnection != NULL)
-		{
-			ui32OSid = psPageArrayData->psConnection->ui32OSid;
-		}
-
-		if (PVRSRV_CHECK_SHARED_BUFFER(psPageArrayData->uiAllocFlags))
-		{
-			pArena=psDevNode->psOSSharedArena;
-			PVR_DPF((PVR_DBG_MESSAGE,
-					 "(GPU Virtualization Validation): Giving from shared mem"));
-		}
-		else
-		{
-			pArena=psDevNode->psOSidSubArena[ui32OSid];
-			PVR_DPF((PVR_DBG_MESSAGE,
-					 "(GPU Virtualization Validation): Giving from OS slot %d",
-					 ui32OSid));
-		}
-	}
-#else
-	/* Get suitable local memory region for this GPU physheap allocation */
-	eError = PhysmemGetArenaLMA(psPageArrayData->psPhysHeap, &pArena);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PhysmemGetArenaLMA");
-#endif
-
-	psPageArrayData->psArena = pArena;
-
-	/*
-	 * 3 cases:
-	 * Sparse allocation populating the whole PMR.
-	 * [**********]
-	 * Sparse allocation partially populating the PMR at given indices.
-	 * [*** *** **]
-	 * Contiguous allocation.
-	 * [**********]
-	 *
-	 * Note: Separate cases are required for 1 and 3 due to memstats tracking.
-	 * In Contiguous case we can track the block as a single memstat record as we know
-	 * we will also free in that size record.
-	 * Sparse allocations require a memstat record per chunk as they can be arbitrarily
-	 * free'd.
-	 */
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		if (psPageArrayData->uiTotalNumChunks == psPageArrayData->uiChunksToAlloc &&
-		    !pui32MapTable)
-		{
-			eError = _AllocLMPagesSparseFull(psPageArrayData);
-		}
-		else
-		{
-			eError = _AllocLMPagesSparse(psPageArrayData, pui32MapTable);
-		}
-	}
-	else
-	{
-		eError = _AllocLMPagesContig(psPageArrayData);
-	}
-
-	return eError;
-}
-
-static void
-_FreeLMPageArray(PMR_LMALLOCARRAY_DATA *psPageArrayData)
-{
-	PVR_DPF((PVR_DBG_MESSAGE,
-			"physmem_lma.c: freed local memory array structure for PMR @0x%p",
-			psPageArrayData));
-
-	OSFreeMem(psPageArrayData);
-}
-
-static PVRSRV_ERROR
-_FreeLMPagesContig(PMR_LMALLOCARRAY_DATA *psPageArrayData)
-{
-	RA_ARENA *pArena = psPageArrayData->psArena;
-	IMG_UINT64 uiPhysSize =
-		(IMG_UINT64) psPageArrayData->uiTotalNumChunks << psPageArrayData->uiLog2ChunkSize;
-	PVRSRV_ERROR eError;
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
-	{
-		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
-	}
-#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
-#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
-
-	PVR_ASSERT(psPageArrayData->iNumChunksAllocated != 0);
-	PVR_ASSERT(psPageArrayData->iNumChunksAllocated ==
-	           psPageArrayData->uiTotalNumChunks);
-
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_POISON_ON_FREE))
-	{
-		eError = _PhysPgMemSet(psPageArrayData,
-							   psPageArrayData->aBaseArray,
-							   uiPhysSize,
-							   PVRSRV_POISON_ON_FREE_VALUE);
-		PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
-	}
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsDecrMemAllocStat(uiStat,
-	                            uiPhysSize,
-	                            psPageArrayData->uiPid);
-#else
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-	{
-		PVRSRVStatsRemoveMemAllocRecord(uiStat,
-		                                (IMG_UINT64) psPageArrayData->aBaseArray[0],
-		                                psPageArrayData->uiPid);
-	}
-	else
-	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
-		{
-			if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
-			{
-				PVRSRVStatsRemoveMemAllocRecord(uiStat,
-				                                (IMG_UINT64) psPageArrayData->aBaseArray[i],
-				                                psPageArrayData->uiPid);
-			}
-		}
-	}
-#endif
-#endif
-
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-	{
-		eError = RA_FreeMulti(pArena,
-							  psPageArrayData->aBaseArray,
-							  1);
-		PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
-	}
-	else
-	{
-		eError = RA_FreeMulti(pArena,
-							  psPageArrayData->aBaseArray,
-							  psPageArrayData->iNumChunksAllocated);
-		PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
-	}
-
-	psPageArrayData->iNumChunksAllocated = 0;
-
-	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-			"%s: freed %"IMG_UINT64_FMTSPEC" local memory for PMR @0x%p",
-			__func__,
-			uiPhysSize,
-			psPageArrayData));
-
-	return eError;
-}
-
-static PVRSRV_ERROR
-_FreeLMPagesRemainingSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData)
-{
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 uiChunkSize = 1ULL << psPageArrayData->uiLog2ChunkSize;
-	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
-	IMG_BOOL bPoisonOnFree = (BIT_ISSET(ui32Flags, FLAG_POISON_ON_FREE));
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
-	{
-		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
-	}
-#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
-#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsDecrMemAllocStat(uiStat,
-	                            psPageArrayData->iNumChunksAllocated << psPageArrayData->uiLog2ChunkSize,
-	                            psPageArrayData->uiPid);
-#endif
-
-	for (i = 0; i < psPageArrayData->uiTotalNumChunks;)
-	{
-		if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
-		{
-			IMG_UINT32 j;
-			IMG_UINT32 ui32AccumulatedChunks = 1;
-
-			for (j = i;
-				 j + 1 != psPageArrayData->uiTotalNumChunks &&
-				 RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
-				 j++)
-			{
-				ui32AccumulatedChunks++;
-			}
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
-			for (j = i; j < (i + ui32AccumulatedChunks); j++)
-			{
-				PVRSRVStatsRemoveMemAllocRecord(uiStat,
-				                                RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[j]),
-				                                psPageArrayData->uiPid);
-				if (bPoisonOnFree)
-#else
-			for (j = i; j < (i + ui32AccumulatedChunks) && bPoisonOnFree; j++)
-			{
-#endif
-				{
-					eError = _PhysPgMemSet(psPageArrayData,
-										   &psPageArrayData->aBaseArray[j],
-										   uiChunkSize,
-										   PVRSRV_POISON_ON_FREE_VALUE);
-					PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
-				}
-			}
-
-			eError = RA_FreeMulti(psPageArrayData->psArena,
-			                       &psPageArrayData->aBaseArray[i],
-			                       ui32AccumulatedChunks);
-			PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
-
-			psPageArrayData->iNumChunksAllocated -= ui32AccumulatedChunks;
-			i += ui32AccumulatedChunks;
-		}
-		else if (RA_BASE_IS_INVALID(psPageArrayData->aBaseArray[i]))
-		{
-			i++;
-		}
-	}
-
-	/* We have freed all allocations in the previous loop */
-	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR
-_FreeLMPagesSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData,
-                   IMG_UINT32 *pui32FreeIndices,
-                   IMG_UINT32 ui32FreeChunkCount)
-{
-	RA_ARENA *pArena = psPageArrayData->psArena;
-	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
-	IMG_UINT32 uiChunkSize = 1ULL << uiLog2ChunkSize;
-	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
-	IMG_UINT32 uiActualFreeCount = ui32FreeChunkCount;
-	PVRSRV_ERROR eError;
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
-	{
-		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
-	}
-#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
-#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
-
-	PVR_ASSERT(psPageArrayData->iNumChunksAllocated != 0);
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
-	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < ui32FreeChunkCount; i++)
-		{
-			IMG_UINT32 ui32Index = pui32FreeIndices[i];
-
-			PVRSRVStatsRemoveMemAllocRecord(uiStat,
-			                                (IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(
-			                                psPageArrayData->aBaseArray[ui32Index]),
-			                                psPageArrayData->uiPid);
-		}
-	}
-#endif
-
-	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_FREE))
-	{
-		IMG_UINT32 i, ui32Index = 0;
-		for (i = 0; i < ui32FreeChunkCount; i++)
-		{
-			ui32Index = pui32FreeIndices[i];
-
-			eError = _PhysPgMemSet(psPageArrayData,
-								   &psPageArrayData->aBaseArray[ui32Index],
-								   uiChunkSize,
-								   PVRSRV_POISON_ON_FREE_VALUE);
-			PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
-		}
-	}
-
-	eError = RA_FreeMultiSparse(pArena,
-	                             psPageArrayData->aBaseArray,
-	                             psPageArrayData->uiTotalNumChunks,
-	                             uiLog2ChunkSize,
-	                             pui32FreeIndices,
-	                             &uiActualFreeCount);
-	psPageArrayData->iNumChunksAllocated -= uiActualFreeCount;
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	PVRSRVStatsDecrMemAllocStat(uiStat,
-	                            uiActualFreeCount << psPageArrayData->uiLog2ChunkSize,
-	                            psPageArrayData->uiPid);
-#endif
-	if (eError == PVRSRV_ERROR_RA_FREE_INVALID_CHUNK)
-	{
-		/* Log the RA error but convert it to PMR level to match the interface,
-		 * this is important because other PMR factories may not use the RA but
-		 * still return error, returning a PMR based error
-		 * keeps the interface agnostic to implementation behaviour.
-		 */
-		PVR_LOG_IF_ERROR(eError, "RA_FreeMultiSparse");
-		return PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK;
-	}
-	PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMultiSparse");
-
-	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
-
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-			"%s: freed %d local memory for PMR @0x%p",
-			__func__,
-			(uiActualFreeCount * uiChunkSize),
-			psPageArrayData));
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR
-_FreeLMPages(PMR_LMALLOCARRAY_DATA *psPageArrayData,
-             IMG_UINT32 *pui32FreeIndices,
-             IMG_UINT32 ui32FreeChunkCount)
-{
-	PVRSRV_ERROR eError;
-
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		if (!pui32FreeIndices)
-		{
-			eError =  _FreeLMPagesRemainingSparse(psPageArrayData);
-		}
-		else
-		{
-			eError = _FreeLMPagesSparse(psPageArrayData, pui32FreeIndices, ui32FreeChunkCount);
-		}
-	}
-	else
-	{
-		eError = _FreeLMPagesContig(psPageArrayData);
-	}
-
-	return eError;
-}
-
-/*
- *
- * Implementation of callback functions
- *
- */
-
-/* destructor func is called after last reference disappears, but
-   before PMR itself is freed. */
-static void
-PMRFinalizeLocalMem(PMR_IMPL_PRIVDATA pvPriv)
-{
-	PVRSRV_ERROR eError;
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
-
-	/* We can't free pages until now. */
-	if (psLMAllocArrayData->iNumChunksAllocated != 0)
-	{
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION) && defined(__linux__)
-		PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-		IMG_UINT32 ui32LMALeakMax = psPVRSRVData->sMemLeakIntervals.ui32GPU;
-
-		mutex_lock(&g_sLMALeakMutex);
-
-		g_ui32LMALeakCounter++;
-		if (ui32LMALeakMax && g_ui32LMALeakCounter >= ui32LMALeakMax)
-		{
-			g_ui32LMALeakCounter = 0;
-			mutex_unlock(&g_sLMALeakMutex);
-
-			PVR_DPF((PVR_DBG_WARNING, "%s: Skipped freeing of PMR 0x%p to trigger memory leak.", __func__, pvPriv));
-			return;
-		}
-
-		mutex_unlock(&g_sLMALeakMutex);
-#endif
-		eError = _FreeLMPages(psLMAllocArrayData, NULL, 0);
-		PVR_LOG_IF_ERROR(eError, "_FreeLMPages");
-		PVR_ASSERT (eError == PVRSRV_OK);
-	}
-
-	_FreeLMPageArray(psLMAllocArrayData);
-}
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-static PVRSRV_ERROR PMRZombifyLocalMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
-{
-	PMR_LMALLOCARRAY_DATA *psPageArrayData = pvPriv;
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
-	IMG_PID uiPid = psPageArrayData->uiPid;
-#endif
-
-	BIT_SET(psPageArrayData->ui32Flags, FLAG_ZOMBIE);
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS)
-#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
-	{
-		IMG_UINT64 uiSize = BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE) ?
-			(IMG_UINT64) psPageArrayData->iNumChunksAllocated << uiLog2ChunkSize :
-			(IMG_UINT64) psPageArrayData->uiTotalNumChunks << uiLog2ChunkSize;
-
-		PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, uiSize, uiPid);
-		PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES, uiSize, uiPid);
-	}
-#else /* !defined(PVRSRV_ENABLE_MEMORY_STATS) */
-	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		/* _FreeLMPagesRemainingSparse path */
-
-		IMG_UINT32 i;
-
-		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
-		{
-			if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
-			{
-				IMG_UINT32 j;
-				IMG_UINT32 ui32AccumulatedChunks = 1;
-
-				for (j = i;
-				     j + 1 != psPageArrayData->uiTotalNumChunks &&
-				         RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
-				     j++)
-				{
-					ui32AccumulatedChunks++;
-				}
-
-				for (j = i; j < (i + ui32AccumulatedChunks); j++)
-				{
-					IMG_CPU_PHYADDR sCpuPAddr = {
-						.uiAddr = RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[j]),
-					};
-
-					PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-					                                sCpuPAddr.uiAddr,
-					                                uiPid);
-					PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES,
-					                             NULL,
-					                             sCpuPAddr,
-					                             1ULL << uiLog2ChunkSize,
-					                             uiPid
-					                             DEBUG_MEMSTATS_VALUES);
-				}
-			}
-		}
-	}
-	else
-	{
-		/* _FreeLMPagesContig path */
-
-		if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-		{
-			IMG_CPU_PHYADDR sCpuPAddr = {
-				.uiAddr = psPageArrayData->aBaseArray[0]
-			};
-
-			PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-			                                psPageArrayData->aBaseArray[0],
-			                                uiPid);
-			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES,
-			                             NULL,
-			                             sCpuPAddr,
-			                             psPageArrayData->uiTotalNumChunks << uiLog2ChunkSize,
-			                             uiPid
-			                             DEBUG_MEMSTATS_VALUES);
-		}
-		else
-		{
-			IMG_UINT32 i;
-
-			for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
-			{
-				if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
-				{
-					IMG_CPU_PHYADDR sCpuPAddr = {
-						.uiAddr = RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[i]),
-					};
-
-					PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
-					                                psPageArrayData->aBaseArray[i],
-					                                uiPid);
-					PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES,
-					                             NULL,
-					                             sCpuPAddr,
-					                             1ULL << psPageArrayData->uiLog2ChunkSize,
-					                             uiPid
-					                             DEBUG_MEMSTATS_VALUES);
-				}
-			}
-
-		}
-	}
-#endif /* !defined(PVRSRV_ENABLE_MEMORY_STATS) */
-#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
-
-	PVR_UNREFERENCED_PARAMETER(psPMR);
-
-	return PVRSRV_OK;
-}
-#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
-
-/* callback function for locking the system physical page addresses.
-   As we are LMA there is nothing to do as we control physical memory. */
-static PVRSRV_ERROR
-PMRLockSysPhysAddressesLocalMem(PMR_IMPL_PRIVDATA pvPriv)
-{
-
-	PVRSRV_ERROR eError;
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData;
-
-	psLMAllocArrayData = pvPriv;
-
-	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_ONDEMAND))
-	{
-		/* Allocate Memory for deferred allocation */
-		eError = _AllocLMPages(psLMAllocArrayData, NULL);
-		PVR_RETURN_IF_ERROR(eError);
-	}
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR
-PMRUnlockSysPhysAddressesLocalMem(PMR_IMPL_PRIVDATA pvPriv)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData;
-
-	psLMAllocArrayData = pvPriv;
-
-	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_ONDEMAND))
-	{
-		/* Free Memory for deferred allocation */
-		eError = _FreeLMPages(psLMAllocArrayData, NULL, 0);
-		PVR_RETURN_IF_ERROR(eError);
-	}
-
-	PVR_ASSERT(eError == PVRSRV_OK);
-	return eError;
-}
-
-/* N.B. It is assumed that PMRLockSysPhysAddressesLocalMem() is called _before_ this function! */
-static PVRSRV_ERROR
-PMRSysPhysAddrLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-					   IMG_UINT32 ui32Log2PageSize,
-					   IMG_UINT32 ui32NumOfPages,
-					   IMG_DEVMEM_OFFSET_T *puiOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
-					   IMG_UINT64 ui64IPAPolicyValue,
-					   IMG_UINT64 ui64IPAClearMask,
-#endif
-					   IMG_BOOL *pbValid,
-					   IMG_DEV_PHYADDR *psDevPAddr)
-{
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
-	IMG_UINT32 idx;
-	IMG_UINT32 uiLog2AllocSize;
-	IMG_UINT64 uiAllocIndex;
-	IMG_DEVMEM_OFFSET_T uiInAllocOffset;
-	IMG_UINT32 uiNumAllocs = psLMAllocArrayData->uiTotalNumChunks;
-
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
-	PVR_UNREFERENCED_PARAMETER(ui64IPAPolicyValue);
-	PVR_UNREFERENCED_PARAMETER(ui64IPAClearMask);
-#endif
-
-	if (psLMAllocArrayData->uiLog2ChunkSize < ui32Log2PageSize)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-		         "%s: Requested physical addresses from PMR "
-		         "for incompatible contiguity %u!",
-		         __func__,
-		         ui32Log2PageSize));
-		return PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY;
-	}
-
-	PVR_ASSERT(psLMAllocArrayData->uiLog2ChunkSize != 0);
-	PVR_ASSERT(ui32Log2PageSize >= RA_BASE_FLAGS_LOG2);
-
-	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
-	{
-		for (idx=0; idx < ui32NumOfPages; idx++)
-		{
-			if (pbValid[idx])
-			{
-				psDevPAddr[idx].uiAddr = psLMAllocArrayData->aBaseArray[0] + puiOffset[idx];
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
-				/* Modify the physical address with the associated IPA values */
-				psDevPAddr[idx].uiAddr &= ~ui64IPAClearMask;
-				psDevPAddr[idx].uiAddr |= ui64IPAPolicyValue;
-#endif
-			}
-		}
-	}
-	else
-	{
-		uiLog2AllocSize = psLMAllocArrayData->uiLog2ChunkSize;
-
-		for (idx=0; idx < ui32NumOfPages; idx++)
-		{
-			if (pbValid[idx])
-			{
-				uiAllocIndex = puiOffset[idx] >> uiLog2AllocSize;
-				uiInAllocOffset = puiOffset[idx] - (uiAllocIndex << uiLog2AllocSize);
-
-				PVR_LOG_RETURN_IF_FALSE(uiAllocIndex < uiNumAllocs,
-										"puiOffset out of range", PVRSRV_ERROR_OUT_OF_RANGE);
-
-				PVR_ASSERT(uiInAllocOffset < (1ULL << uiLog2AllocSize));
-
-				/* The base may or may not be a ghost base, but we don't care,
-				 * we just need the real representation of the base.
-				 */
-				psDevPAddr[idx].uiAddr = RA_BASE_STRIP_GHOST_BIT(
-					psLMAllocArrayData->aBaseArray[uiAllocIndex]) + uiInAllocOffset;
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
-				/* Modify the physical address with the associated IPA values */
-				psDevPAddr[idx].uiAddr &= ~ui64IPAClearMask;
-				psDevPAddr[idx].uiAddr |= ui64IPAPolicyValue;
-#endif
-			}
-		}
-	}
-
-	return PVRSRV_OK;
-}
-
-static PVRSRV_ERROR
-PMRAcquireKernelMappingDataLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-								 size_t uiOffset,
-								 size_t uiSize,
-								 void **ppvKernelAddressOut,
-								 IMG_HANDLE *phHandleOut,
-								 PMR_FLAGS_T ulFlags)
-{
-	PVRSRV_ERROR eError;
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
-	PMR_KERNEL_MAPPING *psKernelMapping;
-	RA_BASE_T *paBaseArray;
-	IMG_UINT32 ui32ChunkIndex = 0;
-	size_t uiOffsetMask = uiOffset;
-
-	IMG_UINT32 uiLog2ChunkSize = psLMAllocArrayData->uiLog2ChunkSize;
-	IMG_UINT64 uiChunkSize = 1ULL << uiLog2ChunkSize;
-	IMG_UINT64 uiPhysSize;
-
-	PVR_ASSERT(psLMAllocArrayData);
-	PVR_ASSERT(ppvKernelAddressOut);
-	PVR_ASSERT(phHandleOut);
-
-	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		IMG_UINT32 i;
-		/* Locate the desired physical chunk to map in */
-		ui32ChunkIndex = uiOffset >> psLMAllocArrayData->uiLog2ChunkSize;
-
-		if (OSIsMapPhysNonContigSupported())
-		{
-			/* If a size hasn't been supplied assume we are mapping a single page */
-			IMG_UINT32 uiNumChunksToMap;
-
-			/* This is to support OSMapPMR originated parameters */
-			if (uiOffset == 0 && uiSize == 0)
-			{
-				uiNumChunksToMap = psLMAllocArrayData->iNumChunksAllocated;
-			}
-			else
-			{
-				uiNumChunksToMap = uiSize >> psLMAllocArrayData->uiLog2ChunkSize;
-			}
-
-			/* Check we are attempting to map at least a chunk in size */
-			if (uiNumChunksToMap < 1)
-			{
-				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_INVALID_PARAMS, "uiNumChunksToMap < 1");
-			}
-
-			/* Check contiguous region doesn't exceed size of PMR */
-			if (ui32ChunkIndex + (uiNumChunksToMap - 1) > psLMAllocArrayData->uiTotalNumChunks)
-			{
-				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_INVALID_PARAMS,
-				                        "Mapping range exceeds total num chunks in PMR");
-			}
-
-			/* Check the virtually contiguous region given is physically backed */
-			for (i = ui32ChunkIndex; i < ui32ChunkIndex + uiNumChunksToMap; i++)
-			{
-				if (RA_BASE_IS_INVALID(psLMAllocArrayData->aBaseArray[i]))
-				{
-					PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY, "Sparse contiguity check");
-				}
-			}
-			/* Size of virtually contiguous sparse alloc */
-			uiPhysSize = (IMG_UINT64) uiNumChunksToMap << psLMAllocArrayData->uiLog2ChunkSize;
-		}
-		else
-		{
-			size_t uiStart = uiOffset;
-			size_t uiEnd = uiOffset + uiSize - 1;
-			size_t uiChunkMask = ~((1 << psLMAllocArrayData->uiLog2ChunkSize) - 1);
-
-			/* We can still map if only one chunk is required */
-			if ((uiStart & uiChunkMask) != (uiEnd & uiChunkMask))
-			{
-				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY, "Sparse contiguity check");
-			}
-			/* Map a single chunk */
-			uiPhysSize = uiChunkSize;
-		}
-
-		paBaseArray = &psLMAllocArrayData->aBaseArray[ui32ChunkIndex];
-
-		/* Offset mask to be used for address offsets within a chunk */
-		uiOffsetMask = (1U << psLMAllocArrayData->uiLog2ChunkSize) - 1;
-	}
-	else
-	{
-		paBaseArray = psLMAllocArrayData->aBaseArray;
-		uiPhysSize = (IMG_UINT64) psLMAllocArrayData->uiTotalNumChunks << uiLog2ChunkSize;
-	}
-
-	PVR_ASSERT(ui32ChunkIndex < psLMAllocArrayData->uiTotalNumChunks);
-
-	psKernelMapping = OSAllocMem(sizeof(*psKernelMapping));
-	PVR_RETURN_IF_NOMEM(psKernelMapping);
-
-	eError = _MapPMRKernel(psLMAllocArrayData,
-	                       paBaseArray,
-	                       uiPhysSize,
-	                       ulFlags,
-	                       psKernelMapping);
-	if (eError == PVRSRV_OK)
-	{
-		/* uiOffset & uiOffsetMask is used to get the kernel addr within the page */
-		*ppvKernelAddressOut = ((IMG_CHAR *) psKernelMapping->pvKernelAddress) + (uiOffset & uiOffsetMask);
-		*phHandleOut = psKernelMapping;
-	}
-	else
-	{
-		OSFreeMem(psKernelMapping);
-		PVR_LOG_ERROR(eError, "_MapPMRKernel");
-	}
-
-	return eError;
-}
-
-static void PMRReleaseKernelMappingDataLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-                                                IMG_HANDLE hHandle)
-{
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = (PMR_LMALLOCARRAY_DATA *) pvPriv;
-	PMR_KERNEL_MAPPING *psKernelMapping = (PMR_KERNEL_MAPPING *) hHandle;
-
-	PVR_ASSERT(psLMAllocArrayData);
-	PVR_ASSERT(psKernelMapping);
-
-	_UnMapPMRKernel(psLMAllocArrayData,
-	                psKernelMapping);
-
-	OSFreeMem(psKernelMapping);
-}
-
-static PVRSRV_ERROR
-CopyBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-				  IMG_DEVMEM_OFFSET_T uiOffset,
-				  IMG_UINT8 *pcBuffer,
-				  size_t uiBufSz,
-				  size_t *puiNumBytes,
-				  void (*pfnCopyBytes)(IMG_UINT8 *pcBuffer,
-									   IMG_UINT8 *pcPMR,
-									   size_t uiSize))
-{
-	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
-	size_t uiBytesCopied;
-	size_t uiBytesToCopy;
-	size_t uiBytesCopyableFromAlloc;
-	PMR_KERNEL_MAPPING sMapping;
-	IMG_UINT8 *pcKernelPointer = NULL;
-	size_t uiBufferOffset;
-	IMG_UINT64 uiAllocIndex;
-	IMG_DEVMEM_OFFSET_T uiInAllocOffset;
-	IMG_UINT32 uiLog2ChunkSize = psLMAllocArrayData->uiLog2ChunkSize;
-	IMG_UINT64 uiChunkSize = 1ULL << uiLog2ChunkSize;
-	IMG_UINT64 uiPhysSize;
-	PVRSRV_ERROR eError;
-
-	uiBytesCopied = 0;
-	uiBytesToCopy = uiBufSz;
-	uiBufferOffset = 0;
-
-	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
-	{
-		while (uiBytesToCopy > 0)
-		{
-			/* we have to map one alloc in at a time */
-			PVR_ASSERT(psLMAllocArrayData->uiLog2ChunkSize != 0);
-			uiAllocIndex = uiOffset >> psLMAllocArrayData->uiLog2ChunkSize;
-			uiInAllocOffset = uiOffset - (uiAllocIndex << psLMAllocArrayData->uiLog2ChunkSize);
-			uiBytesCopyableFromAlloc = uiBytesToCopy;
-			if (uiBytesCopyableFromAlloc + uiInAllocOffset > (1ULL << psLMAllocArrayData->uiLog2ChunkSize))
-			{
-				uiBytesCopyableFromAlloc = TRUNCATE_64BITS_TO_SIZE_T((1ULL << psLMAllocArrayData->uiLog2ChunkSize)-uiInAllocOffset);
-			}
-			/* Mapping a single chunk at a time */
-			uiPhysSize = uiChunkSize;
-
-			PVR_ASSERT(uiBytesCopyableFromAlloc != 0);
-			PVR_ASSERT(uiAllocIndex < psLMAllocArrayData->uiTotalNumChunks);
-			PVR_ASSERT(uiInAllocOffset < (1ULL << uiLog2ChunkSize));
-
-			eError = _MapPMRKernel(psLMAllocArrayData,
-			                       &psLMAllocArrayData->aBaseArray[uiAllocIndex],
-			                       uiPhysSize,
-			                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
-			                       &sMapping);
-			PVR_GOTO_IF_ERROR(eError, e0);
-			pcKernelPointer = sMapping.pvKernelAddress;
-			pfnCopyBytes(&pcBuffer[uiBufferOffset], &pcKernelPointer[uiInAllocOffset], uiBytesCopyableFromAlloc);
-
-			_UnMapPMRKernel(psLMAllocArrayData,
-			                &sMapping);
-
-			uiBufferOffset += uiBytesCopyableFromAlloc;
-			uiBytesToCopy -= uiBytesCopyableFromAlloc;
-			uiOffset += uiBytesCopyableFromAlloc;
-			uiBytesCopied += uiBytesCopyableFromAlloc;
-		}
-	}
-	else
-	{
-		uiPhysSize = (IMG_UINT64) psLMAllocArrayData->uiTotalNumChunks << uiLog2ChunkSize;
-		PVR_ASSERT((uiOffset + uiBufSz) <= uiPhysSize);
-		PVR_ASSERT(uiChunkSize != 0);
-		eError = _MapPMRKernel(psLMAllocArrayData,
-		                       psLMAllocArrayData->aBaseArray,
-		                       uiPhysSize,
-		                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
-		                       &sMapping);
-		PVR_GOTO_IF_ERROR(eError, e0);
-		pcKernelPointer = sMapping.pvKernelAddress;
-		pfnCopyBytes(pcBuffer, &pcKernelPointer[uiOffset], uiBufSz);
-
-		_UnMapPMRKernel(psLMAllocArrayData,
-		                &sMapping);
-
-		uiBytesCopied = uiBufSz;
-	}
-	*puiNumBytes = uiBytesCopied;
-	return PVRSRV_OK;
-e0:
-	*puiNumBytes = uiBytesCopied;
-	return eError;
-}
-
-static void ReadLocalMem(IMG_UINT8 *pcBuffer,
-						 IMG_UINT8 *pcPMR,
-						 size_t uiSize)
-{
-	/* the memory is mapped as WC (and also aligned to page size) so we can
-	 * safely call "Cached" memcpy */
-	OSCachedMemCopy(pcBuffer, pcPMR, uiSize);
-}
-
-static PVRSRV_ERROR
-PMRReadBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-				  IMG_DEVMEM_OFFSET_T uiOffset,
-				  IMG_UINT8 *pcBuffer,
-				  size_t uiBufSz,
-				  size_t *puiNumBytes)
-{
-	return CopyBytesLocalMem(pvPriv,
-							 uiOffset,
-							 pcBuffer,
-							 uiBufSz,
-							 puiNumBytes,
-							 ReadLocalMem);
-}
-
-static void WriteLocalMem(IMG_UINT8 *pcBuffer,
-						  IMG_UINT8 *pcPMR,
-						  size_t uiSize)
-{
-	/* the memory is mapped as WC (and also aligned to page size) so we can
-	 * safely call "Cached" memcpy but need to issue a write memory barrier
-	 * to flush the write buffers after */
-	OSCachedMemCopyWMB(pcPMR, pcBuffer, uiSize);
-}
-
-static PVRSRV_ERROR
-PMRWriteBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
-					  IMG_DEVMEM_OFFSET_T uiOffset,
-					  IMG_UINT8 *pcBuffer,
-					  size_t uiBufSz,
-					  size_t *puiNumBytes)
-{
-	return CopyBytesLocalMem(pvPriv,
-							 uiOffset,
-							 pcBuffer,
-							 uiBufSz,
-							 puiNumBytes,
-							 WriteLocalMem);
-}
-
-/*************************************************************************/ /*!
-@Function       PMRChangeSparseMemLocalMem
-@Description    This function Changes the sparse mapping by allocating and
-                freeing of pages. It also changes the GPU maps accordingly.
-@Return         PVRSRV_ERROR failure code
-*/ /**************************************************************************/
-static PVRSRV_ERROR
-PMRChangeSparseMemLocalMem(PMR_IMPL_PRIVDATA pPriv,
-                           const PMR *psPMR,
-                           IMG_UINT32 ui32AllocPageCount,
-                           IMG_UINT32 *pai32AllocIndices,
-                           IMG_UINT32 ui32FreePageCount,
-                           IMG_UINT32 *pai32FreeIndices,
-                           IMG_UINT32 uiFlags)
-{
-	PVRSRV_ERROR eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-	IMG_UINT32 ui32AdtnlAllocPages = 0;
-	IMG_UINT32 ui32AdtnlFreePages = 0;
-	IMG_UINT32 ui32CommonRequstCount = 0;
-	IMG_UINT32 ui32Loop = 0;
-	IMG_UINT32 ui32Index = 0;
-	IMG_UINT32 uiAllocpgidx;
-	IMG_UINT32 uiFreepgidx;
-
-	PMR_LMALLOCARRAY_DATA *psPMRPageArrayData = (PMR_LMALLOCARRAY_DATA *)pPriv;
-	IMG_UINT32 uiLog2ChunkSize = psPMRPageArrayData->uiLog2ChunkSize;
-	IMG_UINT32 uiChunkSize = 1ULL << uiLog2ChunkSize;
-
-#if defined(DEBUG)
-	IMG_BOOL bPoisonFail = IMG_FALSE;
-	IMG_BOOL bZeroFail = IMG_FALSE;
-#endif
-
-	/* Fetch the Page table array represented by the PMR */
-	RA_BASE_T *paBaseArray = psPMRPageArrayData->aBaseArray;
-	PMR_MAPPING_TABLE *psPMRMapTable = PMR_GetMappingTable(psPMR);
-
-	/* The incoming request is classified into two operations independent of
-	 * each other: alloc & free chunks.
-	 * These operations can be combined with two mapping operations as well
-	 * which are GPU & CPU space mappings.
-	 *
-	 * From the alloc and free chunk requests, the net amount of chunks to be
-	 * allocated or freed is computed. Chunks that were requested to be freed
-	 * will be reused to fulfil alloc requests.
-	 *
-	 * The order of operations is:
-	 * 1. Allocate new Chunks.
-	 * 2. Move the free chunks from free request to alloc positions.
-	 * 3. Free the rest of the chunks not used for alloc
-	 *
-	 * Alloc parameters are validated at the time of allocation
-	 * and any error will be handled then. */
-
-	if (SPARSE_RESIZE_BOTH == (uiFlags & SPARSE_RESIZE_BOTH))
-	{
-		ui32CommonRequstCount = (ui32AllocPageCount > ui32FreePageCount) ?
-				ui32FreePageCount : ui32AllocPageCount;
-
-		PDUMP_PANIC(PMR_DeviceNode(psPMR), SPARSEMEM_SWAP, "Request to swap alloc & free chunks not supported");
-	}
-
-	if (SPARSE_RESIZE_ALLOC == (uiFlags & SPARSE_RESIZE_ALLOC))
-	{
-		ui32AdtnlAllocPages = ui32AllocPageCount - ui32CommonRequstCount;
-	}
-	else
-	{
-		ui32AllocPageCount = 0;
-	}
-
-	if (SPARSE_RESIZE_FREE == (uiFlags & SPARSE_RESIZE_FREE))
-	{
-		ui32AdtnlFreePages = ui32FreePageCount - ui32CommonRequstCount;
-	}
-	else
-	{
-		ui32FreePageCount = 0;
-	}
-
-	PVR_LOG_RETURN_IF_FALSE(
-	    (ui32CommonRequstCount | ui32AdtnlAllocPages | ui32AdtnlFreePages) != 0,
-	    "Invalid combination of parameters: ui32CommonRequstCount,"
-	    " ui32AdtnlAllocPages and ui32AdtnlFreePages.",
-	    PVRSRV_ERROR_INVALID_PARAMS
-	);
-
-	{
-		/* Validate the free page indices */
-		if (ui32FreePageCount)
-		{
-			if (pai32FreeIndices != NULL)
-			{
-				for (ui32Loop = 0; ui32Loop < ui32FreePageCount; ui32Loop++)
-				{
-					uiFreepgidx = pai32FreeIndices[ui32Loop];
-
-					if (uiFreepgidx >= psPMRPageArrayData->uiTotalNumChunks)
-					{
-						PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE, e0);
-					}
-
-					if (RA_BASE_IS_INVALID(paBaseArray[uiFreepgidx]))
-					{
-						PVR_LOG_GOTO_WITH_ERROR("paBaseArray[uiFreepgidx]", eError, PVRSRV_ERROR_INVALID_PARAMS, e0);
-					}
-				}
-			}
-			else
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-				         "%s: Given non-zero free count but missing indices array",
-				         __func__));
-				return PVRSRV_ERROR_INVALID_PARAMS;
-			}
-		}
-
-		/* The following block of code verifies any issues with common alloc chunk indices */
-		for (ui32Loop = ui32AdtnlAllocPages; ui32Loop < ui32AllocPageCount; ui32Loop++)
-		{
-			uiAllocpgidx = pai32AllocIndices[ui32Loop];
-			if (uiAllocpgidx >= psPMRPageArrayData->uiTotalNumChunks)
-			{
-				PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE, e0);
-			}
-
-			if ((!RA_BASE_IS_INVALID(paBaseArray[uiAllocpgidx])) ||
-					(psPMRMapTable->aui32Translation[uiAllocpgidx] != TRANSLATION_INVALID))
-			{
-				PVR_LOG_GOTO_WITH_ERROR("Trying to allocate already allocated page again", eError, PVRSRV_ERROR_INVALID_PARAMS, e0);
-			}
-		}
-
-		ui32Loop = 0;
-
-		/* Allocate new chunks */
-		if (0 != ui32AdtnlAllocPages)
-		{
-			/* Say how many chunks to allocate */
-			psPMRPageArrayData->uiChunksToAlloc = ui32AdtnlAllocPages;
-
-			eError = _AllocLMPages(psPMRPageArrayData, pai32AllocIndices);
-			PVR_LOG_GOTO_IF_ERROR(eError, "_AllocLMPages", e0);
-
-			/* Mark the corresponding chunks of translation table as valid */
-			for (ui32Loop = 0; ui32Loop < ui32AdtnlAllocPages; ui32Loop++)
-			{
-				psPMRMapTable->aui32Translation[pai32AllocIndices[ui32Loop]] = pai32AllocIndices[ui32Loop];
-			}
-
-			psPMRMapTable->ui32NumPhysChunks += ui32AdtnlAllocPages;
-		}
-
-		ui32Index = ui32Loop;
-		ui32Loop = 0;
-
-		/* Move the corresponding free chunks to alloc request */
-		eError = RA_SwapSparseMem(psPMRPageArrayData->psArena,
-		                           paBaseArray,
-		                           psPMRPageArrayData->uiTotalNumChunks,
-		                           psPMRPageArrayData->uiLog2ChunkSize,
-		                           &pai32AllocIndices[ui32Index],
-		                           &pai32FreeIndices[ui32Loop],
-		                           ui32CommonRequstCount);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RA_SwapSparseMem", unwind_alloc);
-
-		for (ui32Loop = 0; ui32Loop < ui32CommonRequstCount; ui32Loop++, ui32Index++)
-		{
-			uiAllocpgidx = pai32AllocIndices[ui32Index];
-			uiFreepgidx  = pai32FreeIndices[ui32Loop];
-
-			psPMRMapTable->aui32Translation[uiFreepgidx] = TRANSLATION_INVALID;
-			psPMRMapTable->aui32Translation[uiAllocpgidx] = uiAllocpgidx;
-
-			/* Be sure to honour the attributes associated with the allocation
-			 * such as zeroing, poisoning etc. */
-			if (BIT_ISSET(psPMRPageArrayData->ui32Flags, FLAG_POISON_ON_ALLOC))
-			{
-				eError = _PhysPgMemSet(psPMRPageArrayData,
-				                       &psPMRPageArrayData->aBaseArray[uiAllocpgidx],
-				                       uiChunkSize,
-				                       PVRSRV_POISON_ON_ALLOC_VALUE);
-
-				/* Consider this as a soft failure and go ahead but log error to kernel log */
-				if (eError != PVRSRV_OK)
-				{
-#if defined(DEBUG)
-					bPoisonFail = IMG_TRUE;
-#endif
-				}
-			}
-
-			if (BIT_ISSET(psPMRPageArrayData->ui32Flags, FLAG_ZERO))
-			{
-				eError = _PhysPgMemSet(psPMRPageArrayData,
-									   &psPMRPageArrayData->aBaseArray[uiAllocpgidx],
-									   uiChunkSize,
-									   ZERO_PAGE_VALUE);
-				/* Consider this as a soft failure and go ahead but log error to kernel log */
-				if (eError != PVRSRV_OK)
-				{
-#if defined(DEBUG)
-					/* Don't think we need to zero any chunks further */
-					bZeroFail = IMG_TRUE;
-#endif
-				}
-			}
-		}
-
-		/* Free the additional free chunks */
-		if (0 != ui32AdtnlFreePages)
-		{
-			ui32Index = ui32Loop;
-			eError = _FreeLMPages(psPMRPageArrayData, &pai32FreeIndices[ui32Loop], ui32AdtnlFreePages);
-			PVR_LOG_GOTO_IF_ERROR(eError, "_FreeLMPages", e0);
-
-			ui32Loop = 0;
-
-			while (ui32Loop++ < ui32AdtnlFreePages)
-			{
-				/* Set the corresponding mapping table entry to invalid address */
-				psPMRMapTable->aui32Translation[pai32FreeIndices[ui32Index++]] = TRANSLATION_INVALID;
-			}
-
-			psPMRMapTable->ui32NumPhysChunks -= ui32AdtnlFreePages;
-		}
-	}
-
-#if defined(DEBUG)
-	if (IMG_TRUE == bPoisonFail)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Error in poisoning the chunk", __func__));
-	}
-
-	if (IMG_TRUE == bZeroFail)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Error in zeroing the chunk", __func__));
-	}
-#endif
-
-	return PVRSRV_OK;
-
-unwind_alloc:
-	_FreeLMPages(psPMRPageArrayData, pai32AllocIndices, ui32Index);
-
-	for (ui32Loop = 0; ui32Loop < ui32Index; ui32Loop++)
-	{
-		psPMRMapTable->aui32Translation[pai32AllocIndices[ui32Loop]] = TRANSLATION_INVALID;
-	}
-
-e0:
-	return eError;
-}
-
-/*************************************************************************/ /*!
-@Function       PMRChangeSparseMemCPUMapLocalMem
-@Description    This function Changes CPU maps accordingly
-@Return         PVRSRV_ERROR failure code
-*/ /**************************************************************************/
-static
-PVRSRV_ERROR PMRChangeSparseMemCPUMapLocalMem(PMR_IMPL_PRIVDATA pPriv,
-                                              const PMR *psPMR,
-                                              IMG_UINT64 sCpuVAddrBase,
-                                              IMG_UINT32 ui32AllocPageCount,
-                                              IMG_UINT32 *pai32AllocIndices,
-                                              IMG_UINT32 ui32FreePageCount,
-                                              IMG_UINT32 *pai32FreeIndices)
-{
-	PVRSRV_ERROR eError;
-	IMG_DEV_PHYADDR *psPageArray;
-	PMR_LMALLOCARRAY_DATA *psPMRPageArrayData = (PMR_LMALLOCARRAY_DATA *)pPriv;
-	uintptr_t sCpuVABase = sCpuVAddrBase;
-	IMG_CPU_PHYADDR sCpuAddrPtr;
-	IMG_BOOL bValid = IMG_FALSE;
-	IMG_UINT32 i;
-
-	/* Get the base address of the heap */
-	eError = PMR_CpuPhysAddr(psPMR,
-	                         psPMRPageArrayData->uiLog2ChunkSize,
-	                         1,
-	                         0,	/* offset zero here mean first page in the PMR */
-	                         &sCpuAddrPtr,
-	                         &bValid);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PMR_CpuPhysAddr");
-
-	/* Phys address of heap is computed here by subtracting the offset of this page
-	 * basically phys address of any page = Base address of heap + offset of the page */
-	sCpuAddrPtr.uiAddr -= RA_BASE_STRIP_GHOST_BIT(psPMRPageArrayData->aBaseArray[0]);
-
-	/* We still have ghost bits in the base array, this interface expects true page
-	 * addresses so we need to pre mask / translate the base array
-	 */
-	psPageArray = OSAllocMem(sizeof(IMG_DEV_PHYADDR)*
-                             psPMRPageArrayData->uiTotalNumChunks);
-	PVR_LOG_RETURN_IF_NOMEM(psPageArray, "Page translation array");
-
-	for (i = 0; i <  psPMRPageArrayData->uiTotalNumChunks; i++)
-	{
-		psPageArray[i].uiAddr = RA_BASE_STRIP_GHOST_BIT(psPMRPageArrayData->aBaseArray[i]);
-	}
-
-	eError = OSChangeSparseMemCPUAddrMap((void**) psPageArray,
-	                                     sCpuVABase,
-	                                     sCpuAddrPtr,
-	                                     ui32AllocPageCount,
-	                                     pai32AllocIndices,
-	                                     ui32FreePageCount,
-	                                     pai32FreeIndices,
-	                                     IMG_TRUE);
-
-	OSFreeMem(psPageArray);
-
-	return eError;
-}
-
-static PMR_IMPL_FUNCTAB _sPMRLMAFuncTab = {
-	.pfnLockPhysAddresses = &PMRLockSysPhysAddressesLocalMem,
-	.pfnUnlockPhysAddresses = &PMRUnlockSysPhysAddressesLocalMem,
-	.pfnDevPhysAddr = &PMRSysPhysAddrLocalMem,
-	.pfnAcquireKernelMappingData = &PMRAcquireKernelMappingDataLocalMem,
-	.pfnReleaseKernelMappingData = &PMRReleaseKernelMappingDataLocalMem,
-	.pfnReadBytes = &PMRReadBytesLocalMem,
-	.pfnWriteBytes = &PMRWriteBytesLocalMem,
-	.pfnChangeSparseMem = &PMRChangeSparseMemLocalMem,
-	.pfnChangeSparseMemCPUMap = &PMRChangeSparseMemCPUMapLocalMem,
-	.pfnMMap = NULL,
-	.pfnFinalize = &PMRFinalizeLocalMem,
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-	.pfnZombify = &PMRZombifyLocalMem,
-#endif
-};
-
-PVRSRV_ERROR
-PhysmemNewLocalRamBackedPMR(PHYS_HEAP *psPhysHeap,
-                            CONNECTION_DATA *psConnection,
-                            IMG_DEVMEM_SIZE_T uiSize,
-                            IMG_UINT32 ui32NumPhysChunks,
-                            IMG_UINT32 ui32NumVirtChunks,
-                            IMG_UINT32 *pui32MappingTable,
-                            IMG_UINT32 uiLog2AllocPageSize,
-                            PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                            const IMG_CHAR *pszAnnotation,
-                            IMG_PID uiPid,
-                            PMR **ppsPMRPtr,
-                            IMG_UINT32 ui32PDumpFlags)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_ERROR eError2;
-	PMR *psPMR = NULL;
-	PMR_LMALLOCARRAY_DATA *psPrivData = NULL;
-	PMR_FLAGS_T uiPMRFlags;
-	IMG_UINT32 ui32LMAllocFlags = 0;
-
-	/* This path is checking for the type of PMR to create, if sparse we
-	 * have to perform additional validation as we can only map sparse ranges
-	 * if the os functionality to do so is present. We can also only map virtually
-	 * contiguous sparse regions. Non backed gaps in a range cannot be mapped.
-	 */
-	if (ui32NumPhysChunks != ui32NumVirtChunks || ui32NumVirtChunks > 1)
-	{
-		if (PVRSRV_CHECK_KERNEL_CPU_MAPPABLE(uiFlags) &&
-		   !OSIsMapPhysNonContigSupported())
-		{
-			PVR_DPF((PVR_DBG_ERROR,
-					"%s: LMA kernel mapping functions not available "
-					"for physically discontiguous memory.",
-					__func__));
-			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, errorOnParam);
-		}
-		BIT_SET(ui32LMAllocFlags, FLAG_SPARSE);
-	}
-
-	if (PVRSRV_CHECK_ON_DEMAND(uiFlags))
-	{
-		BIT_SET(ui32LMAllocFlags, FLAG_ONDEMAND);
-	}
-
-	if (PVRSRV_CHECK_ZERO_ON_ALLOC(uiFlags))
-	{
-		BIT_SET(ui32LMAllocFlags, FLAG_ZERO);
-	}
-
-	if (PVRSRV_CHECK_POISON_ON_ALLOC(uiFlags))
-	{
-		BIT_SET(ui32LMAllocFlags, FLAG_POISON_ON_ALLOC);
-	}
-
-#if defined(DEBUG)
-	if (PVRSRV_CHECK_POISON_ON_FREE(uiFlags))
-	{
-		BIT_SET(ui32LMAllocFlags, FLAG_POISON_ON_FREE);
-	}
-#endif
-
-	/* Create Array structure that holds the physical pages */
-	eError = _AllocLMPageArray(uiSize,
-	                           ui32NumPhysChunks,
-	                           ui32NumVirtChunks,
-	                           uiLog2AllocPageSize,
-	                           ui32LMAllocFlags,
-	                           psPhysHeap,
-	                           uiFlags,
-	                           uiPid,
-	                           &psPrivData,
-	                           psConnection);
-	PVR_GOTO_IF_ERROR(eError, errorOnAllocPageArray);
-
-	if (!BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND))
-	{
-		/* Allocate the physical pages */
-		eError = _AllocLMPages(psPrivData, pui32MappingTable);
-		PVR_GOTO_IF_ERROR(eError, errorOnAllocPages);
-	}
-
-	/* In this instance, we simply pass flags straight through.
-
-	   Generically, uiFlags can include things that control the PMR
-	   factory, but we don't need any such thing (at the time of
-	   writing!), and our caller specifies all PMR flags so we don't
-	   need to meddle with what was given to us.
-	*/
-	uiPMRFlags = (PMR_FLAGS_T)(uiFlags & PVRSRV_MEMALLOCFLAGS_PMRFLAGSMASK);
-	/* check no significant bits were lost in cast due to different
-	   bit widths for flags */
-	PVR_ASSERT(uiPMRFlags == (uiFlags & PVRSRV_MEMALLOCFLAGS_PMRFLAGSMASK));
-
-	if (BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND))
-	{
-		PDUMPCOMMENT(PhysHeapDeviceNode(psPhysHeap), "Deferred Allocation PMR (LMA)");
-	}
-
-	eError = PMRCreatePMR(psPhysHeap,
-						  uiSize,
-						  ui32NumPhysChunks,
-						  ui32NumVirtChunks,
-						  pui32MappingTable,
-						  uiLog2AllocPageSize,
-						  uiPMRFlags,
-						  pszAnnotation,
-						  &_sPMRLMAFuncTab,
-						  psPrivData,
-						  PMR_TYPE_LMA,
-						  &psPMR,
-						  ui32PDumpFlags);
-	PVR_LOG_GOTO_IF_ERROR(eError, "PMRCreatePMR", errorOnCreate);
-
-	*ppsPMRPtr = psPMR;
-	return PVRSRV_OK;
-
-errorOnCreate:
-	if (!BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND) && psPrivData->iNumChunksAllocated)
-	{
-		eError2 = _FreeLMPages(psPrivData, NULL, 0);
-		PVR_ASSERT(eError2 == PVRSRV_OK);
-	}
-
-errorOnAllocPages:
-	_FreeLMPageArray(psPrivData);
-
-errorOnAllocPageArray:
-errorOnParam:
-	PVR_ASSERT(eError != PVRSRV_OK);
-	return eError;
 }
diff --git a/drivers/gpu/drm/img-rogue/physmem_lma.h b/drivers/gpu/drm/img-rogue/physmem_lma.h
index 08dba2941135..af42d8826dac 100644
--- a/drivers/gpu/drm/img-rogue/physmem_lma.h
+++ b/drivers/gpu/drm/img-rogue/physmem_lma.h
@@ -49,6 +49,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "img_types.h"
 #include "pvrsrv_error.h"
 #include "pvrsrv_memallocflags.h"
+#include "device.h"
 
 /* services/server/include/ */
 #include "pmr.h"
@@ -71,24 +72,4 @@ PhysmemCreateHeapLMA(PVRSRV_DEVICE_NODE *psDevNode,
                      IMG_CHAR *pszLabel,
                      PHYS_HEAP **ppsPhysHeap);
 
-/*
- * PhysmemNewLocalRamBackedPMR
- *
- * This function will create a PMR using the local card memory and is OS
- * agnostic.
- */
-PVRSRV_ERROR
-PhysmemNewLocalRamBackedPMR(PHYS_HEAP *psPhysHeap,
-							CONNECTION_DATA *psConnection,
-                            IMG_DEVMEM_SIZE_T uiSize,
-                            IMG_UINT32 ui32NumPhysChunks,
-                            IMG_UINT32 ui32NumVirtChunks,
-                            IMG_UINT32 *pui32MappingTable,
-                            IMG_UINT32 uiLog2PageSize,
-                            PVRSRV_MEMALLOCFLAGS_T uiFlags,
-                            const IMG_CHAR *pszAnnotation,
-                            IMG_PID uiPid,
-                            PMR **ppsPMRPtr,
-                            IMG_UINT32 ui32PDumpFlags);
-
 #endif /* #ifndef SRVSRV_PHYSMEM_LMA_H */
diff --git a/drivers/gpu/drm/img-rogue/physmem_osmem.c b/drivers/gpu/drm/img-rogue/physmem_osmem.c
index c321840f9973..cef1ea620821 100644
--- a/drivers/gpu/drm/img-rogue/physmem_osmem.c
+++ b/drivers/gpu/drm/img-rogue/physmem_osmem.c
@@ -65,7 +65,7 @@ static IMG_UINT32 PhysHeapOSGetPageShift(void)
 static PHEAP_IMPL_FUNCS _sPHEAPImplFuncs =
 {
 	.pfnDestroyData = NULL,
-	.pfnGetPMRFactoryMemStats = PhysmemGetOSRamMemStats,
+	.pfnGetFactoryMemStats = PhysmemGetOSRamMemStats,
 	.pfnCreatePMR = PhysmemNewOSRamBackedPMR,
 	.pfnPagesAlloc = &OSPhyContigPagesAlloc,
 	.pfnPagesFree = &OSPhyContigPagesFree,
diff --git a/drivers/gpu/drm/img-rogue/physmem_osmem.h b/drivers/gpu/drm/img-rogue/physmem_osmem.h
index 28c64f1558b6..5e76513477b6 100644
--- a/drivers/gpu/drm/img-rogue/physmem_osmem.h
+++ b/drivers/gpu/drm/img-rogue/physmem_osmem.h
@@ -63,7 +63,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "physheap.h"
 
 /*************************************************************************/ /*!
-@Function       PhysmemCreateHeapLMA
+@Function       PhysmemCreateHeapOSMEM
 @Description    Create and register new OSMEM heap with OSMEM specific details.
 @Input          psDevNode    Pointer to device node struct.
 @Input          uiPolicy     Heap allocation policy flags
@@ -93,33 +93,33 @@ PhysmemCreateHeapOSMEM(PVRSRV_DEVICE_NODE *psDevNode,
                 system memory is not to be used in the OS port then the
                 implementation must return PVRSRV_ERROR_NOT_SUPPORTED.
 
-@Input          psPhysHeap       the phys heap
-@Input          psConnection     the connection to the originator process
-@Input          uiSize           the size of the allocation
+@Input          psPhysHeap       The phys heap
+@Input          psConnection     The connection to the originator process
+@Input          uiSize           The size of the allocation
                                  (must be a multiple of page size)
-@Input          ui32NumPhysChunks  when sparse allocations are requested,
-                                   this is the number of physical chunks
-                                   to be allocated.
-                                   For regular allocations, this will be 1.
-@Input          ui32NumVirtChunks  when sparse allocations are requested,
-                                   this is the number of virtual chunks
-                                   covering the sparse allocation.
-                                   For regular allocations, this will be 1.
-@Input          pui32MappingTable  when sparse allocations are requested,
+@Input          ui32NumPhysChunks     When sparse allocations are requested,
+                                      this is the number of physical chunks
+                                      to be allocated.
+                                      For regular allocations, this will be 1.
+@Input          ui32NumLogicalChunks  When sparse allocations are requested,
+                                      this is the number of logical chunks
+                                      covering the sparse allocation.
+                                      For regular allocations, this will be 1.
+@Input          pui32MappingTable  When sparse allocations are requested,
                                    this is the list of the indices of
                                    each physically-backed virtual chunk
                                    For regular allocations, this will
                                    be NULL.
-@Input          uiLog2PageSize   the physical pagesize in log2(bytes).
-@Input          uiFlags          the allocation flags.
-@Input          pszAnnotation    string describing the PMR (for debug).
-                                 This should be passed into the function
-                                 PMRCreatePMR().
-@Input          uiPid            The process ID that this allocation should
-                                 be associated with.
-@Output         ppsPMROut        pointer to the PMR created for the
-                                 new allocation
-@Input          ui32PDumpFlags   the pdump flags.
+@Input          uiLog2DevPageSize  The physical dev pagesize in log2(bytes).
+@Input          uiFlags            The allocation flags.
+@Input          pszAnnotation      String describing the PMR (for debug).
+                                   This should be passed into the function
+                                   PMRCreatePMR().
+@Input          uiPid              The process ID that this allocation should
+                                   be associated with.
+@Output         ppsPMROut          Pointer to the PMR created for the
+                                   new allocation
+@Input          ui32PDumpFlags     The pdump flags.
 @Return         PVRSRV_OK on success, a failure code otherwise.
 */ /**************************************************************************/
 PVRSRV_ERROR
@@ -127,9 +127,9 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
                          CONNECTION_DATA *psConnection,
                          IMG_DEVMEM_SIZE_T uiSize,
                          IMG_UINT32 ui32NumPhysChunks,
-                         IMG_UINT32 ui32NumVirtChunks,
+                         IMG_UINT32 ui32NumLogicalChunks,
                          IMG_UINT32 *pui32MappingTable,
-                         IMG_UINT32 uiLog2PageSize,
+                         IMG_UINT32 uiLog2DevPageSize,
                          PVRSRV_MEMALLOCFLAGS_T uiFlags,
                          const IMG_CHAR *pszAnnotation,
                          IMG_PID uiPid,
diff --git a/drivers/gpu/drm/img-rogue/physmem_osmem_linux.c b/drivers/gpu/drm/img-rogue/physmem_osmem_linux.c
index da6194baa724..69c2bd3f3909 100644
--- a/drivers/gpu/drm/img-rogue/physmem_osmem_linux.c
+++ b/drivers/gpu/drm/img-rogue/physmem_osmem_linux.c
@@ -54,6 +54,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <linux/gfp.h>
 #include <linux/sched.h>
 #include <linux/atomic.h>
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#include <linux/migrate.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+#include <drm/drm_file.h>
+#endif
+#endif
 
 #if defined(CONFIG_X86)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
@@ -64,7 +70,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif
 
 /* include/ */
-#include "rgx_heaps.h"
 #include "img_types.h"
 #include "img_defs.h"
 #include "pvr_debug.h"
@@ -85,6 +90,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "physmem_cpumap_history.h"
 #endif
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+/* services/server/env/linux */
+#include "env_connection.h"
+#endif
+#endif
+
 /* ourselves */
 #include "physmem_osmem.h"
 #include "physmem_osmem_linux.h"
@@ -99,22 +111,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "kernel_compatibility.h"
 #include "sysconfig.h"
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+
 static IMG_UINT32 g_uiMaxOrder = PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM;
-#else
-/* split_page not available on older kernels */
-#undef PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM
-#define PVR_LINUX_PHYSMEM_MAX_ALLOC_ORDER_NUM 0
-static IMG_UINT32 g_uiMaxOrder;
-#endif
 
-/*
-	These corresponds to the MMU min/max page sizes and associated PTE
-	alignment that can be used on the device for an allocation. It is
-	4KB (min) and 2MB (max) respectively.
-*/
-#define PVR_MIN_PHYSMEM_CONTIG_ALLOC_LOG2PGSZ	RGX_HEAP_4KB_PAGE_SHIFT
-#define PVR_MAX_PHYSMEM_CONTIG_ALLOC_LOG2PGSZ	RGX_HEAP_2MB_PAGE_SHIFT
 
 /* Defines how many pages should be mapped at once to the kernel */
 #define PVR_LINUX_PHYSMEM_MAX_KMAP_PAGES 1024 /* 4 MB */
@@ -124,12 +123,16 @@ static IMG_UINT32 g_uiMaxOrder;
 	to provide side-band information associated with that address.
 	These includes whether the address was obtained via alloc_page
 	or dma_alloc and if address came allocated pre-aligned or an
-	adjustment was made manually to aligned it.
+	adjustment was made manually to aligned it. They can also indicate
+	a page entry in the array has been generated by us for ease of mapping
+	and is part of a higher order page, this is known as a CMA Ghost.
 */
+#define DMA_SET_CMA_GHOST(x)			((x) | ((dma_addr_t)0x03))
+#define DMA_IS_CMA_GHOST(x)				(((x) & ((dma_addr_t)0x03)) == 0x03)
 #define DMA_SET_ADJUSTED_ADDR(x)		((x) | ((dma_addr_t)0x02))
-#define DMA_IS_ADDR_ADJUSTED(x)			((x) & ((dma_addr_t)0x02))
+#define DMA_IS_ADDR_ADJUSTED(x)			(((x) & ((dma_addr_t)0x02)) == 0x02)
 #define DMA_SET_ALLOCPG_ADDR(x)			((x) | ((dma_addr_t)0x01))
-#define DMA_IS_ALLOCPG_ADDR(x)			((x) & ((dma_addr_t)0x01))
+#define DMA_IS_ALLOCPG_ADDR(x)			(((x) & ((dma_addr_t)0x01)) == 0x01)
 #define DMA_GET_ALIGN_ADJUSTMENT(x)		((x>>2) & ((dma_addr_t)0x3ff))
 #define DMA_SET_ALIGN_ADJUSTMENT(x,y)	((x) | (((dma_addr_t)y)<<0x02))
 #define DMA_GET_ADDR(x)					(((dma_addr_t)x) & ((dma_addr_t)~0xfff))
@@ -140,6 +143,17 @@ static IMG_UINT32 g_uiMaxOrder;
 typedef struct _PMR_OSPAGEARRAY_DATA_ {
 	/* Device for which this allocation has been made */
 	PVRSRV_DEVICE_NODE *psDevNode;
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+
+	/* DRM Node associated with connection that made the allocation */
+	struct drm_file *psDRMFile;
+#endif
+	/* How many pages in the PMR are currently in process of migration */
+	ATOMIC_T iNumOSPagesUnderMigration;
+#endif
+
 	/* The pid that made this allocation */
 	IMG_PID uiPid;
 
@@ -158,14 +172,14 @@ typedef struct _PMR_OSPAGEARRAY_DATA_ {
 	IMG_UINT32 uiTotalNumOSPages;
 
 	/*
-	  uiLog2AllocPageSize;
+	  uiLog2DevPageSize;
 
-	  size of each "page" -- this would normally be the same as
+	  size of each requested device "page" -- this would normally be the same as
 	  PAGE_SHIFT, but we support the idea that we may allocate pages
 	  in larger chunks for better contiguity, using order>0 in the
 	  call to alloc_pages()
 	*/
-	IMG_UINT32 uiLog2AllocPageSize;
+	IMG_UINT32 uiLog2DevPageSize;
 
 	/*
 	  ui64DmaMask;
@@ -188,10 +202,14 @@ typedef struct _PMR_OSPAGEARRAY_DATA_ {
 #define FLAG_POISON_ON_ALLOC   (2U)
 #define FLAG_ONDEMAND          (3U)
 
-#define FLAG_IS_CMA            (5U)
+/* IS CMA ensures the allocation will go through the dma_alloc_coherent path */
+#define FLAG_DMA_CMA           (5U)
 #define FLAG_UNSET_MEMORY_TYPE (6U)
 
 #define FLAG_IS_ZOMBIE         (7U)
+/* Pref CMA appends a flag (if exists) to hint alloc_pages should source from CMA region */
+#define FLAG_PREF_CMA          (8U)
+#define FLAG_IS_MOVABLE        (9U)
 
 	/*
 	 * Allocation flags related to the pages:
@@ -219,15 +237,22 @@ typedef struct _PMR_OSPAGEARRAY_DATA_ {
 	 * variable and are accounted for in the memory statistics */
 	IMG_UINT32 ui32CMAAdjustedPageCount;
 
-#if defined(PVRSRV_PHYSMEM_CPUMAP_HISTORY)
 	/*
 	  Handle on the parent PMR
 	 */
-	void *hPMR;
-#endif
+	PMR *hPMR;
 
 } PMR_OSPAGEARRAY_DATA;
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+typedef struct _OSMEM_PAGE_PRIVDATA_
+{
+	PMR_OSPAGEARRAY_DATA *psPMRData;
+	/* Store index of entry to speed up migration */
+	IMG_UINT32 uiPMRArrIdx;
+} OSMEM_PAGE_PRIVDATA;
+#endif
+
 /***********************************
  * Page pooling for uncached pages *
  ***********************************/
@@ -243,6 +268,7 @@ _FreeOSPage_CMA(struct device *dev,
 static void
 _FreeOSPage(IMG_UINT32 uiOrder,
 			IMG_BOOL bUnsetMemoryType,
+			PMR_OSPAGEARRAY_DATA *psPageArrayData,
 			struct page *psPage);
 
 static PVRSRV_ERROR
@@ -254,6 +280,13 @@ static PVRSRV_ERROR
 _FreePagesFromPoolUnlocked(IMG_UINT32 uiMaxPagesToFree,
 						   IMG_UINT32 *puiPagesFreed);
 
+static inline PVRSRV_ERROR
+_ApplyOSPagesAttribute(PVRSRV_DEVICE_NODE *psDevNode,
+					   struct page **ppsPage,
+					   IMG_UINT32 uiNumPages,
+					   IMG_BOOL bFlush,
+					   IMG_UINT32 ui32CPUCacheFlags);
+
 /* A struct for our page pool holding an array of zeroed (!) pages.
  * We always put units of page arrays to the pool but are
  * able to take individual pages */
@@ -281,6 +314,9 @@ typedef struct
 /* Caches to hold page pool and page array structures */
 static struct kmem_cache *g_psLinuxPagePoolCache;
 static struct kmem_cache *g_psLinuxPageArray;
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+static struct kmem_cache *g_psLinuxPagePrivateData;
+#endif
 
 /* Track what is live, all protected by pool lock.
  * x86 needs two page pools because we have to change the memory attributes
@@ -337,14 +373,315 @@ static DEFINE_MUTEX(g_sPagePoolMutex);
 static LIST_HEAD(g_sPagePoolList_WC);
 static LIST_HEAD(g_sPagePoolList_UC);
 
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-/* Global structure to manage GPU memory leak */
-static DEFINE_MUTEX(g_sUMALeakMutex);
-static IMG_UINT32 g_ui32UMALeakCounter = 0;
-#endif
 
 static IMG_BOOL g_bInitialisedOnAlloc = IMG_FALSE;
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+
+static bool OSMemPageIsolate(struct page *psPage, isolate_mode_t uIsolateMode);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+static int OSMemPageMigrate(struct address_space *psAddrSpace,
+		struct page *psDstPage, struct page *psSrcPage, enum migrate_mode eMigrateMode);
+#else
+static int OSMemPageMigrate(struct page *psDstPage, struct page *psSrcPage, enum migrate_mode eMigrateMode);
+#endif
+static void OSMemPagePutback(struct page *psPage);
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION_DEBUG)
+#define MIGRATE_DBG_LOG(x) PVR_DPF(x);
+#else
+#define MIGRATE_DBG_LOG(...)
+#endif
+
+static INLINE OSMEM_PAGE_PRIVDATA* GetPrivateDataFromPage(struct page* psPage)
+{
+	return (OSMEM_PAGE_PRIVDATA*) page_private(psPage);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+static const struct address_space_operations movable_callbacks =
+{
+	.isolate_page = OSMemPageIsolate,
+	.migratepage = OSMemPageMigrate,
+	.putback_page = OSMemPagePutback
+
+};
+#else
+static const struct movable_operations movable_callbacks =
+{
+	.isolate_page = OSMemPageIsolate,
+	.migrate_page = OSMemPageMigrate,
+	.putback_page = OSMemPagePutback
+};
+#endif
+
+static bool OSMemPageIsolate(struct page *psPage, isolate_mode_t uIsolateMode)
+{
+	OSMEM_PAGE_PRIVDATA *psPrivData = GetPrivateDataFromPage(psPage);
+
+
+	PVR_GOTO_IF_FALSE(psPrivData != NULL, condition_failed);
+
+	/* Attempt to migrate pages before PMR wrapper has been setup,
+	 * avoid migration at this time.
+	 */
+	PVR_GOTO_IF_FALSE(psPrivData->psPMRData->hPMR, condition_failed);
+
+	OSAtomicAdd(&psPrivData->psPMRData->iNumOSPagesUnderMigration, 1);
+	PVR_GOTO_IF_FALSE(!PMR_IsGpuMapped(psPrivData->psPMRData->hPMR), condition_failed);
+	PVR_GOTO_IF_FALSE(!PMR_IsCpuMapped(psPrivData->psPMRData->hPMR), condition_failed);
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	PVR_GOTO_IF_FALSE(!PMR_IsZombie(psPrivData->psPMRData->hPMR), condition_failed);
+#endif
+	/* Try take a ref on PMR, this ensures destruction will not occur while migrating */
+	PVR_GOTO_IF_ERROR(PMRTryRefPMR(psPrivData->psPMRData->hPMR), condition_failed);
+
+
+	psPrivData->psPMRData->pagearray[psPrivData->uiPMRArrIdx] = NULL;
+
+	MIGRATE_DBG_LOG((PVR_DBG_ERROR, "Isolated: PMR UID %llu, PMR Size 0x%llx, "
+	                                "OSPageSize %lu, PageAddr 0x%llx",
+	                                PMRInternalGetUID(psPrivData->psPMRData->hPMR),
+	                                (unsigned long long) PMR_LogicalSize(psPrivData->psPMRData->hPMR),
+	                                OSGetPageSize(),
+	                                (unsigned long long) psPage));
+
+	/* Movable */
+	return true;
+
+condition_failed:
+	/* Not movable */
+	OSAtomicSubtract(&psPrivData->psPMRData->iNumOSPagesUnderMigration, 1);
+
+	return false;
+}
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+static int OSMemPageMigrate(struct address_space *psAddrSpace,
+		struct page *psDstPage, struct page *psSrcPage, enum migrate_mode eMigrateMode)
+#else
+static int OSMemPageMigrate(struct page *psDstPage, struct page *psSrcPage, enum migrate_mode eMigrateMode)
+#endif
+{
+	void* vpDst;
+	void* vpSrc;
+	PMR_OSPAGEARRAY_DATA *psPMRData;
+	OSMEM_PAGE_PRIVDATA *psSrcPagePrivData = GetPrivateDataFromPage(psSrcPage);
+
+	if (!psSrcPagePrivData)
+	{
+		/* Shouldn't hit this case */
+		PVR_DPF((PVR_DBG_ERROR, "Migrate invalid, potentially leaked PMR"));
+		return -EINVAL;
+	}
+	psPMRData = psSrcPagePrivData->psPMRData;
+
+	PVR_UNREFERENCED_PARAMETER(eMigrateMode);
+
+	vpDst = kmap(psDstPage);
+	vpSrc = kmap(psSrcPage);
+
+
+	OSDeviceMemCopy(vpDst, vpSrc, PAGE_SIZE);
+
+	kunmap(vpDst);
+	kunmap(vpSrc);
+
+#if defined(CONFIG_X86)
+	/* Reset caching attrs of page we give back to OS */
+	if (!set_pages_array_wb(&psSrcPage, 1))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attribute PMR UID:%llu",
+		         __func__,
+		         (unsigned long long)PMRInternalGetUID(psSrcPagePrivData->psPMRData->hPMR)));
+		return -EINVAL;
+	}
+#endif
+
+	psPMRData->pagearray[psSrcPagePrivData->uiPMRArrIdx] = psDstPage;
+
+	MIGRATE_DBG_LOG((PVR_DBG_ERROR, "Migrated: PMR UID %llu, PMR Size 0x%llx, "
+	                                "OSPageSize %lu, SrcPageAddr 0x%llx, DstPageAddr 0x%llx",
+	                                PMRInternalGetUID(psSrcPagePrivData->psPMRData->hPMR),
+	                                (unsigned long long) PMR_LogicalSize(psSrcPagePrivData->psPMRData->hPMR),
+	                                OSGetPageSize(),
+	                                (unsigned long long) psSrcPage,
+	                                (unsigned long long) psDstPage));
+
+	/* Apply caching reqs to page we receive from OS */
+	_ApplyOSPagesAttribute(psPMRData->psDevNode,
+	                       &psPMRData->pagearray[psSrcPagePrivData->uiPMRArrIdx],
+	                       1,
+	                       IMG_FALSE,
+	                       psPMRData->ui32CPUCacheFlags);
+
+	get_page(psDstPage);
+	SetPagePrivate(psDstPage);
+	set_page_private(psDstPage, (unsigned long)psSrcPagePrivData);
+
+	/* DstPage already locked prior to callback */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+	__SetPageMovable(psDstPage, psPMRData->psDRMFile->filp->f_inode->i_mapping);
+#else
+	__SetPageMovable(psDstPage, &movable_callbacks);
+#endif
+
+	set_page_private(psSrcPage, 0);
+	ClearPagePrivate(psSrcPage);
+	put_page(psSrcPage);
+	__ClearPageMovable(psSrcPage);
+
+	/* Migration for this page no longer in progress */
+	OSAtomicSubtract(&psSrcPagePrivData->psPMRData->iNumOSPagesUnderMigration, 1);
+
+	/* Unref parent PMR to allow for subsequent destruction,
+	 * if PMR resource no longer required and the bridge has
+	 * dropped its handles to it, destruction will follow.
+	 */
+	PMRUnrefPMR2(psSrcPagePrivData->psPMRData->hPMR);
+
+	return MIGRATEPAGE_SUCCESS;
+}
+
+static void OSMemPagePutback(struct page *psPage)
+{
+	OSMEM_PAGE_PRIVDATA *psPrivData = GetPrivateDataFromPage(psPage);
+	if (!psPrivData)
+	{
+		/* We shouldn't hit this case */
+		PVR_DPF((PVR_DBG_ERROR, "Putback invalid, potentially leaked PMR"));
+		return;
+	}
+
+	MIGRATE_DBG_LOG((PVR_DBG_ERROR, "Putback: PMR UID %llu, PMR Size 0x%llx, "
+	                                "OSPageSize %lu, PageAddr 0x%llx",
+	                                PMRInternalGetUID(psPrivData->psPMRData->hPMR),
+	                                (unsigned long long) PMR_LogicalSize(psPrivData->psPMRData->hPMR),
+	                                OSGetPageSize(),
+	                                (unsigned long long) psPage));
+
+
+	/* Restore the page to our structures */
+	psPrivData->psPMRData->pagearray[psPrivData->uiPMRArrIdx] = psPage;
+
+	/* Migration for this page no longer in progress */
+	OSAtomicSubtract(&psPrivData->psPMRData->iNumOSPagesUnderMigration, 1);
+
+	/* Unref surrounding PMR as we no longer need the PMR to remain in case of array access.
+	 */
+	PMRUnrefPMR2(psPrivData->psPMRData->hPMR);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+int LinuxRegisterMigrateCallbacks(struct file* filp)
+{
+	if (filp == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "filp NULL, cannot set movable callbacks, PID %u:%s",
+		                        OSGetCurrentClientProcessIDKM(),
+		                        OSGetCurrentClientProcessNameKM()));
+		return -EINVAL;
+	}
+
+	filp->f_inode->i_mapping->a_ops = &movable_callbacks;
+
+	return 0;
+}
+
+void LinuxDeregisterMigrateCallbacks(struct file* filp)
+{
+	if (filp == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "filp NULL, cannot unset movable callbacks"));
+		return;
+	}
+
+	filp->f_inode->i_mapping->a_ops = NULL;
+}
+#endif
+
+
+static INLINE void OSMemSetMovablePageAttr(struct page* psPage,
+                                           PMR_OSPAGEARRAY_DATA *psPageArrayData,
+                                           IMG_UINT32 uiPageIndex)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+	struct drm_file *psDRMFile = psPageArrayData->psDRMFile;
+#endif
+	OSMEM_PAGE_PRIVDATA *psPrivData;
+
+	if (!BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_MOVABLE))
+	{
+		return;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+	/* Allocations marked with movable may occur before we have a valid connection
+	 * and thus DRM file. In this case ignore the request. An example of this would be
+	 * a kernel originated request which wouldn't have a connection associated.
+	 */
+	if (!psDRMFile)
+	{
+		PVR_ASSERT(!"Attempt to make allocation movable without connection associated, "
+		            "possible server origin");
+		return;
+	}
+#endif
+
+	psPrivData = kmem_cache_alloc(g_psLinuxPagePrivateData, GFP_KERNEL);
+	if (psPrivData == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s: OS refused the memory allocation for the private page data. "
+		         "Page will not be marked movable. PMR UID:%llu",
+				 __func__,
+				 PMRInternalGetUID(psPrivData->psPMRData->hPMR)));
+		return;
+	}
+
+	psPrivData->psPMRData = psPageArrayData;
+	psPrivData->uiPMRArrIdx = uiPageIndex;
+
+	SetPagePrivate(psPage);
+	set_page_private(psPage, (unsigned long)psPrivData);
+
+	/* Take page lock here while we set movable as __SetPageMovable asserts it */
+	lock_page(psPage);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+	__SetPageMovable(psPage, psDRMFile->filp->f_inode->i_mapping);
+#else
+	__SetPageMovable(psPage, &movable_callbacks);
+#endif
+	unlock_page(psPage);
+}
+
+static INLINE void OSMemUnsetMovablePageAttr(struct page* psPage, PMR_OSPAGEARRAY_DATA *psPageArrayData)
+{
+	OSMEM_PAGE_PRIVDATA *psPrivData;
+
+	if (!BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_MOVABLE))
+	{
+		return;
+	}
+
+	/* Private data should only be set if page is movable */
+	psPrivData = GetPrivateDataFromPage(psPage);
+	if (!psPrivData)
+	{
+		return;
+	}
+
+	lock_page(psPage);
+	__ClearPageMovable(psPage);
+	set_page_private(psPage, 0);
+	ClearPagePrivate(psPage);
+	unlock_page(psPage);
+
+	kmem_cache_free(g_psLinuxPagePrivateData, psPrivData);
+}
+#endif /* defined(SUPPORT_LINUX_OSPAGE_MIGRATION) */
+
 static inline IMG_BOOL
 _ShouldInitMem(IMG_UINT32 ui32AllocFlags)
 {
@@ -417,7 +754,12 @@ _GetPoolListHead(IMG_UINT32 ui32CPUCacheFlags,
 	return IMG_TRUE;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
 static struct shrinker g_sShrinker;
+static struct shrinker *g_psShrinker = &g_sShrinker;
+#else
+static struct shrinker *g_psShrinker;
+#endif
 
 /* Returning the number of pages that still reside in the page pool. */
 static unsigned long
@@ -433,7 +775,7 @@ _CountObjectsInPagePool(struct shrinker *psShrinker, struct shrink_control *psSh
 {
 	int remain;
 
-	PVR_ASSERT(psShrinker == &g_sShrinker);
+	PVR_ASSERT(psShrinker == g_psShrinker);
 	(void)psShrinker;
 	(void)psShrinkControl;
 
@@ -453,7 +795,7 @@ _ScanObjectsInPagePool(struct shrinker *psShrinker, struct shrink_control *psShr
 	unsigned long uNumToScan = psShrinkControl->nr_to_scan;
 	IMG_UINT32 uiPagesFreed;
 
-	PVR_ASSERT(psShrinker == &g_sShrinker);
+	PVR_ASSERT(psShrinker == g_psShrinker);
 	(void)psShrinker;
 
 	/* In order to avoid possible deadlock use mutex_trylock in place of mutex_lock */
@@ -464,41 +806,12 @@ _ScanObjectsInPagePool(struct shrinker *psShrinker, struct shrink_control *psShr
 							   &uiPagesFreed);
 	uNumToScan -= uiPagesFreed;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
-	{
-		int remain;
-		remain = _GetNumberOfPagesInPoolUnlocked();
-		_PagePoolUnlock();
-		return remain;
-	}
-#else
 	/* Returning the number of pages freed during the scan */
 	_PagePoolUnlock();
 	return psShrinkControl->nr_to_scan - uNumToScan;
-#endif
-}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
-static int
-_ShrinkPagePool(struct shrinker *psShrinker, struct shrink_control *psShrinkControl)
-{
-	if (psShrinkControl->nr_to_scan != 0)
-	{
-		return _ScanObjectsInPagePool(psShrinker, psShrinkControl);
-	}
-	else
-	{
-		/* No pages are being reclaimed so just return the page count */
-		return _CountObjectsInPagePool(psShrinker, psShrinkControl);
-	}
 }
 
-static struct shrinker g_sShrinker =
-{
-	.shrink = _ShrinkPagePool,
-	.seeks = DEFAULT_SEEKS
-};
-#else
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
 static struct shrinker g_sShrinker =
 {
 	.count_objects = _CountObjectsInPagePool,
@@ -508,15 +821,51 @@ static struct shrinker g_sShrinker =
 #endif
 
 /* Register the shrinker so Linux can reclaim cached pages */
-void LinuxInitPhysmem(void)
+PVRSRV_ERROR LinuxInitPhysmem(void)
 {
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	g_psLinuxPagePrivateData = kmem_cache_create("pvr-ppd", sizeof(OSMEM_PAGE_PRIVDATA), 0, 0, NULL);
+	if (!g_psLinuxPagePrivateData)
+	{
+		PVR_LOG_GOTO_WITH_ERROR("kmem_cache_create() g_psLinuxPagePrivateData",
+		                        eError, PVRSRV_ERROR_OUT_OF_MEMORY, e1);
+	}
+#endif
+
 	g_psLinuxPageArray = kmem_cache_create("pvr-pa", sizeof(PMR_OSPAGEARRAY_DATA), 0, 0, NULL);
+	if (!g_psLinuxPageArray)
+	{
+		PVR_LOG_GOTO_WITH_ERROR("kmem_cache_create() g_psLinuxPageArray",
+		                        eError, PVRSRV_ERROR_OUT_OF_MEMORY, e2);
+	}
 
 	g_psLinuxPagePoolCache = kmem_cache_create("pvr-pp", sizeof(LinuxPagePoolEntry), 0, 0, NULL);
 	if (g_psLinuxPagePoolCache)
 	{
 		/* Only create the shrinker if we created the cache OK */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
 		register_shrinker(&g_sShrinker, "pvr-pp");
+#else
+		g_psShrinker = shrinker_alloc(0, "pvr-pp");
+		if (g_psShrinker)
+		{
+			g_psShrinker->count_objects = _CountObjectsInPagePool;
+			g_psShrinker->scan_objects = _ScanObjectsInPagePool;
+			g_psShrinker->seeks = DEFAULT_SEEKS;
+			shrinker_register(g_psShrinker);
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Unable to allocate a shrinker for page pool cache"));
+		}
+#endif
+	}
+	else
+	{
+		PVR_LOG_GOTO_WITH_ERROR("kmem_cache_create() g_psLinuxPagePoolCache",
+		                        eError, PVRSRV_ERROR_OUT_OF_MEMORY, e3);
 	}
 
 	OSAtomicWrite(&g_iPoolCleanTasks, 0);
@@ -539,6 +888,20 @@ void LinuxInitPhysmem(void)
 	g_bInitialisedOnAlloc = IMG_FALSE;
 #endif
 #endif
+
+	return PVRSRV_OK;
+
+e3:
+	/* Free the page array */
+	kmem_cache_destroy(g_psLinuxPageArray);
+e2:
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	/* Free the page private data */
+	kmem_cache_destroy(g_psLinuxPagePrivateData);
+e1:
+#endif
+
+	return eError;
 }
 
 /* Unregister the shrinker and remove all pages from the pool that are still left */
@@ -563,12 +926,23 @@ void LinuxDeinitPhysmem(void)
 	PVR_ASSERT(_PagesInPoolUnlocked() == 0);
 
 	/* Free the page cache */
-	kmem_cache_destroy(g_psLinuxPagePoolCache);
+	if (g_psLinuxPagePoolCache)
+		kmem_cache_destroy(g_psLinuxPagePoolCache);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
 	unregister_shrinker(&g_sShrinker);
+#else
+	shrinker_free(g_psShrinker);
+#endif
 	_PagePoolUnlock();
 
-	kmem_cache_destroy(g_psLinuxPageArray);
+	if (g_psLinuxPageArray)
+		kmem_cache_destroy(g_psLinuxPageArray);
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	if (g_psLinuxPagePrivateData)
+		kmem_cache_destroy(g_psLinuxPagePrivateData);
+#endif
 }
 
 static void EnableOOMKiller(void)
@@ -842,17 +1216,15 @@ _GetPagesFromPoolUnlocked(IMG_UINT32 ui32CPUCacheFlags,
 static inline void
 _GetPagesFromPoolLocked(PVRSRV_DEVICE_NODE *psDevNode,
 						IMG_UINT32 ui32CPUCacheFlags,
+						IMG_UINT32 ui32AllocFlags,
 						IMG_UINT32 uiPagesToAlloc,
 						IMG_UINT32 uiOrder,
-						IMG_BOOL bZero,
 						struct page **ppsPageArray,
 						IMG_UINT32 *puiPagesFromPool)
 {
-#if defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
-	PVR_UNREFERENCED_PARAMETER(bZero);
-#else
-	/* Don't get pages from pool if it doesn't provide zeroed pages */
-	if (bZero)
+#if !defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
+	/* Don't get pages from pool as it doesn't provide zeroed pages */
+	if (BIT_ISSET(ui32AllocFlags, FLAG_ZERO))
 	{
 		return;
 	}
@@ -860,9 +1232,13 @@ _GetPagesFromPoolLocked(PVRSRV_DEVICE_NODE *psDevNode,
 
 	/* The page pool stores only order 0 pages. If we need zeroed memory we
 	 * directly allocate from the OS because it is faster than
-	 * doing it within the driver. */
+	 * doing it within the driver. CMA is naturally more commonly used for higher
+	 * order pages and so we reject that also.
+	 */
 	if (uiOrder == 0 &&
-	    !PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags))
+	    !PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags) &&
+	    !BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA) &&
+	    !BIT_ISSET(ui32AllocFlags, FLAG_IS_MOVABLE))
 	{
 
 		_PagePoolLock();
@@ -1029,7 +1405,7 @@ _CleanupThread_CleanPages(void *pvData)
 
 	for (i = 0; i < psCleanupData->psPoolEntry->uiItemsRemaining; i++)
 	{
-		_FreeOSPage(0, IMG_TRUE, psPagePoolEntry->ppsPageArray[i]);
+		_FreeOSPage(0, IMG_TRUE, NULL, psPagePoolEntry->ppsPageArray[i]);
 	}
 	OSFreeMemNoStats(psPagePoolEntry->ppsPageArray);
 	kmem_cache_free(g_psLinuxPagePoolCache, psPagePoolEntry);
@@ -1041,6 +1417,35 @@ _CleanupThread_CleanPages(void *pvData)
 #endif /* defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES) */
 }
 
+static bool _PagesHaveOtherRefs(struct page **ppsPageArray, IMG_UINT32 uiNumPages)
+{
+	IMG_UINT32 ui32pageIndex;
+
+	PVR_DPF_ENTERED;
+
+	if (!ppsPageArray)
+	{
+		PVR_DPF_RETURN_RC(false);
+	}
+
+	/* Iterate pages in ppsPageArray and return
+	   false if any are found to have page_count() > 1
+	*/
+	for (ui32pageIndex = 0; ui32pageIndex < uiNumPages; ui32pageIndex++)
+	{
+		struct page *psPage = ppsPageArray[ui32pageIndex];
+
+		if (page_count(psPage) > 1)
+		{
+			PVR_DPF((PVR_DBG_MESSAGE,
+			         "%s: page %d in page array found with page_count() of %d",
+			         __func__, ui32pageIndex, page_count(psPage)));
+			PVR_DPF_RETURN_RC(true);
+		}
+	}
+
+	PVR_DPF_RETURN_RC(false);
+}
 
 /* Put page array to the page pool.
  * Handles locking and checks whether the pages are
@@ -1048,111 +1453,118 @@ _CleanupThread_CleanPages(void *pvData)
 static inline IMG_BOOL
 _PutPagesToPoolLocked(PVRSRV_DEVICE_NODE *psDevNode,
                       IMG_UINT32 ui32CPUCacheFlags,
+                      IMG_UINT32 ui32AllocFlags,
                       struct page **ppsPageArray,
                       IMG_UINT32 uiOrder,
                       IMG_UINT32 uiNumPages)
 {
 	LinuxCleanupData *psCleanupData;
 	PVRSRV_CLEANUP_THREAD_WORK *psCleanupThreadFn;
+	IMG_UINT32 uiEntries;
+	IMG_UINT32 *puiCounter;
+	struct list_head *psPoolHead;
 #if defined(SUPPORT_PHYSMEM_TEST)
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 #endif
 
-	if (uiOrder == 0 &&
-		!PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags))
+	PVR_DPF_ENTERED;
+
+	/* The page pool stores only order 0 pages. CMA is naturally more
+	 * commonly used for higher order pages and so we reject that also.
+	 */
+	if (uiOrder != 0 ||
+		PVRSRV_CHECK_CPU_CACHED(ui32CPUCacheFlags) ||
+		BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA) ||
+		BIT_ISSET(ui32AllocFlags, FLAG_IS_MOVABLE))
 	{
-		IMG_UINT32 uiEntries;
-		IMG_UINT32 *puiCounter;
-		struct list_head *psPoolHead;
+		goto eExitFalse;
+	}
 
+	if (_PagesHaveOtherRefs(ppsPageArray, uiNumPages))
+	{
+		/* Pages still have other references, so
+		   must not be put into our pool */
+		goto eExitFalse;
+	}
 
-		_PagePoolLock();
+	_PagePoolLock();
 
-		uiEntries = _PagesInPoolUnlocked();
+	uiEntries = _PagesInPoolUnlocked();
+
+	/* Check for number of current page pool entries */
+	if ( (uiEntries >= g_ui32PagePoolMaxEntries) ||
+		 ((uiEntries + uiNumPages) >=
+		  (g_ui32PagePoolMaxEntries + g_ui32PagePoolMaxExcessEntries) ))
+	{
+		goto eUnlock;
+	}
+
+	/* Check for whether we have other asynchronous tasks in-flight */
+	if (OSAtomicIncrement(&g_iPoolCleanTasks) >
+			PVR_LINUX_PHYSMEM_MAX_ASYNC_CLEAN_TASKS)
+	{
+		goto eDecrement;
+	}
 
-		/* Check for number of current page pool entries and whether
-		 * we have other asynchronous tasks in-flight */
-		if ( (uiEntries < g_ui32PagePoolMaxEntries) &&
-		     ((uiEntries + uiNumPages) <
-		      (g_ui32PagePoolMaxEntries + g_ui32PagePoolMaxExcessEntries) ))
-		{
-			if (OSAtomicIncrement(&g_iPoolCleanTasks) <=
-					PVR_LINUX_PHYSMEM_MAX_ASYNC_CLEAN_TASKS)
-			{
 #if defined(SUPPORT_PHYSMEM_TEST)
-				if (!psPVRSRVData->hCleanupThread)
-				{
-					goto eDecrement;
-				}
+	if (!psPVRSRVData->hCleanupThread)
+	{
+		goto eDecrement;
+	}
 #endif
 
-				psCleanupData = OSAllocMem(sizeof(*psCleanupData));
-
-				if (!psCleanupData)
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get memory for deferred page pool cleanup. "
-							 "Trying to free pages immediately",
-							 __func__));
-					goto eDecrement;
-				}
+	psCleanupData = OSAllocMem(sizeof(*psCleanupData));
 
-				psCleanupThreadFn = &psCleanupData->sCleanupWork;
-				psCleanupData->ui32CPUCacheMode = ui32CPUCacheFlags;
-				psCleanupData->psPoolEntry = kmem_cache_alloc(g_psLinuxPagePoolCache, GFP_KERNEL);
+	if (!psCleanupData)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s: Failed to get memory for deferred page pool cleanup. "
+				 "Trying to free pages immediately",
+				 __func__));
+		goto eDecrement;
+	}
 
-				if (!psCleanupData->psPoolEntry)
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get memory for deferred page pool cleanup. "
-							 "Trying to free pages immediately",
-							 __func__));
-					goto eFreeCleanupData;
-				}
+	psCleanupThreadFn = &psCleanupData->sCleanupWork;
+	psCleanupData->ui32CPUCacheMode = ui32CPUCacheFlags;
+	psCleanupData->psPoolEntry = kmem_cache_alloc(g_psLinuxPagePoolCache, GFP_KERNEL);
 
-				if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead, &puiCounter))
-				{
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failed to get correct page pool",
-							 __func__));
-					goto eFreePoolEntry;
-				}
+	if (!psCleanupData->psPoolEntry)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s: Failed to get memory for deferred page pool cleanup. "
+				 "Trying to free pages immediately",
+				 __func__));
+		goto eFreeCleanupData;
+	}
 
-				/* Increase counter here to avoid deferred cleanup tasks piling up */
-				*puiCounter = *puiCounter + uiNumPages;
+	if (!_GetPoolListHead(ui32CPUCacheFlags, &psPoolHead, &puiCounter))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s: Failed to get correct page pool",
+				 __func__));
+		goto eFreePoolEntry;
+	}
 
-				psCleanupData->psPoolEntry->ppsPageArray = ppsPageArray;
-				psCleanupData->psPoolEntry->uiItemsRemaining = uiNumPages;
+	/* Increase counter here to avoid deferred cleanup tasks piling up */
+	*puiCounter = *puiCounter + uiNumPages;
 
-				psCleanupThreadFn->pfnFree = _CleanupThread_CleanPages;
-				psCleanupThreadFn->pvData = psCleanupData;
-				psCleanupThreadFn->bDependsOnHW = IMG_FALSE;
-				psCleanupThreadFn->eCleanupType = PVRSRV_CLEANUP_TYPE_OSMEM;
-				CLEANUP_THREAD_SET_RETRY_COUNT(psCleanupThreadFn,
-				                               CLEANUP_THREAD_RETRY_COUNT_DEFAULT);
+	psCleanupData->psPoolEntry->ppsPageArray = ppsPageArray;
+	psCleanupData->psPoolEntry->uiItemsRemaining = uiNumPages;
 
-				/* We must not hold the pool lock when calling AddWork because it might call us back to
-				 * free pooled pages directly when unloading the driver	 */
-				_PagePoolUnlock();
+	psCleanupThreadFn->pfnFree = _CleanupThread_CleanPages;
+	psCleanupThreadFn->pvData = psCleanupData;
+	psCleanupThreadFn->bDependsOnHW = IMG_FALSE;
+	psCleanupThreadFn->eCleanupType = PVRSRV_CLEANUP_TYPE_OSMEM;
+	CLEANUP_THREAD_SET_RETRY_COUNT(psCleanupThreadFn,
+								   CLEANUP_THREAD_RETRY_COUNT_DEFAULT);
 
-				PVRSRVCleanupThreadAddWork(psDevNode, psCleanupThreadFn);
-			}
-			else
-			{
-				goto eDecrement;
-			}
-		}
-		else
-		{
-			goto eUnlock;
-		}
-	}
-	else
-	{
-		goto eExitFalse;
-	}
+	/* We must not hold the pool lock when calling AddWork because it might call us back to
+	 * free pooled pages directly when unloading the driver	 */
+	_PagePoolUnlock();
 
-	return IMG_TRUE;
+	PVRSRVCleanupThreadAddWork(psDevNode, psCleanupThreadFn);
+
+	PVR_DPF_RETURN_RC(IMG_TRUE);
 
 eFreePoolEntry:
 	OSFreeMem(psCleanupData->psPoolEntry);
@@ -1163,16 +1575,47 @@ _PutPagesToPoolLocked(PVRSRV_DEVICE_NODE *psDevNode,
 eUnlock:
 	_PagePoolUnlock();
 eExitFalse:
-	return IMG_FALSE;
+	PVR_DPF_RETURN_RC(IMG_FALSE);
 }
 
 /* Get the GFP flags that we pass to the page allocator */
 static inline gfp_t
-_GetGFPFlags(IMG_BOOL bZero,
-             PVRSRV_DEVICE_NODE *psDevNode)
+_GetGFPFlags(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 {
-	struct device *psDev = psDevNode->psDevConfig->pvOSDevice;
-	gfp_t gfp_flags = GFP_USER | __GFP_NOWARN | __GFP_NOMEMALLOC;
+	/* If higher order pages then potentially ask the kernel to zero the allocation
+	 * for us. If zero order we can do it ourselves later in a batch operation
+	 */
+	IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+	IMG_BOOL bZero = uiOrder ? _ShouldInitMem(psPageArrayData->ui32AllocFlags) : IMG_FALSE;
+	struct device *psDev = psPageArrayData->psDevNode->psDevConfig->pvOSDevice;
+
+	gfp_t gfp_flags = __GFP_NOWARN | __GFP_NOMEMALLOC;
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_MOVABLE))
+	{
+		gfp_flags |= GFP_HIGHUSER_MOVABLE;
+	}
+	else
+#else
+	{
+		gfp_flags |= GFP_USER;
+	}
+#endif
+
+#if defined(ANDROID)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)) && \
+	(LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+	/* Only Android has CMA suggestion flag, base Linux kernel uses heuristics based on memory
+	 * pressure / availability to achieve similar goal.
+	 */
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_PREF_CMA))
+	{
+		gfp_flags |= __GFP_CMA;
+	}
+#endif
+#endif
 
 #if defined(PVR_LINUX_PHYSMEM_USE_HIGHMEM_ONLY)
 	/* Force use of HIGHMEM */
@@ -1272,9 +1715,7 @@ _PoisonDevicePage(PVRSRV_DEVICE_NODE *psDevNode,
 static PVRSRV_ERROR
 _AllocOSPageArray(PVRSRV_DEVICE_NODE *psDevNode,
 				  PMR_SIZE_T uiSize,
-				  IMG_UINT32 ui32NumPhysChunks,
-				  IMG_UINT32 ui32NumVirtChunks,
-				  IMG_UINT32 uiLog2AllocPageSize,
+				  IMG_UINT32 uiLog2DevPageSize,
 				  IMG_UINT32 ui32AllocFlags,
 				  IMG_UINT32 ui32CPUCacheFlags,
 				  IMG_PID uiPid,
@@ -1282,18 +1723,14 @@ _AllocOSPageArray(PVRSRV_DEVICE_NODE *psDevNode,
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT32 uiNumOSPageSizeVirtPages;
-	IMG_UINT32 uiNumDevPageSizeVirtPages;
 	PMR_OSPAGEARRAY_DATA *psPageArrayData;
 	IMG_UINT64 ui64DmaMask = 0;
-	PVR_UNREFERENCED_PARAMETER(ui32NumPhysChunks);
 
 	/* Use of cast below is justified by the assertion that follows to
 	 * prove that no significant bits have been truncated */
 	uiNumOSPageSizeVirtPages = (IMG_UINT32) (((uiSize - 1) >> PAGE_SHIFT) + 1);
 	PVR_ASSERT(((PMR_SIZE_T) uiNumOSPageSizeVirtPages << PAGE_SHIFT) == uiSize);
 
-	uiNumDevPageSizeVirtPages = uiNumOSPageSizeVirtPages >> (uiLog2AllocPageSize - PAGE_SHIFT);
-
 	/* Allocate the struct to hold the metadata */
 	psPageArrayData = kmem_cache_alloc(g_psLinuxPageArray, GFP_KERNEL);
 	if (psPageArrayData == NULL)
@@ -1316,37 +1753,36 @@ _AllocOSPageArray(PVRSRV_DEVICE_NODE *psDevNode,
 	 * the oom-killer softirq is trying to call _ScanObjectsInPagePool(), it must not
 	 * try to acquire the vmalloc hash table lock again.
 	 */
-	psPageArrayData->pagearray = OSAllocZMemNoStats(sizeof(struct page *) * uiNumDevPageSizeVirtPages);
+	psPageArrayData->pagearray = OSAllocZMemNoStats(sizeof(struct page *) * uiNumOSPageSizeVirtPages);
 	if (psPageArrayData->pagearray == NULL)
 	{
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto e_free_kmem_cache;
 	}
-	else
+
+	if (BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA))
 	{
-		if (BIT_ISSET(ui32AllocFlags, FLAG_IS_CMA))
+		/* Allocate additional DMA/CMA cpu kernel virtual address & device bus address array state */
+		psPageArrayData->dmavirtarray = OSAllocZMemNoStats(sizeof(void*) * uiNumOSPageSizeVirtPages);
+		if (psPageArrayData->dmavirtarray == NULL)
 		{
-			/* Allocate additional DMA/CMA cpu kernel virtual address & device bus address array state */
-			psPageArrayData->dmavirtarray = OSAllocZMemNoStats(sizeof(void*) * uiNumDevPageSizeVirtPages);
-			if (psPageArrayData->dmavirtarray == NULL)
-			{
-				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto e_free_pagearray;
-			}
-
-			psPageArrayData->dmaphysarray = OSAllocZMemNoStats(sizeof(dma_addr_t) * uiNumDevPageSizeVirtPages);
-			if (psPageArrayData->dmaphysarray == NULL)
-			{
-				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto e_free_cpuvirtaddrarray;
-			}
+			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+			goto e_free_pagearray;
 		}
-		else
+
+		psPageArrayData->dmaphysarray = OSAllocZMemNoStats(sizeof(dma_addr_t) * uiNumOSPageSizeVirtPages);
+		if (psPageArrayData->dmaphysarray == NULL)
 		{
-			psPageArrayData->dmavirtarray = NULL;
-			psPageArrayData->dmaphysarray = NULL;
+			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+			goto e_free_cpuvirtaddrarray;
 		}
 	}
+	else
+	{
+		psPageArrayData->dmavirtarray = NULL;
+		psPageArrayData->dmaphysarray = NULL;
+	}
+
 
 	if (psDevNode->psDevConfig && psDevNode->psDevConfig->pvOSDevice)
 	{
@@ -1355,15 +1791,19 @@ _AllocOSPageArray(PVRSRV_DEVICE_NODE *psDevNode,
 	}
 
 	/* Init metadata */
+	psPageArrayData->hPMR = NULL;
 	psPageArrayData->psDevNode = psDevNode;
 	psPageArrayData->uiPid = uiPid;
 	psPageArrayData->iNumOSPagesAllocated = 0;
 	psPageArrayData->uiTotalNumOSPages = uiNumOSPageSizeVirtPages;
-	psPageArrayData->uiLog2AllocPageSize = uiLog2AllocPageSize;
+	psPageArrayData->uiLog2DevPageSize = uiLog2DevPageSize;
 	psPageArrayData->ui64DmaMask = ui64DmaMask;
 	psPageArrayData->ui32AllocFlags = ui32AllocFlags;
 	psPageArrayData->ui32CPUCacheFlags = ui32CPUCacheFlags;
 	psPageArrayData->ui32CMAAdjustedPageCount = 0;
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	OSAtomicWrite(&psPageArrayData->iNumOSPagesUnderMigration, 0);
+#endif
 
 	*ppsPageArrayDataPtr = psPageArrayData;
 	return PVRSRV_OK;
@@ -1554,7 +1994,6 @@ _AllocOSPage_CMA(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	IMG_UINT32 uiAllocIsMisaligned;
 	size_t alloc_size = PAGE_SIZE << ui32AllocOrder;
 	struct device *dev = psPageArrayData->psDevNode->psDevConfig->pvOSDevice;
-	PVR_ASSERT(ui32AllocOrder == ui32MinOrder);
 
 	do
 	{
@@ -1658,19 +2097,18 @@ _AllocOSPage_CMA(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 					/* Store adjustments in PAGE_SIZE counts */
 					align_adjust = align_adjust >> PAGE_SHIFT;
 					bus_addr = DMA_SET_ALIGN_ADJUSTMENT(bus_addr, align_adjust);
-				}
 
-				/* Taint bus_addr due to over-allocation, allows us to free
-				 * memory correctly */
-				bus_addr = DMA_SET_ADJUSTED_ADDR(bus_addr);
+					/* Taint bus_addr due to over-allocation, allows us to free
+					 * memory correctly */
+					bus_addr = DMA_SET_ADJUSTED_ADDR(bus_addr);
+				}
 				uiAllocIsMisaligned = 0;
 			}
 		}
 	} while (uiAllocIsMisaligned);
 
 	/* Convert OSPageSize-based index into DevicePageSize-based index */
-	psPageArrayData->ui32CMAAdjustedPageCount += (alloc_size - (PAGE_SIZE << ui32AllocOrder ));
-
+	psPageArrayData->ui32CMAAdjustedPageCount += (alloc_size - (PAGE_SIZE << ui32AllocOrder));
 	psPageArrayData->dmavirtarray[uiPageIndex] = virt_addr;
 	psPageArrayData->dmaphysarray[uiPageIndex] = bus_addr;
 	psPageArrayData->pagearray[uiPageIndex] = page;
@@ -1708,7 +2146,6 @@ _AllocOSPage(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 	/* In case we need to, split the higher order page;
 	   this should only be used for order-0 allocations
 	   as higher order allocations should use DMA/CMA */
@@ -1716,11 +2153,13 @@ _AllocOSPage(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	{
 		split_page(psPage, uiAllocOrder);
 	}
-#endif
 
 	/* Store the page (or multiple split pages) in the page array */
 	for (ui32Count = 0; ui32Count < (1 << uiAllocOrder); ui32Count++)
 	{
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+		OSMemSetMovablePageAttr(&psPage[ui32Count], psPageArrayData, uiPageIndex + ui32Count);
+#endif
 		psPageArrayData->pagearray[uiPageIndex + ui32Count] = &(psPage[ui32Count]);
 	}
 
@@ -1731,12 +2170,14 @@ _AllocOSPage(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 #if defined(PVRSRV_ENABLE_MEMORY_STATS)
 
 static inline void _AddMemAllocRecord_UmaPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
-                                               const struct page *psPage)
+                                               const struct page *psPage,
+                                               IMG_UINT32 uiOrder)
 {
 	IMG_CPU_PHYADDR sCPUPhysAddr = { page_to_phys(psPage) };
+	IMG_UINT32 uiPageSize = 1 << psPageArrayData->uiLog2DevPageSize;
 	PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES,
 	                             NULL, sCPUPhysAddr,
-	                             1 << psPageArrayData->uiLog2AllocPageSize,
+	                             uiPageSize << uiOrder,
 	                             psPageArrayData->uiPid
 	                             DEBUG_MEMSTATS_VALUES);
 }
@@ -1757,19 +2198,16 @@ static inline void _RemoveMemAllocRecord_UmaPages(PMR_OSPAGEARRAY_DATA *psPageAr
 }
 
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
-static inline void _AddMemZombieRecord_UmaPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
-                                                const struct page *psPage)
+static inline void _TransferToMemZombieRecord_UmaPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
+                                                       const struct page *psPage)
 {
 	IMG_CPU_PHYADDR sCPUPhysAddr = { page_to_phys(psPage) };
 
-	PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES,
-	                                (IMG_UINT64) sCPUPhysAddr.uiAddr,
-	                                psPageArrayData->uiPid);
-	PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES,
-	                             NULL, sCPUPhysAddr,
-	                             1 << psPageArrayData->uiLog2AllocPageSize,
-	                             psPageArrayData->uiPid
-	                             DEBUG_MEMSTATS_VALUES);
+	PVRSRVStatsTransferMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES,
+	                                  PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES,
+	                                  (IMG_UINT64) sCPUPhysAddr.uiAddr,
+	                                  psPageArrayData->uiPid
+	                                  DEBUG_MEMSTATS_VALUES);
 }
 #endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
 
@@ -1825,16 +2263,21 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT32 uiArrayIndex = 0;
+	/* Order of the allocation to request, can be upgraded for large allocations
+	 * to aid efficient allocation. */
 	IMG_UINT32 ui32Order;
-	IMG_UINT32 ui32MinOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
+	/* Min order the requested allocation can be. We express this in terms of the device
+	 * page size to the OS page size. The OS page size is the minimum page size we can request
+	 * else we cannot map it. Requesters may request further size / contiguity constraints in form
+	 * of the log2AllocPageSize */
+	IMG_UINT32 ui32MinOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
 	IMG_BOOL bIncreaseMaxOrder = IMG_TRUE;
 
 	IMG_UINT32 ui32NumPageReq;
 	IMG_UINT32 uiOSPagesToAlloc;
 	IMG_UINT32 uiDevPagesFromPool = 0;
 
-	gfp_t gfp_flags = _GetGFPFlags(ui32MinOrder ? _ShouldInitMem(psPageArrayData->ui32AllocFlags) : IMG_FALSE, /* Zero all pages later as batch */
-	                                      psPageArrayData->psDevNode);
+	gfp_t gfp_flags = _GetGFPFlags(psPageArrayData);
 	gfp_t ui32GfpFlags;
 	gfp_t ui32HighOrderGfpFlags = ((gfp_flags & ~__GFP_RECLAIM) | __GFP_NORETRY);
 
@@ -1850,41 +2293,26 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 	   applies to new pages allocated from the kernel.  */
 	_GetPagesFromPoolLocked(psPageArrayData->psDevNode,
 							psPageArrayData->ui32CPUCacheFlags,
+							psPageArrayData->ui32AllocFlags,
 							uiOSPagesToAlloc,
 							ui32MinOrder,
-							BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_ZERO),
 							ppsPageArray,
 							&uiDevPagesFromPool);
 
 	uiArrayIndex = uiDevPagesFromPool;
 
-	if ((uiOSPagesToAlloc - uiDevPagesFromPool) < PVR_LINUX_HIGHORDER_ALLOCATION_THRESHOLD)
+	if ((uiOSPagesToAlloc - uiDevPagesFromPool) < PVR_LINUX_HIGHORDER_ALLOCATION_THRESHOLD &&
+	    !BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 	{	/* Small allocations: ask for one device page at a time */
 		ui32Order = ui32MinOrder;
 		bIncreaseMaxOrder = IMG_FALSE;
 	}
 	else
 	{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 		/* Large zero-order or none zero-order allocations, ask for
 		   MAX(max-order, min-order) order pages at a time; alloc
 		   failures throttles this down to ZeroOrder allocations */
 		ui32Order = MAX(g_uiMaxOrder, ui32MinOrder);
-#else
-		/* Because split_page() is not available on older kernels
-		   we cannot mix-and-match any-order pages in the PMR;
-		   only same-order pages must be present in page array.
-		   So we unconditionally force it to use ui32MinOrder on
-		   these older kernels */
-		ui32Order = ui32MinOrder;
-#if defined(DEBUG)
-		if (! BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
-		{
-			/* Check that this is zero */
-			PVR_ASSERT(! ui32Order);
-		}
-#endif
-#endif
 	}
 
 	/* Only if asking for more contiguity than we actually need, let it fail */
@@ -1897,32 +2325,24 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 
 		while (ui32NumPageReq > ui32PageRemain)
 		{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 			/* Pages to request is larger than that remaining
 			   so ask for less so never over allocate */
 			ui32Order = MAX(ui32Order >> 1, ui32MinOrder);
-#else
-			/* Pages to request is larger than that remaining so
-			   do nothing thus over allocate as we do not support
-			   mix/match of any-order pages in PMR page-array in
-			   older kernels (simplifies page free logic) */
-			PVR_ASSERT(ui32Order == ui32MinOrder);
-#endif
 			ui32NumPageReq = (1 << ui32Order);
 			ui32GfpFlags = (ui32Order > ui32MinOrder) ? ui32HighOrderGfpFlags : gfp_flags;
 		}
 
-		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 		{
 			/* As the DMA/CMA framework rounds-up request to the
 			   next power-of-two, we request multiple uiMinOrder
 			   pages to satisfy allocation request in order to
 			   minimise wasting memory */
 			eError = _AllocOSPage_CMA(psPageArrayData,
-									  ui32GfpFlags,
+									  gfp_flags,
 									  ui32Order,
 									  ui32MinOrder,
-									  uiArrayIndex >> ui32MinOrder);
+									  uiArrayIndex);
 		}
 		else
 		{
@@ -1936,6 +2356,26 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 
 		if (eError == PVRSRV_OK)
 		{
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+			if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
+			{
+				/* We encode non Ghost entries for CMA so we can record in order chunks */
+				_AddMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[uiArrayIndex], ui32Order);
+			}
+			else
+			{
+				/* Higher order pages get split using split_page() meaning we can't create a higher
+				 * order record in case the logic below reduces the order request part way through
+				 */
+				IMG_UINT32 i;
+				for (i = 0; i < (1 << ui32Order); i++)
+				{
+					_AddMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[uiArrayIndex + i], 0);
+				}
+			}
+#endif
+#endif
 			/* Successful request. Move onto next. */
 			uiArrayIndex += ui32NumPageReq;
 		}
@@ -1949,18 +2389,13 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 				ui32NumPageReq = (1 << ui32Order);
 				ui32GfpFlags = (ui32Order > ui32MinOrder) ? ui32HighOrderGfpFlags : gfp_flags;
 				g_uiMaxOrder = ui32Order;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
-				/* We should not trigger this code path in older kernels,
-				   this is enforced by ensuring ui32Order == ui32MinOrder */
-				PVR_ASSERT(ui32Order == ui32MinOrder);
-#endif
 			}
 			else
 			{
 				/* Failed to alloc pages at required contiguity. Failed allocation */
 				PVR_DPF((PVR_DBG_ERROR, "%s: %s failed to honour request at %u of %u, flags = %x, order = %u (%s)",
 								__func__,
-								BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA) ? "dma_alloc_coherent" : "alloc_pages",
+								BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA) ? "dma_alloc_coherent" : "alloc_pages",
 								uiArrayIndex,
 								uiOSPagesToAlloc,
 								ui32GfpFlags,
@@ -1979,21 +2414,32 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 
 	/* Construct table of page pointers to apply attributes */
 	ppsPageAttributeArray = &ppsPageArray[uiDevPagesFromPool];
-	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
-	{
-		IMG_UINT32 uiIdx, uiIdy, uiIdz;
 
-		ppsPageAttributeArray = OSAllocMem(sizeof(struct page *) * uiOSPagesToAlloc);
-		PVR_LOG_GOTO_IF_NOMEM(ppsPageAttributeArray, eError, e_free_pages);
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
+	{
+		IMG_UINT32 i;
+		dma_addr_t *psBusAddrArray = &psPageArrayData->dmaphysarray[uiDevPagesFromPool];
 
-		for (uiIdx = 0; uiIdx < uiOSPagesToAlloc; uiIdx += ui32NumPageReq)
+		/* Iterate over page array generating ghost CMA pages */
+		for (i = 0; i < uiOSPagesToAlloc;)
 		{
-			uiIdy = uiIdx >> ui32Order;
-			for (uiIdz = 0; uiIdz < ui32NumPageReq; uiIdz++)
+			IMG_UINT32 j;
+			IMG_UINT32 ui32NumPagesPerOrder = 1;
+
+			/* Iterate and populate until we find the next real page */
+			for (j = i + 1;
+			     j < uiOSPagesToAlloc &&
+			     ppsPageAttributeArray[j] == NULL;
+			     j++, ui32NumPagesPerOrder++)
 			{
-				ppsPageAttributeArray[uiIdx+uiIdz] = ppsPageArray[uiIdy];
-				ppsPageAttributeArray[uiIdx+uiIdz] += uiIdz;
+				/* Generate ghost page */
+				ppsPageAttributeArray[j] = ppsPageAttributeArray[i];
+				ppsPageAttributeArray[j] += ui32NumPagesPerOrder;
+				/* Mark DMA addr as ghost */
+				psBusAddrArray[j] = DMA_SET_CMA_GHOST(psBusAddrArray[i]);
 			}
+
+			i += ui32NumPagesPerOrder;
 		}
 	}
 
@@ -2045,36 +2491,13 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 		PVR_DPF((PVR_DBG_ERROR, "Failed to set page attributes"));
 		goto e_free_pages;
 	}
-	else
-	{
-		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
-		{
-			OSFreeMem(ppsPageAttributeArray);
-		}
-	}
 
 	/* Update metadata */
 	psPageArrayData->iNumOSPagesAllocated = psPageArrayData->uiTotalNumOSPages;
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	{
-#if defined(PVRSRV_ENABLE_MEMORY_STATS)
-		IMG_UINT32 ui32NumPages =
-		        psPageArrayData->iNumOSPagesAllocated >> ui32MinOrder;
-		IMG_UINT32 i;
-
-		for (i = 0; i < ui32NumPages; i++)
-		{
-			if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
-			{
-				_AddMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
-			}
-			else
-			{
-				_AddMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i << ui32MinOrder]);
-			}
-		}
-#else /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
 		_IncrMemAllocStat_UmaPages(((uiOSPagesToAlloc * PAGE_SIZE)+(psPageArrayData->ui32CMAAdjustedPageCount)),
 		                           psPageArrayData->uiPid);
 #endif /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
@@ -2088,25 +2511,23 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 	{
 		IMG_UINT32 ui32PageToFree;
 
-		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 		{
 			IMG_UINT32 uiDevArrayIndex = uiArrayIndex >> ui32Order;
 			IMG_UINT32 uiDevPageSize = PAGE_SIZE << ui32Order;
 			PVR_ASSERT(ui32Order == ui32MinOrder);
 
-			if (ppsPageAttributeArray)
-			{
-				OSFreeMem(ppsPageAttributeArray);
-			}
-
 			for (ui32PageToFree = 0; ui32PageToFree < uiDevArrayIndex; ui32PageToFree++)
 			{
-				_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
-								uiDevPageSize,
-								ui32MinOrder,
-								psPageArrayData->dmavirtarray[ui32PageToFree],
-								psPageArrayData->dmaphysarray[ui32PageToFree],
-								ppsPageArray[ui32PageToFree]);
+				if (!DMA_IS_CMA_GHOST(psPageArrayData->dmaphysarray[ui32PageToFree]))
+				{
+					_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
+									uiDevPageSize,
+									ui32MinOrder,
+									psPageArrayData->dmavirtarray[ui32PageToFree],
+									psPageArrayData->dmaphysarray[ui32PageToFree],
+									ppsPageArray[ui32PageToFree]);
+				}
 				psPageArrayData->dmaphysarray[ui32PageToFree]= (dma_addr_t)0;
 				psPageArrayData->dmavirtarray[ui32PageToFree] = NULL;
 				ppsPageArray[ui32PageToFree] = NULL;
@@ -2117,15 +2538,18 @@ _AllocOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 			/* Free the pages we got from the pool */
 			for (ui32PageToFree = 0; ui32PageToFree < uiDevPagesFromPool; ui32PageToFree++)
 			{
-				_FreeOSPage(ui32MinOrder,
+				/* Pages added to pool are always order 0 */
+				_FreeOSPage(0,
 							BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_UNSET_MEMORY_TYPE),
+							psPageArrayData,
 							ppsPageArray[ui32PageToFree]);
 				ppsPageArray[ui32PageToFree] = NULL;
 			}
 
 			for (ui32PageToFree = uiDevPagesFromPool; ui32PageToFree < uiArrayIndex; ui32PageToFree++)
 			{
-				_FreeOSPage(ui32MinOrder, IMG_FALSE, ppsPageArray[ui32PageToFree]);
+				/* Higher order pages from _AllocOSPage are always split into order 0 using split_page */
+				_FreeOSPage(0, IMG_FALSE, psPageArrayData, ppsPageArray[ui32PageToFree]);
 				ppsPageArray[ui32PageToFree] = NULL;
 			}
 		}
@@ -2148,13 +2572,16 @@ _CheckIfIndexInRange(IMG_UINT32 ui32Index, IMG_UINT32 *pui32Indices, IMG_UINT32
 }
 
 static INLINE PVRSRV_ERROR
-_CheckIfPageNotAllocated(IMG_UINT32 ui32Index, IMG_UINT32 *pui32Indices, struct page **ppsPageArray)
+_CheckIfPageNotAllocated(IMG_UINT32 ui32Index, IMG_UINT32 *pui32Indices, IMG_UINT32 uiOrder, struct page **ppsPageArray)
 {
-	if (ppsPageArray[pui32Indices[ui32Index]] != NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Mapping number %u at page array index %u already exists. "
-		        "Page struct %p", __func__, pui32Indices[ui32Index], ui32Index,
-		        ppsPageArray[pui32Indices[ui32Index]]));
+	if (ppsPageArray[pui32Indices[ui32Index] << uiOrder] != NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Mapping Idx Dev:%u|OS:%u at page array index %u already exists. "
+		        "Page struct %p", __func__,
+		        pui32Indices[ui32Index],
+		        pui32Indices[ui32Index] << uiOrder,
+		        ui32Index,
+		        ppsPageArray[pui32Indices[ui32Index] << uiOrder]));
 		return PVRSRV_ERROR_PMR_MAPPING_ALREADY_EXISTS;
 	}
 
@@ -2167,19 +2594,18 @@ _CheckIfPageNotAllocated(IMG_UINT32 ui32Index, IMG_UINT32 *pui32Indices, struct
  * virtual range. */
 static PVRSRV_ERROR
 _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
-					 IMG_UINT32 *puiAllocIndices,
+					 IMG_UINT32 *pauiDevPageAllocIndices,
 					 IMG_UINT32 uiDevPagesToAlloc)
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
 	struct page **ppsPageArray = psPageArrayData->pagearray;
-	IMG_UINT32 uiOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
+	IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
 	IMG_UINT32 uiDevPagesFromPool = 0;
 	IMG_UINT32 uiOSPagesToAlloc = uiDevPagesToAlloc * (1 << uiOrder);
 	IMG_UINT32 uiDevPagesAllocated = psPageArrayData->uiTotalNumOSPages >> uiOrder;
 	const IMG_UINT32 ui32AllocFlags = psPageArrayData->ui32AllocFlags;
-	gfp_t ui32GfpFlags = _GetGFPFlags(uiOrder ? _ShouldInitMem(ui32AllocFlags) : IMG_FALSE, /* Zero pages later as batch */
-									  psPageArrayData->psDevNode);
+	gfp_t ui32GfpFlags = _GetGFPFlags(psPageArrayData);
 
 	/* We use this page array to receive pages from the pool and then reuse it afterwards to
 	 * store pages that need their cache attribute changed on x86 */
@@ -2213,13 +2639,14 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	 * - PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES == 1 && uiOrder == 0
 	 * - PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES == 0 && uiOrder == 0 &&
 	 *   !(BIT_ISSET(ui32AllocFlags, FLAG_ZERO))
+	 * - !BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA)
 	 * _ShouldInitMem() must not be used for bZero argument since it only
 	 * applies to new pages allocated from the kernel.  */
 	_GetPagesFromPoolLocked(psPageArrayData->psDevNode,
 							psPageArrayData->ui32CPUCacheFlags,
+							psPageArrayData->ui32AllocFlags,
 							uiDevPagesToAlloc,
 							uiOrder,
-							BIT_ISSET(ui32AllocFlags, FLAG_ZERO),
 							ppsTempPageArray,
 							&uiDevPagesFromPool);
 
@@ -2231,25 +2658,36 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	/* Move pages we got from the pool to the array. */
 	for (i = 0; i < uiDevPagesFromPool; i++)
 	{
-		eError = _CheckIfIndexInRange(i, puiAllocIndices, uiDevPagesAllocated);
+		eError = _CheckIfIndexInRange(i, pauiDevPageAllocIndices, uiDevPagesAllocated);
 		PVR_GOTO_IF_ERROR(eError, e_free_pool_pages);
-		eError = _CheckIfPageNotAllocated(i, puiAllocIndices, ppsPageArray);
+		eError = _CheckIfPageNotAllocated(i, pauiDevPageAllocIndices, uiOrder, ppsPageArray);
 		PVR_GOTO_IF_ERROR(eError, e_free_pool_pages);
 
-		ppsPageArray[puiAllocIndices[i]] = ppsTempPageArray[i];
+		/* In this case the allocation order is the same for device and OS page size, we can use
+		 * DevPageAllocIndices here without having to scale up from device to OS page indices.
+		 */
+		PVR_ASSERT(uiOrder == 0);
+		ppsPageArray[pauiDevPageAllocIndices[i]] = ppsTempPageArray[i];
 	}
 
 	/* Allocate pages from the OS */
 	for (i = uiDevPagesFromPool; i < uiDevPagesToAlloc; i++)
 	{
-		eError = _CheckIfIndexInRange(i, puiAllocIndices, uiDevPagesAllocated);
+		IMG_UINT32 uiOSPageAllocIndex = pauiDevPageAllocIndices[i] << uiOrder;
+		/* We can perform range checks in terms of device pages, then we scale the indices
+		 * to OS page size for the storage array.
+		 */
+		eError = _CheckIfIndexInRange(i, pauiDevPageAllocIndices, uiDevPagesAllocated);
 		PVR_GOTO_IF_ERROR(eError, e_free_pages);
-		eError = _CheckIfPageNotAllocated(i, puiAllocIndices, ppsPageArray);
+		eError = _CheckIfPageNotAllocated(i, pauiDevPageAllocIndices, uiOrder, ppsPageArray);
 		PVR_GOTO_IF_ERROR(eError, e_free_pages);
 
 		/* Allocated pages and assign them the array. */
-		if (BIT_ISSET(ui32AllocFlags, FLAG_IS_CMA))
+		if (BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA))
 		{
+			IMG_UINT32 uiSubPageInOrder;
+			dma_addr_t *psBusAddrArray = &psPageArrayData->dmaphysarray[uiDevPagesFromPool];
+
 			/* As the DMA/CMA framework rounds-up request to the
 			   next power-of-two, we request multiple uiMinOrder
 			   pages to satisfy allocation request in order to
@@ -2258,31 +2696,49 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 									  ui32GfpFlags,
 									  uiOrder,
 									  uiOrder,
-									  puiAllocIndices[i]);
+									  uiOSPageAllocIndex);
 			if (eError != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "Failed to alloc CMA pages"));
 				goto e_free_pages;
 			}
+
+			for (uiSubPageInOrder = 1;
+			     uiSubPageInOrder < (1 << uiOrder);
+			     uiSubPageInOrder++)
+			{
+				/* Generate ghost page */
+				ppsPageArray[uiOSPageAllocIndex + uiSubPageInOrder] = ppsPageArray[uiOSPageAllocIndex];
+				ppsPageArray[uiOSPageAllocIndex + uiSubPageInOrder] += uiSubPageInOrder;
+				/* Mark DMA addr as ghost */
+				psBusAddrArray[uiOSPageAllocIndex + uiSubPageInOrder] = DMA_SET_CMA_GHOST(psBusAddrArray[uiOSPageAllocIndex]);
+			}
 		}
 		else
 		{
-			DisableOOMKiller();
-			ppsPageArray[puiAllocIndices[i]] = alloc_pages(ui32GfpFlags, uiOrder);
-			EnableOOMKiller();
+			eError = _AllocOSPage(psPageArrayData,
+								  ui32GfpFlags,
+								  uiOrder,
+								  uiOrder,
+								  uiOSPageAllocIndex);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "Failed to alloc CMA pages"));
+				goto e_free_pages;
+			}
 		}
 
-		if (ppsPageArray[puiAllocIndices[i]] != NULL)
+		if (ppsPageArray[uiOSPageAllocIndex] != NULL)
 		{
 			/* Append pages to the temporary array so it's easier to process
 			 * them later on. */
 
-			if (BIT_ISSET(ui32AllocFlags, FLAG_IS_CMA))
+			if (BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA))
 			{
 				IMG_UINT32 idx;
 				struct page *psPageAddr;
 
-				psPageAddr = ppsPageArray[puiAllocIndices[i]];
+				psPageAddr = ppsPageArray[uiOSPageAllocIndex];
 
 				/* "divide" CMA pages into OS pages if they have higher order */
 				for (idx = 0; idx < (1 << uiOrder); idx++)
@@ -2294,7 +2750,7 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 			}
 			else
 			{
-				ppsTempPageArray[uiTempPageArrayIndex] = ppsPageArray[puiAllocIndices[i]];
+				ppsTempPageArray[uiTempPageArrayIndex] = ppsPageArray[uiOSPageAllocIndex];
 				uiTempPageArrayIndex++;
 			}
 		}
@@ -2366,7 +2822,8 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	for (i = 0; i < uiDevPagesToAlloc; i++)
 	{
 		_AddMemAllocRecord_UmaPages(psPageArrayData,
-		                            ppsPageArray[puiAllocIndices[i]]);
+		                            ppsPageArray[pauiDevPageAllocIndices[i] << uiOrder],
+		                            uiOrder);
 	}
 #else
 	_IncrMemAllocStat_UmaPages(((uiOSPagesToAlloc * PAGE_SIZE)+(psPageArrayData->ui32CMAAdjustedPageCount)),
@@ -2377,31 +2834,43 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	return PVRSRV_OK;
 
 e_free_pages:
-	if (BIT_ISSET(ui32AllocFlags, FLAG_IS_CMA))
+	if (BIT_ISSET(ui32AllocFlags, FLAG_DMA_CMA))
 	{
 		IMG_UINT32 uiDevPageSize = PAGE_SIZE << uiOrder;
 
 		/* Free the pages we just allocated from the CMA */
 		for (; i > uiDevPagesFromPool; i--)
 		{
+			IMG_UINT32 idx = (i - 1) << uiOrder;
+			IMG_UINT32 uiSubPageInOrder;
 			_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
 			                uiDevPageSize,
 			                uiOrder,
-			                psPageArrayData->dmavirtarray[puiAllocIndices[i-1]],
-			                psPageArrayData->dmaphysarray[puiAllocIndices[i-1]],
-			                ppsPageArray[puiAllocIndices[i-1]]);
-			psPageArrayData->dmaphysarray[puiAllocIndices[i-1]]= (dma_addr_t) 0;
-			psPageArrayData->dmavirtarray[puiAllocIndices[i-1]] = NULL;
-			ppsPageArray[puiAllocIndices[i-1]] = NULL;
+			                psPageArrayData->dmavirtarray[pauiDevPageAllocIndices[idx]],
+			                psPageArrayData->dmaphysarray[pauiDevPageAllocIndices[idx]],
+			                ppsPageArray[pauiDevPageAllocIndices[idx]]);
+			psPageArrayData->dmaphysarray[pauiDevPageAllocIndices[idx]]= (dma_addr_t) 0;
+			psPageArrayData->dmavirtarray[pauiDevPageAllocIndices[idx]] = NULL;
+			ppsPageArray[pauiDevPageAllocIndices[idx]] = NULL;
+
+			for (uiSubPageInOrder = 1;
+				 uiSubPageInOrder < (1 << uiOrder);
+				 uiSubPageInOrder++)
+			{
+				ppsPageArray[idx + uiSubPageInOrder] = NULL;
+				psPageArrayData->dmaphysarray[idx + uiSubPageInOrder] = (dma_addr_t)0;
+				psPageArrayData->dmavirtarray[idx + uiSubPageInOrder] = NULL;
+			}
 		}
+
 	}
 	else
 	{
 		/* Free the pages we just allocated from the OS */
 		for (; i > uiDevPagesFromPool; i--)
 		{
-			_FreeOSPage(0, IMG_FALSE, ppsPageArray[puiAllocIndices[i-1]]);
-			ppsPageArray[puiAllocIndices[i-1]] = NULL;
+			_FreeOSPage(0, IMG_FALSE, psPageArrayData, ppsPageArray[pauiDevPageAllocIndices[i-1]]);
+			ppsPageArray[pauiDevPageAllocIndices[i-1]] = NULL;
 		}
 	}
 
@@ -2410,12 +2879,13 @@ _AllocOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 	for (i = 0; i < uiDevPagesFromPool; i++)
 	{
 		_FreeOSPage(0, BIT_ISSET(ui32AllocFlags, FLAG_UNSET_MEMORY_TYPE),
+		            psPageArrayData,
 		            ppsTempPageArray[i]);
 
 		/* not using _CheckIfIndexInRange() to not print error message */
-		if (puiAllocIndices[i] < uiDevPagesAllocated)
+		if (pauiDevPageAllocIndices[i] < uiDevPagesAllocated)
 		{
-			ppsPageArray[puiAllocIndices[i]] = NULL;
+			ppsPageArray[pauiDevPageAllocIndices[i]] = NULL;
 		}
 	}
 
@@ -2440,7 +2910,7 @@ _AllocOSPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 
 	/* Parameter checks */
 	PVR_ASSERT(NULL != psPageArrayData);
-	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 	{
 		PVR_ASSERT(psPageArrayData->dmaphysarray != NULL);
 		PVR_ASSERT(psPageArrayData->dmavirtarray != NULL);
@@ -2469,7 +2939,7 @@ _AllocOSPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 
 	_DumpPageArray(ppsPageArray,
 	               psPageArrayData->uiTotalNumOSPages >>
-	               (psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT) );
+	               (psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT) );
 
 	PVR_DPF((PVR_DBG_MESSAGE, "physmem_osmem_linux.c: allocated OS memory for PMR @0x%p", psPageArrayData));
 	return PVRSRV_OK;
@@ -2525,6 +2995,15 @@ _FreeOSPage_CMA(struct device *dev,
 			virt_addr -= align_adjust << PAGE_SHIFT;
 		}
 
+#if defined(DEBUG)
+		/* We should never attempt to free a CMA Ghost as it is handled in layer above */
+		if (DMA_IS_CMA_GHOST(dev_addr))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Attempt to free CMA Ghost entry!"));
+			return;
+		}
+#endif
+
 		dma_free_coherent(dev, alloc_size, virt_addr, DMA_GET_ADDR(dev_addr));
 	}
 }
@@ -2539,6 +3018,7 @@ _FreeOSPage_CMA(struct device *dev,
 static void
 _FreeOSPage(IMG_UINT32 uiOrder,
 			IMG_BOOL bUnsetMemoryType,
+			PMR_OSPAGEARRAY_DATA *psPageArrayData,
 			struct page *psPage)
 {
 
@@ -2560,6 +3040,19 @@ _FreeOSPage(IMG_UINT32 uiOrder,
 #else
 	PVR_UNREFERENCED_PARAMETER(bUnsetMemoryType);
 #endif
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	/* May call _FreeOSPage from clean pages for pool path, it has no
+	 * association with PMR_OSPAGEARRAY_DATA at this point
+	 */
+	if (psPageArrayData)
+	{
+		OSMemUnsetMovablePageAttr(psPage, psPageArrayData);
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psPageArrayData);
+#endif
+
 	__free_pages(psPage, uiOrder);
 }
 
@@ -2569,6 +3062,8 @@ _FreeOSPagesArray(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 {
 	PVR_DPF((PVR_DBG_MESSAGE, "physmem_osmem_linux.c: freed OS memory for PMR @0x%p", psPageArrayData));
 
+	psPageArrayData->hPMR = NULL;
+
 	/* Check if the page array actually still exists.
 	 * It might be the case that has been moved to the page pool */
 	if (psPageArrayData->pagearray != NULL)
@@ -2592,203 +3087,191 @@ _FreeOSPagesArray(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 /* Free all or some pages from a sparse page array */
 static PVRSRV_ERROR
 _FreeOSPages_Sparse(PMR_OSPAGEARRAY_DATA *psPageArrayData,
-					IMG_UINT32 *pai32FreeIndices,
-					IMG_UINT32 ui32FreePageCount)
+					IMG_UINT32 *paui32DevPageFreeIndices,
+					IMG_UINT32 uiDevPagesToFree)
 {
-	IMG_BOOL bSuccess;
-	IMG_UINT32 uiOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
-	IMG_UINT32 uiPageIndex, i, j, uiTempIdx = 0;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
 	struct page **ppsPageArray = psPageArrayData->pagearray;
-	IMG_UINT32 uiNumPages;
-
-	struct page **ppsTempPageArray;
-	IMG_UINT32 uiTempArraySize;
+	IMG_UINT32 uiNumDevPages;
+	struct page **ppsOSPagesToFree;
+	IMG_UINT32 *puiDevIndicesToFree;
+	IMG_UINT32 uiOSPageCount;
+	IMG_UINT32 uiTransferedDevPageCount;
+	IMG_UINT32 i;
 
 	/* We really should have something to free before we call this */
 	PVR_ASSERT(psPageArrayData->iNumOSPagesAllocated != 0);
 
-	if (pai32FreeIndices == NULL)
+	if (paui32DevPageFreeIndices == NULL)
 	{
-		uiNumPages = psPageArrayData->uiTotalNumOSPages >> uiOrder;
-		uiTempArraySize = psPageArrayData->iNumOSPagesAllocated;
+		uiNumDevPages = psPageArrayData->uiTotalNumOSPages >> uiOrder;
+		uiOSPageCount = psPageArrayData->iNumOSPagesAllocated;
 	}
 	else
 	{
-		uiNumPages = ui32FreePageCount;
-		uiTempArraySize = ui32FreePageCount << uiOrder;
+		uiNumDevPages = uiDevPagesToFree;
+		uiOSPageCount = uiNumDevPages << uiOrder;
 	}
 
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
-	for (i = 0; i < uiNumPages; i++)
+	/* Construct the array of pages before any free operation so error recovery is possible.
+	 * OSAllocMemNoStats required because this code may be run without the bridge lock held */
+	ppsOSPagesToFree = OSAllocMemNoStats(uiOSPageCount * sizeof(*ppsOSPagesToFree));
+	PVR_LOG_GOTO_IF_NOMEM(ppsOSPagesToFree, eError, err_array);
+	puiDevIndicesToFree = OSAllocMemNoStats(uiNumDevPages * sizeof(*puiDevIndicesToFree));
+	PVR_LOG_GOTO_IF_NOMEM(puiDevIndicesToFree, eError, err_indices);
+
+	/* Count how many allocated dev pages have been found. In case we need to unwind */
+	uiTransferedDevPageCount = 0;
+	for (i = 0; i < uiNumDevPages; i++)
 	{
-		IMG_UINT32 idx = pai32FreeIndices ? pai32FreeIndices[i] : i;
+		IMG_UINT32 uiSubPageInOrder;
+		IMG_UINT32 idx = paui32DevPageFreeIndices ? paui32DevPageFreeIndices[i] : i;
+		/* Scale Device page index to OS page Idx */
+		idx <<= uiOrder;
 
-		if (NULL != ppsPageArray[idx])
+		if (ppsPageArray[idx] != NULL)
 		{
-			_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[idx]);
+			IMG_UINT32 uiOSFreeArrayIdx = uiTransferedDevPageCount << uiOrder;
+			puiDevIndicesToFree[uiTransferedDevPageCount] = idx;
+
+			for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+			{
+				ppsOSPagesToFree[uiOSFreeArrayIdx + uiSubPageInOrder] = ppsPageArray[idx + uiSubPageInOrder];
+				ppsPageArray[idx + uiSubPageInOrder] = NULL;
+			}
+			uiTransferedDevPageCount++;
+		}
+		else if (paui32DevPageFreeIndices != NULL)
+		{
+			IMG_UINT32 j;
+			PVR_DPF((PVR_DBG_ERROR, "Invalid free index (%u), possible duplicate", idx));
+			/* Restore the ppsPageArray to its initial state.
+			 * Reverse the loop and swap the ppsTempPages back into ppsPageArray. */
+			for (j = 0; j < uiTransferedDevPageCount; j++)
+			{
+				IMG_UINT32 uiSubPageInOrder;
+
+				idx = puiDevIndicesToFree[j];
+				ppsPageArray[idx] = ppsOSPagesToFree[j];
+
+				for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+				{
+					ppsPageArray[idx + uiSubPageInOrder] = ppsOSPagesToFree[j + uiSubPageInOrder];
+				}
+			}
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK, err_indices);
 		}
 	}
-#endif
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
+	for (i = 0; i < uiTransferedDevPageCount; i++)
+	{
+		/* Scale Device page index to OS page Idx */
+		IMG_UINT32 idx = i << uiOrder;
+
+		_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsOSPagesToFree[idx]);
+	}
+#endif /* PVRSRV_ENABLE_PROCESS_STATS && PVRSRV_ENABLE_MEMORY_STATS */
 
 	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_POISON_ON_FREE))
 	{
-		for (i = 0; i < uiNumPages; i++)
+		for (i = 0; i < uiTransferedDevPageCount; i++)
 		{
-			IMG_UINT32 idx = pai32FreeIndices ? pai32FreeIndices[i] : i;
+			/* Scale Device page index to OS page Idx */
+			IMG_UINT32 idx = i << uiOrder;
 
-			if (NULL != ppsPageArray[idx])
-			{
-				_PoisonDevicePage(psPageArrayData->psDevNode,
-				                  ppsPageArray[idx],
-				                  uiOrder,
-				                  psPageArrayData->ui32CPUCacheFlags,
-				                  PVRSRV_POISON_ON_FREE_VALUE);
-			}
-			else if (pai32FreeIndices != NULL)
-			{
-				/* Attempt to poison an index not containing a valid page */
-				return PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK;
-			}
+			_PoisonDevicePage(psPageArrayData->psDevNode,
+			                  ppsOSPagesToFree[idx],
+			                  uiOrder,
+			                  psPageArrayData->ui32CPUCacheFlags,
+			                  PVRSRV_POISON_ON_FREE_VALUE);
 		}
 	}
 
-	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 	{
-		IMG_UINT32 uiDevNumPages = uiNumPages;
-		IMG_UINT32 uiDevPageSize = 1<<psPageArrayData->uiLog2AllocPageSize;
-
-		for (i = 0; i < uiDevNumPages; i++)
+		IMG_UINT64 ui64DevPageSize = IMG_PAGE2BYTES64(psPageArrayData->uiLog2DevPageSize);
+		for (i = 0; i < uiTransferedDevPageCount; i++)
 		{
-			IMG_UINT32 idx = pai32FreeIndices ? pai32FreeIndices[i] : i;
-			if (NULL != ppsPageArray[idx])
+			IMG_UINT32 uiSubPageInOrder;
+			/* Scale Device page index to OS page Idx */
+			IMG_UINT32 uiFreeIdx = i << uiOrder;
+			/* Get the page's original index in ppsPageArray, already scaled to dev pages */
+			IMG_UINT32 idx = puiDevIndicesToFree[i];
+			_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
+			                ui64DevPageSize,
+			                uiOrder,
+			                psPageArrayData->dmavirtarray[idx],
+			                psPageArrayData->dmaphysarray[idx],
+			                ppsOSPagesToFree[uiFreeIdx]);
+			for (uiSubPageInOrder = 0;
+			     uiSubPageInOrder < (1 << uiOrder);
+			     uiSubPageInOrder++)
 			{
-				_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
-								uiDevPageSize,
-								uiOrder,
-								psPageArrayData->dmavirtarray[idx],
-								psPageArrayData->dmaphysarray[idx],
-								ppsPageArray[idx]);
-				psPageArrayData->dmaphysarray[idx] = (dma_addr_t)0;
-				psPageArrayData->dmavirtarray[idx] = NULL;
-				ppsPageArray[idx] = NULL;
-				uiTempIdx++;
-			}
-			else if (pai32FreeIndices != NULL)
-			{
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
-				/* Attempt to keep memstats consistent in event of fail as we have
-				 * freed some pages
-				 */
-				uiTempIdx <<= uiOrder;
-				_DecrMemAllocStat_UmaPages(psPageArrayData, uiTempIdx * PAGE_SIZE, psPageArrayData->uiPid);
-#endif
-				/* Attempt to free an already free index, could be duplicated free indices */
-				return PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK;
+				psPageArrayData->dmaphysarray[idx + uiSubPageInOrder] = (dma_addr_t)0;
+				psPageArrayData->dmavirtarray[idx + uiSubPageInOrder] = NULL;
 			}
 		}
-		uiTempIdx <<= uiOrder;
 	}
 	else
 	{
+		IMG_BOOL bPagesInPool;
 
-		/* OSAllocMemNoStats required because this code may be run without the bridge lock held */
-		ppsTempPageArray = OSAllocMemNoStats(sizeof(struct page*) * uiTempArraySize);
-		if (ppsTempPageArray == NULL)
+		/* Try to move the temp page array to the pool */
+		bPagesInPool = _PutPagesToPoolLocked(psPageArrayData->psDevNode,
+		                                     psPageArrayData->ui32CPUCacheFlags,
+		                                     psPageArrayData->ui32AllocFlags,
+		                                     ppsOSPagesToFree,
+		                                     0,
+		                                     uiOSPageCount);
+		if (bPagesInPool)
 		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Failed free_pages metadata allocation", __func__));
-			return PVRSRV_ERROR_OUT_OF_MEMORY;
+			/* Do NOT free ppsPagesToFree if it moved to the pool */
+			ppsOSPagesToFree = NULL;
 		}
-
-		/* Put pages in a contiguous array so further processing is easier */
-		for (i = 0; i < uiNumPages; i++)
+		else
 		{
-			uiPageIndex = pai32FreeIndices ? pai32FreeIndices[i] : i;
-			if (NULL != ppsPageArray[uiPageIndex])
+			/* Free pages and reset page caching attributes on x86 */
+#if defined(CONFIG_X86)
+			if (uiOSPageCount != 0 && BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_UNSET_MEMORY_TYPE))
 			{
-				struct page *psPage = ppsPageArray[uiPageIndex];
+				int iError;
+				iError = set_pages_array_wb(ppsOSPagesToFree, uiOSPageCount);
 
-				for (j = 0; j < (1<<uiOrder); j++)
+				if (iError)
 				{
-					ppsTempPageArray[uiTempIdx] = psPage;
-					uiTempIdx++;
-					psPage++;
+					PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attributes", __func__));
 				}
-
-				ppsPageArray[uiPageIndex] = NULL;
 			}
-			else if (pai32FreeIndices != NULL)
-			{
-				/* Attempt to free an already free index, could be duplicated free indices.
-				 * We don't have a need to unwind here as this isn't something we want to
-				 * recover from, we do want to try and maintain some consistency with pages we
-				 * can free before the error occurred and adjusting the memstats as required.
-				 */
-				for (i = 0; i < uiTempIdx; i++)
-				{
-					__free_pages(ppsTempPageArray[i], 0);
-				}
-
-#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
-				_DecrMemAllocStat_UmaPages(psPageArrayData, uiTempIdx * PAGE_SIZE, psPageArrayData->uiPid);
 #endif
 
-				OSFreeMemNoStats(ppsTempPageArray);
-				return PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK;
-			}
-		}
-
-		/* Try to move the temp page array to the pool */
-		bSuccess = _PutPagesToPoolLocked(psPageArrayData->psDevNode,
-		                                 psPageArrayData->ui32CPUCacheFlags,
-		                                 ppsTempPageArray,
-		                                 0,
-		                                 uiTempIdx);
-		if (bSuccess)
-		{
-			goto exit_ok;
-		}
-
-		/* Free pages and reset page caching attributes on x86 */
-#if defined(CONFIG_X86)
-		if (uiTempIdx != 0 && BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_UNSET_MEMORY_TYPE))
-		{
-			int iError;
-			iError = set_pages_array_wb(ppsTempPageArray, uiTempIdx);
-
-			if (iError)
+			/* Free the pages */
+			for (i = 0; i < uiOSPageCount; i++)
 			{
-				PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attributes", __func__));
+				_FreeOSPage(0, IMG_FALSE, psPageArrayData, ppsOSPagesToFree[i]);
 			}
 		}
-#endif
-
-		/* Free the pages */
-		for (i = 0; i < uiTempIdx; i++)
-		{
-			__free_pages(ppsTempPageArray[i], 0);
-		}
-
-		/* Free the temp page array here if it did not move to the pool */
-		OSFreeMemNoStats(ppsTempPageArray);
 	}
 
-exit_ok:
-
 #if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
 	_DecrMemAllocStat_UmaPages(psPageArrayData,
-	                           ((uiTempIdx * PAGE_SIZE)-(psPageArrayData->ui32CMAAdjustedPageCount)),
+	                           (uiOSPageCount * PAGE_SIZE) - psPageArrayData->ui32CMAAdjustedPageCount,
 	                           psPageArrayData->uiPid);
 #endif
 
-	if (pai32FreeIndices && ((uiTempIdx >> uiOrder) != ui32FreePageCount))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Probable sparse duplicate indices: ReqFreeCount: %d "
-				"ActualFreedCount: %d", __func__, ui32FreePageCount, (uiTempIdx >> uiOrder)));
-	}
 	/* Update metadata */
-	psPageArrayData->iNumOSPagesAllocated -= uiTempIdx;
+	psPageArrayData->iNumOSPagesAllocated -= uiOSPageCount;
 	PVR_ASSERT(0 <= psPageArrayData->iNumOSPagesAllocated);
-	return PVRSRV_OK;
+
+err_indices:
+	OSFreeMemNoStats(puiDevIndicesToFree);
+err_array:
+	if (ppsOSPagesToFree)
+	{
+		OSFreeMemNoStats(ppsOSPagesToFree);
+	}
+	return eError;
 }
 
 /* Free all the pages in a page array */
@@ -2797,9 +3280,9 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 {
 	IMG_BOOL bSuccess;
 	IMG_UINT32 i;
-	IMG_UINT32 uiNumPages = psPageArrayData->uiTotalNumOSPages;
-	IMG_UINT32 uiOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
-	IMG_UINT32 uiDevNumPages = uiNumPages >> uiOrder;
+	IMG_UINT32 uiOSNumPages = psPageArrayData->uiTotalNumOSPages;
+	IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+	IMG_UINT32 uiDevNumPages = uiOSNumPages >> uiOrder;
 	IMG_UINT32 uiDevPageSize = PAGE_SIZE << uiOrder;
 	struct page **ppsPageArray = psPageArrayData->pagearray;
 
@@ -2808,19 +3291,22 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 #if defined(PVRSRV_ENABLE_MEMORY_STATS)
-	for (i = 0; i < uiDevNumPages; i++)
+	for (i = 0; i < uiOSNumPages; i++)
 	{
-		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 		{
-			_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+			if (!DMA_IS_CMA_GHOST(psPageArrayData->dmaphysarray[i]))
+			{
+				_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+			}
 		}
 		else
 		{
-			_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i << uiOrder]);
+			_RemoveMemAllocRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
 		}
 	}
 #else
-	_DecrMemAllocStat_UmaPages(psPageArrayData, uiNumPages * PAGE_SIZE - psPageArrayData->ui32CMAAdjustedPageCount,
+	_DecrMemAllocStat_UmaPages(psPageArrayData, uiOSNumPages * PAGE_SIZE - psPageArrayData->ui32CMAAdjustedPageCount,
 	                           psPageArrayData->uiPid);
 #endif
 #endif
@@ -2829,8 +3315,11 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 	{
 		for (i = 0; i < uiDevNumPages; i++)
 		{
+			/* Scale Device page index to OS page idx */
+			IMG_UINT32 idx = i << uiOrder;
+
 			_PoisonDevicePage(psPageArrayData->psDevNode,
-			                  ppsPageArray[i],
+			                  ppsPageArray[idx],
 			                  uiOrder,
 			                  psPageArrayData->ui32CPUCacheFlags,
 			                  PVRSRV_POISON_ON_FREE_VALUE);
@@ -2840,25 +3329,30 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 	/* Try to move the page array to the pool */
 	bSuccess = _PutPagesToPoolLocked(psPageArrayData->psDevNode,
 	                                 psPageArrayData->ui32CPUCacheFlags,
+	                                 psPageArrayData->ui32AllocFlags,
 	                                 ppsPageArray,
 	                                 uiOrder,
-	                                 uiNumPages);
+	                                 uiOSNumPages);
 	if (bSuccess)
 	{
 		psPageArrayData->pagearray = NULL;
 		goto exit_ok;
 	}
 
-	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_IS_CMA))
+	if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 	{
-		for (i = 0; i < uiDevNumPages; i++)
+		for (i = 0; i < uiOSNumPages; i++)
 		{
-			_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
-							uiDevPageSize,
-							uiOrder,
-							psPageArrayData->dmavirtarray[i],
-							psPageArrayData->dmaphysarray[i],
-							ppsPageArray[i]);
+			if (!DMA_IS_CMA_GHOST(psPageArrayData->dmaphysarray[i]))
+			{
+				_FreeOSPage_CMA(psPageArrayData->psDevNode->psDevConfig->pvOSDevice,
+								uiDevPageSize,
+								uiOrder,
+								psPageArrayData->dmavirtarray[i],
+								psPageArrayData->dmaphysarray[i],
+								ppsPageArray[i]);
+
+			}
 			psPageArrayData->dmaphysarray[i] = (dma_addr_t)0;
 			psPageArrayData->dmavirtarray[i] = NULL;
 			ppsPageArray[i] = NULL;
@@ -2871,7 +3365,7 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 		{
 			int ret;
 
-			ret = set_pages_array_wb(ppsPageArray, uiNumPages);
+			ret = set_pages_array_wb(ppsPageArray, uiOSNumPages);
 			if (ret)
 			{
 				PVR_DPF((PVR_DBG_ERROR, "%s: Failed to reset page attributes",
@@ -2880,9 +3374,9 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 		}
 #endif
 
-		for (i = 0; i < uiNumPages; i++)
+		for (i = 0; i < uiOSNumPages; i++)
 		{
-			_FreeOSPage(uiOrder, IMG_FALSE, ppsPageArray[i]);
+			_FreeOSPage(uiOrder, IMG_FALSE, psPageArrayData, ppsPageArray[i]);
 			ppsPageArray[i] = NULL;
 		}
 	}
@@ -2893,6 +3387,203 @@ _FreeOSPages_Fast(PMR_OSPAGEARRAY_DATA *psPageArrayData)
 	return PVRSRV_OK;
 }
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static PVRSRV_ERROR PMRFreeZombiePagesOSMem(PMR_IMPL_ZOMBIEPAGES pvPriv)
+{
+	PVRSRV_ERROR eError;
+	PMR_OSPAGEARRAY_DATA *psZombiePageArray = pvPriv;
+
+	eError = _FreeOSPages(psZombiePageArray,
+	                      NULL,
+	                      0 /* Unused */);
+
+	if (eError != PVRSRV_OK)
+	{
+		goto e0;
+	}
+
+	_FreeOSPagesArray(psZombiePageArray);
+
+	return PVRSRV_OK;
+e0:
+	return eError;
+}
+
+/* Extracts ui32ExtractPageCount of pages referenced in pai32ExtractIndices from the psSrcPageArrayData
+ * Allocates a new PMR_OSPAGEARRAY_DATA object and fills it with the extracted pages information.
+ */
+static PVRSRV_ERROR
+_ExtractPages(PMR_OSPAGEARRAY_DATA *psSrcPageArrayData,
+			  IMG_UINT32 *pai32ExtractIndices,
+			  IMG_UINT32 ui32ExtractPageCount,
+			  PMR_OSPAGEARRAY_DATA** psOutPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 i, uiSubPageInOrder, uiOrder;
+	PMR_OSPAGEARRAY_DATA* psDstPageArrayData;
+
+	/* Alloc PMR_OSPAGEARRAY_DATA for the extracted pages */
+	eError = _AllocOSPageArray(psSrcPageArrayData->psDevNode,
+	                           (IMG_UINT64)ui32ExtractPageCount << psSrcPageArrayData->uiLog2DevPageSize,
+	                           psSrcPageArrayData->uiLog2DevPageSize,
+	                           psSrcPageArrayData->ui32AllocFlags,
+	                           psSrcPageArrayData->ui32CPUCacheFlags,
+	                           psSrcPageArrayData->uiPid,
+	                           &psDstPageArrayData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "_AllocOSPageArray failed in _ExtractPages"));
+		return eError;
+	}
+
+	uiOrder = psSrcPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+
+	/* Transfer from src pagearray to dst pagearray */
+	for (i = 0; i < ui32ExtractPageCount; i++)
+	{
+		IMG_UINT32 idxSrc = pai32ExtractIndices[i] << uiOrder;
+		IMG_UINT32 idxExtracted = i << uiOrder;
+
+		if (psSrcPageArrayData->pagearray[idxSrc] != NULL)
+		{
+			for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+			{
+				psDstPageArrayData->pagearray[idxExtracted + uiSubPageInOrder] =
+				    psSrcPageArrayData->pagearray[idxSrc + uiSubPageInOrder];
+
+				psSrcPageArrayData->pagearray[idxSrc + uiSubPageInOrder] = NULL;
+			}
+		}
+	}
+
+	/* Do the same for dmaphysarray and dmavirtarray if allocated with CMA */
+	if (BIT_ISSET(psSrcPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
+	{
+		for (i = 0; i < ui32ExtractPageCount; i++)
+		{
+			IMG_UINT32 idxSrc = pai32ExtractIndices[i] << uiOrder;
+			IMG_UINT32 idxDst = i << uiOrder;
+
+			if (psSrcPageArrayData->dmaphysarray[idxSrc] != (dma_addr_t)0 ||
+			    psSrcPageArrayData->dmavirtarray[idxSrc] != NULL)
+			{
+				for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+				{
+					psDstPageArrayData->dmaphysarray[idxDst + uiSubPageInOrder] =
+					    psSrcPageArrayData->dmaphysarray[idxSrc + uiSubPageInOrder];
+					psDstPageArrayData->dmavirtarray[idxDst + uiSubPageInOrder] =
+					    psSrcPageArrayData->dmavirtarray[idxSrc + uiSubPageInOrder];
+
+					psSrcPageArrayData->dmaphysarray[idxSrc + uiSubPageInOrder] = (dma_addr_t)0;
+					psSrcPageArrayData->dmavirtarray[idxSrc + uiSubPageInOrder] = NULL;
+				}
+			}
+		}
+	}
+
+	/* Update page counts */
+	psSrcPageArrayData->iNumOSPagesAllocated -= ui32ExtractPageCount << uiOrder;
+	psDstPageArrayData->iNumOSPagesAllocated += ui32ExtractPageCount << uiOrder;
+
+	*psOutPageArrayData = psDstPageArrayData;
+	return PVRSRV_OK;
+}
+
+/* Extracts all allocated pages referenced psSrcPageArrayData
+ * Allocates a new PMR_OSPAGEARRAY_DATA object and fills it with the extracted
+ * pages information.
+ */
+static PVRSRV_ERROR
+_ExtractAllPages(PMR_OSPAGEARRAY_DATA *psSrcPageArrayData,
+				 PMR_OSPAGEARRAY_DATA **psOutPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 i, uiSubPageInOrder, uiOrder;
+	PMR_OSPAGEARRAY_DATA* psDstPageArrayData;
+	IMG_UINT32 uiPagesCopied = 0;
+
+	/* Alloc PMR_OSPAGEARRAY_DATA for the extracted pages */
+	eError = _AllocOSPageArray(psSrcPageArrayData->psDevNode,
+	                           (IMG_UINT64)psSrcPageArrayData->iNumOSPagesAllocated << psSrcPageArrayData->uiLog2DevPageSize,
+	                           psSrcPageArrayData->uiLog2DevPageSize,
+	                           psSrcPageArrayData->ui32AllocFlags,
+	                           psSrcPageArrayData->ui32CPUCacheFlags,
+	                           psSrcPageArrayData->uiPid,
+	                           &psDstPageArrayData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "_AllocOSPageArray failed in _ExtractPages"));
+		return eError;
+	}
+
+	uiOrder = psSrcPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+
+	/* Transfer from src pagearray to dst pagearray */
+	/* Iterate through all pages in psSrcPageArrayData but stop once
+	 * we have copied psSrcPageArrayData->iNumOSPagesAllocated pages to
+	 * psDstPageArrayData.
+	 */
+	for (i = 0; ((i < psSrcPageArrayData->uiTotalNumOSPages) &&
+	             (uiPagesCopied < psSrcPageArrayData->iNumOSPagesAllocated)); i++)
+	{
+		IMG_UINT32 idx = i << uiOrder;
+
+		if (psSrcPageArrayData->pagearray[idx] != NULL)
+		{
+
+			for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+			{
+				psDstPageArrayData->pagearray[uiPagesCopied + uiSubPageInOrder] =
+				        psSrcPageArrayData->pagearray[idx + uiSubPageInOrder];
+
+				psSrcPageArrayData->pagearray[idx + uiSubPageInOrder] = NULL;
+			}
+			uiPagesCopied++;
+		}
+	}
+
+	/* Reset uiPagesCopied */
+	uiPagesCopied = 0;
+
+	/* Do the same for dmaphysarray and dmavirtarray if allocated with CMA */
+	if (BIT_ISSET(psSrcPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
+	{
+		/* Iterate through all pages in psSrcPageArrayData but stop once
+		 * we have copied psSrcPageArrayData->iNumOSPagesAllocated pages to
+		 * psDstPageArrayData.
+		 */
+		for (i = 0; ((i < psSrcPageArrayData->uiTotalNumOSPages) &&
+		             (uiPagesCopied < psSrcPageArrayData->iNumOSPagesAllocated)); i++)
+		{
+			IMG_UINT32 idx = i << uiOrder;
+
+			if (psSrcPageArrayData->dmaphysarray[i] != (dma_addr_t)0 ||
+			    psSrcPageArrayData->dmavirtarray[i] != NULL)
+			{
+				for (uiSubPageInOrder = 0; uiSubPageInOrder < (1 << uiOrder); uiSubPageInOrder++)
+				{
+					psDstPageArrayData->dmaphysarray[uiPagesCopied + uiSubPageInOrder] =
+					    psSrcPageArrayData->dmaphysarray[idx + uiSubPageInOrder];
+					psDstPageArrayData->dmavirtarray[uiPagesCopied + uiSubPageInOrder] =
+					    psSrcPageArrayData->dmavirtarray[idx + uiSubPageInOrder];
+
+					psSrcPageArrayData->dmaphysarray[idx + uiSubPageInOrder] = (dma_addr_t)0;
+					psSrcPageArrayData->dmavirtarray[idx + uiSubPageInOrder] = NULL;
+				}
+				uiPagesCopied++;
+			}
+		}
+	}
+
+	/* Update page counts */
+	psDstPageArrayData->iNumOSPagesAllocated = psSrcPageArrayData->iNumOSPagesAllocated << uiOrder;
+	psSrcPageArrayData->iNumOSPagesAllocated = 0;
+
+	*psOutPageArrayData = psDstPageArrayData;
+	return PVRSRV_OK;
+}
+#endif /* defined(SUPPORT_PMR_PAGES_DEFERRED_FREE) */
+
 /* Free pages from a page array.
  * Takes care of mem stats and chooses correct free path depending on parameters. */
 static PVRSRV_ERROR
@@ -2922,7 +3613,7 @@ _FreeOSPages(PMR_OSPAGEARRAY_DATA *psPageArrayData,
 
 	_DumpPageArray(psPageArrayData->pagearray,
 	               psPageArrayData->uiTotalNumOSPages >>
-	              (psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT) );
+	              (psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT) );
 
 	return eError;
 }
@@ -2945,24 +3636,6 @@ PMRFinalizeOSMem(PMR_IMPL_PRIVDATA pvPriv)
 	/* We can't free pages until now. */
 	if (psOSPageArrayData->iNumOSPagesAllocated != 0)
 	{
-#if defined(DEBUG) && defined(SUPPORT_VALIDATION)
-		PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-		IMG_UINT32 ui32UMALeakMax = psPVRSRVData->sMemLeakIntervals.ui32GPU;
-
-		mutex_lock(&g_sUMALeakMutex);
-
-		g_ui32UMALeakCounter++;
-		if (ui32UMALeakMax && g_ui32UMALeakCounter >= ui32UMALeakMax)
-		{
-			g_ui32UMALeakCounter = 0;
-			mutex_unlock(&g_sUMALeakMutex);
-
-			PVR_DPF((PVR_DBG_WARNING, "%s: Skipped freeing of PMR 0x%p to trigger memory leak.", __func__, pvPriv));
-			return;
-		}
-
-		mutex_unlock(&g_sUMALeakMutex);
-#endif
 
 		eError = _FreeOSPages(psOSPageArrayData, NULL, 0);
 		PVR_LOG_IF_ERROR(eError, "_FreeOSPages");
@@ -2977,8 +3650,7 @@ static PVRSRV_ERROR PMRZombifyOSMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 {
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	PMR_OSPAGEARRAY_DATA *psPageArrayData = pvPriv;
-	IMG_UINT32 uiNumPages = psPageArrayData->uiTotalNumOSPages;
-	const IMG_UINT32 uiFlags = psPageArrayData->ui32AllocFlags;
+	IMG_UINT32 uiNumOSPages = psPageArrayData->uiTotalNumOSPages;
 
 	BIT_SET(psPageArrayData->ui32AllocFlags, FLAG_IS_ZOMBIE);
 
@@ -2989,28 +3661,42 @@ static PVRSRV_ERROR PMRZombifyOSMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 		/* _FreeOSPages_Sparse() path */
 
 		struct page *const *const ppsPageArray = psPageArrayData->pagearray;
+		const IMG_UINT32 uiFlags = psPageArrayData->ui32AllocFlags;
 
 #if defined(PVRSRV_ENABLE_MEMORY_STATS)
 		IMG_UINT32 i;
 
-		for (i = 0; i < uiNumPages; i++)
+		if (BIT_ISSET(uiFlags, FLAG_DMA_CMA))
 		{
-			if (ppsPageArray[i] != NULL)
+			for (i = 0; i < uiNumOSPages; i++)
 			{
-				_AddMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+				if (ppsPageArray[i] != NULL && !DMA_IS_CMA_GHOST(psPageArrayData->dmaphysarray[i]))
+				{
+					_TransferToMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+				}
+			}
+		}
+		else
+		{
+			for (i = 0; i < uiNumOSPages; i++)
+			{
+				if (ppsPageArray[i] != NULL)
+				{
+					_TransferToMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+				}
 			}
 		}
 #else /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
-		const IMG_UINT32 uiOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
+		const IMG_UINT32 uiOrder = psPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+		IMG_UINT32 uiNumDevPages = psPageArrayData->uiTotalNumOSPages >> uiOrder;
 		IMG_UINT32 i, j, uiAllocatedNumPages = 0;
 
-		uiNumPages >>= uiOrder;
-
-		if (BIT_ISSET(uiFlags, FLAG_IS_CMA))
+		if (BIT_ISSET(uiFlags, FLAG_DMA_CMA))
 		{
-			for (i = 0; i < uiNumPages; i++)
+			for (i = 0; i < uiNumDevPages; i++)
 			{
-				if (ppsPageArray[i] != NULL)
+				IMG_UINT32 idx = i << uiOrder;
+				if (ppsPageArray[idx] != NULL)
 				{
 					uiAllocatedNumPages++;
 				}
@@ -3019,9 +3705,10 @@ static PVRSRV_ERROR PMRZombifyOSMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 		}
 		else
 		{
-			for (i = 0; i < uiNumPages; i++)
+			for (i = 0; i < uiNumDevPages; i++)
 			{
-				if (ppsPageArray[i] != NULL)
+				IMG_UINT32 idx = i << uiOrder;
+				if (ppsPageArray[idx] != NULL)
 				{
 					for (j = 0; j < (1<<uiOrder); j++)
 					{
@@ -3043,17 +3730,28 @@ static PVRSRV_ERROR PMRZombifyOSMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
 
 #if defined(PVRSRV_ENABLE_MEMORY_STATS)
 		struct page *const *const ppsPageArray = psPageArrayData->pagearray;
-		const IMG_UINT32 uiOrder = psPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
 		IMG_UINT32 i;
 
-		for (i = 0; i < uiNumPages; i++)
+		if (BIT_ISSET(psPageArrayData->ui32AllocFlags, FLAG_DMA_CMA))
 		{
-			IMG_UINT32 uiIdx = BIT_ISSET(uiFlags, FLAG_IS_CMA) ? i : i << uiOrder;
-			_AddMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[uiIdx]);
+			for (i = 0; i < uiNumOSPages; i++)
+			{
+				if (!DMA_IS_CMA_GHOST(psPageArrayData->dmaphysarray[i]))
+				{
+					_TransferToMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+				}
+			}
+		}
+		else
+		{
+			for (i = 0; i < uiNumOSPages; i++)
+			{
+				_TransferToMemZombieRecord_UmaPages(psPageArrayData, ppsPageArray[i]);
+			}
 		}
 #else /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
 		_ZombifyMemAllocStat_UmaPages(
-		    uiNumPages * PAGE_SIZE - psPageArrayData->ui32CMAAdjustedPageCount,
+		    uiNumOSPages * PAGE_SIZE - psPageArrayData->ui32CMAAdjustedPageCount,
 		    psPageArrayData->uiPid
 		);
 #endif /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
@@ -3090,15 +3788,45 @@ PMRLockSysPhysAddressesOSMem(PMR_IMPL_PRIVDATA pvPriv)
 	return eError;
 }
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static PVRSRV_ERROR
+PMRUnlockSysPhysAddressesOSMem(PMR_IMPL_PRIVDATA pvPriv,
+                               PMR_IMPL_ZOMBIEPAGES *ppvZombiePages)
+#else
 static PVRSRV_ERROR
 PMRUnlockSysPhysAddressesOSMem(PMR_IMPL_PRIVDATA pvPriv)
+#endif
 {
 	/* Just drops the refcount. */
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	PMR_OSPAGEARRAY_DATA *psOSPageArrayData = pvPriv;
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	PMR_OSPAGEARRAY_DATA *psExtractedPagesPageArray = NULL;
+
+	*ppvZombiePages = NULL;
+#endif
 
 	if (BIT_ISSET(psOSPageArrayData->ui32AllocFlags, FLAG_ONDEMAND))
 	{
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+		if (psOSPageArrayData->iNumOSPagesAllocated == 0)
+		{
+			*ppvZombiePages = NULL;
+			return PVRSRV_OK;
+		}
+
+		eError = _ExtractAllPages(psOSPageArrayData,
+		                          &psExtractedPagesPageArray);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_ExtractAllPages", e0);
+
+		if (psExtractedPagesPageArray)
+		{
+			/* Zombify pages to get proper stats */
+			eError = PMRZombifyOSMem(psExtractedPagesPageArray, NULL);
+			PVR_WARN_IF_ERROR(eError, "PMRZombifyOSMem");
+		}
+		*ppvZombiePages = psExtractedPagesPageArray;
+#else
 		/* Free Memory for deferred allocation */
 		eError = _FreeOSPages(psOSPageArrayData,
 							  NULL,
@@ -3107,8 +3835,12 @@ PMRUnlockSysPhysAddressesOSMem(PMR_IMPL_PRIVDATA pvPriv)
 		{
 			return eError;
 		}
+#endif
 	}
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+e0:
+#endif
 	PVR_ASSERT(eError == PVRSRV_OK);
 	return eError;
 }
@@ -3116,7 +3848,7 @@ PMRUnlockSysPhysAddressesOSMem(PMR_IMPL_PRIVDATA pvPriv)
 static INLINE IMG_BOOL IsOffsetValid(const PMR_OSPAGEARRAY_DATA *psOSPageArrayData,
                                      IMG_UINT32 ui32Offset)
 {
-	return (ui32Offset >> psOSPageArrayData->uiLog2AllocPageSize) <
+	return (ui32Offset >> psOSPageArrayData->uiLog2DevPageSize) <
 	    psOSPageArrayData->uiTotalNumOSPages;
 }
 
@@ -3124,12 +3856,11 @@ static INLINE IMG_BOOL IsOffsetValid(const PMR_OSPAGEARRAY_DATA *psOSPageArrayDa
 static IMG_DEV_PHYADDR GetOffsetPA(const PMR_OSPAGEARRAY_DATA *psOSPageArrayData,
                                    IMG_UINT32 ui32Offset)
 {
-	IMG_UINT32 ui32Log2AllocPageSize = psOSPageArrayData->uiLog2AllocPageSize;
-	IMG_UINT32 ui32PageIndex = ui32Offset >> ui32Log2AllocPageSize;
-	IMG_UINT32 ui32InPageOffset = ui32Offset - (ui32PageIndex << ui32Log2AllocPageSize);
+	IMG_UINT32 ui32PageIndex = ui32Offset >> PAGE_SHIFT;
+	IMG_UINT32 ui32InPageOffset = ui32Offset - (ui32PageIndex << PAGE_SHIFT);
 	IMG_DEV_PHYADDR sPA;
 
-	PVR_ASSERT(ui32InPageOffset < (1U << ui32Log2AllocPageSize));
+	PVR_ASSERT(ui32InPageOffset < (1U << PAGE_SHIFT));
 
 	sPA.uiAddr = phys_cpu2gpu(page_to_phys(psOSPageArrayData->pagearray[ui32PageIndex]));
 	sPA.uiAddr += ui32InPageOffset;
@@ -3143,7 +3874,7 @@ PMRSysPhysAddrOSMem(PMR_IMPL_PRIVDATA pvPriv,
 					IMG_UINT32 ui32Log2PageSize,
 					IMG_UINT32 ui32NumOfPages,
 					IMG_DEVMEM_OFFSET_T *puiOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 					IMG_UINT64 ui64IPAPolicyValue,
 					IMG_UINT64 ui64IPAClearMask,
 #endif
@@ -3153,12 +3884,12 @@ PMRSysPhysAddrOSMem(PMR_IMPL_PRIVDATA pvPriv,
 	const PMR_OSPAGEARRAY_DATA *psOSPageArrayData = pvPriv;
 	IMG_UINT32 uiIdx;
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	PVR_UNREFERENCED_PARAMETER(ui64IPAPolicyValue);
 	PVR_UNREFERENCED_PARAMETER(ui64IPAClearMask);
 #endif
 
-	if (psOSPageArrayData->uiLog2AllocPageSize < ui32Log2PageSize)
+	if (psOSPageArrayData->uiLog2DevPageSize < ui32Log2PageSize)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 		         "%s: Requested physical addresses from PMR "
@@ -3168,6 +3899,17 @@ PMRSysPhysAddrOSMem(PMR_IMPL_PRIVDATA pvPriv,
 		return PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY;
 	}
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	if (OSAtomicRead(&psOSPageArrayData->iNumOSPagesUnderMigration))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Requested physical addresses from PMR "
+		         "in process of page migration!",
+		         __func__));
+		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
+	}
+#endif
+
 	for (uiIdx=0; uiIdx < ui32NumOfPages; uiIdx++)
 	{
 		if (pbValid[uiIdx])
@@ -3193,7 +3935,7 @@ PMRSysPhysAddrOSMem(PMR_IMPL_PRIVDATA pvPriv,
 				}
 			}
 #endif
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 			/* Modify the physical address with the associated IPA values */
 			psDevPAddr[uiIdx].uiAddr &= ~ui64IPAClearMask;
 			psDevPAddr[uiIdx].uiAddr |= ui64IPAPolicyValue;
@@ -3229,25 +3971,20 @@ PMRAcquireKernelMappingDataOSMem(PMR_IMPL_PRIVDATA pvPriv,
 	IMG_UINT32 ui32PageOffset=0;
 	size_t uiMapOffset=0;
 	IMG_UINT32 ui32PageCount = 0;
-	IMG_UINT32 uiLog2AllocPageSize = psOSPageArrayData->uiLog2AllocPageSize;
-	IMG_UINT32 uiOSPageShift = OSGetPageShift();
-	IMG_UINT32 uiPageSizeDiff = 0;
+	IMG_UINT32 uiLog2DevPageSize = psOSPageArrayData->uiLog2DevPageSize;
 	struct page **pagearray;
 	PMR_OSPAGEARRAY_KERNMAP_DATA *psData;
 
-	/* For cases device page size greater than the OS page size,
-	 * multiple physically contiguous OS pages constitute one device page.
-	 * However only the first page address of such an ensemble is stored
-	 * as part of the mapping table in the driver. Hence when mapping the PMR
-	 * in part/full, all OS pages that constitute the device page
-	 * must also be mapped to kernel.
-	 *
-	 * For the case where device page size less than OS page size,
-	 * treat it the same way as the page sizes are equal */
-	if (uiLog2AllocPageSize > uiOSPageShift)
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	if (OSAtomicRead(&psOSPageArrayData->iNumOSPagesUnderMigration))
 	{
-		uiPageSizeDiff = uiLog2AllocPageSize - uiOSPageShift;
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Requested physical addresses from PMR "
+		         "in process of page migration!",
+		         __func__));
+		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
 	}
+#endif
 
 	/*
 		Zero offset and size as a special meaning which means map in the
@@ -3266,17 +4003,13 @@ PMRAcquireKernelMappingDataOSMem(PMR_IMPL_PRIVDATA pvPriv,
 	{
 		size_t uiEndoffset;
 
-		ui32PageOffset = uiOffset >> uiLog2AllocPageSize;
-		uiMapOffset = uiOffset - (ui32PageOffset << uiLog2AllocPageSize);
+		ui32PageOffset = uiOffset >> uiLog2DevPageSize;
+		uiMapOffset = uiOffset - (ui32PageOffset << uiLog2DevPageSize);
 		uiEndoffset = uiOffset + uiSize - 1;
 		/* Add one as we want the count, not the offset */
-		/* Page count = amount of device pages (note uiLog2AllocPageSize being used) */
-		ui32PageCount = (uiEndoffset >> uiLog2AllocPageSize) + 1;
+		/* Page count = amount of device pages (note uiLog2DevPageSize being used) */
+		ui32PageCount = (uiEndoffset >> uiLog2DevPageSize) + 1;
 		ui32PageCount -= ui32PageOffset;
-
-		/* The OS page count to be mapped might be different if the
-		 * OS page size is lesser than the device page size */
-		ui32PageCount <<= uiPageSizeDiff;
 	}
 
 	switch (PVRSRV_CPU_CACHE_MODE(psOSPageArrayData->ui32CPUCacheFlags))
@@ -3297,55 +4030,20 @@ PMRAcquireKernelMappingDataOSMem(PMR_IMPL_PRIVDATA pvPriv,
 				goto e0;
 	}
 
-	if (uiPageSizeDiff)
-	{
-		/* Each device page can be broken down into ui32SubPageCount OS pages */
-		IMG_UINT32 ui32SubPageCount = 1 << uiPageSizeDiff;
-		IMG_UINT32 i;
-		struct page **psPage = &psOSPageArrayData->pagearray[ui32PageOffset];
-
-		/* Allocate enough memory for the OS page pointers for this mapping */
-		pagearray = OSAllocMem(ui32PageCount * sizeof(pagearray[0]));
-
-		if (pagearray == NULL)
-		{
-			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-			goto e0;
-		}
-
-		/* construct array that holds the page pointers that constitute the requested
-		 * mapping */
-		for (i = 0; i < ui32PageCount; i++)
-		{
-			IMG_UINT32 ui32OSPageArrayIndex  = i / ui32SubPageCount;
-			IMG_UINT32 ui32OSPageArrayOffset = i % ui32SubPageCount;
-
-			/*
-			 * The driver only stores OS page pointers for the first OS page
-			 * within each device page (psPage[ui32OSPageArrayIndex]).
-			 * Get the next OS page structure at device page granularity,
-			 * then calculate OS page pointers for all the other pages.
-			 */
-			pagearray[i] = psPage[ui32OSPageArrayIndex] + ui32OSPageArrayOffset;
-		}
-	}
-	else
-	{
-		pagearray = &psOSPageArrayData->pagearray[ui32PageOffset];
-	}
+	pagearray = &psOSPageArrayData->pagearray[ui32PageOffset];
 
 	psData = OSAllocMem(sizeof(*psData));
 	if (psData == NULL)
 	{
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto e1;
+		goto e0;
 	}
 
 	pvAddress = pvr_vmap(pagearray, ui32PageCount, VM_MAP, prot);
 	if (pvAddress == NULL)
 	{
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		goto e2;
+		goto e1;
 	}
 
 	*ppvKernelAddressOut = pvAddress + uiMapOffset;
@@ -3354,11 +4052,6 @@ PMRAcquireKernelMappingDataOSMem(PMR_IMPL_PRIVDATA pvPriv,
 	psData->PageProps = prot;
 	*phHandleOut = psData;
 
-	if (uiPageSizeDiff)
-	{
-		OSFreeMem(pagearray);
-	}
-
 #if defined(PVRSRV_PHYSMEM_CPUMAP_HISTORY)
 	{
 		IMG_CPU_PHYADDR pvAddrPhy;
@@ -3379,13 +4072,8 @@ PMRAcquireKernelMappingDataOSMem(PMR_IMPL_PRIVDATA pvPriv,
 	/*
 	  error exit paths follow
 	*/
-e2:
-	OSFreeMem(psData);
 e1:
-	if (uiPageSizeDiff)
-	{
-		OSFreeMem(pagearray);
-	}
+	OSFreeMem(psData);
 e0:
 	PVR_ASSERT(eError != PVRSRV_OK);
 	return eError;
@@ -3425,6 +4113,9 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 						IMG_UINT32 *pai32AllocIndices,
 						IMG_UINT32 ui32FreePageCount,
 						IMG_UINT32 *pai32FreeIndices,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+						PMR_IMPL_ZOMBIEPAGES *ppvZombiePages,
+#endif
 						IMG_UINT32 uiFlags)
 {
 	PVRSRV_ERROR eError;
@@ -3434,11 +4125,6 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 	struct page **psPageArray = psPMRPageArrayData->pagearray;
 	void **psDMAVirtArray = psPMRPageArrayData->dmavirtarray;
 	dma_addr_t *psDMAPhysArray = psPMRPageArrayData->dmaphysarray;
-
-	struct page *psPage;
-	dma_addr_t psDMAPAddr;
-	void *pvDMAVAddr;
-
 	IMG_UINT32 ui32AdtnlAllocPages = 0; /*<! Number of pages to alloc from the OS */
 	IMG_UINT32 ui32AdtnlFreePages = 0; /*<! Number of pages to free back to the OS */
 	IMG_UINT32 ui32CommonRequestCount = 0; /*<! Number of pages to move position in the page array */
@@ -3446,8 +4132,8 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 	IMG_UINT32 ui32Index = 0;
 	IMG_UINT32 uiAllocpgidx;
 	IMG_UINT32 uiFreepgidx;
-	IMG_UINT32 uiOrder = psPMRPageArrayData->uiLog2AllocPageSize - PAGE_SHIFT;
-	IMG_BOOL bCMA = BIT_ISSET(psPMRPageArrayData->ui32AllocFlags, FLAG_IS_CMA);
+	IMG_UINT32 uiOrder = psPMRPageArrayData->uiLog2DevPageSize - PAGE_SHIFT;
+	IMG_BOOL bCMA = BIT_ISSET(psPMRPageArrayData->ui32AllocFlags, FLAG_DMA_CMA);
 
 
 	/* Check SPARSE flags and calculate pages to allocate and free */
@@ -3477,6 +4163,10 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 		ui32FreePageCount = 0;
 	}
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	*ppvZombiePages = NULL;
+#endif
+
 	if (0 == (ui32CommonRequestCount || ui32AdtnlAllocPages || ui32AdtnlFreePages))
 	{
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -3518,7 +4208,7 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 					goto e0;
 				}
 
-				if (NULL == psPageArray[uiFreepgidx])
+				if (NULL == (psPageArray[uiFreepgidx << uiOrder]))
 				{
 					eError = PVRSRV_ERROR_INVALID_PARAMS;
 					PVR_DPF((PVR_DBG_ERROR,
@@ -3549,7 +4239,7 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 			goto e0;
 		}
 
-		if ((NULL != psPageArray[uiAllocpgidx]) ||
+		if ((NULL != psPageArray[uiAllocpgidx << uiOrder]) ||
 		    (TRANSLATION_INVALID != psPMRMapTable->aui32Translation[uiAllocpgidx]))
 		{
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -3588,33 +4278,48 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 	/* Move the corresponding free pages to alloc request */
 	for (ui32Loop = 0; ui32Loop < ui32CommonRequestCount; ui32Loop++, ui32Index++)
 	{
-		uiAllocpgidx = pai32AllocIndices[ui32Index];
-		uiFreepgidx  = pai32FreeIndices[ui32Loop];
+		IMG_UINT32 uiOrderIdx;
+		uiAllocpgidx = pai32AllocIndices[ui32Index] << uiOrder;
+		uiFreepgidx  = pai32FreeIndices[ui32Loop] << uiOrder;
 
-		psPage = psPageArray[uiAllocpgidx];
-		psPageArray[uiAllocpgidx] = psPageArray[uiFreepgidx];
-
-		if (bCMA)
+		for (uiOrderIdx = 0; uiOrderIdx < (1 << uiOrder); uiOrderIdx++)
 		{
-			pvDMAVAddr = psDMAVirtArray[uiAllocpgidx];
-			psDMAPAddr = psDMAPhysArray[uiAllocpgidx];
-			psDMAVirtArray[uiAllocpgidx] = psDMAVirtArray[uiFreepgidx];
-			psDMAPhysArray[uiAllocpgidx] = psDMAPhysArray[uiFreepgidx];
+			psPageArray[uiAllocpgidx + uiOrderIdx] = psPageArray[uiFreepgidx + uiOrderIdx];
+			if (bCMA)
+			{
+				psDMAVirtArray[uiAllocpgidx + uiOrderIdx] = psDMAVirtArray[uiFreepgidx + uiOrderIdx];
+				psDMAPhysArray[uiAllocpgidx + uiOrderIdx] = psDMAPhysArray[uiFreepgidx + uiOrderIdx];
+				psDMAVirtArray[uiFreepgidx + uiOrderIdx] = NULL;
+				psDMAPhysArray[uiFreepgidx + uiOrderIdx] = (dma_addr_t)0;
+			}
+			psPageArray[uiFreepgidx + uiOrderIdx] = NULL;
 		}
 
 		psPMRMapTable->aui32Translation[uiFreepgidx] = TRANSLATION_INVALID;
 		psPMRMapTable->aui32Translation[uiAllocpgidx] = uiAllocpgidx;
-		psPageArray[uiFreepgidx] = NULL;
-		if (bCMA)
-		{
-			psDMAVirtArray[uiFreepgidx] = NULL;
-			psDMAPhysArray[uiFreepgidx] = (dma_addr_t)0;
-		}
 	}
 
-	/* Free the additional free pages */
+	/* Free or zombie the additional free pages */
 	if (0 != ui32AdtnlFreePages)
 	{
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+		PMR_OSPAGEARRAY_DATA *psExtractedPagesPageArray = NULL;
+
+		eError = _ExtractPages(psPMRPageArrayData,
+		                       &pai32FreeIndices[ui32Loop],
+		                       ui32AdtnlFreePages,
+		                       &psExtractedPagesPageArray);
+		if (eError != PVRSRV_OK)
+		{
+			goto e0;
+		}
+
+		/* Zombify pages to get proper stats */
+		eError = PMRZombifyOSMem(psExtractedPagesPageArray, NULL);
+		PVR_LOG_IF_ERROR(eError, "psExtractedPagesPageArray");
+
+		*ppvZombiePages = psExtractedPagesPageArray;
+#else
 		eError = _FreeOSPages(psPMRPageArrayData,
 		                      &pai32FreeIndices[ui32Loop],
 		                      ui32AdtnlFreePages);
@@ -3622,6 +4327,7 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 		{
 			goto e0;
 		}
+#endif /* SUPPORT_PMR_PAGES_DEFERRED_FREE */
 		psPMRMapTable->ui32NumPhysChunks -= ui32AdtnlFreePages;
 		while (ui32Loop < ui32FreePageCount)
 		{
@@ -3636,37 +4342,6 @@ PMRChangeSparseMemOSMem(PMR_IMPL_PRIVDATA pPriv,
 	return eError;
 }
 
-/*************************************************************************/ /*!
-@Function       PMRChangeSparseMemCPUMapOSMem
-@Description    This function Changes CPU maps accordingly
-@Return         PVRSRV_ERROR failure code
-*/ /**************************************************************************/
-static
-PVRSRV_ERROR PMRChangeSparseMemCPUMapOSMem(PMR_IMPL_PRIVDATA pPriv,
-                                           const PMR *psPMR,
-                                           IMG_UINT64 sCpuVAddrBase,
-                                           IMG_UINT32 ui32AllocPageCount,
-                                           IMG_UINT32 *pai32AllocIndices,
-                                           IMG_UINT32 ui32FreePageCount,
-                                           IMG_UINT32 *pai32FreeIndices)
-{
-	struct page **psPageArray;
-	PMR_OSPAGEARRAY_DATA *psPMRPageArrayData = (PMR_OSPAGEARRAY_DATA *)pPriv;
-	IMG_CPU_PHYADDR sCPUPAddr;
-
-	sCPUPAddr.uiAddr = 0;
-	psPageArray = psPMRPageArrayData->pagearray;
-
-	return OSChangeSparseMemCPUAddrMap((void **)psPageArray,
-	                                   sCpuVAddrBase,
-	                                   sCPUPAddr,
-	                                   ui32AllocPageCount,
-	                                   pai32AllocIndices,
-	                                   ui32FreePageCount,
-	                                   pai32FreeIndices,
-	                                   IMG_FALSE);
-}
-
 static PMR_IMPL_FUNCTAB _sPMROSPFuncTab = {
 	.pfnLockPhysAddresses = &PMRLockSysPhysAddressesOSMem,
 	.pfnUnlockPhysAddresses = &PMRUnlockSysPhysAddressesOSMem,
@@ -3676,8 +4351,10 @@ static PMR_IMPL_FUNCTAB _sPMROSPFuncTab = {
 	.pfnReadBytes = NULL,
 	.pfnWriteBytes = NULL,
 	.pfnChangeSparseMem = &PMRChangeSparseMemOSMem,
-	.pfnChangeSparseMemCPUMap = &PMRChangeSparseMemCPUMapOSMem,
 	.pfnFinalize = &PMRFinalizeOSMem,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	.pfnFreeZombiePages = &PMRFreeZombiePagesOSMem,
+#endif
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
 	.pfnZombify = &PMRZombifyOSMem,
 #endif
@@ -3688,13 +4365,13 @@ static PVRSRV_ERROR
 DoPageAlloc(PMR_OSPAGEARRAY_DATA *psPrivData,
             IMG_UINT32 *puiAllocIndices,
             IMG_UINT32 ui32NumPhysChunks,
-            IMG_UINT32 ui32NumVirtChunks,
+            IMG_UINT32 ui32NumLogicalChunks,
             IMG_UINT32 ui32Log2AllocPageSize)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 
 	/* Do we fill the whole page array or just parts (sparse)? */
-	if (ui32NumPhysChunks == ui32NumVirtChunks)
+	if (ui32NumPhysChunks == ui32NumLogicalChunks)
 	{
 		/* Allocate the physical pages */
 		eError = _AllocOSPages(psPrivData,
@@ -3712,21 +4389,31 @@ DoPageAlloc(PMR_OSPAGEARRAY_DATA *psPrivData,
 	return eError;
 }
 
-static void _EncodeAllocationFlags(IMG_UINT32 uiLog2AllocPageSize,
+static void _EncodeAllocationFlags(IMG_UINT32 uiLog2DevPageSize,
 	                               PVRSRV_MEMALLOCFLAGS_T uiFlags,
 	                               IMG_UINT32* ui32AllocFlags)
 {
 
+	if (PVRSRV_CHECK_OS_LINUX_PREFER_CMA(uiFlags))
+	{
+		BIT_SET(*ui32AllocFlags, FLAG_PREF_CMA);
+	}
 	/*
 	 * Use CMA framework if order is greater than OS page size; please note
 	 * that OSMMapPMRGeneric() has the same expectation as well.
 	 */
-	/* IsCMA? */
-	if (uiLog2AllocPageSize > PAGE_SHIFT)
+	else if (uiLog2DevPageSize > PAGE_SHIFT)
 	{
-		BIT_SET(*ui32AllocFlags, FLAG_IS_CMA);
+		BIT_SET(*ui32AllocFlags, FLAG_DMA_CMA);
 	}
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	if (PVRSRV_CHECK_OS_LINUX_MOVABLE(uiFlags))
+	{
+		BIT_SET(*ui32AllocFlags, FLAG_IS_MOVABLE);
+	}
+#endif
+
 	/* OnDemand? */
 	if (PVRSRV_CHECK_ON_DEMAND(uiFlags))
 	{
@@ -3781,9 +4468,9 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 						 CONNECTION_DATA *psConnection,
 						 IMG_DEVMEM_SIZE_T uiSize,
 						 IMG_UINT32 ui32NumPhysChunks,
-						 IMG_UINT32 ui32NumVirtChunks,
+						 IMG_UINT32 ui32NumLogicalChunks,
 						 IMG_UINT32 *puiAllocIndices,
-						 IMG_UINT32 uiLog2AllocPageSize,
+						 IMG_UINT32 uiLog2DevPageSize,
 						 PVRSRV_MEMALLOCFLAGS_T uiFlags,
 						 const IMG_CHAR *pszAnnotation,
 						 IMG_PID uiPid,
@@ -3798,14 +4485,18 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 	IMG_UINT32 ui32CPUCacheFlags;
 	IMG_UINT32 ui32AllocFlags = 0;
 	PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPhysHeap);
+	IMG_UINT32 ui32ValidPageSizeMask = psDevNode->psMMUDevAttrs->ui32ValidPageSizeMask;
+	IMG_UINT32 ui32PageSize = IMG_PAGE2BYTES32(uiLog2DevPageSize);
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
+	PVR_LOG_GOTO_IF_INVALID_PARAM(ui32PageSize & ui32ValidPageSizeMask, eError, errorOnParam);
+
 	/*
 	 * The host driver (but not guest) can still use this factory for firmware
 	 * allocations
 	 */
-	if (PVRSRV_VZ_MODE_IS(GUEST) && PVRSRV_CHECK_FW_MAIN(uiFlags))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode) && PVRSRV_CHECK_FW_MAIN(uiFlags))
 	{
 		PVR_ASSERT(0);
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -3813,7 +4504,7 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 	}
 
 	/* Select correct caching mode */
-	eError = DevmemCPUCacheMode(psDevNode, uiFlags, &ui32CPUCacheFlags);
+	eError = DevmemCPUCacheMode(uiFlags, &ui32CPUCacheFlags);
 	if (eError != PVRSRV_OK)
 	{
 		goto errorOnParam;
@@ -3824,7 +4515,16 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 		ui32CPUCacheFlags |= PVRSRV_MEMALLOCFLAG_CPU_CACHE_CLEAN;
 	}
 
-	_EncodeAllocationFlags(uiLog2AllocPageSize, uiFlags, &ui32AllocFlags);
+	_EncodeAllocationFlags(uiLog2DevPageSize, uiFlags, &ui32AllocFlags);
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	/* Reject sparse PMR marked for migrate */
+	if (BIT_ISSET(ui32AllocFlags, FLAG_IS_MOVABLE) &&
+	   (ui32NumPhysChunks != ui32NumLogicalChunks|| ui32NumLogicalChunks > 1))
+	{
+		PVR_LOG_GOTO_WITH_ERROR("PhysmemNewOSRamBackedPMR", eError, PVRSRV_ERROR_INVALID_PARAMS, errorOnParam);
+	}
+#endif
 
 
 #if defined(PVR_LINUX_PHYSMEM_ZERO_ALL_PAGES)
@@ -3837,26 +4537,32 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 	   very restrictive conditions, also there is a maximum alignment value
 	   which must not exceed the largest device page-size. If these are not
 	   met then fail the aligned-requested allocation */
-	if (BIT_ISSET(ui32AllocFlags, FLAG_IS_CMA))
+	if (uiLog2DevPageSize > PAGE_SHIFT)
 	{
-		IMG_UINT32 uiAlign = 1 << uiLog2AllocPageSize;
-		if (uiAlign > uiSize || uiAlign > (1 << PVR_MAX_PHYSMEM_CONTIG_ALLOC_LOG2PGSZ))
+		IMG_UINT64 ui64InvalidSizeMask = ui32PageSize - 1;
+		IMG_UINT32 ui32PageSizeMask = psDevNode->psMMUDevAttrs->ui32ValidPageSizeMask;
+		IMG_UINT32 ui32MaxPageSize = 1;
+
+		while (ui32PageSizeMask > 1)
+		{
+			ui32PageSizeMask >>= 1;
+			ui32MaxPageSize <<= 1;
+		}
+
+		if ((uiSize & ui64InvalidSizeMask) || (ui32PageSize > ui32MaxPageSize))
 		{
 			PVR_DPF((PVR_DBG_ERROR,
 					"%s: Invalid PA alignment: size 0x%llx, align 0x%x",
-					__func__, uiSize, uiAlign));
+					__func__, uiSize, ui32PageSize));
 			eError = PVRSRV_ERROR_INVALID_ALIGNMENT;
 			goto errorOnParam;
 		}
-		PVR_ASSERT(uiLog2AllocPageSize > PVR_MIN_PHYSMEM_CONTIG_ALLOC_LOG2PGSZ);
 	}
 
 	/* Create Array structure that hold the physical pages */
 	eError = _AllocOSPageArray(psDevNode,
 							   uiSize,
-							   ui32NumPhysChunks,
-							   ui32NumVirtChunks,
-							   uiLog2AllocPageSize,
+							   uiLog2DevPageSize,
 							   ui32AllocFlags,
 							   ui32CPUCacheFlags,
 							   uiPid,
@@ -3866,10 +4572,23 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 		goto errorOnAllocPageArray;
 	}
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+	if (psConnection)
+	{
+		psPrivData->psDRMFile = ((ENV_CONNECTION_DATA*)psConnection->hOsPrivateData)->psDRMFile;
+	}
+	else
+	{
+		psPrivData->psDRMFile = NULL;
+	}
+#endif
+#endif
+
 	if (!BIT_ISSET(ui32AllocFlags, FLAG_ONDEMAND))
 	{
 		eError = DoPageAlloc(psPrivData, puiAllocIndices, ui32NumPhysChunks,
-		                     ui32NumVirtChunks, uiLog2AllocPageSize);
+		                     ui32NumLogicalChunks, uiLog2DevPageSize);
 		if (eError != PVRSRV_OK)
 		{
 			goto errorOnAllocPages;
@@ -3900,9 +4619,9 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 	eError = PMRCreatePMR(psPhysHeap,
 						  uiSize,
 						  ui32NumPhysChunks,
-						  ui32NumVirtChunks,
+						  ui32NumLogicalChunks,
 						  puiAllocIndices,
-						  uiLog2AllocPageSize,
+						  uiLog2DevPageSize,
 						  uiPMRFlags,
 						  pszAnnotation,
 						  &_sPMROSPFuncTab,
@@ -3915,10 +4634,7 @@ PhysmemNewOSRamBackedPMR(PHYS_HEAP *psPhysHeap,
 		goto errorOnCreate;
 	}
 
-#if defined(PVRSRV_PHYSMEM_CPUMAP_HISTORY)
 	psPrivData->hPMR = psPMR;
-#endif
-
 	*ppsPMRPtr = psPMR;
 
 	return PVRSRV_OK;
diff --git a/drivers/gpu/drm/img-rogue/physmem_osmem_linux.h b/drivers/gpu/drm/img-rogue/physmem_osmem_linux.h
index 89706fffdc5c..c9d7e5ce5083 100644
--- a/drivers/gpu/drm/img-rogue/physmem_osmem_linux.h
+++ b/drivers/gpu/drm/img-rogue/physmem_osmem_linux.h
@@ -43,7 +43,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef PHYSMEM_OSMEM_LINUX_H
 #define PHYSMEM_OSMEM_LINUX_H
 
-void LinuxInitPhysmem(void);
+PVRSRV_ERROR LinuxInitPhysmem(void);
 void LinuxDeinitPhysmem(void);
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0))
+int LinuxRegisterMigrateCallbacks(struct file* filp);
+void LinuxDeregisterMigrateCallbacks(struct file* filp);
+#endif
+#endif
+
 #endif /* PHYSMEM_OSMEM_LINUX_H */
diff --git a/drivers/gpu/drm/img-rogue/physmem_ramem.c b/drivers/gpu/drm/img-rogue/physmem_ramem.c
new file mode 100644
index 000000000000..6597042770d9
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/physmem_ramem.c
@@ -0,0 +1,2609 @@
+/*************************************************************************/ /*!
+@File           physmem_ramem.c
+@Title          Resource allocator managed PMR Factory common definitions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Part of Services memory management.  This file defines the
+                RA managed memory PMR factory API that is shared between local
+                physheap implementations (LMA & IMA)
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include "img_types.h"
+#include "pvr_debug.h"
+#include "pvrsrv_error.h"
+#include "pvrsrv_memallocflags.h"
+#include "physmem_ramem.h"
+#include "physheap.h"
+#include "allocmem.h"
+#include "ra.h"
+#include "connection_server.h"
+#include "device.h"
+#include "devicemem_server_utils.h"
+#include "osfunc.h"
+#include "pmr.h"
+#include "pmr_impl.h"
+#include "rgx_pdump_panics.h"
+#include "pdump_km.h"
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#include "process_stats.h"
+#endif
+
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+#include "rgxutils.h"
+#endif
+
+#if defined(INTEGRITY_OS)
+#include "mm.h"
+#include "integrity_memobject.h"
+#endif
+
+#include "physmem_dlm.h"
+
+
+#if defined(PVRSRV_PHYSHEAP_DISABLE_OOM_DEMOTION)
+#define PHYSHEAP_DPF_LVL PVR_DBG_ERROR
+#else
+#define PHYSHEAP_DPF_LVL PVR_DBG_WARNING
+#endif
+
+/* Common Physheap Callback implementations */
+
+IMG_UINT32
+RAMemGetPageShift(void)
+{
+	return PVRSRV_4K_PAGE_SIZE_ALIGNSHIFT;
+}
+
+PVRSRV_ERROR
+RAMemDoPhyContigPagesAlloc(RA_ARENA *pArena,
+                           size_t uiSize,
+                           PVRSRV_DEVICE_NODE *psDevNode,
+                           PG_HANDLE *psMemHandle,
+                           IMG_DEV_PHYADDR *psDevPAddr,
+                           IMG_PID uiPid)
+{
+	RA_BASE_T uiCardAddr = 0;
+	RA_LENGTH_T uiActualSize;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32Log2NumPages;
+
+#if defined(DEBUG)
+	static IMG_UINT32 ui32MaxLog2NumPagesHistory = 0;
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	/* Firmware heaps on VZ are usually LMA, and several 64kb allocations need to
+	 * be made on Guest drivers: FwGuardPage, FwSysInit, FwConnectionCtl, FwOsInit.
+	 * Increase the maximum number to avoid driver warnings. */
+	IMG_UINT32	ui32MaxLog2NumPages = 7;	/* 128 pages => 512KB */
+#else
+	IMG_UINT32	ui32MaxLog2NumPages = 4;	/*  16 pages =>  64KB */
+#endif
+	ui32MaxLog2NumPages = MAX(ui32MaxLog2NumPages, OSGetOrder(1 << psDevNode->ui32Non4KPageSizeLog2));
+#else /* defined(DEBUG) */
+	PVR_UNREFERENCED_PARAMETER(psDevNode);
+#endif /* defined(DEBUG) */
+
+	PVR_ASSERT(uiSize != 0);
+	ui32Log2NumPages = OSGetOrder(uiSize);
+	uiSize = IMG_PAGES2BYTES64(OSGetPageSize(),ui32Log2NumPages);
+
+	eError = RA_Alloc(pArena,
+	                  uiSize,
+	                  RA_NO_IMPORT_MULTIPLIER,
+	                  0,                         /* No flags */
+	                  uiSize,
+	                  "RAMemPhyContigPagesAlloc",
+	                  &uiCardAddr,
+	                  &uiActualSize,
+	                  NULL);                     /* No private handle */
+
+	if (eError != PVRSRV_OK)
+	{
+		RA_USAGE_STATS sRAStats;
+		RA_Get_Usage_Stats(pArena, &sRAStats);
+
+		PVR_DPF((PVR_DBG_ERROR,
+				"Failed to Allocate size = 0x"IMG_SIZE_FMTSPECX", align = 0x"
+				IMG_SIZE_FMTSPECX" Arena Free Space 0x%"IMG_UINT64_FMTSPECX,
+				uiSize, uiSize,	sRAStats.ui64FreeArenaSize));
+		return eError;
+	}
+
+	PVR_ASSERT(uiSize == uiActualSize);
+
+	psMemHandle->u.ui64Handle = uiCardAddr;
+	psDevPAddr->uiAddr = (IMG_UINT64) uiCardAddr;
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsIncrMemAllocStatAndTrack(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
+	                                    uiSize,
+	                                    uiCardAddr,
+	                                    uiPid);
+#else
+	{
+		IMG_CPU_PHYADDR sCpuPAddr;
+		sCpuPAddr.uiAddr = psDevPAddr->uiAddr;
+
+		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
+									 NULL,
+									 sCpuPAddr,
+									 uiSize,
+									 uiPid
+									 DEBUG_MEMSTATS_VALUES);
+	}
+#endif
+#else /* PVRSRV_ENABLE_PROCESS_STATS */
+	PVR_UNREFERENCED_PARAMETER(uiPid);
+#endif /* PVRSRV_ENABLE_PROCESS_STATS */
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+	PVR_DPF((PVR_DBG_MESSAGE,
+	        "%s: (GPU Virtualisation) Allocated 0x" IMG_SIZE_FMTSPECX " at 0x%"
+	        IMG_UINT64_FMTSPECX ", Arena ID %u",
+	        __func__, uiSize, psDevPAddr->uiAddr, psMemHandle->uiOSid));
+#endif
+
+#if defined(DEBUG)
+	if (ui32Log2NumPages > ui32MaxLog2NumPages && ui32Log2NumPages > ui32MaxLog2NumPagesHistory)
+	{
+		PVR_ASSERT((ui32Log2NumPages <= ui32MaxLog2NumPages));
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: ui32MaxLog2NumPages = %u, increasing to %u", __func__,
+		        ui32MaxLog2NumPages, ui32Log2NumPages ));
+		ui32MaxLog2NumPagesHistory = ui32Log2NumPages;
+	}
+#endif /* defined(DEBUG) */
+	psMemHandle->uiOrder = ui32Log2NumPages;
+
+	return eError;
+}
+
+void
+RAMemDoPhyContigPagesFree(RA_ARENA *pArena,
+                          PG_HANDLE *psMemHandle)
+{
+	RA_BASE_T uiCardAddr = (RA_BASE_T) psMemHandle->u.ui64Handle;
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsDecrMemAllocStatAndUntrack(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
+	                                      (IMG_UINT64)uiCardAddr);
+#else
+	PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA,
+									(IMG_UINT64)uiCardAddr,
+									OSGetCurrentClientProcessIDKM());
+#endif
+#endif
+
+	RA_Free(pArena, uiCardAddr);
+	psMemHandle->uiOrder = 0;
+}
+
+PVRSRV_ERROR
+RAMemPhyContigPagesMap(PHYS_HEAP *psPhysHeap,
+                       PG_HANDLE *psMemHandle,
+                       size_t uiSize, IMG_DEV_PHYADDR *psDevPAddr,
+                       void **pvPtr)
+{
+	IMG_CPU_PHYADDR sCpuPAddr;
+	IMG_UINT32 ui32NumPages = (1 << psMemHandle->uiOrder);
+	PVR_UNREFERENCED_PARAMETER(uiSize);
+
+	PhysHeapDevPAddrToCpuPAddr(psPhysHeap, 1, &sCpuPAddr, psDevPAddr);
+	*pvPtr = OSMapPhysToLin(sCpuPAddr,
+							ui32NumPages * OSGetPageSize(),
+							PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC);
+	PVR_RETURN_IF_NOMEM(*pvPtr);
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
+	                            ui32NumPages * OSGetPageSize(),
+	                            OSGetCurrentClientProcessIDKM());
+#else
+	{
+		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
+									 *pvPtr,
+									 sCpuPAddr,
+									 ui32NumPages * OSGetPageSize(),
+									 OSGetCurrentClientProcessIDKM()
+									 DEBUG_MEMSTATS_VALUES);
+	}
+#endif
+#endif
+	return PVRSRV_OK;
+}
+
+void
+RAMemPhyContigPagesUnmap(PHYS_HEAP *psPhysHeap,
+                         PG_HANDLE *psMemHandle,
+                         void *pvPtr)
+{
+	IMG_UINT32 ui32NumPages = (1 << psMemHandle->uiOrder);
+	PVR_UNREFERENCED_PARAMETER(psPhysHeap);
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
+		                            ui32NumPages * OSGetPageSize(),
+		                            OSGetCurrentClientProcessIDKM());
+#else
+	PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA,
+	                                (IMG_UINT64)(uintptr_t)pvPtr,
+	                                OSGetCurrentClientProcessIDKM());
+#endif
+#endif
+
+	OSUnMapPhysToLin(pvPtr, ui32NumPages * OSGetPageSize());
+}
+
+PVRSRV_ERROR
+RAMemPhyContigPagesClean(PHYS_HEAP *psPhysHeap,
+                         PG_HANDLE *psMemHandle,
+                         IMG_UINT32 uiOffset,
+                         IMG_UINT32 uiLength)
+{
+	/* No need to flush because we map as uncached */
+	PVR_UNREFERENCED_PARAMETER(psPhysHeap);
+	PVR_UNREFERENCED_PARAMETER(psMemHandle);
+	PVR_UNREFERENCED_PARAMETER(uiOffset);
+	PVR_UNREFERENCED_PARAMETER(uiLength);
+
+	return PVRSRV_OK;
+}
+
+/* Local memory allocation routines */
+
+/* Assert that the conversions between the RA base type and the device
+ * physical address are safe.
+ */
+static_assert(sizeof(IMG_DEV_PHYADDR) == sizeof(RA_BASE_T),
+              "Size IMG_DEV_PHYADDR != RA_BASE_T");
+
+/* Since 0x0 is a valid DevPAddr, we rely on max 64-bit value to be an invalid
+ * page address */
+#define INVALID_PAGE_ADDR ~((IMG_UINT64)0x0)
+#define ZERO_PAGE_VALUE 0
+
+typedef struct _PMR_KERNEL_MAP_HANDLE_ {
+	void *vma;
+	void *pvKernelAddress;
+	/* uiSize has 2 uses:
+	 * In Physically contiguous case it is used to track size of the mapping
+	 * for free.
+	 * In Physically sparse case it is used to determine free path to use, single page
+	 * sparse mapping or multi page
+	 */
+	size_t uiSize;
+} PMR_KERNEL_MAPPING;
+
+typedef struct _PMR_LMALLOCARRAY_DATA_ {
+
+#define FLAG_ZERO              (0U)
+#define FLAG_POISON_ON_FREE    (1U)
+#define FLAG_POISON_ON_ALLOC   (2U)
+#define FLAG_ONDEMAND          (3U)
+#define FLAG_SPARSE            (4U)
+#define FLAG_PHYS_CONTIG       (5U)
+#define FLAG_ZOMBIE            (6U)
+
+	IMG_PID uiPid;
+
+	/*
+	 * N.B Chunks referenced in this struct commonly are
+	 * to OS page sized. But in reality it is dependent on
+	 * the uiLog2ChunkSize.
+	 * Chunks will always be one 1 << uiLog2ChunkSize in size.
+	 * */
+
+	/*
+	 * The number of chunks currently allocated in the PMR.
+	 */
+	IMG_INT32 iNumChunksAllocated;
+
+	/*
+	 * Total number of (Virtual) chunks supported by this PMR.
+	 */
+	IMG_UINT32 uiTotalNumChunks;
+
+	/* The number of chunks to next be allocated for the PMR.
+	 * This will initially be the number allocated at first alloc
+	 * but may be changed in later calls to change sparse.
+	 * It represents the number of chunks to next be allocated.
+	 * This is used to store this value because we have the ability to
+	 * defer allocation.
+	 */
+	IMG_UINT32 uiChunksToAlloc;
+
+	/*
+	 * Log2 representation of the chunksize.
+	 */
+	IMG_UINT32 uiLog2ChunkSize;
+
+	/* Physical heap and arena pointers for this allocation */
+	PHYS_HEAP* psPhysHeap;
+	RA_ARENA* psArena;
+	PVRSRV_MEMALLOCFLAGS_T uiAllocFlags;
+
+	/*
+	   Connection data for this requests' originating process. NULL for
+	   direct-bridge originating calls
+	 */
+	CONNECTION_DATA *psConnection;
+
+	/*
+	 * Allocation flags related to the pages:
+	 * Zero              - Should we Zero memory on alloc
+	 * Poison on free    - Should we Poison the memory on free.
+	 * Poison on alloc   - Should we Poison the memory on alloc.
+	 * On demand         - Is the allocation on Demand i.e Do we defer allocation to time of use.
+	 * Sparse            - Is the PMR sparse.
+	 * Phys Contig       - Is the alloc Physically contiguous
+	 * Zombie            - Is zombie
+	 * */
+	IMG_UINT32 ui32Flags;
+
+	RA_BASE_ARRAY_T aBaseArray; /* Array of RA Bases */
+
+} PMR_LMALLOCARRAY_DATA;
+
+static PVRSRV_ERROR
+_FreeLMPages(PMR_LMALLOCARRAY_DATA *psPageArrayData,
+             IMG_UINT32 *pui32FreeIndices,
+             IMG_UINT32 ui32FreeChunkCount);
+
+static PVRSRV_ERROR _MapPhysicalContigAlloc(PHYS_HEAP *psPhysHeap,
+                                            RA_BASE_ARRAY_T paBaseArray,
+                                            size_t uiSize,
+                                            PMR_FLAGS_T ulFlags,
+                                            PMR_KERNEL_MAPPING *psMapping)
+{
+	IMG_UINT32 ui32CPUCacheFlags;
+	PVRSRV_ERROR eError;
+	IMG_CPU_PHYADDR sCpuPAddr;
+	IMG_DEV_PHYADDR sDevPAddr;
+	sDevPAddr.uiAddr = RA_BASE_STRIP_GHOST_BIT(*paBaseArray);
+
+	eError = DevmemCPUCacheMode(ulFlags, &ui32CPUCacheFlags);
+	PVR_RETURN_IF_ERROR(eError);
+
+	PhysHeapDevPAddrToCpuPAddr(psPhysHeap,
+	                           1,
+	                           &sCpuPAddr,
+	                           &sDevPAddr);
+
+	psMapping->pvKernelAddress = OSMapPhysToLin(sCpuPAddr, uiSize, ui32CPUCacheFlags);
+	PVR_LOG_RETURN_IF_FALSE(psMapping->pvKernelAddress,
+	                        "OSMapPhyToLin: out of VM Mem",
+	                        PVRSRV_ERROR_PMR_NO_KERNEL_MAPPING);
+	psMapping->vma = NULL;
+	psMapping->uiSize = uiSize;
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR _MapPhysicalSparseAlloc(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
+                                            RA_BASE_ARRAY_T paBaseArray,
+                                            size_t uiSize,
+                                            PMR_KERNEL_MAPPING *psMapping)
+{
+	IMG_UINT32 uiChunkCount = uiSize >> psLMAllocArrayData->uiLog2ChunkSize;
+	IMG_CPU_PHYADDR uiPages[PMR_MAX_TRANSLATION_STACK_ALLOC], *puiPages;
+	PVRSRV_ERROR eError;
+	size_t uiPageShift = OSGetPageShift();
+	IMG_UINT32 uiOSPagesPerChunkShift = psLMAllocArrayData->uiLog2ChunkSize - uiPageShift;
+	IMG_UINT32 uiOSPageCount = uiChunkCount << uiOSPagesPerChunkShift;
+
+	if (uiOSPageCount > PMR_MAX_TRANSLATION_STACK_ALLOC)
+	{
+		puiPages = OSAllocZMem(sizeof(IMG_CPU_PHYADDR) * uiOSPageCount);
+		PVR_RETURN_IF_NOMEM(puiPages);
+	}
+	else
+	{
+		puiPages = &uiPages[0];
+	}
+
+	if (uiOSPagesPerChunkShift == 0)
+	{
+		IMG_UINT32 i;
+		PhysHeapDevPAddrToCpuPAddr(psLMAllocArrayData->psPhysHeap,
+								   uiChunkCount,
+								   puiPages,
+								   (IMG_DEV_PHYADDR *)paBaseArray);
+
+		/* If the ghost bit is present then the addrs returned will be off by 1
+		 * Strip the ghost bit to correct to real page aligned addresses.
+		 * */
+		for (i = 0; i < uiChunkCount; i++)
+		{
+			puiPages[i].uiAddr = RA_BASE_STRIP_GHOST_BIT(puiPages[i].uiAddr);
+		}
+	}
+	else
+	{
+		IMG_UINT32 i = 0, j = 0, index = 0;
+		for (i = 0; i < uiChunkCount; i++)
+		{
+			IMG_UINT32 ui32OSPagesPerDeviceChunk = (1 << uiOSPagesPerChunkShift);
+			IMG_DEV_PHYADDR uiDevAddr;
+			uiDevAddr.uiAddr = RA_BASE_STRIP_GHOST_BIT(paBaseArray[i]);
+			for (j = 0; j < ui32OSPagesPerDeviceChunk; j++)
+			{
+				PhysHeapDevPAddrToCpuPAddr(psLMAllocArrayData->psPhysHeap,
+										   1,
+										   &puiPages[index],
+										   &uiDevAddr);
+				uiDevAddr.uiAddr += (1ULL << uiPageShift);
+				index++;
+			}
+		}
+	}
+
+	eError = OSMapPhysArrayToLin(puiPages,
+	                             uiOSPageCount,
+	                             &psMapping->pvKernelAddress,
+	                             &psMapping->vma);
+	if (eError == PVRSRV_OK)
+	{
+		psMapping->uiSize = uiSize;
+	}
+
+	if (puiPages != &uiPages[0])
+	{
+		OSFreeMem(puiPages);
+	}
+
+	return eError;
+}
+
+static PVRSRV_ERROR _MapPMRKernel(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
+                                  RA_BASE_ARRAY_T paBaseArray,
+                                  size_t uiSize,
+                                  PMR_FLAGS_T ulFlags,
+                                  PMR_KERNEL_MAPPING *psMapping)
+{
+	PVRSRV_ERROR eError;
+	PHYS_HEAP *psPhysHeap = psLMAllocArrayData->psPhysHeap;
+	if (!BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		/* Physically Contig */
+		if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+		{
+			eError = _MapPhysicalContigAlloc(psPhysHeap,
+			                                 paBaseArray,
+			                                 uiSize,
+			                                 ulFlags,
+			                                 psMapping);
+		}
+		/* Physically Sparse */
+		else
+		{
+			eError = _MapPhysicalSparseAlloc(psLMAllocArrayData,
+			                                 paBaseArray,
+			                                 uiSize,
+			                                 psMapping);
+		}
+	}
+	else
+	{
+		/* Sparse Alloc Single Chunk */
+		if (uiSize == IMG_PAGE2BYTES64(psLMAllocArrayData->uiLog2ChunkSize))
+		{
+			eError = _MapPhysicalContigAlloc(psPhysHeap,
+			                                 paBaseArray,
+			                                 uiSize,
+			                                 ulFlags,
+			                                 psMapping);
+		}
+		/* Sparse Alloc Multi Chunk */
+		else
+		{
+			eError = _MapPhysicalSparseAlloc(psLMAllocArrayData,
+			                                 paBaseArray,
+			                                 uiSize,
+			                                 psMapping);
+		}
+	}
+
+	return eError;
+}
+
+static void _UnMapPhysicalContigAlloc(PMR_KERNEL_MAPPING *psKernelMapping)
+{
+	OSUnMapPhysToLin(psKernelMapping->pvKernelAddress, psKernelMapping->uiSize);
+}
+
+static void _UnMapPhysicalSparseAlloc(PMR_KERNEL_MAPPING *psKernelMapping)
+{
+	OSUnMapPhysArrayToLin(psKernelMapping->pvKernelAddress,
+	                   psKernelMapping->vma);
+}
+
+static void _UnMapPMRKernel(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
+                            PMR_KERNEL_MAPPING *psKernelMapping)
+{
+	if (!BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		/* Physically Contig */
+		if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+		{
+			_UnMapPhysicalContigAlloc(psKernelMapping);
+		}
+		/* Physically Sparse */
+		else
+		{
+			_UnMapPhysicalSparseAlloc(psKernelMapping);
+		}
+	}
+	else
+	{
+		/* Sparse Alloc Single Chunk */
+		if (psKernelMapping->uiSize == IMG_PAGE2BYTES64(psLMAllocArrayData->uiLog2ChunkSize))
+		{
+			_UnMapPhysicalContigAlloc(psKernelMapping);
+		}
+		/* Sparse Alloc Multi Chunk */
+		else
+		{
+			_UnMapPhysicalSparseAlloc(psKernelMapping);
+		}
+	}
+}
+
+static PVRSRV_ERROR
+_PhysPgMemSet(PMR_LMALLOCARRAY_DATA *psLMAllocArrayData,
+              RA_BASE_ARRAY_T paBaseArray,
+              size_t uiSize,
+              IMG_BYTE ui8SetValue)
+{
+	PVRSRV_ERROR eError;
+	PMR_KERNEL_MAPPING sKernelMapping;
+
+	eError = _MapPMRKernel(psLMAllocArrayData,
+	                       paBaseArray,
+	                       uiSize,
+	                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
+	                       &sKernelMapping);
+	PVR_GOTO_IF_ERROR(eError, map_failed);
+
+	OSCachedMemSetWMB(sKernelMapping.pvKernelAddress, ui8SetValue, uiSize);
+
+	_UnMapPMRKernel(psLMAllocArrayData, &sKernelMapping);
+
+	return PVRSRV_OK;
+
+map_failed:
+	PVR_DPF((PVR_DBG_ERROR, "Failed to poison/zero allocation"));
+	return eError;
+}
+
+static PVRSRV_ERROR
+_AllocLMPageArray(PMR_SIZE_T uiSize,
+                  IMG_UINT32 ui32NumPhysChunks,
+                  IMG_UINT32 uiLog2AllocPageSize,
+                  IMG_UINT32 ui32Flags,
+                  PHYS_HEAP* psPhysHeap,
+                  RA_ARENA* pArena,
+                  PVRSRV_MEMALLOCFLAGS_T uiAllocFlags,
+                  IMG_PID uiPid,
+                  PMR_LMALLOCARRAY_DATA **ppsPageArrayDataPtr,
+                  CONNECTION_DATA *psConnection)
+{
+	PMR_LMALLOCARRAY_DATA *psPageArrayData = NULL;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiNumPages;
+
+	PVR_ASSERT(!BIT_ISSET(ui32Flags, FLAG_ZERO) || !BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC));
+	PVR_ASSERT(OSGetPageShift() <= uiLog2AllocPageSize);
+
+	/* Use of cast below is justified by the assertion that follows to
+	prove that no significant bits have been truncated */
+	uiNumPages = (IMG_UINT32)(((uiSize - 1) >> uiLog2AllocPageSize) + 1);
+	PVR_ASSERT(((PMR_SIZE_T)uiNumPages << uiLog2AllocPageSize) == uiSize);
+
+	psPageArrayData = OSAllocMem(sizeof(PMR_LMALLOCARRAY_DATA) + IMG_FLEX_ARRAY_SIZE(sizeof(RA_BASE_T), uiNumPages));
+	PVR_GOTO_IF_NOMEM(psPageArrayData, eError, errorOnAllocArray);
+
+	if (BIT_ISSET(ui32Flags, FLAG_SPARSE))
+	{
+		/* Since no pages are allocated yet, initialise page addresses to INVALID_PAGE_ADDR */
+		OSCachedMemSet(psPageArrayData->aBaseArray,
+					   0xFF,
+					   sizeof(RA_BASE_T) *
+					   uiNumPages);
+	}
+	else
+	{
+		/* Base pointers have been allocated for the full PMR in case we require a non
+		 * physically contiguous backing for the virtually contiguous allocation but the most
+		 * common case will be contiguous and so only require the first Base to be present
+		 */
+		psPageArrayData->aBaseArray[0] = INVALID_BASE_ADDR;
+	}
+
+	psPageArrayData->uiTotalNumChunks = uiNumPages;
+	psPageArrayData->uiChunksToAlloc = BIT_ISSET(ui32Flags, FLAG_SPARSE) ? ui32NumPhysChunks : uiNumPages;
+	psPageArrayData->uiLog2ChunkSize = uiLog2AllocPageSize;
+
+	psPageArrayData->psConnection = psConnection;
+	psPageArrayData->uiPid = uiPid;
+	psPageArrayData->iNumChunksAllocated = 0;
+	psPageArrayData->ui32Flags = ui32Flags;
+	psPageArrayData->psPhysHeap = psPhysHeap;
+	psPageArrayData->psArena = pArena;
+	psPageArrayData->uiAllocFlags = uiAllocFlags;
+
+	*ppsPageArrayDataPtr = psPageArrayData;
+
+	return PVRSRV_OK;
+
+/*
+  error exit path follows:
+*/
+
+errorOnAllocArray:
+	PVR_ASSERT(eError != PVRSRV_OK);
+	return eError;
+}
+
+static PVRSRV_ERROR
+_AllocLMPagesContig(PMR_LMALLOCARRAY_DATA *psPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64PhysSize = IMG_PAGES2BYTES64(psPageArrayData->uiChunksToAlloc, uiLog2ChunkSize);
+	IMG_BOOL bPhysContig;
+	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
+
+
+	eError = RA_AllocMulti(psPageArrayData->psArena,
+	                  ui64PhysSize,
+	                  uiLog2ChunkSize,
+	                  RA_NO_IMPORT_MULTIPLIER,
+	                  0,                       /* No flags */
+	                  "LMA_Page_Alloc",
+	                  psPageArrayData->aBaseArray,
+	                  psPageArrayData->uiTotalNumChunks,
+	                  &bPhysContig);
+
+	if (PVRSRV_OK != eError)
+	{
+		RA_USAGE_STATS sRAStats;
+		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
+
+		PVR_DPF((PHYSHEAP_DPF_LVL,
+				"Contig: Failed to Allocate size = 0x%llx, align = 0x%llx"
+				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
+				" Arena Name: '%s'",
+				(unsigned long long)ui64PhysSize,
+				1ULL << uiLog2ChunkSize,
+				sRAStats.ui64FreeArenaSize,
+				RA_GetArenaName(psPageArrayData->psArena)));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
+	}
+
+	if (bPhysContig)
+	{
+		BIT_SET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG);
+	}
+
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+{
+	PVR_DPF((PVR_DBG_MESSAGE,
+			"(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
+			psPageArrayData->aBaseArray[0]));
+}
+#endif
+
+	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC))
+	{
+		eError = _PhysPgMemSet(psPageArrayData,
+		                       psPageArrayData->aBaseArray,
+		                       ui64PhysSize,
+		                       PVRSRV_POISON_ON_ALLOC_VALUE);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoison);
+	}
+
+	if (BIT_ISSET(ui32Flags, FLAG_ZERO))
+	{
+		eError = _PhysPgMemSet(psPageArrayData,
+		                       psPageArrayData->aBaseArray,
+		                       ui64PhysSize,
+		                       ZERO_PAGE_VALUE);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnZero);
+	}
+
+	psPageArrayData->iNumChunksAllocated += psPageArrayData->uiChunksToAlloc;
+
+	/* We have alloc'd the previous request, set 0 for book keeping */
+	psPageArrayData->uiChunksToAlloc = 0;
+
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, ui64PhysSize, psPageArrayData->uiPid);
+#else
+	if (bPhysContig)
+	{
+		IMG_CPU_PHYADDR sLocalCpuPAddr;
+		sLocalCpuPAddr.uiAddr = (IMG_UINT64) psPageArrayData->aBaseArray[0];
+		PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+								 NULL,
+								 sLocalCpuPAddr,
+								 IMG_PAGES2BYTES64(psPageArrayData->uiTotalNumChunks, uiLog2ChunkSize),
+								 psPageArrayData->uiPid
+								 DEBUG_MEMSTATS_VALUES);
+	}
+	else
+	{
+		IMG_UINT32 i, j;
+		IMG_CPU_PHYADDR sLocalCpuPAddr;
+
+		for (i = 0; i < psPageArrayData->uiTotalNumChunks;)
+		{
+			IMG_UINT32 ui32AllocSizeInChunks = 1;
+
+			for (j = i;
+			     j + 1 != psPageArrayData->uiTotalNumChunks &&
+			     RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
+			     j++)
+			{
+				ui32AllocSizeInChunks++;
+			}
+
+			sLocalCpuPAddr.uiAddr = (IMG_UINT64) psPageArrayData->aBaseArray[i];
+			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+									 NULL,
+									 sLocalCpuPAddr,
+									 IMG_PAGES2BYTES64(ui32AllocSizeInChunks, uiLog2ChunkSize),
+									 psPageArrayData->uiPid
+									 DEBUG_MEMSTATS_VALUES);
+
+			i += ui32AllocSizeInChunks;
+		}
+	}
+#endif
+#endif
+
+	return PVRSRV_OK;
+
+	/*
+	  error exit paths follow:
+	*/
+errorOnZero:
+errorOnPoison:
+	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
+
+	RA_FreeMulti(psPageArrayData->psArena,
+	              psPageArrayData->aBaseArray,
+	              psPageArrayData->uiTotalNumChunks);
+
+errorOnRAAlloc:
+	PVR_ASSERT(eError != PVRSRV_OK);
+	return eError;
+}
+
+/*
+ * Fully allocated variant of sparse allocation does not take in as argument an
+ * array of indices. It is used in cases where the amount of chunks to allocate is
+ * the same as the total the PMR can represent. I.E when we want to fully populate
+ * a sparse PMR.
+ */
+static PVRSRV_ERROR
+_AllocLMPagesSparseFull(PMR_LMALLOCARRAY_DATA *psPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64PhysSize = IMG_PAGES2BYTES64(psPageArrayData->uiChunksToAlloc, uiLog2ChunkSize);
+	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
+
+
+	eError = RA_AllocMultiSparse(psPageArrayData->psArena,
+	                  uiLog2ChunkSize,
+	                  RA_NO_IMPORT_MULTIPLIER,
+	                  0,                       /* No flags */
+	                  "LMA_Page_Alloc",
+	                  psPageArrayData->aBaseArray,
+	                  psPageArrayData->uiTotalNumChunks,
+	                  NULL, /* No indices given meaning allocate full base array using chunk count below */
+	                  psPageArrayData->uiChunksToAlloc);
+	if (PVRSRV_OK != eError)
+	{
+		RA_USAGE_STATS sRAStats;
+		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
+
+		PVR_DPF((PHYSHEAP_DPF_LVL,
+				"SparseFull: Failed to Allocate size = 0x%llx, align = 0x%llx"
+				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
+				" Arena Name: '%s'",
+				(unsigned long long)ui64PhysSize,
+				1ULL << uiLog2ChunkSize,
+				sRAStats.ui64FreeArenaSize,
+				RA_GetArenaName(psPageArrayData->psArena)));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
+	}
+
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+{
+	PVR_DPF((PVR_DBG_MESSAGE,
+		"(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
+		psPageArrayData->aBaseArray[0]));
+}
+#endif
+
+	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC))
+	{
+		eError = _PhysPgMemSet(psPageArrayData,
+		                       psPageArrayData->aBaseArray,
+		                       ui64PhysSize,
+		                       PVRSRV_POISON_ON_ALLOC_VALUE);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoison);
+	}
+
+	if (BIT_ISSET(ui32Flags, FLAG_ZERO))
+	{
+		eError = _PhysPgMemSet(psPageArrayData,
+		                       psPageArrayData->aBaseArray,
+		                       ui64PhysSize,
+		                       ZERO_PAGE_VALUE);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnZero);
+	}
+
+	psPageArrayData->iNumChunksAllocated += psPageArrayData->uiChunksToAlloc;
+
+	/* We have alloc'd the previous request, set 0 for book keeping */
+	psPageArrayData->uiChunksToAlloc = 0;
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, ui64PhysSize, psPageArrayData->uiPid);
+#else
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
+		{
+			IMG_CPU_PHYADDR sLocalCpuPAddr;
+			sLocalCpuPAddr.uiAddr =
+				(IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[i]);
+			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+									 NULL,
+									 sLocalCpuPAddr,
+									 1 << uiLog2ChunkSize,
+									 psPageArrayData->uiPid
+									 DEBUG_MEMSTATS_VALUES);
+		}
+	}
+#endif
+#endif
+
+	return PVRSRV_OK;
+
+	/*
+	  error exit paths follow:
+	*/
+errorOnZero:
+errorOnPoison:
+	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
+
+	RA_FreeMulti(psPageArrayData->psArena,
+	              psPageArrayData->aBaseArray,
+	              psPageArrayData->uiTotalNumChunks);
+
+errorOnRAAlloc:
+	PVR_ASSERT(eError != PVRSRV_OK);
+	return eError;
+}
+
+static PVRSRV_ERROR
+_AllocLMPagesSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData, IMG_UINT32 *pui32MapTable)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(uiLog2ChunkSize);
+	IMG_UINT32 uiChunksToAlloc = psPageArrayData->uiChunksToAlloc;
+	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
+
+	if (!pui32MapTable)
+	{
+		PVR_LOG_GOTO_WITH_ERROR("pui32MapTable", eError, PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY, errorOnRAAlloc);
+	}
+
+#if defined(DEBUG)
+	/*
+	 * This block performs validation of the mapping table input in the following ways:
+	 * Check that each index in the mapping table does not exceed the number of the chunks
+	 * the whole PMR supports.
+	 * Check that each index given by the mapping table is not already allocated.
+	 * Check that there are no duplicated indices given in the mapping table.
+	 */
+	{
+		IMG_UINT32 i;
+		IMG_BOOL bIssueDetected = IMG_FALSE;
+		PVRSRV_ERROR eMapCheckError;
+
+		for (i = 0; i < uiChunksToAlloc; i++)
+		{
+			if (pui32MapTable[i] >= psPageArrayData->uiTotalNumChunks)
+			{
+				PVR_DPF((PVR_DBG_ERROR,
+						"%s: Page alloc request Index out of bounds for PMR @0x%p",
+						__func__,
+						psPageArrayData));
+				eMapCheckError = PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE;
+				bIssueDetected = IMG_TRUE;
+				break;
+			}
+
+			if (!RA_BASE_IS_INVALID(psPageArrayData->aBaseArray[pui32MapTable[i]]))
+			{
+				PVR_DPF((PVR_DBG_ERROR,
+						"%s: Mapping already exists Index %u Mapping index %u",
+						__func__,
+						i,
+						pui32MapTable[i]));
+				eMapCheckError = PVRSRV_ERROR_PMR_MAPPING_ALREADY_EXISTS;
+				bIssueDetected = IMG_TRUE;
+				break;
+			}
+
+			if (RA_BASE_IS_SPARSE_PREP(psPageArrayData->aBaseArray[pui32MapTable[i]]))
+			{
+				PVR_DPF((PVR_DBG_ERROR,
+						"%s: Mapping already exists in mapping table given Index %u Mapping index %u",
+						__func__,
+						i,
+						pui32MapTable[i]));
+				eMapCheckError = PVRSRV_ERROR_PMR_MAPPING_ALREADY_EXISTS;
+				bIssueDetected = IMG_TRUE;
+				break;
+			}
+			else
+			{
+				/* Set the To Prep value so we can detect duplicated map indices */
+				psPageArrayData->aBaseArray[pui32MapTable[i]] = RA_BASE_SPARSE_PREP_ALLOC_ADDR;
+			}
+		}
+		/* Unwind the Alloc Prep Values */
+		if (bIssueDetected)
+		{
+			/* We don't want to affect the index of the issue seen
+			 * as it could be a valid mapping. If it is a duplicated
+			 * mapping in the given table then we will clean-up the
+			 * previous instance anyway.
+			 */
+			IMG_UINT32 uiUnwind = i;
+
+			for (i = 0; i < uiUnwind; i++)
+			{
+				psPageArrayData->aBaseArray[pui32MapTable[i]] = INVALID_BASE_ADDR;
+			}
+
+			PVR_GOTO_WITH_ERROR(eError, eMapCheckError, errorOnRAAlloc);
+		}
+	}
+#endif
+
+	eError = RA_AllocMultiSparse(psPageArrayData->psArena,
+	                              psPageArrayData->uiLog2ChunkSize,
+	                              RA_NO_IMPORT_MULTIPLIER,
+	                              0,
+	                              "LMA_Page_Alloc",
+	                              psPageArrayData->aBaseArray,
+	                              psPageArrayData->uiTotalNumChunks,
+	                              pui32MapTable,
+	                              uiChunksToAlloc);
+	if (PVRSRV_OK != eError)
+	{
+		RA_USAGE_STATS sRAStats;
+		RA_Get_Usage_Stats(psPageArrayData->psArena, &sRAStats);
+
+		PVR_DPF((PHYSHEAP_DPF_LVL,
+				"Sparse: Failed to Allocate size = 0x%llx, align = 0x%llx"
+				" Arena Free Space 0x%"IMG_UINT64_FMTSPECX""
+				" Arena Name: '%s'",
+				(unsigned long long) uiChunksToAlloc << uiLog2ChunkSize,
+				1ULL << uiLog2ChunkSize,
+				sRAStats.ui64FreeArenaSize,
+				RA_GetArenaName(psPageArrayData->psArena)));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES, errorOnRAAlloc);
+	}
+
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+{
+	PVR_DPF((PVR_DBG_MESSAGE,
+	        "(GPU Virtualization Validation): First RealBase: %"IMG_UINT64_FMTSPECX,
+	        psPageArrayData->aBaseArray[pui32MapTable[0]]));
+}
+#endif
+
+	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC) || BIT_ISSET(ui32Flags, FLAG_ZERO))
+	{
+		IMG_UINT32 i, ui32Index = 0;
+		for (i = 0; i < uiChunksToAlloc; i++)
+		{
+			ui32Index = pui32MapTable[i];
+
+			eError = _PhysPgMemSet(psPageArrayData,
+			                       &psPageArrayData->aBaseArray[ui32Index],
+			                       ui64ChunkSize,
+			                       BIT_ISSET(ui32Flags, FLAG_POISON_ON_ALLOC) ? PVRSRV_POISON_ON_ALLOC_VALUE :
+			                                                                    ZERO_PAGE_VALUE);
+			PVR_LOG_GOTO_IF_ERROR(eError, "_PhysPgMemSet", errorOnPoisonZero);
+		}
+	}
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+	                            uiChunksToAlloc << uiLog2ChunkSize,
+	                            psPageArrayData->uiPid);
+#else
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psPageArrayData->uiChunksToAlloc; i++)
+		{
+			IMG_UINT32 ui32Index = pui32MapTable[i];
+			IMG_CPU_PHYADDR sLocalCpuPAddr;
+			sLocalCpuPAddr.uiAddr =
+				(IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[ui32Index]);
+			PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+									 NULL,
+									 sLocalCpuPAddr,
+									 ui64ChunkSize,
+									 psPageArrayData->uiPid
+									 DEBUG_MEMSTATS_VALUES);
+		}
+	}
+#endif
+#endif
+
+	psPageArrayData->iNumChunksAllocated += uiChunksToAlloc;
+
+	/* We have alloc'd the previous request, set 0 for book keeping */
+	psPageArrayData->uiChunksToAlloc = 0;
+
+	return PVRSRV_OK;
+
+	/*
+	  error exit paths follow:
+	*/
+errorOnPoisonZero:
+	eError = PVRSRV_ERROR_PMR_FAILED_TO_ALLOC_PAGES;
+
+	RA_FreeMultiSparse(psPageArrayData->psArena,
+	                    psPageArrayData->aBaseArray,
+	                    psPageArrayData->uiTotalNumChunks,
+	                    psPageArrayData->uiLog2ChunkSize,
+	                    pui32MapTable,
+	                    &uiChunksToAlloc);
+
+errorOnRAAlloc:
+	PVR_ASSERT(eError != PVRSRV_OK);
+	return eError;
+
+}
+
+static PVRSRV_ERROR
+_AllocLMPages(PMR_LMALLOCARRAY_DATA *psPageArrayData, IMG_UINT32 *pui32MapTable)
+{
+	PVRSRV_ERROR eError;
+
+	PVR_ASSERT(NULL != psPageArrayData);
+	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
+
+	if (psPageArrayData->uiTotalNumChunks <
+			(psPageArrayData->iNumChunksAllocated + psPageArrayData->uiChunksToAlloc))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "Pages requested to allocate don't fit PMR alloc Size. "
+				"Allocated: %u + Requested: %u > Total Allowed: %u",
+				psPageArrayData->iNumChunksAllocated,
+				psPageArrayData->uiChunksToAlloc,
+				psPageArrayData->uiTotalNumChunks));
+		return PVRSRV_ERROR_PMR_BAD_MAPPINGTABLE_SIZE;
+	}
+
+	/* If we have a non-backed sparse PMR then we can just return */
+	if (psPageArrayData->uiChunksToAlloc == 0)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE,
+							"%s: Non-Backed Sparse PMR Created: %p.",
+							__func__,
+							psPageArrayData));
+		return PVRSRV_OK;
+	}
+
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
+	{
+		IMG_UINT32 ui32OSid=0;
+		PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPageArrayData->psPhysHeap);
+
+		/* Obtain the OSid specific data from our connection handle */
+		if (psPageArrayData->psConnection != NULL)
+		{
+			ui32OSid = psPageArrayData->psConnection->ui32OSid;
+		}
+
+		/* Replace the given RA Arena with OS Arena */
+		if (PVRSRV_CHECK_SHARED_BUFFER(psPageArrayData->uiAllocFlags))
+		{
+			psPageArrayData->psArena = psDevNode->psOSSharedArena;
+			PVR_DPF((PVR_DBG_MESSAGE,
+					 "(GPU Virtualization Validation): Giving from shared mem"));
+		}
+		else
+		{
+			psPageArrayData->psArena = psDevNode->psOSidSubArena[ui32OSid];
+			PVR_DPF((PVR_DBG_MESSAGE,
+					 "(GPU Virtualization Validation): Giving from OS slot %d",
+					 ui32OSid));
+		}
+	}
+#endif
+
+	/*
+	 * 3 cases:
+	 * Sparse allocation populating the whole PMR.
+	 * [**********]
+	 * Sparse allocation partially populating the PMR at given indices.
+	 * [*** *** **]
+	 * Contiguous allocation.
+	 * [**********]
+	 *
+	 * Note: Separate cases are required for 1 and 3 due to memstats tracking.
+	 * In Contiguous case we can track the block as a single memstat record as we know
+	 * we will also free in that size record.
+	 * Sparse allocations require a memstat record per chunk as they can be arbitrarily
+	 * free'd.
+	 */
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		if (psPageArrayData->uiTotalNumChunks == psPageArrayData->uiChunksToAlloc &&
+		    !pui32MapTable)
+		{
+			eError = _AllocLMPagesSparseFull(psPageArrayData);
+		}
+		else
+		{
+			eError = _AllocLMPagesSparse(psPageArrayData, pui32MapTable);
+		}
+	}
+	else
+	{
+		eError = _AllocLMPagesContig(psPageArrayData);
+	}
+
+	return eError;
+}
+
+static void
+_FreeLMPageArray(PMR_LMALLOCARRAY_DATA *psPageArrayData)
+{
+	PVR_DPF((PVR_DBG_MESSAGE,
+			"physmem_lma.c: freed local memory array structure for PMR @0x%p",
+			psPageArrayData));
+
+	OSFreeMem(psPageArrayData);
+}
+
+static PVRSRV_ERROR
+_FreeLMPagesContig(PMR_LMALLOCARRAY_DATA *psPageArrayData)
+{
+	RA_ARENA *pArena = psPageArrayData->psArena;
+	IMG_UINT64 ui64PhysSize = IMG_PAGES2BYTES64(psPageArrayData->uiTotalNumChunks, psPageArrayData->uiLog2ChunkSize);
+	PVRSRV_ERROR eError;
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
+	{
+		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
+	}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
+
+	PVR_ASSERT(psPageArrayData->iNumChunksAllocated != 0);
+	PVR_ASSERT(psPageArrayData->iNumChunksAllocated ==
+	           psPageArrayData->uiTotalNumChunks);
+
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_POISON_ON_FREE))
+	{
+		eError = _PhysPgMemSet(psPageArrayData,
+							   psPageArrayData->aBaseArray,
+							   ui64PhysSize,
+							   PVRSRV_POISON_ON_FREE_VALUE);
+		PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
+	}
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsDecrMemAllocStat(uiStat,
+	                            ui64PhysSize,
+	                            psPageArrayData->uiPid);
+#else
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+	{
+		PVRSRVStatsRemoveMemAllocRecord(uiStat,
+		                                (IMG_UINT64) psPageArrayData->aBaseArray[0],
+		                                psPageArrayData->uiPid);
+	}
+	else
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
+		{
+			if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
+			{
+				PVRSRVStatsRemoveMemAllocRecord(uiStat,
+				                                (IMG_UINT64) psPageArrayData->aBaseArray[i],
+				                                psPageArrayData->uiPid);
+			}
+		}
+	}
+#endif
+#endif
+
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+	{
+		eError = RA_FreeMulti(pArena,
+							  psPageArrayData->aBaseArray,
+							  1);
+		PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
+	}
+	else
+	{
+		eError = RA_FreeMulti(pArena,
+							  psPageArrayData->aBaseArray,
+							  psPageArrayData->iNumChunksAllocated);
+		PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
+	}
+
+	psPageArrayData->iNumChunksAllocated = 0;
+
+	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
+
+	PVR_DPF((PVR_DBG_MESSAGE,
+			"%s: freed %"IMG_UINT64_FMTSPEC" local memory for PMR @0x%p",
+			__func__,
+			ui64PhysSize,
+			psPageArrayData));
+
+	return eError;
+}
+
+static PVRSRV_ERROR
+_FreeLMPagesRemainingSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData)
+{
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(psPageArrayData->uiLog2ChunkSize);
+	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
+	IMG_BOOL bPoisonOnFree = (BIT_ISSET(ui32Flags, FLAG_POISON_ON_FREE));
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
+	{
+		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
+	}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsDecrMemAllocStat(uiStat,
+	                            psPageArrayData->iNumChunksAllocated << psPageArrayData->uiLog2ChunkSize,
+	                            psPageArrayData->uiPid);
+#endif
+
+	for (i = 0; i < psPageArrayData->uiTotalNumChunks;)
+	{
+		if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
+		{
+			IMG_UINT32 j;
+			IMG_UINT32 ui32AccumulatedChunks = 1;
+
+			for (j = i;
+				 j + 1 != psPageArrayData->uiTotalNumChunks &&
+				 RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
+				 j++)
+			{
+				ui32AccumulatedChunks++;
+			}
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
+			for (j = i; j < (i + ui32AccumulatedChunks); j++)
+			{
+				PVRSRVStatsRemoveMemAllocRecord(uiStat,
+				                                RA_BASE_STRIP_GHOST_BIT(psPageArrayData->aBaseArray[j]),
+				                                psPageArrayData->uiPid);
+				if (bPoisonOnFree)
+#else
+			for (j = i; j < (i + ui32AccumulatedChunks) && bPoisonOnFree; j++)
+			{
+#endif
+				{
+					eError = _PhysPgMemSet(psPageArrayData,
+										   &psPageArrayData->aBaseArray[j],
+										   ui64ChunkSize,
+										   PVRSRV_POISON_ON_FREE_VALUE);
+					PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
+				}
+			}
+
+			eError = RA_FreeMulti(psPageArrayData->psArena,
+			                       &psPageArrayData->aBaseArray[i],
+			                       ui32AccumulatedChunks);
+			PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMulti");
+
+			psPageArrayData->iNumChunksAllocated -= ui32AccumulatedChunks;
+			i += ui32AccumulatedChunks;
+		}
+		else if (RA_BASE_IS_INVALID(psPageArrayData->aBaseArray[i]))
+		{
+			i++;
+		}
+	}
+
+	/* We have freed all allocations in the previous loop */
+	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR
+_FreeLMPagesSparse(PMR_LMALLOCARRAY_DATA *psPageArrayData,
+                   IMG_UINT32 *pui32FreeIndices,
+                   IMG_UINT32 ui32FreeChunkCount)
+{
+	RA_ARENA *pArena = psPageArrayData->psArena;
+	IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(uiLog2ChunkSize);
+	IMG_UINT32 ui32Flags = psPageArrayData->ui32Flags;
+	IMG_UINT32 uiActualFreeCount = ui32FreeChunkCount;
+	PVRSRV_ERROR eError;
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+	IMG_UINT32 uiStat = PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES;
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_ZOMBIE))
+	{
+		uiStat = PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES;
+	}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
+
+	PVR_ASSERT(psPageArrayData->iNumChunksAllocated != 0);
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < ui32FreeChunkCount; i++)
+		{
+			IMG_UINT32 ui32Index = pui32FreeIndices[i];
+
+			PVRSRVStatsRemoveMemAllocRecord(uiStat,
+			                                (IMG_UINT64) RA_BASE_STRIP_GHOST_BIT(
+			                                psPageArrayData->aBaseArray[ui32Index]),
+			                                psPageArrayData->uiPid);
+		}
+	}
+#endif
+
+	if (BIT_ISSET(ui32Flags, FLAG_POISON_ON_FREE))
+	{
+		IMG_UINT32 i, ui32Index = 0;
+		for (i = 0; i < ui32FreeChunkCount; i++)
+		{
+			ui32Index = pui32FreeIndices[i];
+
+			eError = _PhysPgMemSet(psPageArrayData,
+								   &psPageArrayData->aBaseArray[ui32Index],
+								   ui64ChunkSize,
+								   PVRSRV_POISON_ON_FREE_VALUE);
+			PVR_LOG_IF_ERROR(eError, "_PhysPgMemSet");
+		}
+	}
+
+	eError = RA_FreeMultiSparse(pArena,
+	                             psPageArrayData->aBaseArray,
+	                             psPageArrayData->uiTotalNumChunks,
+	                             uiLog2ChunkSize,
+	                             pui32FreeIndices,
+	                             &uiActualFreeCount);
+	psPageArrayData->iNumChunksAllocated -= uiActualFreeCount;
+#if defined(PVRSRV_ENABLE_PROCESS_STATS) && !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	PVRSRVStatsDecrMemAllocStat(uiStat,
+	                            uiActualFreeCount << psPageArrayData->uiLog2ChunkSize,
+	                            psPageArrayData->uiPid);
+#endif
+	if (eError == PVRSRV_ERROR_RA_FREE_INVALID_CHUNK)
+	{
+		/* Log the RA error but convert it to PMR level to match the interface,
+		 * this is important because other PMR factories may not use the RA but
+		 * still return error, returning a PMR based error
+		 * keeps the interface agnostic to implementation behaviour.
+		 */
+		PVR_LOG_IF_ERROR(eError, "RA_FreeMultiSparse");
+		return PVRSRV_ERROR_PMR_FREE_INVALID_CHUNK;
+	}
+	PVR_LOG_RETURN_IF_ERROR(eError, "RA_FreeMultiSparse");
+
+	PVR_ASSERT(0 <= psPageArrayData->iNumChunksAllocated);
+
+
+	PVR_DPF((PVR_DBG_MESSAGE,
+			"%s: freed %" IMG_UINT64_FMTSPEC " local memory for PMR @0x%p",
+			__func__,
+			(uiActualFreeCount * ui64ChunkSize),
+			psPageArrayData));
+
+	return PVRSRV_OK;
+}
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static PVRSRV_ERROR PMRFreeZombiePagesRAMem(PMR_IMPL_ZOMBIEPAGES pvPriv)
+{
+	PVRSRV_ERROR eError;
+	PMR_LMALLOCARRAY_DATA *psZombiePageArray = pvPriv;
+
+	eError = _FreeLMPages(psZombiePageArray, NULL, 0);
+	PVR_GOTO_IF_ERROR(eError, e0);
+
+	_FreeLMPageArray(psZombiePageArray);
+	return PVRSRV_OK;
+e0:
+	return eError;
+}
+
+/* Allocates a new PMR_LMALLOCARRAY_DATA object and fills it with
+ * pages to be extracted from psSrcPageArrayData.
+ */
+static PVRSRV_ERROR
+_ExtractPages(PMR_LMALLOCARRAY_DATA *psSrcPageArrayData,
+			  IMG_UINT32 *pai32ExtractIndices,
+			  IMG_UINT32 ui32ExtractPageCount,
+			  PMR_LMALLOCARRAY_DATA **psOutPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32ExtractPageCountSaved;
+	PMR_LMALLOCARRAY_DATA* psDstPageArrayData;
+
+	/* Alloc PMR_LMALLOCARRAY_DATA for the extracted pages */
+	eError = _AllocLMPageArray(ui32ExtractPageCount << psSrcPageArrayData->uiLog2ChunkSize,
+	                           ui32ExtractPageCount,
+	                           psSrcPageArrayData->uiLog2ChunkSize,
+	                           psSrcPageArrayData->ui32Flags,
+	                           psSrcPageArrayData->psPhysHeap,
+	                           psSrcPageArrayData->psArena,
+	                           psSrcPageArrayData->uiAllocFlags,
+	                           psSrcPageArrayData->uiPid,
+	                           &psDstPageArrayData,
+	                           psSrcPageArrayData->psConnection);
+	PVR_LOG_GOTO_IF_ERROR(eError, "_AllocLMPageArray", alloc_error);
+
+	ui32ExtractPageCountSaved = ui32ExtractPageCount;
+	/* Transfer pages from source base array to newly allocated page array */
+	eError = RA_TransferMultiSparseIndices(psSrcPageArrayData->psArena,
+	                                       psSrcPageArrayData->aBaseArray,
+	                                       psSrcPageArrayData->uiTotalNumChunks,
+	                                       psDstPageArrayData->aBaseArray,
+	                                       psDstPageArrayData->uiTotalNumChunks,
+	                                       psSrcPageArrayData->uiLog2ChunkSize,
+	                                       pai32ExtractIndices,
+	                                       &ui32ExtractPageCountSaved);
+	PVR_LOG_GOTO_IF_FALSE((eError == PVRSRV_OK) && (ui32ExtractPageCountSaved == ui32ExtractPageCount),
+	                      "RA_TransferMultiSparseIndices failed",
+	                      transfer_error);
+
+
+	/* Update page counts */
+	psSrcPageArrayData->iNumChunksAllocated -= ui32ExtractPageCount;
+	psDstPageArrayData->iNumChunksAllocated += ui32ExtractPageCount;
+
+	*psOutPageArrayData = psDstPageArrayData;
+
+	return PVRSRV_OK;
+transfer_error:
+	_FreeLMPageArray(psDstPageArrayData);
+alloc_error:
+	return eError;
+}
+
+/* Extracts all allocated pages referenced psSrcPageArrayData
+ * Allocates a new PMR_OSPAGEARRAY_DATA object and fills it with the extracted
+ * pages information.
+ */
+static PVRSRV_ERROR
+_ExtractAllPages(PMR_LMALLOCARRAY_DATA *psSrcPageArrayData,
+				 PMR_LMALLOCARRAY_DATA **psOutPageArrayData)
+{
+	PVRSRV_ERROR eError;
+	PMR_LMALLOCARRAY_DATA* psDstPageArrayData;
+	IMG_UINT32 ui32IdxSrc, ui32IdxDst;
+
+	if (psSrcPageArrayData->iNumChunksAllocated == 0)
+	{
+		/* Do nothing if psSrcPageArrayData contains no allocated pages */
+		return PVRSRV_OK;
+	}
+
+	/* Alloc PMR_LMALLOCARRAY_DATA for the extracted pages */
+	eError = _AllocLMPageArray(psSrcPageArrayData->iNumChunksAllocated << psSrcPageArrayData->uiLog2ChunkSize,
+	                           psSrcPageArrayData->iNumChunksAllocated,
+	                           psSrcPageArrayData->uiLog2ChunkSize,
+	                           psSrcPageArrayData->ui32Flags,
+	                           psSrcPageArrayData->psPhysHeap,
+	                           psSrcPageArrayData->psArena,
+	                           psSrcPageArrayData->uiAllocFlags,
+	                           psSrcPageArrayData->uiPid,
+	                           &psDstPageArrayData,
+	                           psSrcPageArrayData->psConnection);
+	PVR_LOG_RETURN_IF_ERROR_VA(eError, "_AllocLMPageArray failed in %s", __func__);
+
+	/* Now do the transfer */
+	ui32IdxDst=0;
+	for (ui32IdxSrc=0; ((ui32IdxDst<psSrcPageArrayData->iNumChunksAllocated) &&
+	                    (psDstPageArrayData->iNumChunksAllocated<psSrcPageArrayData->iNumChunksAllocated)); ui32IdxSrc++)
+	{
+		if (psSrcPageArrayData->aBaseArray[ui32IdxSrc] != INVALID_BASE_ADDR)
+		{
+			psDstPageArrayData->aBaseArray[ui32IdxDst++] = psSrcPageArrayData->aBaseArray[ui32IdxSrc];
+			psSrcPageArrayData->aBaseArray[ui32IdxSrc] = INVALID_BASE_ADDR;
+			psDstPageArrayData->iNumChunksAllocated++;
+		}
+	}
+
+	/* Update src page count */
+	psSrcPageArrayData->iNumChunksAllocated = 0;
+
+	*psOutPageArrayData = psDstPageArrayData;
+
+	return PVRSRV_OK;
+}
+#endif /* defined(SUPPORT_PMR_PAGES_DEFERRED_FREE) */
+
+static PVRSRV_ERROR
+_FreeLMPages(PMR_LMALLOCARRAY_DATA *psPageArrayData,
+             IMG_UINT32 *pui32FreeIndices,
+             IMG_UINT32 ui32FreeChunkCount)
+{
+	PVRSRV_ERROR eError;
+
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		if (!pui32FreeIndices)
+		{
+			eError =  _FreeLMPagesRemainingSparse(psPageArrayData);
+		}
+		else
+		{
+			eError = _FreeLMPagesSparse(psPageArrayData, pui32FreeIndices, ui32FreeChunkCount);
+		}
+	}
+	else
+	{
+		eError = _FreeLMPagesContig(psPageArrayData);
+	}
+
+	return eError;
+}
+
+/*
+ *
+ * Implementation of PMR callback functions
+ *
+ */
+
+/* destructor func is called after last reference disappears, but
+   before PMR itself is freed. */
+static void
+PMRFinalizeLocalMem(PMR_IMPL_PRIVDATA pvPriv)
+{
+	PVRSRV_ERROR eError;
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
+
+	/* We can't free pages until now. */
+	if (psLMAllocArrayData->iNumChunksAllocated != 0)
+	{
+		eError = _FreeLMPages(psLMAllocArrayData, NULL, 0);
+		PVR_LOG_IF_ERROR(eError, "_FreeLMPages");
+		PVR_ASSERT (eError == PVRSRV_OK);
+	}
+
+	_FreeLMPageArray(psLMAllocArrayData);
+}
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+static inline void _TransferToMemZombieRecord_LmaPages(PMR_LMALLOCARRAY_DATA *psPageArrayData,
+                                                       RA_BASE_T uiBase)
+{
+	IMG_CPU_PHYADDR sCPUPhysAddr = {
+		.uiAddr = RA_BASE_STRIP_GHOST_BIT(uiBase)
+	};
+
+	PVRSRVStatsTransferMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES,
+	                                  PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES,
+	                                  sCPUPhysAddr.uiAddr,
+	                                  psPageArrayData->uiPid
+	                                  DEBUG_MEMSTATS_VALUES);
+}
+#endif
+
+static PVRSRV_ERROR PMRZombifyLocalMem(PMR_IMPL_PRIVDATA pvPriv, PMR *psPMR)
+{
+	PMR_LMALLOCARRAY_DATA *psPageArrayData = pvPriv;
+
+	BIT_SET(psPageArrayData->ui32Flags, FLAG_ZOMBIE);
+
+#if defined(PVRSRV_ENABLE_PROCESS_STATS)
+#if !defined(PVRSRV_ENABLE_MEMORY_STATS)
+	{
+		IMG_PID uiPid = psPageArrayData->uiPid;
+		IMG_UINT32 uiLog2ChunkSize = psPageArrayData->uiLog2ChunkSize;
+		IMG_UINT64 uiSize = BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE) ?
+			(IMG_UINT64) psPageArrayData->iNumChunksAllocated << uiLog2ChunkSize :
+			(IMG_UINT64) psPageArrayData->uiTotalNumChunks << uiLog2ChunkSize;
+
+		PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES, uiSize, uiPid);
+		PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES, uiSize, uiPid);
+	}
+#else /* !defined(PVRSRV_ENABLE_MEMORY_STATS) */
+	if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		/* _FreeLMPagesRemainingSparse path */
+
+		IMG_UINT32 i;
+
+		for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
+		{
+			if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
+			{
+				IMG_UINT32 j;
+				IMG_UINT32 ui32AccumulatedChunks = 1;
+
+				for (j = i;
+				     j + 1 != psPageArrayData->uiTotalNumChunks &&
+				         RA_BASE_IS_GHOST(psPageArrayData->aBaseArray[j + 1]);
+				     j++)
+				{
+					ui32AccumulatedChunks++;
+				}
+
+				for (j = i; j < (i + ui32AccumulatedChunks); j++)
+				{
+					_TransferToMemZombieRecord_LmaPages(psPageArrayData,
+					                                    psPageArrayData->aBaseArray[j]);
+				}
+			}
+		}
+	}
+	else
+	{
+		/* _FreeLMPagesContig path */
+
+		if (BIT_ISSET(psPageArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+		{
+			_TransferToMemZombieRecord_LmaPages(psPageArrayData,
+			                                    psPageArrayData->aBaseArray[0]);
+		}
+		else
+		{
+			IMG_UINT32 i;
+
+			for (i = 0; i < psPageArrayData->uiTotalNumChunks; i++)
+			{
+				if (RA_BASE_IS_REAL(psPageArrayData->aBaseArray[i]))
+				{
+					_TransferToMemZombieRecord_LmaPages(psPageArrayData,
+					                                    psPageArrayData->aBaseArray[i]);
+				}
+			}
+
+		}
+	}
+#endif /* !defined(PVRSRV_ENABLE_MEMORY_STATS) */
+#endif /* defined(PVRSRV_ENABLE_PROCESS_STATS) */
+
+	PVR_UNREFERENCED_PARAMETER(psPMR);
+
+	return PVRSRV_OK;
+}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+
+/* callback function for locking the system physical page addresses.
+   As we are LMA there is nothing to do as we control physical memory. */
+static PVRSRV_ERROR
+PMRLockSysPhysAddressesLocalMem(PMR_IMPL_PRIVDATA pvPriv)
+{
+
+	PVRSRV_ERROR eError;
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData;
+
+	psLMAllocArrayData = pvPriv;
+
+	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_ONDEMAND))
+	{
+		/* Allocate Memory for deferred allocation */
+		eError = _AllocLMPages(psLMAllocArrayData, NULL);
+		PVR_RETURN_IF_ERROR(eError);
+	}
+
+	return PVRSRV_OK;
+}
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static PVRSRV_ERROR
+PMRUnlockSysPhysAddressesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+                                  PMR_IMPL_ZOMBIEPAGES *ppvZombiePages)
+#else
+static PVRSRV_ERROR
+PMRUnlockSysPhysAddressesLocalMem(PMR_IMPL_PRIVDATA pvPriv)
+#endif
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	PMR_LMALLOCARRAY_DATA *psExtractedPagesPageArray = NULL;
+
+	*ppvZombiePages = NULL;
+#endif
+
+	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_ONDEMAND))
+	{
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+		if (psLMAllocArrayData->iNumChunksAllocated == 0)
+		{
+			*ppvZombiePages = NULL;
+			return PVRSRV_OK;
+		}
+
+		eError = _ExtractAllPages(psLMAllocArrayData,
+		                          &psExtractedPagesPageArray);
+		PVR_LOG_GOTO_IF_ERROR(eError, "_ExtractAllPages", e0);
+
+		if (psExtractedPagesPageArray)
+		{
+			/* Zombify pages to get proper stats */
+			eError = PMRZombifyLocalMem(psExtractedPagesPageArray, NULL);
+			PVR_WARN_IF_ERROR(eError, "PMRZombifyLocalMem");
+		}
+		*ppvZombiePages = psExtractedPagesPageArray;
+#else
+		/* Free Memory for deferred allocation */
+		eError = _FreeLMPages(psLMAllocArrayData, NULL, 0);
+		PVR_RETURN_IF_ERROR(eError);
+#endif
+	}
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+e0:
+#endif
+	PVR_ASSERT(eError == PVRSRV_OK);
+	return eError;
+}
+
+/* N.B. It is assumed that PMRLockSysPhysAddressesLocalMem() is called _before_ this function! */
+static PVRSRV_ERROR
+PMRSysPhysAddrLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+					   IMG_UINT32 ui32Log2PageSize,
+					   IMG_UINT32 ui32NumOfPages,
+					   IMG_DEVMEM_OFFSET_T *puiOffset,
+#if defined(SUPPORT_STATIC_IPA)
+					   IMG_UINT64 ui64IPAPolicyValue,
+					   IMG_UINT64 ui64IPAClearMask,
+#endif
+					   IMG_BOOL *pbValid,
+					   IMG_DEV_PHYADDR *psDevPAddr)
+{
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
+	IMG_UINT32 idx;
+	IMG_UINT32 uiLog2AllocSize;
+	IMG_UINT64 uiAllocIndex;
+	IMG_DEVMEM_OFFSET_T uiInAllocOffset;
+	IMG_UINT32 uiNumAllocs = psLMAllocArrayData->uiTotalNumChunks;
+
+#if defined(SUPPORT_STATIC_IPA)
+	PVR_UNREFERENCED_PARAMETER(ui64IPAPolicyValue);
+	PVR_UNREFERENCED_PARAMETER(ui64IPAClearMask);
+#endif
+
+	if (psLMAllocArrayData->uiLog2ChunkSize < ui32Log2PageSize)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Requested physical addresses from PMR "
+		         "for incompatible contiguity %u!",
+		         __func__,
+		         ui32Log2PageSize));
+		return PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY;
+	}
+
+	PVR_ASSERT(psLMAllocArrayData->uiLog2ChunkSize != 0);
+	PVR_ASSERT(ui32Log2PageSize >= RA_BASE_FLAGS_LOG2);
+
+	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_PHYS_CONTIG))
+	{
+		for (idx=0; idx < ui32NumOfPages; idx++)
+		{
+			if (pbValid[idx])
+			{
+				psDevPAddr[idx].uiAddr = psLMAllocArrayData->aBaseArray[0] + puiOffset[idx];
+#if defined(SUPPORT_STATIC_IPA)
+				/* Modify the physical address with the associated IPA values */
+				psDevPAddr[idx].uiAddr &= ~ui64IPAClearMask;
+				psDevPAddr[idx].uiAddr |= ui64IPAPolicyValue;
+#endif
+			}
+		}
+	}
+	else
+	{
+		uiLog2AllocSize = psLMAllocArrayData->uiLog2ChunkSize;
+
+		for (idx=0; idx < ui32NumOfPages; idx++)
+		{
+			if (pbValid[idx])
+			{
+				uiAllocIndex = puiOffset[idx] >> uiLog2AllocSize;
+				uiInAllocOffset = puiOffset[idx] - (uiAllocIndex << uiLog2AllocSize);
+
+				PVR_LOG_RETURN_IF_FALSE(uiAllocIndex < uiNumAllocs,
+										"puiOffset out of range", PVRSRV_ERROR_OUT_OF_RANGE);
+
+				PVR_ASSERT(uiInAllocOffset < (1ULL << uiLog2AllocSize));
+
+				/* The base may or may not be a ghost base, but we don't care,
+				 * we just need the real representation of the base.
+				 */
+				psDevPAddr[idx].uiAddr = RA_BASE_STRIP_GHOST_BIT(
+					psLMAllocArrayData->aBaseArray[uiAllocIndex]) + uiInAllocOffset;
+#if defined(SUPPORT_STATIC_IPA)
+				/* Modify the physical address with the associated IPA values */
+				psDevPAddr[idx].uiAddr &= ~ui64IPAClearMask;
+				psDevPAddr[idx].uiAddr |= ui64IPAPolicyValue;
+#endif
+			}
+		}
+	}
+
+	return PVRSRV_OK;
+}
+
+static PVRSRV_ERROR
+PMRAcquireKernelMappingDataLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+								 size_t uiOffset,
+								 size_t uiSize,
+								 void **ppvKernelAddressOut,
+								 IMG_HANDLE *phHandleOut,
+								 PMR_FLAGS_T ulFlags)
+{
+	PVRSRV_ERROR eError;
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
+	PMR_KERNEL_MAPPING *psKernelMapping;
+	RA_BASE_T *paBaseArray;
+	IMG_UINT32 ui32ChunkIndex = 0;
+	size_t uiOffsetMask = uiOffset;
+
+	IMG_UINT32 uiLog2ChunkSize = psLMAllocArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(uiLog2ChunkSize);
+	IMG_UINT64 ui64PhysSize;
+
+	PVR_ASSERT(psLMAllocArrayData);
+	PVR_ASSERT(ppvKernelAddressOut);
+	PVR_ASSERT(phHandleOut);
+
+	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		IMG_UINT32 i;
+		/* Locate the desired physical chunk to map in */
+		ui32ChunkIndex = uiOffset >> psLMAllocArrayData->uiLog2ChunkSize;
+
+		if (OSIsMapPhysNonContigSupported())
+		{
+			/* If a size hasn't been supplied assume we are mapping a single page */
+			IMG_UINT32 uiNumChunksToMap;
+
+			/* This is to support OSMapPMR originated parameters */
+			if (uiOffset == 0 && uiSize == 0)
+			{
+				uiNumChunksToMap = psLMAllocArrayData->iNumChunksAllocated;
+			}
+			else
+			{
+				uiNumChunksToMap = uiSize >> psLMAllocArrayData->uiLog2ChunkSize;
+			}
+
+			/* Check we are attempting to map at least a chunk in size */
+			if (uiNumChunksToMap < 1)
+			{
+				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_INVALID_PARAMS, "uiNumChunksToMap < 1");
+			}
+
+			/* Check contiguous region doesn't exceed size of PMR */
+			if (ui32ChunkIndex + (uiNumChunksToMap - 1) > psLMAllocArrayData->uiTotalNumChunks)
+			{
+				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_INVALID_PARAMS,
+				                        "Mapping range exceeds total num chunks in PMR");
+			}
+
+			/* Check the virtually contiguous region given is physically backed */
+			for (i = ui32ChunkIndex; i < ui32ChunkIndex + uiNumChunksToMap; i++)
+			{
+				if (RA_BASE_IS_INVALID(psLMAllocArrayData->aBaseArray[i]))
+				{
+					PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY, "Sparse contiguity check");
+				}
+			}
+			/* Size of virtually contiguous sparse alloc */
+			ui64PhysSize = IMG_PAGES2BYTES64(uiNumChunksToMap, psLMAllocArrayData->uiLog2ChunkSize);
+		}
+		else
+		{
+			size_t uiStart = uiOffset;
+			size_t uiEnd = uiOffset + uiSize - 1;
+			size_t uiChunkMask = ~(IMG_PAGE2BYTES64(psLMAllocArrayData->uiLog2ChunkSize) - 1);
+
+			/* We can still map if only one chunk is required */
+			if ((uiStart & uiChunkMask) != (uiEnd & uiChunkMask))
+			{
+				PVR_LOG_RETURN_IF_ERROR(PVRSRV_ERROR_PMR_INCOMPATIBLE_CONTIGUITY, "Sparse contiguity check");
+			}
+			/* Map a single chunk */
+			ui64PhysSize = ui64ChunkSize;
+		}
+
+		paBaseArray = &psLMAllocArrayData->aBaseArray[ui32ChunkIndex];
+
+		/* Offset mask to be used for address offsets within a chunk */
+		uiOffsetMask = (1U << psLMAllocArrayData->uiLog2ChunkSize) - 1;
+	}
+	else
+	{
+		paBaseArray = psLMAllocArrayData->aBaseArray;
+		ui64PhysSize = IMG_PAGES2BYTES64(psLMAllocArrayData->uiTotalNumChunks, uiLog2ChunkSize);
+	}
+
+	PVR_ASSERT(ui32ChunkIndex < psLMAllocArrayData->uiTotalNumChunks);
+
+	psKernelMapping = OSAllocMem(sizeof(*psKernelMapping));
+	PVR_RETURN_IF_NOMEM(psKernelMapping);
+
+	eError = _MapPMRKernel(psLMAllocArrayData,
+	                       paBaseArray,
+	                       ui64PhysSize,
+	                       ulFlags,
+	                       psKernelMapping);
+	if (eError == PVRSRV_OK)
+	{
+		/* uiOffset & uiOffsetMask is used to get the kernel addr within the page */
+		*ppvKernelAddressOut = ((IMG_CHAR *) psKernelMapping->pvKernelAddress) + (uiOffset & uiOffsetMask);
+		*phHandleOut = psKernelMapping;
+	}
+	else
+	{
+		OSFreeMem(psKernelMapping);
+		PVR_LOG_ERROR(eError, "_MapPMRKernel");
+	}
+
+	return eError;
+}
+
+static void PMRReleaseKernelMappingDataLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+                                                IMG_HANDLE hHandle)
+{
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = (PMR_LMALLOCARRAY_DATA *) pvPriv;
+	PMR_KERNEL_MAPPING *psKernelMapping = (PMR_KERNEL_MAPPING *) hHandle;
+
+	PVR_ASSERT(psLMAllocArrayData);
+	PVR_ASSERT(psKernelMapping);
+
+	_UnMapPMRKernel(psLMAllocArrayData,
+	                psKernelMapping);
+
+	OSFreeMem(psKernelMapping);
+}
+
+static PVRSRV_ERROR
+CopyBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+				  IMG_DEVMEM_OFFSET_T uiOffset,
+				  IMG_UINT8 *pcBuffer,
+				  size_t uiBufSz,
+				  size_t *puiNumBytes,
+				  void (*pfnCopyBytes)(IMG_UINT8 *pcBuffer,
+									   IMG_UINT8 *pcPMR,
+									   size_t uiSize))
+{
+	PMR_LMALLOCARRAY_DATA *psLMAllocArrayData = pvPriv;
+	size_t uiBytesCopied;
+	size_t uiBytesToCopy;
+	size_t uiBytesCopyableFromAlloc;
+	PMR_KERNEL_MAPPING sMapping;
+	IMG_UINT8 *pcKernelPointer = NULL;
+	size_t uiBufferOffset;
+	IMG_UINT64 uiAllocIndex;
+	IMG_DEVMEM_OFFSET_T uiInAllocOffset;
+	IMG_UINT32 uiLog2ChunkSize = psLMAllocArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(uiLog2ChunkSize);
+	IMG_UINT64 ui64PhysSize;
+	PVRSRV_ERROR eError;
+
+	uiBytesCopied = 0;
+	uiBytesToCopy = uiBufSz;
+	uiBufferOffset = 0;
+
+	if (BIT_ISSET(psLMAllocArrayData->ui32Flags, FLAG_SPARSE))
+	{
+		while (uiBytesToCopy > 0)
+		{
+			/* we have to map one alloc in at a time */
+			PVR_ASSERT(psLMAllocArrayData->uiLog2ChunkSize != 0);
+			uiAllocIndex = uiOffset >> psLMAllocArrayData->uiLog2ChunkSize;
+			uiInAllocOffset = uiOffset - (uiAllocIndex << psLMAllocArrayData->uiLog2ChunkSize);
+			uiBytesCopyableFromAlloc = uiBytesToCopy;
+			if (uiBytesCopyableFromAlloc + uiInAllocOffset > (1ULL << psLMAllocArrayData->uiLog2ChunkSize))
+			{
+				uiBytesCopyableFromAlloc = TRUNCATE_64BITS_TO_SIZE_T((1ULL << psLMAllocArrayData->uiLog2ChunkSize)-uiInAllocOffset);
+			}
+			/* Mapping a single chunk at a time */
+			ui64PhysSize = ui64ChunkSize;
+
+			PVR_ASSERT(uiBytesCopyableFromAlloc != 0);
+			PVR_ASSERT(uiAllocIndex < psLMAllocArrayData->uiTotalNumChunks);
+			PVR_ASSERT(uiInAllocOffset < (1ULL << uiLog2ChunkSize));
+
+			eError = _MapPMRKernel(psLMAllocArrayData,
+			                       &psLMAllocArrayData->aBaseArray[uiAllocIndex],
+			                       ui64PhysSize,
+			                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
+			                       &sMapping);
+			PVR_GOTO_IF_ERROR(eError, e0);
+			pcKernelPointer = sMapping.pvKernelAddress;
+			pfnCopyBytes(&pcBuffer[uiBufferOffset], &pcKernelPointer[uiInAllocOffset], uiBytesCopyableFromAlloc);
+
+			_UnMapPMRKernel(psLMAllocArrayData,
+			                &sMapping);
+
+			uiBufferOffset += uiBytesCopyableFromAlloc;
+			uiBytesToCopy -= uiBytesCopyableFromAlloc;
+			uiOffset += uiBytesCopyableFromAlloc;
+			uiBytesCopied += uiBytesCopyableFromAlloc;
+		}
+	}
+	else
+	{
+		ui64PhysSize = IMG_PAGES2BYTES64(psLMAllocArrayData->uiTotalNumChunks, uiLog2ChunkSize);
+		PVR_ASSERT((uiOffset + uiBufSz) <= ui64PhysSize);
+		PVR_ASSERT(ui64ChunkSize != 0);
+		eError = _MapPMRKernel(psLMAllocArrayData,
+		                       psLMAllocArrayData->aBaseArray,
+		                       ui64PhysSize,
+		                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC,
+		                       &sMapping);
+		PVR_GOTO_IF_ERROR(eError, e0);
+		pcKernelPointer = sMapping.pvKernelAddress;
+		pfnCopyBytes(pcBuffer, &pcKernelPointer[uiOffset], uiBufSz);
+
+		_UnMapPMRKernel(psLMAllocArrayData,
+		                &sMapping);
+
+		uiBytesCopied = uiBufSz;
+	}
+	*puiNumBytes = uiBytesCopied;
+	return PVRSRV_OK;
+e0:
+	*puiNumBytes = uiBytesCopied;
+	return eError;
+}
+
+static void ReadLocalMem(IMG_UINT8 *pcBuffer,
+						 IMG_UINT8 *pcPMR,
+						 size_t uiSize)
+{
+	/* the memory is mapped as WC (and also aligned to page size) so we can
+	 * safely call "Cached" memcpy */
+	OSCachedMemCopy(pcBuffer, pcPMR, uiSize);
+}
+
+static PVRSRV_ERROR
+PMRReadBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+				  IMG_DEVMEM_OFFSET_T uiOffset,
+				  IMG_UINT8 *pcBuffer,
+				  size_t uiBufSz,
+				  size_t *puiNumBytes)
+{
+	return CopyBytesLocalMem(pvPriv,
+							 uiOffset,
+							 pcBuffer,
+							 uiBufSz,
+							 puiNumBytes,
+							 ReadLocalMem);
+}
+
+static void WriteLocalMem(IMG_UINT8 *pcBuffer,
+						  IMG_UINT8 *pcPMR,
+						  size_t uiSize)
+{
+	/* the memory is mapped as WC (and also aligned to page size) so we can
+	 * safely call "Cached" memcpy but need to issue a write memory barrier
+	 * to flush the write buffers after */
+	OSCachedMemCopyWMB(pcPMR, pcBuffer, uiSize);
+}
+
+static PVRSRV_ERROR
+PMRWriteBytesLocalMem(PMR_IMPL_PRIVDATA pvPriv,
+					  IMG_DEVMEM_OFFSET_T uiOffset,
+					  IMG_UINT8 *pcBuffer,
+					  size_t uiBufSz,
+					  size_t *puiNumBytes)
+{
+	return CopyBytesLocalMem(pvPriv,
+							 uiOffset,
+							 pcBuffer,
+							 uiBufSz,
+							 puiNumBytes,
+							 WriteLocalMem);
+}
+
+/*************************************************************************/ /*!
+@Function       PMRChangeSparseMemLocalMem
+@Description    This function Changes the sparse mapping by allocating and
+                freeing of pages. It also changes the GPU maps accordingly.
+@Return         PVRSRV_ERROR failure code
+*/ /**************************************************************************/
+static PVRSRV_ERROR
+PMRChangeSparseMemLocalMem(PMR_IMPL_PRIVDATA pPriv,
+                           const PMR *psPMR,
+                           IMG_UINT32 ui32AllocPageCount,
+                           IMG_UINT32 *pai32AllocIndices,
+                           IMG_UINT32 ui32FreePageCount,
+                           IMG_UINT32 *pai32FreeIndices,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+                           PMR_IMPL_ZOMBIEPAGES *ppvZombiePages,
+#endif
+                           IMG_UINT32 uiFlags)
+{
+	PVRSRV_ERROR eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+	IMG_UINT32 ui32AdtnlAllocPages = 0;
+	IMG_UINT32 ui32AdtnlFreePages = 0;
+	IMG_UINT32 ui32CommonRequstCount = 0;
+	IMG_UINT32 ui32Loop = 0;
+	IMG_UINT32 ui32Index = 0;
+	IMG_UINT32 uiAllocpgidx;
+	IMG_UINT32 uiFreepgidx;
+
+	PMR_LMALLOCARRAY_DATA *psPMRPageArrayData = (PMR_LMALLOCARRAY_DATA *)pPriv;
+	IMG_UINT32 uiLog2ChunkSize = psPMRPageArrayData->uiLog2ChunkSize;
+	IMG_UINT64 ui64ChunkSize = IMG_PAGE2BYTES64(uiLog2ChunkSize);
+
+#if defined(DEBUG)
+	IMG_BOOL bPoisonFail = IMG_FALSE;
+	IMG_BOOL bZeroFail = IMG_FALSE;
+#endif
+
+	/* Fetch the Page table array represented by the PMR */
+	RA_BASE_T *paBaseArray = psPMRPageArrayData->aBaseArray;
+	PMR_MAPPING_TABLE *psPMRMapTable = PMR_GetMappingTable(psPMR);
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	*ppvZombiePages = NULL;
+#endif
+	/* The incoming request is classified into two operations independent of
+	 * each other: alloc & free chunks.
+	 * These operations can be combined with two mapping operations as well
+	 * which are GPU & CPU space mappings.
+	 *
+	 * From the alloc and free chunk requests, the net amount of chunks to be
+	 * allocated or freed is computed. Chunks that were requested to be freed
+	 * will be reused to fulfil alloc requests.
+	 *
+	 * The order of operations is:
+	 * 1. Allocate new Chunks.
+	 * 2. Move the free chunks from free request to alloc positions.
+	 * 3. Free the rest of the chunks not used for alloc
+	 *
+	 * Alloc parameters are validated at the time of allocation
+	 * and any error will be handled then. */
+
+	if (SPARSE_RESIZE_BOTH == (uiFlags & SPARSE_RESIZE_BOTH))
+	{
+		ui32CommonRequstCount = (ui32AllocPageCount > ui32FreePageCount) ?
+				ui32FreePageCount : ui32AllocPageCount;
+
+		PDUMP_PANIC(PMR_DeviceNode(psPMR), SPARSEMEM_SWAP, "Request to swap alloc & free chunks not supported");
+	}
+
+	if (SPARSE_RESIZE_ALLOC == (uiFlags & SPARSE_RESIZE_ALLOC))
+	{
+		ui32AdtnlAllocPages = ui32AllocPageCount - ui32CommonRequstCount;
+	}
+	else
+	{
+		ui32AllocPageCount = 0;
+	}
+
+	if (SPARSE_RESIZE_FREE == (uiFlags & SPARSE_RESIZE_FREE))
+	{
+		ui32AdtnlFreePages = ui32FreePageCount - ui32CommonRequstCount;
+	}
+	else
+	{
+		ui32FreePageCount = 0;
+	}
+
+	PVR_LOG_RETURN_IF_FALSE(
+	    (ui32CommonRequstCount | ui32AdtnlAllocPages | ui32AdtnlFreePages) != 0,
+	    "Invalid combination of parameters: ui32CommonRequstCount,"
+	    " ui32AdtnlAllocPages and ui32AdtnlFreePages.",
+	    PVRSRV_ERROR_INVALID_PARAMS
+	);
+
+	{
+		/* Validate the free page indices */
+		if (ui32FreePageCount)
+		{
+			if (pai32FreeIndices != NULL)
+			{
+				for (ui32Loop = 0; ui32Loop < ui32FreePageCount; ui32Loop++)
+				{
+					uiFreepgidx = pai32FreeIndices[ui32Loop];
+
+					if (uiFreepgidx >= psPMRPageArrayData->uiTotalNumChunks)
+					{
+						PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE, e0);
+					}
+
+					if (RA_BASE_IS_INVALID(paBaseArray[uiFreepgidx]))
+					{
+						PVR_LOG_GOTO_WITH_ERROR("paBaseArray[uiFreepgidx]", eError, PVRSRV_ERROR_INVALID_PARAMS, e0);
+					}
+				}
+			}
+			else
+			{
+				PVR_DPF((PVR_DBG_ERROR,
+				         "%s: Given non-zero free count but missing indices array",
+				         __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
+			}
+		}
+
+		/* The following block of code verifies any issues with common alloc chunk indices */
+		for (ui32Loop = ui32AdtnlAllocPages; ui32Loop < ui32AllocPageCount; ui32Loop++)
+		{
+			uiAllocpgidx = pai32AllocIndices[ui32Loop];
+			if (uiAllocpgidx >= psPMRPageArrayData->uiTotalNumChunks)
+			{
+				PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_OUT_OF_RANGE, e0);
+			}
+
+			if ((!RA_BASE_IS_INVALID(paBaseArray[uiAllocpgidx])) ||
+					(psPMRMapTable->aui32Translation[uiAllocpgidx] != TRANSLATION_INVALID))
+			{
+				PVR_LOG_GOTO_WITH_ERROR("Trying to allocate already allocated page again", eError, PVRSRV_ERROR_INVALID_PARAMS, e0);
+			}
+		}
+
+		ui32Loop = 0;
+
+		/* Allocate new chunks */
+		if (0 != ui32AdtnlAllocPages)
+		{
+			/* Say how many chunks to allocate */
+			psPMRPageArrayData->uiChunksToAlloc = ui32AdtnlAllocPages;
+
+			eError = _AllocLMPages(psPMRPageArrayData, pai32AllocIndices);
+			PVR_LOG_GOTO_IF_ERROR(eError, "_AllocLMPages", e0);
+
+			/* Mark the corresponding chunks of translation table as valid */
+			for (ui32Loop = 0; ui32Loop < ui32AdtnlAllocPages; ui32Loop++)
+			{
+				psPMRMapTable->aui32Translation[pai32AllocIndices[ui32Loop]] = pai32AllocIndices[ui32Loop];
+			}
+
+			psPMRMapTable->ui32NumPhysChunks += ui32AdtnlAllocPages;
+		}
+
+		ui32Index = ui32Loop;
+		ui32Loop = 0;
+
+		/* Move the corresponding free chunks to alloc request */
+		eError = RA_SwapSparseMem(psPMRPageArrayData->psArena,
+		                           paBaseArray,
+		                           psPMRPageArrayData->uiTotalNumChunks,
+		                           psPMRPageArrayData->uiLog2ChunkSize,
+		                           &pai32AllocIndices[ui32Index],
+		                           &pai32FreeIndices[ui32Loop],
+		                           ui32CommonRequstCount);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RA_SwapSparseMem", unwind_alloc);
+
+		for (ui32Loop = 0; ui32Loop < ui32CommonRequstCount; ui32Loop++, ui32Index++)
+		{
+			uiAllocpgidx = pai32AllocIndices[ui32Index];
+			uiFreepgidx  = pai32FreeIndices[ui32Loop];
+
+			psPMRMapTable->aui32Translation[uiFreepgidx] = TRANSLATION_INVALID;
+			psPMRMapTable->aui32Translation[uiAllocpgidx] = uiAllocpgidx;
+
+			/* Be sure to honour the attributes associated with the allocation
+			 * such as zeroing, poisoning etc. */
+			if (BIT_ISSET(psPMRPageArrayData->ui32Flags, FLAG_POISON_ON_ALLOC))
+			{
+				eError = _PhysPgMemSet(psPMRPageArrayData,
+				                       &psPMRPageArrayData->aBaseArray[uiAllocpgidx],
+				                       ui64ChunkSize,
+				                       PVRSRV_POISON_ON_ALLOC_VALUE);
+
+				/* Consider this as a soft failure and go ahead but log error to kernel log */
+				if (eError != PVRSRV_OK)
+				{
+#if defined(DEBUG)
+					bPoisonFail = IMG_TRUE;
+#endif
+				}
+			}
+
+			if (BIT_ISSET(psPMRPageArrayData->ui32Flags, FLAG_ZERO))
+			{
+				eError = _PhysPgMemSet(psPMRPageArrayData,
+									   &psPMRPageArrayData->aBaseArray[uiAllocpgidx],
+									   ui64ChunkSize,
+									   ZERO_PAGE_VALUE);
+				/* Consider this as a soft failure and go ahead but log error to kernel log */
+				if (eError != PVRSRV_OK)
+				{
+#if defined(DEBUG)
+					/* Don't think we need to zero any chunks further */
+					bZeroFail = IMG_TRUE;
+#endif
+				}
+			}
+		}
+
+		/* Free or zombie the additional free chunks */
+		if (0 != ui32AdtnlFreePages)
+		{
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+			PMR_LMALLOCARRAY_DATA *psExtractedPagesPageArray = NULL;
+
+			eError = _ExtractPages(psPMRPageArrayData, &pai32FreeIndices[ui32Loop], ui32AdtnlFreePages, &psExtractedPagesPageArray);
+			PVR_LOG_GOTO_IF_ERROR(eError, "_ExtractPages", e0);
+
+			/* Zombify pages to get proper stats */
+			eError = PMRZombifyLocalMem(psExtractedPagesPageArray, NULL);
+			PVR_LOG_IF_ERROR(eError, "PMRZombifyLocalMem");
+
+			*ppvZombiePages = psExtractedPagesPageArray;
+#else
+			eError = _FreeLMPages(psPMRPageArrayData, &pai32FreeIndices[ui32Loop], ui32AdtnlFreePages);
+			PVR_LOG_GOTO_IF_ERROR(eError, "_FreeLMPages", e0);
+#endif /* SUPPORT_PMR_PAGES_DEFERRED_FREE */
+			ui32Index = ui32Loop;
+			ui32Loop = 0;
+
+			while (ui32Loop++ < ui32AdtnlFreePages)
+			{
+				/* Set the corresponding mapping table entry to invalid address */
+				psPMRMapTable->aui32Translation[pai32FreeIndices[ui32Index++]] = TRANSLATION_INVALID;
+			}
+
+			psPMRMapTable->ui32NumPhysChunks -= ui32AdtnlFreePages;
+		}
+	}
+
+#if defined(DEBUG)
+	if (IMG_TRUE == bPoisonFail)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Error in poisoning the chunk", __func__));
+	}
+
+	if (IMG_TRUE == bZeroFail)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Error in zeroing the chunk", __func__));
+	}
+#endif
+
+	return PVRSRV_OK;
+
+unwind_alloc:
+	_FreeLMPages(psPMRPageArrayData, pai32AllocIndices, ui32Index);
+
+	for (ui32Loop = 0; ui32Loop < ui32Index; ui32Loop++)
+	{
+		psPMRMapTable->aui32Translation[pai32AllocIndices[ui32Loop]] = TRANSLATION_INVALID;
+	}
+
+e0:
+	return eError;
+}
+
+static PMR_IMPL_FUNCTAB _sPMRLMAFuncTab = {
+	.pfnLockPhysAddresses = &PMRLockSysPhysAddressesLocalMem,
+	.pfnUnlockPhysAddresses = &PMRUnlockSysPhysAddressesLocalMem,
+	.pfnDevPhysAddr = &PMRSysPhysAddrLocalMem,
+	.pfnAcquireKernelMappingData = &PMRAcquireKernelMappingDataLocalMem,
+	.pfnReleaseKernelMappingData = &PMRReleaseKernelMappingDataLocalMem,
+	.pfnReadBytes = &PMRReadBytesLocalMem,
+	.pfnWriteBytes = &PMRWriteBytesLocalMem,
+	.pfnChangeSparseMem = &PMRChangeSparseMemLocalMem,
+	.pfnMMap = NULL,
+	.pfnFinalize = &PMRFinalizeLocalMem,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	.pfnFreeZombiePages = &PMRFreeZombiePagesRAMem,
+#endif
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	.pfnZombify = &PMRZombifyLocalMem,
+#endif
+};
+
+PVRSRV_ERROR
+PhysmemNewRAMemRamBackedPMR(PHYS_HEAP *psPhysHeap,
+                            RA_ARENA *pArena,
+                            CONNECTION_DATA *psConnection,
+                            IMG_DEVMEM_SIZE_T uiSize,
+                            IMG_UINT32 ui32NumPhysChunks,
+                            IMG_UINT32 ui32NumVirtChunks,
+                            IMG_UINT32 *pui32MappingTable,
+                            IMG_UINT32 uiLog2AllocPageSize,
+                            PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                            const IMG_CHAR *pszAnnotation,
+                            IMG_PID uiPid,
+                            PMR **ppsPMRPtr,
+                            IMG_UINT32 ui32PDumpFlags)
+{
+	PVRSRV_ERROR eError;
+	PVRSRV_ERROR eError2;
+	PMR *psPMR = NULL;
+	PMR_LMALLOCARRAY_DATA *psPrivData = NULL;
+	PMR_FLAGS_T uiPMRFlags;
+	IMG_UINT32 ui32LMAllocFlags = 0;
+
+	/* This path is checking for the type of PMR to create, if sparse we
+	 * have to perform additional validation as we can only map sparse ranges
+	 * if the os functionality to do so is present. We can also only map virtually
+	 * contiguous sparse regions. Non backed gaps in a range cannot be mapped.
+	 */
+	if (ui32NumPhysChunks != ui32NumVirtChunks || ui32NumVirtChunks > 1)
+	{
+		if (PVRSRV_CHECK_KERNEL_CPU_MAPPABLE(uiFlags) &&
+		   !OSIsMapPhysNonContigSupported())
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+					"%s: LMA kernel mapping functions not available "
+					"for physically discontiguous memory.",
+					__func__));
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, errorOnParam);
+		}
+		BIT_SET(ui32LMAllocFlags, FLAG_SPARSE);
+	}
+
+	if (PVRSRV_CHECK_ON_DEMAND(uiFlags))
+	{
+		BIT_SET(ui32LMAllocFlags, FLAG_ONDEMAND);
+	}
+
+	if (PVRSRV_CHECK_ZERO_ON_ALLOC(uiFlags))
+	{
+		BIT_SET(ui32LMAllocFlags, FLAG_ZERO);
+	}
+
+	if (PVRSRV_CHECK_POISON_ON_ALLOC(uiFlags))
+	{
+		BIT_SET(ui32LMAllocFlags, FLAG_POISON_ON_ALLOC);
+	}
+
+#if defined(DEBUG)
+	if (PVRSRV_CHECK_POISON_ON_FREE(uiFlags))
+	{
+		BIT_SET(ui32LMAllocFlags, FLAG_POISON_ON_FREE);
+	}
+#endif
+
+	/* Create Array structure that holds the physical pages */
+	eError = _AllocLMPageArray(uiSize,
+	                           ui32NumPhysChunks,
+	                           uiLog2AllocPageSize,
+	                           ui32LMAllocFlags,
+	                           psPhysHeap,
+	                           pArena,
+	                           uiFlags,
+	                           uiPid,
+	                           &psPrivData,
+	                           psConnection);
+	PVR_GOTO_IF_ERROR(eError, errorOnAllocPageArray);
+
+	if (!BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND))
+	{
+		/* Allocate the physical pages */
+		eError = _AllocLMPages(psPrivData, pui32MappingTable);
+		PVR_GOTO_IF_ERROR(eError, errorOnAllocPages);
+	}
+
+	/* In this instance, we simply pass flags straight through.
+
+	   Generically, uiFlags can include things that control the PMR
+	   factory, but we don't need any such thing (at the time of
+	   writing!), and our caller specifies all PMR flags so we don't
+	   need to meddle with what was given to us.
+	*/
+	uiPMRFlags = (PMR_FLAGS_T)(uiFlags & PVRSRV_MEMALLOCFLAGS_PMRFLAGSMASK);
+	/* check no significant bits were lost in cast due to different
+	   bit widths for flags */
+	PVR_ASSERT(uiPMRFlags == (uiFlags & PVRSRV_MEMALLOCFLAGS_PMRFLAGSMASK));
+
+	if (BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND))
+	{
+		PDUMPCOMMENT(PhysHeapDeviceNode(psPhysHeap), "Deferred Allocation PMR (LMA)");
+	}
+
+	eError = PMRCreatePMR(psPhysHeap,
+						  uiSize,
+						  ui32NumPhysChunks,
+						  ui32NumVirtChunks,
+						  pui32MappingTable,
+						  uiLog2AllocPageSize,
+						  uiPMRFlags,
+						  pszAnnotation,
+						  &_sPMRLMAFuncTab,
+						  psPrivData,
+						  PMR_TYPE_LMA,
+						  &psPMR,
+						  ui32PDumpFlags);
+	PVR_LOG_GOTO_IF_ERROR(eError, "PMRCreatePMR", errorOnCreate);
+
+	*ppsPMRPtr = psPMR;
+	return PVRSRV_OK;
+
+errorOnCreate:
+	if (!BIT_ISSET(ui32LMAllocFlags, FLAG_ONDEMAND) && psPrivData->iNumChunksAllocated)
+	{
+		eError2 = _FreeLMPages(psPrivData, NULL, 0);
+		PVR_ASSERT(eError2 == PVRSRV_OK);
+	}
+
+errorOnAllocPages:
+	_FreeLMPageArray(psPrivData);
+
+errorOnAllocPageArray:
+errorOnParam:
+	PVR_ASSERT(eError != PVRSRV_OK);
+	return eError;
+}
diff --git a/drivers/gpu/drm/img-rogue/physmem_ramem.h b/drivers/gpu/drm/img-rogue/physmem_ramem.h
new file mode 100644
index 000000000000..9dbf668e21b9
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/physmem_ramem.h
@@ -0,0 +1,109 @@
+/*************************************************************************/ /*!
+@File           physmem_ramem.h
+@Title          Resource allocator managed PMR Factory common definitions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Part of Services memory management.  This file defines the
+                RA managed memory PMR factory API that is shared between local
+                physheap implementations (LMA & IMA)
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#ifndef PHYSMEM_RAMEM_H
+#define PHYSMEM_RAMEM_H
+
+#include "img_types.h"
+#include "pvrsrv_memallocflags.h"
+#include "physheap.h"
+#include "ra.h"
+#include "connection_server.h"
+#include "pmr_impl.h"
+
+IMG_UINT32
+RAMemGetPageShift(void);
+
+PVRSRV_ERROR
+RAMemDoPhyContigPagesAlloc(RA_ARENA *pArena,
+                           size_t uiSize,
+                           PVRSRV_DEVICE_NODE *psDevNode,
+                           PG_HANDLE *psMemHandle,
+                           IMG_DEV_PHYADDR *psDevPAddr,
+                           IMG_PID uiPid);
+
+void
+RAMemDoPhyContigPagesFree(RA_ARENA *pArena,
+                          PG_HANDLE *psMemHandle);
+
+PVRSRV_ERROR
+RAMemPhyContigPagesMap(PHYS_HEAP *psPhysHeap,
+                  PG_HANDLE *psMemHandle,
+                  size_t uiSize, IMG_DEV_PHYADDR *psDevPAddr,
+                  void **pvPtr);
+
+void
+RAMemPhyContigPagesUnmap(PHYS_HEAP *psPhysHeap,
+                    PG_HANDLE *psMemHandle,
+                    void *pvPtr);
+
+PVRSRV_ERROR
+RAMemPhyContigPagesClean(PHYS_HEAP *psPhysHeap,
+                    PG_HANDLE *psMemHandle,
+                    IMG_UINT32 uiOffset,
+                    IMG_UINT32 uiLength);
+
+/*
+ * PhysmemNewRAMemRamBackedPMR
+ *
+ * This function will create a PMR using the memory managed by
+ * the PMR factory and is OS agnostic.
+ */
+PVRSRV_ERROR
+PhysmemNewRAMemRamBackedPMR(PHYS_HEAP *psPhysHeap,
+                            RA_ARENA *pArena,
+                            CONNECTION_DATA *psConnection,
+                            IMG_DEVMEM_SIZE_T uiSize,
+                            IMG_UINT32 ui32NumPhysChunks,
+                            IMG_UINT32 ui32NumVirtChunks,
+                            IMG_UINT32 *pui32MappingTable,
+                            IMG_UINT32 uiLog2PageSize,
+                            PVRSRV_MEMALLOCFLAGS_T uiFlags,
+                            const IMG_CHAR *pszAnnotation,
+                            IMG_PID uiPid,
+                            PMR **ppsPMRPtr,
+                            IMG_UINT32 ui32PDumpFlags);
+
+#endif /* PHYSMEM_RAMEM_H */
diff --git a/drivers/gpu/drm/img-rogue/plato_drv.h b/drivers/gpu/drm/img-rogue/plato_drv.h
index 06f3f9270f35..cfebfb05b8f0 100644
--- a/drivers/gpu/drm/img-rogue/plato_drv.h
+++ b/drivers/gpu/drm/img-rogue/plato_drv.h
@@ -239,9 +239,7 @@ struct plato_device {
 	struct platform_device *hdmi_dev;
 #endif
 
-#if defined(CONFIG_MTRR) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 	int mtrr;
-#endif
 	int instance;
 };
 
diff --git a/drivers/gpu/drm/img-rogue/pmr.c b/drivers/gpu/drm/img-rogue/pmr.c
index 521ea64ec14c..41d8a12e7a2c 100644
--- a/drivers/gpu/drm/img-rogue/pmr.c
+++ b/drivers/gpu/drm/img-rogue/pmr.c
@@ -66,6 +66,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pdump_physmem.h"
 #include "pmr_impl.h"
 #include "pmr_os.h"
+#include "pmr_env.h"
 #include "pvrsrv.h"
 
 #include "allocmem.h"
@@ -147,6 +148,29 @@ static struct _PMR_CTX_
 	IMG_BOOL bModuleInitialised;
 } _gsSingletonPMRContext = { 1, 0, {0}, NULL, IMG_FALSE };
 
+typedef struct _PMR_HEADER_
+{
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+	/* List node used to put the header on the zombie list
+	 * (psDevNode->sPMRZombieList). */
+	DLLIST_NODE sZombieNode;
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+
+	IMG_BOOL bIsZombiePages;
+} PMR_HEADER;
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+/*
+ * A structure describing zombie pages.
+ */
+typedef struct _PMR_ZOMBIE_PAGES_
+{
+	PMR_HEADER sHeader;
+	PMR_IMPL_ZOMBIEPAGES pvFactoryPages;
+	PFN_FREE_ZOMBIE_PAGES_FN pfnFactoryFreeZombies;
+} PMR_ZOMBIE_PAGES;
+#endif
+
 /* A PMR. One per physical allocation. May be "shared".
  *
  * "shared" is ambiguous. We need to be careful with terminology.
@@ -163,11 +187,8 @@ static struct _PMR_CTX_
  */
 struct _PMR_
 {
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-	/* List node used to put the PMR on the zombie list
-	 * (psDevNode->sPMRZombieList). */
-	DLLIST_NODE sZombieNode;
-#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+	/* A Common header structure shared between PMR and PMR-like PMR_ZOMBIE_PAGES object */
+	PMR_HEADER sHeader;
 
 	/* This object is strictly refcounted. References include:
 	 * - mapping
@@ -193,6 +214,21 @@ struct _PMR_
 	 */
 	ATOMIC_T iCpuMapCount;
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	/* GPU mapping count - this is the number of times a Device Page from a PMR has been
+	 * mapped to the GPU. It is used to determine when it is safe to permit
+	 * migration of constituent OS pages when SUPPORT_LINUX_OSPAGE_MIGRATION is
+	 * used.
+	 */
+	ATOMIC_T iGpuMapCount;
+#endif
+
+	/* Count of how many reservations refer to this
+	 * PMR as a part of a GPU mapping. Must be protected
+	 * by PMR lock.
+	 */
+	IMG_INT32 iAssociatedResCount;
+
 	/* Lock count - this is the number of times PMRLockSysPhysAddresses()
 	 * has been called, less the number of PMRUnlockSysPhysAddresses()
 	 * calls. This is arguably here for debug reasons only, as the refcount
@@ -220,6 +256,9 @@ struct _PMR_
 	/* Data associated with the "subtype" */
 	PMR_IMPL_PRIVDATA pvFlavourData;
 
+	/* Environment specific data */
+	DECLARE_PMR_ENV_DATA(sEnvData)
+
 	/* What kind of PMR do we have? */
 	PMR_IMPL_TYPE eFlavour;
 
@@ -361,7 +400,7 @@ PDumpPMRMallocPMR(PMR *psPMR,
                   IMG_DEVMEM_SIZE_T uiSize,
                   IMG_UINT32 ui32ChunkSize,
                   IMG_UINT32 ui32NumPhysChunks,
-                  IMG_UINT32 ui32NumVirtChunks,
+                  IMG_UINT32 ui32NumLogicalChunks,
                   IMG_UINT32 *puiMappingTable,
                   IMG_UINT32 uiLog2Contiguity,
                   IMG_BOOL bInitialise,
@@ -410,7 +449,7 @@ PPVRSRV_DEVICE_NODE PMRGetExportDeviceNode(PMR_EXPORT *psExportPMR)
 static PVRSRV_ERROR
 _PMRCreate(PMR_SIZE_T uiLogicalSize,
            IMG_UINT32 ui32NumPhysChunks,
-           IMG_UINT32 ui32NumVirtChunks,
+           IMG_UINT32 ui32NumLogicalChunks,
            IMG_UINT32 *pui32MappingTable,
            PMR_LOG2ALIGN_T uiLog2ContiguityGuarantee,
            PMR_FLAGS_T uiFlags,
@@ -428,8 +467,8 @@ _PMRCreate(PMR_SIZE_T uiLogicalSize,
 	psContext = &_gsSingletonPMRContext;
 
 	/* Do we have a sparse allocation? */
-	if ( (ui32NumVirtChunks != ui32NumPhysChunks) ||
-			(ui32NumVirtChunks > 1) )
+	if ( (ui32NumLogicalChunks != ui32NumPhysChunks) ||
+			(ui32NumLogicalChunks > 1) )
 	{
 		bSparse = IMG_TRUE;
 		uiChunkSize = 1ULL << uiLog2ContiguityGuarantee;
@@ -443,15 +482,15 @@ _PMRCreate(PMR_SIZE_T uiLogicalSize,
 	if (bSparse)
 	{
 		/* Check the logical size and chunk information agree with each other */
-		if (uiLogicalSize != (uiChunkSize * ui32NumVirtChunks))
+		if (uiLogicalSize != (uiChunkSize * ui32NumLogicalChunks))
 		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Bad mapping size (uiLogicalSize = 0x%llx, uiChunkSize = 0x%llx, ui32NumVirtChunks = %d)",
-					__func__, (unsigned long long)uiLogicalSize, (unsigned long long)uiChunkSize, ui32NumVirtChunks));
+			PVR_DPF((PVR_DBG_ERROR, "%s: Bad mapping size (uiLogicalSize = 0x%llx, uiChunkSize = 0x%llx, ui32NumLogicalChunks = %d)",
+					__func__, (unsigned long long)uiLogicalSize, (unsigned long long)uiChunkSize, ui32NumLogicalChunks));
 			return PVRSRV_ERROR_PMR_BAD_MAPPINGTABLE_SIZE;
 		}
 	}
 
-	pvPMRLinAddr = OSAllocMem(sizeof(*psPMR) + sizeof(*psMappingTable) + sizeof(IMG_UINT32) * ui32NumVirtChunks);
+	pvPMRLinAddr = OSAllocMem(sizeof(*psPMR) + sizeof(*psMappingTable) + IMG_FLEX_ARRAY_SIZE(sizeof(IMG_UINT32), ui32NumLogicalChunks));
 	PVR_RETURN_IF_NOMEM(pvPMRLinAddr);
 
 	psPMR = (PMR *) pvPMRLinAddr;
@@ -459,22 +498,15 @@ _PMRCreate(PMR_SIZE_T uiLogicalSize,
 
 	/* Setup the mapping table */
 	psMappingTable->uiChunkSize = uiChunkSize;
-	psMappingTable->ui32NumVirtChunks = ui32NumVirtChunks;
+	psMappingTable->ui32NumLogicalChunks = ui32NumLogicalChunks;
 	psMappingTable->ui32NumPhysChunks = ui32NumPhysChunks;
 	OSCachedMemSet(&psMappingTable->aui32Translation[0], 0xFF, sizeof(psMappingTable->aui32Translation[0])*
-	               ui32NumVirtChunks);
+	               ui32NumLogicalChunks);
 	for (i=0; i<ui32NumPhysChunks; i++)
 	{
 		ui32Temp = pui32MappingTable[i];
-		if (ui32Temp < ui32NumVirtChunks)
-		{
-			psMappingTable->aui32Translation[ui32Temp] = ui32Temp;
-		}
-		else
-		{
-			OSFreeMem(psPMR);
-			return PVRSRV_ERROR_PMR_INVALID_MAP_INDEX_ARRAY;
-		}
+		PVR_ASSERT(ui32Temp < ui32NumLogicalChunks);
+		psMappingTable->aui32Translation[ui32Temp] = ui32Temp;
 	}
 
 	eError = OSLockCreate(&psPMR->hLock);
@@ -487,6 +519,10 @@ _PMRCreate(PMR_SIZE_T uiLogicalSize,
 	/* Setup the PMR */
 	OSAtomicWrite(&psPMR->iRefCount, 0);
 	OSAtomicWrite(&psPMR->iCpuMapCount, 0);
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	OSAtomicWrite(&psPMR->iGpuMapCount, 0);
+#endif
+	psPMR->iAssociatedResCount = 0;
 
 	/* If allocation is not made on demand, it will be backed now and
 	 * backing will not be removed until the PMR is destroyed, therefore
@@ -501,9 +537,11 @@ _PMRCreate(PMR_SIZE_T uiLogicalSize,
 	psPMR->psMappingTable = psMappingTable;
 	psPMR->uiInternalFlags = bSparse ? PMR_FLAG_INTERNAL_SPARSE_ALLOC : 0;
 	psPMR->szAnnotation[0] = '\0';
+	psPMR->sHeader.bIsZombiePages = IMG_FALSE;
+	PMR_ENV_INITIALIZE(psPMR, sEnvData);
 
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
-	dllist_init(&psPMR->sZombieNode);
+	dllist_init(&psPMR->sHeader.sZombieNode);
 #endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
@@ -554,6 +592,18 @@ _Unref(PMR *psPMR)
 	return OSAtomicDecrement(&psPMR->iRefCount);
 }
 
+void
+PMRLockPMR(PMR *psPMR)
+{
+	OSLockAcquire(psPMR->hLock);	/* Uses same lock as PhysAddresses */
+}
+
+void
+PMRUnlockPMR(PMR *psPMR)
+{
+	OSLockRelease(psPMR->hLock);	/* Uses same lock as PhysAddresses */
+}
+
 static INLINE void
 _FactoryLock(const PMR_IMPL_FUNCTAB *psFuncTable)
 {
@@ -577,6 +627,8 @@ _PMRDestroy(PMR *psPMR)
 {
 	PVR_ASSERT(psPMR != NULL);
 
+	PMR_ENV_FINALIZE(psPMR, sEnvData);
+
 	if (psPMR->psFuncTab->pfnFinalize != NULL)
 	{
 		psPMR->psFuncTab->pfnFinalize(psPMR->pvFlavourData);
@@ -588,7 +640,7 @@ _PMRDestroy(PMR *psPMR)
 	{
 		PDumpPMRFreePMR(psPMR,
 		                psPMR->uiLogicalSize,
-		                (1 << psPMR->uiLog2ContiguityGuarantee),
+		                IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee),
 		                psPMR->uiLog2ContiguityGuarantee,
 		                psPMR->hPDumpAllocHandle);
 	}
@@ -629,6 +681,34 @@ _PMRDestroy(PMR *psPMR)
 	OSFreeMem(psPMR);
 }
 
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+static IMG_BOOL
+PMR_IsListNodeZombiePages(const DLLIST_NODE *psNode)
+{
+	PMR_HEADER *psPMRHeader = IMG_CONTAINER_OF(psNode, PMR_HEADER, sZombieNode);
+	PVR_ASSERT(psPMRHeader != NULL);
+	return psPMRHeader->bIsZombiePages;
+}
+
+static PMR_ZOMBIE_PAGES*
+PMR_GetZombiePagesFromNode(const DLLIST_NODE *psNode)
+{
+	PMR_HEADER *psPMRHeader = IMG_CONTAINER_OF(psNode, PMR_HEADER, sZombieNode);
+	PVR_ASSERT(psPMRHeader != NULL);
+	return IMG_CONTAINER_OF(psPMRHeader, PMR_ZOMBIE_PAGES, sHeader);
+}
+#endif /* defined(SUPPORT_PMR_PAGES_DEFERRED_FREE) */
+
+static PMR*
+PMR_GetPMRFromNode(const DLLIST_NODE *psNode)
+{
+	PMR_HEADER *psPMRHeader = IMG_CONTAINER_OF(psNode, PMR_HEADER, sZombieNode);
+	PVR_ASSERT(psPMRHeader != NULL);
+	return IMG_CONTAINER_OF(psPMRHeader, PMR, sHeader);
+}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+
 static void
 _UnrefAndMaybeDestroy(PMR *psPMR)
 {
@@ -685,7 +765,7 @@ _UnrefAndMaybeDestroy(PMR *psPMR)
 		OSLockAcquire(psDevNode->hPMRZombieListLock);
 
 		BITMASK_SET(psPMR->uiInternalFlags, PMR_FLAG_INTERNAL_IS_ZOMBIE);
-		dllist_add_to_tail(&psDevNode->sPMRZombieList, &psPMR->sZombieNode);
+		dllist_add_to_tail(&psDevNode->sPMRZombieList, &psPMR->sHeader.sZombieNode);
 		psDevNode->uiPMRZombieCount++;
 
 		/* PMR pages are accounted by the driver/process stats. Those stats
@@ -748,6 +828,8 @@ static PVRSRV_ERROR _PmrZombieCleanup(void *pvData)
 {
 	PMR_ZOMBIE_CLEANUP_ITEM *psCleanupItem = pvData;
 	DLLIST_NODE *psNode;
+	IMG_BOOL bNeedRetry = IMG_FALSE;
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (_CanNotFreeZombies(psCleanupItem))
 	{
@@ -756,9 +838,6 @@ static PVRSRV_ERROR _PmrZombieCleanup(void *pvData)
 
 	do
 	{
-		PMR *psPMR;
-		const PMR_IMPL_FUNCTAB *psFuncTable;
-
 		/* hPMRZombieListLock will prevent removing a node while the list is
 		 * processed. If the lock is already acquired by other process which
 		 * intends to remove an item from the list it'll assure the list
@@ -772,37 +851,66 @@ static PVRSRV_ERROR _PmrZombieCleanup(void *pvData)
 
 		if (psNode != NULL)
 		{
-			psPMR = IMG_CONTAINER_OF(psNode, PMR, sZombieNode);
-			psFuncTable = psPMR->psFuncTab;
-
-			_FactoryLock(psFuncTable);
-			_ZombieListLock(psCleanupItem);
-
-			/* It is possible that the element might have been removed so
-			 * we have to check if the PMR is still a zombie. */
-
-			if (PMR_IsZombie(psPMR))
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+			if (PMR_IsListNodeZombiePages(psNode))
 			{
+				PMR_ZOMBIE_PAGES* psZombiePages = PMR_GetZombiePagesFromNode(psNode);
+				eError = psZombiePages->pfnFactoryFreeZombies(psZombiePages->pvFactoryPages);
+				if (eError != PVRSRV_OK)
+				{
+					PVR_DPF((PVR_DBG_ERROR, "Cannot free zombie pages! Skipping object %p", psZombiePages));
+					bNeedRetry = IMG_TRUE;
+					continue;
+				}
+				_ZombieListLock(psCleanupItem);
 				dllist_remove_node(psNode);
 				psCleanupItem->psDevNode->uiPMRZombieCountInCleanup--;
-				/* Unlock here to avoid locking dependency with the power lock.
-				 * It's okay to do it here since the factory lock is the one
-				 * that needs to be held during PMR destruction. */
 				_ZombieListUnlock(psCleanupItem);
 
-				_PMRDestroy(psPMR);
+				OSFreeMem(psZombiePages);
 			}
 			else
+#endif
 			{
-				_ZombieListUnlock(psCleanupItem);
+				PMR* psPMR = PMR_GetPMRFromNode(psNode);
+				const PMR_IMPL_FUNCTAB *psFuncTable = psPMR->psFuncTab;
+
+				_FactoryLock(psFuncTable);
+				_ZombieListLock(psCleanupItem);
+
+				/* It is possible that the element might have been removed so
+				 * we have to check if the PMR is still a zombie. */
+
+				if (PMR_IsZombie(psPMR))
+				{
+					dllist_remove_node(psNode);
+					psCleanupItem->psDevNode->uiPMRZombieCountInCleanup--;
+					/* Unlock here to avoid locking dependency with the power lock.
+					 * It's okay to do it here since the factory lock is the one
+					 * that needs to be held during PMR destruction. */
+					_ZombieListUnlock(psCleanupItem);
+
+					_PMRDestroy(psPMR);
+				}
+				else
+				{
+					_ZombieListUnlock(psCleanupItem);
+				}
+				_FactoryUnlock(psFuncTable);
 			}
-			_FactoryUnlock(psFuncTable);
 		}
 	} while (psNode != NULL);
 
-	OSFreeMem(psCleanupItem);
+	if (bNeedRetry)
+	{
+		eError = PVRSRV_ERROR_RETRY;
+	}
+	else
+	{
+		OSFreeMem(psCleanupItem);
+	}
 
-	return PVRSRV_OK;
+	return eError;
 }
 
 IMG_BOOL PMRQueueZombiesForCleanup(PPVRSRV_DEVICE_NODE psDevNode)
@@ -866,18 +974,18 @@ PMRDequeueZombieAndRef(PMR *psPMR)
 	 * reference count must be 0 (can't use _Ref() due to the warning). */
 	OSAtomicIncrement(&psPMR->iRefCount);
 
-#if defined(SUPPORT_VALIDATION) || defined(DEBUG) || defined(PVR_TESTING_UTILS)
+#if  defined(DEBUG)
 	PVR_LOG(("%s: 0x%p, key:0x%016" IMG_UINT64_FMTSPECX ", numLive:%d",
 			__func__, psPMR, psPMR->uiKey, OSAtomicRead(&psPMR->psContext->uiNumLivePMRs)));
 #endif
 
 	/* If we got to this point the PMR must be on a list. If it's not
 	 * it should mean a race of some sort. */
-	PVR_ASSERT(!dllist_is_empty(&psPMR->sZombieNode));
+	PVR_ASSERT(!dllist_is_empty(&psPMR->sHeader.sZombieNode));
 
 	/* Revive the PMR (remove it from the zombie list) and therefore
 	 * prevent it's destruction. */
-	dllist_remove_node(&psPMR->sZombieNode);
+	dllist_remove_node(&psPMR->sHeader.sZombieNode);
 	BITMASK_UNSET(psPMR->uiInternalFlags, PMR_FLAG_INTERNAL_IS_ZOMBIE);
 	PhysHeapDeviceNode(psPMR->psPhysHeap)->uiPMRZombieCountInCleanup--;
 
@@ -902,7 +1010,7 @@ PVRSRV_ERROR
 PMRCreatePMR(PHYS_HEAP *psPhysHeap,
              PMR_SIZE_T uiLogicalSize,
              IMG_UINT32 ui32NumPhysChunks,
-             IMG_UINT32 ui32NumVirtChunks,
+             IMG_UINT32 ui32NumLogicalChunks,
              IMG_UINT32 *pui32MappingTable,
              PMR_LOG2ALIGN_T uiLog2ContiguityGuarantee,
              PMR_FLAGS_T uiFlags,
@@ -920,7 +1028,7 @@ PMRCreatePMR(PHYS_HEAP *psPhysHeap,
 
 	eError = _PMRCreate(uiLogicalSize,
 	                    ui32NumPhysChunks,
-	                    ui32NumVirtChunks,
+	                    ui32NumLogicalChunks,
 	                    pui32MappingTable,
 	                    uiLog2ContiguityGuarantee,
 	                    uiFlags,
@@ -934,7 +1042,7 @@ PMRCreatePMR(PHYS_HEAP *psPhysHeap,
 	psPMR->eFlavour = eType;
 	OSAtomicWrite(&psPMR->iRefCount, 1);
 
-	OSStringLCopy(psPMR->szAnnotation, pszAnnotation, DEVMEM_ANNOTATION_MAX_LEN);
+	OSStringSafeCopy(psPMR->szAnnotation, pszAnnotation, DEVMEM_ANNOTATION_MAX_LEN);
 
 #if defined(PDUMP)
 	/* if allocation was done on the host node don't include it in the PDUMP */
@@ -956,9 +1064,9 @@ PMRCreatePMR(PHYS_HEAP *psPhysHeap,
 
 		PDumpPMRMallocPMR(psPMR,
 		                  uiLogicalSize,
-		                  1ULL<<uiLog2ContiguityGuarantee,
+		                  IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee),
 		                  ui32NumPhysChunks,
-		                  ui32NumVirtChunks,
+		                  ui32NumLogicalChunks,
 		                  pui32MappingTable,
 		                  uiLog2ContiguityGuarantee,
 		                  bInitialise,
@@ -966,6 +1074,8 @@ PMRCreatePMR(PHYS_HEAP *psPhysHeap,
 		                  &psPMR->hPDumpAllocHandle,
 		                  ui32PDumpFlags);
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
 #endif
 
 	*ppsPMRPtr = psPMR;
@@ -1045,10 +1155,20 @@ PMRUnlockSysPhysAddresses(PMR *psPMR)
 PVRSRV_ERROR
 PMRUnlockSysPhysAddressesNested(PMR *psPMR, IMG_UINT32 ui32NestingLevel)
 {
-	PVRSRV_ERROR eError;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	PMR_IMPL_ZOMBIEPAGES pvZombiePages = NULL;
+	PMR_ZOMBIE_PAGES* psPMRZombiePages = NULL;
+#endif
 
 	PVR_ASSERT(psPMR != NULL);
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	/* Speculatively preallocate in order to simplify error handling later */
+	psPMRZombiePages = OSAllocZMem(sizeof(PMR_ZOMBIE_PAGES));
+	PVR_GOTO_IF_NOMEM(psPMRZombiePages, eError, e0);
+#endif
+
 	/* Acquiring the lock here, as well as during the Lock operation ensures
 	 * the lock count hitting zero and the unlocking of the phys addresses is
 	 * an atomic operation
@@ -1062,7 +1182,13 @@ PMRUnlockSysPhysAddressesNested(PMR *psPMR, IMG_UINT32 ui32NestingLevel)
 		{
 			PVR_ASSERT(psPMR->psFuncTab->pfnLockPhysAddresses != NULL);
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+			eError = psPMR->psFuncTab->pfnUnlockPhysAddresses(psPMR->pvFlavourData,
+			                                                  &pvZombiePages);
+#else
 			eError = psPMR->psFuncTab->pfnUnlockPhysAddresses(psPMR->pvFlavourData);
+#endif
+
 			/* must never fail */
 			PVR_ASSERT(eError == PVRSRV_OK);
 		}
@@ -1070,12 +1196,59 @@ PMRUnlockSysPhysAddressesNested(PMR *psPMR, IMG_UINT32 ui32NestingLevel)
 
 	OSLockRelease(psPMR->hLock);
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	if (pvZombiePages != NULL)
+	{
+		PVRSRV_DEV_POWER_STATE ePowerState;
+		PVRSRV_DEVICE_NODE *psDevNode;
+
+		psDevNode = PhysHeapDeviceNode(psPMR->psPhysHeap);
+		eError = PVRSRVGetDevicePowerState(psDevNode, &ePowerState);
+		if (eError != PVRSRV_OK)
+		{
+			/* Treat unknown power state as ON. */
+			ePowerState = PVRSRV_DEV_POWER_STATE_ON;
+		}
+
+		if (ePowerState == PVRSRV_DEV_POWER_STATE_OFF ||
+			psDevNode->eDevState == PVRSRV_DEVICE_STATE_PCI_ERROR)
+		{
+			/* Free preallocated psPMRZombiePages as these won't be used*/
+			OSFreeMem(psPMRZombiePages);
+
+			eError = psPMR->psFuncTab->pfnFreeZombiePages(pvZombiePages);
+			PVR_LOG_GOTO_IF_ERROR(eError, "Error when trying to free zombies immediately.", e0);
+		}
+		else
+		{
+			PVR_ASSERT(psPMRZombiePages != NULL);
+			psPMRZombiePages->sHeader.bIsZombiePages = IMG_TRUE;
+			psPMRZombiePages->pfnFactoryFreeZombies = psPMR->psFuncTab->pfnFreeZombiePages;
+			psPMRZombiePages->pvFactoryPages = pvZombiePages;
+
+			OSLockAcquire(psDevNode->hPMRZombieListLock);
+			dllist_add_to_tail(&psDevNode->sPMRZombieList, &psPMRZombiePages->sHeader.sZombieNode);
+			psDevNode->uiPMRZombieCount++;
+			OSLockRelease(psDevNode->hPMRZombieListLock);
+		}
+	}
+	else
+	{
+		OSFreeMem(psPMRZombiePages);
+	}
+#endif
+
 	/* We also count the locks as references, so that the PMR is not
 	 * freed while someone is using a physical address.
 	 */
 	_UnrefAndMaybeDestroy(psPMR);
 
-	return PVRSRV_OK;
+	return eError;
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+e0:
+	return eError;
+#endif
 }
 
 PVRSRV_ERROR
@@ -1111,17 +1284,25 @@ PMRLocalImportPMR(PMR *psPMR,
 	/* Return the PMR */
 	*ppsPMR = psPMR;
 	*puiSize = psPMR->uiLogicalSize;
-	*puiAlign = 1ULL << psPMR->uiLog2ContiguityGuarantee;
+	*puiAlign = IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee);
 	return PVRSRV_OK;
 }
 
+inline IMG_UINT64
+PMRInternalGetUID(PMR *psPMR)
+{
+	PVR_ASSERT(psPMR != NULL);
+
+	return psPMR->uiSerialNum;
+}
+
 PVRSRV_ERROR
 PMRGetUID(PMR *psPMR,
           IMG_UINT64 *pui64UID)
 {
 	PVR_ASSERT(psPMR != NULL);
 
-	*pui64UID = psPMR->uiSerialNum;
+	*pui64UID = PMRInternalGetUID(psPMR);
 
 	return PVRSRV_OK;
 }
@@ -1294,7 +1475,7 @@ PVRSRV_ERROR PMRSecureImportPMR(CONNECTION_DATA *psConnection,
 	/* Return the PMR */
 	*ppsPMR = psPMR;
 	*puiSize = psPMR->uiLogicalSize;
-	*puiAlign = 1ull << psPMR->uiLog2ContiguityGuarantee;
+	*puiAlign = IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee);
 	return PVRSRV_OK;
 e0:
 	PVR_ASSERT(eError != PVRSRV_OK);
@@ -1368,7 +1549,7 @@ _PMRAcquireKernelMappingData(PMR *psPMR,
 		/* Zero size means map in the whole PMR ... */
 		*puiLengthOut = (size_t)psPMR->uiLogicalSize;
 	}
-	else if (uiSize > (1 << psPMR->uiLog2ContiguityGuarantee))
+	else if (uiSize > IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee))
 	{
 		/* ... map in the requested pages ... */
 		*puiLengthOut = uiSize;
@@ -1376,10 +1557,14 @@ _PMRAcquireKernelMappingData(PMR *psPMR,
 	else
 	{
 		/* ... otherwise we just map in one page */
-		*puiLengthOut = 1 << psPMR->uiLog2ContiguityGuarantee;
+		*puiLengthOut = IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee);
 	}
 	*phPrivOut = hPriv;
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	PMRCpuMapCountIncr(psPMR);
+#endif
+
 	return PVRSRV_OK;
 
 e0:
@@ -1428,6 +1613,10 @@ PMRReleaseKernelMappingData(PMR *psPMR,
 	PVR_ASSERT (psPMR->psFuncTab->pfnAcquireKernelMappingData != NULL);
 	PVR_ASSERT (psPMR->psFuncTab->pfnReleaseKernelMappingData != NULL);
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+	PMRCpuMapCountDecr(psPMR);
+#endif
+
 	psPMR->psFuncTab->pfnReleaseKernelMappingData(psPMR->pvFlavourData,
 	                                              hPriv);
 
@@ -1448,7 +1637,7 @@ PMRReleaseKernelMappingData(PMR *psPMR,
 	Log2PageSize else argument is redundant (set to zero).
  */
 
-static void
+static PVRSRV_ERROR
 _PMRLogicalOffsetToPhysicalOffset(const PMR *psPMR,
                                   IMG_UINT32 ui32Log2PageSize,
                                   IMG_UINT32 ui32NumOfPages,
@@ -1465,12 +1654,12 @@ _PMRLogicalOffsetToPhysicalOffset(const PMR *psPMR,
 	IMG_UINT32 idx;
 
 	/* Must be translating at least a page */
-	PVR_ASSERT(ui32NumOfPages);
+	PVR_ASSERT(ui32NumOfPages > 0);
 
-	if (psMappingTable->ui32NumPhysChunks == psMappingTable->ui32NumVirtChunks)
+	if (psMappingTable->ui32NumPhysChunks == psMappingTable->ui32NumLogicalChunks)
 	{
 		/* Fast path the common case, as logical and physical offsets are
-			equal we assume the ui32NumOfPages span is also valid */
+		 * equal we assume the ui32NumOfPages span is also valid */
 		*pui32BytesRemain = TRUNCATE_64BITS_TO_32BITS(psPMR->uiLogicalSize - uiOffset);
 		puiPhysicalOffset[0] = uiOffset;
 		bValid[0] = IMG_TRUE;
@@ -1479,7 +1668,7 @@ _PMRLogicalOffsetToPhysicalOffset(const PMR *psPMR,
 		{
 			/* initial offset may not be page aligned, round down */
 			uiOffset &= ~(uiPageSize-1);
-			for (idx=1; idx < ui32NumOfPages; idx++)
+			for (idx = 1; idx < ui32NumOfPages; idx++)
 			{
 				uiOffset += uiPageSize;
 				puiPhysicalOffset[idx] = uiOffset;
@@ -1489,46 +1678,50 @@ _PMRLogicalOffsetToPhysicalOffset(const PMR *psPMR,
 	}
 	else
 	{
-		for (idx=0; idx < ui32NumOfPages; idx++)
+		for (idx = 0; idx < ui32NumOfPages; idx++)
 		{
+			IMG_UINT32 uiTranslation;
+			const IMG_UINT32 uiChunkSize = psMappingTable->uiChunkSize;
+
 			ui64ChunkIndex = OSDivide64r64(
 					uiOffset,
-					TRUNCATE_64BITS_TO_32BITS(psMappingTable->uiChunkSize),
+					TRUNCATE_64BITS_TO_32BITS(uiChunkSize),
 					&ui32Remain);
 
-			if (psMappingTable->aui32Translation[ui64ChunkIndex] == TRANSLATION_INVALID)
+			/* In some cases ui32NumOfPages can come from the user space which
+			 * means that the uiOffset could go out-of-bounds when the number
+			 * of pages is invalid. */
+			if (ui64ChunkIndex >= psMappingTable->ui32NumLogicalChunks)
+			{
+				return PVRSRV_ERROR_BAD_MAPPING;
+			}
+
+			uiTranslation = psMappingTable->aui32Translation[ui64ChunkIndex];
+
+			if (uiTranslation == TRANSLATION_INVALID)
 			{
 				bValid[idx] = IMG_FALSE;
+				/* explicitly set to an invalid value */
+				puiPhysicalOffset[idx] = IMG_UINT64_C(0xffffffffffffffff);
 			}
 			else
 			{
 				bValid[idx] = IMG_TRUE;
+				puiPhysicalOffset[idx] = uiTranslation * uiChunkSize + ui32Remain;
 			}
 
 			if (idx == 0)
 			{
-				if (ui32Remain == 0)
-				{
-					/* Start of chunk so return the chunk size */
-					*pui32BytesRemain = TRUNCATE_64BITS_TO_32BITS(psMappingTable->uiChunkSize);
-				}
-				else
-				{
-					*pui32BytesRemain = TRUNCATE_64BITS_TO_32BITS(psMappingTable->uiChunkSize - ui32Remain);
-				}
-
-				puiPhysicalOffset[idx] = (psMappingTable->aui32Translation[ui64ChunkIndex] * psMappingTable->uiChunkSize) +	 ui32Remain;
-
+				*pui32BytesRemain = TRUNCATE_64BITS_TO_32BITS(uiChunkSize - ui32Remain);
 				/* initial offset may not be page aligned, round down */
 				uiOffset &= ~(uiPageSize-1);
 			}
-			else
-			{
-				puiPhysicalOffset[idx] = psMappingTable->aui32Translation[ui64ChunkIndex] * psMappingTable->uiChunkSize + ui32Remain;
-			}
+
 			uiOffset += uiPageSize;
 		}
 	}
+
+	return PVRSRV_OK;
 }
 
 static PVRSRV_ERROR
@@ -1633,13 +1826,15 @@ PMR_ReadBytes(PMR *psPMR,
 		size_t uiRead;
 		IMG_BOOL bValid;
 
-		_PMRLogicalOffsetToPhysicalOffset(psPMR,
-		                                  0,
-		                                  1,
-		                                  uiLogicalOffset,
-		                                  &uiPhysicalOffset,
-		                                  &ui32Remain,
-		                                  &bValid);
+		eError = _PMRLogicalOffsetToPhysicalOffset(psPMR,
+		                                           0,
+		                                           1,
+		                                           uiLogicalOffset,
+		                                           &uiPhysicalOffset,
+		                                           &ui32Remain,
+		                                           &bValid);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_PMRLogicalOffsetToPhysicalOffset");
+
 		/* Copy till either then end of the chunk or end
 		 * of the buffer
 		 */
@@ -1790,13 +1985,14 @@ PMR_WriteBytes(PMR *psPMR,
 		size_t uiWrite;
 		IMG_BOOL bValid;
 
-		_PMRLogicalOffsetToPhysicalOffset(psPMR,
-		                                  0,
-		                                  1,
-		                                  uiLogicalOffset,
-		                                  &uiPhysicalOffset,
-		                                  &ui32Remain,
-		                                  &bValid);
+		eError = _PMRLogicalOffsetToPhysicalOffset(psPMR,
+		                                           0,
+		                                           1,
+		                                           uiLogicalOffset,
+		                                           &uiPhysicalOffset,
+		                                           &ui32Remain,
+		                                           &bValid);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_PMRLogicalOffsetToPhysicalOffset");
 
 		/* Copy till either then end of the chunk or end of the buffer
 		 */
@@ -1843,6 +2039,8 @@ PMRMMapPMR(PMR *psPMR, PMR_MMAP_DATA pOSMMapData, PVRSRV_MEMALLOCFLAGS_T uiFlags
 	                    !PVRSRV_CHECK_CPU_WRITEABLE(uiFlags),
 	                    PVRSRV_ERROR_PMR_NOT_PERMITTED);
 
+	PVR_LOG_RETURN_IF_TRUE(PMR_PhysicalSize(psPMR) == 0, "PVRSRV_ERROR_BAD_MAPPING can not map PMR of 0 physical size", PVRSRV_ERROR_BAD_MAPPING);
+
 	if (psPMR->psFuncTab->pfnMMap)
 	{
 		return psPMR->psFuncTab->pfnMMap(psPMR->pvFlavourData, psPMR, pOSMMapData);
@@ -1891,26 +2089,62 @@ PMRUnrefPMR2(PMR *psPMR)
 	_UnrefAndMaybeDestroy(psPMR);
 }
 
-PVRSRV_ERROR
-PMRUnrefUnlockPMR(PMR *psPMR)
+#define PMR_MAPCOUNT_MIN 0
+#define PMR_MAPCOUNT_MAX IMG_INT32_MAX
+
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+PVRSRV_ERROR PMRTryRefPMR(PMR *psPMR)
 {
-	PMRUnlockSysPhysAddresses(psPMR);
+	PVR_ASSERT(psPMR != NULL);
 
-	_UnrefAndMaybeDestroy(psPMR);
+	if (OSAtomicAddUnless(&psPMR->iRefCount, 1, 0) == 0)
+	{
+		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
+	}
 
 	return PVRSRV_OK;
 }
 
-#define PMR_CPUMAPCOUNT_MIN 0
-#define PMR_CPUMAPCOUNT_MAX IMG_INT32_MAX
 void
-PMRCpuMapCountIncr(PMR *psPMR)
+PMRGpuMapDevPageCountIncr(PMR *psPMR, IMG_UINT32 uiCount)
+{
+	if (OSAtomicAddUnless(&psPMR->iGpuMapCount, uiCount, PMR_MAPCOUNT_MAX) == PMR_MAPCOUNT_MAX)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: iGpuMapCount for PMR: @0x%p (%s) has overflowed.",
+		                        __func__,
+		                        psPMR,
+		                        psPMR->szAnnotation));
+		OSWarnOn(1);
+	}
+}
+
+void
+PMRGpuMapDevPageCountDecr(PMR *psPMR, IMG_UINT32 uiCount)
 {
-	IMG_BOOL bSuccess;
+	if (OSAtomicSubtractUnless(&psPMR->iGpuMapCount, uiCount, PMR_MAPCOUNT_MIN) == PMR_MAPCOUNT_MIN)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: iGpuMapCount (now %d) for PMR: @0x%p (%s) has underflowed.",
+		                        __func__,
+		                        (IMG_INT32) OSAtomicRead(&psPMR->iGpuMapCount),
+		                        psPMR,
+		                        psPMR->szAnnotation));
+		OSWarnOn(1);
+	}
+}
+
+IMG_BOOL
+PMR_IsGpuMapped(PMR *psPMR)
+{
+	PVR_ASSERT(psPMR != NULL);
 
-	bSuccess = OSAtomicAddUnless(&psPMR->iCpuMapCount, 1,
-	                             PMR_CPUMAPCOUNT_MAX);
-	if (!bSuccess)
+	return (OSAtomicRead(&psPMR->iGpuMapCount) > 0);
+}
+#endif /* #if defined(SUPPORT_LINUX_OSPAGE_MIGRATION) */
+
+void
+PMRCpuMapCountIncr(PMR *psPMR)
+{
+	if (OSAtomicAddUnless(&psPMR->iCpuMapCount, 1, PMR_MAPCOUNT_MAX) == PMR_MAPCOUNT_MAX)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: iCpuMapCount for PMR: @0x%p (%s) has overflowed.",
 		                        __func__,
@@ -1923,11 +2157,7 @@ PMRCpuMapCountIncr(PMR *psPMR)
 void
 PMRCpuMapCountDecr(PMR *psPMR)
 {
-	IMG_BOOL bSuccess;
-
-	bSuccess = OSAtomicSubtractUnless(&psPMR->iCpuMapCount, 1,
-	                                  PMR_CPUMAPCOUNT_MIN);
-	if (!bSuccess)
+	if (OSAtomicSubtractUnless(&psPMR->iCpuMapCount, 1, PMR_MAPCOUNT_MIN) == PMR_MAPCOUNT_MIN)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: iCpuMapCount (now %d) for PMR: @0x%p (%s) has underflowed.",
 		                        __func__,
@@ -1938,14 +2168,55 @@ PMRCpuMapCountDecr(PMR *psPMR)
 	}
 }
 
-static IMG_BOOL
-_PMR_IsMapped(PMR *psPMR)
+IMG_BOOL
+PMR_IsCpuMapped(PMR *psPMR)
 {
 	PVR_ASSERT(psPMR != NULL);
 
 	return (OSAtomicRead(&psPMR->iCpuMapCount) > 0);
 }
 
+void
+PMRGpuResCountIncr(PMR *psPMR)
+{
+	if (psPMR->iAssociatedResCount == PMR_MAPCOUNT_MAX)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: iAssociatedResCount for PMR: @0x%p (%s) has overflowed.",
+		                        __func__,
+		                        psPMR,
+		                        psPMR->szAnnotation));
+		OSWarnOn(1);
+		return;
+	}
+
+	psPMR->iAssociatedResCount++;
+}
+
+void
+PMRGpuResCountDecr(PMR *psPMR)
+{
+	if (psPMR->iAssociatedResCount == PMR_MAPCOUNT_MIN)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: iAssociatedResCount (now %d) for PMR: @0x%p (%s) has underflowed.",
+		                        __func__,
+		                        psPMR->iAssociatedResCount,
+		                        psPMR,
+		                        psPMR->szAnnotation));
+		OSWarnOn(1);
+		return;
+	}
+
+	psPMR->iAssociatedResCount--;
+}
+
+IMG_BOOL
+PMR_IsGpuMultiMapped(PMR *psPMR)
+{
+	PVR_ASSERT(psPMR != NULL);
+
+	return psPMR->iAssociatedResCount > 1;
+}
+
 PVRSRV_DEVICE_NODE *
 PMR_DeviceNode(const PMR *psPMR)
 {
@@ -2006,18 +2277,8 @@ IMG_BOOL PMR_IsMemLayoutFixed(PMR *psPMR)
 	return BITMASK_HAS(psPMR->uiInternalFlags, PMR_FLAG_INTERNAL_NO_LAYOUT_CHANGE);
 }
 
-void
-PMR_LogicalSize(const PMR *psPMR,
-                IMG_DEVMEM_SIZE_T *puiLogicalSize)
-{
-	PVR_ASSERT(psPMR != NULL);
-
-	*puiLogicalSize = psPMR->uiLogicalSize;
-}
-
-PVRSRV_ERROR
-PMR_PhysicalSize(const PMR *psPMR,
-                 IMG_DEVMEM_SIZE_T *puiPhysicalSize)
+IMG_DEVMEM_SIZE_T
+PMR_PhysicalSize(const PMR *psPMR)
 {
 	PVR_ASSERT(psPMR != NULL);
 
@@ -2026,24 +2287,15 @@ PMR_PhysicalSize(const PMR *psPMR,
 	{
 		if (_PMRIsSparse(psPMR))
 		{
-			*puiPhysicalSize = psPMR->psMappingTable->uiChunkSize * psPMR->psMappingTable->ui32NumPhysChunks;
+			return psPMR->psMappingTable->uiChunkSize * psPMR->psMappingTable->ui32NumPhysChunks;
 		}
 		else
 		{
-			*puiPhysicalSize = psPMR->uiLogicalSize;
+			return psPMR->uiLogicalSize;
 		}
 	}
-	else
-	{
-		*puiPhysicalSize = 0;
-	}
-	return PVRSRV_OK;
-}
 
-PHYS_HEAP *
-PMR_PhysHeap(const PMR *psPMR)
-{
-	return psPMR->psPhysHeap;
+	return 0;
 }
 
 PVRSRV_ERROR
@@ -2071,13 +2323,14 @@ PMR_IsOffsetValid(const PMR *psPMR,
 		PVR_GOTO_IF_NOMEM(pui32BytesRemain, eError, e0);
 	}
 
-	_PMRLogicalOffsetToPhysicalOffset(psPMR,
-	                                  ui32Log2PageSize,
-	                                  ui32NumOfPages,
-	                                  uiLogicalOffset,
-	                                  puiPhysicalOffset,
-	                                  pui32BytesRemain,
-	                                  pbValid);
+	eError = _PMRLogicalOffsetToPhysicalOffset(psPMR,
+	                                           ui32Log2PageSize,
+	                                           ui32NumOfPages,
+	                                           uiLogicalOffset,
+	                                           puiPhysicalOffset,
+	                                           pui32BytesRemain,
+	                                           pbValid);
+	PVR_LOG_IF_ERROR(eError, "_PMRLogicalOffsetToPhysicalOffset");
 
 e0:
 	if (puiPhysicalOffset != auiPhysicalOffset && puiPhysicalOffset != NULL)
@@ -2093,6 +2346,12 @@ PMR_IsOffsetValid(const PMR *psPMR,
 	return eError;
 }
 
+PHYS_HEAP *
+PMR_PhysHeap(const PMR *psPMR)
+{
+	return psPMR->psPhysHeap;
+}
+
 PMR_MAPPING_TABLE *
 PMR_GetMappingTable(const PMR *psPMR)
 {
@@ -2108,10 +2367,19 @@ PMR_GetLog2Contiguity(const PMR *psPMR)
 	return psPMR->uiLog2ContiguityGuarantee;
 }
 
-IMG_UINT32 PMRGetMaxChunkCount(PMR *psPMR)
+IMG_DEVMEM_SIZE_T
+PMR_LogicalSize(const PMR *psPMR)
 {
 	PVR_ASSERT(psPMR != NULL);
-	return (PMR_MAX_SUPPORTED_SIZE >> psPMR->uiLog2ContiguityGuarantee);
+
+	return psPMR->uiLogicalSize;
+}
+
+IMG_UINT32 PMR_GetLogicalChunkCount(const PMR *psPMR)
+{
+	PVR_ASSERT(psPMR != NULL);
+
+	return psPMR->psMappingTable->ui32NumLogicalChunks;
 }
 
 const IMG_CHAR *
@@ -2240,7 +2508,7 @@ PMR_DevPhysAddr(const PMR *psPMR,
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_DEVMEM_OFFSET_T auiPhysicalOffset[PMR_MAX_TRANSLATION_STACK_ALLOC];
 	IMG_DEVMEM_OFFSET_T *puiPhysicalOffset = auiPhysicalOffset;
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	IMG_UINT32 ui32FlagsIPAPolicy;      /* Local value for the IPA policy */
 	IMG_UINT32 ui32IPAHeapShift;        /* Phys-heap bit-shift value */
 	IMG_UINT32 ui32IPAHeapPolicyValue;  /* Phys-heap default policy value */
@@ -2255,9 +2523,11 @@ PMR_DevPhysAddr(const PMR *psPMR,
 	PVR_ASSERT(ui32NumOfPages > 0);
 	PVR_ASSERT(psPMR->psFuncTab->pfnDevPhysAddr != NULL);
 
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	PVR_ASSERT(OSAtomicRead(&psPMR->iLockCount) > (PVRSRV_CHECK_ON_DEMAND(psPMR->uiFlags) ? 0 : 1));
-#endif
+	if (OSAtomicRead(&psPMR->iLockCount) <= 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"Attempt to obtain DevPhysAddr of non-backed PMR"));
+		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
+	}
 
 	if (ui32NumOfPages > PMR_MAX_TRANSLATION_STACK_ALLOC)
 	{
@@ -2265,15 +2535,16 @@ PMR_DevPhysAddr(const PMR *psPMR,
 		PVR_RETURN_IF_NOMEM(puiPhysicalOffset);
 	}
 
-	_PMRLogicalOffsetToPhysicalOffset(psPMR,
-	                                  ui32Log2PageSize,
-	                                  ui32NumOfPages,
-	                                  uiLogicalOffset,
-	                                  puiPhysicalOffset,
-	                                  &ui32Remain,
-	                                  pbValid);
+	eError = _PMRLogicalOffsetToPhysicalOffset(psPMR,
+	                                           ui32Log2PageSize,
+	                                           ui32NumOfPages,
+	                                           uiLogicalOffset,
+	                                           puiPhysicalOffset,
+	                                           &ui32Remain,
+	                                           pbValid);
+	PVR_LOG_GOTO_IF_ERROR(eError, "_PMRLogicalOffsetToPhysicalOffset", FreeOffsetArray);
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 	/* Need to determine the values to pass into the pfnDevPhysAddr
 	 * for Intermediate Physical Address settings associated with
 	 * this PMR.
@@ -2312,14 +2583,14 @@ PMR_DevPhysAddr(const PMR *psPMR,
 	}
 	ui64IPAPolicy = (IMG_UINT64)ui32FlagsIPAPolicy << ui32IPAHeapShift;
 	ui64IPAClearMask = (IMG_UINT64)ui32IPAHeapClearMask << ui32IPAHeapShift;
-#endif	/* PVRSRV_SUPPORT_IPA_FEATURE */
+#endif	/* SUPPORT_STATIC_IPA */
 
 	/* Sparse PMR may not always have the first page valid */
 	eError = psPMR->psFuncTab->pfnDevPhysAddr(psPMR->pvFlavourData,
 											  ui32Log2PageSize,
 											  ui32NumOfPages,
 											  puiPhysicalOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 											  ui64IPAPolicy,
 											  ui64IPAClearMask,
 #endif
@@ -2430,13 +2701,40 @@ PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
 {
 	PVRSRV_ERROR eError;
 
-	if (PMR_IsMemLayoutFixed(psPMR) || _PMR_IsMapped(psPMR))
+	PMRLockPMR(psPMR);
+
+	eError = PMR_ChangeSparseMemUnlocked(psPMR,
+	                                     ui32AllocPageCount,
+	                                     pai32AllocIndices,
+	                                     ui32FreePageCount,
+	                                     pai32FreeIndices,
+	                                     uiSparseFlags);
+
+	PMRUnlockPMR(psPMR);
+
+	return eError;
+}
+
+PVRSRV_ERROR PMR_ChangeSparseMemUnlocked(PMR *psPMR,
+                                 IMG_UINT32 ui32AllocPageCount,
+                                 IMG_UINT32 *pai32AllocIndices,
+                                 IMG_UINT32 ui32FreePageCount,
+                                 IMG_UINT32 *pai32FreeIndices,
+                                 IMG_UINT32 uiSparseFlags)
+{
+	PVRSRV_ERROR eError;
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	PMR_IMPL_ZOMBIEPAGES pvZombiePages = NULL;
+	PMR_ZOMBIE_PAGES* psPMRZombiePages = NULL;
+#endif
+
+	if (PMR_IsMemLayoutFixed(psPMR) || PMR_IsCpuMapped(psPMR))
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 				"%s: This PMR layout cannot be changed - PMR_IsMemLayoutFixed()=%c, _PMR_IsMapped()=%c",
 				__func__,
 				PMR_IsMemLayoutFixed(psPMR) ? 'Y' : 'n',
-				_PMR_IsMapped(psPMR) ? 'Y' : 'n'));
+				PMR_IsCpuMapped(psPMR) ? 'Y' : 'n'));
 		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
 	}
 
@@ -2448,12 +2746,24 @@ PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
 		return PVRSRV_ERROR_NOT_IMPLEMENTED;
 	}
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	if (uiSparseFlags & SPARSE_RESIZE_FREE)
+	{
+		/* Speculatively preallocate in order to simplify error handling later */
+		psPMRZombiePages = OSAllocZMem(sizeof(PMR_ZOMBIE_PAGES));
+		PVR_GOTO_IF_NOMEM(psPMRZombiePages, eError, e0);
+	}
+#endif
+
 	eError = psPMR->psFuncTab->pfnChangeSparseMem(psPMR->pvFlavourData,
 	                                              psPMR,
 	                                              ui32AllocPageCount,
 	                                              pai32AllocIndices,
 	                                              ui32FreePageCount,
 	                                              pai32FreeIndices,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	                                              &pvZombiePages,
+#endif
 	                                              uiSparseFlags);
 	if (eError != PVRSRV_OK)
 	{
@@ -2466,8 +2776,51 @@ PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
 									  OSGetCurrentClientProcessIDKM());
 		}
 #endif
-		goto e0;
+		goto e1;
+	}
+
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	if (pvZombiePages != NULL)
+	{
+		PVRSRV_DEV_POWER_STATE ePowerState;
+		PVRSRV_DEVICE_NODE *psDevNode;
+
+		psDevNode = PhysHeapDeviceNode(psPMR->psPhysHeap);
+		eError = PVRSRVGetDevicePowerState(psDevNode, &ePowerState);
+		if (eError != PVRSRV_OK)
+		{
+			/* Treat unknown power state as ON. */
+			ePowerState = PVRSRV_DEV_POWER_STATE_ON;
+		}
+
+		if (ePowerState == PVRSRV_DEV_POWER_STATE_OFF ||
+			psDevNode->eDevState == PVRSRV_DEVICE_STATE_PCI_ERROR)
+		{
+			/* Free preallocated psPMRZombiePages as these won't be used*/
+			OSFreeMem(psPMRZombiePages);
+
+			eError = psPMR->psFuncTab->pfnFreeZombiePages(pvZombiePages);
+			PVR_LOG_GOTO_IF_ERROR(eError, "Error when trying to free zombies immediately.", e0);
+		}
+		else
+		{
+			PVR_ASSERT(psPMRZombiePages != NULL);
+			psPMRZombiePages->sHeader.bIsZombiePages = IMG_TRUE;
+			psPMRZombiePages->pfnFactoryFreeZombies = psPMR->psFuncTab->pfnFreeZombiePages;
+			psPMRZombiePages->pvFactoryPages = pvZombiePages;
+
+			OSLockAcquire(psDevNode->hPMRZombieListLock);
+			dllist_add_to_tail(&psDevNode->sPMRZombieList, &psPMRZombiePages->sHeader.sZombieNode);
+			psDevNode->uiPMRZombieCount++;
+			OSLockRelease(psDevNode->hPMRZombieListLock);
+		}
 	}
+	else
+	{
+		/* Free psPMRZombiePages as change sparse has not produced zombie pages */
+		OSFreeMem(psPMRZombiePages);
+	}
+#endif
 
 #if defined(PDUMP)
 	{
@@ -2485,7 +2838,7 @@ PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
 		}
 
 		PDumpPMRChangeSparsePMR(psPMR,
-		                        1 << psPMR->uiLog2ContiguityGuarantee,
+		                        IMG_PAGE2BYTES32(psPMR->uiLog2ContiguityGuarantee),
 		                        ui32AllocPageCount,
 		                        pai32AllocIndices,
 		                        ui32FreePageCount,
@@ -2497,49 +2850,18 @@ PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
 
 #endif
 
-e0:
-	return eError;
-}
-
-
-PVRSRV_ERROR PMR_ChangeSparseMemCPUMap(PMR *psPMR,
-                                       IMG_UINT64 sCpuVAddrBase,
-                                       IMG_UINT32 ui32AllocPageCount,
-                                       IMG_UINT32 *pai32AllocIndices,
-                                       IMG_UINT32 ui32FreePageCount,
-                                       IMG_UINT32 *pai32FreeIndices)
-{
-	PVRSRV_ERROR eError;
-
-	if ((NULL == psPMR->psFuncTab) ||
-			(NULL == psPMR->psFuncTab->pfnChangeSparseMemCPUMap))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-				"%s: This type of sparse PMR cannot be changed.",
-				__func__));
-		return PVRSRV_ERROR_NOT_IMPLEMENTED;
-	}
-
-	if (PMR_IsMemLayoutFixed(psPMR))
+	return PVRSRV_OK;
+e1:
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+	if (uiSparseFlags & SPARSE_RESIZE_FREE)
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-				"%s: This PMR layout cannot be changed",
-				__func__));
-		return PVRSRV_ERROR_PMR_NOT_PERMITTED;
+		OSFreeMem(psPMRZombiePages);
 	}
-
-	eError = psPMR->psFuncTab->pfnChangeSparseMemCPUMap(psPMR->pvFlavourData,
-	                                                    psPMR,
-	                                                    sCpuVAddrBase,
-	                                                    ui32AllocPageCount,
-	                                                    pai32AllocIndices,
-	                                                    ui32FreePageCount,
-	                                                    pai32FreeIndices);
-
+e0:
+#endif
 	return eError;
 }
 
-
 #if defined(PDUMP)
 
 static PVRSRV_ERROR
@@ -2565,8 +2887,7 @@ _PMR_PDumpSymbolicAddrPhysical(const PMR *psPMR,
 	}
 	else
 #endif
-	if (DevmemCPUCacheCoherency(psDevNode, psPMR->uiFlags) ||
-	    DevmemDeviceCacheCoherency(psDevNode, psPMR->uiFlags))
+	if (DevmemDeviceCacheCoherency(psDevNode, psPMR->uiFlags))
 	{
 		OSSNPrintf(pszMemspaceName,
 		           ui32MemspaceNameLen,
@@ -2593,7 +2914,7 @@ _PMR_PDumpSymbolicAddrPhysical(const PMR *psPMR,
 	}
 
 
-	*puiNewOffset = uiPhysicalOffset & ((1 << PMR_GetLog2Contiguity(psPMR))-1);
+	*puiNewOffset = uiPhysicalOffset & (IMG_PAGE2BYTES64(PMR_GetLog2Contiguity(psPMR))-1);
 	*puiNextSymName = (IMG_DEVMEM_OFFSET_T) (((uiPhysicalOffset >> PMR_GetLog2Contiguity(psPMR))+1)
 			<< PMR_GetLog2Contiguity(psPMR));
 
@@ -2615,6 +2936,7 @@ PMR_PDumpSymbolicAddr(const PMR *psPMR,
 	IMG_DEVMEM_OFFSET_T uiPhysicalOffset;
 	IMG_UINT32 ui32Remain;
 	IMG_BOOL bValid;
+	PVRSRV_ERROR eError;
 
 	PVR_ASSERT(uiLogicalOffset < psPMR->uiLogicalSize);
 
@@ -2626,13 +2948,14 @@ PMR_PDumpSymbolicAddr(const PMR *psPMR,
 		return PVRSRV_OK;
 	}
 
-	_PMRLogicalOffsetToPhysicalOffset(psPMR,
-	                                  0,
-	                                  1,
-	                                  uiLogicalOffset,
-	                                  &uiPhysicalOffset,
-	                                  &ui32Remain,
-	                                  &bValid);
+	eError = _PMRLogicalOffsetToPhysicalOffset(psPMR,
+	                                           0,
+	                                           1,
+	                                           uiLogicalOffset,
+	                                           &uiPhysicalOffset,
+	                                           &ui32Remain,
+	                                           &bValid);
+	PVR_LOG_RETURN_IF_ERROR(eError, "_PMRLogicalOffsetToPhysicalOffset");
 
 	if (!bValid)
 	{
@@ -2838,7 +3161,7 @@ PMRPDumpLoadMemValue64(PMR *psPMR,
 	IMG_CHAR aszSymbolicName[PHYSMEM_PDUMP_SYMNAME_MAX_LENGTH];
 	IMG_DEVMEM_OFFSET_T uiPDumpSymbolicOffset;
 	IMG_DEVMEM_OFFSET_T uiNextSymName;
-	IMG_UINT32 uiPMRPageSize = 1 << psPMR->uiLog2ContiguityGuarantee;
+	PMR_SIZE_T ui64PMRPageSize = IMG_PAGE2BYTES64(psPMR->uiLog2ContiguityGuarantee);
 
 	/* Confirm that the device node's ui32InternalID matches the bound
 	 * PDump device stored in PVRSRV_DATA.
@@ -2850,8 +3173,8 @@ PMRPDumpLoadMemValue64(PMR *psPMR,
 
 	PVR_ASSERT(uiLogicalOffset + sizeof(ui64Value) <= psPMR->uiLogicalSize);
 	/* Especially make sure to not cross a block boundary */
-	PVR_ASSERT(( ((uiLogicalOffset & (uiPMRPageSize-1)) + sizeof(ui64Value))
-			<= uiPMRPageSize));
+	PVR_ASSERT(( ((uiLogicalOffset & (ui64PMRPageSize-1)) + sizeof(ui64Value))
+			<= ui64PMRPageSize));
 
 	eError = PMRLockSysPhysAddresses(psPMR);
 	PVR_ASSERT(eError == PVRSRV_OK);
@@ -2908,18 +3231,18 @@ PMRPDumpCopyMem64(PMR *psDstPMR,
 	IMG_CHAR aszSymbolicName[PHYSMEM_PDUMP_SYMNAME_MAX_LENGTH];
 	IMG_DEVMEM_OFFSET_T uiPDumpSymbolicOffset;
 	IMG_DEVMEM_OFFSET_T uiNextSymName;
-	const IMG_UINT32 uiDstPMRPageSize = 1 << psDstPMR->uiLog2ContiguityGuarantee;
-	const IMG_UINT32 uiSrcPMRPageSize = 1 << psSrcPMR->uiLog2ContiguityGuarantee;
+	const PMR_SIZE_T ui64DstPMRPageSize = IMG_PAGE2BYTES64(psDstPMR->uiLog2ContiguityGuarantee);
+	const PMR_SIZE_T ui64SrcPMRPageSize = IMG_PAGE2BYTES64(psSrcPMR->uiLog2ContiguityGuarantee);
 
 	PVR_ASSERT(uiSrcLogicalOffset + sizeof(IMG_UINT32) <= psSrcPMR->uiLogicalSize);
 	/* Especially make sure to not cross a block boundary */
-	PVR_ASSERT(( ((uiSrcLogicalOffset & (uiSrcPMRPageSize-1)) + sizeof(IMG_UINT32))
-			<= uiSrcPMRPageSize));
+	PVR_ASSERT(( ((uiSrcLogicalOffset & (ui64SrcPMRPageSize-1)) + sizeof(IMG_UINT32))
+			<= ui64SrcPMRPageSize));
 
 	PVR_ASSERT(uiDstLogicalOffset + sizeof(IMG_UINT32) <= psDstPMR->uiLogicalSize);
 	/* Especially make sure to not cross a block boundary */
-	PVR_ASSERT(( ((uiDstLogicalOffset & (uiDstPMRPageSize-1)) + sizeof(IMG_UINT32))
-			<= uiDstPMRPageSize));
+	PVR_ASSERT(( ((uiDstLogicalOffset & (ui64DstPMRPageSize-1)) + sizeof(IMG_UINT32))
+			<= ui64DstPMRPageSize));
 
 	eError = PMRLockSysPhysAddresses(psSrcPMR);
 	PVR_ASSERT(eError == PVRSRV_OK);
@@ -3012,7 +3335,7 @@ PMRPDumpLoadMem(PMR *psPMR,
 #define PMR_MAX_PDUMP_BUFSZ (1<<21)
 	IMG_CHAR aszParamStreamFilename[PDUMP_PARAM_MAX_FILE_NAME];
 	IMG_UINT8 *pcBuffer = NULL;
-	size_t uiBufSz;
+	size_t ui64BufSz;
 	IMG_BOOL bValid;
 	IMG_DEVMEM_SIZE_T uiSizeRemain = uiSize;
 	PVRSRV_DEVICE_NODE *psDevNode = PMR_DeviceNode(psPMR);
@@ -3049,16 +3372,16 @@ PMRPDumpLoadMem(PMR *psPMR,
 
 		/* get the zero page information. it is constant for this function */
 		PDumpGetParameterZeroPageInfo(&uiParamStreamFileOffset,
-		                              &uiBufSz,
+		                              &ui64BufSz,
 		                              &pszParamStreamFileName);
 	}
 	else
 	{
 
-		uiBufSz = 1 << PMR_GetLog2Contiguity(psPMR);
-		PVR_ASSERT((1 << PMR_GetLog2Contiguity(psPMR)) <= PMR_MAX_PDUMP_BUFSZ);
+		ui64BufSz = IMG_PAGE2BYTES64(PMR_GetLog2Contiguity(psPMR));
+		PVR_ASSERT(IMG_PAGE2BYTES64(PMR_GetLog2Contiguity(psPMR)) <= PMR_MAX_PDUMP_BUFSZ);
 
-		pcBuffer = OSAllocMem(uiBufSz);
+		pcBuffer = OSAllocMem(ui64BufSz);
 
 		PVR_LOG_RETURN_IF_NOMEM(pcBuffer, "OSAllocMem");
 
@@ -3082,7 +3405,7 @@ PMRPDumpLoadMem(PMR *psPMR,
 		                               &uiOutOffset,
 		                               &uiNextSymName);
 		PVR_ASSERT(eError == PVRSRV_OK);
-		PVR_ASSERT((uiNextSymName - uiCurrentOffset) <= uiBufSz);
+		PVR_ASSERT((uiNextSymName - uiCurrentOffset) <= ui64BufSz);
 
 		PMR_IsOffsetValid(psPMR,
 		                  0,
@@ -3503,7 +3826,7 @@ PDumpPMRMallocPMR(PMR *psPMR,
                   IMG_DEVMEM_SIZE_T uiSize,
                   IMG_UINT32 ui32ChunkSize,
                   IMG_UINT32 ui32NumPhysChunks,
-                  IMG_UINT32 ui32NumVirtChunks,
+                  IMG_UINT32 ui32NumLogicalChunks,
                   IMG_UINT32 *puiMappingTable,
                   IMG_UINT32 uiLog2Contiguity,
                   IMG_BOOL bInitialise,
@@ -3615,7 +3938,7 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 	IMG_DEVMEM_OFFSET_T uiNextSymName;
 #endif
 #if !defined(NO_HARDWARE)
-	IMG_UINT32 uiPageListPageSize = 1 << psPageListPMR->uiLog2ContiguityGuarantee;
+	PMR_SIZE_T ui64PageListPageSize = IMG_PAGE2BYTES64(psPageListPMR->uiLog2ContiguityGuarantee);
 	IMG_UINT64 uiPageListPMRPage = 0;
 	IMG_UINT64 uiPrevPageListPMRPage = 0;
 	IMG_HANDLE hPrivData = NULL;
@@ -3626,6 +3949,10 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 	IMG_DEV_PHYADDR *pasDevAddrPtr;
 	IMG_BOOL *pbPageIsValid;
 #endif
+	PVRSRV_DEVICE_NODE *psDevNode = PhysHeapDeviceNode(psPageListPMR->psPhysHeap);
+	IMG_BOOL bCPUCacheSnoop =
+		(PVRSRVSystemSnoopingOfCPUCache(psDevNode->psDevConfig) &&
+		 psDevNode->pfnGetDeviceSnoopMode(psDevNode) == PVRSRV_DEVICE_SNOOP_CPU_ONLY);
 
 	uiWordSize = PMR_PM_WORD_SIZE;
 
@@ -3664,6 +3991,21 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_INVALID_PMR_FLAGS, return_error);
 	}
 
+	/* the PMR into which we are writing must not be user CPU cacheable: */
+	if (!bCPUCacheSnoop &&
+		(PVRSRV_CHECK_CPU_CACHE_INCOHERENT(uiFlags) ||
+		 PVRSRV_CHECK_CPU_CACHE_COHERENT(uiFlags) ||
+		 PVRSRV_CHECK_CPU_CACHED(uiFlags)))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "Masked flags = 0x%" PVRSRV_MEMALLOCFLAGS_FMTSPEC,
+		         (PMR_FLAGS_T)(uiFlags &  PVRSRV_MEMALLOCFLAG_CPU_CACHE_MODE_MASK)));
+		PVR_DPF((PVR_DBG_ERROR,
+		         "Page list PMR allows CPU caching (0x%" PVRSRV_MEMALLOCFLAGS_FMTSPEC ")",
+		         uiFlags));
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_INVALID_PMR_FLAGS, return_error);
+	}
+
 	if (_PMRIsSparse(psPageListPMR))
 	{
 		PVR_LOG_GOTO_WITH_ERROR("psPageListPMR", eError, PVRSRV_ERROR_INVALID_PARAMS, return_error);
@@ -3691,13 +4033,7 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 		PVR_LOG_GOTO_IF_NOMEM(pasDevAddrPtr, eError, unlock_phys_addrs);
 
 		pbPageIsValid = OSAllocMem(uiNumPages * sizeof(IMG_BOOL));
-		if (pbPageIsValid == NULL)
-		{
-			/* Clean-up before exit */
-			OSFreeMem(pasDevAddrPtr);
-
-			PVR_LOG_GOTO_WITH_ERROR("pbPageIsValid", eError, PVRSRV_ERROR_OUT_OF_MEMORY, free_devaddr_array);
-		}
+		PVR_LOG_GOTO_IF_NOMEM(pbPageIsValid, eError, free_devaddr_array);
 	}
 	else
 	{
@@ -3726,7 +4062,7 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 		PVR_ASSERT(eError == PVRSRV_OK);
 
 		eError = PMR_PDumpSymbolicAddr(psReferencePMR,
-		                               (IMG_DEVMEM_OFFSET_T)uiPageIndex << uiLog2PageSize,
+		                               IMG_PAGES2BYTES64(uiPageIndex, uiLog2PageSize),
 		                               sizeof(aszPageMemspaceName),
 		                               &aszPageMemspaceName[0],
 		                               sizeof(aszPageSymbolicName),
@@ -3767,13 +4103,13 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 		 */
 		PVR_ASSERT(pbPageIsValid[uiPageIndex]);
 		PVR_ASSERT(pasDevAddrPtr[uiPageIndex].uiAddr != 0);
-		PVR_ASSERT(((pasDevAddrPtr[uiPageIndex].uiAddr >> uiLog2PageSize) & 0xFFFFFFFF00000000ll) == 0);
+		PVR_ASSERT(((pasDevAddrPtr[uiPageIndex].uiAddr >> uiLog2PageSize) & 0xFFFFFFFF00000000LL) == 0);
 
 		uiPageListPMRPage = uiPMROffset >> psReferencePMR->uiLog2ContiguityGuarantee;
 
 		if ((pui32DataPtr == NULL) || (uiPageListPMRPage != uiPrevPageListPMRPage))
 		{
-			size_t uiMappingOffset = uiPMROffset & (~(uiPageListPageSize - 1));
+			size_t uiMappingOffset = uiPMROffset & (~(ui64PageListPageSize - 1));
 			size_t uiMappedSize;
 
 			/* If we already had a page list mapped, we need to unmap it... */
@@ -3784,7 +4120,7 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 
 			eError = PMRAcquireKernelMappingData(psPageListPMR,
 			                                     uiMappingOffset,
-			                                     uiPageListPageSize,
+			                                     ui64PageListPageSize,
 			                                     &pvKernAddr,
 			                                     &uiMappedSize,
 			                                     &hPrivData);
@@ -3796,13 +4132,13 @@ PMRWritePMPageList(/* Target PMR, offset, and length */
 			}
 
 			uiPrevPageListPMRPage = uiPageListPMRPage;
-			PVR_ASSERT(uiMappedSize >= uiPageListPageSize);
+			PVR_ASSERT(uiMappedSize >= ui64PageListPageSize);
 			PVR_ASSERT(pvKernAddr != NULL);
 
-			pui32DataPtr = IMG_OFFSET_ADDR(pvKernAddr, (uiPMROffset & (uiPageListPageSize - 1)));
+			pui32DataPtr = IMG_OFFSET_ADDR(pvKernAddr, (uiPMROffset & (ui64PageListPageSize - 1)));
 		}
 
-		PVR_ASSERT(((pasDevAddrPtr[uiPageIndex].uiAddr >> uiLog2PageSize) & 0xFFFFFFFF00000000ll) == 0);
+		PVR_ASSERT(((pasDevAddrPtr[uiPageIndex].uiAddr >> uiLog2PageSize) & 0xFFFFFFFF00000000LL) == 0);
 
 		/* Write the physical page index into the page list PMR */
 		*pui32DataPtr++ = TRUNCATE_64BITS_TO_32BITS(pasDevAddrPtr[uiPageIndex].uiAddr >> uiLog2PageSize);
@@ -3873,7 +4209,7 @@ PMRZeroingPMR(PMR *psPMR,
 {
 	IMG_UINT32 uiNumPages;
 	IMG_UINT32 uiPageIndex;
-	IMG_UINT32 ui32PageSize = 1 << uiLog2PageSize;
+	PMR_SIZE_T ui64PageSize = IMG_PAGE2BYTES64(uiLog2PageSize);
 	IMG_HANDLE hPrivData = NULL;
 	void *pvKernAddr = NULL;
 	PVRSRV_ERROR eError = PVRSRV_OK;
@@ -3888,9 +4224,9 @@ PMRZeroingPMR(PMR *psPMR,
 	if ((PMR_SIZE_T)uiNumPages << uiLog2PageSize != psPMR->uiLogicalSize)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-		         "%s: PMR is not a multiple of %u",
+		         "%s: PMR is not a multiple of %" IMG_UINT64_FMTSPEC,
 		         __func__,
-		         ui32PageSize));
+		         ui64PageSize));
 		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_PMR_NOT_PAGE_MULTIPLE, MultiPage_Error);
 	}
 
@@ -3904,20 +4240,20 @@ PMRZeroingPMR(PMR *psPMR,
 	{
 		/* map the physical page (for a given PMR offset) into kernel space */
 		eError = PMRAcquireKernelMappingData(psPMR,
-		                                     (size_t)uiPageIndex << uiLog2PageSize,
-		                                     ui32PageSize,
+		                                     IMG_PAGES2BYTES64(uiPageIndex, uiLog2PageSize),
+		                                     ui64PageSize,
 		                                     &pvKernAddr,
 		                                     &uiMappedSize,
 		                                     &hPrivData);
 		PVR_LOG_GOTO_IF_ERROR(eError, "PMRAcquireKernelMappingData", AcquireKernelMapping_Error);
 
 		/* ensure the mapped page size is the same as the physical page size */
-		if (uiMappedSize != ui32PageSize)
+		if (uiMappedSize != ui64PageSize)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
-			         "%s: Physical Page size = 0x%08x, Size of Mapping = 0x%016" IMG_UINT64_FMTSPECx,
+			         "%s: Physical Page size = 0x%08" IMG_UINT64_FMTSPECx ", Size of Mapping = 0x%016" IMG_UINT64_FMTSPECx,
 			         __func__,
-			         ui32PageSize,
+			         ui64PageSize,
 			         (IMG_UINT64)uiMappedSize));
 			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, MappingSize_Error);
 		}
@@ -3925,7 +4261,7 @@ PMRZeroingPMR(PMR *psPMR,
 		/* Use the conservative 'DeviceMemSet' here because we can't know
 		 * if this PMR will be mapped cached.
 		 */
-		OSDeviceMemSet(pvKernAddr, 0, ui32PageSize);
+		OSDeviceMemSet(pvKernAddr, 0, ui64PageSize);
 
 		/* release mapping */
 		PMRReleaseKernelMappingData(psPMR, hPrivData);
@@ -3933,11 +4269,11 @@ PMRZeroingPMR(PMR *psPMR,
 	}
 
 	PVR_DPF((PVR_DBG_MESSAGE,
-	         "%s: Zeroing PMR %p done (num pages %u, page size %u)",
+	         "%s: Zeroing PMR %p done (num pages %u, page size %" IMG_UINT64_FMTSPEC ")",
 	         __func__,
 	         psPMR,
 	         uiNumPages,
-	         ui32PageSize));
+	         ui64PageSize));
 
 	return PVRSRV_OK;
 
@@ -3994,7 +4330,7 @@ PMRDumpPageList(PMR *psPMR,
 		eError = PMR_DevPhysAddr(psPMR,
 		                         uiLog2PageSize,
 		                         1,
-		                         (IMG_DEVMEM_OFFSET_T)uiPageIndex << uiLog2PageSize,
+		                         IMG_PAGES2BYTES64(uiPageIndex, uiLog2PageSize),
 		                         &sDevAddrPtr,
 		                         &bPageIsValid,
 		                         DEVICE_USE);
@@ -4031,6 +4367,8 @@ PMRDumpPageList(PMR *psPMR,
 	return eError;
 }
 
+DEFINE_PMR_ENV_GET_DATA(psPMR, sEnvData)
+
 PVRSRV_ERROR
 PMRInit(void)
 {
@@ -4146,11 +4484,37 @@ PMRFreeZombies(PPVRSRV_DEVICE_NODE psDeviceNode)
 
 	dllist_foreach_node(&sZombieList, psThis, psNext)
 	{
-		PMR *psPMR = IMG_CONTAINER_OF(psThis, PMR, sZombieNode);
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+		if (PMR_IsListNodeZombiePages(psThis))
+		{
+			PVRSRV_ERROR eError;
+			PMR_ZOMBIE_PAGES* psZombiePages = PMR_GetZombiePagesFromNode(psThis);
 
-		dllist_remove_node(&psPMR->sZombieNode);
+			eError = psZombiePages->pfnFactoryFreeZombies(psZombiePages->pvFactoryPages);
+			if (eError != PVRSRV_OK)
+			{
+				/* In case of failure to free zombie pages, remove it from
+				 * the sZombieList and add back to the original list. */
+				OSLockAcquire(psDeviceNode->hPMRZombieListLock);
+				dllist_remove_node(psThis);
+				dllist_add_to_tail(&psDeviceNode->sPMRZombieList, psThis);
+				psDeviceNode->uiPMRZombieCount++;
+				OSLockRelease(psDeviceNode->hPMRZombieListLock);
+
+				PVR_DPF((PVR_DBG_ERROR, "Cannot free zombie pages!"));
+				continue;
+			}
 
-		_PMRDestroy(psPMR);
+			dllist_remove_node(psThis);
+			OSFreeMem(psZombiePages);
+		}
+		else
+#endif
+		{
+			PMR *psPMR = PMR_GetPMRFromNode(psThis);
+			dllist_remove_node(psThis);
+			_PMRDestroy(psPMR);
+		}
 
 		uiZombieCount--;
 	}
@@ -4170,10 +4534,19 @@ PMRDumpZombies(PPVRSRV_DEVICE_NODE psDeviceNode)
 
 	dllist_foreach_node(&psDeviceNode->sPMRZombieList, psThis, psNext)
 	{
-		PMR *psPMR = IMG_CONTAINER_OF(psThis, PMR, sZombieNode);
-
-		PVR_DPF((PVR_DBG_ERROR, "PMR = %px, Flavour = %s, Annotation: %s",
-		        psPMR, PMR_GetTypeStr(psPMR), PMR_GetAnnotation(psPMR)));
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+		if (PMR_IsListNodeZombiePages(psThis))
+		{
+			PMR_ZOMBIE_PAGES* psZombiePages = PMR_GetZombiePagesFromNode(psThis);
+			PVR_DPF((PVR_DBG_ERROR, "Zombie Pages = %p", psZombiePages));
+		}
+		else
+#endif
+		{
+			PMR *psPMR = PMR_GetPMRFromNode(psThis);
+			PVR_DPF((PVR_DBG_ERROR, "PMR = %px, Flavour = %s, Annotation: %s",
+			        psPMR, PMR_GetTypeStr(psPMR), PMR_GetAnnotation(psPMR)));
+		}
 	}
 
 	OSLockRelease(psDeviceNode->hPMRZombieListLock);
diff --git a/drivers/gpu/drm/img-rogue/pmr.h b/drivers/gpu/drm/img-rogue/pmr.h
index 2a86e96c73d2..7cd3fb4d8929 100644
--- a/drivers/gpu/drm/img-rogue/pmr.h
+++ b/drivers/gpu/drm/img-rogue/pmr.h
@@ -75,7 +75,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define PMR_MAX_TRANSLATION_STACK_ALLOC				(32)
 
 /* Maximum size PMR can have is 8G of memory */
-#define PMR_MAX_SUPPORTED_SIZE (0x200000000ULL)
+#define PMR_MAX_SUPPORTED_SIZE IMG_UINT64_C(0x200000000)
 /* Max number of pages in a PMR at 4k page size */
 #define PMR_MAX_SUPPORTED_4K_PAGE_COUNT (PMR_MAX_SUPPORTED_SIZE >> 12ULL)
 
@@ -89,11 +89,11 @@ typedef IMG_UINT64 PMR_PASSWORD_T;
 
 struct _PMR_MAPPING_TABLE_
 {
-	PMR_SIZE_T	uiChunkSize;			/*!< Size of a "chunk" */
-	IMG_UINT32	ui32NumPhysChunks;		/*!< Number of physical chunks that are valid */
-	IMG_UINT32	ui32NumVirtChunks;		/*!< Number of virtual chunks in the mapping */
+	PMR_SIZE_T uiChunkSize;            /*!< Size of a "chunk" */
+	IMG_UINT32 ui32NumPhysChunks;      /*!< Number of physical chunks that are valid */
+	IMG_UINT32 ui32NumLogicalChunks;   /*!< Number of logical chunks in the mapping */
 	/* Must be last */
-	IMG_UINT32	aui32Translation[1];	/*!< Translation mapping for "logical" to physical */
+	IMG_UINT32 aui32Translation[IMG_FLEX_ARRAY_MEMBER];    /*!< Translation mapping for "logical" to physical */
 };
 
 #define TRANSLATION_INVALID 0xFFFFFFFFUL
@@ -192,7 +192,7 @@ PVRSRV_ERROR
 PMRCreatePMR(PHYS_HEAP *psPhysHeap,
              PMR_SIZE_T uiLogicalSize,
              IMG_UINT32 ui32NumPhysChunks,
-             IMG_UINT32 ui32NumVirtChunks,
+             IMG_UINT32 ui32NumLogicalChunks,
              IMG_UINT32 *pui32MappingTable,
              PMR_LOG2ALIGN_T uiLog2ContiguityGuarantee,
              PMR_FLAGS_T uiFlags,
@@ -502,19 +502,45 @@ PMRRefPMR2(PMR *psPMR);
 void
 PMRUnrefPMR2(PMR *psPMR);
 
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
 /*
- * PMRUnrefUnlockPMR()
+ * PMRTryRefPMR()
  *
- * Same as above but also unlocks the PMR.
+ * This attempts to take a reference on the PMR but only succeeds if
+ * the PMR is not at refcount 0. Other Ref functions would class this
+ * attempt as a logical error. This function is free to attempt and return
+ * an error if PMR is in a free in progress state.
  */
 PVRSRV_ERROR
-PMRUnrefUnlockPMR(PMR *psPMR);
+PMRTryRefPMR(PMR *psPMR);
+
+/*
+ * PMRGpuMapDevPageCountIncr()
+ *
+ * Increment count of the number of current device page GPU mappings of the PMR.
+ */
+void
+PMRGpuMapDevPageCountIncr(PMR *psPMR, IMG_UINT32 uiCount);
+
+/*
+ * PMRGpuMapDevPageCountDecr()
+ *
+ * Decrement count of the number of current device page GPU mappings of the PMR.
+ */
+void
+PMRGpuMapDevPageCountDecr(PMR *psPMR, IMG_UINT32 uiCount);
+
+IMG_BOOL
+PMR_IsGpuMapped(PMR *psPMR);
+#else
+#define PMRGpuMapDevPageCountIncr(...)
+#define PMRGpuMapDevPageCountDecr(...)
+#endif /* #if defined(SUPPORT_LINUX_OSPAGE_MIGRATION) */
 
 /*
  * PMRCpuMapCountIncr()
  *
  * Increment count of the number of current CPU mappings of the PMR.
- *
  */
 void
 PMRCpuMapCountIncr(PMR *psPMR);
@@ -523,11 +549,41 @@ PMRCpuMapCountIncr(PMR *psPMR);
  * PMRCpuMapCountDecr()
  *
  * Decrement count of the number of current CPU mappings of the PMR.
- *
  */
 void
 PMRCpuMapCountDecr(PMR *psPMR);
 
+IMG_BOOL
+PMR_IsCpuMapped(PMR *psPMR);
+
+/*
+ * PMRGpuResCountIncr()
+ *
+ * Increment count of the number of current GPU reservations associated with the PMR.
+ * Must be protected by PMR lock.
+ */
+void
+PMRGpuResCountIncr(PMR *psPMR);
+
+/*
+ * PMRGpuResCountDecr()
+ *
+ * Decrement count of the number of current GPU reservations associated with the PMR.
+ * Must be protected by PMR lock.
+ *
+ */
+void
+PMRGpuResCountDecr(PMR *psPMR);
+
+/*
+ * PMR_IsGpuMultiMapped()
+ *
+ * Must be protected by PMR lock.
+ *
+ */
+IMG_BOOL
+PMR_IsGpuMultiMapped(PMR *psPMR);
+
 PPVRSRV_DEVICE_NODE
 PMR_DeviceNode(const PMR *psPMR);
 
@@ -546,13 +602,21 @@ PMR_Flags(const PMR *psPMR);
 IMG_BOOL
 PMR_IsSparse(const PMR *psPMR);
 
-void
-PMR_LogicalSize(const PMR *psPMR,
-				IMG_DEVMEM_SIZE_T *puiLogicalSize);
+IMG_DEVMEM_SIZE_T
+PMR_PhysicalSize(const PMR *psPMR);
 
+/*
+ * PMR_IsOffsetValid()
+ *
+ * Returns if an address offset inside a PMR has a valid
+ * physical backing.
+ */
 PVRSRV_ERROR
-PMR_PhysicalSize(const PMR *psPMR,
-				 IMG_DEVMEM_SIZE_T *puiPhysicalSize);
+PMR_IsOffsetValid(const PMR *psPMR,
+				IMG_UINT32 ui32Log2PageSize,
+				IMG_UINT32 ui32NumOfPages,
+				IMG_DEVMEM_OFFSET_T uiLogicalOffset,
+				IMG_BOOL *pbValid);
 
 PHYS_HEAP *
 PMR_PhysHeap(const PMR *psPMR);
@@ -563,30 +627,20 @@ PMR_GetMappingTable(const PMR *psPMR);
 IMG_UINT32
 PMR_GetLog2Contiguity(const PMR *psPMR);
 
+IMG_DEVMEM_SIZE_T
+PMR_LogicalSize(const PMR *psPMR);
+
 /*
- * PMRGetMaxChunkCount
+ * PMR_GetLogicalChunkCount
  *
- * Given a PMR, calculate the maximum number of chunks supported by
- * the PMR from the contiguity and return it.
+ * Retrieve the maximum number of chunks supported by the PMR.
+ * This property is fixed at creation time.
  */
-IMG_UINT32 PMRGetMaxChunkCount(PMR *psPMR);
+IMG_UINT32 PMR_GetLogicalChunkCount(const PMR *psPMR);
 
 const IMG_CHAR *
 PMR_GetAnnotation(const PMR *psPMR);
 
-/*
- * PMR_IsOffsetValid()
- *
- * Returns if an address offset inside a PMR has a valid
- * physical backing.
- */
-PVRSRV_ERROR
-PMR_IsOffsetValid(const PMR *psPMR,
-				IMG_UINT32 ui32Log2PageSize,
-				IMG_UINT32 ui32NumOfPages,
-				IMG_DEVMEM_OFFSET_T uiLogicalOffset,
-				IMG_BOOL *pbValid);
-
 PMR_IMPL_TYPE
 PMR_GetType(const PMR *psPMR);
 
@@ -648,10 +702,17 @@ PMR_CpuPhysAddr(const PMR *psPMR,
                 IMG_CPU_PHYADDR *psCpuAddrPtr,
                 IMG_BOOL *pbValid);
 
+/* PMRGetUID()
+ *
+ * Used for bridge calls that expect a PVRSRV_ERROR returned
+ * */
 PVRSRV_ERROR
 PMRGetUID(PMR *psPMR,
           IMG_UINT64 *pui64UID);
 
+IMG_UINT64
+PMRInternalGetUID(PMR *psPMR);
+
 #if defined(SUPPORT_PMR_DEFERRED_FREE)
 /*
  * PMR_IsZombie()
@@ -692,35 +753,36 @@ PMRDequeueZombieAndRef(PMR *psPMR);
 #endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
 
 /*
- * PMR_ChangeSparseMem()
+ * PMR_ChangeSparseMemUnlocked()
  *
  * See note above about Lock/Unlock semantics.
  *
  * This function alters the memory map of the given PMR in device space by
- *  adding/deleting the pages as requested.
+ * adding/deleting the pages as requested. PMR lock must be taken
+ * before calling this function.
  *
  */
-PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
+PVRSRV_ERROR PMR_ChangeSparseMemUnlocked(PMR *psPMR,
                                  IMG_UINT32 ui32AllocPageCount,
                                  IMG_UINT32 *pai32AllocIndices,
                                  IMG_UINT32 ui32FreePageCount,
                                  IMG_UINT32 *pai32FreeIndices,
-                                 IMG_UINT32	uiSparseFlags);
-
+                                 IMG_UINT32 uiSparseFlags);
 /*
- * PMR_ChangeSparseMemCPUMap()
+ * PMR_ChangeSparseMem()
  *
  * See note above about Lock/Unlock semantics.
  *
- * This function alters the memory map of the given PMR in CPU space by
- * adding/deleting the pages as requested.
+ * This function alters the memory map of the given PMR in device space by
+ *  adding/deleting the pages as requested.
+ *
  */
-PVRSRV_ERROR PMR_ChangeSparseMemCPUMap(PMR *psPMR,
-                                       IMG_UINT64 sCpuVAddrBase,
-                                       IMG_UINT32 ui32AllocPageCount,
-                                       IMG_UINT32 *pai32AllocIndices,
-                                       IMG_UINT32 ui32FreePageCount,
-                                       IMG_UINT32 *pai32FreeIndices);
+PVRSRV_ERROR PMR_ChangeSparseMem(PMR *psPMR,
+                                 IMG_UINT32 ui32AllocPageCount,
+                                 IMG_UINT32 *pai32AllocIndices,
+                                 IMG_UINT32 ui32FreePageCount,
+                                 IMG_UINT32 *pai32FreeIndices,
+                                 IMG_UINT32	uiSparseFlags);
 
 #if defined(PDUMP)
 
@@ -1122,6 +1184,24 @@ PVRSRV_ERROR
 PMRStoreRIHandle(PMR *psPMR, void *hRIHandle);
 #endif
 
+/*
+ * PMRLockPMR()
+ *
+ * To be called when the PMR must not be modified by any other call-stack.
+ * Acquires the mutex on the passed in PMR.
+ */
+void
+PMRLockPMR(PMR *psPMR);
+
+/*
+ * PMRUnlockPMR()
+ *
+ * To be called when the PMR is no longer being modified.
+ * Releases the per-PMR mutex.
+ */
+void
+PMRUnlockPMR(PMR *psPMR);
+
 #if defined(PVRSRV_INTERNAL_IPA_FEATURE_TESTING)
 PVRSRV_ERROR
 PMRModifyIPAPolicy(PMR *psPMR, IMG_UINT8 ui8NewIPAPolicy);
diff --git a/drivers/gpu/drm/img-rogue/pmr_env.c b/drivers/gpu/drm/img-rogue/pmr_env.c
new file mode 100644
index 000000000000..e0c74b4b508d
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/pmr_env.c
@@ -0,0 +1,83 @@
+/*************************************************************************/ /*!
+@File
+@Title          Linux environment PMR functions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include <linux/string.h>
+
+#include "img_defs.h"
+
+#include "pmr_env.h"
+#include "physmem_dmabuf_internal.h"
+
+void
+PMREnvInitialize(PMR_ENV *psPMREnv)
+{
+	memset(psPMREnv, 0, sizeof(*psPMREnv));
+}
+
+void
+PMREnvFinalize(PMR_ENV *psPMREnv)
+{
+	void *pvDmaBufExportData;
+
+	pvDmaBufExportData = smp_load_acquire(&psPMREnv->pvDmaBufExportData);
+	if (pvDmaBufExportData)
+		PhysmemDmaBufExportFinalize(pvDmaBufExportData);
+}
+
+void
+PMREnvDmaBufSetExportData(PMR *psPMR, void *pvData)
+{
+	PMR_ENV *psPMREnv = PMREnvGetData(psPMR);
+
+	smp_store_release(&psPMREnv->pvDmaBufExportData, pvData);
+}
+
+void *
+PMREnvDmaBufGetExportData(PMR *psPMR)
+{
+	PMR_ENV *psPMREnv = PMREnvGetData(psPMR);
+	void *pvDmaBufExportData;
+
+	pvDmaBufExportData = smp_load_acquire(&psPMREnv->pvDmaBufExportData);
+
+	return pvDmaBufExportData;
+}
diff --git a/drivers/gpu/drm/img-rogue/pmr_env.h b/drivers/gpu/drm/img-rogue/pmr_env.h
new file mode 100644
index 000000000000..52a172e80b82
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/pmr_env.h
@@ -0,0 +1,90 @@
+/*************************************************************************/ /*!
+@File
+@Title          Environment PMR functions and data
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Environment specific PMR functions and data
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(PMR_ENV_H)
+#define PMR_ENV_H
+
+#include "pvrsrv_memallocflags.h"
+#include "powervr/mem_types.h"
+#include "pmr_impl.h"
+
+/* Structures, functions and definitions shared with the generic PMR code */
+struct _PMR_ENV_
+{
+	/*
+	 * The smp_store_release and smp_load_acquire functions are used
+	 * to access this field, in order to avoid taking locks, where
+	 * possible.
+	 */
+	void *pvDmaBufExportData;
+};
+
+typedef struct _PMR_ENV_ PMR_ENV;
+
+#define	DECLARE_PMR_ENV_DATA(name) PMR_ENV name;
+
+/* The generic PMR code calls these functions, via the macros that follow */
+void PMREnvInitialize(PMR_ENV *psPMREnv);
+void PMREnvFinalize(PMR_ENV *psPMREnv);
+
+#define	PMR_ENV_INITIALIZE(psPMR, sEnvData) PMREnvInitialize(&psPMR->sEnvData)
+#define	PMR_ENV_FINALIZE(psPMR, sEnvData) PMREnvFinalize(&psPMR->sEnvData)
+
+/* The generic PMR code provides this function, using the macro that follows */
+PMR_ENV *PMREnvGetData(PMR *psPMR);
+
+#define	DEFINE_PMR_ENV_GET_DATA(psPMR, sEnvData) \
+	PMR_ENV *PMREnvGetData(PMR *psPMR) { return &psPMR->sEnvData; }
+
+/*
+ * Structures, functions and definitions used by the environment specific
+ * PMR code.
+ */
+
+void
+PMREnvDmaBufSetExportData(PMR *psPMR, void *pvData);
+
+void *
+PMREnvDmaBufGetExportData(PMR *psPMR);
+
+#endif /* !defined(PMR_ENV_H) */
diff --git a/drivers/gpu/drm/img-rogue/pmr_impl.h b/drivers/gpu/drm/img-rogue/pmr_impl.h
index 68089ddc6fa8..3c290ca3a6e7 100644
--- a/drivers/gpu/drm/img-rogue/pmr_impl.h
+++ b/drivers/gpu/drm/img-rogue/pmr_impl.h
@@ -79,6 +79,10 @@ typedef struct _PMR_MAPPING_TABLE_ PMR_MAPPING_TABLE;
  */
 typedef void *PMR_MMAP_DATA;
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+typedef void *PMR_IMPL_ZOMBIEPAGES;
+#endif
+
 #define PMR_IMPL_TYPES \
 	X(NONE), \
 	X(OSMEM), \
@@ -135,13 +139,24 @@ typedef PVRSRV_ERROR (*PFN_LOCK_PHYS_ADDRESSES_FN)(PMR_IMPL_PRIVDATA pvPriv);
 
 @Input          pvPriv                Private data (which was generated by the
                                       PMR factory when PMR was created)
+@Output         ppvZombiePages        Zombie pages object. If non-null is returned
+                                      caller is obligated to call pfnFreeZombiePages
+                                      at an appropriate time to prevent memory leaks.
+                                      If support for deferred freeing of pages is not
+                                      provided, the implementation must set
+                                      *ppvZombiePages to NULL.
 
 @Return         PVRSRV_OK if the operation was successful, an error code
                 otherwise.
 */ /**************************************************************************/
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+typedef PVRSRV_ERROR (*PFN_UNLOCK_PHYS_ADDRESSES_FN)(PMR_IMPL_PRIVDATA pvPriv,
+                                                     PMR_IMPL_ZOMBIEPAGES *ppvZombiePages);
+#else
 typedef PVRSRV_ERROR (*PFN_UNLOCK_PHYS_ADDRESSES_FN)(PMR_IMPL_PRIVDATA pvPriv);
+#endif
 
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
 /*************************************************************************/ /*!
 @Brief          Callback function type PFN_DEV_PHYS_ADDR_FN
 
@@ -219,7 +234,7 @@ typedef PVRSRV_ERROR (*PFN_DEV_PHYS_ADDR_FN)(PMR_IMPL_PRIVDATA pvPriv,
                       IMG_UINT32 ui32Log2PageSize,
                       IMG_UINT32 ui32NumOfAddr,
                       IMG_DEVMEM_OFFSET_T *puiOffset,
-#if defined(PVRSRV_SUPPORT_IPA_FEATURE)
+#if defined(SUPPORT_STATIC_IPA)
                       IMG_UINT64 ui64IPAPolicyValue,
                       IMG_UINT64 ui64IPAClearMask,
 #endif
@@ -365,6 +380,9 @@ typedef PVRSRV_ERROR (*PFN_WRITE_BYTES_FN)(PMR_IMPL_PRIVDATA pvPriv,
                                       allocation that do not require
                                       a physical allocation.
 @Input          ui32Flags             Allocation flags
+@Output         ppvZombiePages        Zombie pages object. If non-null is returned
+                                      caller is obligated to call pfnFreeZombiePages
+                                      at an appropriate time to prevent memory leaks
 
 @Return         PVRSRV_OK if the sparse allocation physical backing was updated
                 successfully, an error code otherwise.
@@ -375,6 +393,9 @@ typedef PVRSRV_ERROR (*PFN_CHANGE_SPARSE_MEM_FN)(PMR_IMPL_PRIVDATA pPriv,
                       IMG_UINT32 *pai32AllocIndices,
                       IMG_UINT32 ui32FreePageCount,
                       IMG_UINT32 *pai32FreeIndices,
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+                      PMR_IMPL_ZOMBIEPAGES *ppvZombiePages,
+#endif
                       IMG_UINT32 uiFlags);
 
 /*************************************************************************/ /*!
@@ -507,6 +528,29 @@ typedef PVRSRV_ERROR (*PFN_ZOMBIFY_FN)(PMR_IMPL_PRIVDATA pvPriv,
                                        PMR *psPMR);
 #endif
 
+#ifdef SUPPORT_PMR_PAGES_DEFERRED_FREE
+/*************************************************************************/ /*!
+@Brief          Callback function type PFN_FREE_ZOMBIE_PAGES_FN
+
+@Description    Called to perform factory actions to free zombie pages object
+                previously returned by PFN_CHANGE_SPARSE_MEM_FN.
+
+                This function should free the pages described in the
+                pvZombiePages parameter and do any associated actions related
+                to freeing such as poisoning or returning to the page pool.
+
+                Implementation of this callback is required when
+                SUPPORT_PMR_PAGES_DEFERRED_FREE=1.
+
+@Return         PVRSRV_OK if the operation was successful, an error code
+                otherwise. If error is returned, the PMR layer might retry.
+                On error, factory implementations should modify the contents
+                of the PMR_IMPL_ZOMBIEPAGES object reflecting any changes in
+                underlying memory as a result of the initial (failed) call.
+*/ /**************************************************************************/
+typedef PVRSRV_ERROR (*PFN_FREE_ZOMBIE_PAGES_FN)(PMR_IMPL_ZOMBIEPAGES pvZombiePages);
+#endif
+
 /*! PMR factory callback table.
  */
 struct _PMR_IMPL_FUNCTAB_ {
@@ -530,8 +574,11 @@ struct _PMR_IMPL_FUNCTAB_ {
 
     /*! Callback function pointer, see ::PFN_CHANGE_SPARSE_MEM_FN */
     PFN_CHANGE_SPARSE_MEM_FN pfnChangeSparseMem;
-    /*! Callback function pointer, see ::PFN_CHANGE_SPARSE_MEM_CPU_MAP_FN */
-    PFN_CHANGE_SPARSE_MEM_CPU_MAP_FN pfnChangeSparseMemCPUMap;
+
+#ifdef SUPPORT_PMR_PAGES_DEFERRED_FREE
+    /*! Callback function pointer, see ::PFN_FREE_ZOMBIE_PAGES_FN */
+    PFN_FREE_ZOMBIE_PAGES_FN pfnFreeZombiePages;
+#endif
 
     /*! Callback function pointer, see ::PFN_MMAP_FN */
     PFN_MMAP_FN pfnMMap;
diff --git a/drivers/gpu/drm/img-rogue/pmr_os.c b/drivers/gpu/drm/img-rogue/pmr_os.c
index 5e82e9ce785d..5802364a23a7 100644
--- a/drivers/gpu/drm/img-rogue/pmr_os.c
+++ b/drivers/gpu/drm/img-rogue/pmr_os.c
@@ -45,10 +45,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 #include <linux/version.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 #include <linux/pfn_t.h>
 #include <linux/pfn.h>
-#endif
 
 #include "img_defs.h"
 #include "pvr_debug.h"
@@ -94,8 +92,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 static void MMapPMROpen(struct vm_area_struct *ps_vma)
 {
 	PMR *psPMR = ps_vma->vm_private_data;
+	PVRSRV_ERROR eError;
 
-	/* Our VM flags should ensure this function never gets called */
+	/* VM_DONTCOPY should ensure this function never gets called */
 	PVR_DPF((PVR_DBG_WARNING,
 			 "%s: Unexpected mmap open call, this is probably an application bug.",
 			 __func__));
@@ -107,13 +106,15 @@ static void MMapPMROpen(struct vm_area_struct *ps_vma)
 			 ps_vma->vm_end - ps_vma->vm_start,
 			 psPMR));
 
-	/* In case we get called anyway let's do things right by increasing the refcount and
-	 * locking down the physical addresses. */
+	/* Should this entry-point be called for one of our PMRs we must increase
+	 * the refcount and lock down the physical addresses.
+	 */
 	PMRRefPMR(psPMR);
 
-	if (PMRLockSysPhysAddresses(psPMR) != PVRSRV_OK)
+	eError = PMRLockSysPhysAddresses(psPMR);
+	if (unlikely(eError != PVRSRV_OK))
 	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Could not lock down physical addresses, aborting.", __func__));
+		PVR_LOG_ERROR(eError, "PMRLockSysPhysAddresses");
 		PMRUnrefPMR(psPMR);
 	}
 	else
@@ -219,18 +220,9 @@ static INLINE int _OSMMapPMR(PVRSRV_DEVICE_NODE *psDevNode,
 							IMG_BOOL bUseMixedMap)
 {
 	IMG_INT32 iStatus;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 	pfn_t sPFN;
-#else
-	unsigned long uiPFN;
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 	sPFN = phys_to_pfn_t(psCpuPAddr->uiAddr, 0);
-#else
-	uiPFN = psCpuPAddr->uiAddr >> PAGE_SHIFT;
-	PVR_ASSERT(((IMG_UINT64)uiPFN << PAGE_SHIFT) == psCpuPAddr->uiAddr);
-#endif
 
 	/*
 	 * vm_insert_page() allows insertion of individual pages into user
@@ -261,11 +253,7 @@ static INLINE int _OSMMapPMR(PVRSRV_DEVICE_NODE *psDevNode,
 #else
 			iStatus = vm_insert_mixed(ps_vma,
 									  ps_vma->vm_start + uiOffset,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 									  sPFN);
-#else
-									  uiPFN);
-#endif
 #endif
 		}
 		else
@@ -273,11 +261,7 @@ static INLINE int _OSMMapPMR(PVRSRV_DEVICE_NODE *psDevNode,
 			/* Since kernel 3.7 this sets VM_MIXEDMAP internally */
 			iStatus = vm_insert_page(ps_vma,
 									 ps_vma->vm_start + uiOffset,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 									 pfn_t_to_page(sPFN));
-#else
-									 pfn_to_page(uiPFN));
-#endif
 		}
 	}
 	else
@@ -322,11 +306,7 @@ static INLINE int _OSMMapPMR(PVRSRV_DEVICE_NODE *psDevNode,
 
 		iStatus = remap_pfn_range(ps_vma,
 								  ps_vma->vm_start + uiOffset,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 								  pfn_t_to_pfn(sPFN),
-#else
-								  uiPFN,
-#endif
 								  uiNumContiguousBytes,
 								  ps_vma->vm_page_prot);
 	}
@@ -360,20 +340,52 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 	PVR_RETURN_IF_INVALID_PARAM(((uVMFlags & VM_WRITE) == 0) ||
 	                            ((uVMFlags & VM_SHARED) != 0));
 
+	uiLength = ps_vma->vm_end - ps_vma->vm_start;
+
+	/* Check early if the requested mapping size doesn't exceed the virtual
+	 * PMR size. */
+	if (PMR_LogicalSize(psPMR) < uiLength)
+	{
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_BAD_MAPPING, ErrReturn);
+	}
+
+	uiLog2PageSize = PMR_GetLog2Contiguity(psPMR);
+
+	/* Check the number of PFNs to be mapped is valid. */
+	uiNumOfPFNs = uiLength >> uiLog2PageSize;
+	if (uiNumOfPFNs == 0)
+	{
+		/* print as 64-bit value to avoid Smatch warning */
+		PVR_LOG_VA(PVR_DBG_ERROR,
+		           "uiLength is invalid. Must be >= %" IMG_UINT64_FMTSPEC ".",
+		           IMG_UINT64_C(1) << uiLog2PageSize);
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_BAD_MAPPING, ErrReturn);
+	}
+
+	/*
+	 * Take a reference on the PMR so that it can't be freed while mapped
+	 * into the user process.
+	 */
+	PMRRefPMR(psPMR);
+
 	eError = PMRLockSysPhysAddresses(psPMR);
 	if (eError != PVRSRV_OK)
 	{
-		goto e0;
+		goto ErrUnrefPMR;
 	}
 
+	/* Increment mapping count of the PMR so that its layout cannot be
+	 * changed (if sparse).
+	 */
+	PMRLockPMR(psPMR);
+
+	PMRCpuMapCountIncr(psPMR);
 	sPageProt = vm_get_page_prot(uVMFlags);
 
-	eError = DevmemCPUCacheMode(psDevNode,
-	                            PMR_Flags(psPMR),
-	                            &ui32CPUCacheFlags);
+	eError = DevmemCPUCacheMode(PMR_Flags(psPMR), &ui32CPUCacheFlags);
 	if (eError != PVRSRV_OK)
 	{
-		goto e0;
+		goto ErrUnlockPhysAddr;
 	}
 
 	switch (ui32CPUCacheFlags)
@@ -400,7 +412,7 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 
 		default:
 				eError = PVRSRV_ERROR_INVALID_PARAMS;
-				goto e1;
+				goto ErrUnlockPhysAddr;
 	}
 	ps_vma->vm_page_prot = sPageProt;
 
@@ -418,35 +430,21 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 	/* Don't allow mapping to be inherited across a process fork */
 	uVMFlags |= VM_DONTCOPY;
 
-	uiLength = ps_vma->vm_end - ps_vma->vm_start;
-
+#if defined(PMR_OS_USE_VM_INSERT_PAGE)
 	/* Is this mmap targeting non order-zero pages or does it use pfn mappings?
 	 * If yes, don't use vm_insert_page */
-	uiLog2PageSize = PMR_GetLog2Contiguity(psPMR);
-
-#if defined(PMR_OS_USE_VM_INSERT_PAGE)
 	bUseVMInsertPage = (uiLog2PageSize == PAGE_SHIFT) && (PMR_GetType(psPMR) != PMR_TYPE_EXTMEM);
 #endif
 
 	/* Can we use stack allocations */
-	uiNumOfPFNs = uiLength >> uiLog2PageSize;
 	if (uiNumOfPFNs > PMR_MAX_TRANSLATION_STACK_ALLOC)
 	{
 		psCpuPAddr = OSAllocMem(uiNumOfPFNs * sizeof(*psCpuPAddr));
-		if (psCpuPAddr == NULL)
-		{
-			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-			goto e1;
-		}
+		PVR_LOG_GOTO_IF_NOMEM(psCpuPAddr, eError, ErrUnlockPhysAddr);
 
 		/* Should allocation fail, clean-up here before exiting */
 		pbValid = OSAllocMem(uiNumOfPFNs * sizeof(*pbValid));
-		if (pbValid == NULL)
-		{
-			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-			OSFreeMem(psCpuPAddr);
-			goto e2;
-		}
+		PVR_LOG_GOTO_IF_NOMEM(pbValid, eError, ErrFreeCpuPAddr);
 	}
 	else
 	{
@@ -463,7 +461,7 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 				 pbValid);
 	if (eError != PVRSRV_OK)
 	{
-		goto e3;
+		goto ErrFreeValid;
 	}
 
 	/*
@@ -474,26 +472,15 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 	 */
 	if (bUseVMInsertPage)
 	{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 		pfn_t sPFN;
-#else
-		unsigned long uiPFN;
-#endif
 
 		for (uiOffsetIdx = 0; uiOffsetIdx < uiNumOfPFNs; ++uiOffsetIdx)
 		{
 			if (pbValid[uiOffsetIdx])
 			{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0))
 				sPFN = phys_to_pfn_t(psCpuPAddr[uiOffsetIdx].uiAddr, 0);
 
 				if (!pfn_t_valid(sPFN) || page_count(pfn_t_to_page(sPFN)) == 0)
-#else
-				uiPFN = psCpuPAddr[uiOffsetIdx].uiAddr >> PAGE_SHIFT;
-				PVR_ASSERT(((IMG_UINT64)uiPFN << PAGE_SHIFT) == psCpuPAddr[uiOffsetIdx].uiAddr);
-
-				if (!pfn_valid(uiPFN) || page_count(pfn_to_page(uiPFN)) == 0)
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)) */
 				{
 					bUseMixedMap = IMG_TRUE;
 					break;
@@ -537,7 +524,7 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 				/* Failure error code doesn't get propagated */
 				eError = PVRSRV_ERROR_PMR_CPU_PAGE_MAP_FAILED;
 				PVR_ASSERT(0);
-				goto e3;
+				goto ErrFreeValid;
 			}
 		}
 #if defined(PVRSRV_ENABLE_PROCESS_STATS) && defined(PVRSRV_ENABLE_MEMORY_STATS)
@@ -575,37 +562,31 @@ OSMMapPMRGeneric(PMR *psPMR, PMR_MMAP_DATA pOSMMapData)
 	/* Install open and close handlers for ref-counting */
 	ps_vma->vm_ops = &gsMMapOps;
 
-	/*
-	 * Take a reference on the PMR so that it can't be freed while mapped
-	 * into the user process.
-	 */
-	PMRRefPMR(psPMR);
-
 #if defined(PVRSRV_ENABLE_LINUX_MMAP_STATS)
 	/* record the stats */
 	MMapStatsAddOrUpdatePMR(psPMR, uiLength);
 #endif
 
-	/* Increment mapping count of the PMR so that its layout cannot be
-	 * changed (if sparse).
-	 */
-	PMRCpuMapCountIncr(psPMR);
-
+	PMRUnlockPMR(psPMR);
 	return PVRSRV_OK;
 
 	/* Error exit paths follow */
-e3:
+ErrFreeValid:
 	if (pbValid != abValid)
 	{
 		OSFreeMem(pbValid);
 	}
-e2:
+ErrFreeCpuPAddr:
 	if (psCpuPAddr != asCpuPAddr)
 	{
 		OSFreeMem(psCpuPAddr);
 	}
-e1:
+ErrUnlockPhysAddr:
+	PMRCpuMapCountDecr(psPMR);
+	PMRUnlockPMR(psPMR);
 	PMRUnlockSysPhysAddresses(psPMR);
-e0:
+ErrUnrefPMR:
+	PMRUnrefPMR(psPMR);
+ErrReturn:
 	return eError;
 }
diff --git a/drivers/gpu/drm/img-rogue/power.c b/drivers/gpu/drm/img-rogue/power.c
index 7d2d4627aab4..dfd8abac72a3 100644
--- a/drivers/gpu/drm/img-rogue/power.c
+++ b/drivers/gpu/drm/img-rogue/power.c
@@ -40,6 +40,9 @@ COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ /**************************************************************************/
+#if !defined(__linux__)
+#include <errno.h>
+#endif /* #if !defined(__linux__) */
 
 #include "pdump_km.h"
 #include "allocmem.h"
@@ -47,10 +50,15 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "lock.h"
 #include "pvrsrv.h"
+#include "power.h"
 #include "pvr_debug.h"
 #include "htbserver.h"
 #include "di_server.h"
 
+#define OS_POWERLOCK_TIMEOUT_MS		(5000UL)
+#define OS_POWERLOCK_TIMEOUT_US		(OS_POWERLOCK_TIMEOUT_MS * 1000UL)
+#define OS_POWERLOCK_RETRY_COUNT	(50)
+
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 typedef struct _EXTRA_POWER_STATS_
 {
@@ -90,7 +98,7 @@ struct _PVRSRV_POWER_DEV_TAG_
 	PFN_FORCED_IDLE_CANCEL_REQUEST	pfnForcedIdleCancelRequest;
 	PFN_GPU_UNITS_POWER_CHANGE		pfnGPUUnitsPowerChange;
 	IMG_HANDLE						hSysData;
-	IMG_HANDLE						hDevCookie;
+	IMG_HANDLE						psDevNode;
 	PVRSRV_DEV_POWER_STATE			eDefaultPowerState;
 	ATOMIC_T						eCurrentPowerState;
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
@@ -286,7 +294,7 @@ int PVRSRVPowerStatsPrintElements(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 		 ui32Idx != psPowerStats->ui32ClockSpeedIndexEnd;
 		 ui32Idx = (ui32Idx + 1) % NUM_EXTRA_POWER_STATS)
 	{
-		DIPrintf(psEntry, "%12llu\t%11llu\t%9llu\n",
+		DIPrintf(psEntry, "%12" IMG_UINT64_FMTSPEC "\t%11" IMG_UINT64_FMTSPEC "\t%9" IMG_UINT64_FMTSPEC "\n",
 				 psPowerStats->asClockSpeedChanges[ui32Idx].ui64PreClockSpeedChangeDuration,
 				 psPowerStats->asClockSpeedChanges[ui32Idx].ui64BetweenPreEndingAndPostStartingDuration,
 				 psPowerStats->asClockSpeedChanges[ui32Idx].ui64PostClockSpeedChangeDuration);
@@ -363,7 +371,12 @@ const char *PVRSRVDevPowerStateToString(PVRSRV_DEV_POWER_STATE eState)
   device powerlock after releasing it temporarily for some timeout period
   in function PVRSRVDeviceIdleRequestKM
  */
+#if defined(DEBUG)
+typedef PVRSRV_ERROR (*PFN_POWER_LOCK_ACQUIRE) (PPVRSRV_DEVICE_NODE psDevNode,
+                                                const char *pszFile, const unsigned int ui32LineNum);
+#else
 typedef PVRSRV_ERROR (*PFN_POWER_LOCK_ACQUIRE) (PPVRSRV_DEVICE_NODE psDevNode);
+#endif
 
 static inline IMG_UINT64 PVRSRVProcessStatsGetTimeNs(void)
 {
@@ -426,43 +439,74 @@ IMG_BOOL PVRSRVPwrLockIsLockedByMe(PCPVRSRV_DEVICE_NODE psDeviceNode)
 	       OSGetCurrentClientProcessIDKM() == psDeviceNode->uiPwrLockOwnerPID;
 }
 
+
+#if defined(DEBUG)
+static void _PVRSRVPowerLockOwner(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                  const char *pszFile, const unsigned int ui32LineNum)
+{
+	psDeviceNode->sPowerLockOwner.pszFile = pszFile;
+	psDeviceNode->sPowerLockOwner.ui32LineNum = ui32LineNum;
+	psDeviceNode->sPowerLockOwner.ui64Timestamp = OSClockus64();
+}
+#endif
+
+#if defined(DEBUG)
+PVRSRV_ERROR PVRSRVPowerLock_Debug(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                   const char *pszFile, const unsigned int ui32LineNum)
+#else
 PVRSRV_ERROR PVRSRVPowerLock(PPVRSRV_DEVICE_NODE psDeviceNode)
+#endif
 {
 	OSLockAcquire(psDeviceNode->hPowerLock);
+	psDeviceNode->uiPwrLockOwnerPID = OSGetCurrentClientProcessIDKM();
+#if defined(DEBUG)
+	_PVRSRVPowerLockOwner(psDeviceNode, pszFile, ui32LineNum);
+#endif
 
-	/* Only allow to take powerlock when the system power is on */
-	if (_IsSystemStatePowered(psDeviceNode->eCurrentSysPowerState))
-	{
-		psDeviceNode->uiPwrLockOwnerPID = OSGetCurrentClientProcessIDKM();
-		return PVRSRV_OK;
-	}
-
-	OSLockRelease(psDeviceNode->hPowerLock);
-
-	return PVRSRV_ERROR_SYSTEM_STATE_POWERED_OFF;
+	return PVRSRV_OK;
 }
 
+#if defined(DEBUG)
+PVRSRV_ERROR PVRSRVPowerTryLock_Debug(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                      const char *pszFile, const unsigned int ui32LineNum)
+#else
 PVRSRV_ERROR PVRSRVPowerTryLock(PPVRSRV_DEVICE_NODE psDeviceNode)
+#endif
 {
 	if (!(OSTryLockAcquire(psDeviceNode->hPowerLock)))
 	{
 		return PVRSRV_ERROR_RETRY;
 	}
 
-	/* Only allow to take powerlock when the system power is on */
-	if (_IsSystemStatePowered(psDeviceNode->eCurrentSysPowerState))
+	psDeviceNode->uiPwrLockOwnerPID = OSGetCurrentClientProcessIDKM();
+#if defined(DEBUG)
+	_PVRSRVPowerLockOwner(psDeviceNode, pszFile, ui32LineNum);
+#endif
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PVRSRVPowerTryLockWaitForTimeout(PPVRSRV_DEVICE_NODE psDeviceNode)
+{
+	PVRSRV_ERROR eError;
+
+	/* Take power lock, retry if it's in use in another task. */
+	LOOP_UNTIL_TIMEOUT_US(OS_POWERLOCK_TIMEOUT_US)
 	{
-		psDeviceNode->uiPwrLockOwnerPID = OSGetCurrentClientProcessIDKM();
+		eError = PVRSRVPowerTryLock(psDeviceNode);
+		if (eError != PVRSRV_ERROR_RETRY)
+		{
+			return eError;
+		}
 
-		/* System is powered ON, return OK */
-		return PVRSRV_OK;
-	}
-	else
+		OSSleepms(OS_POWERLOCK_TIMEOUT_MS / OS_POWERLOCK_RETRY_COUNT);
+	} END_LOOP_UNTIL_TIMEOUT_US();
+
+	if (eError == PVRSRV_ERROR_RETRY)
 	{
-		/* System is powered OFF, release the lock and return error */
-		OSLockRelease(psDeviceNode->hPowerLock);
-		return PVRSRV_ERROR_SYSTEM_STATE_POWERED_OFF;
+		return PVRSRV_ERROR_TIMEOUT;
 	}
+	return eError;
 }
 
 /*!
@@ -477,6 +521,20 @@ PVRSRV_ERROR PVRSRVPowerTryLock(PPVRSRV_DEVICE_NODE psDeviceNode)
                PFN_POWER_LOCK_ACQUIRE
 
 ******************************************************************************/
+#if defined(DEBUG)
+#define _PVRSRVForcedPowerLock(DEV_NODE)	\
+	_PVRSRVForcedPowerLock_Debug(DEV_NODE, __FILE__, __LINE__)
+
+static PVRSRV_ERROR _PVRSRVForcedPowerLock_Debug(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                                 const char *pszFile, const unsigned int ui32LineNum)
+{
+	OSLockAcquire(psDeviceNode->hPowerLock);
+	psDeviceNode->uiPwrLockOwnerPID = OSGetCurrentClientProcessIDKM();
+	_PVRSRVPowerLockOwner(psDeviceNode, pszFile, ui32LineNum);
+
+	return PVRSRV_OK;
+}
+#else
 static PVRSRV_ERROR _PVRSRVForcedPowerLock(PPVRSRV_DEVICE_NODE psDeviceNode)
 {
 	OSLockAcquire(psDeviceNode->hPowerLock);
@@ -484,6 +542,7 @@ static PVRSRV_ERROR _PVRSRVForcedPowerLock(PPVRSRV_DEVICE_NODE psDeviceNode)
 
 	return PVRSRV_OK;
 }
+#endif
 
 void PVRSRVPowerUnlock(PPVRSRV_DEVICE_NODE psDeviceNode)
 {
@@ -534,7 +593,7 @@ PVRSRV_ERROR PVRSRVSetDeviceCurrentPowerState(PVRSRV_POWER_DEV *psPowerDevice,
 	eOldPowerState = OSAtomicExchange(&psPowerDevice->eCurrentPowerState,
 	                                  eNewPowerState);
 
-	psDeviceNode = psPowerDevice->hDevCookie;
+	psDeviceNode = psPowerDevice->psDevNode;
 	PVR_ASSERT(psDeviceNode);
 
 	if (eNewPowerState == PVRSRV_DEV_POWER_STATE_OFF &&
@@ -569,9 +628,9 @@ static PVRSRV_ERROR _PVRSRVDeviceIdleRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode,
 	if ((psPowerDev && psPowerDev->pfnForcedIdleRequest) &&
 	    (pfnIsDefaultStateOff == NULL || pfnIsDefaultStateOff(psPowerDev)))
 	{
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
-			eError = psPowerDev->pfnForcedIdleRequest(psPowerDev->hDevCookie,
+			eError = psPowerDev->pfnForcedIdleRequest(psPowerDev->psDevNode,
 			                                          bDeviceOffPermitted);
 			if (eError == PVRSRV_ERROR_DEVICE_IDLE_REQUEST_DENIED)
 			{
@@ -581,7 +640,11 @@ static PVRSRV_ERROR _PVRSRVDeviceIdleRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode,
 
 				OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 
+#if defined(DEBUG)
+				eErrPwrLockAcq = pfnPowerLockAcquire(psDeviceNode, __FILE__, __LINE__);
+#else
 				eErrPwrLockAcq = pfnPowerLockAcquire(psDeviceNode);
+#endif
 				if (eErrPwrLockAcq != PVRSRV_OK)
 				{
 					/* We only understand PVRSRV_ERROR_RETRY, so assert on others.
@@ -602,7 +665,7 @@ static PVRSRV_ERROR _PVRSRVDeviceIdleRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode,
 				/* idle request successful or some other error occurred, return */
 				break;
 			}
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 	}
 	else
 	{
@@ -623,7 +686,12 @@ inline PVRSRV_ERROR PVRSRVDeviceIdleRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode,
 	return _PVRSRVDeviceIdleRequestKM(psDeviceNode,
 	                                  pfnIsDefaultStateOff,
 	                                  bDeviceOffPermitted,
-	                                  PVRSRVPowerLock);
+#if defined(DEBUG)
+	                                  PVRSRVPowerLock_Debug
+#else
+	                                  PVRSRVPowerLock
+#endif
+	                                  );
 }
 
 PVRSRV_ERROR PVRSRVDeviceIdleCancelRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode)
@@ -632,7 +700,7 @@ PVRSRV_ERROR PVRSRVDeviceIdleCancelRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode)
 
 	if (psPowerDev && psPowerDev->pfnForcedIdleCancelRequest)
 	{
-		return psPowerDev->pfnForcedIdleCancelRequest(psPowerDev->hDevCookie);
+		return psPowerDev->pfnForcedIdleCancelRequest(psPowerDev->psDevNode);
 	}
 
 	return PVRSRV_OK;
@@ -641,11 +709,12 @@ PVRSRV_ERROR PVRSRVDeviceIdleCancelRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode)
 /*!
 ******************************************************************************
 
- @Function	PVRSRVDevicePrePowerStateKM
+ @Function	PVRSRVDeviceSystemPrePowerStateKM
 
  @Description
 
- Perform device-specific processing required before a power transition
+ Perform device and system-specific processing required before a power
+ transition
 
  @Input		psPowerDevice : Power device
  @Input		eNewPowerState : New power state
@@ -655,9 +724,9 @@ PVRSRV_ERROR PVRSRVDeviceIdleCancelRequestKM(PPVRSRV_DEVICE_NODE psDeviceNode)
 
 ******************************************************************************/
 static
-PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
-										 PVRSRV_DEV_POWER_STATE	eNewPowerState,
-										 PVRSRV_POWER_FLAGS		ePwrFlags)
+PVRSRV_ERROR PVRSRVDeviceSystemPrePowerStateKM(PVRSRV_POWER_DEV			*psPowerDevice,
+											   PVRSRV_DEV_POWER_STATE	eNewPowerState,
+											   PVRSRV_POWER_FLAGS		ePwrFlags)
 {
 	PVRSRV_DEV_POWER_STATE eCurrentPowerState;
 	IMG_UINT64 ui64SysTimer1 = 0;
@@ -675,7 +744,7 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
 		ui64DevTimer1 = PVRSRVProcessStatsGetTimeNs();
 
 		/* Call the device's power callback. */
-		eError = psPowerDevice->pfnDevicePrePower(psPowerDevice->hDevCookie,
+		eError = psPowerDevice->pfnDevicePrePower(psPowerDevice->psDevNode,
 												  eNewPowerState,
 												  eCurrentPowerState,
 												  ePwrFlags);
@@ -723,7 +792,7 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
 		if (psPowerDevice->pfnDevicePrePower != NULL)
 		{
 			/* Call the device's power callback. */
-			eError2 = psPowerDevice->pfnDevicePrePower(psPowerDevice->hDevCookie,
+			eError2 = psPowerDevice->pfnDevicePrePower(psPowerDevice->psDevNode,
 			                                           eCurrentPowerState,
 			                                           eNewPowerState,
 			                                           ePwrFlags);
@@ -732,7 +801,7 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
 		if (eError2 == PVRSRV_OK && psPowerDevice->pfnDevicePostPower != NULL)
 		{
 			/* Call the device's power callback. */
-			eError2 = psPowerDevice->pfnDevicePostPower(psPowerDevice->hDevCookie,
+			eError2 = psPowerDevice->pfnDevicePostPower(psPowerDevice->psDevNode,
 			                                            eCurrentPowerState,
 			                                            eNewPowerState,
 			                                            ePwrFlags);
@@ -746,11 +815,12 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
 /*!
 ******************************************************************************
 
- @Function	PVRSRVDevicePostPowerStateKM
+ @Function	PVRSRVDeviceSystemPostPowerStateKM
 
  @Description
 
- Perform device-specific processing required after a power transition
+ Perform device and system-specific processing required after a power
+ transition
 
  @Input		psPowerDevice : Power device
  @Input		eNewPowerState : New power state
@@ -760,9 +830,9 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
 
 ******************************************************************************/
 static
-PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(PVRSRV_POWER_DEV			*psPowerDevice,
-										  PVRSRV_DEV_POWER_STATE	eNewPowerState,
-										  PVRSRV_POWER_FLAGS		ePwrFlags)
+PVRSRV_ERROR PVRSRVDeviceSystemPostPowerStateKM(PVRSRV_POWER_DEV		*psPowerDevice,
+												PVRSRV_DEV_POWER_STATE	eNewPowerState,
+												PVRSRV_POWER_FLAGS		ePwrFlags)
 {
 	PVRSRV_DEV_POWER_STATE eCurrentPowerState;
 	IMG_UINT64 ui64SysTimer1 = 0;
@@ -799,7 +869,7 @@ PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(PVRSRV_POWER_DEV			*psPowerDevice,
 		ui64DevTimer1 = PVRSRVProcessStatsGetTimeNs();
 
 		/* Call the device's power callback. */
-		eError = psPowerDevice->pfnDevicePostPower(psPowerDevice->hDevCookie,
+		eError = psPowerDevice->pfnDevicePostPower(psPowerDevice->psDevNode,
 												   eNewPowerState,
 												   eCurrentPowerState,
 												   ePwrFlags);
@@ -843,16 +913,18 @@ PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(PPVRSRV_DEVICE_NODE psDeviceNode,
 	if (OSAtomicRead(&psPowerDevice->eCurrentPowerState) != eNewPowerState ||
 	    BITMASK_ANY(ePwrFlags, PVRSRV_POWER_FLAGS_OSPM_SUSPEND_REQ | PVRSRV_POWER_FLAGS_OSPM_RESUME_REQ))
 	{
-		eError = PVRSRVDevicePrePowerStateKM(psPowerDevice,
-											 eNewPowerState,
-											 ePwrFlags);
+		eError = PVRSRVDeviceSystemPrePowerStateKM(psPowerDevice,
+												   eNewPowerState,
+												   ePwrFlags);
 		PVR_GOTO_IF_ERROR(eError, ErrorExit);
 
-		eError = PVRSRVDevicePostPowerStateKM(psPowerDevice,
-											  eNewPowerState,
-											  ePwrFlags);
+		eError = PVRSRVDeviceSystemPostPowerStateKM(psPowerDevice,
+													eNewPowerState,
+													ePwrFlags);
 		PVR_GOTO_IF_ERROR(eError, ErrorExit);
 
+		psDeviceNode->eCurrentSysPowerState = eNewPowerState;
+
 		/* Signal Device Watchdog Thread about power mode change. */
 		if (eNewPowerState == PVRSRV_DEV_POWER_STATE_ON)
 		{
@@ -902,13 +974,14 @@ PVRSRV_ERROR PVRSRVSetDeviceSystemPowerState(PPVRSRV_DEVICE_NODE psDeviceNode,
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT uiStage = 0;
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+	PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus = OSAtomicRead(&psDeviceNode->eHealthStatus);
+#endif
 
-	PVRSRV_DEV_POWER_STATE eNewDevicePowerState = _IsSystemStatePowered(eNewSysPowerState)
-	    ? PVRSRV_DEV_POWER_STATE_DEFAULT : PVRSRV_DEV_POWER_STATE_OFF;
-
-	/* If setting devices to default state, force idle all devices whose default state is off */
-	PFN_SYS_DEV_IS_DEFAULT_STATE_OFF pfnIsDefaultStateOff =
-	  (eNewDevicePowerState == PVRSRV_DEV_POWER_STATE_DEFAULT) ? PVRSRVDeviceIsDefaultStateOFF : NULL;
+	PVRSRV_DATA*    psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_POWER_DEV *psPowerDevice;
+	PVRSRV_DEV_POWER_STATE eNewDevicePowerState;
+	PFN_SYS_DEV_IS_DEFAULT_STATE_OFF pfnIsDefaultStateOff;
 
 	/* Require a proper power state */
 	if (eNewSysPowerState == PVRSRV_SYS_POWER_STATE_Unspecified)
@@ -918,6 +991,14 @@ PVRSRV_ERROR PVRSRVSetDeviceSystemPowerState(PPVRSRV_DEVICE_NODE psDeviceNode,
 
 	/* Prevent simultaneous SetPowerStateKM calls */
 	_PVRSRVForcedPowerLock(psDeviceNode);
+	psPowerDevice = psDeviceNode->psPowerDev;
+
+	eNewDevicePowerState = _IsSystemStatePowered(eNewSysPowerState)
+	    ? psPowerDevice->eDefaultPowerState : PVRSRV_DEV_POWER_STATE_OFF;
+
+	/* If setting devices to default state, force idle all devices whose default state is off */
+	pfnIsDefaultStateOff =
+	  (eNewDevicePowerState == PVRSRV_DEV_POWER_STATE_OFF) ? PVRSRVDeviceIsDefaultStateOFF : NULL;
 
 	/* No power transition requested, so do nothing */
 	if (eNewSysPowerState == psDeviceNode->eCurrentSysPowerState)
@@ -927,10 +1008,19 @@ PVRSRV_ERROR PVRSRVSetDeviceSystemPowerState(PPVRSRV_DEVICE_NODE psDeviceNode,
 	}
 
 	/* If the device is already off don't send the idle request. */
-	if (psDeviceNode->eCurrentSysPowerState != PVRSRV_SYS_POWER_STATE_OFF)
+	if ((psDeviceNode->eCurrentSysPowerState != PVRSRV_SYS_POWER_STATE_OFF) && (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+		&& (eHealthStatus == PVRSRV_DEVICE_HEALTH_STATUS_OK)
+#endif
+		)
 	{
 		eError = _PVRSRVDeviceIdleRequestKM(psDeviceNode, pfnIsDefaultStateOff,
-		                                    IMG_TRUE, _PVRSRVForcedPowerLock);
+#if defined(DEBUG)
+		                                    IMG_TRUE, _PVRSRVForcedPowerLock_Debug
+#else
+		                                    IMG_TRUE, _PVRSRVForcedPowerLock
+#endif
+		                                    );
 		if (eError != PVRSRV_OK)
 		{
 			PVR_LOG_ERROR(eError, "_PVRSRVDeviceIdleRequestKM");
@@ -939,12 +1029,42 @@ PVRSRV_ERROR PVRSRVSetDeviceSystemPowerState(PPVRSRV_DEVICE_NODE psDeviceNode,
 		}
 	}
 
-	eError = PVRSRVSetDevicePowerStateKM(psDeviceNode, eNewDevicePowerState,
-										 ePwrFlags | PVRSRV_POWER_FLAGS_FORCED);
-	if (eError != PVRSRV_OK)
+	/* Call power function if the state change or if this is an OS request. */
+	if (OSAtomicRead(&psPowerDevice->eCurrentPowerState) != eNewDevicePowerState ||
+	    BITMASK_ANY(ePwrFlags, PVRSRV_POWER_FLAGS_OSPM_SUSPEND_REQ | PVRSRV_POWER_FLAGS_OSPM_RESUME_REQ))
 	{
+		eError = PVRSRVDeviceSystemPrePowerStateKM(psPowerDevice,
+												   eNewDevicePowerState,
+												   ePwrFlags);
 		uiStage = 2;
-		goto ErrorExit;
+		PVR_GOTO_IF_ERROR(eError, ErrorExit);
+
+		eError = PVRSRVDeviceSystemPostPowerStateKM(psPowerDevice,
+													eNewDevicePowerState,
+													ePwrFlags);
+		PVR_GOTO_IF_ERROR(eError, ErrorExit);
+
+		/* Signal Device Watchdog Thread about power mode change. */
+		if (eNewDevicePowerState == PVRSRV_DEV_POWER_STATE_ON)
+		{
+			psPVRSRVData->ui32DevicesWatchdogPwrTrans++;
+#if !defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
+			if (psPVRSRVData->ui32DevicesWatchdogTimeout == DEVICES_WATCHDOG_POWER_OFF_SLEEP_TIMEOUT)
+#endif
+			{
+				eError = OSEventObjectSignal(psPVRSRVData->hDevicesWatchdogEvObj);
+				PVR_LOG_IF_ERROR(eError, "OSEventObjectSignal");
+			}
+		}
+#if defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
+		else if (eNewDevicePowerState == PVRSRV_DEV_POWER_STATE_OFF)
+		{
+			/* signal watchdog thread and give it a chance to switch to
+			 * longer / infinite wait time */
+			eError = OSEventObjectSignal(psPVRSRVData->hDevicesWatchdogEvObj);
+			PVR_LOG_IF_ERROR(eError, "OSEventObjectSignal");
+		}
+#endif /* defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP) */
 	}
 
 	psDeviceNode->eCurrentSysPowerState = eNewSysPowerState;
@@ -974,15 +1094,7 @@ PVRSRV_ERROR PVRSRVSetSystemPowerState(PVRSRV_DEVICE_CONFIG *psDevConfig,
 	PVRSRV_DEVICE_NODE *psDevNode = psDevConfig->psDevNode;
 	PVRSRV_SYS_POWER_STATE eCurrentSysPowerState;
 
-	if (psDevNode != NULL)
-	{
-		eCurrentSysPowerState = psDevNode->eCurrentSysPowerState;
-	}
-	else
-	{
-		/* assume power is off if no device node */
-		eCurrentSysPowerState = PVRSRV_SYS_POWER_STATE_OFF;
-	}
+	PVRSRVGetSystemPowerState(psDevNode, &eCurrentSysPowerState);
 
 	/* no power transition requested, so do nothing */
 	if (eNewSysPowerState == eCurrentSysPowerState)
@@ -1029,7 +1141,7 @@ void PVRSRVSetPowerCallbacks(PPVRSRV_DEVICE_NODE				psDeviceNode,
 {
 	if (psPowerDevice != NULL)
 	{
-		if (PVRSRV_VZ_MODE_IS(GUEST) || (psDeviceNode->bAutoVzFwIsUp))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) || (psDeviceNode->bAutoVzFwIsUp))
 		{
 			psPowerDevice->pfnSystemPrePower = NULL;
 			psPowerDevice->pfnSystemPostPower = NULL;
@@ -1057,7 +1169,7 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(PPVRSRV_DEVICE_NODE psDeviceNode,
 									   PFN_FORCED_IDLE_REQUEST	pfnForcedIdleRequest,
 									   PFN_FORCED_IDLE_CANCEL_REQUEST	pfnForcedIdleCancelRequest,
 									   PFN_GPU_UNITS_POWER_CHANGE	pfnGPUUnitsPowerChange,
-									   IMG_HANDLE					hDevCookie,
+									   IMG_HANDLE					psDevNode,
 									   PVRSRV_DEV_POWER_STATE		eCurrentPowerState,
 									   PVRSRV_DEV_POWER_STATE		eDefaultPowerState)
 {
@@ -1085,7 +1197,7 @@ PVRSRV_ERROR PVRSRVRegisterPowerDevice(PPVRSRV_DEVICE_NODE psDeviceNode,
 	psPowerDevice->pfnPostClockSpeedChange = pfnPostClockSpeedChange;
 	psPowerDevice->pfnGPUUnitsPowerChange = pfnGPUUnitsPowerChange;
 	psPowerDevice->hSysData = psDeviceNode->psDevConfig->hSysData;
-	psPowerDevice->hDevCookie = hDevCookie;
+	psPowerDevice->psDevNode = psDevNode;
 	PVRSRVSetDeviceCurrentPowerState(psPowerDevice, eCurrentPowerState);
 	psPowerDevice->eDefaultPowerState = eDefaultPowerState;
 
@@ -1102,6 +1214,8 @@ void PVRSRVRemovePowerDevice(PPVRSRV_DEVICE_NODE psDeviceNode)
 {
 	if (psDeviceNode->psPowerDev)
 	{
+		/* RGX device/firmware should now be powered down */
+		PVR_ASSERT(PVRSRVIsDevicePowered(psDeviceNode) == IMG_FALSE);
 		OSFreeMem(psDeviceNode->psPowerDev);
 		psDeviceNode->psPowerDev = NULL;
 	}
@@ -1135,6 +1249,42 @@ IMG_BOOL PVRSRVIsDevicePowered(PPVRSRV_DEVICE_NODE psDeviceNode)
 	return (ePowerState == PVRSRV_DEV_POWER_STATE_ON);
 }
 
+PVRSRV_ERROR PVRSRVGetSystemPowerState(PVRSRV_DEVICE_NODE *psDeviceNode,
+	                                   PPVRSRV_SYS_POWER_STATE peCurrentSysPowerState)
+{
+	if (psDeviceNode != NULL)
+	{
+		if (psDeviceNode->psDevConfig->pfnGpuDomainPower)
+		{
+			*peCurrentSysPowerState = psDeviceNode->psDevConfig->pfnGpuDomainPower(psDeviceNode);
+		}
+		else
+		{
+			*peCurrentSysPowerState = psDeviceNode->eCurrentSysPowerState;
+		}
+	}
+	else
+	{
+		/* assume power is off if no device node */
+		*peCurrentSysPowerState = PVRSRV_SYS_POWER_STATE_OFF;
+		return PVRSRV_ERROR_UNKNOWN_POWER_STATE;
+	}
+
+	return PVRSRV_OK;
+}
+
+IMG_BOOL PVRSRVIsSystemPowered(PPVRSRV_DEVICE_NODE psDeviceNode)
+{
+	PVRSRV_SYS_POWER_STATE eSysPowerState;
+
+	if (PVRSRVGetSystemPowerState(psDeviceNode, &eSysPowerState) != PVRSRV_OK)
+	{
+		return IMG_FALSE;
+	}
+
+	return (eSysPowerState == PVRSRV_SYS_POWER_STATE_ON);
+}
+
 PVRSRV_ERROR
 PVRSRVDevicePreClockSpeedChange(PPVRSRV_DEVICE_NODE psDeviceNode,
                                 IMG_BOOL            bIdleDevice,
@@ -1181,7 +1331,7 @@ PVRSRVDevicePreClockSpeedChange(PPVRSRV_DEVICE_NODE psDeviceNode,
 		}
 	}
 
-	eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->hDevCookie,
+	eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->psDevNode,
 	                                               eCurrentPowerState);
 
 	ui64StopTimer = PVRSRVProcessStatsGetTimeUs();
@@ -1212,7 +1362,7 @@ PVRSRVDevicePostClockSpeedChange(PPVRSRV_DEVICE_NODE psDeviceNode,
 
 	eCurrentPowerState = OSAtomicRead(&psPowerDevice->eCurrentPowerState);
 
-	eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->hDevCookie,
+	eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->psDevNode,
 													eCurrentPowerState);
 	if (eError != PVRSRV_OK)
 	{
@@ -1269,7 +1419,7 @@ PVRSRV_ERROR PVRSRVDeviceGPUUnitsPowerChange(PPVRSRV_DEVICE_NODE psDeviceNode,
 
 		if (psPowerDevice->pfnGPUUnitsPowerChange != NULL)
 		{
-			PVRSRV_ERROR eError2 = psPowerDevice->pfnGPUUnitsPowerChange(psPowerDevice->hDevCookie, ui32NewValue);
+			PVRSRV_ERROR eError2 = psPowerDevice->pfnGPUUnitsPowerChange(psPowerDevice->psDevNode, ui32NewValue);
 
 			if (eError2 != PVRSRV_OK)
 			{
diff --git a/drivers/gpu/drm/img-rogue/power.h b/drivers/gpu/drm/img-rogue/power.h
index e4ef6de844bc..57226d91f6c5 100644
--- a/drivers/gpu/drm/img-rogue/power.h
+++ b/drivers/gpu/drm/img-rogue/power.h
@@ -66,18 +66,52 @@ typedef IMG_BOOL (*PFN_SYS_DEV_IS_DEFAULT_STATE_OFF)(PVRSRV_POWER_DEV *psPowerDe
   Typedef for a pointer to a Function that will be called before a transition
   from one power state to another. See also PFN_POST_POWER.
  */
-typedef PVRSRV_ERROR (*PFN_PRE_POWER) (IMG_HANDLE				hDevHandle,
-									   PVRSRV_DEV_POWER_STATE	eNewPowerState,
-									   PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
-									   PVRSRV_POWER_FLAGS		ePwrFlags);
+typedef PVRSRV_ERROR (*PFN_PRE_POWER)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                      PVRSRV_DEV_POWER_STATE eNewPowerState,
+                                      PVRSRV_DEV_POWER_STATE eCurrentPowerState,
+                                      PVRSRV_POWER_FLAGS ePwrFlags);
 /*!
   Typedef for a pointer to a Function that will be called after a transition
   from one power state to another. See also PFN_PRE_POWER.
  */
-typedef PVRSRV_ERROR (*PFN_POST_POWER) (IMG_HANDLE				hDevHandle,
-										PVRSRV_DEV_POWER_STATE	eNewPowerState,
-										PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
-										PVRSRV_POWER_FLAGS		ePwrFlags);
+typedef PVRSRV_ERROR (*PFN_POST_POWER)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                       PVRSRV_DEV_POWER_STATE eNewPowerState,
+                                       PVRSRV_DEV_POWER_STATE eCurrentPowerState,
+                                       PVRSRV_POWER_FLAGS ePwrFlags);
+
+/* Clock speed handler prototypes */
+
+/*!
+  Typedef for a pointer to a Function that will be called before a transition
+  from one clock speed to another. See also PFN_POST_CLOCKSPEED_CHANGE.
+ */
+typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                                  PVRSRV_DEV_POWER_STATE eCurrentPowerState);
+
+/*!
+  Typedef for a pointer to a Function that will be called after a transition
+  from one clock speed to another. See also PFN_PRE_CLOCKSPEED_CHANGE.
+ */
+typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                                   PVRSRV_DEV_POWER_STATE eCurrentPowerState);
+
+/*!
+  Typedef for a pointer to a function that will be called to transition the
+  device to a forced idle state. Used in unison with (forced) power requests,
+  DVFS and cluster count changes.
+ */
+typedef PVRSRV_ERROR (*PFN_FORCED_IDLE_REQUEST)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                                IMG_BOOL bDeviceOffPermitted);
+
+/*!
+  Typedef for a pointer to a function that will be called to cancel a forced
+  idle state and return the firmware back to a state where the hardware can be
+  scheduled.
+ */
+typedef PVRSRV_ERROR (*PFN_FORCED_IDLE_CANCEL_REQUEST)(PPVRSRV_DEVICE_NODE psDeviceNode);
+
+typedef PVRSRV_ERROR (*PFN_GPU_UNITS_POWER_CHANGE)(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                                   IMG_UINT32 ui32SESPowerState);
 
 const char *PVRSRVSysPowerStateToString(PVRSRV_SYS_POWER_STATE eState);
 const char *PVRSRVDevPowerStateToString(PVRSRV_DEV_POWER_STATE eState);
@@ -96,7 +130,13 @@ void PVRSRVPowerLockDeInit(PPVRSRV_DEVICE_NODE psDeviceNode);
  @Return	PVRSRV_ERROR_SYSTEM_STATE_POWERED_OFF or PVRSRV_OK
 
 ******************************************************************************/
+#if defined(DEBUG)
+PVRSRV_ERROR PVRSRVPowerLock_Debug(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                   const char *pszFile, const unsigned int ui32LineNum);
+#define PVRSRVPowerLock(DEV_NODE)	PVRSRVPowerLock_Debug(DEV_NODE, __FILE__, __LINE__)
+#else
 PVRSRV_ERROR PVRSRVPowerLock(PPVRSRV_DEVICE_NODE psDeviceNode);
+#endif
 
 /*!
 ******************************************************************************
@@ -122,7 +162,32 @@ void PVRSRVPowerUnlock(PPVRSRV_DEVICE_NODE psDeviceNode);
 		PVRSRV_OK
 
 ******************************************************************************/
+#if defined(DEBUG)
+PVRSRV_ERROR PVRSRVPowerTryLock_Debug(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                      const char *pszFile, const unsigned int ui32LineNum);
+#define PVRSRVPowerTryLock(DEV_NODE)	PVRSRVPowerTryLock_Debug(DEV_NODE, __FILE__, __LINE__)
+#else
 PVRSRV_ERROR PVRSRVPowerTryLock(PPVRSRV_DEVICE_NODE psDeviceNode);
+#endif
+
+/*!
+******************************************************************************
+
+ @Function	PVRSRVPowerTryLockWaitForTimeout
+
+ @Description	Try to obtain the mutex for power transitions. Only allowed when
+		system power is on. The call blocks until either the lock is acquired,
+		or the timeout is reached.
+
+		*** Debug only. DO NOT use in core GPU functions which cannot fail. ***
+		If the power lock cannot be taken the device may be powered down at
+		any time in another worker thread.
+
+ @Return	PVRSRV_ERROR_RETRY or PVRSRV_ERROR_SYSTEM_STATE_POWERED_OFF or
+		PVRSRV_OK
+
+******************************************************************************/
+PVRSRV_ERROR PVRSRVPowerTryLockWaitForTimeout(PPVRSRV_DEVICE_NODE psDeviceNode);
 
 /*!
 ******************************************************************************
@@ -310,6 +375,42 @@ PVRSRV_ERROR PVRSRVGetDevicePowerState(PCPVRSRV_DEVICE_NODE psDeviceNode,
 ******************************************************************************/
 IMG_BOOL PVRSRVIsDevicePowered(PPVRSRV_DEVICE_NODE psDeviceNode);
 
+/*!
+******************************************************************************
+
+ @Function	PVRSRVGetSystemPowerState
+
+ @Description
+
+	Return the system power state
+
+ @Input		psDeviceNode : Device node
+ @Output	peCurrentSysPowerState : Current power state
+
+ @Return	PVRSRV_ERROR_UNKNOWN_POWER_STATE if device could not be found.
+            PVRSRV_OK otherwise.
+
+******************************************************************************/
+PVRSRV_ERROR PVRSRVGetSystemPowerState(PPVRSRV_DEVICE_NODE psDeviceNode,
+	                                   PPVRSRV_SYS_POWER_STATE peCurrentSysPowerState);
+
+/*!
+******************************************************************************
+
+ @Function	PVRSRVIsSystemPowered
+
+ @Description
+
+	Whether the system layer is powered, for ensuring the RGX regbank is powered
+	during initial GPU driver configuration.
+
+ @Input		psDeviceNode : Device node
+
+ @Return	IMG_BOOL
+
+******************************************************************************/
+IMG_BOOL PVRSRVIsSystemPowered(PPVRSRV_DEVICE_NODE psDeviceNode);
+
 /**************************************************************************/ /*!
 @Function       PVRSRVDevicePreClockSpeedChange
 
diff --git a/drivers/gpu/drm/img-rogue/powervr/img_drm_fourcc.h b/drivers/gpu/drm/img-rogue/powervr/img_drm_fourcc.h
index 92f1d4c97871..d4717db1cccb 100644
--- a/drivers/gpu/drm/img-rogue/powervr/img_drm_fourcc.h
+++ b/drivers/gpu/drm/img-rogue/powervr/img_drm_fourcc.h
@@ -140,4 +140,22 @@ THE SOFTWARE.
 #define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY37_8x8_V13     fourcc_mod_code(PVR, 32)
 #define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY37_16x4_V13    fourcc_mod_code(PVR, 33)
 
+#define DRM_FORMAT_MOD_PVR_FBCDC_8x8_V14             fourcc_mod_code(PVR, 34)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY25_8x8_V14     fourcc_mod_code(PVR, 35)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY37_8x8_V14     fourcc_mod_code(PVR, 36)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY50_8x8_V14     fourcc_mod_code(PVR, 37)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY75_8x8_V14     fourcc_mod_code(PVR, 38)
+
+#define DRM_FORMAT_MOD_PVR_FBCDC_16x4_V14            fourcc_mod_code(PVR, 39)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY25_16x4_V14    fourcc_mod_code(PVR, 40)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY37_16x4_V14    fourcc_mod_code(PVR, 41)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY50_16x4_V14    fourcc_mod_code(PVR, 42)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY75_16x4_V14    fourcc_mod_code(PVR, 43)
+
+#define DRM_FORMAT_MOD_PVR_FBCDC_32x2_V14            fourcc_mod_code(PVR, 44)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY25_32x2_V14    fourcc_mod_code(PVR, 45)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY37_32x2_V14    fourcc_mod_code(PVR, 46)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY50_32x2_V14    fourcc_mod_code(PVR, 47)
+#define DRM_FORMAT_MOD_PVR_FBCDC_LOSSY75_32x2_V14    fourcc_mod_code(PVR, 48)
+
 #endif /* IMG_DRM_FOURCC_H */
diff --git a/drivers/gpu/drm/img-rogue/powervr/pvrsrv_sync_ext.h b/drivers/gpu/drm/img-rogue/powervr/pvrsrv_sync_ext.h
index 30f7972444cd..933212e03c17 100644
--- a/drivers/gpu/drm/img-rogue/powervr/pvrsrv_sync_ext.h
+++ b/drivers/gpu/drm/img-rogue/powervr/pvrsrv_sync_ext.h
@@ -53,6 +53,7 @@ extern "C" {
  */
 typedef int32_t PVRSRV_FENCE;
 typedef int32_t PVRSRV_TIMELINE;
+typedef int32_t PVRSRV_EXP_FENCE_CTX;
 
 /*! Maximum length for an annotation name string for fence sync model objects.
  */
@@ -62,6 +63,7 @@ typedef int32_t PVRSRV_TIMELINE;
  */
 #define PVRSRV_NO_TIMELINE      ((PVRSRV_TIMELINE) -1)
 #define PVRSRV_NO_FENCE         ((PVRSRV_FENCE)    -1)
+#define PVRSRV_NO_EXP_FENCE_CTX ((PVRSRV_EXP_FENCE_CTX) -1)
 #define PVRSRV_NO_FENCE_PTR     NULL
 #define PVRSRV_NO_TIMELINE_PTR  NULL
 
diff --git a/drivers/gpu/drm/img-rogue/proc_stats.h b/drivers/gpu/drm/img-rogue/proc_stats.h
index 037880e19da5..72c14c5f8e4d 100644
--- a/drivers/gpu/drm/img-rogue/proc_stats.h
+++ b/drivers/gpu/drm/img-rogue/proc_stats.h
@@ -43,36 +43,140 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef PROC_STATS_H
 #define PROC_STATS_H
 
-/* X-Macro for Process stat keys */
+#define DKP_HIDDEN "hidden"
+
+#define PROCESS_STAT_KMALLOC                   X(PVRSRV_PROCESS_STAT_TYPE_KMALLOC,                "MemoryUsageKMalloc",                "host_kmalloc")
+#define PROCESS_STAT_KMALLOC_MAX               X(PVRSRV_PROCESS_STAT_TYPE_KMALLOC_MAX,            "MemoryUsageKMallocMax",             DKP_HIDDEN)
+
+#define PROCESS_STAT_VMALLOC                   X(PVRSRV_PROCESS_STAT_TYPE_VMALLOC,                "MemoryUsageVMalloc",                "host_vmalloc")
+#define PROCESS_STAT_VMALLOC_MAX               X(PVRSRV_PROCESS_STAT_TYPE_VMALLOC_MAX,            "MemoryUsageVMallocMax",             DKP_HIDDEN)
+
+#define PROCESS_STAT_ALLOC_PAGES_PT_UMA        X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA,     "MemoryUsageAllocPTMemoryUMA",       "host_mem_dev_pt")
+#define PROCESS_STAT_ALLOC_PAGES_PT_UMA_MAX    X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA_MAX, "MemoryUsageAllocPTMemoryUMAMax",    DKP_HIDDEN)
+
+#define PROCESS_STAT_VMAP_PT_UMA               X(PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA,            "MemoryUsageVMapPTUMA",              DKP_HIDDEN)
+#define PROCESS_STAT_VMAP_PT_UMA_MAX           X(PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA_MAX,        "MemoryUsageVMapPTUMAMax",           DKP_HIDDEN)
+
+#define PROCESS_STAT_ALLOC_PAGES_PT_LMA        X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA,     "MemoryUsageAllocPTMemoryLMA",       "local_mem_dev_pt")
+#define PROCESS_STAT_ALLOC_PAGES_PT_LMA_MAX    X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA_MAX, "MemoryUsageAllocPTMemoryLMAMax",    DKP_HIDDEN)
+
+#define PROCESS_STAT_IOREMAP_PT_LMA            X(PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA,         "MemoryUsageIORemapPTLMA",           DKP_HIDDEN)
+#define PROCESS_STAT_IOREMAP_PT_LMA_MAX        X(PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA_MAX,     "MemoryUsageIORemapPTLMAMax",        DKP_HIDDEN)
+
+#define PROCESS_STAT_ALLOC_LMA_PAGES           X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES,        "MemoryUsageAllocGPUMemLMA",         "local_mem_dev_buf")
+#define PROCESS_STAT_ALLOC_LMA_PAGES_MAX       X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES_MAX,    "MemoryUsageAllocGPUMemLMAMax",      DKP_HIDDEN)
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+#define PROCESS_STAT_ZOMBIE_LMA_PAGES          X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES,       "MemoryUsageZombieGPUMemLMA",        "local_mem_dev_buf_purgeable")
+#define PROCESS_STAT_ZOMBIE_LMA_PAGES_MAX      X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES_MAX,   "MemoryUsageZombieGPUMemLMAMax",     DKP_HIDDEN)
+#else
+#define PROCESS_STAT_ZOMBIE_LMA_PAGES
+#define PROCESS_STAT_ZOMBIE_LMA_PAGES_MAX
+#endif
+
+#define PROCESS_STAT_ALLOC_UMA_PAGES           X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES,        "MemoryUsageAllocGPUMemUMA",         "host_mem_dev_buf")
+#define PROCESS_STAT_ALLOC_UMA_PAGES_MAX       X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES_MAX,    "MemoryUsageAllocGPUMemUMAMax",      DKP_HIDDEN)
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+#define PROCESS_STAT_ZOMBIE_UMA_PAGES          X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES,       "MemoryUsageZombieGPUMemUMA",        "host_mem_dev_buf_purgeable")
+#define PROCESS_STAT_ZOMBIE_UMA_PAGES_MAX      X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES_MAX,   "MemoryUsageZombieGPUMemUMAMax",     DKP_HIDDEN)
+#else
+#define PROCESS_STAT_ZOMBIE_UMA_PAGES
+#define PROCESS_STAT_ZOMBIE_UMA_PAGES_MAX
+#endif
+
+#define PROCESS_STAT_MAP_UMA_LMA_PAGES         X(PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES,      "MemoryUsageMappedGPUMemUMA/LMA",    DKP_HIDDEN)
+#define PROCESS_STAT_MAP_UMA_LMA_PAGES_MAX     X(PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES_MAX,  "MemoryUsageMappedGPUMemUMA/LMAMax", DKP_HIDDEN)
+
+#define PROCESS_STAT_DMA_BUF_IMPORT            X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT,         "MemoryUsageDmaBufImport",           "dma_buf_import")
+#define PROCESS_STAT_DMA_BUF_IMPORT_MAX        X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT_MAX,     "MemoryUsageDmaBufImportMax",        DKP_HIDDEN)
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+#define PROCESS_STAT_DMA_BUF_ZOMBIE            X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE,         "MemoryUsageDmaBufZombie",           "dma_buf_purgeable")
+#define PROCESS_STAT_DMA_BUF_ZOMBIE_MAX        X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE_MAX,     "MemoryUsageDmaBufZombieMax",        DKP_HIDDEN)
+#else
+#define PROCESS_STAT_DMA_BUF_ZOMBIE
+#define PROCESS_STAT_DMA_BUF_ZOMBIE_MAX
+#endif
+
+#define PROCESS_STAT_TOTAL                     X(PVRSRV_PROCESS_STAT_TYPE_TOTAL,                  "MemoryUsageTotal",                  DKP_HIDDEN)
+#define PROCESS_STAT_TOTAL_MAX                 X(PVRSRV_PROCESS_STAT_TYPE_TOTAL_MAX,              "MemoryUsageTotalMax",               DKP_HIDDEN)
+
+/* Process stat keys */
 #define PVRSRV_PROCESS_STAT_KEY \
-	X(PVRSRV_PROCESS_STAT_TYPE_KMALLOC, "MemoryUsageKMalloc") \
-	X(PVRSRV_PROCESS_STAT_TYPE_KMALLOC_MAX, "MemoryUsageKMallocMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_VMALLOC, "MemoryUsageVMalloc") \
-	X(PVRSRV_PROCESS_STAT_TYPE_VMALLOC_MAX, "MemoryUsageVMallocMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA, "MemoryUsageAllocPTMemoryUMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA_MAX, "MemoryUsageAllocPTMemoryUMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA, "MemoryUsageVMapPTUMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA_MAX, "MemoryUsageVMapPTUMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA, "MemoryUsageAllocPTMemoryLMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA_MAX, "MemoryUsageAllocPTMemoryLMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA, "MemoryUsageIORemapPTLMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA_MAX, "MemoryUsageIORemapPTLMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES, "MemoryUsageAllocGPUMemLMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES_MAX, "MemoryUsageAllocGPUMemLMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES, "MemoryUsageZombieGPUMemLMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES_MAX, "MemoryUsageZombieGPUMemLMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES, "MemoryUsageAllocGPUMemUMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES_MAX, "MemoryUsageAllocGPUMemUMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES, "MemoryUsageZombieGPUMemUMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES_MAX, "MemoryUsageZombieGPUMemUMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES, "MemoryUsageMappedGPUMemUMA/LMA") \
-	X(PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES_MAX, "MemoryUsageMappedGPUMemUMA/LMAMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT, "MemoryUsageDmaBufImport") \
-	X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT_MAX, "MemoryUsageDmaBufImportMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE, "MemoryUsageDmaBufZombie") \
-	X(PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE_MAX, "MemoryUsageDmaBufZombieMax") \
-	X(PVRSRV_PROCESS_STAT_TYPE_TOTAL, "MemoryUsageTotal") \
-	X(PVRSRV_PROCESS_STAT_TYPE_TOTAL_MAX, "MemoryUsageTotalMax")
+	PROCESS_STAT_KMALLOC \
+	PROCESS_STAT_KMALLOC_MAX \
+	PROCESS_STAT_VMALLOC \
+	PROCESS_STAT_VMALLOC_MAX \
+	PROCESS_STAT_ALLOC_PAGES_PT_UMA \
+	PROCESS_STAT_ALLOC_PAGES_PT_UMA_MAX \
+	PROCESS_STAT_VMAP_PT_UMA \
+	PROCESS_STAT_VMAP_PT_UMA_MAX \
+	PROCESS_STAT_ALLOC_PAGES_PT_LMA \
+	PROCESS_STAT_ALLOC_PAGES_PT_LMA_MAX \
+	PROCESS_STAT_IOREMAP_PT_LMA \
+	PROCESS_STAT_IOREMAP_PT_LMA_MAX \
+	PROCESS_STAT_ALLOC_LMA_PAGES \
+	PROCESS_STAT_ALLOC_LMA_PAGES_MAX \
+	PROCESS_STAT_ZOMBIE_LMA_PAGES \
+	PROCESS_STAT_ZOMBIE_LMA_PAGES_MAX \
+	PROCESS_STAT_ALLOC_UMA_PAGES \
+	PROCESS_STAT_ALLOC_UMA_PAGES_MAX \
+	PROCESS_STAT_ZOMBIE_UMA_PAGES \
+	PROCESS_STAT_ZOMBIE_UMA_PAGES_MAX \
+	PROCESS_STAT_MAP_UMA_LMA_PAGES \
+	PROCESS_STAT_MAP_UMA_LMA_PAGES_MAX \
+	PROCESS_STAT_DMA_BUF_IMPORT \
+	PROCESS_STAT_DMA_BUF_IMPORT_MAX \
+	PROCESS_STAT_DMA_BUF_ZOMBIE \
+	PROCESS_STAT_DMA_BUF_ZOMBIE_MAX \
+	PROCESS_STAT_TOTAL \
+	PROCESS_STAT_TOTAL_MAX
+
+#if defined(SUPPORT_LINUX_FDINFO)
+/* DKP process stats within the drm-memory-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_MEMORY \
+	PROCESS_STAT_KMALLOC \
+	PROCESS_STAT_VMALLOC \
+	PROCESS_STAT_ALLOC_PAGES_PT_UMA \
+	PROCESS_STAT_ALLOC_UMA_PAGES \
+	PROCESS_STAT_ZOMBIE_UMA_PAGES
+
+/* DKP process stats within the drm-shared-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_SHARED \
+	PROCESS_STAT_DMA_BUF_IMPORT \
+	PROCESS_STAT_DMA_BUF_ZOMBIE
+
+/* DKP process stats within the drm-total-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_TOTAL \
+	PROCESS_STAT_KMALLOC \
+	PROCESS_STAT_VMALLOC \
+	PROCESS_STAT_ALLOC_PAGES_PT_UMA \
+	PROCESS_STAT_ALLOC_UMA_PAGES \
+	PROCESS_STAT_ALLOC_PAGES_PT_LMA \
+	PROCESS_STAT_ALLOC_LMA_PAGES
+
+/* DKP process stats within the drm-resident-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_RESIDENT \
+	PROCESS_STAT_KMALLOC \
+	PROCESS_STAT_VMALLOC \
+	PROCESS_STAT_ALLOC_PAGES_PT_UMA \
+	PROCESS_STAT_ALLOC_UMA_PAGES \
+	PROCESS_STAT_ZOMBIE_UMA_PAGES \
+	PROCESS_STAT_ALLOC_PAGES_PT_LMA \
+	PROCESS_STAT_ALLOC_LMA_PAGES \
+	PROCESS_STAT_ZOMBIE_LMA_PAGES \
+
+/* DKP process stats within the drm-purgeable-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_PURGEABLE \
+	PROCESS_STAT_ZOMBIE_LMA_PAGES \
+	PROCESS_STAT_ZOMBIE_UMA_PAGES \
+	PROCESS_STAT_DMA_BUF_ZOMBIE
+
+/* DKP process stats within the drm-active-<region> key */
+#define PVRSRV_DKP_MEM_STAT_GROUP_ACTIVE
+
+#endif
 
 /* X-Macro for Device stat keys */
 #define PVRSRV_DEVICE_STAT_KEY \
@@ -130,7 +234,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
 typedef enum {
-#define X(stat_type, stat_str) stat_type,
+#define X(stat_type, stat_str, drm_str) stat_type,
 	PVRSRV_PROCESS_STAT_KEY
 #undef X
 	PVRSRV_PROCESS_STAT_TYPE_COUNT
diff --git a/drivers/gpu/drm/img-rogue/process_stats.c b/drivers/gpu/drm/img-rogue/process_stats.c
index e82f0f916e05..77441c578089 100644
--- a/drivers/gpu/drm/img-rogue/process_stats.c
+++ b/drivers/gpu/drm/img-rogue/process_stats.c
@@ -61,6 +61,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "trace_events.h"
 #endif
 
+#if defined(SUPPORT_LINUX_FDINFO) && defined(PVRSRV_ENABLE_PROCESS_STATS)
+#include "dkp_impl.h"
+
+#define PROC_STATS_FDINFO_ENABLED
+#endif
+
 /* Enabled OS Statistics entries: DEBUGFS on Linux, undefined for other OSs */
 #if defined(__linux__) && ( \
 	defined(PVRSRV_ENABLE_PERPID_STATS) || \
@@ -81,14 +87,21 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 #define MAX_DEAD_LIST_PROCESSES  (10)
 
+/*
+ * Maximum size of a process name to be displayed in process_stats.
+ */
+#define MAX_PROC_NAME_LEN  (16)
+
 /*
  * Definition of all the strings used to format process based statistics.
  */
 
 #if defined(PVRSRV_ENABLE_PERPID_STATS)
 /* Array of Process stat type defined using the X-Macro */
-#define X(stat_type, stat_str) stat_str,
+#define X(stat_type, stat_str, drm_str) stat_str,
 static const IMG_CHAR *const pszProcessStatType[PVRSRV_PROCESS_STAT_TYPE_COUNT] = { PVRSRV_PROCESS_STAT_KEY };
+#undef X
+#define X(stat_type, stat_str) stat_str,
 static const IMG_CHAR *const pszDeviceStatType[PVRSRV_DEVICE_STAT_TYPE_COUNT] = { PVRSRV_DEVICE_STAT_KEY };
 #undef X
 #endif
@@ -122,6 +135,7 @@ int GlobalStatsPrintElements(OSDI_IMPL_ENTRY *psEntry, void *pvData);
 #define GET_GLOBAL_STAT_VALUE(idx) gsGlobalStats.ui64StatValue[idx]
 
 #define GET_GPUMEM_GLOBAL_STAT_VALUE() \
+	GET_GLOBAL_STAT_VALUE(PVRSRV_DRIVER_STAT_TYPE_ALLOC_GPUMEM_UMA_POOL) + \
 	GET_GLOBAL_STAT_VALUE(PVRSRV_DRIVER_STAT_TYPE_ALLOC_PT_MEMORY_UMA) + \
 	GET_GLOBAL_STAT_VALUE(PVRSRV_DRIVER_STAT_TYPE_ALLOC_PT_MEMORY_LMA) + \
 	GET_GLOBAL_STAT_VALUE(PVRSRV_DRIVER_STAT_TYPE_ALLOC_GPUMEM_LMA) + \
@@ -198,6 +212,7 @@ typedef struct _PVRSRV_PROCESS_STATS_ {
 
 	/* OS level process ID */
 	IMG_PID	                       pid;
+	IMG_CHAR                       processName[MAX_PROC_NAME_LEN];
 	IMG_UINT32                     ui32RefCount;
 
 	/* Process memory stats */
@@ -230,6 +245,10 @@ typedef struct _PVRSRV_PROCESS_STATS_ {
 	IMG_INT32                      ai32DevStats[][PVRSRV_DEVICE_STAT_TYPE_COUNT];
 } PVRSRV_PROCESS_STATS;
 
+#if defined(PROC_STATS_FDINFO_ENABLED)
+static PVRDKF_DKP_HANDLE ghDKPHandle;
+#endif
+
 #if defined(ENABLE_DEBUGFS_PIDS)
 
 typedef struct _PVRSRV_OS_STAT_ENTRY_
@@ -316,7 +335,7 @@ _prepareStatsHeaderString(IMG_CHAR *pszStatsSpecificStr, const IMG_CHAR* pszGene
 	IMG_CHAR szStatsHeaderFooterStr[75];
 
 	/* Prepare text content of the header in a local string */
-	OSStringLCopy(szStatsHeaderFooterStr, pszStatsSpecificStr, ARRAY_SIZE(szStatsHeaderFooterStr));
+	OSStringSafeCopy(szStatsHeaderFooterStr, pszStatsSpecificStr, ARRAY_SIZE(szStatsHeaderFooterStr));
 	OSStringLCat(szStatsHeaderFooterStr, pszGenericHeaderStr, ARRAY_SIZE(szStatsHeaderFooterStr));
 
 	/* Write all '-' characters to the header string */
@@ -434,9 +453,9 @@ static PVRSRV_ERROR _RegisterProcess(IMG_HANDLE *phProcessStats, IMG_PID ownerPi
 
 static void _DestroyProcessStat(PVRSRV_PROCESS_STATS* psProcessStats);
 
-static void _DecreaseProcStatValue(PVRSRV_MEM_ALLOC_TYPE eAllocType,
-                                   PVRSRV_PROCESS_STATS* psProcessStats,
-                                   IMG_UINT64 uiBytes);
+static void _DecreaseProcStatValueUnlocked(PVRSRV_MEM_ALLOC_TYPE eAllocType,
+                                           PVRSRV_PROCESS_STATS* psProcessStats,
+                                           IMG_UINT64 uiBytes);
 
 /*************************************************************************/ /*!
 @Function       _FindProcessStatsInLiveList
@@ -548,6 +567,9 @@ _CompressMemoryUsage(void)
 	{
 		PVRSRV_PROCESS_STATS *psProcessStatsToBeFreed;
 		psProcessStatsToBeFreed = IMG_CONTAINER_OF(psNode, PVRSRV_PROCESS_STATS, sNode);
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+		RIDeleteEntriesForPID(psProcessStatsToBeFreed->pid);
+#endif
 		_DestroyProcessStat(psProcessStatsToBeFreed);
 	}
 } /* _CompressMemoryUsage */
@@ -773,6 +795,86 @@ _removeStatisticsEntries(void)
 }
 #endif
 
+#if defined(PROC_STATS_FDINFO_ENABLED)
+
+#define GENERATE_DKP_PRINT(_handle, _key, _value)                   \
+	PVRDKPOutput((_handle),                                         \
+	             "%s:%-*s%"IMG_UINT64_FMTSPEC"\n",                  \
+	             (_key),                                            \
+	             (int)(50 - sizeof((_key))),                        \
+	              "",                                               \
+	             (IMG_UINT64)(_value))
+
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+#define GENERATE_PROCESS_STAT_FDINFO(_dkp_handle, _stat_type, _key, _process_stats) \
+	do { \
+		IMG_UINT32 ui32Value = MAX(0, (_process_stats)->i64StatValue[(_stat_type)]); \
+		if (((_stat_type) == PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES) || \
+			((_stat_type) == PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES)) \
+		{ \
+			ui32Value = RITotalAllocProcessUnlocked((_process_stats)->pid, \
+			                                        ((_stat_type) == PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES) ? PHYS_HEAP_TYPE_LMA : PHYS_HEAP_TYPE_UMA); \
+		} \
+		GENERATE_DKP_PRINT((_dkp_handle), (_key), ui32Value); \
+	} while (0)
+#else
+#define GENERATE_PROCESS_STAT_FDINFO(_dkp_handle, _stat_type, _key, _process_stats) \
+	GENERATE_DKP_PRINT((_dkp_handle), (_key), MAX(0, (_process_stats)->i64StatValue[(_stat_type)]));
+#endif
+
+static void _ProcessStatsDKPShow(PVRSRV_DEVICE_NODE *psDevNode,
+                                 int pid,
+                                 IMG_HANDLE hPrivData)
+{
+	PVRSRV_PROCESS_STATS *psProcessStats = _FindProcessStatsInLiveList((IMG_PID)pid);
+
+	PVR_UNREFERENCED_PARAMETER(psDevNode);
+	PVR_UNREFERENCED_PARAMETER(hPrivData);
+
+	if (psProcessStats == NULL)
+	{
+		/* Just return if the specified process is no longer in the process
+		 * stats list.
+		 */
+		return;
+	}
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-memory-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_MEMORY
+	#undef X
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-shared-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_SHARED
+	#undef X
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-total-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_TOTAL
+	#undef X
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-resident-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_RESIDENT
+	#undef X
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-purgeable-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_PURGEABLE
+	#undef X
+
+	#define X(_stat_type, _stat_name, _dkp_name) \
+	GENERATE_PROCESS_STAT_FDINFO(ghDKPHandle, _stat_type, "drm-active-"_dkp_name, psProcessStats);
+	PVRSRV_DKP_MEM_STAT_GROUP_ACTIVE
+	#undef X
+}
+
+#undef GENERATE_PROCESS_STAT_FDINFO
+#undef GENERATE_DKP_PRINT
+
+#endif
+
 /*************************************************************************/ /*!
 @Function       PVRSRVStatsInitialise
 @Description    Entry point for initialising the statistics module.
@@ -845,6 +947,23 @@ PVRSRVStatsInitialise(void)
 		PVR_LOG_IF_ERROR(error, "DICreateEntry (3)");
 	}
 
+#if defined(PROC_STATS_FDINFO_ENABLED)
+	/* We might error here, but drm usage keys related to memory are optional.
+	 * We'll notify that the DKP registration has failed but continue as if nothing
+	 * happened. */
+	{
+		error = PVRSRVRegisterDKP(NULL,
+		                          "proc-stats",
+		                          &_ProcessStatsDKPShow,
+		                          DKP_CONNECTION_FLAG_SERVICES,
+		                          &ghDKPHandle);
+		if (error != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "%s: Failed to register process stats DKP", __func__));
+		}
+	}
+#endif
+
 	return PVRSRV_OK;
 
 destroy_stats_lock_:
@@ -905,6 +1024,17 @@ PVRSRVStatsDestroy(void)
 	PVRSRVStatsDeregisterProcess(g_hDriverProcessStats);
 #endif
 
+#if defined(PROC_STATS_FDINFO_ENABLED)
+	if (ghDKPHandle != NULL)
+	{
+		PVRSRV_ERROR eError = PVRSRVUnRegisterDKP(NULL, ghDKPHandle);
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to unregister process stats DKP", __func__));
+		}
+	}
+#endif
+
 	/* Stop monitoring memory allocations... */
 	bProcessStatsInitialised = IMG_FALSE;
 
@@ -1221,6 +1351,8 @@ _RegisterProcess(IMG_HANDLE *phProcessStats, IMG_PID ownerPid)
 	eError = _AllocateProcessStats(&psProcessStats, ownerPid);
 	PVR_GOTO_IF_ERROR(eError, e0);
 
+	OSStringSafeCopy(psProcessStats->processName, OSGetCurrentProcessName(), MAX_PROC_NAME_LEN);
+
 	/* Add it to the live list... */
 	OSLockAcquire(g_psLinkedListLock);
 	dllist_add_to_head(&gsLiveList, &psProcessStats->sNode);
@@ -1374,166 +1506,14 @@ void PVRSRVStatsDeviceDisconnect(PVRSRV_DEVICE_NODE *psDeviceNode)
 	OSLockRelease(g_psLinkedListLock);
 }
 
-void
-PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
-							 void *pvCpuVAddr,
-							 IMG_CPU_PHYADDR sCpuPAddr,
-							 size_t uiBytes,
-							 IMG_PID currentPid
-							 DEBUG_MEMSTATS_PARAMS)
+/* Assumes PVRSRV_PROCESS_STATS lock (psProcessStats->hLock) has already been taken */
+static void
+_IncreaseProcStatValueUnlocked(PVRSRV_PROCESS_STATS* psProcessStats,
+                               PVRSRV_MEM_ALLOC_TYPE eAllocType,
+                               size_t uiBytes)
 {
-#if defined(PVRSRV_ENABLE_MEMORY_STATS)
-	IMG_PID				   currentCleanupPid = PVRSRVGetPurgeConnectionPid();
-	PVRSRV_DATA*		   psPVRSRVData = PVRSRVGetPVRSRVData();
-	PVRSRV_MEM_ALLOC_REC*  psRecord = NULL;
-	PVRSRV_PROCESS_STATS*  psProcessStats;
-	__maybe_unused PVRSRV_PROC_SEARCH_STATE eProcSearch = PVRSRV_PROC_FOUND;
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-	IMG_UINT64 ui64InitialSize;
-#endif
-
-	/* Don't do anything if we are not initialised or we are shutting down! */
-	if (!bProcessStatsInitialised)
-	{
-#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
-		PVR_DPF((PVR_DBG_WARNING,
-				 "%s: Called when process statistics module is not initialised",
-				 __func__));
-#endif
-		return;
-	}
-
-	/*
-	 * To prevent a recursive loop, we make the memory allocations for our
-	 * memstat records via OSAllocMemNoStats(), which does not try to
-	 * create a memstat record entry.
-	 */
-
-	/* Allocate the memory record... */
-	psRecord = OSAllocZMemNoStats(sizeof(PVRSRV_MEM_ALLOC_REC));
-	if (psRecord == NULL)
-	{
-		return;
-	}
-
-	psRecord->eAllocType       = eAllocType;
-	psRecord->pvCpuVAddr       = pvCpuVAddr;
-	psRecord->sCpuPAddr.uiAddr = sCpuPAddr.uiAddr;
-	psRecord->uiBytes          = uiBytes;
-
-#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS_ON)
-	psRecord->pvAllocdFromFile = pvAllocFromFile;
-	psRecord->ui32AllocdFromLine = ui32AllocFromLine;
-#endif
-
-	_increase_global_stat(eAllocType, uiBytes);
-	/* Lock while we find the correct process... */
-	OSLockAcquire(g_psLinkedListLock);
-
-	if (psPVRSRVData)
-	{
-		if ((currentPid == psPVRSRVData->cleanupThreadPid) &&
-		    (currentCleanupPid != 0))
-		{
-			psProcessStats = _FindProcessStats(currentCleanupPid);
-		}
-		else
-		{
-			psProcessStats = _FindProcessStatsInLiveList(currentPid);
-			if (!psProcessStats)
-			{
-				psProcessStats = _FindProcessStatsInDeadList(currentPid);
-				eProcSearch = PVRSRV_PROC_RESURRECTED;
-			}
-		}
-	}
-	else
-	{
-		psProcessStats = _FindProcessStatsInLiveList(currentPid);
-		if (!psProcessStats)
-		{
-			psProcessStats = _FindProcessStatsInDeadList(currentPid);
-			eProcSearch = PVRSRV_PROC_RESURRECTED;
-		}
-	}
-
-	if (psProcessStats == NULL)
-	{
-		eProcSearch = PVRSRV_PROC_NOTFOUND;
-
-#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
-		PVR_DPF((PVR_DBG_MESSAGE,
-				 "%s: Process stat increment called for 'unknown' process PID(%d)",
-				 __func__, currentPid));
-
-		if (_AllocateProcessStats(&psProcessStats, currentPid) != PVRSRV_OK)
-		{
-			OSLockRelease(g_psLinkedListLock);
-			PVR_DPF((PVR_DBG_ERROR,
-			        "%s UNABLE TO CREATE process_stats entry for pid %d [%s] (" IMG_SIZE_FMTSPEC " bytes)",
-			        __func__, currentPid, OSGetCurrentProcessName(), uiBytes));
-			goto free_record;
-		}
-
-		/* Add it to the live list... */
-		dllist_add_to_head(&gsLiveList, &psProcessStats->sNode);
-
-		OSLockRelease(g_psLinkedListLock);
-
-#else /* defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS) */
-		OSLockRelease(g_psLinkedListLock);
-		goto free_record;
-#endif /* defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS) */
-	}
-	else
-	{
-#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
-		if (eProcSearch == PVRSRV_PROC_RESURRECTED)
-		{
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "%s: Process stat incremented on 'dead' process PID(%d)",
-				 __func__, currentPid));
-			/* Move process from dead list to live list */
-			_MoveProcessToLiveList(psProcessStats);
-		}
-#endif
-		OSLockRelease(g_psLinkedListLock);
-	}
-
-	OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
-
-#if defined(PVRSRV_ENABLE_MEMORY_STATS)
-	{
-		IMG_UINT64 ui64Key;
-
-		if (eAllocType == PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA
-			|| eAllocType == PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES
-			|| eAllocType == PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-			|| eAllocType == PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES
-			|| eAllocType == PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES
-#endif
-			)
-		{
-			ui64Key = psRecord->sCpuPAddr.uiAddr;
-		}
-		else
-		{
-			ui64Key = (IMG_UINT64)psRecord->pvCpuVAddr;
-		}
-
-		/* Insert the memory record... */
-		if (!HASH_Insert(psProcessStats->psMemoryRecords, ui64Key, (uintptr_t)psRecord))
-		{
-			PVR_DPF((PVR_DBG_ERROR,
-					 "%s UNABLE TO CREATE mem stats record for pid %d [%s] (" IMG_SIZE_FMTSPEC " bytes)",
-					 __func__, currentPid, OSGetCurrentProcessName(), uiBytes));
-		}
-	}
-#endif
-
 #if defined(ENABLE_GPU_MEM_TRACEPOINT)
-	ui64InitialSize = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
+	IMG_UINT64 ui64InitialSize = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
 #endif
 
 	/* Update the memory watermarks... */
@@ -1628,6 +1608,22 @@ PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 		}
 		break;
 
+		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT:
+		{
+			INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT, uiBytes);
+			psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+		}
+		break;
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE:
+		{
+			INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE, uiBytes);
+			psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+		}
+		break;
+#endif
+
 		default:
 		{
 			PVR_ASSERT(0);
@@ -1641,49 +1637,405 @@ PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 		IMG_UINT64 ui64Size = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
 		if (ui64Size != ui64InitialSize)
 		{
-			TracepointUpdateGPUMemPerProcess(0, psProcessStats->pid, ui64Size);
+			TracepointUpdateGPUMemPerProcess(0, psProcessStats->pid,
+			                                 ui64Size);
 		}
 	}
 #endif
+}
 
-	OSLockRelease(psProcessStats->hLock);
-
-	return;
-
-free_record:
-	_decrease_global_stat(eAllocType, uiBytes);
-	if (psRecord != NULL)
-	{
-		OSFreeMemNoStats(psRecord);
-	}
-#endif /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
-} /* PVRSRVStatsAddMemAllocRecord */
-
-void
-PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
-								IMG_UINT64 ui64Key,
-								IMG_PID currentPid)
+/* Assumes PVRSRV_PROCESS_STATS lock (psProcessStats->hLock) has already been taken */
+static void
+_DecreaseProcStatValueUnlocked(PVRSRV_MEM_ALLOC_TYPE eAllocType,
+                               PVRSRV_PROCESS_STATS* psProcessStats,
+                               IMG_UINT64 uiBytes)
 {
-#if defined(PVRSRV_ENABLE_MEMORY_STATS)
-	IMG_PID				   currentCleanupPid = PVRSRVGetPurgeConnectionPid();
-	PVRSRV_DATA*		   psPVRSRVData = PVRSRVGetPVRSRVData();
-	PVRSRV_PROCESS_STATS*  psProcessStats = NULL;
-	PVRSRV_MEM_ALLOC_REC*  psRecord		  = NULL;
-	IMG_BOOL			   bFound	      = IMG_FALSE;
-
-	/* Don't do anything if we are not initialised or we are shutting down! */
-	if (!bProcessStatsInitialised)
-	{
-#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
-		PVR_DPF((PVR_DBG_WARNING,
-				 "%s: Called when process statistics module is not initialised",
-				 __func__));
+#if defined(ENABLE_GPU_MEM_TRACEPOINT)
+	IMG_UINT64 ui64InitialSize = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
 #endif
-		return;
-	}
 
-	/* Lock while we find the correct process and remove this record... */
-	OSLockAcquire(g_psLinkedListLock);
+	switch (eAllocType)
+	{
+		case PVRSRV_MEM_ALLOC_TYPE_KMALLOC:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_KMALLOC, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_KMALLOC] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_KMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_VMALLOC:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMALLOC, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_VMALLOC] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_UMA:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_VMAP_PT_UMA:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+#endif
+
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES, uiBytes);
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+#endif
+
+		case PVRSRV_MEM_ALLOC_TYPE_MAP_UMA_LMA_PAGES:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE:
+		{
+			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE, uiBytes);
+			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE] == 0)
+			{
+				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
+			}
+		}
+		break;
+#endif
+
+		default:
+		{
+			PVR_ASSERT(0);
+		}
+		break;
+	}
+
+#if defined(ENABLE_GPU_MEM_TRACEPOINT)
+	if (psProcessStats->pid != PVR_SYS_ALLOC_PID)
+	{
+		IMG_UINT64 ui64Size = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
+		if (ui64Size != ui64InitialSize)
+		{
+			TracepointUpdateGPUMemPerProcess(0, psProcessStats->pid, ui64Size);
+		}
+	}
+#endif
+}
+
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+static INLINE IMG_BOOL
+_CheckKeyPhysAddr(PVRSRV_MEM_ALLOC_TYPE eAllocType)
+{
+	switch (eAllocType)
+	{
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA:
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES:
+		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES:
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES:
+		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES:
+#endif
+			return IMG_TRUE;
+		default:
+			return IMG_FALSE;
+	}
+}
+#endif
+
+void
+PVRSRVStatsAddMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
+							 void *pvCpuVAddr,
+							 IMG_CPU_PHYADDR sCpuPAddr,
+							 size_t uiBytes,
+							 IMG_PID currentPid
+							 DEBUG_MEMSTATS_PARAMS)
+{
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+	IMG_PID				   currentCleanupPid = PVRSRVGetPurgeConnectionPid();
+	PVRSRV_DATA*		   psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_MEM_ALLOC_REC*  psRecord = NULL;
+	PVRSRV_PROCESS_STATS*  psProcessStats;
+	__maybe_unused PVRSRV_PROC_SEARCH_STATE eProcSearch = PVRSRV_PROC_FOUND;
+
+	/* Don't do anything if we are not initialised or we are shutting down! */
+	if (!bProcessStatsInitialised)
+	{
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
+		PVR_DPF((PVR_DBG_WARNING,
+				 "%s: Called when process statistics module is not initialised",
+				 __func__));
+#endif
+		return;
+	}
+
+	/*
+	 * To prevent a recursive loop, we make the memory allocations for our
+	 * memstat records via OSAllocMemNoStats(), which does not try to
+	 * create a memstat record entry.
+	 */
+
+	/* Allocate the memory record... */
+	psRecord = OSAllocZMemNoStats(sizeof(PVRSRV_MEM_ALLOC_REC));
+	if (psRecord == NULL)
+	{
+		return;
+	}
+
+	psRecord->eAllocType       = eAllocType;
+	psRecord->pvCpuVAddr       = pvCpuVAddr;
+	psRecord->sCpuPAddr.uiAddr = sCpuPAddr.uiAddr;
+	psRecord->uiBytes          = uiBytes;
+
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS_ON)
+	psRecord->pvAllocdFromFile = pvAllocFromFile;
+	psRecord->ui32AllocdFromLine = ui32AllocFromLine;
+#endif
+
+	_increase_global_stat(eAllocType, uiBytes);
+	/* Lock while we find the correct process... */
+	OSLockAcquire(g_psLinkedListLock);
+
+	if (psPVRSRVData)
+	{
+		if ((currentPid == psPVRSRVData->cleanupThreadPid) &&
+		    (currentCleanupPid != 0))
+		{
+			psProcessStats = _FindProcessStats(currentCleanupPid);
+		}
+		else
+		{
+			psProcessStats = _FindProcessStatsInLiveList(currentPid);
+			if (!psProcessStats)
+			{
+				psProcessStats = _FindProcessStatsInDeadList(currentPid);
+				eProcSearch = PVRSRV_PROC_RESURRECTED;
+			}
+		}
+	}
+	else
+	{
+		psProcessStats = _FindProcessStatsInLiveList(currentPid);
+		if (!psProcessStats)
+		{
+			psProcessStats = _FindProcessStatsInDeadList(currentPid);
+			eProcSearch = PVRSRV_PROC_RESURRECTED;
+		}
+	}
+
+	if (psProcessStats == NULL)
+	{
+		eProcSearch = PVRSRV_PROC_NOTFOUND;
+
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
+		PVR_DPF((PVR_DBG_MESSAGE,
+				 "%s: Process stat increment called for 'unknown' process PID(%d)",
+				 __func__, currentPid));
+
+		if (_AllocateProcessStats(&psProcessStats, currentPid) != PVRSRV_OK)
+		{
+			OSLockRelease(g_psLinkedListLock);
+			PVR_DPF((PVR_DBG_ERROR,
+			        "%s UNABLE TO CREATE process_stats entry for pid %d [%s] (" IMG_SIZE_FMTSPEC " bytes)",
+			        __func__, currentPid, OSGetCurrentProcessName(), uiBytes));
+			goto free_record;
+		}
+
+		/* Add it to the live list... */
+		dllist_add_to_head(&gsLiveList, &psProcessStats->sNode);
+
+		OSLockRelease(g_psLinkedListLock);
+
+#else /* defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS) */
+		OSLockRelease(g_psLinkedListLock);
+		goto free_record;
+#endif /* defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS) */
+	}
+	else
+	{
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
+		if (eProcSearch == PVRSRV_PROC_RESURRECTED)
+		{
+			PVR_DPF((PVR_DBG_MESSAGE,
+				 "%s: Process stat incremented on 'dead' process PID(%d)",
+				 __func__, currentPid));
+			/* Move process from dead list to live list */
+			_MoveProcessToLiveList(psProcessStats);
+		}
+#endif
+		OSLockRelease(g_psLinkedListLock);
+	}
+
+	OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
+
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+	{
+		IMG_UINT64 ui64Key;
+
+		if (_CheckKeyPhysAddr(eAllocType))
+		{
+			ui64Key = psRecord->sCpuPAddr.uiAddr;
+		}
+		else
+		{
+			ui64Key = (IMG_UINT64)psRecord->pvCpuVAddr;
+		}
+
+		/* Insert the memory record... */
+		if (!HASH_Insert(psProcessStats->psMemoryRecords, ui64Key, (uintptr_t)psRecord))
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+					 "%s UNABLE TO CREATE mem stats record for pid %d [%s] (" IMG_SIZE_FMTSPEC " bytes)",
+					 __func__, currentPid, OSGetCurrentProcessName(), uiBytes));
+		}
+	}
+#endif
+
+	/* Update the memory watermarks... */
+	_IncreaseProcStatValueUnlocked(psProcessStats,
+	                               eAllocType,
+	                               uiBytes);
+
+	OSLockRelease(psProcessStats->hLock);
+
+	return;
+
+free_record:
+	_decrease_global_stat(eAllocType, uiBytes);
+	if (psRecord != NULL)
+	{
+		OSFreeMemNoStats(psRecord);
+	}
+#else /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
+	PVR_UNREFERENCED_PARAMETER(eAllocType);
+	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
+	PVR_UNREFERENCED_PARAMETER(sCpuPAddr);
+	PVR_UNREFERENCED_PARAMETER(uiBytes);
+	PVR_UNREFERENCED_PARAMETER(currentPid);
+#endif /* defined(PVRSRV_ENABLE_MEMORY_STATS) */
+} /* PVRSRVStatsAddMemAllocRecord */
+
+void
+PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
+								IMG_UINT64 ui64Key,
+								IMG_PID currentPid)
+{
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+	IMG_PID				   currentCleanupPid = PVRSRVGetPurgeConnectionPid();
+	PVRSRV_DATA*		   psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_PROCESS_STATS*  psProcessStats = NULL;
+	PVRSRV_MEM_ALLOC_REC*  psRecord		  = NULL;
+	IMG_BOOL			   bFound	      = IMG_FALSE;
+
+	/* Don't do anything if we are not initialised or we are shutting down! */
+	if (!bProcessStatsInitialised)
+	{
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
+		PVR_DPF((PVR_DBG_WARNING,
+				 "%s: Called when process statistics module is not initialised",
+				 __func__));
+#endif
+		return;
+	}
+
+	/* Lock while we find the correct process and remove this record... */
+	OSLockAcquire(g_psLinkedListLock);
 
 	if (psPVRSRVData)
 	{
@@ -1755,16 +2107,16 @@ PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 		}
 	}
 
-	/* Update the watermark and remove this record...*/
+	/* Update the watermark and remove this record... */
 	if (bFound)
 	{
 		_decrease_global_stat(eAllocType, psRecord->uiBytes);
 
 		OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
 
-		_DecreaseProcStatValue(eAllocType,
-		                       psProcessStats,
-		                       psRecord->uiBytes);
+		_DecreaseProcStatValueUnlocked(eAllocType,
+		                               psProcessStats,
+		                               psRecord->uiBytes);
 
 		OSLockRelease(psProcessStats->hLock);
 		OSLockRelease(g_psLinkedListLock);
@@ -1793,11 +2145,137 @@ PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 	}
 
 #else
-PVR_UNREFERENCED_PARAMETER(eAllocType);
-PVR_UNREFERENCED_PARAMETER(ui64Key);
+	PVR_UNREFERENCED_PARAMETER(eAllocType);
+	PVR_UNREFERENCED_PARAMETER(ui64Key);
+	PVR_UNREFERENCED_PARAMETER(currentPid);
 #endif
 } /* PVRSRVStatsRemoveMemAllocRecord */
 
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+void
+PVRSRVStatsTransferMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eCurrentType,
+                                  PVRSRV_MEM_ALLOC_TYPE eTargetType,
+                                  IMG_UINT64 ui64Key,
+                                  IMG_PID currentPid
+                                  DEBUG_MEMSTATS_PARAMS)
+{
+#if defined(PVRSRV_ENABLE_MEMORY_STATS)
+	IMG_PID				   currentCleanupPid = PVRSRVGetPurgeConnectionPid();
+	PVRSRV_DATA*		   psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_PROCESS_STATS*  psProcessStats = NULL;
+	PVRSRV_MEM_ALLOC_REC*  psRecord		  = NULL;
+	IMG_BOOL			   bFound	      = IMG_FALSE;
+
+	/* Don't do anything if we are not initialised or we are shutting down! */
+	if (!bProcessStatsInitialised)
+	{
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
+		PVR_DPF((PVR_DBG_WARNING,
+				 "%s: Called when process statistics module is not initialised",
+				 __func__));
+#endif
+		return;
+	}
+
+	if (_CheckKeyPhysAddr(eCurrentType) != _CheckKeyPhysAddr(eTargetType))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "Key type used for current type must match target type, "
+		                        "Record transfer failed!"));
+		return;
+	}
+
+	/* Lock while we find the correct process and remove this record... */
+	OSLockAcquire(g_psLinkedListLock);
+
+	if (psPVRSRVData)
+	{
+		if ((currentPid == psPVRSRVData->cleanupThreadPid) &&
+		    (currentCleanupPid != 0))
+		{
+			psProcessStats = _FindProcessStats(currentCleanupPid);
+		}
+		else
+		{
+			psProcessStats = _FindProcessStats(currentPid);
+		}
+	}
+	else
+	{
+		psProcessStats = _FindProcessStats(currentPid);
+	}
+
+	if (psProcessStats != NULL)
+	{
+		OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
+		psRecord = (PVRSRV_MEM_ALLOC_REC*)HASH_Remove(psProcessStats->psMemoryRecords, ui64Key);
+		OSLockRelease(psProcessStats->hLock);
+		bFound = psRecord != NULL;
+	}
+
+	/* If not found, we need to do a full search in case it was allocated to a different PID... */
+	if (!bFound)
+	{
+		PVRSRV_PROCESS_STATS* psProcessStatsAlreadyChecked = psProcessStats;
+		DLLIST_NODE *psNode, *psNext;
+
+		/* Search all live lists first... */
+		dllist_foreach_node(&gsLiveList, psNode, psNext)
+		{
+			psProcessStats = IMG_CONTAINER_OF(psNode, PVRSRV_PROCESS_STATS, sNode);
+			if (psProcessStats != psProcessStatsAlreadyChecked)
+			{
+				OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
+				psRecord = (PVRSRV_MEM_ALLOC_REC*)HASH_Remove(psProcessStats->psMemoryRecords, ui64Key);
+				OSLockRelease(psProcessStats->hLock);
+				bFound = psRecord != NULL;
+			}
+
+			if (bFound)
+			{
+				break;
+			}
+		}
+	}
+
+	if (bFound)
+	{
+		/* Update the current type watermark by reducing */
+		_decrease_global_stat(eCurrentType, psRecord->uiBytes);
+
+		OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
+
+		_DecreaseProcStatValueUnlocked(eCurrentType,
+		                               psProcessStats,
+		                               psRecord->uiBytes);
+
+		/* Change the type of the record */
+		psRecord->eAllocType = eTargetType;
+#if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS_ON)
+		/* Adjust where the record transfer originated */
+		psRecord->pvAllocdFromFile = pvAllocFromFile;
+		psRecord->ui32AllocdFromLine = ui32AllocFromLine;
+#endif
+
+		/* Update the target watermark by increasing */
+		_IncreaseProcStatValueUnlocked(psProcessStats,
+		                               eTargetType,
+		                               psRecord->uiBytes);
+		OSLockRelease(psProcessStats->hLock);
+
+		_increase_global_stat(eTargetType, psRecord->uiBytes);
+	}
+
+	OSLockRelease(g_psLinkedListLock);
+
+#else
+PVR_UNREFERENCED_PARAMETER(eCurrentType);
+PVR_UNREFERENCED_PARAMETER(eTargetType);
+PVR_UNREFERENCED_PARAMETER(ui64Key);
+PVR_UNREFERENCED_PARAMETER(currentPid);
+#endif
+}
+#endif /* defined(SUPPORT_PMR_DEFERRED_FREE) */
+
 void
 PVRSRVStatsIncrMemAllocStatAndTrack(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 									size_t uiBytes,
@@ -1859,9 +2337,6 @@ PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 	PVRSRV_DATA*		  psPVRSRVData = PVRSRVGetPVRSRVData();
 	PVRSRV_PROCESS_STATS* psProcessStats = NULL;
 	__maybe_unused PVRSRV_PROC_SEARCH_STATE eProcSearch = PVRSRV_PROC_FOUND;
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-	IMG_UINT64 ui64InitialSize;
-#endif
 
 	/* Don't do anything if we are not initialised or we are shutting down! */
 	if (!bProcessStatsInitialised)
@@ -1948,314 +2423,13 @@ PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 		 */
 		OSLockRelease(g_psLinkedListLock);
 
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-		ui64InitialSize = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
-#endif
-
 		/* Update the memory watermarks... */
-		switch (eAllocType)
-		{
-			case PVRSRV_MEM_ALLOC_TYPE_KMALLOC:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_KMALLOC, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_KMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_VMALLOC:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMALLOC, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_UMA:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_VMAP_PT_UMA:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-			case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-#endif
-
-			case PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-			case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES, uiBytes);
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-#endif
-
-			case PVRSRV_MEM_ALLOC_TYPE_MAP_UMA_LMA_PAGES:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-			case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-			case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE:
-			{
-				INCREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE, uiBytes);
-				psProcessStats->ui32StatAllocFlags |= (IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-			break;
-#endif
-
-			default:
-			{
-				PVR_ASSERT(0);
-			}
-			break;
-		}
-
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-		if (psProcessStats->pid != PVR_SYS_ALLOC_PID)
-		{
-			IMG_UINT64 ui64Size = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
-			if (ui64Size != ui64InitialSize)
-			{
-				TracepointUpdateGPUMemPerProcess(0, psProcessStats->pid,
-				                                 ui64Size);
-			}
-		}
-#endif
+		_IncreaseProcStatValueUnlocked(psProcessStats,
+		                               eAllocType,
+		                               uiBytes);
 
 		OSLockRelease(psProcessStats->hLock);
 	}
-
-}
-
-static void
-_DecreaseProcStatValue(PVRSRV_MEM_ALLOC_TYPE eAllocType,
-                       PVRSRV_PROCESS_STATS* psProcessStats,
-                       IMG_UINT64 uiBytes)
-{
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-	IMG_UINT64 ui64InitialSize = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
-#endif
-
-	switch (eAllocType)
-	{
-		case PVRSRV_MEM_ALLOC_TYPE_KMALLOC:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_KMALLOC, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_KMALLOC] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_KMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_VMALLOC:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMALLOC, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_VMALLOC] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMALLOC-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_UMA:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_VMAP_PT_UMA:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_VMAP_PT_UMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_PAGES_PT_LMA:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_PAGES_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_IOREMAP_PT_LMA:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_IOREMAP_PT_LMA-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_LMA_PAGES:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_LMA_PAGES:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-#endif
-
-		case PVRSRV_MEM_ALLOC_TYPE_ALLOC_UMA_PAGES:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-		case PVRSRV_MEM_ALLOC_TYPE_ZOMBIE_UMA_PAGES:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES, uiBytes);
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_TOTAL, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_ZOMBIE_UMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-#endif
-
-		case PVRSRV_MEM_ALLOC_TYPE_MAP_UMA_LMA_PAGES:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_MAP_UMA_LMA_PAGES-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_IMPORT:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_IMPORT-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-
-#if defined(SUPPORT_PMR_DEFERRED_FREE)
-		case PVRSRV_MEM_ALLOC_TYPE_DMA_BUF_ZOMBIE:
-		{
-			DECREASE_STAT_VALUE(psProcessStats, PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE, uiBytes);
-			if (psProcessStats->i64StatValue[PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE] == 0)
-			{
-				psProcessStats->ui32StatAllocFlags &= ~(IMG_UINT32)(1 << (PVRSRV_PROCESS_STAT_TYPE_DMA_BUF_ZOMBIE-PVRSRV_PROCESS_STAT_TYPE_KMALLOC));
-			}
-		}
-		break;
-#endif
-
-		default:
-		{
-			PVR_ASSERT(0);
-		}
-		break;
-	}
-
-#if defined(ENABLE_GPU_MEM_TRACEPOINT)
-	if (psProcessStats->pid != PVR_SYS_ALLOC_PID)
-	{
-		IMG_UINT64 ui64Size = GET_GPUMEM_PERPID_STAT_VALUE(psProcessStats);
-		if (ui64Size != ui64InitialSize)
-		{
-			TracepointUpdateGPUMemPerProcess(0, psProcessStats->pid, ui64Size);
-		}
-	}
-#endif
 }
 
 #if defined(PVRSRV_ENABLE_MEMTRACK_STATS_FILE)
@@ -2351,9 +2525,9 @@ _StatsDecrMemTrackedStat(_PVR_STATS_TRACKING_HASH_ENTRY *psTrackingHashEntry,
 	{
 		OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
 		/* Decrement the memory stat... */
-		_DecreaseProcStatValue(eAllocType,
-		                       psProcessStats,
-		                       psTrackingHashEntry->uiSizeInBytes);
+		_DecreaseProcStatValueUnlocked(eAllocType,
+		                               psProcessStats,
+		                               psTrackingHashEntry->uiSizeInBytes);
 		OSLockRelease(psProcessStats->hLock);
 	}
 
@@ -2426,9 +2600,9 @@ PVRSRVStatsDecrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 		 */
 		OSLockRelease(g_psLinkedListLock);
 		/* Update the memory watermarks... */
-		_DecreaseProcStatValue(eAllocType,
-		                       psProcessStats,
-		                       uiBytes);
+		_DecreaseProcStatValueUnlocked(eAllocType,
+		                               psProcessStats,
+		                               uiBytes);
 		OSLockRelease(psProcessStats->hLock);
 
 #if defined(PVRSRV_DEBUG_LINUX_MEMORY_STATS)
@@ -2720,9 +2894,12 @@ ProcessStatsPrintElements(OSDI_IMPL_ENTRY *psEntry,
 {
 	IMG_UINT32 ui32StatNumber;
 
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+	RILockAcquireKM();
+#endif
 	OSLockAcquireNested(psProcessStats->hLock, PROCESS_LOCK_SUBCLASS_CURRENT);
 
-	DIPrintf(psEntry, "PID %u\n", psProcessStats->pid);
+	DIPrintf(psEntry, "PID %u - %s\n", psProcessStats->pid, psProcessStats->processName);
 
 	/* Print device stats table PVRSRV_DEVICE_STAT_TYPE */
 	if (psProcessStats->ui32DevCount > 0)
@@ -2769,7 +2946,7 @@ ProcessStatsPrintElements(OSDI_IMPL_ENTRY *psEntry,
 			    (ui32StatNumber == PVRSRV_PROCESS_STAT_TYPE_ALLOC_UMA_PAGES))
 			{
 				/* get the stat from RI */
-				IMG_INT32 ui32Total = RITotalAllocProcessKM(psProcessStats->pid,
+				IMG_INT32 ui32Total = RITotalAllocProcessUnlocked(psProcessStats->pid,
 									    (ui32StatNumber == PVRSRV_PROCESS_STAT_TYPE_ALLOC_LMA_PAGES)
 									    ? PHYS_HEAP_TYPE_LMA : PHYS_HEAP_TYPE_UMA);
 
@@ -2798,6 +2975,9 @@ ProcessStatsPrintElements(OSDI_IMPL_ENTRY *psEntry,
 	}
 
 	OSLockRelease(psProcessStats->hLock);
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+	RILockReleaseKM();
+#endif
 } /* ProcessStatsPrintElements */
 #endif
 
@@ -2880,7 +3060,7 @@ CacheOpStatsPrintElements(OSDI_IMPL_ENTRY *psEntry,
 		"%-10s %-10s %-5s 0x%-8llx 0x%-8llx %-12llu\n"
 #endif
 
-	DIPrintf(psEntry, "PID %u\n", psProcessStats->pid);
+	DIPrintf(psEntry, "PID %u - %s\n", psProcessStats->pid, psProcessStats->processName);
 
 	/* File header info */
 	DIPrintf(psEntry,
@@ -3132,7 +3312,7 @@ int GlobalStatsPrintElements(OSDI_IMPL_ENTRY *psEntry, void *pvData)
 	{
 		if (OSStringNCompare(pszDriverStatType[ui32StatNumber], "", 1) != 0)
 		{
-			DIPrintf(psEntry, "%-34s%12llu\n",
+			DIPrintf(psEntry, "%-34s%12" IMG_UINT64_FMTSPEC "\n",
 				    pszDriverStatType[ui32StatNumber],
 				    GET_GLOBAL_STAT_VALUE(ui32StatNumber));
 		}
diff --git a/drivers/gpu/drm/img-rogue/process_stats.h b/drivers/gpu/drm/img-rogue/process_stats.h
index 5b5539e7f0aa..c410736e1749 100644
--- a/drivers/gpu/drm/img-rogue/process_stats.h
+++ b/drivers/gpu/drm/img-rogue/process_stats.h
@@ -103,8 +103,6 @@ PVRSRV_ERROR PVRSRVStatsDeviceConnect(PVRSRV_DEVICE_NODE *psDeviceNode);
 
 void PVRSRVStatsDeviceDisconnect(PVRSRV_DEVICE_NODE *psDeviceNode);
 
-#define MAX_POWER_STAT_ENTRIES		51
-
 /*
  * Functions for recording the statistics...
  */
@@ -120,6 +118,14 @@ void PVRSRVStatsRemoveMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 									 IMG_UINT64 ui64Key,
 									 IMG_PID uiPid);
 
+#if defined(SUPPORT_PMR_DEFERRED_FREE)
+void PVRSRVStatsTransferMemAllocRecord(PVRSRV_MEM_ALLOC_TYPE eCurrentType,
+                                       PVRSRV_MEM_ALLOC_TYPE eTargetType,
+                                       IMG_UINT64 ui64Key,
+                                       IMG_PID currentPid
+                                       DEBUG_MEMSTATS_PARAMS);
+#endif
+
 void PVRSRVStatsIncrMemAllocStat(PVRSRV_MEM_ALLOC_TYPE eAllocType,
 								 size_t uiBytes,
 								 IMG_PID uiPid);
diff --git a/drivers/gpu/drm/img-rogue/pvr_bridge.h b/drivers/gpu/drm/img-rogue/pvr_bridge.h
index 7afdaa856fe5..dafc51dd57f0 100644
--- a/drivers/gpu/drm/img-rogue/pvr_bridge.h
+++ b/drivers/gpu/drm/img-rogue/pvr_bridge.h
@@ -94,9 +94,6 @@ extern "C" {
 #include "common_validation_bridge.h"
 #endif
 
-#if defined(PVR_TESTING_UTILS)
-#include "common_tutils_bridge.h"
-#endif
 
 #include "common_devicememhistory_bridge.h"
 #include "common_synctracking_bridge.h"
@@ -272,13 +269,8 @@ extern "C" {
 
 /*  18: TUTILS interface functions */
 #define PVRSRV_BRIDGE_TUTILS				18UL
-#if defined(PVR_TESTING_UTILS)
-#define PVRSRV_BRIDGE_TUTILS_DISPATCH_FIRST (PVRSRV_BRIDGE_VALIDATION_DISPATCH_LAST + 1)
-#define PVRSRV_BRIDGE_TUTILS_DISPATCH_LAST  (PVRSRV_BRIDGE_TUTILS_DISPATCH_FIRST + PVRSRV_BRIDGE_TUTILS_CMD_LAST)
-#else
 #define PVRSRV_BRIDGE_TUTILS_DISPATCH_FIRST 0
 #define PVRSRV_BRIDGE_TUTILS_DISPATCH_LAST  (PVRSRV_BRIDGE_VALIDATION_DISPATCH_LAST)
-#endif
 
 /*  19: DevMem history interface functions */
 #define PVRSRV_BRIDGE_DEVICEMEMHISTORY		19UL
@@ -390,12 +382,6 @@ static const IMG_UINT32 gui32PVRBridges =
 	| (1U << (PVRSRV_BRIDGE_PVRTL - PVRSRV_BRIDGE_FIRST))
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
 	| (1U << (PVRSRV_BRIDGE_RI - PVRSRV_BRIDGE_FIRST))
-#endif
-#if defined(SUPPORT_VALIDATION)
-	| (1U << (PVRSRV_BRIDGE_VALIDATION - PVRSRV_BRIDGE_FIRST))
-#endif
-#if defined(PVR_TESTING_UTILS)
-	| (1U << (PVRSRV_BRIDGE_TUTILS - PVRSRV_BRIDGE_FIRST))
 #endif
 	| (1U << (PVRSRV_BRIDGE_DEVICEMEMHISTORY - PVRSRV_BRIDGE_FIRST))
 #if defined(PVRSRV_ENABLE_HTB)
diff --git a/drivers/gpu/drm/img-rogue/pvr_bridge_k.c b/drivers/gpu/drm/img-rogue/pvr_bridge_k.c
index 2c23f57eee92..77739189b0aa 100644
--- a/drivers/gpu/drm/img-rogue/pvr_bridge_k.c
+++ b/drivers/gpu/drm/img-rogue/pvr_bridge_k.c
@@ -79,6 +79,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "srvcore.h"
 #include "common_srvcore_bridge.h"
+#include "kernel_compatibility.h"
 
 PVRSRV_ERROR InitDMABUFBridge(void);
 void DeinitDMABUFBridge(void);
@@ -106,9 +107,6 @@ static ATOMIC_T g_iNumActiveDriverThreads;
 static ATOMIC_T g_iNumActiveKernelThreads;
 static IMG_HANDLE g_hDriverThreadEventObject;
 
-#if defined(PVR_TESTING_UTILS)
-#include "pvrsrv.h"
-#endif
 
 #if defined(DEBUG_BRIDGE_KM)
 static DI_ENTRY *gpsDIBridgeStatsEntry;
@@ -239,6 +237,17 @@ static IMG_INT64 BridgeStatsWrite(const IMG_CHAR *pcBuffer,
 
 #endif /* defined(DEBUG_BRIDGE_KM) */
 
+PVRSRV_ERROR LinuxGetThreadActivityStats(LINUX_THREAD_ACTIVITY_STATS *psThreadStats)
+{
+	PVR_RETURN_IF_FALSE(psThreadStats != NULL, PVRSRV_ERROR_INVALID_PARAMS);
+
+	psThreadStats->i32KernelThreadCount = OSAtomicRead(&g_iNumActiveKernelThreads);
+	psThreadStats->i32DriverThreadCount = OSAtomicRead(&g_iNumActiveDriverThreads);
+	psThreadStats->i32SuspendedThreadCount = OSAtomicRead(&g_iDriverSuspendCount);
+
+	return PVRSRV_OK;
+}
+
 PVRSRV_ERROR OSPlatformBridgeInit(void)
 {
 	PVRSRV_ERROR eError;
@@ -252,7 +261,7 @@ PVRSRV_ERROR OSPlatformBridgeInit(void)
 
 	eError = OSEventObjectCreate("Global driver thread event object",
 	                             &g_hDriverThreadEventObject);
-	PVR_LOG_GOTO_IF_ERROR(eError, "OSEventObjectCreate", error_);
+	PVR_LOG_GOTO_IF_ERROR(eError, "OSEventObjectCreate", EventCreateError);
 
 #if defined(DEBUG_BRIDGE_KM)
 	{
@@ -271,17 +280,18 @@ PVRSRV_ERROR OSPlatformBridgeInit(void)
 		                       &g_BridgeDispatchTable[0],
 		                       DI_ENTRY_TYPE_GENERIC,
 		                       &gpsDIBridgeStatsEntry);
-		PVR_LOG_GOTO_IF_ERROR(eError, "DICreateEntry", error_);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DICreateEntry", DIEntryCreateError);
 	}
 #endif
 
 	return PVRSRV_OK;
 
-error_:
-	if (g_hDriverThreadEventObject) {
-		OSEventObjectDestroy(g_hDriverThreadEventObject);
-		g_hDriverThreadEventObject = NULL;
-	}
+#if defined(DEBUG_BRIDGE_KM)
+DIEntryCreateError:
+#endif
+EventCreateError:
+	OSEventObjectDestroy(g_hDriverThreadEventObject);
+	g_hDriverThreadEventObject = NULL;
 
 	return eError;
 }
@@ -289,18 +299,13 @@ PVRSRV_ERROR OSPlatformBridgeInit(void)
 void OSPlatformBridgeDeInit(void)
 {
 #if defined(DEBUG_BRIDGE_KM)
-	if (gpsDIBridgeStatsEntry != NULL)
-	{
-		DIDestroyEntry(gpsDIBridgeStatsEntry);
-	}
+	DIDestroyEntry(gpsDIBridgeStatsEntry);
 #endif
 
-	DeinitDMABUFBridge();
+	OSEventObjectDestroy(g_hDriverThreadEventObject);
+	g_hDriverThreadEventObject = NULL;
 
-	if (g_hDriverThreadEventObject != NULL) {
-		OSEventObjectDestroy(g_hDriverThreadEventObject);
-		g_hDriverThreadEventObject = NULL;
-	}
+	DeinitDMABUFBridge();
 }
 
 PVRSRV_ERROR LinuxBridgeBlockClientsAccess(struct pvr_drm_private *psDevPriv,
@@ -308,7 +313,7 @@ PVRSRV_ERROR LinuxBridgeBlockClientsAccess(struct pvr_drm_private *psDevPriv,
 {
 	PVRSRV_ERROR eError;
 	IMG_HANDLE hEvent;
-	IMG_INT iSuspendCount;
+	__maybe_unused IMG_INT iSuspendCount;
 
 	eError = OSEventObjectOpen(g_hDriverThreadEventObject, &hEvent);
 	if (eError != PVRSRV_OK)
@@ -362,7 +367,7 @@ PVRSRV_ERROR LinuxBridgeBlockClientsAccess(struct pvr_drm_private *psDevPriv,
 PVRSRV_ERROR LinuxBridgeUnblockClientsAccess(struct pvr_drm_private *psDevPriv)
 {
 	PVRSRV_ERROR eError;
-	IMG_INT iSuspendCount;
+	__maybe_unused IMG_INT iSuspendCount;
 
 	/* resume the driver and then signal so any waiting threads wake up */
 	if (OSAtomicCompareExchange(&psDevPriv->suspended, _SUSPENDED,
@@ -460,13 +465,6 @@ PVRSRV_ERROR PVRSRVDriverThreadEnter(void *pvData)
 		PVRSRVBlockIfFrozen(psDevNode);
 		OSAtomicIncrement(&psDevNode->iThreadsActive);
 	}
-#if defined(PVR_TESTING_UTILS)
-	else
-	{
-		PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-		OSAtomicIncrement(&psPVRSRVData->iNumDriverTasksActive);
-	}
-#endif	/* defined(PVR_TESTING_UTILS) */
 
 	/* increment first so there is no race between this value and
 	 * g_iDriverSuspendCount in LinuxBridgeBlockClientsAccess() */
@@ -607,6 +605,16 @@ PVRSRV_MMap(struct file *pFile, struct vm_area_struct *ps_vma)
 	}
 
 	mutex_lock(&g_sMMapMutex);
+
+	/* Forcibly clear the VM_MAYWRITE flag as this is inherited from the
+	 * kernel mmap code and we do not want to produce a potentially writable
+	 * mapping from a read-only mapping.
+	 */
+	if (!BITMASK_HAS(ps_vma->vm_flags, VM_WRITE))
+	{
+		pvr_vm_flags_clear(ps_vma, VM_MAYWRITE);
+	}
+
 	/* Note: PMRMMapPMR will take a reference on the PMR.
 	 * Unref the handle immediately, because we have now done
 	 * the required operation on the PMR (whether it succeeded or not)
diff --git a/drivers/gpu/drm/img-rogue/pvr_bridge_k.h b/drivers/gpu/drm/img-rogue/pvr_bridge_k.h
index e6464efae23e..2885dd465eaf 100644
--- a/drivers/gpu/drm/img-rogue/pvr_bridge_k.h
+++ b/drivers/gpu/drm/img-rogue/pvr_bridge_k.h
@@ -48,6 +48,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_error.h"
 #include "pvr_drv.h"
 
+typedef struct LINUX_THREAD_ACTIVITY_STATS
+{
+	IMG_INT32 i32KernelThreadCount;
+	IMG_INT32 i32DriverThreadCount;
+	IMG_INT32 i32SuspendedThreadCount;
+} LINUX_THREAD_ACTIVITY_STATS;
+
 /*!
 ******************************************************************************
  @Function      LinuxBridgeBlockClientsAccess
@@ -79,6 +86,17 @@ PVRSRV_ERROR LinuxBridgeUnblockClientsAccess(struct pvr_drm_private *psDevPriv);
 void LinuxBridgeNumActiveKernelThreadsIncrement(void);
 void LinuxBridgeNumActiveKernelThreadsDecrement(void);
 
+/*************************************************************************/ /*!
+ @Function      LinuxGetThreadActivityStats
+ @Description   Getter for active and suspended thread stats.
+
+ @Output        psThreadStats   Struct to be populated with thread activity
+                                stats.
+
+ @Return        PVRSRV_ERROR
+*/ /**************************************************************************/
+PVRSRV_ERROR LinuxGetThreadActivityStats(LINUX_THREAD_ACTIVITY_STATS *psThreadStats);
+
 /*!
 ******************************************************************************
  @Function      PVRSRVDriverThreadEnter
diff --git a/drivers/gpu/drm/img-rogue/pvr_buffer_sync.c b/drivers/gpu/drm/img-rogue/pvr_buffer_sync.c
index 0dc3dffdbad8..529cafd2bcf3 100644
--- a/drivers/gpu/drm/img-rogue/pvr_buffer_sync.c
+++ b/drivers/gpu/drm/img-rogue/pvr_buffer_sync.c
@@ -77,13 +77,7 @@ struct pvr_buffer_sync_append_data {
 static struct dma_resv *
 pmr_reservation_object_get(struct _PMR_ *pmr)
 {
-	struct dma_buf *dmabuf;
-
-	dmabuf = PhysmemGetDmaBuf(pmr);
-	if (dmabuf)
-		return dmabuf->resv;
-
-	return NULL;
+	return PhysmemGetDmaResv(pmr);
 }
 
 static int
diff --git a/drivers/gpu/drm/img-rogue/pvr_counting_timeline.c b/drivers/gpu/drm/img-rogue/pvr_counting_timeline.c
index 3fa890316dcc..240872e0b0fd 100644
--- a/drivers/gpu/drm/img-rogue/pvr_counting_timeline.c
+++ b/drivers/gpu/drm/img-rogue/pvr_counting_timeline.c
@@ -145,6 +145,12 @@ struct pvr_counting_fence_timeline *pvr_counting_fence_timeline_create(
 	if (!timeline->context)
 		goto err_free_timeline;
 
+	timeline->current_value = 0;
+	timeline->next_value = 1;
+	kref_init(&timeline->kref);
+	spin_lock_init(&timeline->active_fences_lock);
+	INIT_LIST_HEAD(&timeline->active_fences);
+
 	srv_err = PVRSRVRegisterDriverDbgRequestNotify(
 				&timeline->dbg_request_handle,
 				pvr_counting_fence_timeline_debug_request,
@@ -156,12 +162,6 @@ struct pvr_counting_fence_timeline *pvr_counting_fence_timeline_create(
 		goto err_free_timeline_ctx;
 	}
 
-	timeline->current_value = 0;
-	timeline->next_value = 1;
-	kref_init(&timeline->kref);
-	spin_lock_init(&timeline->active_fences_lock);
-	INIT_LIST_HEAD(&timeline->active_fences);
-
 err_out:
 	return timeline;
 
diff --git a/drivers/gpu/drm/img-rogue/pvr_debug.c b/drivers/gpu/drm/img-rogue/pvr_debug.c
index bf529f9c6a30..cf59a2d5aa3e 100644
--- a/drivers/gpu/drm/img-rogue/pvr_debug.c
+++ b/drivers/gpu/drm/img-rogue/pvr_debug.c
@@ -42,6 +42,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ /**************************************************************************/
 
 #include <linux/sched.h>
+#include <linux/pid.h>
 #include <linux/moduleparam.h>
 
 #include "img_types.h"
@@ -99,7 +100,7 @@ AddToBufferCCB(const IMG_CHAR *pszFileName, IMG_UINT32 ui32Line,
 
 	do_gettimeofday(&gsDebugCCB[giOffset].sTimeVal);
 
-	OSStringLCopy(gsDebugCCB[giOffset].pcMesg, szBuffer,
+	OSStringSafeCopy(gsDebugCCB[giOffset].pcMesg, szBuffer,
 	              PVRSRV_DEBUG_CCB_MESG_MAX);
 
 	giOffset = (giOffset + 1) % PVRSRV_DEBUG_CCB_MAX;
@@ -161,7 +162,7 @@ void PVRSRVDebugPrintfDumpCCB(void)
 
 static IMG_UINT32 PVRDebugLevel =
 	(
-	 DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING | DBGPRIV_DEBUG
+	 DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING
 #if defined(PVRSRV_DEBUG_CCB_MAX)
 	 | DBGPRIV_BUFFERED
 #endif /* defined(PVRSRV_DEBUG_CCB_MAX) */
@@ -377,34 +378,34 @@ void PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
 	{
 		case DBGPRIV_FATAL:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Fatal): ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Fatal): ", ui32BufSiz);
 			PVRSRV_REPORT_ERROR();
 			break;
 		}
 		case DBGPRIV_ERROR:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Error): ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Error): ", ui32BufSiz);
 			PVRSRV_REPORT_ERROR();
 			break;
 		}
 		case DBGPRIV_WARNING:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Warn):  ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Warn):  ", ui32BufSiz);
 			break;
 		}
 		case DBGPRIV_MESSAGE:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Mesg):  ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Mesg):  ", ui32BufSiz);
 			break;
 		}
 		case DBGPRIV_VERBOSE:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Verb):  ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Verb):  ", ui32BufSiz);
 			break;
 		}
 		case DBGPRIV_DEBUG:
 		{
-			OSStringLCopy(pszBuf, "PVR_K:(Debug): ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K:(Debug): ", ui32BufSiz);
 			break;
 		}
 		case DBGPRIV_CALLTRACE:
@@ -412,7 +413,7 @@ void PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
 		case DBGPRIV_BUFFERED:
 		default:
 		{
-			OSStringLCopy(pszBuf, "PVR_K: ", ui32BufSiz);
+			OSStringSafeCopy(pszBuf, "PVR_K: ", ui32BufSiz);
 			break;
 		}
 	}
diff --git a/drivers/gpu/drm/img-rogue/pvr_debug.h b/drivers/gpu/drm/img-rogue/pvr_debug.h
index 2e8599fe6797..46033a0da47e 100644
--- a/drivers/gpu/drm/img-rogue/pvr_debug.h
+++ b/drivers/gpu/drm/img-rogue/pvr_debug.h
@@ -310,7 +310,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 
 	#define PVR_LOG_ERROR(_rc, _call) do \
 		{ \
-			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 			PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 		} while (false)
 
@@ -318,7 +318,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 			} \
 		MSC_SUPPRESS_4127 \
@@ -328,7 +328,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_WARNING, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_WARNING, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_WARNING, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 			} \
 		MSC_SUPPRESS_4127 \
@@ -338,7 +338,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_expr == NULL)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_OUT_OF_MEMORY, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_OUT_OF_MEMORY, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s failed (PVRSRV_ERROR_OUT_OF_MEMORY) in %s()", _call, __func__)); \
 				return PVRSRV_ERROR_OUT_OF_MEMORY; \
 			} \
@@ -349,7 +349,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_expr == NULL)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_OUT_OF_MEMORY, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_OUT_OF_MEMORY, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s failed (PVRSRV_ERROR_OUT_OF_MEMORY) in %s()", #_expr, __func__)); \
 				_err = PVRSRV_ERROR_OUT_OF_MEMORY; \
 				goto _go; \
@@ -361,7 +361,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 				return _rc; \
 			} \
@@ -372,7 +372,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 				return; \
 			} \
@@ -383,7 +383,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 				goto _go; \
 			} \
@@ -392,7 +392,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 
 	#define PVR_LOG_GOTO_WITH_ERROR(_call, _err, _rc, _go) do \
 		{ \
-			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 			PVR_DPF((PVR_DBG_ERROR, "%s() failed (%s) in %s()", _call, PVRSRVGETERRORSTRING(_rc), __func__)); \
 			_err = _rc; \
 			goto _go; \
@@ -403,7 +403,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s in %s()", _msg, __func__)); \
 			} \
 		MSC_SUPPRESS_4127 \
@@ -413,7 +413,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s in %s()", _msg, __func__)); \
 				return _rc; \
 			} \
@@ -424,7 +424,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s in %s()", _msg, __func__)); \
 				return; \
 			} \
@@ -435,7 +435,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_F, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s in %s()", _msg, __func__)); \
 				goto _go; \
 			} \
@@ -446,7 +446,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely((_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_T, PVRSRV_ERROR_UNEXPECTED_TRUE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_COND_ERROR_T, PVRSRV_ERROR_UNEXPECTED_TRUE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s in %s()", _msg, __func__)); \
 				return _rc; \
 			} \
@@ -457,7 +457,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_INVALID_PARAMS, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_INVALID_PARAMS, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, "%s invalid in %s()", _param, __func__)); \
 				return PVRSRV_ERROR_INVALID_PARAMS; \
 			} \
@@ -466,7 +466,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 
 	#define PVR_LOG_GOTO_IF_INVALID_PARAM(_expr, _err, _go) do \
 		{ if (unlikely(!(_expr))) { \
-			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_INVALID_PARAMS, __LINE__); \
+			HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_INVALID_PARAMS, HTB_FILE_NAME, __LINE__); \
 			PVR_DPF((PVR_DBG_ERROR, "%s invalid in %s()", #_expr, __func__)); \
 			_err = PVRSRV_ERROR_INVALID_PARAMS; \
 			goto _go; } \
@@ -477,11 +477,11 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (_lvl == PVR_DBG_ERROR) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_ERROR, HTB_FILE_NAME, __LINE__); \
 			} \
 			else if (_lvl == PVR_DBG_WARNING) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_WARNING, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_WARN, HTB_FILE_NAME, __LINE__); \
 			} \
 			PVR_DPF((_lvl, ("In %s() "_msg), __func__)); \
 		} while (false)
@@ -490,11 +490,11 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (_lvl == PVR_DBG_ERROR) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_ERROR, HTB_FILE_NAME, __LINE__); \
 			} \
 			else if (_lvl == PVR_DBG_WARNING) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_WARNING, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_WARN, HTB_FILE_NAME, __LINE__); \
 			} \
 			PVR_DPF((_lvl, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 		} while (false)
@@ -505,11 +505,11 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 			{ \
 				if (_lvl == PVR_DBG_ERROR) \
 				{ \
-					HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+					HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				} \
 				else if (_lvl == PVR_DBG_WARNING) \
 				{ \
-					HTBLOGK(HTB_SF_MAIN_DBG_WARNING, _rc, __LINE__); \
+					HTBLOGK(HTB_SF_MAIN_DBG_WARNING, _rc, HTB_FILE_NAME, __LINE__); \
 				} \
 				PVR_DPF((_lvl, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 			} \
@@ -522,11 +522,11 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 			{ \
 				if (_lvl == PVR_DBG_ERROR) \
 				{ \
-					HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+					HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_ERROR, HTB_FILE_NAME, __LINE__); \
 				} \
 				else if (_lvl == PVR_DBG_WARNING) \
 				{ \
-					HTBLOGK(HTB_SF_MAIN_DBG_WARNING, PVRSRV_ERROR_NOT_SUPPORTED, __LINE__); \
+					HTBLOGK(HTB_SF_MAIN_DBG_MSGLVL_WARN, HTB_FILE_NAME, __LINE__); \
 				} \
 				PVR_DPF((_lvl, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 			} \
@@ -537,7 +537,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 				return _rc; \
 			} \
@@ -548,7 +548,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(_rc != PVRSRV_OK)) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 				goto _go; \
 			} \
@@ -559,7 +559,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, ("At %s: "_msg), __func__, __VA_ARGS__)); \
 				return _rc; \
 			} \
@@ -570,7 +570,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely(!(_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, ("In %s() "_msg), __func__, __VA_ARGS__)); \
 				goto _go; \
 			} \
@@ -581,7 +581,7 @@ PVRSRVDebugAssertFail(const IMG_CHAR *pszFile,
 		{ \
 			if (unlikely((_expr))) \
 			{ \
-				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, __LINE__); \
+				HTBLOGK(HTB_SF_MAIN_DBG_ERROR, _rc, HTB_FILE_NAME, __LINE__); \
 				PVR_DPF((PVR_DBG_ERROR, ("At %s: "_msg), __func__, __VA_ARGS__)); \
 				return _rc; \
 			} \
diff --git a/drivers/gpu/drm/img-rogue/pvr_debugfs.c b/drivers/gpu/drm/img-rogue/pvr_debugfs.c
index 111e61e56b25..63c557bc8459 100644
--- a/drivers/gpu/drm/img-rogue/pvr_debugfs.c
+++ b/drivers/gpu/drm/img-rogue/pvr_debugfs.c
@@ -121,14 +121,7 @@ static void _WriteData(void *pvNativeHandle, const void *pvData,
 static void _VPrintf(void *pvNativeHandle, const IMG_CHAR *pszFmt,
                      va_list pArgs)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 	seq_vprintf(pvNativeHandle, pszFmt, pArgs);
-#else
-	IMG_CHAR szBuffer[PVR_MAX_DEBUG_MESSAGE_LEN];
-
-	vsnprintf(szBuffer, PVR_MAX_DEBUG_MESSAGE_LEN, pszFmt, pArgs);
-	seq_printf(pvNativeHandle, "%s", szBuffer);
-#endif
 }
 
 static void _Puts(void *pvNativeHandle, const IMG_CHAR *pszStr)
@@ -139,11 +132,7 @@ static void _Puts(void *pvNativeHandle, const IMG_CHAR *pszStr)
 static IMG_BOOL _HasOverflowed(void *pvNativeHandle)
 {
 	struct seq_file *psSeqFile = pvNativeHandle;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
 	return seq_has_overflowed(psSeqFile);
-#else
-	return psSeqFile->count == psSeqFile->size;
-#endif
 }
 
 static OSDI_IMPL_ENTRY_CB _g_sEntryCallbacks = {
diff --git a/drivers/gpu/drm/img-rogue/pvr_drm.c b/drivers/gpu/drm/img-rogue/pvr_drm.c
index a2c2dd62464e..7458ccb6a885 100644
--- a/drivers/gpu/drm/img-rogue/pvr_drm.c
+++ b/drivers/gpu/drm/img-rogue/pvr_drm.c
@@ -61,6 +61,7 @@
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/mutex.h>
+#include <linux/pci.h>
 
 #include "module_common.h"
 #include "pvr_drm.h"
@@ -68,13 +69,23 @@
 #include "pvrversion.h"
 #include "services_kernel_client.h"
 #include "pvr_sync_ioctl_drm.h"
+#include "physmem_dmabuf_internal.h"
 
 #include "kernel_compatibility.h"
 
+#include "dkf_server.h"
+#include "dkp_impl.h"
+
 #define PVR_DRM_DRIVER_NAME PVR_DRM_NAME
 #define PVR_DRM_DRIVER_DESC "Imagination Technologies PVR DRM"
 #define	PVR_DRM_DRIVER_DATE "20170530"
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+#define	PVR_DRM_DRIVER_PRIME 0
+#else
+#define	PVR_DRM_DRIVER_PRIME DRIVER_PRIME
+#endif
+
 /*
  * Protects global PVRSRV_DATA on a multi device system. i.e. this is used to
  * protect the PVRSRVCommonDeviceXXXX() APIs in the Server common layer which
@@ -222,10 +233,45 @@ const struct dev_pm_ops pvr_pm_ops = {
 	.restore = pvr_pm_restore,
 };
 
+#if defined(SUPPORT_LINUX_FDINFO)
+static void pvr_drm_show_drm_info(struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+	int pid, void *hPrivHandle)
+{
+	struct pvr_drm_private *priv;
+	struct drm_device *pdev;
+
+	pdev = (struct drm_device *)hPrivHandle;
+
+	/* The only field possibly valid in 'priv' is the dev_node field */
+	priv = (struct pvr_drm_private *)pdev->dev_private;
+
+	if (priv->dev_node == psDevNode) {
+
+		/* For kernels post 6.5.0 the mandatory driver fields are produced
+		 * by the 'drm_show_fdinfo' routine in the kernel.
+		 * Avoid duplicating this information here.
+		 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 5, 0))
+		PVRDKPOutput(priv->hDeviceDKPRef,
+		             "drm-driver:\t%s\n",
+		             PVR_DRM_DRIVER_NAME);
+#if defined(CONFIG_PCI)
+		if (dev_is_pci(pdev->dev)) {
+			struct pci_dev *pcidev = to_pci_dev(pdev->dev);
+
+			PVRDKPOutput(priv->hDeviceDKPRef,
+			             "drm-pdev:\t%04x:%02x:%02x.%d\n",
+			             pci_domain_nr(pcidev->bus),
+			             pcidev->bus->number,
+			             PCI_SLOT(pcidev->devfn),
+			             PCI_FUNC(pcidev->devfn));
+		}
+#endif /* defined(CONFIG_PCI) */
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(6, 5, 0) */
+	}
+}
+#endif	/* SUPPORT_LINUX_FDINFO */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-static
-#endif
 int pvr_drm_load(struct drm_device *ddev, unsigned long flags)
 {
 	struct pvr_drm_private *priv;
@@ -236,18 +282,10 @@ int pvr_drm_load(struct drm_device *ddev, unsigned long flags)
 
 	dev_set_drvdata(ddev->dev, ddev);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0))
-	/*
-	 * Older kernels do not have render drm_minor member in drm_device,
-	 * so we fallback to primary node for device identification
-	 */
-	deviceId = ddev->primary->index;
-#else
 	if (ddev->render)
 		deviceId = ddev->render->index;
 	else /* when render node is NULL, fallback to primary node */
 		deviceId = ddev->primary->index;
-#endif
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
@@ -293,12 +331,29 @@ int pvr_drm_load(struct drm_device *ddev, unsigned long flags)
 	}
 #endif
 
+#if defined(SUPPORT_LINUX_FDINFO)
+	srv_err = PVRSRVRegisterDKP(ddev,
+	                            "drm-pvr-drm",
+	                            pvr_drm_show_drm_info,
+	                            DKP_CONNECTION_FLAG_ALL,
+	                            &priv->hDeviceDKPRef);
+
+	if (srv_err != PVRSRV_OK) {
+		err = -ENODEV;
+		DRM_ERROR("device %p initialisation failed (err=%d)\n",
+				  ddev->dev, err);
+		goto err_device_deinit;
+	}
+#endif
+
 	mutex_unlock(&g_device_mutex);
 
 	return 0;
 
-#if (PVRSRV_DEVICE_INIT_MODE == PVRSRV_LINUX_DEV_INIT_ON_PROBE)
+#if defined(SUPPORT_LINUX_FDINFO) || (PVRSRV_DEVICE_INIT_MODE == PVRSRV_LINUX_DEV_INIT_ON_PROBE)
 err_device_deinit:
+#endif
+#if (PVRSRV_DEVICE_INIT_MODE == PVRSRV_LINUX_DEV_INIT_ON_PROBE)
 	drm_mode_config_cleanup(ddev);
 	PVRSRVDeviceDeinit(priv->dev_node);
 #endif
@@ -313,9 +368,6 @@ int pvr_drm_load(struct drm_device *ddev, unsigned long flags)
 	return err;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
-static
-#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
 int pvr_drm_unload(struct drm_device *ddev)
 #else
@@ -337,6 +389,10 @@ void pvr_drm_unload(struct drm_device *ddev)
 	if (ddev->dev->dma_parms == &priv->dma_parms)
 		ddev->dev->dma_parms = NULL;
 
+#if defined(SUPPORT_LINUX_FDINFO)
+	PVRSRVUnRegisterDKP(ddev, priv->hDeviceDKPRef);
+#endif
+
 	kfree(priv);
 	ddev->dev_private = NULL;
 
@@ -377,23 +433,25 @@ static void pvr_drm_release(struct drm_device *ddev, struct drm_file *dfile)
 	module_put(THIS_MODULE);
 }
 
-/*
- * The DRM global lock is taken for ioctls unless the DRM_UNLOCKED flag is set.
- */
 static struct drm_ioctl_desc pvr_drm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(PVR_SRVKM_CMD, PVRSRV_BridgeDispatchKM,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(PVR_SRVKM_INIT, drm_pvr_srvkm_init,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
 #if defined(SUPPORT_NATIVE_FENCE_SYNC) && !defined(USE_PVRSYNC_DEVNODE)
 	DRM_IOCTL_DEF_DRV(PVR_SYNC_RENAME_CMD, pvr_sync_rename_ioctl,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(PVR_SYNC_FORCE_SW_ONLY_CMD, pvr_sync_force_sw_only_ioctl,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(PVR_SW_SYNC_CREATE_FENCE_CMD, pvr_sw_sync_create_fence_ioctl,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(PVR_SW_SYNC_INC_CMD, pvr_sw_sync_inc_ioctl,
-			  DRM_RENDER_ALLOW | DRM_UNLOCKED),
+			  DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(PVR_EXP_FENCE_SYNC_FORCE_CMD, pvr_sync_ioctl_force_exp_only,
+			  DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(PVR_SYNC_CREATE_EXPORT_FENCE_CMD,
+			  pvr_export_fence_sync_create_fence_ioctl,
+			  DRM_RENDER_ALLOW),
 #endif
 };
 
@@ -410,6 +468,43 @@ static long pvr_compat_ioctl(struct file *file, unsigned int cmd,
 }
 #endif /* defined(CONFIG_COMPAT) */
 
+#if defined(SUPPORT_LINUX_FDINFO)
+/*
+ * Produce the PVR specific fdinfo (utilization figures etc.) when queried.
+ *
+ * For kernels post 6.5 there is a helper function called 'drm_show_fdinfo'
+ * which will generate the mandatory keys (drm-driver, drm-pdev, drm-client-id)
+ * so we do not need to generate these if running on a later kernel etc.
+ *
+ */
+static void pvr_show_fdinfo(struct seq_file *seq_file, struct file *file)
+{
+	struct drm_file *dfile = file->private_data;
+	struct drm_device *dev = dfile->minor->dev;
+	struct drm_printer p = drm_seq_file_printer(seq_file);
+	PVRSRV_CONNECTION_PRIV *pvr_connection = dfile->driver_priv;
+	struct pvr_drm_private *priv;
+	int my_pid;
+
+	/* Grab the PID from the associated drm_file->pid->numbers[0].nr */
+	my_pid = dfile->pid->numbers[0].nr;
+
+	priv = (struct pvr_drm_private *)dev->dev_private;
+
+	/* Generate driver-specific keys */
+	PVRDKFTraverse((DKF_VPRINTF_FUNC*)drm_vprintf,
+	               &p,
+	               priv->dev_node,
+	               my_pid,
+	               pvr_connection->ui32Type);
+
+	/* Call into OS-specific drm_show_fdinfo if it is supported */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 5, 0))
+	drm_show_fdinfo(seq_file, file);
+#endif	/* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 5, 0) */
+}
+#endif /* SUPPORT_LINUX_FDINFO */
+
 const struct file_operations pvr_drm_fops = {
 	.owner			= THIS_MODULE,
 	.open			= drm_open,
@@ -421,24 +516,29 @@ const struct file_operations pvr_drm_fops = {
 	.mmap			= PVRSRV_MMap,
 	.poll			= drm_poll,
 	.read			= drm_read,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0))
-	.fasync			= drm_fasync,
-#endif
+#if defined(SUPPORT_LINUX_FDINFO)
+	.show_fdinfo	= pvr_show_fdinfo,
+#endif /* SUPPORT_LINUX_FDINFO */
 };
 
 const struct drm_driver pvr_drm_generic_driver = {
-	.driver_features	= DRIVER_MODESET | DRIVER_RENDER,
+	.driver_features	= DRIVER_MODESET | DRIVER_RENDER |
+				  DRIVER_GEM | PVR_DRM_DRIVER_PRIME,
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	.load			= NULL,
 	.unload			= NULL,
-#else
-	.load			= pvr_drm_load,
-	.unload			= pvr_drm_unload,
-#endif
 	.open			= pvr_drm_open,
 	.postclose		= pvr_drm_release,
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0))
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	/* prime_fd_to_handle is not supported */
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0))
+	.gem_prime_export	= PhysmemGEMPrimeExport,
+	.gem_free_object	= PhysmemGEMObjectFree,
+#endif
 	.ioctls			= pvr_drm_ioctls,
 	.num_ioctls		= ARRAY_SIZE(pvr_drm_ioctls),
 	.fops			= &pvr_drm_fops,
diff --git a/drivers/gpu/drm/img-rogue/pvr_drm.h b/drivers/gpu/drm/img-rogue/pvr_drm.h
index c0d00c98d8c0..bc76ddf9b597 100644
--- a/drivers/gpu/drm/img-rogue/pvr_drm.h
+++ b/drivers/gpu/drm/img-rogue/pvr_drm.h
@@ -85,12 +85,18 @@ struct pvr_sw_sync_create_fence_data {
 	__u64 sync_pt_idx;
 };
 
+typedef struct pvr_sw_sync_create_fence_data pvr_exp_sync_create_fence_data_t;
+
 struct pvr_sw_timeline_advance_data {
 	__u64 sync_pt_idx;
 };
 
 #define PVR_SRVKM_SERVICES_INIT  1
 #define PVR_SRVKM_SYNC_INIT 2
+#define PVR_SRVKM_SYNC_EXP_FENCE_INIT 3
+#if defined(SUPPORT_LINUX_OSPAGE_MIGRATION)
+#define PVR_SRVKM_SERVICES_PAGE_MIGRATE_INIT 4
+#endif
 struct drm_pvr_srvkm_init_data {
 	__u32 init_module;
 };
@@ -119,6 +125,10 @@ struct drm_pvr_srvkm_init_data {
 /* PVR Services Render Device Init command */
 #define DRM_PVR_SRVKM_INIT		5
 
+/* PVR Services Export Fence Sync commands */
+#define DRM_PVR_EXP_FENCE_SYNC_FORCE_CMD	6
+#define DRM_PVR_SYNC_CREATE_EXPORT_FENCE_CMD	7
+
 /* These defines must be prefixed with "DRM_IOCTL_". */
 #define	DRM_IOCTL_PVR_SRVKM_CMD	\
 	DRM_IOWR(DRM_COMMAND_BASE + DRM_PVR_SRVKM_CMD, \
@@ -143,4 +153,12 @@ struct drm_pvr_srvkm_init_data {
 	DRM_IOW(DRM_COMMAND_BASE + DRM_PVR_SRVKM_INIT, \
 		struct drm_pvr_srvkm_init_data)
 
+#define DRM_IOCTL_PVR_EXP_FENCE_SYNC_FORCE_CMD \
+	DRM_IOWR(DRM_COMMAND_BASE + DRM_PVR_EXP_FENCE_SYNC_FORCE_CMD, \
+		pvr_exp_sync_create_fence_data_t)
+
+#define DRM_IOCTL_PVR_SYNC_CREATE_EXPORT_FENCE_CMD \
+	DRM_IOWR(DRM_COMMAND_BASE + DRM_PVR_SYNC_CREATE_EXPORT_FENCE_CMD, \
+		pvr_exp_sync_create_fence_data_t)
+
 #endif /* defined(__PVR_DRM_H__) */
diff --git a/drivers/gpu/drm/img-rogue/pvr_drv.h b/drivers/gpu/drm/img-rogue/pvr_drv.h
index ee4fdf44259c..827145d60c50 100644
--- a/drivers/gpu/drm/img-rogue/pvr_drv.h
+++ b/drivers/gpu/drm/img-rogue/pvr_drv.h
@@ -90,20 +90,24 @@ struct pvr_drm_private {
 	 * the OS called suspend on this device.
 	 */
 	atomic_t suspended;
+
+	/* Padding for 8-byte alignment */
+	unsigned int uiPad1;
+
+	/* Handle associated with DKP for this DRM device */
+	void *hDeviceDKPRef;
 };
 
 extern const struct dev_pm_ops pvr_pm_ops;
 extern const struct drm_driver pvr_drm_generic_driver;
 extern const struct file_operations pvr_drm_fops;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 int pvr_drm_load(struct drm_device *ddev, unsigned long flags);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
 int pvr_drm_unload(struct drm_device *ddev);
 #else
 void pvr_drm_unload(struct drm_device *ddev);
 #endif
-#endif
 
 int PVRSRV_BridgeDispatchKM(struct drm_device *dev, void *arg,
 			    struct drm_file *file);
diff --git a/drivers/gpu/drm/img-rogue/pvr_export_fence.c b/drivers/gpu/drm/img-rogue/pvr_export_fence.c
new file mode 100644
index 000000000000..9a192b1b6fd1
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/pvr_export_fence.c
@@ -0,0 +1,472 @@
+/*
+ * @File
+ * @Codingstyle LinuxKernel
+ * @Copyright   Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+ * @License     Dual MIT/GPLv2
+ *
+ * The contents of this file are subject to the MIT license as set out below.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License Version 2 ("GPL") in which case the provisions
+ * of GPL are applicable instead of those above.
+ *
+ * If you wish to allow use of your version of this file only under the terms of
+ * GPL, and not to allow others to use your version of this file under the terms
+ * of the MIT license, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by GPL as set
+ * out in the file called "GPL-COPYING" included in this distribution. If you do
+ * not delete the provisions above, a recipient may use your version of this file
+ * under the terms of either the MIT license or GPL.
+ *
+ * This License is also included in this distribution in the file called
+ * "MIT-COPYING".
+ *
+ * EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+ * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ * PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock_types.h>
+#include <linux/atomic.h>
+#include <linux/slab.h>
+#include <linux/printk.h>
+#include <linux/bug.h>
+
+#include "pvr_export_fence.h"
+#include "osfunc_common.h"
+
+struct pvr_exp_fence_context {
+	struct kref kref;
+	unsigned int context;
+	char context_name[32];
+	char driver_name[32];
+	atomic_t seqno;
+	atomic_t fence_count;
+
+	void *cmd_complete_handle;
+
+	/* lock for signal and fence lists */
+	spinlock_t list_lock;
+	struct list_head signal_list;
+	struct list_head fence_list;
+};
+
+struct pvr_exp_fence {
+	struct dma_fence base;
+	struct pvr_exp_fence_context *fence_context;
+	PSYNC_CHECKPOINT checkpoint_handle;
+	/* dma_fence fd (needed for hwperf) */
+	int fd;
+	/* Lock for the dma fence */
+	spinlock_t lock;
+	/* fence will point to the dma_fence in base */
+	struct dma_fence *fence;
+	struct list_head fence_head;
+	struct list_head signal_head;
+};
+
+#define PVR_DUMPDEBUG_LOG(pfnDumpDebugPrintf, pvDumpDebugFile, fmt, ...) \
+	do {                                                             \
+		if (pfnDumpDebugPrintf)                                  \
+			pfnDumpDebugPrintf(pvDumpDebugFile, fmt,         \
+					   ## __VA_ARGS__);              \
+		else                                                     \
+			pr_err(fmt "\n", ## __VA_ARGS__);                \
+	} while (0)
+
+static inline bool
+pvr_exp_fence_sync_is_signaled(struct pvr_exp_fence *exp_fence, u32 fence_sync_flags)
+{
+	if (exp_fence->checkpoint_handle) {
+		return SyncCheckpointIsSignalled(exp_fence->checkpoint_handle,
+						 fence_sync_flags);
+	}
+	return false;
+}
+
+const char *pvr_exp_fence_context_name(struct pvr_exp_fence_context *fctx)
+{
+	return fctx->context_name;
+}
+
+void pvr_exp_fence_context_value_str(struct pvr_exp_fence_context *fctx,
+				    char *str, int size)
+{
+	snprintf(str, size, "%d", atomic_read(&fctx->seqno));
+}
+
+static void
+pvr_exp_fence_context_fences_dump(struct pvr_exp_fence_context *fctx,
+				  DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+				  void *pvDumpDebugFile)
+{
+	unsigned long flags;
+	char value[128];
+
+	spin_lock_irqsave(&fctx->list_lock, flags);
+	pvr_exp_fence_context_value_str(fctx, value, sizeof(value));
+	PVR_DUMPDEBUG_LOG(pfnDumpDebugPrintf, pvDumpDebugFile,
+			 "exp_fence_ctx: @%s", value);
+	spin_unlock_irqrestore(&fctx->list_lock, flags);
+}
+
+static inline unsigned
+pvr_exp_fence_context_seqno_next(struct pvr_exp_fence_context *fence_context)
+{
+	if (fence_context)
+		return atomic_inc_return(&fence_context->seqno) - 1;
+	else
+		return 0xfeedface;
+}
+
+static void
+pvr_exp_fence_context_signal_fences(void *data)
+{
+	struct pvr_exp_fence_context *fctx = (struct pvr_exp_fence_context *)data;
+	struct pvr_exp_fence *pvr_exp_fence, *tmp;
+	unsigned long flags1;
+	int chkpt_ct = 0;
+	int chkpt_sig_ct = 0;
+
+	LIST_HEAD(signal_list);
+
+	/*
+	 * We can't call fence_signal while holding the lock as we can end up
+	 * in a situation whereby pvr_fence_foreign_signal_sync, which also
+	 * takes the list lock, ends up being called as a result of the
+	 * fence_signal below, i.e. fence_signal(fence) -> fence->callback()
+	 *  -> fence_signal(foreign_fence) -> foreign_fence->callback() where
+	 * the foreign_fence callback is pvr_fence_foreign_signal_sync.
+	 *
+	 * So extract the items we intend to signal and add them to their own
+	 * queue.
+	 */
+	spin_lock_irqsave(&fctx->list_lock, flags1);
+	list_for_each_entry_safe(pvr_exp_fence, tmp, &fctx->signal_list, signal_head) {
+		chkpt_ct++;
+		if (pvr_exp_fence_sync_is_signaled(pvr_exp_fence, PVRSRV_FENCE_FLAG_SUPPRESS_HWP_PKT)) {
+			chkpt_sig_ct++;
+			list_move_tail(&pvr_exp_fence->signal_head, &signal_list);
+		}
+	}
+	spin_unlock_irqrestore(&fctx->list_lock, flags1);
+
+	list_for_each_entry_safe(pvr_exp_fence, tmp, &signal_list, signal_head) {
+		spin_lock_irqsave(&pvr_exp_fence->fence_context->list_lock, flags1);
+		list_del(&pvr_exp_fence->signal_head);
+		spin_unlock_irqrestore(&pvr_exp_fence->fence_context->list_lock, flags1);
+		dma_fence_signal(pvr_exp_fence->fence);
+		dma_fence_put(pvr_exp_fence->fence);
+	}
+}
+
+static const char *pvr_exp_fence_get_driver_name(struct dma_fence *fence)
+{
+	struct pvr_exp_fence *pvr_exp_fence = to_pvr_exp_fence(fence);
+
+	if (pvr_exp_fence && pvr_exp_fence->fence_context)
+		return pvr_exp_fence->fence_context->driver_name;
+	else
+		return "***NO_DRIVER***";
+}
+
+static const char *pvr_exp_fence_get_timeline_name(struct dma_fence *fence)
+{
+	struct pvr_exp_fence *pvr_exp_fence = to_pvr_exp_fence(fence);
+
+	if (pvr_exp_fence && pvr_exp_fence->fence_context)
+		return pvr_exp_fence_context_name(pvr_exp_fence->fence_context);
+	else
+		return "***NO_TIMELINE***";
+}
+
+static void pvr_exp_fence_value_str(struct dma_fence *fence, char *str, int size)
+{
+	snprintf(str, size, "%llu", (u64) fence->seqno);
+}
+
+static void pvr_exp_fence_timeline_value_str(struct dma_fence *fence,
+					    char *str, int size)
+{
+	struct pvr_exp_fence *pvr_exp_fence = to_pvr_exp_fence(fence);
+
+	if (pvr_exp_fence && pvr_exp_fence->fence_context)
+		pvr_exp_fence_context_value_str(pvr_exp_fence->fence_context, str, size);
+}
+
+static bool pvr_exp_fence_enable_signaling(struct dma_fence *fence)
+{
+	struct pvr_exp_fence *exp_fence = to_pvr_exp_fence(fence);
+	unsigned long flags;
+
+	if (!exp_fence)
+		return false;
+
+	if (pvr_exp_fence_sync_is_signaled(exp_fence, PVRSRV_FENCE_FLAG_SUPPRESS_HWP_PKT))
+		return false;
+
+	dma_fence_get(&exp_fence->base);
+
+	spin_lock_irqsave(&exp_fence->fence_context->list_lock, flags);
+	list_add_tail(&exp_fence->signal_head, &exp_fence->fence_context->signal_list);
+	spin_unlock_irqrestore(&exp_fence->fence_context->list_lock, flags);
+
+	return true;
+}
+
+static void pvr_exp_fence_context_destroy_kref(struct kref *kref)
+{
+	struct pvr_exp_fence_context *fence_context =
+		container_of(kref, struct pvr_exp_fence_context, kref);
+	unsigned int fence_count;
+
+	if (WARN_ON(!list_empty_careful(&fence_context->fence_list)))
+		pvr_exp_fence_context_fences_dump(fence_context, NULL, NULL);
+
+	PVRSRVUnregisterCmdCompleteNotify(fence_context->cmd_complete_handle);
+
+	fence_count = atomic_read(&fence_context->fence_count);
+	if (WARN_ON(fence_count))
+		pr_debug("%s context has %u fence(s) remaining\n",
+			 fence_context->context_name, fence_count);
+
+	kfree(fence_context);
+}
+
+static void pvr_exp_fence_release(struct dma_fence *fence)
+{
+	struct pvr_exp_fence *pvr_exp_fence = to_pvr_exp_fence(fence);
+	unsigned long flags;
+
+	if (pvr_exp_fence) {
+		if (pvr_exp_fence->fence_context) {
+			spin_lock_irqsave(&pvr_exp_fence->fence_context->list_lock, flags);
+			list_del(&pvr_exp_fence->fence_head);
+			atomic_dec(&pvr_exp_fence->fence_context->fence_count);
+			spin_unlock_irqrestore(&pvr_exp_fence->fence_context->list_lock, flags);
+
+			kref_put(&pvr_exp_fence->fence_context->kref,
+				 pvr_exp_fence_context_destroy_kref);
+		}
+
+		if (pvr_exp_fence->checkpoint_handle) {
+			SyncCheckpointFree(pvr_exp_fence->checkpoint_handle);
+			pvr_exp_fence->checkpoint_handle = NULL;
+		}
+
+		kfree(pvr_exp_fence);
+	}
+}
+
+static const struct dma_fence_ops pvr_exp_fence_ops = {
+	.get_driver_name = pvr_exp_fence_get_driver_name,
+	.get_timeline_name = pvr_exp_fence_get_timeline_name,
+	.fence_value_str = pvr_exp_fence_value_str,
+	.timeline_value_str = pvr_exp_fence_timeline_value_str,
+	.enable_signaling = pvr_exp_fence_enable_signaling,
+	.wait = dma_fence_default_wait,
+	.release = pvr_exp_fence_release,
+};
+
+struct pvr_exp_fence_context *
+pvr_exp_fence_context_create(const char *context_name, const char *driver_name)
+{
+	struct pvr_exp_fence_context *fence_context;
+	PVRSRV_ERROR srv_err;
+
+	fence_context = kzalloc(sizeof(*fence_context), GFP_KERNEL);
+	if (!fence_context)
+		return NULL;
+
+	fence_context->context = dma_fence_context_alloc(1);
+	OSStringSafeCopy(fence_context->context_name, context_name,
+		sizeof(fence_context->context_name));
+	OSStringSafeCopy(fence_context->driver_name, driver_name,
+		sizeof(fence_context->driver_name));
+	atomic_set(&fence_context->seqno, 0);
+	atomic_set(&fence_context->fence_count, 0);
+	kref_init(&fence_context->kref);
+
+	spin_lock_init(&fence_context->list_lock);
+	INIT_LIST_HEAD(&fence_context->signal_list);
+	INIT_LIST_HEAD(&fence_context->fence_list);
+
+	srv_err = PVRSRVRegisterCmdCompleteNotify(&fence_context->cmd_complete_handle,
+				pvr_exp_fence_context_signal_fences,
+				fence_context);
+	if (srv_err != PVRSRV_OK) {
+		pr_err("%s: failed to register command complete callback (%s)\n",
+		       __func__, PVRSRVGetErrorString(srv_err));
+		kfree(fence_context);
+		return NULL;
+	}
+
+	return fence_context;
+}
+
+void pvr_exp_fence_context_destroy(struct pvr_exp_fence_context *fence_context)
+{
+	if (fence_context) {
+		kref_put(&fence_context->kref, pvr_exp_fence_context_destroy_kref);
+	}
+}
+
+struct dma_fence *
+pvr_exp_fence_create(struct pvr_exp_fence_context *fence_context, int fd, u64 *sync_pt_idx)
+{
+	struct pvr_exp_fence *pvr_exp_fence;
+	unsigned long flags;
+	unsigned int seqno;
+	struct pvr_exp_fence_context *pfence_context = fence_context;
+
+	if (WARN_ON(!fence_context))
+		return NULL;
+
+	pvr_exp_fence = kzalloc(sizeof(*pvr_exp_fence), GFP_KERNEL);
+	if (WARN_ON(!pvr_exp_fence))
+		return NULL;
+
+	spin_lock_init(&pvr_exp_fence->lock);
+
+	INIT_LIST_HEAD(&pvr_exp_fence->fence_head);
+	INIT_LIST_HEAD(&pvr_exp_fence->signal_head);
+
+	pvr_exp_fence->fence_context = pfence_context;
+
+	/* No sync checkpoint is assigned until attached to a kick */
+	pvr_exp_fence->checkpoint_handle = NULL;
+
+	seqno = pvr_exp_fence_context_seqno_next(pfence_context);
+
+	pvr_exp_fence->fence = &pvr_exp_fence->base;
+
+	dma_fence_init(&pvr_exp_fence->base, &pvr_exp_fence_ops,
+		       &pvr_exp_fence->lock, pfence_context->context, seqno);
+
+	atomic_inc(&pfence_context->fence_count);
+
+	spin_lock_irqsave(&fence_context->list_lock, flags);
+	list_add_tail(&pvr_exp_fence->fence_head, &fence_context->fence_list);
+	spin_unlock_irqrestore(&fence_context->list_lock, flags);
+
+	kref_get(&pfence_context->kref);
+
+	pvr_exp_fence->fd = fd;
+
+	*sync_pt_idx = pvr_exp_fence_context_seqno_next(pfence_context);
+
+	return &pvr_exp_fence->base;
+}
+
+enum PVRSRV_ERROR_TAG
+pvr_exp_fence_assign_checkpoint(PVRSRV_FENCE fence_to_resolve,
+				struct dma_fence *fence,
+				PSYNC_CHECKPOINT_CONTEXT checkpoint_context,
+				PSYNC_CHECKPOINT *assigned_checkpoint)
+{
+	struct SYNC_CHECKPOINT_TAG *new_sync_checkpoint;
+	struct pvr_exp_fence *pvr_exp_fence;
+	PVRSRV_FENCE export_fence_fd = fence_to_resolve;
+	PVRSRV_ERROR err;
+
+	pvr_exp_fence = to_pvr_exp_fence(fence);
+	if (!pvr_exp_fence)	{
+		pr_err("%s: Invalid fence_to_resolve\n", __func__);
+		err = PVRSRV_ERROR_INVALID_PARAMS;
+		goto err_out;
+	}
+
+	if (pvr_exp_fence->checkpoint_handle) {
+		/* export fence already has a sync checkpoint assigned */
+		*assigned_checkpoint = pvr_exp_fence->checkpoint_handle;
+		return PVRSRV_OK;
+	}
+
+	/* Ensure fd assigned to export fence when it was created is passed
+	 * to SyncCheckpointAlloc() (so correct fd is used in HWPerf event)
+	 * as the export fence may only be part of the check fence.
+	 */
+	if (pvr_exp_fence->fd != PVRSRV_NO_FENCE) {
+		export_fence_fd = pvr_exp_fence->fd;
+	}
+
+	err = SyncCheckpointAlloc(checkpoint_context,
+				  PVRSRV_NO_TIMELINE, export_fence_fd,
+				  fence->ops->get_timeline_name(fence), &new_sync_checkpoint);
+	if (unlikely(err != PVRSRV_OK)) {
+		pr_err("%s: SyncCheckpointAlloc() failed (err%d)\n",
+		       __func__, err);
+		*assigned_checkpoint = NULL;
+		goto err_out;
+	}
+
+	pvr_exp_fence->checkpoint_handle = new_sync_checkpoint;
+	*assigned_checkpoint = new_sync_checkpoint;
+	return PVRSRV_OK;
+
+err_out:
+	return err;
+}
+
+enum PVRSRV_ERROR_TAG
+pvr_exp_fence_rollback(struct dma_fence *fence)
+{
+	struct pvr_exp_fence *pvr_exp_fence;
+	PVRSRV_ERROR err;
+
+	pvr_exp_fence = to_pvr_exp_fence(fence);
+	if (!pvr_exp_fence) {
+		pr_err("%s: Invalid fence\n", __func__);
+		err = PVRSRV_ERROR_INVALID_PARAMS;
+		goto err_out;
+	}
+
+	if (pvr_exp_fence->checkpoint_handle) {
+		/* Free the assigned sync checkpoint */
+		SyncCheckpointFree(pvr_exp_fence->checkpoint_handle);
+		pvr_exp_fence->checkpoint_handle = NULL;
+	}
+
+	return PVRSRV_OK;
+
+err_out:
+	return err;
+}
+
+bool pvr_is_exp_fence(struct dma_fence *fence)
+{
+	return (fence->ops == &pvr_exp_fence_ops);
+}
+
+struct pvr_exp_fence *to_pvr_exp_fence(struct dma_fence *fence)
+{
+	if (pvr_is_exp_fence(fence))
+		return container_of(fence, struct pvr_exp_fence, base);
+
+	return NULL;
+}
+
+struct SYNC_CHECKPOINT_TAG *
+pvr_exp_fence_get_checkpoint(struct pvr_exp_fence *export_fence)
+{
+	if (export_fence) {
+		return export_fence->checkpoint_handle;
+	}
+	else
+		return NULL;
+}
diff --git a/drivers/gpu/drm/img-rogue/pvr_export_fence.h b/drivers/gpu/drm/img-rogue/pvr_export_fence.h
new file mode 100644
index 000000000000..0ffe8a11ce40
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/pvr_export_fence.h
@@ -0,0 +1,77 @@
+/*
+ * @File
+ * @Codingstyle LinuxKernel
+ * @Copyright   Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+ * @License     Dual MIT/GPLv2
+ *
+ * The contents of this file are subject to the MIT license as set out below.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License Version 2 ("GPL") in which case the provisions
+ * of GPL are applicable instead of those above.
+ *
+ * If you wish to allow use of your version of this file only under the terms of
+ * GPL, and not to allow others to use your version of this file under the terms
+ * of the MIT license, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by GPL as set
+ * out in the file called "GPL-COPYING" included in this distribution. If you do
+ * not delete the provisions above, a recipient may use your version of this file
+ * under the terms of either the MIT license or GPL.
+ *
+ * This License is also included in this distribution in the file called
+ * "MIT-COPYING".
+ *
+ * EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+ * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+ * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ * PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#if !defined(__PVR_EXPORT_FENCES_H__)
+#define __PVR_EXPORT_FENCES_H__
+
+#include "pvr_linux_fence.h"
+#include "services_kernel_client.h"
+
+struct pvr_exp_fence_context;
+struct pvr_exp_fence;
+
+struct pvr_exp_fence_context *pvr_exp_fence_context_create(const char *name,
+				const char *driver_name);
+void pvr_exp_fence_context_destroy(struct pvr_exp_fence_context *fence_context);
+struct dma_fence *pvr_exp_fence_create(struct pvr_exp_fence_context *fence_context,
+				       int fd,
+				       u64 *sync_pt_idx);
+
+const char *pvr_exp_fence_context_name(struct pvr_exp_fence_context *fctx);
+void pvr_exp_fence_context_value_str(struct pvr_exp_fence_context *fctx,
+				    char *str, int size);
+
+enum PVRSRV_ERROR_TAG pvr_exp_fence_assign_checkpoint(PVRSRV_FENCE fence_to_resolve,
+						      struct dma_fence *fence,
+						      PSYNC_CHECKPOINT_CONTEXT checkpoint_context,
+						      PSYNC_CHECKPOINT *assigned_checkpoint);
+
+enum PVRSRV_ERROR_TAG pvr_exp_fence_rollback(struct dma_fence *fence);
+
+bool pvr_is_exp_fence(struct dma_fence *fence);
+
+struct pvr_exp_fence *to_pvr_exp_fence(struct dma_fence *fence);
+
+struct SYNC_CHECKPOINT_TAG *
+pvr_exp_fence_get_checkpoint(struct pvr_exp_fence *export_fence);
+
+#endif /* !defined(__PVR_EXPORT_FENCES_H__) */
diff --git a/drivers/gpu/drm/img-rogue/pvr_fence.c b/drivers/gpu/drm/img-rogue/pvr_fence.c
index 52b8aeaffbfb..b707206bcbf6 100644
--- a/drivers/gpu/drm/img-rogue/pvr_fence.c
+++ b/drivers/gpu/drm/img-rogue/pvr_fence.c
@@ -49,6 +49,7 @@
 #include "pvr_fence.h"
 #include "services_kernel_client.h"
 #include "sync_checkpoint_external.h"
+#include "osfunc_common.h"
 
 #define CREATE_TRACE_POINTS
 #include "pvr_fence_trace.h"
@@ -362,7 +363,7 @@ pvr_fence_context_create_internal(struct workqueue_struct *fence_status_wq,
 	fctx->fence_wq = fence_status_wq;
 
 	fctx->fence_context = dma_fence_context_alloc(1);
-	strlcpy(fctx->name, name, sizeof(fctx->name));
+	OSStringSafeCopy(fctx->name, name, sizeof(fctx->name));
 
 	srv_err = PVRSRVRegisterCmdCompleteNotify(&fctx->cmd_complete_handle,
 				pvr_fence_context_signal_fences,
diff --git a/drivers/gpu/drm/img-rogue/pvr_fence.h b/drivers/gpu/drm/img-rogue/pvr_fence.h
index 25ecc8bb9911..fb4775d5fb16 100644
--- a/drivers/gpu/drm/img-rogue/pvr_fence.h
+++ b/drivers/gpu/drm/img-rogue/pvr_fence.h
@@ -44,13 +44,6 @@
 #if !defined(__PVR_FENCE_H__)
 #define __PVR_FENCE_H__
 
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0))
-static inline void pvr_fence_cleanup(void)
-{
-}
-#else
 #include "services_kernel_client.h"
 #include "pvr_linux_fence.h"
 #include <linux/list.h>
@@ -194,7 +187,7 @@ static inline void pvr_fence_cleanup(void)
 {
 	/*
 	 * Ensure all PVR fence contexts have been destroyed, by flushing
-	 * the global workqueue.
+	 * the context destruction workqueue.
 	 */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 36))
 	flush_workqueue(NativeSyncGetFenceCtxDestroyWq());
@@ -242,5 +235,4 @@ static inline void pvr_fence_cleanup(void)
 #define PVR_FENCE_ERR(f, fmt, ...)                                         \
 	DMA_FENCE_ERR(f, "(PVR) " fmt, ## __VA_ARGS__)
 
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)) */
 #endif /* !defined(__PVR_FENCE_H__) */
diff --git a/drivers/gpu/drm/img-rogue/pvr_fence_trace.h b/drivers/gpu/drm/img-rogue/pvr_fence_trace.h
index e2f044caad1c..95b2a0dc6c7c 100644
--- a/drivers/gpu/drm/img-rogue/pvr_fence_trace.h
+++ b/drivers/gpu/drm/img-rogue/pvr_fence_trace.h
@@ -184,7 +184,7 @@ DECLARE_EVENT_CLASS(pvr_fence_foreign,
 			fence->fence->ops->fence_value_str(
 				fence->fence, __entry->foreign_val,
 				sizeof(__entry->foreign_val)) :
-			(void) strlcpy(__entry->foreign_val,
+			(void) OSStringSafeCopy(__entry->foreign_val,
 				"unknown", sizeof(__entry->foreign_val));
 		__entry->foreign_context = fence->fence->context;
 	),
diff --git a/drivers/gpu/drm/img-rogue/pvr_gputrace.c b/drivers/gpu/drm/img-rogue/pvr_gputrace.c
index 9c04b99b709a..723e6d4d9082 100644
--- a/drivers/gpu/drm/img-rogue/pvr_gputrace.c
+++ b/drivers/gpu/drm/img-rogue/pvr_gputrace.c
@@ -42,11 +42,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include <linux/version.h>
 #include <linux/fs.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0))
 #include <linux/trace_events.h>
-#else
-#include <linux/ftrace_event.h>
-#endif
 
 #include "pvrsrv_error.h"
 #include "pvrsrv_apphint.h"
@@ -67,16 +63,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif
 
 #if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-#include "pvr_gpuwork.h"
+#define CREATE_TRACE_POINTS
+#include "gpu_work.h"
 #define TRACE_FS_CLK "/sys/kernel/tracing/trace_clock"
 #else
 #define TRACE_FS_CLK "/sys/kernel/debug/tracing/trace_clock"
 #endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-#include "pvr_gpufreq.h"
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
-
 #if defined(SUPPORT_RGX)
 #if defined(PVRSRV_FORCE_HWPERF_TO_SCHED_CLK)
 #define TRACE_CLK     RGXTIMECORR_CLOCK_SCHED
@@ -87,12 +80,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif
 #endif
 
-#if defined(PVRSRV_TRACE_ROGUE_EVENTS) || \
-    defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) || \
-    defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-#define TRACE_EVENTS_DEFINED
-#endif
-
 /******************************************************************************
  Module internal implementation
 ******************************************************************************/
@@ -151,11 +138,9 @@ static PVRSRV_ERROR _GpuTraceDisable(
 	PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 	IMG_BOOL bDeInit);
 
-#if defined(TRACE_EVENTS_DEFINED)
 static void _GpuTraceCmdCompleteNotify(PVRSRV_CMDCOMP_HANDLE);
 static void _GpuTraceProcessPackets(PVRSRV_RGXDEV_INFO *psDevInfo, void *pBuffer,
                                     IMG_UINT32 ui32ReadLen);
-#endif
 
 static void _FTrace_FWOnReaderOpenCB(void *pvArg)
 {
@@ -163,6 +148,12 @@ static void _FTrace_FWOnReaderOpenCB(void *pvArg)
 	psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_FTRACE] = IMG_FALSE;
 }
 
+static void _FTrace_FWOnReaderCloseCB(void *pvArg)
+{
+	PVRSRV_RGXDEV_INFO* psRgxDevInfo = (PVRSRV_RGXDEV_INFO*) pvArg;
+	psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_FTRACE] = IMG_TRUE;
+}
+
 /* Currently supported by default */
 #if defined(SUPPORT_TL_PRODUCER_CALLBACK)
 static PVRSRV_ERROR GPUTraceTLCB(IMG_HANDLE hStream,
@@ -279,16 +270,6 @@ PVRSRV_ERROR PVRGpuTraceSupportInit(void)
 	eError = OSLockCreate(&ghGPUTraceStateLock);
 	PVR_LOG_RETURN_IF_ERROR (eError, "OSLockCreate");
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	eError = GpuTraceWorkPeriodInitialize();
-	PVR_LOG_RETURN_IF_ERROR (eError, "GpuTraceWorkPeriodInitialize");
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
-
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-	eError = GpuTraceFreqInitialize();
-	PVR_LOG_RETURN_IF_ERROR (eError, "GpuTraceFreqInitialize");
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
-
 #if defined(SUPPORT_RGX)
 #if !defined(PVRSRV_FORCE_HWPERF_TO_SCHED_CLK)
 	PVRGpuTraceInitFTraceClockSource();
@@ -306,13 +287,6 @@ void PVRGpuTraceSupportDeInit(void)
 #endif /* !defined(PVRSRV_FORCE_HWPERF_TO_SCHED_CLK) */
 #endif /* defined(SUPPORT_RGX) */
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-	GpuTraceFreqDeInitialize();
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
-
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	GpuTraceSupportDeInitialize();
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
 	if (ghGPUTraceStateLock)
 	{
 		OSLockDestroy(ghGPUTraceStateLock);
@@ -352,6 +326,7 @@ PVRSRV_ERROR PVRGpuTraceInitStream(PVRSRV_RGXDEV_INFO *psDevInfo)
 							psDevInfo->ui32RGXL2HWPerfBufSize,
 							TL_OPMODE_DROP_NEWER | TL_FLAG_NO_SIGNAL_ON_COMMIT,
 							_FTrace_FWOnReaderOpenCB, psDevInfo,
+							_FTrace_FWOnReaderCloseCB, psDevInfo,
 #if !defined(SUPPORT_TL_PRODUCER_CALLBACK)
 							NULL, NULL
 #else
@@ -374,7 +349,7 @@ PVRSRV_ERROR PVRGpuTraceInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	RGX_HWPERF_FTRACE_DATA *psData;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	psData = OSAllocZMem(sizeof(RGX_HWPERF_FTRACE_DATA));
 	psDevInfo->pvGpuFtraceData = psData;
@@ -399,7 +374,7 @@ void PVRGpuTraceDeInitDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	RGX_HWPERF_FTRACE_DATA *psData = psDevInfo->pvGpuFtraceData;
 
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVNODE, psDeviceNode);
 	if (psData)
 	{
 		/* first disable the tracing, to free up TL resources */
@@ -470,18 +445,6 @@ void PVRGpuTraceInitIfEnabled(PVRSRV_DEVICE_NODE *psDeviceNode)
 		}
 #endif
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-		if (trace_set_clr_event("power", "gpu_frequency", 1) != 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "Failed to enable \"gpu_frequency\" event"));
-		}
-		else
-		{
-			PVR_LOG(("FTrace event from \"gpu_frequency\" enabled"));
-			bEnable = IMG_TRUE;
-		}
-#endif
-
 		if (bEnable)
 		{
 			/* this enables FTrace globally (if not enabled nothing will appear
@@ -516,18 +479,15 @@ static PVRSRV_ERROR _GpuTraceEnable(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 	}
 
 	uiFilter =
-#if defined(PVRSRV_TRACE_ROGUE_EVENTS) || defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	    RGX_HWPERF_EVENT_MASK_HW_KICKFINISH |
-#endif
 #if defined(PVRSRV_TRACE_ROGUE_EVENTS)
-	    RGX_HWPERF_EVENT_MASK_FW_SED | RGX_HWPERF_EVENT_MASK_FW_UFO |
+	    RGX_HWPERF_EVENT_MASK_HW_KICKFINISH | RGX_HWPERF_EVENT_MASK_FW_SED | RGX_HWPERF_EVENT_MASK_FW_UFO |
 #endif
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-	    RGX_HWPERF_CLKS_CHG |
+#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+            RGX_HWPERF_EVENT_MASK_VALUE(RGX_HWPERF_TRACE_EVENT_GPU_WORK_PERIOD) |
 #endif
 	    0;
 
-#if defined(SUPPORT_RGX)
+#if defined(SUPPORT_RGX) && !defined(NO_HARDWARE)
 	/* Signal FW to enable event generation */
 	if (psRgxDevInfo->bFirmwareInitialised)
 	{
@@ -556,6 +516,11 @@ static PVRSRV_ERROR _GpuTraceEnable(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	/* In case there was any data copied from the L1 buffer to the FTrace L2
+	 * buffer in the narrow window between disabling the FTrace and MISR
+	 * running, drop this data to make the ordinal tracking correct. */
+	TLStreamReset(psRgxDevInfo->hHWPerfStream[RGX_HWPERF_L2_STREAM_FTRACE]);
+
 	/* Open the TL Stream for FTrace data consumption */
 	eError = TLClientOpenStream(DIRECT_BRIDGE_HANDLE,
 								pszFTraceStreamName,
@@ -582,7 +547,6 @@ static PVRSRV_ERROR _GpuTraceEnable(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 	 */
 	psFtraceData->ui64LastSampledTimeCorrOSTimeStamp = 0;
 
-#if defined(TRACE_EVENTS_DEFINED)
 	/* Register a notifier to collect HWPerf data whenever the HW completes
 	 * an operation.
 	 */
@@ -591,13 +555,10 @@ static PVRSRV_ERROR _GpuTraceEnable(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 		&_GpuTraceCmdCompleteNotify,
 		psRgxDevInfo);
 	PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVRegisterCmdCompleteNotify", err_close_stream);
-#endif /* defined(TRACE_EVENTS_DEFINED) */
 
 err_out:
 	PVR_DPF_RETURN_RC(eError);
-#if defined(TRACE_EVENTS_DEFINED)
 err_close_stream:
-#endif /* defined(TRACE_EVENTS_DEFINED) */
 	TLClientCloseStream(DIRECT_BRIDGE_HANDLE,
 						psFtraceData->hGPUFTraceTLStream);
 	psFtraceData->hGPUFTraceTLStream = NULL;
@@ -610,8 +571,6 @@ static PVRSRV_ERROR _GpuTraceDisable(PVRSRV_RGXDEV_INFO *psRgxDevInfo, IMG_BOOL
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	RGX_HWPERF_FTRACE_DATA *psFtraceData;
-	IMG_PBYTE pBuffer;
-	IMG_UINT32 ui32ReadLen;
 #if defined(SUPPORT_RGX)
 	PVRSRV_DEVICE_NODE *psRgxDevNode = psRgxDevInfo->psDeviceNode;
 #endif
@@ -649,7 +608,6 @@ static PVRSRV_ERROR _GpuTraceDisable(PVRSRV_RGXDEV_INFO *psRgxDevInfo, IMG_BOOL
 	}
 #endif
 
-#if defined(TRACE_EVENTS_DEFINED)
 	if (psFtraceData->hGPUTraceCmdCompleteHandle)
 	{
 		/* Tracing is being turned off. Unregister the notifier. */
@@ -658,33 +616,6 @@ static PVRSRV_ERROR _GpuTraceDisable(PVRSRV_RGXDEV_INFO *psRgxDevInfo, IMG_BOOL
 		PVR_LOG_IF_ERROR(eError, "PVRSRVUnregisterCmdCompleteNotify");
 		psFtraceData->hGPUTraceCmdCompleteHandle = NULL;
 	}
-#endif /* defined(TRACE_EVENTS_DEFINED) */
-
-	/* We have to flush both the L1 (FW) and L2 (Host) buffers in case there
-	 * are some events left unprocessed in this FTrace/systrace "session"
-	 * (note that even if we have just disabled HWPerf on the FW some packets
-	 * could have been generated and already copied to L2 by the MISR handler).
-	 *
-	 * With the following calls we will both copy new data to the Host buffer
-	 * (done by the producer callback in TLClientAcquireData) and advance
-	 * the read offset in the buffer to catch up with the latest events.
-	 */
-	eError = TLClientAcquireData(DIRECT_BRIDGE_HANDLE,
-								 psFtraceData->hGPUFTraceTLStream,
-								 &pBuffer, &ui32ReadLen);
-	PVR_LOG_IF_ERROR(eError, "TLClientCloseStream");
-
-#if defined(TRACE_EVENTS_DEFINED)
-	/* We still need to process packets if there were any so that there is
-	 * no gap in the ordinal value.
-	 */
-	if (ui32ReadLen > 0)
-	{
-		_GpuTraceProcessPackets(psRgxDevInfo, pBuffer, ui32ReadLen);
-	}
-#endif /* defined(TRACE_EVENTS_DEFINED) */
-
-	psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_FTRACE] = IMG_TRUE;
 
 	/* Let close stream perform the release data on the outstanding acquired
 	 * data */
@@ -710,8 +641,6 @@ static PVRSRV_ERROR _GpuTraceSetEnabled(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	RGX_HWPERF_FTRACE_DATA *psFtraceData;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	PVR_DPF_ENTERED;
 
 	PVR_ASSERT(psRgxDevInfo);
@@ -732,7 +661,7 @@ static PVRSRV_ERROR _GpuTraceSetEnabled(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 
 static PVRSRV_ERROR _GpuTraceSetEnabledForAllDevices(IMG_BOOL bNewValue)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_NOT_IMPLEMENTED;
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 	PVRSRV_DEVICE_NODE *psDeviceNode;
 
@@ -742,11 +671,17 @@ static PVRSRV_ERROR _GpuTraceSetEnabledForAllDevices(IMG_BOOL bNewValue)
 	/* enable/disable GPU trace on all devices */
 	while (psDeviceNode)
 	{
-		eError = _GpuTraceSetEnabled(psDeviceNode->pvDevice, bNewValue);
-		if (eError != PVRSRV_OK)
+		PVRSRV_RGXDEV_INFO *psRgxDevInfo = (PVRSRV_RGXDEV_INFO*)psDeviceNode->pvDevice;
+
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psRgxDevInfo))
+#endif
 		{
-			break;
+			eError = _GpuTraceSetEnabled(psRgxDevInfo, bNewValue);
+			if (eError != PVRSRV_OK)
+				break;
 		}
+
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
@@ -894,7 +829,7 @@ static uint64_t CalculateEventTimestamp(
 	uint32_t ui32TimeCorrIndex,
 	uint64_t ui64EventTimestamp)
 {
-	RGXFWIF_GPU_UTIL_FWCB *psGpuUtilFWCB = psDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
 	RGX_HWPERF_FTRACE_DATA *psFtraceData = psDevInfo->pvGpuFtraceData;
 	RGXFWIF_TIME_CORR *psTimeCorr;
 	uint64_t ui64CRTimeStamp;
@@ -902,8 +837,8 @@ static uint64_t CalculateEventTimestamp(
 	uint64_t ui64CRDeltaToOSDeltaKNs;
 	uint64_t ui64EventOSTimestamp, deltaRgxTimer, delta_ns;
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->sTimeCorr[ui32TimeCorrIndex], INVALIDATE);
-	psTimeCorr = &psGpuUtilFWCB->sTimeCorr[ui32TimeCorrIndex];
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->sTimeCorr[ui32TimeCorrIndex], INVALIDATE);
+	psTimeCorr = &psGpuUtilFW->sTimeCorr[ui32TimeCorrIndex];
 	ui64CRTimeStamp = psTimeCorr->ui64CRTimeStamp;
 	ui64OSTimeStamp = psTimeCorr->ui64OSTimeStamp;
 	ui64CRDeltaToOSDeltaKNs = psTimeCorr->ui64CRDeltaToOSDeltaKNs;
@@ -969,15 +904,6 @@ static void _GpuTraceSwitchEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 	                    eSwType);
 #endif /* defined(PVRSRV_TRACE_ROGUE_EVENTS) */
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-	 GpuTraceWorkPeriod(psHWPerfPktData->ui32PID,
-	                    psDevInfo->psDeviceNode->sDevId.ui32InternalID,
-	                    ui64Timestamp,
-	                    psHWPerfPktData->ui32IntJobRef,
-	                    (eSwType == PVR_GPUTRACE_SWITCH_TYPE_BEGIN) ?
-						PVR_GPU_WORK_EVENT_START : PVR_GPU_WORK_EVENT_END);
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
-
 	PVR_DPF_RETURN;
 }
 #endif /* defined(PVRSRV_TRACE_ROGUE_EVENTS) || defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
@@ -1025,29 +951,6 @@ static void _GpuTraceFirmwareEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 }
 #endif /* defined(PVRSRV_TRACE_ROGUE_EVENTS) */
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-static void _GpuTraceCLKsEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
-                               RGX_HWPERF_V2_PACKET_HDR *psHWPerfPkt)
-
-{
-	RGX_HWPERF_V2_PACKET_DATA *psHWPerfPktData =
-		RGX_HWPERF_GET_PACKET_DATA(psHWPerfPkt);
-
-	switch (psHWPerfPktData->sCLKSCHG.eClockName)
-	{
-		case RGX_HWPERF_CLKS_CHG_NAME_CORE:
-		{
-			GpuTraceFrequency(psDevInfo->psDeviceNode->sDevId.ui32InternalID,
-					psHWPerfPktData->sCLKSCHG.ui64NewClockSpeed);
-			break;
-		}
-		default:
-			break;
-	}
-}
-#endif
-
-#if defined(TRACE_EVENTS_DEFINED)
 static IMG_BOOL ValidAndEmitFTraceEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 		RGX_HWPERF_V2_PACKET_HDR* psHWPerfPkt)
 {
@@ -1088,6 +991,7 @@ static IMG_BOOL ValidAndEmitFTraceEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 		{ "TDM",            _T(BEGIN)  }, /* RGX_HWPERF_HW_TDMKICK */
 		{ "TDM",            _T(END)    }, /* RGX_HWPERF_HW_TDMFINISHED */
 		{ "NULL",           _T(SINGLE) }, /* RGX_HWPERF_HW_NULLKICK */
+		{ "GPU_WORK_PERIOD",_T(SINGLE) }, /* RGX_HWPERF_HW_GPU_WORK_PERIOD */
 #undef _T
 	};
 	static_assert(RGX_HWPERF_HW_EVENT_RANGE0_FIRST_TYPE == RGX_HWPERF_FW_EVENT_RANGE_LAST_TYPE + 1,
@@ -1128,14 +1032,6 @@ static IMG_BOOL ValidAndEmitFTraceEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 	}
 #endif /* defined(PVRSRV_TRACE_ROGUE_EVENTS) */
 
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-	if (eType == RGX_HWPERF_CLKS_CHG)
-	{
-		_GpuTraceCLKsEvent(psDevInfo, psHWPerfPkt);
-		return IMG_TRUE;
-	}
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
-
 #if defined(PVRSRV_TRACE_ROGUE_EVENTS) || defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
 	if (eType <= RGX_HWPERF_HW_EVENT_RANGE0_LAST_TYPE)
 	{
@@ -1180,6 +1076,33 @@ static IMG_BOOL ValidAndEmitFTraceEvent(PVRSRV_RGXDEV_INFO *psDevInfo,
 
 		return IMG_TRUE;
 	}
+#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+	else if (psDevInfo->psDeviceNode->bGPUWorkPeriodFTraceEnabled &&
+		 eType == RGX_HWPERF_TRACE_EVENT_GPU_WORK_PERIOD &&
+		 RGX_HWPERF_GET_OSID(psHWPerfPkt) == RGXFW_HOST_DRIVER_ID)
+	{
+		RGX_HWPERF_GPU_WORK_PERIOD_DATA *psHWPerfPktData;
+		IMG_UINT64 ui64StartTimestamp, ui64EndTimestamp;
+
+		psHWPerfPktData = RGX_HWPERF_GET_PACKET_DATA_BYTES(psHWPerfPkt);
+		ui64StartTimestamp = CalculateEventTimestamp(psDevInfo,
+					psHWPerfPktData->ui32StartTimeCorrIndex,
+					psHWPerfPktData->ui64GPUWorkPeriodStartTime);
+		ui64EndTimestamp = CalculateEventTimestamp(psDevInfo,
+					psHWPerfPktData->ui32TimeCorrIndex,
+					psHWPerfPkt->ui64Timestamp);
+
+		PVR_ASSERT(ui64EndTimestamp > ui64StartTimestamp);
+
+		trace_gpu_work_period(psDevInfo->psDeviceNode->sDevId.ui32InternalID,
+				psHWPerfPktData->ui32UID,
+				ui64StartTimestamp,
+				ui64EndTimestamp,
+				ui64EndTimestamp - ui64StartTimestamp);
+
+		return IMG_TRUE;
+	}
+#endif
 #endif /* defined(PVRSRV_TRACE_ROGUE_EVENTS) || defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
 #if defined(PVRSRV_TRACE_ROGUE_EVENTS)
 	if (HWPERF_PACKET_IS_FW_TYPE(eType))
@@ -1339,23 +1262,6 @@ static void _GpuTraceCmdCompleteNotify(PVRSRV_CMDCOMP_HANDLE hCmdCompHandle)
 
 	PVR_DPF_RETURN;
 }
-#endif /* defined(TRACE_EVENTS_DEFINED) */
-
-#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
-PVRSRV_ERROR
-PVRSRVGpuTraceWorkPeriodEventStatsRegister(IMG_HANDLE
-		*phGpuWorkPeriodEventStats)
-{
-	return GpuTraceWorkPeriodEventStatsRegister(phGpuWorkPeriodEventStats);
-}
-
-void
-PVRSRVGpuTraceWorkPeriodEventStatsUnregister(
-		IMG_HANDLE hGpuWorkPeriodEventStats)
-{
-	GpuTraceWorkPeriodEventStatsUnregister(hGpuWorkPeriodEventStats);
-}
-#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD) */
 
 /* ----- AppHint interface -------------------------------------------------- */
 
@@ -1364,12 +1270,36 @@ static PVRSRV_ERROR _GpuTraceIsEnabledCallback(
 	const void *private_data,
 	IMG_BOOL *value)
 {
-	PVR_UNREFERENCED_PARAMETER(device);
 	PVR_UNREFERENCED_PARAMETER(private_data);
 
-	*value = gbFTraceGPUEventsEnabled;
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	if (device && PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, device))
+	{
+		*value = IMG_FALSE;
+	}
+	else
+#endif
+	{
+		PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+		PVRSRV_DEVICE_NODE *psDeviceNode = psPVRSRVData ? psPVRSRVData->psDeviceNodeList : NULL;
 
-	return PVRSRV_OK;
+		while (psDeviceNode)
+		{
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+			PVRSRV_RGXDEV_INFO *psRgxDevInfo = (PVRSRV_RGXDEV_INFO*)psDeviceNode->pvDevice;
+
+			if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psRgxDevInfo))
+#endif
+			{
+				*value = gbFTraceGPUEventsEnabled;
+				return PVRSRV_OK;
+			}
+			psDeviceNode = psDeviceNode->psNext;
+		}
+		*value = IMG_FALSE;
+	}
+
+	return PVRSRV_ERROR_NOT_IMPLEMENTED;
 }
 
 static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
@@ -1377,15 +1307,19 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 	const void *private_data,
 	IMG_BOOL value)
 {
-	PVR_UNREFERENCED_PARAMETER(device);
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	if (device && PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, device))
+	{
+		return PVRSRV_ERROR_NOT_IMPLEMENTED;
+	}
+#endif
 
 	/* Lock down the state to avoid concurrent writes */
 	OSLockAcquire(ghGPUTraceStateLock);
 
 	if (value != gbFTraceGPUEventsEnabled)
 	{
-#if (defined(PVRSRV_NEED_PVR_TRACE) || defined(PVRSRV_NEED_PVR_DPF)) && \
-    defined(TRACE_EVENTS_DEFINED)
+#if defined(PVRSRV_NEED_PVR_DPF)
 		const IMG_CHAR *pszOperation = value ? "enable" : "disable";
 		/* in case MESSAGE level is compiled out */
 		PVR_UNREFERENCED_PARAMETER(pszOperation);
@@ -1394,7 +1328,8 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 #if defined(PVRSRV_TRACE_ROGUE_EVENTS)
 		if (trace_set_clr_event("rogue", NULL, (int) value) != 0)
 		{
-			PVR_TRACE(("FAILED to %s GPU FTrace event group", pszOperation));
+			PVR_DPF((PVR_DBG_ERROR, "FAILED to %s GPU FTrace event group",
+			        pszOperation));
 			goto err_restore_state;
 		}
 		else
@@ -1407,27 +1342,13 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 #if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
 		if (trace_set_clr_event("power", "gpu_work_period", (int) value) != 0)
 		{
-			PVR_TRACE(("FAILED to %s gpu_work_period GPU FTrace event",
-			          pszOperation));
-			goto err_restore_state;
-		}
-		else
-		{
-			PVR_DPF((PVR_DBG_MESSAGE, "FTrace event from \"gpu_work_period\" %sd",
+			PVR_DPF((PVR_DBG_ERROR, "FAILED to %s gpu_work_period GPU FTrace event",
 			        pszOperation));
-		}
-#endif
-
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-		if (trace_set_clr_event("power", "gpu_frequency", (int) value) != 0)
-		{
-			PVR_TRACE(("FAILED to %s gpu_frequency GPU FTrace event",
-			          pszOperation));
 			goto err_restore_state;
 		}
 		else
 		{
-			PVR_DPF((PVR_DBG_MESSAGE, "FTrace event from \"gpu_frequency\" %sd",
+			PVR_DPF((PVR_DBG_MESSAGE, "FTrace event from \"gpu_work_period\" %sd",
 			        pszOperation));
 		}
 #endif
@@ -1444,16 +1365,18 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 		    The consumer should be active before the supplier    */
 		if (_GpuTraceSetEnabledForAllDevices(value) != PVRSRV_OK)
 		{
-			PVR_TRACE(("FAILED to %s GPU FTrace for all devices", pszOperation));
+			PVR_DPF((PVR_DBG_ERROR, "FAILED to %s GPU FTrace for all devices",
+			        pszOperation));
 			goto err_restore_state;
 		}
 
-		PVR_TRACE(("%s GPU FTrace", value ? "ENABLED" : "DISABLED"));
+		PVR_DPF((PVR_DBG_MESSAGE, "%s GPU FTrace", value ? "ENABLED" : "DISABLED"));
 		gbFTraceGPUEventsEnabled = value;
 	}
 	else
 	{
-		PVR_TRACE(("GPU FTrace already %s!", value ? "enabled" : "disabled"));
+		PVR_DPF((PVR_DBG_MESSAGE, "GPU FTrace already %s!",
+		        value ? "enabled" : "disabled"));
 	}
 
 	OSLockRelease(ghGPUTraceStateLock);
@@ -1473,10 +1396,6 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 	(void) trace_set_clr_event("power", "gpu_work_period",
 	                           (int) gbFTraceGPUEventsEnabled);
 #endif
-#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
-	(void) trace_set_clr_event("power", "gpu_frequency",
-	                           (int) gbFTraceGPUEventsEnabled);
-#endif
 
 	OSLockRelease(ghGPUTraceStateLock);
 
@@ -1485,11 +1404,6 @@ static PVRSRV_ERROR _GpuTraceSetEnabledCallback(
 
 void PVRGpuTraceInitAppHintCallbacks(const PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	/* Do not register callback handlers if we are in GUEST mode */
-	if (PVRSRV_VZ_MODE_IS(GUEST))
-	{
-		return;
-	}
 	PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_EnableFTraceGPU,
 	                                  _GpuTraceIsEnabledCallback,
 	                                  _GpuTraceSetEnabledCallback,
@@ -1680,6 +1594,75 @@ void PVRGpuTraceDisableFirmwareActivityCallback(void)
 #endif /* defined(SUPPORT_RGX) */
 }
 
+#if defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+int PVRGpuTraceEnableWorkPeriodCallback(void)
+#else
+void PVRGpuTraceEnableWorkPeriodCallback(void)
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)) */
+{
+	PVRSRV_ERROR eError = PVRSRV_ERROR_NOT_IMPLEMENTED;
+	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
+	OSWRLockAcquireRead(psPVRSRVData->hDeviceNodeListLock);
+	psDeviceNode = psPVRSRVData->psDeviceNodeList;
+
+	/* enable/disable GPU trace on all devices */
+	while (psDeviceNode)
+	{
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+		PVRSRV_RGXDEV_INFO *psRgxDevInfo = (PVRSRV_RGXDEV_INFO*)psDeviceNode->pvDevice;
+
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psRgxDevInfo))
+#endif
+		{
+			psDeviceNode->bGPUWorkPeriodFTraceEnabled = true;
+			eError = PVRSRV_OK;
+		}
+
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+	if (eError != PVRSRV_OK)
+		return -ENODEV;
+	return 0;
+#else
+	return;
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)) */
+}
+
+void PVRGpuTraceDisableWorkPeriodCallback(void)
+{
+	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
+	if (!psPVRSRVData)
+		return;
+
+	OSWRLockAcquireRead(psPVRSRVData->hDeviceNodeListLock);
+	psDeviceNode = psPVRSRVData->psDeviceNodeList;
+
+	while (psDeviceNode)
+	{
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+		PVRSRV_RGXDEV_INFO *psRgxDevInfo = (PVRSRV_RGXDEV_INFO*)psDeviceNode->pvDevice;
+
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psRgxDevInfo))
+#endif
+		{
+			psDeviceNode->bGPUWorkPeriodFTraceEnabled = false;
+		}
+
+		psDeviceNode = psDeviceNode->psNext;
+	}
+
+	OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+}
+#endif
 /******************************************************************************
  End of file (pvr_gputrace.c)
 ******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/pvr_notifier.c b/drivers/gpu/drm/img-rogue/pvr_notifier.c
index 5add59562de7..50fd35358ad2 100644
--- a/drivers/gpu/drm/img-rogue/pvr_notifier.c
+++ b/drivers/gpu/drm/img-rogue/pvr_notifier.c
@@ -207,7 +207,7 @@ PVRSRVSignalDriverWideEO(void)
 	/* Cleanup Thread could be waiting on Cleanup event object,
 	 * signal it as well to ensure work is processed
 	 */
-	if (psPVRSRVData->hCleanupEventObject)
+	if (psPVRSRVData->hCleanupEventObject && (OSAtomicRead(&psPVRSRVData->i32NumCleanupItemsQueued) != 0))
 	{
 		OSEventObjectSignal(psPVRSRVData->hCleanupEventObject);
 	}
@@ -240,7 +240,7 @@ typedef struct DEBUG_REQUEST_ENTRY_TAG
 typedef struct DEBUG_REQUEST_TABLE_TAG
 {
 	POSWR_LOCK              hLock;
-	DEBUG_REQUEST_ENTRY     asEntry[1];
+	DEBUG_REQUEST_ENTRY     asEntry[IMG_FLEX_ARRAY_MEMBER];
 } DEBUG_REQUEST_TABLE;
 
 typedef struct DEBUG_REQUEST_NOTIFY_TAG
@@ -282,7 +282,7 @@ _RegisterDebugTableI(DEBUG_REQUEST_TABLE **ppsDebugTable)
 	}
 
 	psDebugTable = OSAllocMem(sizeof(DEBUG_REQUEST_TABLE) +
-							  (sizeof(DEBUG_REQUEST_ENTRY) * (g_ui32DebugOrderTableReqCount-1)));
+	                          IMG_FLEX_ARRAY_SIZE(sizeof(DEBUG_REQUEST_ENTRY), g_ui32DebugOrderTableReqCount));
 	PVR_RETURN_IF_NOMEM(psDebugTable);
 
 	eError = OSWRLockCreate(&psDebugTable->hLock);
@@ -543,7 +543,7 @@ PVRSRVDebugRequest(PVRSRV_DEVICE_NODE *psDevNode,
 	                  szVerbosityLevel);
 
 #if defined(RGX_IRQ_HYPERV_HANDLER)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 #endif
 	{
 		OSDumpVersionInfo(pfnDumpDebugPrintf, pvDumpDebugFile);
@@ -592,7 +592,7 @@ PVRSRVDebugRequest(PVRSRV_DEVICE_NODE *psDevNode,
 	}
 
 	PVR_DUMPDEBUG_LOG("Driver Mode: %s",
-	                  PVRSRV_VZ_MODE_IS(NATIVE) ? "Native" : (PVRSRV_VZ_MODE_IS(HOST)) ? "Host":"Guest");
+	                  PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDevNode) ? "Native" : (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDevNode)) ? "Host":"Guest");
 
 	if (psPVRSRVData->sDriverInfo.ui8UMSupportedArch)
 	{
@@ -614,6 +614,18 @@ PVRSRVDebugRequest(PVRSRV_DEVICE_NODE *psDevNode,
 
 	PVR_DUMPDEBUG_LOG("Window system: %s", (IS_DECLARED(WINDOW_SYSTEM)) ? (WINDOW_SYSTEM) : "Not declared");
 
+	PVR_DUMPDEBUG_LOG("Power lock status: %s", OSLockIsLocked(psDevNode->hPowerLock) ? "Locked" : "Free");
+#if defined(DEBUG)
+	if (OSLockIsLocked(psDevNode->hPowerLock))
+	{
+		/* Ensure this info is logged before the power lock is taken, in case
+		 * it's already in use. */
+		PVR_DUMPDEBUG_LOG("Power lock owner: PID = %u at timestamp %" IMG_UINT64_FMTSPEC " (%s:%u)",
+		                  psDevNode->uiPwrLockOwnerPID, psDevNode->sPowerLockOwner.ui64Timestamp,
+		                  psDevNode->sPowerLockOwner.pszFile, psDevNode->sPowerLockOwner.ui32LineNum);
+	}
+#endif
+
 	/* Driver debug table */
 	OSWRLockAcquireReadNested(psDriverDebugTable->hLock, DN_LOCKCLASS_DRIVER);
 	/* Device debug table*/
@@ -651,7 +663,8 @@ PVRSRVDebugRequest(PVRSRV_DEVICE_NODE *psDevNode,
 
 	if (!pfnDumpDebugPrintf)
 	{
-		/* Only notify OS of an issue if the debug dump has gone there */
+		/* Only notify OS of an issue if the caller requested it,
+		 * using a NULL pointer in pfnDumpDebugPrintf. */
 		OSWarnOn(IMG_TRUE);
 	}
 }
diff --git a/drivers/gpu/drm/img-rogue/pvr_platform_drv.c b/drivers/gpu/drm/img-rogue/pvr_platform_drv.c
index 8943913e1144..4e3e09786b89 100644
--- a/drivers/gpu/drm/img-rogue/pvr_platform_drv.c
+++ b/drivers/gpu/drm/img-rogue/pvr_platform_drv.c
@@ -161,25 +161,15 @@ static void pvr_devices_unregister(void)
 
 static int pvr_probe(struct platform_device *pdev)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	struct drm_device *ddev;
 	int ret;
 
 	DRM_DEBUG_DRIVER("device %p\n", &pdev->dev);
 
 	ddev = drm_dev_alloc(&pvr_drm_platform_driver, &pdev->dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
 	if (IS_ERR(ddev))
 		return PTR_ERR(ddev);
-#else
-	if (!ddev)
-		return -ENOMEM;
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-	/* Needed by drm_platform_set_busid */
-	ddev->platformdev = pdev;
-#endif
 
 	/*
 	 * The load callback, called from drm_dev_register, is deprecated,
@@ -211,11 +201,6 @@ static int pvr_probe(struct platform_device *pdev)
 err_drm_dev_put:
 	drm_dev_put(ddev);
 	return	ret;
-#else
-	DRM_DEBUG_DRIVER("device %p\n", &pdev->dev);
-
-	return drm_platform_init(&pvr_drm_platform_driver, pdev);
-#endif
 }
 
 static int pvr_remove(struct platform_device *pdev)
@@ -224,7 +209,6 @@ static int pvr_remove(struct platform_device *pdev)
 
 	DRM_DEBUG_DRIVER("device %p\n", &pdev->dev);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
 	drm_dev_unregister(ddev);
 
 	/* The unload callback, called from drm_dev_unregister, is
@@ -234,9 +218,6 @@ static int pvr_remove(struct platform_device *pdev)
 	pvr_drm_unload(ddev);
 
 	drm_dev_put(ddev);
-#else
-	drm_put_dev(ddev);
-#endif
 	return 0;
 }
 
@@ -249,7 +230,6 @@ static void pvr_shutdown(struct platform_device *pdev)
 	PVRSRVDeviceShutdown(ddev);
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 static const struct of_device_id pvr_of_ids[] = {
 #if defined(SYS_RGX_OF_COMPATIBLE)
 	{ .compatible = SYS_RGX_OF_COMPATIBLE, },
@@ -257,10 +237,9 @@ static const struct of_device_id pvr_of_ids[] = {
 	{},
 };
 
-#if !defined(CHROMIUMOS_KERNEL) || !defined(MODULE)
+#if !defined(CHROMIUMOS_KERNEL)
 MODULE_DEVICE_TABLE(of, pvr_of_ids);
 #endif
-#endif
 
 static struct platform_device_id pvr_platform_ids[] = {
 #if defined(SYS_RGX_DEV_NAME)
@@ -281,16 +260,14 @@ static struct platform_device_id pvr_platform_ids[] = {
 	{ }
 };
 
-#if !defined(CHROMIUMOS_KERNEL) || !defined(MODULE)
+#if !defined(CHROMIUMOS_KERNEL)
 MODULE_DEVICE_TABLE(platform, pvr_platform_ids);
 #endif
 
 static struct platform_driver pvr_platform_driver = {
 	.driver = {
 		.name		= DRVNAME,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 		.of_match_table	= of_match_ptr(pvr_of_ids),
-#endif
 		.pm		= &pvr_pm_ops,
 	},
 	.id_table		= pvr_platform_ids,
@@ -306,10 +283,6 @@ static int __init pvr_init(void)
 	DRM_DEBUG_DRIVER("\n");
 
 	pvr_drm_platform_driver = pvr_drm_generic_driver;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)) && \
-	(LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-	pvr_drm_platform_driver.set_busid = drm_platform_set_busid;
-#endif
 
 	err = PVRSRVDriverInit();
 	if (err)
diff --git a/drivers/gpu/drm/img-rogue/pvr_sw_fence.c b/drivers/gpu/drm/img-rogue/pvr_sw_fence.c
index 4f2404a21161..cccc4a64e321 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sw_fence.c
+++ b/drivers/gpu/drm/img-rogue/pvr_sw_fence.c
@@ -48,6 +48,7 @@
 #include <linux/bug.h>
 
 #include "pvr_sw_fence.h"
+#include "osfunc_common.h"
 
 struct pvr_sw_fence_context {
 	struct kref kref;
@@ -159,9 +160,9 @@ pvr_sw_fence_context_create(const char *context_name, const char *driver_name)
 		return NULL;
 
 	fence_context->context = dma_fence_context_alloc(1);
-	strlcpy(fence_context->context_name, context_name,
+	OSStringSafeCopy(fence_context->context_name, context_name,
 		sizeof(fence_context->context_name));
-	strlcpy(fence_context->driver_name, driver_name,
+	OSStringSafeCopy(fence_context->driver_name, driver_name,
 		sizeof(fence_context->driver_name));
 	atomic_set(&fence_context->seqno, 0);
 	atomic_set(&fence_context->fence_count, 0);
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_api.h b/drivers/gpu/drm/img-rogue/pvr_sync_api.h
index 89b7833ae351..97dd746439b9 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_api.h
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_api.h
@@ -52,6 +52,8 @@ int pvr_sync_api_rename(void *api_priv, void *user_data);
 int pvr_sync_api_force_sw_only(void *api_priv, void **api_priv_new);
 int pvr_sync_api_sw_create_fence(void *api_priv, void *user_data);
 int pvr_sync_api_sw_inc(void *api_priv, void *user_data);
+int pvr_sync_api_force_exp_only(void *api_priv, void *api_data);
+int pvr_sync_api_create_export_fence(void *api_priv, void *user_data);
 
 struct file;
 
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_file.c b/drivers/gpu/drm/img-rogue/pvr_sync_file.c
index e3656108e963..916d585ffb49 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_file.c
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_file.c
@@ -46,6 +46,7 @@
 #include "pvr_sync.h"
 #include "pvr_fence.h"
 #include "pvr_counting_timeline.h"
+#include "pvr_export_fence.h"
 
 #include "linux_sw_sync.h"
 
@@ -58,6 +59,7 @@
 #include <linux/uaccess.h>
 
 #include "pvr_sync_api.h"
+#include "osfunc_common.h"
 
 /* This header must always be included last */
 #include "kernel_compatibility.h"
@@ -107,10 +109,14 @@ struct pvr_sync_timeline {
 	char name[32];
 	void *file_handle;
 	bool is_sw;
+	bool is_export;
 	/* Fence context used for hw fences */
 	struct pvr_fence_context *hw_fence_context;
 	/* Timeline and context for sw fences */
-	struct pvr_counting_fence_timeline *sw_fence_timeline;
+	union {
+		struct pvr_counting_fence_timeline *sw_fence_timeline;
+		struct pvr_exp_fence_context *exp_fence_context;
+	};
 #if defined(NO_HARDWARE)
 	/* List of all timelines (used to advance all timelines in nohw builds) */
 	struct list_head list;
@@ -136,6 +142,17 @@ void pvr_sync_nohw_signal_fence(void *fence_data_to_signal)
 	}
 	mutex_unlock(&pvr_timeline_active_list_lock);
 }
+static
+void pvr_sync_nohw_signal_exp_fence(PVRSRV_FENCE fence_to_signal)
+{
+	struct dma_fence *fence;
+
+	fence = sync_file_get_fence(fence_to_signal);
+	if (fence && pvr_is_exp_fence(fence))
+		dma_fence_signal(fence);
+
+	dma_fence_put(fence);
+}
 #endif
 
 static struct pvr_sync_timeline *pvr_sync_timeline_fget(int fd)
@@ -176,9 +193,10 @@ int pvr_sync_api_init(void *file_handle, void **api_priv)
 	if (!timeline)
 		return -ENOMEM;
 
-	strlcpy(timeline->name, task_comm, sizeof(timeline->name));
+	OSStringSafeCopy(timeline->name, task_comm, sizeof(timeline->name));
 	timeline->file_handle = file_handle;
 	timeline->is_sw = false;
+	timeline->is_export = false;
 
 	*api_priv = (void *)timeline;
 
@@ -192,7 +210,7 @@ int pvr_sync_api_deinit(void *api_priv, bool is_sw)
 	if (!timeline)
 		return 0;
 
-	if (timeline->sw_fence_timeline) {
+	if (timeline->is_sw && timeline->sw_fence_timeline) {
 		/* This makes sure any outstanding SW syncs are marked as
 		 * complete at timeline close time. Otherwise it'll leak the
 		 * timeline (as outstanding fences hold a ref) and possibly
@@ -202,6 +220,8 @@ int pvr_sync_api_deinit(void *api_priv, bool is_sw)
 		pvr_counting_fence_timeline_force_complete(
 			timeline->sw_fence_timeline);
 		pvr_counting_fence_timeline_put(timeline->sw_fence_timeline);
+	} else if (timeline->is_export && timeline->exp_fence_context) {
+		pvr_exp_fence_context_destroy(timeline->exp_fence_context);
 	}
 
 	if (timeline->hw_fence_context) {
@@ -374,7 +394,7 @@ pvr_sync_create_fence(
 		err = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto err_destroy_fence;
 	}
-	strlcpy(sync_file_user_name(sync_file),
+	OSStringSafeCopy(sync_file_user_name(sync_file),
 		pvr_fence->name,
 		sizeof(sync_file_user_name(sync_file)));
 	dma_fence_put(&pvr_fence->base);
@@ -518,24 +538,39 @@ pvr_sync_resolve_fence(PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
 			      &fences[i]->flags))
 #endif
 		{
-			struct pvr_fence *pvr_fence =
-				pvr_fence_create_from_fence(
-					pvr_sync_data.foreign_fence_context,
-					psSyncCheckpointContext,
-					fences[i],
-					fence_to_resolve,
-					"foreign");
-			if (!pvr_fence) {
-				pr_err(FILE_NAME ": %s: Failed to create fence\n",
-				       __func__);
-				err = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto err_free_checkpoints;
+			struct pvr_fence *pvr_fence;
+
+			/* Check if fences[i] is an export fence */
+			if (pvr_is_exp_fence(fences[i])) {
+				/* Assign export fence a sync checkpoint if it does not already
+				 * have one.
+				 */
+				err = pvr_exp_fence_assign_checkpoint(PVRSRV_NO_FENCE,
+				                                      fences[i],
+				                                      psSyncCheckpointContext,
+				                                      &checkpoints[num_used_fences]);
+				SyncCheckpointTakeRef(checkpoints[num_used_fences]);
+				++num_used_fences;
+			}
+			else {
+				pvr_fence = pvr_fence_create_from_fence(
+				            pvr_sync_data.foreign_fence_context,
+			            psSyncCheckpointContext,
+			            fences[i],
+			            fence_to_resolve,
+			            "foreign");
+				if (!pvr_fence) {
+					pr_err(FILE_NAME ": %s: Failed to create fence\n",
+					       __func__);
+					err = PVRSRV_ERROR_OUT_OF_MEMORY;
+					goto err_free_checkpoints;
+				}
+				checkpoints[num_used_fences] =
+				        pvr_fence_get_checkpoint(pvr_fence);
+				SyncCheckpointTakeRef(checkpoints[num_used_fences]);
+				++num_used_fences;
+				dma_fence_put(&pvr_fence->base);
 			}
-			checkpoints[num_used_fences] =
-				pvr_fence_get_checkpoint(pvr_fence);
-			SyncCheckpointTakeRef(checkpoints[num_used_fences]);
-			++num_used_fences;
-			dma_fence_put(&pvr_fence->base);
 		}
 	}
 	/* If we don't return any checkpoints, delete the array because
@@ -565,6 +600,95 @@ pvr_sync_resolve_fence(PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
 	goto err_put_fence;
 }
 
+/*
+ * This is the function that kick code will call in order to obtain the
+ * PSYNC_CHECKPOINT for a given export fence (PVRSRV_FENCE) passed to a kick
+ * function.
+ * If export_fence is not a valid export fence, (ie fops != &pvr_exp_fence_ops)
+ * this function will return (error).
+ *
+ * Input:  export_fence              The export fence to resolve
+ * Input:  checkpoint_context        The context in which to create the new
+ *                                   sync checkpoint for the export fence
+ * Output: checkpoint_handle         The returned PVRSRV_SYNC_CHECKPOINT.
+ */
+static enum PVRSRV_ERROR_TAG
+pvr_sync_resolve_export_fence(PVRSRV_FENCE fence_to_resolve,
+			      PSYNC_CHECKPOINT_CONTEXT checkpoint_context,
+			      PSYNC_CHECKPOINT *checkpoint_handle)
+{
+	PVRSRV_ERROR err = PVRSRV_OK;
+	struct dma_fence *fence;
+
+	fence = sync_file_get_fence(fence_to_resolve);
+	if (!fence) {
+		pr_err(FILE_NAME ": %s: Failed to read sync private data for fd %d\n",
+			__func__, fence_to_resolve);
+		err = PVRSRV_ERROR_HANDLE_NOT_FOUND;
+		goto err_out;
+	}
+
+	if (!pvr_is_exp_fence(fence)) {
+		pr_err(FILE_NAME ": %s: Fence not a pvr export fence\n", __func__);
+		dma_fence_put(fence);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	err = pvr_exp_fence_assign_checkpoint(fence_to_resolve,
+					      fence,
+					      checkpoint_context,
+					      checkpoint_handle);
+	if (err != PVRSRV_OK) {
+		pr_err(FILE_NAME ": %s: Failed to assign export fence a sync checkpoint\n",
+		       __func__);
+	}
+
+	dma_fence_put(fence);
+
+err_out:
+	return err;
+}
+
+/*
+ * This is the function that kick code will call in order to rollback the
+ * PSYNC_CHECKPOINT assigned to an export fence (PVRSRV_FENCE) passed to a kick
+ * function.
+ * If export_fence is not a valid export fence, (ie fops != &pvr_exp_fence_ops)
+ * this function will return (error).
+ *
+ * Input:  fence_to_rollback              The export fence to rollback
+ */
+static enum PVRSRV_ERROR_TAG
+pvr_sync_rollback_export_fence(PVRSRV_FENCE fence_to_rollback)
+{
+	PVRSRV_ERROR err = PVRSRV_OK;
+	struct dma_fence *fence;
+
+	fence = sync_file_get_fence(fence_to_rollback);
+	if (!fence) {
+		pr_err("%s: Failed to read sync private data for fd %d\n",
+			__func__, fence_to_rollback);
+		err = PVRSRV_ERROR_HANDLE_NOT_FOUND;
+		goto err_out;
+	}
+
+	if (!pvr_is_exp_fence(fence)) {
+		pr_err(FILE_NAME ": %s: Fence not a pvr export fence\n", __func__);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	err = pvr_exp_fence_rollback(fence);
+	if (err != PVRSRV_OK) {
+		pr_err("%s: Failed to rollback export fence\n",
+		       __func__);
+	}
+
+	dma_fence_put(fence);
+
+err_out:
+	return err;
+}
+
 /*
  * This is the function that driver code will call in order to request the
  * sync implementation to output debug information relating to any sync
@@ -640,11 +764,20 @@ pvr_sync_fence_get_checkpoints(PVRSRV_FENCE fence_to_pdump, u32 *nr_checkpoints,
 	}
 
 	for (i = 0; i < num_fences; i++) {
-		pvr_fence = to_pvr_fence(fences[i]);
-		if (!pvr_fence)
+		if (is_pvr_fence(fences[i])) {
+			pvr_fence = to_pvr_fence(fences[i]);
+			if (pvr_fence) {
+				checkpoints[num_used_fences] = pvr_fence_get_checkpoint(pvr_fence);
+				++num_used_fences;
+			}
+		} else if (pvr_is_exp_fence(fences[i])) {
+			struct pvr_exp_fence *pvr_exp_fence = to_pvr_exp_fence(fences[i]);
+
+			checkpoints[num_used_fences] = pvr_exp_fence_get_checkpoint(pvr_exp_fence);
+			if (checkpoints[num_used_fences])
+				++num_used_fences;
+		} else
 			continue;
-		checkpoints[num_used_fences] = pvr_fence_get_checkpoint(pvr_fence);
-		++num_used_fences;
 	}
 
 	*checkpoint_handles = checkpoints;
@@ -664,9 +797,9 @@ int pvr_sync_api_rename(void *api_priv, void *user_data)
 	struct pvr_sync_rename_ioctl_data *data = user_data;
 
 	data->szName[sizeof(data->szName) - 1] = '\0';
-	strlcpy(timeline->name, data->szName, sizeof(timeline->name));
+	OSStringSafeCopy(timeline->name, data->szName, sizeof(timeline->name));
 	if (timeline->hw_fence_context)
-		strlcpy(timeline->hw_fence_context->name, data->szName,
+		OSStringSafeCopy(timeline->hw_fence_context->name, data->szName,
 			sizeof(timeline->hw_fence_context->name));
 
 	return 0;
@@ -688,9 +821,85 @@ int pvr_sync_api_force_sw_only(void *api_priv, void **api_priv_new)
 
 	timeline->is_sw = true;
 
+	*api_priv_new = (void *)timeline;
+
+	return 0;
+}
+
+/* We simply treat an export-fence as a SW fence and tweak
+ * the timeline structure to flag it as an 'is_export' type.
+ */
+int pvr_sync_api_force_exp_only(void *api_priv, void *api_data)
+{
+	struct pvr_sync_timeline *timeline = api_priv;
+
+	if (timeline->is_export) {
+		pr_err(FILE_NAME ": %s: Already marked export timeline\n", __func__);
+		return 0;
+	}
+
+	timeline->exp_fence_context = pvr_exp_fence_context_create("pvr_exp_fence_ctx", "pvr_sync");
+	if (!timeline->exp_fence_context)
+		return -ENOMEM;
+
+	timeline->is_export = true;
+
 	return 0;
 }
 
+int pvr_sync_api_create_export_fence(void *api_priv, void *user_data)
+{
+	struct pvr_sync_timeline *timeline = api_priv;
+	struct pvr_exp_fence_context *exp_fence_context = timeline->exp_fence_context;
+	pvr_exp_sync_create_fence_data_t *data = user_data;
+	struct sync_file *sync_file;
+	int fd;
+	struct dma_fence *fence;
+	int err;
+
+	if (data == NULL) {
+		pr_err(FILE_NAME ": %s: Unexpected NULL user_data\n", __func__);
+		err = -EINVAL;
+		goto err_out;
+	}
+
+	fd = get_unused_fd_flags(O_CLOEXEC);
+	if (fd < 0) {
+		pr_err(FILE_NAME ": %s: Failed to find unused fd (%d)\n",
+		       __func__, fd);
+		err = -EMFILE;
+		goto err_out;
+	}
+
+	fence = pvr_exp_fence_create(exp_fence_context, fd, &data->sync_pt_idx);
+	if (!fence) {
+		pr_err(FILE_NAME ": %s: Failed to create a dma fence (%d)\n",
+		       __func__, fd);
+		err = -ENOMEM;
+		goto err_put_fd;
+	}
+
+	sync_file = sync_file_create(fence);
+	dma_fence_put(fence);
+	if (!sync_file) {
+		pr_err(FILE_NAME ": %s: Failed to create a sync_file (%d)\n",
+			__func__, fd);
+		err = -ENOMEM;
+		goto err_put_fd;
+	}
+
+	data->fence = fd;
+
+	fd_install(fd, sync_file->file);
+
+	return 0;
+
+err_put_fd:
+	put_unused_fd(fd);
+err_out:
+	return err;
+}
+
 int pvr_sync_api_sw_create_fence(void *api_priv, void *user_data)
 {
 	struct pvr_sync_timeline *timeline = api_priv;
@@ -779,19 +988,23 @@ enum PVRSRV_ERROR_TAG pvr_sync_register_functions(void)
 	pvr_sync_data.sync_checkpoint_ops.pfnFenceFinalise = pvr_sync_finalise_fence;
 #if defined(NO_HARDWARE)
 	pvr_sync_data.sync_checkpoint_ops.pfnNoHWUpdateTimelines = pvr_sync_nohw_signal_fence;
+	pvr_sync_data.sync_checkpoint_ops.pfnNoHWSignalExpFence = pvr_sync_nohw_signal_exp_fence;
 #else
 	pvr_sync_data.sync_checkpoint_ops.pfnNoHWUpdateTimelines = NULL;
+	pvr_sync_data.sync_checkpoint_ops.pfnNoHWSignalExpFence = NULL;
 #endif
 	pvr_sync_data.sync_checkpoint_ops.pfnFreeCheckpointListMem =
 		pvr_sync_free_checkpoint_list_mem;
 	pvr_sync_data.sync_checkpoint_ops.pfnDumpInfoOnStalledUFOs =
 		pvr_sync_dump_info_on_stalled_ufos;
-	strlcpy(pvr_sync_data.sync_checkpoint_ops.pszImplName, "pvr_sync_file",
+	OSStringSafeCopy(pvr_sync_data.sync_checkpoint_ops.pszImplName, "pvr_sync_file",
 		SYNC_CHECKPOINT_IMPL_MAX_STRLEN);
 #if defined(PDUMP)
 	pvr_sync_data.sync_checkpoint_ops.pfnSyncFenceGetCheckpoints =
 		pvr_sync_fence_get_checkpoints;
 #endif
+	pvr_sync_data.sync_checkpoint_ops.pfnExportFenceResolve = pvr_sync_resolve_export_fence;
+	pvr_sync_data.sync_checkpoint_ops.pfnExportFenceRollback = pvr_sync_rollback_export_fence;
 
 	return SyncCheckpointRegisterFunctions(&pvr_sync_data.sync_checkpoint_ops);
 }
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.c b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.c
index 60ba3555e779..0e1facde86cb 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.c
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.c
@@ -47,6 +47,9 @@
 #include "pvr_sync_api.h"
 #include "pvr_sync_ioctl_common.h"
 
+#include "pvr_debug.h"
+#include "pvr_uaccess.h"
+
 /*
  * The PVR Sync API is unusual in that some operations configure the
  * timeline for use, and are no longer allowed once the timeline is
@@ -74,6 +77,7 @@ struct pvr_sync_file_data {
 	atomic_t in_use;
 	void *api_private;
 	bool is_sw;
+	bool is_export;
 };
 
 static bool pvr_sync_set_in_use(struct pvr_sync_file_data *fdata)
@@ -174,22 +178,25 @@ int pvr_sync_close_common(void *connection_data)
 	return 0;
 }
 
-static inline int pvr_sync_ioctl_rename(void *api_priv, void *arg)
-{
-	struct pvr_sync_rename_ioctl_data *data = arg;
+#define PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(name, type) \
+static inline int pvr_sync_ioctl_common_internal_ ## name(struct pvr_sync_file_data *fdata, type data)
 
-	return pvr_sync_api_rename(api_priv, data);
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(rename, struct pvr_sync_rename_ioctl_data *)
+{
+	return pvr_sync_api_rename(fdata->api_private, data);
 }
 
-static inline int pvr_sync_ioctl_force_sw_only(struct pvr_sync_file_data *fdata)
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(force_sw_only, void*)
 {
-	void *data = fdata->api_private;
+	void *new_api_private = fdata->api_private;
 	int err;
 
-	err = pvr_sync_api_force_sw_only(fdata->api_private, &data);
+	PVR_UNREFERENCED_PARAMETER(data);
+
+	err = pvr_sync_api_force_sw_only(fdata->api_private, &new_api_private);
 	if (!err) {
-		if (data != fdata->api_private)
-			fdata->api_private = data;
+		if (new_api_private != fdata->api_private)
+			fdata->api_private = new_api_private;
 
 		fdata->is_sw = true;
 	}
@@ -197,81 +204,202 @@ static inline int pvr_sync_ioctl_force_sw_only(struct pvr_sync_file_data *fdata)
 	return err;
 }
 
-static inline int pvr_sync_ioctl_sw_create_fence(void *api_priv, void *arg)
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(force_exp_only, void*)
 {
-	struct pvr_sw_sync_create_fence_data *data = arg;
+	int err;
+	PVR_UNREFERENCED_PARAMETER(data);
+
+	err = pvr_sync_api_force_exp_only(fdata->api_private, data);
+	if (!err)
+		fdata->is_export = true;
 
-	return pvr_sync_api_sw_create_fence(api_priv, data);
+	return err;
 }
 
-static inline int pvr_sync_ioctl_sw_inc(void *api_priv, void *arg)
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(create_export_fence, void*)
 {
-	struct pvr_sw_timeline_advance_data *data = arg;
-
-	return pvr_sync_api_sw_inc(api_priv, data);
+	return pvr_sync_api_create_export_fence(fdata->api_private, data);
 }
 
-int pvr_sync_ioctl_common(struct file *file, unsigned int cmd, void *arg)
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(sw_create_fence, struct pvr_sw_sync_create_fence_data *)
 {
-	int err = -ENOTTY;
-	struct pvr_sync_file_data *fdata;
-	bool in_setup;
-
-	fdata = pvr_sync_get_private_data(file);
-	if (!fdata)
-		return -EINVAL;
-
-	switch (cmd) {
-	case DRM_PVR_SYNC_RENAME_CMD:
-	case DRM_PVR_SYNC_FORCE_SW_ONLY_CMD:
-		if (!pvr_sync_set_in_setup(fdata))
-			return -EBUSY;
-
-		in_setup = true;
-		break;
-	default:
-		if (!pvr_sync_set_in_use(fdata))
-			return -EBUSY;
+	return pvr_sync_api_sw_create_fence(fdata->api_private, data);
+}
 
-		in_setup = false;
-		break;
-	}
+PVR_SYNC_IOCTL_DISPATCH_INTERNAL_DECL(sw_inc, struct pvr_sw_timeline_advance_data *)
+{
+	return pvr_sync_api_sw_inc(fdata->api_private, data);
+}
 
-	if (in_setup) {
-		if (fdata->is_sw)
-			err = -ENOTTY;
-		else
-			switch (cmd) {
-			case DRM_PVR_SYNC_RENAME_CMD:
-				err = pvr_sync_ioctl_rename(fdata->api_private,
-							    arg);
-				break;
-			case DRM_PVR_SYNC_FORCE_SW_ONLY_CMD:
-				err = pvr_sync_ioctl_force_sw_only(fdata);
-				break;
-			default:
-				break;
-			}
-	} else {
-		if (!fdata->is_sw)
-			err = -ENOTTY;
-		else
-			switch (cmd) {
-			case DRM_PVR_SW_SYNC_CREATE_FENCE_CMD:
-				err = pvr_sync_ioctl_sw_create_fence(fdata->api_private,
-								     arg);
-				break;
-			case DRM_PVR_SW_SYNC_INC_CMD:
-				err = pvr_sync_ioctl_sw_inc(fdata->api_private,
-							    arg);
-				break;
-			default:
-				break;
-			}
-	}
+/*
+ * enum pvr_sync_ioctl_dispatch_type
+ * @pvr_sync_ioctl_dispatch_type_setup: The command may only be used during the setup phase
+ * @pvr_sync_ioctl_dispatch_type_export: The command may only be used with an export only timeline.
+ * @pvr_sync_ioctl_dispatch_type_software: The command may only be used with a software only timeline.
+ */
+enum pvr_sync_ioctl_dispatch_type {
+	pvr_sync_ioctl_dispatch_type_setup,
+	pvr_sync_ioctl_dispatch_type_export,
+	pvr_sync_ioctl_dispatch_type_software,
+};
 
-	if (in_setup)
-		pvr_sync_reset_in_setup(fdata);
+/* Generates a function `from` which performs validation on the data before passing it to `into` */
+#define PVR_SYNC_IOCTL_DISPATCH_VALIDATE(name, structure, type)                                                                        \
+PVR_SYNC_IOCTL_DISPATCH_DECL(name)                                                                                                     \
+{                                                                                                                                      \
+	int err = -ENOTTY;                                                                                                                 \
+	structure server_data;                                                                                                             \
+                                                                                                                                       \
+	struct pvr_sync_file_data *fdata = pvr_sync_get_private_data(file);                                                                \
+	if (unlikely(!fdata))                                                                                                              \
+		return -EINVAL;                                                                                                                \
+                                                                                                                                       \
+	/* Check if the device is busy and the operation is valid for the timelines current state */                                       \
+	if (type == pvr_sync_ioctl_dispatch_type_setup)                                                                                    \
+	{                                                                                                                                  \
+		if (!pvr_sync_set_in_setup(fdata))                                                                                             \
+			return -EBUSY;                                                                                                             \
+		if (fdata->is_sw || fdata->is_export)                                                                                          \
+			goto return_;                                                                                                              \
+	}                                                                                                                                  \
+	else                                                                                                                               \
+	{                                                                                                                                  \
+		if (!pvr_sync_set_in_use(fdata))                                                                                               \
+			return -EBUSY;                                                                                                             \
+                                                                                                                                       \
+		switch (type)                                                                                                                  \
+		{                                                                                                                              \
+		case pvr_sync_ioctl_dispatch_type_software: {                                                                                  \
+			if (!fdata->is_sw) /* Not a software timeline, software operations cannot be used */                                       \
+				goto return_;                                                                                                          \
+		}                                                                                                                              \
+		break;                                                                                                                         \
+		case pvr_sync_ioctl_dispatch_type_export: {                                                                                    \
+			if (!fdata->is_export) /* Not an export timeline, export operations cannot be used */                                      \
+				goto return_;                                                                                                          \
+		}                                                                                                                              \
+		break;                                                                                                                         \
+		default:                                                                                                                       \
+			goto return_; /* Invalid Type */                                                                                           \
+		}                                                                                                                              \
+	}                                                                                                                                  \
+                                                                                                                                       \
+	/* copy_from_user */                                                                                                               \
+	err = pvr_sync_ioctl_dispatch_copy_in__##name((structure __user *)user_data, &server_data);                                        \
+	if (unlikely(err))                                                                                                                 \
+		goto return_;                                                                                                                  \
+                                                                                                                                       \
+	/* Continue into api */                                                                                                            \
+	err = pvr_sync_ioctl_common_internal_ ## name(fdata, (structure __force *) PVR_SYNC_IOCTL_DISPATCH_DATA(user_data, &server_data)); \
+                                                                                                                                       \
+	if (likely(!err))                                                                                                                  \
+	{                                                                                                                                  \
+		/* copy_to_user */                                                                                                             \
+		err = pvr_sync_ioctl_dispatch_copy_out__##name((structure __user *)user_data, &server_data);                                   \
+	}                                                                                                                                  \
+                                                                                                                                       \
+return_:                                                                                                                               \
+	if (type == pvr_sync_ioctl_dispatch_type_setup)                                                                                    \
+		pvr_sync_reset_in_setup(fdata);                                                                                                \
+	return err;                                                                                                                        \
+}
 
-	return err;
+#if !defined(USE_PVRSYNC_DEVNODE)
+/* drm_ioctl() already copies the data over, see comment on drm_ioctl_t */
+#define PVR_SYNC_IOCTL_DISPATCH_DATA(pUM, pKM) pUM
+#define PVR_SYNC_IOCTL_DISPATCH_COPY_WRAPPER(dir, name, structure, copy) \
+INLINE static int pvr_sync_ioctl_dispatch_copy_ ## dir ## __ ## name (structure __user *pUM, structure *pKM) \
+{ return 0; }
+#else /* !defined(USE_PVRSYNC_DEVNODE) */
+/* Generates a function to copy over the arguments to/from user-mode */
+#define PVR_SYNC_IOCTL_DISPATCH_DATA(pUM, pKM) pKM
+#define PVR_SYNC_IOCTL_DISPATCH_COPY_WRAPPER(dir, name, structure, copy)                                     \
+INLINE static int pvr_sync_ioctl_dispatch_copy_ ## dir ## __ ## name (structure __user *pUM, structure *pKM) \
+{                                                                                                            \
+	/* May be unused if there are no in/out args */                                                          \
+	PVR_UNREFERENCED_PARAMETER(pUM);                                                                         \
+	PVR_UNREFERENCED_PARAMETER(pKM);                                                                         \
+	/* Copy over the data */                                                                                 \
+	{ copy }                                                                                                 \
+	return 0;                                                                                                \
+}
+#endif /* !defined(USE_PVRSYNC_DEVNODE) */
+
+/*************************************************************************/ /*!
+@Function       PVR_SYNC_IOCTL_DISPATCH_COPY
+@Description    Generates the code to copy from/to user mode depending on @dir.
+@Input          dir  Either `from` or `to` corresponding to `copy_from_user`
+                    and `copy_to_user` respectively.
+@Input          to   Pointer for the dest.
+@Input          from Pointer for the src.
+*/ /**************************************************************************/
+#define PVR_SYNC_IOCTL_DISPATCH_COPY(dir, to, from)        \
+if (pvr_copy_##dir##_user(to, from, sizeof(*pKM)))         \
+{                                                          \
+	PVR_DPF((PVR_DBG_ERROR, "Failed copy " #dir " user")); \
+	return -EFAULT;                                        \
 }
+
+/* Copy data from user */
+#define PVR_SYNC_IOCTL_DISPATCH_COPY_IN \
+PVR_SYNC_IOCTL_DISPATCH_COPY(from, pKM, pUM)
+
+/* Copy data to user */
+#define PVR_SYNC_IOCTL_DISPATCH_COPY_OUT \
+PVR_SYNC_IOCTL_DISPATCH_COPY(to, pUM, pKM)
+
+/* Copy no data */
+#define PVR_SYNC_IOCTL_DISPATCH_COPY_NONE
+
+/*************************************************************************/ /*!
+@Function       PVR_SYNC_IOCTL_DISPATCH_FUNCTION
+@Description    Generates a dispatch function which validates the ioctl command
+                and dispatches it to the internal an function.
+                Generates a dispatch function
+                `pvr_sync_ioctl_common_##name(struct file*, void*)`
+                which validates the ioctl command and dispatches it to
+                an internal function
+                `pvr_sync_ioctl_common_internal_##name(struct pvr_sync_file_data*, structure*)`
+@Input          name      A name for the dispatch functions, must be unique.
+@Input          structure The type of the user_data.
+@Input          type      The type specifies when the ioctls are allowed or
+                          if the ioctl is allowed on the current
+                          timeline configuration.
+@Input          copy_in   Either `COPY_IN` or `COPY_NONE`
+@Input          copy_out  Either `COPY_OUT` or `COPY_NONE`
+*/ /**************************************************************************/
+#define PVR_SYNC_IOCTL_DISPATCH_FUNCTION(name, structure, type, copy_in, copy_out) \
+	PVR_SYNC_IOCTL_DISPATCH_COPY_WRAPPER(in, name, structure, PVR_SYNC_IOCTL_DISPATCH_ ## copy_in) \
+	PVR_SYNC_IOCTL_DISPATCH_COPY_WRAPPER(out, name, structure, PVR_SYNC_IOCTL_DISPATCH_ ## copy_out) \
+	PVR_SYNC_IOCTL_DISPATCH_VALIDATE(name, structure, pvr_sync_ioctl_dispatch_type_ ## type)
+
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(rename, struct pvr_sync_rename_ioctl_data,
+                                 setup,
+                                 COPY_IN,
+                                 COPY_NONE);
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(force_sw_only, void*,
+                                 setup,
+                                 COPY_NONE,
+                                 COPY_NONE);
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(force_exp_only, void*,
+                                 setup,
+                                 COPY_NONE,
+                                 COPY_NONE);
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(sw_create_fence, struct pvr_sw_sync_create_fence_data,
+                                 software,
+                                 COPY_IN,
+                                 COPY_OUT);
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(create_export_fence, pvr_exp_sync_create_fence_data_t,
+                                 export,
+                                 COPY_IN,
+                                 COPY_OUT);
+
+PVR_SYNC_IOCTL_DISPATCH_FUNCTION(sw_inc, struct pvr_sw_timeline_advance_data,
+                                 software,
+                                 COPY_NONE,
+                                 COPY_OUT);
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.h b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.h
index ef12dc298368..0959e7673164 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.h
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_common.h
@@ -46,16 +46,30 @@
 
 struct file;
 
-/* Functions provided by pvr_sync_ioctl_common */
+/* Functions provided by pvr_sync_ioctl_common.c */
 
 int pvr_sync_open_common(void *connection_data, void *file_handle);
 int pvr_sync_close_common(void *connection_data);
-int pvr_sync_ioctl_common(struct file *file, unsigned int cmd, void *arg);
 void *pvr_sync_get_api_priv_common(struct file *file);
 
+#if defined(USE_PVRSYNC_DEVNODE)
+#define PVR_SYNC_IOCTL_DISPATCH_DECL(name) \
+	int pvr_sync_ioctl_common_ ## name(struct file *file, void __user *user_data)
+#else /* defined(USE_PVRSYNC_DEVNODE) */
+#define PVR_SYNC_IOCTL_DISPATCH_DECL(name) \
+	int pvr_sync_ioctl_common_ ## name(struct file *file, void *user_data)
+#endif /* defined(USE_PVRSYNC_DEVNODE) */
+
+PVR_SYNC_IOCTL_DISPATCH_DECL(rename);
+PVR_SYNC_IOCTL_DISPATCH_DECL(force_sw_only);
+PVR_SYNC_IOCTL_DISPATCH_DECL(force_exp_only);
+PVR_SYNC_IOCTL_DISPATCH_DECL(sw_create_fence);
+PVR_SYNC_IOCTL_DISPATCH_DECL(create_export_fence);
+PVR_SYNC_IOCTL_DISPATCH_DECL(sw_inc);
+
 struct pvr_sync_file_data;
 
-/* Functions required by pvr_sync_ioctl_common */
+/* Functions required by pvr_sync_ioctl_common.c */
 
 bool pvr_sync_set_private_data(void *connection_data,
 			       struct pvr_sync_file_data *fdata);
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.c b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.c
index 423c8d3a75ef..313393d09c1f 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.c
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.c
@@ -127,35 +127,51 @@ void pvr_sync_close(void *connection_data)
 	if (iErr < 0)
 		pr_err("%s: ERROR (%d) returned by pvr_sync_close_common()\n",
 		       __func__, iErr);
+
+	iErr = OSConnectionPrivateDataDeInit(PVRSRVConnectionPrivateData(connection_data));
+	if (iErr != 0)
+		pr_err("%s: ERROR (%d) returned by OSConnectionPrivateDataDeInit()\n",
+		       __func__, iErr);
+
+	if (connection_data)
+		kfree(connection_data);
 }
 
 
 int pvr_sync_rename_ioctl(struct drm_device __maybe_unused *dev,
 			  void *arg, struct drm_file *file)
 {
-	return pvr_sync_ioctl_common(file->filp,
-				     DRM_PVR_SYNC_RENAME_CMD, arg);
+	return pvr_sync_ioctl_common_rename(file->filp, arg);
 }
 
 int pvr_sync_force_sw_only_ioctl(struct drm_device __maybe_unused *dev,
 				 void *arg, struct drm_file *file)
 {
-	return pvr_sync_ioctl_common(file->filp,
-				     DRM_PVR_SYNC_FORCE_SW_ONLY_CMD, arg);
+	return pvr_sync_ioctl_common_force_sw_only(file->filp, arg);
 }
 
 int pvr_sw_sync_create_fence_ioctl(struct drm_device __maybe_unused *dev,
 				   void *arg, struct drm_file *file)
 {
-	return pvr_sync_ioctl_common(file->filp,
-				     DRM_PVR_SW_SYNC_CREATE_FENCE_CMD, arg);
+	return pvr_sync_ioctl_common_sw_create_fence(file->filp, arg);
 }
 
 int pvr_sw_sync_inc_ioctl(struct drm_device __maybe_unused *dev,
 			  void *arg, struct drm_file *file)
 {
-	return pvr_sync_ioctl_common(file->filp,
-				     DRM_PVR_SW_SYNC_INC_CMD, arg);
+	return pvr_sync_ioctl_common_sw_inc(file->filp, arg);
+}
+
+int pvr_sync_ioctl_force_exp_only(struct drm_device __maybe_unused *dev,
+			  void *arg, struct drm_file *file)
+{
+	return pvr_sync_ioctl_common_force_exp_only(file->filp, arg);
+}
+
+int pvr_export_fence_sync_create_fence_ioctl(struct drm_device __maybe_unused *dev,
+			  void *arg, struct drm_file *file)
+{
+	return pvr_sync_ioctl_common_create_export_fence(file->filp, arg);
 }
 
 int pvr_sync_ioctl_init(void)
diff --git a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.h b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.h
index 756ce4bf71e6..93182205ca0b 100644
--- a/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.h
+++ b/drivers/gpu/drm/img-rogue/pvr_sync_ioctl_drm.h
@@ -58,5 +58,9 @@ int pvr_sw_sync_create_fence_ioctl(struct drm_device *dev, void *arg,
 				   struct drm_file *file);
 int pvr_sw_sync_inc_ioctl(struct drm_device *dev, void *arg,
 			  struct drm_file *file);
+int pvr_sync_ioctl_force_exp_only(struct drm_device *dev, void *arg,
+			  struct drm_file *file);
+int pvr_export_fence_sync_create_fence_ioctl(struct drm_device *dev, void *arg,
+			  struct drm_file *file);
 
 #endif /* _PVR_SYNC_IOCTL_DRM_H */
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv.c b/drivers/gpu/drm/img-rogue/pvrsrv.c
index 0eb314399c60..51f7de420dc5 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv.c
+++ b/drivers/gpu/drm/img-rogue/pvrsrv.c
@@ -94,8 +94,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "tlintern.h"
 #include "htbserver.h"
+#include "rgxmulticore.h"
 
-#define MULTI_DEVICE_BRINGUP
+
+//#define MULTI_DEVICE_BRINGUP
 
 #if defined(MULTI_DEVICE_BRINGUP)
 #define MULTI_DEVICE_BRINGUP_DPF(msg, ...) PVR_DPF((PVR_DBG_MESSAGE, msg, __VA_ARGS__))
@@ -107,6 +109,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxinit.h"
 #include "rgxhwperf.h"
 #include "rgxfwutils.h"
+#include "rgx_bridge_init.h"
 #endif
 
 #if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
@@ -123,6 +126,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #if defined(SUPPORT_LINUX_DVFS)
 #include "pvr_dvfs_device.h"
+#elif defined(SUPPORT_PDVFS)
+#include "pvr_dvfs_common.h"
 #endif
 
 #if defined(SUPPORT_DISPLAY_CLASS)
@@ -169,7 +174,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /*! When unloading try a few times to free everything remaining on the list */
 #define CLEANUP_THREAD_UNLOAD_RETRY 4
 
-#define PVRSRV_TL_CTLR_STREAM_SIZE 4096
+#define PVRSRV_TL_CTRL_STREAM_SIZE 4096
 
 static PVRSRV_DATA	*gpsPVRSRVData;
 static IMG_UINT32 g_ui32InitFlags;
@@ -334,11 +339,15 @@ void PVRSRVCleanupThreadAddWork_Int(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_CLE
 
 	PVR_DPF((PVR_DBG_MESSAGE, "AFTER QUEUEING ----- %s", _ConcatCleanupString(acCleanupString)));
 
+
+	/* Cleanup thread work item added during device destructing:
+	   1. bDependsOnHW: Item may use device resources. Not safe to clean.
+	   2. !bDependsOnHW: Clean item immediately to prevent memory leak. */
+	if (psPVRSRVData->bUnload
 #if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
-	if (psPVRSRVData->eServicesState != PVRSRV_SERVICES_STATE_OK || psPVRSRVData->bUnload)
-#else
-	if (psPVRSRVData->bUnload)
+		|| psPVRSRVData->eServicesState != PVRSRV_SERVICES_STATE_OK
 #endif
+		|| (psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING && !psData->bDependsOnHW))
 	{
 		CLEANUP_THREAD_FN pfnFree = psData->pfnFree;
 
@@ -373,6 +382,7 @@ void PVRSRVCleanupThreadAddWork_Int(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_CLE
 
 		/* add this work item to the list */
 		OSSpinLockAcquire(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
+		OSAtomicIncrement(&psDeviceNode->i32NumCleanupItems);
 		dllist_add_to_tail(&psDeviceNode->sCleanupThreadWorkList, &psData->sNode);
 		OSSpinLockRelease(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
 
@@ -386,8 +396,10 @@ void PVRSRVCleanupThreadAddWork_Int(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_CLE
 
 void PVRSRVCleanupThreadWaitForDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
+#if defined(DEBUG)
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
-	IMG_BOOL bIsEmpty;
+#endif
+	IMG_INT32 i32NumCleanupItems;
 
 	PVR_ASSERT(psDeviceNode != NULL);
 
@@ -396,9 +408,8 @@ void PVRSRVCleanupThreadWaitForDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		return;
 	}
 
-	LOOP_UNTIL_TIMEOUT(OS_THREAD_DESTROY_TIMEOUT_US)
+	LOOP_UNTIL_TIMEOUT_US(OS_THREAD_DESTROY_TIMEOUT_US)
 	{
-		OS_SPINLOCK_FLAGS uiFlags;
 		PVRSRV_ERROR eError;
 
 		if (gpsPVRSRVData->hCleanupEventObject)
@@ -407,19 +418,30 @@ void PVRSRVCleanupThreadWaitForDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 			PVR_LOG_IF_ERROR(eError, "OSEventObjectSignal");
 		}
 
-		OSSpinLockAcquire(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
-		bIsEmpty = dllist_is_empty(&psDeviceNode->sCleanupThreadWorkList);
-		OSSpinLockRelease(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
+		i32NumCleanupItems = OSAtomicRead(&psDeviceNode->i32NumCleanupItems);
 
-		if (bIsEmpty)
+		if (i32NumCleanupItems == 0)
 		{
+#if defined(DEBUG)
+			OS_SPINLOCK_FLAGS uiFlags;
+
+			OSSpinLockAcquire(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
+			PVR_LOG_IF_FALSE(dllist_is_empty(&psDeviceNode->sCleanupThreadWorkList),
+							 "Cleanup thread work list is not empty");
+
+			OSSpinLockRelease(psPVRSRVData->hCleanupThreadWorkListLock, uiFlags);
+#endif
 			break;
 		}
 
 		OSWaitus(OS_THREAD_DESTROY_TIMEOUT_US / OS_THREAD_DESTROY_RETRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
+
+	if (i32NumCleanupItems != 0)
+	{
+		PVR_LOG(("Failed to flush device cleanup queue. %d items remain.", i32NumCleanupItems));
+	}
 
-	PVR_LOG_IF_FALSE(bIsEmpty, "Failed to flush device cleanup queue");
 #if defined(DEBUG)
 	_CleanupThreadWorkListDump(psPVRSRVData);
 #endif
@@ -493,9 +515,15 @@ static INLINE DLLIST_NODE *_CleanupThreadWorkListPop(PVRSRV_DATA *psPVRSRVData,
 	     psDeviceNode != NULL;
 	     psDeviceNode = psDeviceNode->psNext)
 	{
+		/* not safe to run cleanup during deinit */
+		if (psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)
+		{
+			continue;
+		}
+
 		psNode = dllist_get_next_node(&psDeviceNode->sCleanupThreadWorkList);
 
-		/* remember fist non-NULL node and device in case no items are found
+		/* remember first non-NULL node and device in case no items are found
 		 * on later devices */
 		if (psNode != NULL && psFirstNode == NULL)
 		{
@@ -659,6 +687,7 @@ static IMG_BOOL _CleanupThreadProcessWorkList(PVRSRV_DATA *psPVRSRVData,
 				PVR_DPF((PVR_DBG_ERROR, "Failed to free resource (callback " IMG_PFN_FMTSPEC "). "
 				        "Retry limit reached", pfnFree));
 				OSAtomicIncrement(&psPVRSRVData->i32NumCleanupItemsNotCompleted);
+				OSAtomicDecrement(&psDeviceNode->i32NumCleanupItems);
 				/* Dropping item */
 				_CleanupThreadDecrementStats(psPVRSRVData, eCleanupType);
 			}
@@ -666,6 +695,7 @@ static IMG_BOOL _CleanupThreadProcessWorkList(PVRSRV_DATA *psPVRSRVData,
 		else
 		{
 			/* Ok returned */
+			OSAtomicDecrement(&psDeviceNode->i32NumCleanupItems);
 			_CleanupThreadDecrementStats(psPVRSRVData, eCleanupType);
 		}
 	} while (psNodeIter != NULL && psNodeIter != psNodeLast);
@@ -794,6 +824,7 @@ static void CleanupThread(void *pvData)
 
 			psData = IMG_CONTAINER_OF(psNodeIter, PVRSRV_CLEANUP_THREAD_WORK, sNode);
 			OSAtomicIncrement(&psPVRSRVData->i32NumCleanupItemsNotCompleted);
+			OSAtomicDecrement(&psDeviceNode->i32NumCleanupItems);
 			/* Dropping item */
 			_CleanupThreadDecrementStats(psPVRSRVData, psData->eCleanupType);
 		}
@@ -898,6 +929,7 @@ static PVRSRV_ERROR HandleFwHostSideRecovery(PVRSRV_DEVICE_NODE *psDeviceNode)
 }
 #endif
 
+
 void PVRSRVDeviceSetState(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_DEVICE_STATE eNewDevState)
 {
 	if (eNewDevState == psDeviceNode->eDevState)
@@ -921,8 +953,8 @@ void PVRSRVDeviceSetState(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_DEVICE_STATE
 		case PVRSRV_DEVICE_STATE_ACTIVE:
 		case PVRSRV_DEVICE_STATE_FROZEN:
 		case PVRSRV_DEVICE_STATE_DEINIT:
+		case PVRSRV_DEVICE_STATE_DESTRUCTING:
 		case PVRSRV_DEVICE_STATE_BAD:
-		case PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF:
 		{
 			/* PCI_ERROR is a terminal state. Reload driver to recover. */
 			if (eNewDevState != PVRSRV_DEVICE_STATE_PCI_ERROR)
@@ -1122,9 +1154,6 @@ static DWT_SIGNAL _DwtWait(PVRSRV_DATA *psPVRSRVData, IMG_HANDLE hOSEvent,
 
 	eError = OSEventObjectWaitKernel(hOSEvent, (IMG_UINT64) ui32Timeout * 1000);
 
-#ifdef PVR_TESTING_UTILS
-	psPVRSRVData->ui32DevicesWdWakeupCounter++;
-#endif
 
 	if (eError == PVRSRV_OK)
 	{
@@ -1316,9 +1345,6 @@ static void DevicesWatchdogThread(void *pvData)
 		   to initialise) or for the event signal (shutdown or power on). */
 		eError = OSEventObjectWaitKernel(hOSEvent, (IMG_UINT64)ui32Timeout * 1000);
 
-#ifdef PVR_TESTING_UTILS
-		psPVRSRVData->ui32DevicesWdWakeupCounter++;
-#endif
 		if (eError == PVRSRV_OK)
 		{
 			if (psPVRSRVData->bUnload)
@@ -1385,11 +1411,7 @@ static void DevicesWatchdogThread(void *pvData)
 #if defined(SUPPORT_AUTOVZ)
 static void AutoVzWatchdogThread_ForEachCb(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	if (psDeviceNode->eDevState != PVRSRV_DEVICE_STATE_ACTIVE)
-	{
-		return;
-	}
-	else if (psDeviceNode->pfnUpdateAutoVzWatchdog != NULL)
+	if (psDeviceNode->pfnUpdateAutoVzWatchdog != NULL)
 	{
 		psDeviceNode->pfnUpdateAutoVzWatchdog(psDeviceNode);
 	}
@@ -1498,6 +1520,80 @@ static void _ThreadsDebugRequestNotify(PVRSRV_DBGREQ_HANDLE hDbgRequestHandle,
 	}
 }
 
+#define PVRVZMODE_STR_SIZE_MAX (10U)
+#define PVRVZMODE_BUFFER_SIZE (((PVRSRV_MAX_DEVICES)*(PVRVZMODE_STR_SIZE_MAX))+1)
+
+static const IMG_CHAR *const asModeStrings[] =
+{
+	"native",
+	"host",
+	"guest",
+	"default"
+};
+
+static void _InitDefaultVzDriverMode(PVRSRV_DATA *psPVRSRVData, void *pvAppHintState)
+{
+	char *pszMode, pszModeAppHint[PVRVZMODE_BUFFER_SIZE];
+	static const IMG_CHAR *pszDefault = "";
+	PVRSRV_DRIVER_MODE aeInitModes[PVRSRV_MAX_DEVICES];
+	IMG_BOOL bRet;
+	IMG_UINT ui32Dev;
+
+	for (ui32Dev = 0; ui32Dev < PVRSRV_MAX_DEVICES; ui32Dev++)
+	{
+		aeInitModes[ui32Dev] = DRIVER_MODE_DEFAULT;
+	}
+
+	pszMode = pszModeAppHint;
+	pszModeAppHint[0] = '\0';
+
+	bRet = (IMG_BOOL) OSGetAppHintSTRING(APPHINT_NO_DEVICE,
+						pvAppHintState,
+						DriverMode,
+						pszDefault,
+						pszModeAppHint,
+						PVRVZMODE_BUFFER_SIZE);
+	PVR_GOTO_IF_FALSE(bRet, uninit_default);
+
+	ui32Dev = 0;
+
+	while (*pszMode && (ui32Dev < PVRSRV_MAX_DEVICES))
+	{
+		PVRSRV_DRIVER_MODE eMode;
+
+		while (*pszMode == ',')
+		{
+			/* skip commas */
+			pszMode++;
+		}
+
+		for (eMode = DRIVER_MODE_NATIVE; eMode <= DRIVER_MODE_DEFAULT; eMode++)
+		{
+			/* if no matching strings found, device's mode remains DEFAULT */
+			if (OSStringNCompare(pszMode,
+								 asModeStrings[eMode],
+								 OSStringLength(asModeStrings[eMode])) == 0)
+			{
+				aeInitModes[ui32Dev] = eMode;
+			}
+		}
+
+		while ((*pszMode != '\0') && (*pszMode != ','))
+		{
+			/* advance until the next command or string end */
+			pszMode++;
+		}
+
+		ui32Dev++;
+	}
+
+uninit_default:
+	for (ui32Dev = 0; ui32Dev < PVRSRV_MAX_DEVICES; ui32Dev++)
+	{
+		psPVRSRVData->aeModuleParamDriverMode[ui32Dev] = aeInitModes[ui32Dev];
+	}
+}
+
 PVRSRV_ERROR
 PVRSRVCommonDriverInit(void)
 {
@@ -1525,6 +1621,10 @@ PVRSRVCommonDriverInit(void)
 		return PVRSRV_ERROR_ALREADY_EXISTS;
 	}
 
+#if defined(SUPPORT_RGX)
+	RGXBridgeDriverInit();
+#endif
+
 	eError = DIInit();
 	PVR_GOTO_IF_ERROR(eError, Error);
 
@@ -1642,6 +1742,10 @@ PVRSRVCommonDriverInit(void)
 	bAppHintDefault = PVRSRV_APPHINT_ENABLEFULLSYNCTRACKING;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE, pvAppHintState, EnableFullSyncTracking,
 			&bAppHintDefault, &bEnableFullSyncTracking);
+
+	_InitDefaultVzDriverMode(gpsPVRSRVData, pvAppHintState);
+
+
 	OSFreeAppHintState(pvAppHintState);
 	pvAppHintState = NULL;
 
@@ -1708,8 +1812,14 @@ PVRSRVCommonDriverInit(void)
 
 	/* Initialise TL control stream */
 	eError = TLStreamCreate(&psPVRSRVData->hTLCtrlStream,
-	                        PVRSRV_TL_CTLR_STREAM, PVRSRV_TL_CTLR_STREAM_SIZE,
-	                        TL_OPMODE_DROP_OLDEST, NULL, NULL, NULL,
+	                        PVRSRV_TL_CTRL_STREAM,
+	                        PVRSRV_TL_CTRL_STREAM_SIZE,
+	                        TL_OPMODE_DROP_OLDEST,
+	                        NULL,
+	                        NULL,
+	                        NULL,
+	                        NULL,
+	                        NULL,
                             NULL);
 	if (eError != PVRSRV_OK)
 	{
@@ -1824,7 +1934,7 @@ PVRSRVCommonDriverDeInit(void)
 	/* Stop and cleanup the devices watchdog thread */
 	if (gpsPVRSRVData->hAutoVzWatchdogThread)
 	{
-		LOOP_UNTIL_TIMEOUT(OS_THREAD_DESTROY_TIMEOUT_US)
+		LOOP_UNTIL_TIMEOUT_US(OS_THREAD_DESTROY_TIMEOUT_US)
 		{
 			if (gpsPVRSRVData->hAutoVzWatchdogEvObj)
 			{
@@ -1839,7 +1949,7 @@ PVRSRVCommonDriverDeInit(void)
 				break;
 			}
 			OSWaitus(OS_THREAD_DESTROY_TIMEOUT_US/OS_THREAD_DESTROY_RETRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 		PVR_LOG_IF_ERROR(eError, "OSThreadDestroy");
 	}
 
@@ -1854,7 +1964,7 @@ PVRSRVCommonDriverDeInit(void)
 	/* Stop and cleanup the devices watchdog thread */
 	if (gpsPVRSRVData->hDevicesWatchdogThread)
 	{
-		LOOP_UNTIL_TIMEOUT(OS_THREAD_DESTROY_TIMEOUT_US)
+		LOOP_UNTIL_TIMEOUT_US(OS_THREAD_DESTROY_TIMEOUT_US)
 		{
 			if (gpsPVRSRVData->hDevicesWatchdogEvObj)
 			{
@@ -1869,7 +1979,7 @@ PVRSRVCommonDriverDeInit(void)
 				break;
 			}
 			OSWaitus(OS_THREAD_DESTROY_TIMEOUT_US/OS_THREAD_DESTROY_RETRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 		PVR_LOG_IF_ERROR(eError, "OSThreadDestroy");
 	}
 
@@ -1885,7 +1995,7 @@ PVRSRVCommonDriverDeInit(void)
 	 */
 	if (gpsPVRSRVData->hCleanupThread)
 	{
-		LOOP_UNTIL_TIMEOUT(OS_THREAD_DESTROY_TIMEOUT_US)
+		LOOP_UNTIL_TIMEOUT_US(OS_THREAD_DESTROY_TIMEOUT_US)
 		{
 			if (gpsPVRSRVData->hCleanupEventObject)
 			{
@@ -1900,7 +2010,7 @@ PVRSRVCommonDriverDeInit(void)
 				break;
 			}
 			OSWaitus(OS_THREAD_DESTROY_TIMEOUT_US/OS_THREAD_DESTROY_RETRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 		PVR_LOG_IF_ERROR(eError, "OSThreadDestroy");
 	}
 
@@ -1962,10 +2072,6 @@ PVRSRVCommonDriverDeInit(void)
 
 	BridgeDispatcherDeinit();
 
-#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
-	RIDeInitKM();
-#endif
-
 #if defined(PVRSRV_PHYSMEM_CPUMAP_HISTORY)
 	CPUMappingHistoryDeInit();
 #endif
@@ -2005,6 +2111,9 @@ PVRSRVCommonDriverDeInit(void)
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	PVRSRVStatsDestroy();		/* Stage 2 freeing */
+#if defined(PVRSRV_ENABLE_GPU_MEMORY_INFO)
+	RIDeInitKM();
+#endif
 #endif /* PVRSRV_ENABLE_PROCESS_STATS */
 
 	OSFreeMemNoStats(gpsPVRSRVData);		/* Not trackable */
@@ -2020,6 +2129,8 @@ static void _SysDebugRequestNotify(PVRSRV_DBGREQ_HANDLE hDebugRequestHandle,
 	/* Only dump info once */
 	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE*) hDebugRequestHandle;
 
+	PVR_UNREFERENCED_PARAMETER(ui32VerbLevel);
+
 	PVR_DUMPDEBUG_LOG("------[ System Summary Device ID:%d ]------", psDeviceNode->sDevId.ui32InternalID);
 
 	switch (psDeviceNode->eCurrentSysPowerState)
@@ -2058,13 +2169,7 @@ PHYS_HEAP_CONFIG* PVRSRVFindPhysHeapConfig(PVRSRV_DEVICE_CONFIG *psDevConfig,
 	return NULL;
 }
 
-/*************************************************************************/ /*!
-@Function       PVRSRVAcquireInternalID
-@Description    Returns the lowest free device ID.
-@Output         pui32InternalID  The device ID
-@Return         PVRSRV_ERROR     PVRSRV_OK or an error code
-*/ /**************************************************************************/
-static PVRSRV_ERROR PVRSRVAcquireInternalID(IMG_UINT32 *pui32InternalID)
+PVRSRV_ERROR PVRSRVAcquireInternalID(IMG_UINT32 *pui32InternalID)
 {
 	IMG_UINT32 ui32InternalID = 0;
 	IMG_BOOL bFound = IMG_FALSE;
@@ -2099,8 +2204,7 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	PVRSRV_ERROR			eError;
 	PVRSRV_DEVICE_CONFIG	*psDevConfig;
 	PVRSRV_DEVICE_NODE		*psDeviceNode;
-	IMG_UINT32				ui32AppHintDefault;
-	IMG_UINT32				ui32AppHintDriverMode;
+	IMG_UINT32				ui32InternalID;
 
 #if defined(SUPPORT_PHYSMEM_TEST) && !defined(INTEGRITY_OS) && !defined(__QNXNTO__)
 	IMG_UINT32				ui32AppHintPhysMemTestPasses;
@@ -2117,22 +2221,13 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 
 	MULTI_DEVICE_BRINGUP_DPF("PVRSRVCommonDeviceCreate: DevId %d", i32KernelDeviceID);
 
-	/* Read driver mode (i.e. native, host or guest) AppHint early as it is
-	   required by SysDevInit */
-	ui32AppHintDefault = PVRSRV_APPHINT_DRIVERMODE;
-	OSCreateAppHintState(&pvAppHintState);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, DriverMode,
-						 &ui32AppHintDefault, &ui32AppHintDriverMode);
-	psPVRSRVData->eDriverMode = PVRSRV_VZ_APPHINT_MODE(ui32AppHintDriverMode);
-	psPVRSRVData->bForceApphintDriverMode = PVRSRV_VZ_APPHINT_MODE_IS_OVERRIDE(ui32AppHintDriverMode);
-
 	/* Determine if we've got EnablePageFaultDebug set or not */
 	bAppHintDefault = PVRSRV_APPHINT_ENABLEPAGEFAULTDEBUG;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE, pvAppHintState, EnablePageFaultDebug,
 			&bAppHintDefault, &bEnablePageFaultDebug);
 
 #if defined(SUPPORT_AUTOVZ)
-	bAppHintDefault = IMG_FALSE;
+	bAppHintDefault = PVRSRV_APPHINT_AUTOVZGPUPOWERDOWN;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE, pvAppHintState, AutoVzGPUPowerdown,
 			&bAppHintDefault, &bAutoVzGPUPowerdown);
 #endif
@@ -2149,6 +2244,7 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 #endif
 
 	dllist_init(&psDeviceNode->sCleanupThreadWorkList);
+	OSAtomicWrite(&psDeviceNode->i32NumCleanupItems, 0);
 
 	/* Record setting of EnablePageFaultDebug in device-node */
 	psDeviceNode->bEnablePFDebug = bEnablePageFaultDebug;
@@ -2156,12 +2252,17 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	psDeviceNode->bAutoVzAllowGPUPowerdown = bAutoVzGPUPowerdown;
 #endif
 	psDeviceNode->sDevId.i32KernelDeviceID = i32KernelDeviceID;
-	eError = PVRSRVAcquireInternalID(&psDeviceNode->sDevId.ui32InternalID);
+	eError = PVRSRVAcquireInternalID(&ui32InternalID);
 	PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVAcquireInternalID", ErrorDeregisterStats);
 
 	eError = SysDevInit(pvOSDevice, &psDevConfig);
 	PVR_LOG_GOTO_IF_ERROR(eError, "SysDevInit", ErrorDeregisterStats);
 
+	/* Lock down the InternalID for this device by saving the value into
+	 * its device node. This is done after SysDevInit to allow the system
+	 * layer to identify the current device's the internal ID the same way. */
+	psDeviceNode->sDevId.ui32InternalID = ui32InternalID;
+
 	PVR_ASSERT(psDevConfig);
 	PVR_ASSERT(psDevConfig->pvOSDevice == pvOSDevice);
 	PVR_ASSERT(!psDevConfig->psDevNode);
@@ -2179,6 +2280,9 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 
 	PVRSRVDeviceSetState(psDeviceNode, PVRSRV_DEVICE_STATE_CREATING);
 
+	psDeviceNode->psDevConfig = psDevConfig;
+	psDevConfig->psDevNode = psDeviceNode;
+
 	if (psDevConfig->pfnGpuDomainPower)
 	{
 		psDeviceNode->eCurrentSysPowerState = psDevConfig->pfnGpuDomainPower(psDeviceNode);
@@ -2186,9 +2290,7 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	else
 	{
 		/* If the System Layer doesn't provide a function to query the power state
-		 * of the system hardware, use a default implementation that keeps track of
-		 * the power state locally and assumes the system starting state */
-		psDevConfig->pfnGpuDomainPower = PVRSRVDefaultDomainPower;
+		 * of the system hardware, assume the system starting state below. */
 
 #if defined(SUPPORT_AUTOVZ)
 		psDeviceNode->eCurrentSysPowerState = PVRSRV_SYS_POWER_STATE_ON;
@@ -2197,14 +2299,12 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 #endif
 	}
 
-	psDeviceNode->psDevConfig = psDevConfig;
-	psDevConfig->psDevNode = psDeviceNode;
-
 #if defined(SUPPORT_PHYSMEM_TEST) && !defined(INTEGRITY_OS) && !defined(__QNXNTO__)
-	if (PVRSRV_VZ_MODE_IS(NATIVE))
+	if (PVRSRV_VZ_MODE_IS(NATIVE, DEVCFG, psDevConfig))
 	{
+		IMG_UINT32 ui32AppHintDefault = 0;
+
 		/* Read AppHint - Configurable memory test pass count */
-		ui32AppHintDefault = 0;
 		OSCreateAppHintState(&pvAppHintState);
 		OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, PhysMemTestPasses,
 				&ui32AppHintDefault, &ui32AppHintPhysMemTestPasses);
@@ -2219,15 +2319,6 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	}
 #endif
 
-	/* Initialise the paravirtualised connection */
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
-	{
-		PvzConnectionInit();
-		PVR_GOTO_IF_ERROR(eError, ErrorSysDevDeInit);
-	}
-
-	BIT_SET(psDevConfig->psDevNode->ui32VmState, RGXFW_HOST_DRIVER_ID);
-
 	/* Next update value will be 0xFFFFFFF7 since sync prim starts with 0xFFFFFFF6.
 	 * Has to be set before call to PMRInitDevice(). */
 	psDeviceNode->ui32NextMMUInvalidateUpdate = 0xFFFFFFF7U;
@@ -2299,12 +2390,15 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 #if defined(SUPPORT_LINUX_DVFS) && !defined(NO_HARDWARE)
 	eError = InitDVFS(psDeviceNode);
 	PVR_LOG_GOTO_IF_ERROR(eError, "InitDVFS", ErrorDVFSInitFail);
+#elif defined(SUPPORT_PDVFS) && !defined(NO_HARDWARE)
+	eError = InitPDVFS(psDeviceNode);
+	PVR_LOG_GOTO_IF_ERROR(eError, "InitPDVFS", ErrorPDVFSInitFail);
 #endif
 
 	OSAtomicWrite(&psDeviceNode->iNumClockSpeedChanges, 0);
 
-	OSWRLockCreate(&psDeviceNode->hMemoryContextPageFaultNotifyListLock);
-	if (psDeviceNode->hMemoryContextPageFaultNotifyListLock == NULL)
+	OSWRLockCreate(&psDeviceNode->hPageFaultNotifyLock);
+	if (psDeviceNode->hPageFaultNotifyLock == NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to create lock for PF notify list",
 		        __func__));
@@ -2338,9 +2432,6 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	PVR_LOG_GOTO_IF_ERROR(eError, "DebugCommonInitDevice",
 	                      ErrorDestroyMemoryContextPageFaultNotifyListLock);
 
-#if defined(PVR_TESTING_UTILS)
-	TUtilsInit(psDeviceNode);
-#endif
 	/* Create the devicemem_history hook for the device. We need to
 	 * have the debug-info instantiated before calling this.
 	 */
@@ -2373,6 +2464,15 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	psPVRSRVData->ui32RegisteredDevices++;
 	OSWRLockReleaseWrite(psPVRSRVData->hDeviceNodeListLock);
 
+	/* Initialise the paravirtualised connection */
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVCFG, psDevConfig))
+	{
+		PvzConnectionInit(psDevConfig);
+		PVR_GOTO_IF_ERROR(eError, ErrorSysDevDeInit);
+	}
+
+	BIT_SET(psDevConfig->psDevNode->ui32VmState, RGXFW_HOST_DRIVER_ID);
+
 	*ppsDeviceNode = psDeviceNode;
 
 #if defined(SUPPORT_LINUX_DVFS) && !defined(NO_HARDWARE)
@@ -2386,9 +2486,6 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	PVRSRVStatsDeregisterProcess(hProcessStats);
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	OSLockCreateNoStats(&psDeviceNode->hValidationLock);
-#endif
 
 	PVRSRVDeviceSetState(psDeviceNode, PVRSRV_DEVICE_STATE_CREATED);
 
@@ -2414,19 +2511,18 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 #endif
 
 ErrorDebugCommonDeInitDevice:
-#if defined(PVR_TESTING_UTILS)
-	TUtilsDeinit(psDeviceNode);
-#endif
 	DebugCommonDeInitDevice(psDeviceNode);
 
 ErrorDestroyMemoryContextPageFaultNotifyListLock:
-	OSWRLockDestroy(psDeviceNode->hMemoryContextPageFaultNotifyListLock);
-	psDeviceNode->hMemoryContextPageFaultNotifyListLock = NULL;
+	OSWRLockDestroy(psDeviceNode->hPageFaultNotifyLock);
+	psDeviceNode->hPageFaultNotifyLock = NULL;
 
 ErrorPageFaultLockFailCreate:
 
 #if defined(SUPPORT_LINUX_DVFS) && !defined(NO_HARDWARE)
 ErrorDVFSInitFail:
+#elif defined(SUPPORT_PDVFS) && !defined(NO_HARDWARE)
+ErrorPDVFSInitFail:
 #endif
 
 	if (psDeviceNode->hDbgReqNotify)
@@ -2457,9 +2553,9 @@ PVRSRV_ERROR PVRSRVCommonDeviceCreate(void *pvOSDevice,
 	PVRSRVUnregisterDeviceDbgTable(psDeviceNode);
 ErrorPvzConnectionDeInit:
 	psDevConfig->psDevNode = NULL;
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVCFG, psDevConfig))
 	{
-		PvzConnectionDeInit();
+		PvzConnectionDeInit(psDevConfig);
 	}
 ErrorSysDevDeInit:
 	SysDevDeInit(psDevConfig);
@@ -2556,7 +2652,7 @@ static PVRSRV_ERROR _ReadStateFlag(const PVRSRV_DEVICE_NODE *psDevice,
 
 PVRSRV_ERROR PVRSRVCommonDeviceInitialise(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	IMG_BOOL bInitSuccesful = IMG_FALSE;
+	IMG_BOOL bInitSuccessful = IMG_FALSE;
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
 	IMG_HANDLE hProcessStats;
 #endif
@@ -2639,62 +2735,56 @@ PVRSRV_ERROR PVRSRVCommonDeviceInitialise(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXInit", Exit);
 #endif
 
-#if defined(SUPPORT_DMA_TRANSFER)
-	PVRSRVInitialiseDMA(psDeviceNode);
-	PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVInitialiseDMA", Exit);
-#endif
-
-	bInitSuccesful = IMG_TRUE;
+	bInitSuccessful = IMG_TRUE;
 
 #if defined(SUPPORT_RGX)
 Exit:
 #endif
-	eError = PVRSRVDeviceFinalise(psDeviceNode, bInitSuccesful);
+	eError = PVRSRVDeviceFinalise(psDeviceNode, bInitSuccessful);
 	PVR_LOG_IF_ERROR(eError, "PVRSRVDeviceFinalise");
 
 #if defined(SUPPORT_RGX)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
-	{
-		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableClockGating,
-		                                  _ReadStateFlag, _SetStateFlag,
-		                                  APPHINT_OF_DRIVER_NO_DEVICE,
-		                                  (void*)((uintptr_t)RGXFWIF_INICFG_DISABLE_CLKGATING_EN));
-		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableDMOverlap,
-		                                  _ReadStateFlag, _SetStateFlag,
-		                                  APPHINT_OF_DRIVER_NO_DEVICE,
-		                                  (void*)((uintptr_t)RGXFWIF_INICFG_DISABLE_DM_OVERLAP));
-		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_AssertOnHWRTrigger,
-		                                  _ReadStateFlag, _SetStateFlag,
+	if (bInitSuccessful && (eError == PVRSRV_OK))
+	{
+		RGXInitMultiCoreInfo(psDeviceNode);
+
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+		{
+			PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableClockGating,
+			                                  _ReadStateFlag, _SetStateFlag,
+			                                  APPHINT_OF_DRIVER_NO_DEVICE,
+			                                  (void*)((uintptr_t)RGXFWIF_INICFG_DISABLE_CLKGATING_EN));
+			PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableDMOverlap,
+			                                  _ReadStateFlag, _SetStateFlag,
+			                                  APPHINT_OF_DRIVER_NO_DEVICE,
+			                                  (void*)((uintptr_t)RGXFWIF_INICFG_DISABLE_DM_OVERLAP));
+			PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_AssertOnHWRTrigger,
+			                                  _ReadStateFlag, _SetStateFlag,
+			                                  psDeviceNode,
+			                                  (void*)((uintptr_t)RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER));
+			PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_AssertOutOfMemory,
+			                                  _ReadStateFlag, _SetStateFlag,
+			                                  psDeviceNode,
+			                                  (void*)((uintptr_t)RGXFWIF_INICFG_ASSERT_ON_OUTOFMEMORY));
+			PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_CheckMList,
+			                                  _ReadStateFlag, _SetStateFlag,
+			                                  psDeviceNode,
+			                                  (void*)((uintptr_t)RGXFWIF_INICFG_CHECK_MLIST_EN));
+		}
+
+		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableFEDLogging,
+		                                  _ReadDeviceFlag, _SetDeviceFlag,
 		                                  psDeviceNode,
-		                                  (void*)((uintptr_t)RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER));
-		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_AssertOutOfMemory,
-		                                  _ReadStateFlag, _SetStateFlag,
+		                                  (void*)((uintptr_t)RGXKM_DEVICE_STATE_DISABLE_DW_LOGGING_EN));
+		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_ZeroFreelist,
+		                                  _ReadDeviceFlag, _SetDeviceFlag,
 		                                  psDeviceNode,
-		                                  (void*)((uintptr_t)RGXFWIF_INICFG_ASSERT_ON_OUTOFMEMORY));
-		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_CheckMList,
-		                                  _ReadStateFlag, _SetStateFlag,
+		                                  (void*)((uintptr_t)RGXKM_DEVICE_STATE_ZERO_FREELIST));
+		PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisablePDumpPanic,
+		                                  RGXQueryPdumpPanicDisable, RGXSetPdumpPanicDisable,
 		                                  psDeviceNode,
-		                                  (void*)((uintptr_t)RGXFWIF_INICFG_CHECK_MLIST_EN));
+		                                  NULL);
 	}
-
-	PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisableFEDLogging,
-	                                  _ReadDeviceFlag, _SetDeviceFlag,
-	                                  psDeviceNode,
-	                                  (void*)((uintptr_t)RGXKM_DEVICE_STATE_DISABLE_DW_LOGGING_EN));
-	PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_ZeroFreelist,
-	                                  _ReadDeviceFlag, _SetDeviceFlag,
-	                                  psDeviceNode,
-	                                  (void*)((uintptr_t)RGXKM_DEVICE_STATE_ZERO_FREELIST));
-#if defined(SUPPORT_VALIDATION)
-	PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_GPUUnitsPowerChange,
-	                                  _ReadDeviceFlag, _SetDeviceFlag,
-	                                  psDeviceNode,
-	                                  (void*)((uintptr_t)RGXKM_DEVICE_STATE_GPU_UNITS_POWER_CHANGE_EN));
-#endif
-	PVRSRVAppHintRegisterHandlersBOOL(APPHINT_ID_DisablePDumpPanic,
-	                                  RGXQueryPdumpPanicDisable, RGXSetPdumpPanicDisable,
-	                                  psDeviceNode,
-	                                  NULL);
 #endif
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
@@ -2711,8 +2801,11 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_ERROR			eError;
 #if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
 	IMG_BOOL				bForceUnload = IMG_FALSE;
+	PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus = OSAtomicRead(&psDeviceNode->eHealthStatus);
 
-	if (PVRSRVGetPVRSRVData()->eServicesState != PVRSRV_SERVICES_STATE_OK)
+	if ((PVRSRVGetPVRSRVData()->eServicesState != PVRSRV_SERVICES_STATE_OK) ||
+		(eHealthStatus == PVRSRV_DEVICE_HEALTH_STATUS_DEAD) ||
+		(eHealthStatus == PVRSRV_DEVICE_HEALTH_STATUS_FAULT))
 	{
 		bForceUnload = IMG_TRUE;
 	}
@@ -2732,6 +2825,15 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	PVRSRVDeviceSetState(psDeviceNode, PVRSRV_DEVICE_STATE_DEINIT);
 
+	PVRSRVCleanupThreadWaitForDevice(psDeviceNode);
+
+	OSWRLockAcquireWrite(psPVRSRVData->hDeviceNodeListLock);
+	List_PVRSRV_DEVICE_NODE_Remove(psDeviceNode);
+	psPVRSRVData->ui32RegisteredDevices--;
+	OSWRLockReleaseWrite(psPVRSRVData->hDeviceNodeListLock);
+
+	PVRSRVDeviceSetState(psDeviceNode, PVRSRV_DEVICE_STATE_DESTRUCTING);
+
 #if defined(SUPPORT_LINUX_DVFS) && !defined(NO_HARDWARE)
 	UnregisterDVFSDevice(psDeviceNode);
 #endif
@@ -2740,20 +2842,8 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 	pvr_apphint_device_unregister(psDeviceNode);
 #endif /* defined(__linux__) */
 
-#if defined(PVR_TESTING_UTILS)
-	TUtilsDeinit(psDeviceNode);
-#endif
 	DebugCommonDeInitDevice(psDeviceNode);
 
-	if (psDeviceNode->hMemoryContextPageFaultNotifyListLock != NULL)
-	{
-		OSWRLockDestroy(psDeviceNode->hMemoryContextPageFaultNotifyListLock);
-	}
-
-#if defined(SUPPORT_VALIDATION)
-	OSLockDestroyNoStats(psDeviceNode->hValidationLock);
-	psDeviceNode->hValidationLock = NULL;
-#endif
 
 #if defined(SUPPORT_FALLBACK_FENCE_SYNC)
 	SyncFbDeregisterDevice(psDeviceNode);
@@ -2833,10 +2923,10 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 		}
 	}
 
-	PVRSRVDeviceSetState(psDeviceNode, PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF);
-
 #if defined(SUPPORT_LINUX_DVFS) && !defined(NO_HARDWARE)
 	DeinitDVFS(psDeviceNode);
+#elif defined(SUPPORT_PDVFS) && !defined(NO_HARDWARE)
+	DeinitPDVFS(psDeviceNode);
 #endif
 
 	if (psDeviceNode->hDbgReqNotify)
@@ -2864,6 +2954,11 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	PVRSRVUnregisterDeviceDbgTable(psDeviceNode);
 
+	if (psDeviceNode->hPageFaultNotifyLock != NULL)
+	{
+		OSWRLockDestroy(psDeviceNode->hPageFaultNotifyLock);
+	}
+
 	/* Release the Connection-Data lock as late as possible. */
 	if (psDeviceNode->hConnectionsLock)
 	{
@@ -2882,19 +2977,12 @@ void PVRSRVCommonDeviceDestroy(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	psDeviceNode->psDevConfig->psDevNode = NULL;
 
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode))
 	{
-		PvzConnectionDeInit();
+		PvzConnectionDeInit(psDeviceNode->psDevConfig);
 	}
 	SysDevDeInit(psDeviceNode->psDevConfig);
 
-	PVRSRVCleanupThreadWaitForDevice(psDeviceNode);
-
-	OSWRLockAcquireWrite(psPVRSRVData->hDeviceNodeListLock);
-	List_PVRSRV_DEVICE_NODE_Remove(psDeviceNode);
-	psPVRSRVData->ui32RegisteredDevices--;
-	OSWRLockReleaseWrite(psPVRSRVData->hDeviceNodeListLock);
-
 	OSFreeMemNoStats(psDeviceNode);
 }
 
@@ -2977,7 +3065,7 @@ PVRSRV_ERROR PVRSRVDeviceFinalise(PVRSRV_DEVICE_NODE *psDeviceNode,
 		 * Guest driver must do a runtime compatibility check against the
 		 * data provided by the Firmware.
 		 */
-		if (PVRSRV_VZ_MODE_IS(GUEST))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			eError = PVRSRVDevInitCompatCheck(psDeviceNode);
 			if (eError != PVRSRV_OK)
@@ -3020,6 +3108,7 @@ PVRSRV_ERROR PVRSRVDeviceFinalise(PVRSRV_DEVICE_NODE *psDeviceNode,
 					 __func__, psDeviceNode, PVRSRVGetErrorString(eError)));
 
 			PVRSRVPowerUnlock(psDeviceNode);
+			PVRSRVDebugRequest(psDeviceNode, DEBUG_REQUEST_VERBOSITY_MAX, NULL, NULL);
 			goto ErrorExit;
 		}
 
@@ -3097,7 +3186,7 @@ PVRSRV_ERROR PollForValueKM (volatile IMG_UINT32 __iomem           *pui32LinMemA
 #else
 	IMG_UINT32 ui32ActualValue = 0xFFFFFFFFU; /* Initialiser only required to prevent incorrect warning */
 
-	LOOP_UNTIL_TIMEOUT(ui32Timeoutus)
+	LOOP_UNTIL_TIMEOUT_US(ui32Timeoutus)
 	{
 		if (pfnFwInvalidate)
 		{
@@ -3118,8 +3207,17 @@ PVRSRV_ERROR PollForValueKM (volatile IMG_UINT32 __iomem           *pui32LinMemA
 			return PVRSRV_ERROR_TIMEOUT;
 		}
 
-		OSWaitus(ui32PollPeriodus);
-	} END_LOOP_UNTIL_TIMEOUT();
+#define ONE_MSEC_IN_USECS	(1000U)
+
+		if (ui32PollPeriodus <= ONE_MSEC_IN_USECS)
+		{
+			OSWaitus(ui32PollPeriodus);
+		}
+		else
+		{
+			OSSleepms(ui32PollPeriodus / ONE_MSEC_IN_USECS);
+		}
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (BITMASK_HAS(ePollFlags, POLL_FLAG_LOG_ERROR))
 	{
@@ -3184,7 +3282,7 @@ PVRSRVWaitForValueKM(volatile IMG_UINT32 __iomem   *pui32LinMemAddr,
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSEventObjectOpen", EventObjectOpenError);
 
 	eError = PVRSRV_ERROR_TIMEOUT; /* Initialiser for following loop */
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		if (pfnFwInvalidate)
 		{
@@ -3222,7 +3320,7 @@ PVRSRVWaitForValueKM(volatile IMG_UINT32 __iomem   *pui32LinMemAddr,
 						 ui32Mask));
 			}
 		}
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	OSEventObjectClose(hOSEvent);
 
@@ -3287,16 +3385,6 @@ IMG_BOOL PVRSRVSystemSnoopingOfCPUCache(PVRSRV_DEVICE_CONFIG *psDevConfig)
 	return IMG_FALSE;
 }
 
-IMG_BOOL PVRSRVSystemSnoopingOfDeviceCache(PVRSRV_DEVICE_CONFIG *psDevConfig)
-{
-	if ((psDevConfig->eCacheSnoopingMode == PVRSRV_DEVICE_SNOOP_DEVICE_ONLY) ||
-		(psDevConfig->eCacheSnoopingMode == PVRSRV_DEVICE_SNOOP_CROSS))
-	{
-		return IMG_TRUE;
-	}
-	return IMG_FALSE;
-}
-
 IMG_BOOL PVRSRVSystemHasNonMappableLocalMemory(PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
 	return psDevConfig->bHasNonMappableLocalMemory;
@@ -3445,7 +3533,7 @@ PVRSRV_ERROR PVRSRVDestroyHWPerfHostThread(void)
 			eError = OSEventObjectSignal(gpsPVRSRVData->hHWPerfHostPeriodicEvObj);
 			PVR_LOG_IF_ERROR(eError, "OSEventObjectSignal");
 		}
-		LOOP_UNTIL_TIMEOUT(OS_THREAD_DESTROY_TIMEOUT_US)
+		LOOP_UNTIL_TIMEOUT_US(OS_THREAD_DESTROY_TIMEOUT_US)
 		{
 			eError = OSThreadDestroy(gpsPVRSRVData->hHWPerfHostPeriodicThread);
 			if (PVRSRV_OK == eError)
@@ -3454,7 +3542,7 @@ PVRSRV_ERROR PVRSRVDestroyHWPerfHostThread(void)
 				break;
 			}
 			OSWaitus(OS_THREAD_DESTROY_TIMEOUT_US/OS_THREAD_DESTROY_RETRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 		PVR_LOG_IF_ERROR(eError, "OSThreadDestroy");
 
 		if (gpsPVRSRVData->hHWPerfHostPeriodicEvObj)
@@ -3523,12 +3611,6 @@ PVRSRV_DEVICE_NODE *PVRSRVGetDeviceInstanceByKernelDevID(IMG_INT32 i32OSInstance
 	return psDevNode;
 }
 
-/* Default function for querying the power state of the system */
-PVRSRV_SYS_POWER_STATE PVRSRVDefaultDomainPower(PVRSRV_DEVICE_NODE *psDevNode)
-{
-	return psDevNode->eCurrentSysPowerState;
-}
-
 #define _FROZEN 1		/* Device is already frozen */
 #define _NOT_FROZEN 0	/* Device is not frozen */
 
@@ -3743,6 +3825,30 @@ PVRSRV_ERROR PVRSRVDeviceThaw(PVRSRV_DEVICE_NODE *psDevNode)
 	return PVRSRV_OK;
 }
 
+PVRSRV_DRIVER_MODE PVRSRVGetVzModeByDevNum(IMG_UINT32 ui32DevNum)
+{
+	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_DRIVER_MODE eRetMode = DRIVER_MODE_NATIVE;
+	PVRSRV_DEVICE_NODE *psDevNode;
+
+	OSWRLockAcquireRead(psPVRSRVData->hDeviceNodeListLock);
+
+	/* Iterate over all devices. */
+	for (psDevNode = psPVRSRVData->psDeviceNodeList;
+		 psDevNode != NULL;
+		 psDevNode = psDevNode->psNext)
+	{
+		if (psDevNode->sDevId.ui32InternalID == ui32DevNum)
+		{
+			eRetMode = psDevNode->psDevConfig->eDriverMode;
+			break;
+		}
+	}
+
+	OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+	return eRetMode;
+}
+
 /*****************************************************************************
  End of file (pvrsrv.c)
 *****************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv.h b/drivers/gpu/drm/img-rogue/pvrsrv.h
index 71e2debfb9c6..86d607092c60 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv.h
@@ -108,19 +108,9 @@ typedef struct _DRIVER_INFO_
 	IMG_BOOL	bIsNoMatch;
 }DRIVER_INFO;
 
-#if defined(SUPPORT_VALIDATION) && defined(__linux__)
-typedef struct MEM_LEAK_INTERVALS_TAG
-{
-	IMG_UINT32 ui32OSAlloc;
-	IMG_UINT32 ui32GPU;
-	IMG_UINT32 ui32MMU;
-} MEM_LEAK_INTERVALS;
-#endif
 
 typedef struct PVRSRV_DATA_TAG
 {
-	PVRSRV_DRIVER_MODE    eDriverMode;                    /*!< Driver mode (i.e. native, host or guest) */
-	IMG_BOOL              bForceApphintDriverMode;        /*!< Indicate if driver mode is forced via apphint */
 	DRIVER_INFO           sDriverInfo;
 	IMG_UINT32            ui32DPFErrorCount;                 /*!< Number of Fatal/Error DPFs */
 
@@ -151,9 +141,6 @@ typedef struct PVRSRV_DATA_TAG
 #if !defined(PVRSRV_SERVER_THREADS_INDEFINITE_SLEEP)
 	volatile IMG_UINT32   ui32DevicesWatchdogTimeout;     /*! Timeout for the Devices watchdog Thread */
 #endif
-#ifdef PVR_TESTING_UTILS
-	volatile IMG_UINT32   ui32DevicesWdWakeupCounter;     /* Need this for the unit tests. */
-#endif
 
 #if defined(SUPPORT_AUTOVZ)
 	IMG_HANDLE            hAutoVzWatchdogThread;          /*!< Devices watchdog thread */
@@ -182,13 +169,12 @@ typedef struct PVRSRV_DATA_TAG
 	DEVMEM_MEMDESC        *psInfoPageMemDesc;             /*! Memory descriptor of the information page. */
 	POS_LOCK              hInfoPageLock;                  /*! Lock guarding access to information page. */
 
-#if defined(SUPPORT_VALIDATION) && defined(__linux__)
-	MEM_LEAK_INTERVALS    sMemLeakIntervals;              /*!< How often certain memory leak types will trigger */
-#endif
 	IMG_HANDLE            hThreadsDbgReqNotify;
 
+
 	IMG_UINT32            ui32PDumpBoundDevice;           /*!< PDump is bound to the device first connected to */
 	ATOMIC_T              iNumDriverTasksActive;          /*!< Number of device-agnostic tasks active in the server */
+	PVRSRV_DRIVER_MODE    aeModuleParamDriverMode[PVRSRV_MAX_DEVICES]; /*!< Driver Mode for each device requested at launch */
 } PVRSRV_DATA;
 
 /* Function pointer used to invalidate cache between loops in wait/poll for value functions */
@@ -203,34 +189,23 @@ typedef PVRSRV_ERROR (*PFN_INVALIDATE_CACHEFUNC)(const volatile void*, IMG_UINT6
  @Return   PVRSRV_DATA *
 ******************************************************************************/
 PVRSRV_DATA *PVRSRVGetPVRSRVData(void);
+PVRSRV_DRIVER_MODE PVRSRVGetVzModeByDevNum(IMG_UINT32 ui32DevNum);
 
 #define PVRSRV_KM_ERRORS                     ( PVRSRVGetPVRSRVData() ? PVRSRVGetPVRSRVData()->ui32DPFErrorCount : IMG_UINT32_MAX)
 #define PVRSRV_ERROR_LIMIT_REACHED                (PVRSRV_KM_ERRORS == IMG_UINT32_MAX)
 #define PVRSRV_REPORT_ERROR()                do { if (!(PVRSRV_ERROR_LIMIT_REACHED)) { PVRSRVGetPVRSRVData()->ui32DPFErrorCount++; } } while (0)
 
-#define PVRSRV_VZ_MODE_IS(_expr)              (DRIVER_MODE_##_expr == PVRSRVGetPVRSRVData()->eDriverMode)
-#define PVRSRV_VZ_RETN_IF_MODE(_expr)         do { if (  PVRSRV_VZ_MODE_IS(_expr)) { return; } } while (0)
-#define PVRSRV_VZ_RETN_IF_NOT_MODE(_expr)     do { if (! PVRSRV_VZ_MODE_IS(_expr)) { return; } } while (0)
-#define PVRSRV_VZ_RET_IF_MODE(_expr, _rc)     do { if (  PVRSRV_VZ_MODE_IS(_expr)) { return (_rc); } } while (0)
-#define PVRSRV_VZ_RET_IF_NOT_MODE(_expr, _rc) do { if (! PVRSRV_VZ_MODE_IS(_expr)) { return (_rc); } } while (0)
+#define PVRSRV_VZ_MODE_FROM_DEVNODE(pnode)     (pnode->psDevConfig->eDriverMode)
+#define PVRSRV_VZ_MODE_FROM_DEVINFO(pdevinfo)  (pdevinfo->psDeviceNode->psDevConfig->eDriverMode)
+#define PVRSRV_VZ_MODE_FROM_DEVCFG(pdevcfg)    (pdevcfg->eDriverMode)
+#define PVRSRV_VZ_MODE_FROM_DEVID(devid)       (PVRSRVGetVzModeByDevNum(devid))
 
-/*!
-******************************************************************************
-@Note	The driver execution mode AppHint (i.e. PVRSRV_APPHINT_DRIVERMODE)
-		can be an override or non-override 32-bit value. An override value
-		has the MSB bit set & a non-override value has this MSB bit cleared.
-		Excluding this MSB bit & interpreting the remaining 31-bit as a
-		signed 31-bit integer, the mode values are:
-		  [-1 native <default>: 0 host : +1 guest ].
-******************************************************************************/
-#define PVRSRV_VZ_APPHINT_MODE_IS_OVERRIDE(_expr)   ((IMG_UINT32)(_expr)&(IMG_UINT32)(1<<31))
-#define PVRSRV_VZ_APPHINT_MODE(_expr)				\
-	((((IMG_UINT32)(_expr)&(IMG_UINT32)0x7FFFFFFF) == (IMG_UINT32)0x7FFFFFFF) ? DRIVER_MODE_NATIVE : \
-		!((IMG_UINT32)(_expr)&(IMG_UINT32)0x7FFFFFFF) ? DRIVER_MODE_HOST : \
-			((IMG_UINT32)((IMG_UINT32)(_expr)&(IMG_UINT)0x7FFFFFFF)==(IMG_UINT32)0x1) ? DRIVER_MODE_GUEST : \
-				((IMG_UINT32)(_expr)&(IMG_UINT32)0x7FFFFFFF))
+#define PVRSRV_VZ_MODE_IS(_expr, _struct, dev) (DRIVER_MODE_##_expr == PVRSRV_VZ_MODE_FROM_##_struct(dev))
 
-#define PVRSRV_VZ_TIME_SLICE_MAX	(100ULL)
+#define PVRSRV_VZ_RETN_IF_MODE(_expr, _struct, dev)         do { if (  PVRSRV_VZ_MODE_IS(_expr, _struct, dev)) { return; } } while (0)
+#define PVRSRV_VZ_RET_IF_MODE(_expr, _struct, dev, _rc)     do { if (  PVRSRV_VZ_MODE_IS(_expr, _struct, dev)) { return (_rc); } } while (0)
+
+#define PVRSRV_VZ_TIME_SLICE_MAX	(100UL)
 
 typedef struct _PHYS_HEAP_ITERATOR_ PHYS_HEAP_ITERATOR;
 
@@ -392,16 +367,6 @@ IMG_BOOL PVRSRVSystemSnoopingIsEmulated(PVRSRV_DEVICE_CONFIG *psDevConfig);
 ******************************************************************************/
 IMG_BOOL PVRSRVSystemSnoopingOfCPUCache(PVRSRV_DEVICE_CONFIG *psDevConfig);
 
-/*!
-******************************************************************************
- @Function	: PVRSRVSystemSnoopingOfDeviceCache
-
- @Description	: Returns whether the system supports snooping of the device cache
-
- @Return : IMG_TRUE if the system has device cache snooping
-******************************************************************************/
-IMG_BOOL PVRSRVSystemSnoopingOfDeviceCache(PVRSRV_DEVICE_CONFIG *psDevConfig);
-
 /*!
 ******************************************************************************
  @Function	: PVRSRVSystemHasNonMappableLocalMemory
@@ -521,12 +486,12 @@ PVRSRV_DEVICE_NODE* PVRSRVGetDeviceInstance(IMG_UINT32 ui32Instance);
 PVRSRV_DEVICE_NODE *PVRSRVGetDeviceInstanceByKernelDevID(IMG_INT32 i32OSInstance);
 
 /*************************************************************************/ /*!
-@Function       PVRSRVDefaultDomainPower
-@Description    Returns psDevNode->eCurrentSysPowerState
-@Input          PVRSRV_DEVICE_NODE*     Device node
-@Return         PVRSRV_SYS_POWER_STATE  System power state tracked internally
+@Function       PVRSRVAcquireInternalID
+@Description    Returns the lowest free device ID.
+@Output         pui32InternalID  The device ID
+@Return         PVRSRV_ERROR     PVRSRV_OK or an error code
 */ /**************************************************************************/
-PVRSRV_SYS_POWER_STATE PVRSRVDefaultDomainPower(PVRSRV_DEVICE_NODE *psDevNode);
+PVRSRV_ERROR PVRSRVAcquireInternalID(IMG_UINT32 *pui32InternalID);
 
 /*************************************************************************/ /*!
 @Function       PVRSRVDeviceFreeze
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_bridge_init.c b/drivers/gpu/drm/img-rogue/pvrsrv_bridge_init.c
index 154298b02040..13beb3f5c454 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_bridge_init.c
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_bridge_init.c
@@ -121,10 +121,6 @@ void DeinitDEVICEMEMHISTORYBridge(void);
 PVRSRV_ERROR InitVALIDATIONBridge(void);
 void DeinitVALIDATIONBridge(void);
 #endif
-#if defined(PVR_TESTING_UTILS)
-PVRSRV_ERROR InitTUTILSBridge(void);
-void DeinitTUTILSBridge(void);
-#endif
 PVRSRV_ERROR InitSYNCTRACKINGBridge(void);
 void DeinitSYNCTRACKINGBridge(void);
 #if defined(SUPPORT_WRAP_EXTMEM)
@@ -207,10 +203,6 @@ ServerBridgeInit(void)
 	PVR_LOG_IF_ERROR(eError, "InitVALIDATIONBridge");
 #endif
 
-#if defined(PVR_TESTING_UTILS)
-	eError = InitTUTILSBridge();
-	PVR_LOG_IF_ERROR(eError, "InitTUTILSBridge");
-#endif
 
 	eError = InitDEVICEMEMHISTORYBridge();
 	PVR_LOG_IF_ERROR(eError, "InitDEVICEMEMHISTORYBridge");
@@ -321,9 +313,6 @@ void ServerBridgeDeInit(void)
 	DeinitPDUMPBridge();
 #endif
 
-#if defined(PVR_TESTING_UTILS)
-	DeinitTUTILSBridge();
-#endif
 
 #if defined(SUPPORT_DISPLAY_CLASS)
 	DeinitDCBridge();
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_device.h b/drivers/gpu/drm/img-rogue/pvrsrv_device.h
index 8eda99c72089..1ad03bb91323 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_device.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_device.h
@@ -46,7 +46,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "physheap_config.h"
 #include "pvrsrv_error.h"
 #include "pvrsrv_memalloc_physheap.h"
-#include "pvrsrv_firmware_boot.h"
+#include "rgx_firmware_boot.h"
 #include "rgx_fwif_km.h"
 #include "servicesext.h"
 #include "cache_ops.h"
@@ -66,9 +66,10 @@ typedef enum _DRIVER_MODE_
 /* Do not use these enumerations directly, to query the
    current driver mode, use the PVRSRV_VZ_MODE_IS()
    macro */
-	DRIVER_MODE_NATIVE	= -1,
-	DRIVER_MODE_HOST	=  0,
-	DRIVER_MODE_GUEST
+	DRIVER_MODE_NATIVE	= 0,
+	DRIVER_MODE_HOST	= 1,
+	DRIVER_MODE_GUEST	= 2,
+	DRIVER_MODE_DEFAULT	= 3,
 } PVRSRV_DRIVER_MODE;
 
 typedef enum
@@ -170,18 +171,24 @@ typedef void
 							   IMG_BOOL);
 
 
-#if defined(SUPPORT_TRUSTED_DEVICE)
-
-typedef struct _PVRSRV_TD_FW_PARAMS_
+typedef struct _PVRSRV_FW_PARAMS_
 {
 	const void *pvFirmware;
 	IMG_UINT32 ui32FirmwareSize;
+	const void *pvSignature;
+	IMG_UINT32 ui32SignatureSize;
 	PVRSRV_FW_BOOT_PARAMS uFWP;
-} PVRSRV_TD_FW_PARAMS;
+} PVRSRV_FW_PARAMS;
+
+typedef PVRSRV_ERROR
+(*PFN_PREPARE_FW_IMAGE)(IMG_HANDLE hSysData,
+						PVRSRV_FW_PARAMS *psFWParams);
+
+#if defined(SUPPORT_TRUSTED_DEVICE)
 
 typedef PVRSRV_ERROR
 (*PFN_TD_SEND_FW_IMAGE)(IMG_HANDLE hSysData,
-						PVRSRV_TD_FW_PARAMS *psTDFWParams);
+						PVRSRV_FW_PARAMS *psTDFWParams);
 
 typedef struct _PVRSRV_TD_POWER_PARAMS_
 {
@@ -207,7 +214,7 @@ typedef PVRSRV_ERROR
 #endif /* defined(SUPPORT_TRUSTED_DEVICE) */
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
-typedef void (*PFN_SYS_DEV_VIRT_INIT)(IMG_HANDLE hSysData,
+typedef void (*PFN_SYS_INIT_FIREWALL)(IMG_HANDLE hSysData,
                                       IMG_UINT64[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS],
                                       IMG_UINT64[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS]);
 #endif /* defined(SUPPORT_GPUVIRT_VALIDATION) */
@@ -315,6 +322,14 @@ struct _PVRSRV_DEVICE_CONFIG_
 	PFN_SYS_DEV_HOST_CACHE_MAINTENANCE pfnHostCacheMaintenance;
 	IMG_BOOL bHasPhysicalCacheMaintenance;
 
+	/*!
+	 *! Callback to prepare FW image after it has been loaded.  This may
+	 *! be used to separate a signature/header from the firmware proper,
+	 *! potentially modifying pvFirmware and ui32FirmwareSize to point to the
+	 *! actual firmware to be loaded.
+	 */
+	PFN_PREPARE_FW_IMAGE pfnPrepareFWImage;
+
 #if defined(SUPPORT_TRUSTED_DEVICE)
 	/*!
 	 *! Callback to send FW image and FW boot time parameters to the trusted
@@ -356,13 +371,13 @@ struct _PVRSRV_DEVICE_CONFIG_
 	 */
 	IMG_BOOL bDevicePA0IsValid;
 
+#if defined(SUPPORT_GPUVIRT_VALIDATION)
 	/*!
-	 *! Function to initialize System-specific virtualization. If not supported
-	 *! this should be a NULL reference. Only present if
-	 *! SUPPORT_GPUVIRT_VALIDATION is defined.
+	 *! System-specific function to initialise firewall mechanism needed to
+	 *! validate the correctness of memory accesses tagged with OSIDs.
+	 *! Used for hardware validation of virtualization features only.
 	 */
-#if defined(SUPPORT_GPUVIRT_VALIDATION)
-	PFN_SYS_DEV_VIRT_INIT		pfnSysDevVirtInit;
+	PFN_SYS_INIT_FIREWALL		pfnSysInitFirewall;
 #endif
 
 	/*!
@@ -398,6 +413,10 @@ struct _PVRSRV_DEVICE_CONFIG_
 	 */
 	IMG_BOOL bHasDma;
 
+	/*!
+	 *!  DriverMode required
+	 */
+	PVRSRV_DRIVER_MODE eDriverMode;
 };
 
 #endif /* PVRSRV_DEVICE_H*/
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_errors.h b/drivers/gpu/drm/img-rogue/pvrsrv_errors.h
index 99368eff0be2..9fcbab6cf02d 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_errors.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_errors.h
@@ -419,3 +419,4 @@ PVRE(PVRSRV_ERROR_INSUFFICIENT_PHYS_HEAP_MEMORY)
 PVRE(PVRSRV_ERROR_UNEXPECTED_TRUE_EXPR)
 PVRE(PVRSRV_ERROR_UNEXPECTED_FALSE_EXPR)
 PVRE(PVRSRV_ERROR_KERNEL_CCB_OFFSET)
+PVRE(PVRSRV_ERROR_PMB_NOT_PAGE_MULTIPLE)
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_memalloc_physheap.h b/drivers/gpu/drm/img-rogue/pvrsrv_memalloc_physheap.h
index 459da0091e78..a02fe954cd68 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_memalloc_physheap.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_memalloc_physheap.h
@@ -98,40 +98,29 @@ static_assert(PVRSRV_PHYS_HEAP_LAST <= (0x1FU + 1U), "Ensure enum fits in memall
 
 /*! Type conveys the class of physical heap to instantiate within Services
  * for the physical pool of memory. */
+#define PHYS_HEAP_TYPE_LIST                                                                                                                                                                                                                                           \
+	X(UNKNOWN)              /* Not a valid value for any config */                                                                                                                                                                                                    \
+	X(UMA)                  /* Heap represents OS managed physical memory heap i.e. system RAM. Unified Memory Architecture physmem_osmem PMR factory */                                                                                                              \
+	X(LMA)                  /* Heap represents physical memory pool managed by Services i.e. carve out from system RAM or local card memory. Local Memory Architecture physmem_lma PMR factory */                                                                     \
+	X(DLM)                  /* Heap represents local card memory. Used in a DLM heap (Dedicated Local Memory) system. */                                                                                                                                              \
+	X(IMA)                  /* Heap represents phys heap that imports PMBs from a DLM heap.*/                                                                                                                                                                         \
+	X(DMA)                  /* Heap represents a physical memory pool managed by Services, alias of LMA and is only used on VZ non-native system configurations for a heap used for allocations tagged with PVRSRV_PHYS_HEAP_FW_MAIN or PVRSRV_PHYS_HEAP_FW_CONFIG */ \
+	X(WRAP)                 /* Heap used to group UM buffers given to Services. Integrity OS port only. */                                                                                                                                                            \
+	X(LAST)                                                                                                                                                                                                                                                           \
+
 typedef enum _PHYS_HEAP_TYPE_
 {
-	PHYS_HEAP_TYPE_UNKNOWN = 0,     /*!< Not a valid value for any config */
-	PHYS_HEAP_TYPE_UMA,             /*!< Heap represents OS managed physical memory heap
-	                                     i.e. system RAM. Unified Memory Architecture
-	                                     physmem_osmem PMR factory */
-	PHYS_HEAP_TYPE_LMA,             /*!< Heap represents physical memory pool managed by
-	                                     Services i.e. carve out from system RAM or local
-	                                     card memory. Local Memory Architecture
-	                                     physmem_lma PMR factory */
-#if defined(__KERNEL__)
-	PHYS_HEAP_TYPE_DMA,             /*!< Heap represents a physical memory pool managed by
-	                                     Services, alias of LMA and is only used on
-	                                     VZ non-native system configurations for
-	                                     a heap used for allocations tagged with
-	                                     PVRSRV_PHYS_HEAP_FW_MAIN or
-	                                     PVRSRV_PHYS_HEAP_FW_CONFIG */
-#if defined(SUPPORT_WRAP_EXTMEMOBJECT)
-	PHYS_HEAP_TYPE_WRAP,            /*!< Heap used to group UM buffers given
-	                                     to Services. Integrity OS port only. */
-#endif
-#endif
+#define X(_name) PHYS_HEAP_TYPE_ ## _name,
+	PHYS_HEAP_TYPE_LIST
+#undef X
+
 } PHYS_HEAP_TYPE;
 
 /* Defines used when interpreting the ui32PhysHeapFlags in PHYS_HEAP_MEM_STATS
-     0x000000000000dttt
+     0x000000000000000d
      d = is this the default heap? (1=yes, 0=no)
-   ttt = heap type (000 = PHYS_HEAP_TYPE_UNKNOWN,
-                    001 = PHYS_HEAP_TYPE_UMA,
-                    010 = PHYS_HEAP_TYPE_LMA,
-                    011 = PHYS_HEAP_TYPE_DMA)
 */
-#define PVRSRV_PHYS_HEAP_FLAGS_TYPE_MASK  (0x7U << 0)
-#define PVRSRV_PHYS_HEAP_FLAGS_IS_DEFAULT (0x1U << 7)
+#define PVRSRV_PHYS_HEAP_FLAGS_IS_DEFAULT (0x1U)
 
 /* Force PHYS_HEAP_MEM_STATS size to be a multiple of 8 bytes
  * (as type is a parameter in bridge calls)
@@ -141,7 +130,7 @@ typedef struct PHYS_HEAP_MEM_STATS_TAG
 	IMG_UINT64	ui64TotalSize;
 	IMG_UINT64	ui64FreeSize;
 	IMG_UINT32	ui32PhysHeapFlags;
-	IMG_UINT32	ui32UnusedPadding;
+	PHYS_HEAP_TYPE	ePhysHeapType;
 }PHYS_HEAP_MEM_STATS, *PHYS_HEAP_MEM_STATS_PTR;
 
 #if defined(PHYSHEAP_STRINGS)
@@ -162,17 +151,14 @@ static const char *const _pszPhysHeapStrings[] = {
 */ /**************************************************************************/
 static inline const IMG_CHAR *PVRSRVGetClientPhysHeapTypeName(PHYS_HEAP_TYPE ePhysHeapType)
 {
-#define HEAPSTR(x) #x
 	switch (ePhysHeapType)
 	{
-		case PHYS_HEAP_TYPE_UMA:
-			return HEAPSTR(PHYS_HEAP_TYPE_UMA);
-		case PHYS_HEAP_TYPE_LMA:
-			return HEAPSTR(PHYS_HEAP_TYPE_LMA);
+#define X(_name) case PHYS_HEAP_TYPE_ ## _name: return "PHYS_HEAP_TYPE_" # _name;
+		PHYS_HEAP_TYPE_LIST
+#undef X
 		default:
 			return "Unknown Heap Type";
 	}
-#undef HEAPSTR
 }
 
 /*************************************************************************/ /*!
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_memallocflags.h b/drivers/gpu/drm/img-rogue/pvrsrv_memallocflags.h
index 1e960356eb88..e08777797f65 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_memallocflags.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_memallocflags.h
@@ -67,13 +67,17 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
  * | 0-3    | 4-7    | 8-10        | 11-13       | 14          |
  * | GPU-RW | CPU-RW | GPU-Caching | CPU-Caching | KM-Mappable |
  *
- * --- MISC FLAGS         15..23 (9-bits) ---
+ * --- MISC FLAGS         15..20 (9-bits) ---
  * | 15    | 16        | 17  | 18         | 19              | 20      |
  * | Defer | Alloc-Now | SVM | Scratch-Pg | CPU-Cache-Clean | Zero-Pg |
  *
+ * --- RI FLAGS  21..23 (3-bits) ---
+ * | 21     | 22       | 23        |
+ * | Import | Suballoc | FW alloc  |
+ *
  * --- DEV CONTROL FLAGS  26..27 (2-bits) ---
- * | 21-25  | 26-27        |
- * | .....  | Device-Flags |
+ * | 24-25 | 26-27        |
+ * | ...   | Device-Flags |
  *
  * --- MISC FLAGS         28..31 (4-bits) ---
  * | 28             | 29             | 30          | 31            |
@@ -83,6 +87,10 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
  * | 35             |
  * | Shared-buffer  |
  *
+ * --- OS SPECIFIC FLAGS ---
+ * | 36             | 37            |
+ * | Linux Pref CMA | Linux Movable |
+ *
  * --- IPA Policy ---
  * | 53-55      |
  * | IPA Policy |
@@ -586,12 +594,13 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
 
 /*! ----- Bit 19
 
-  Used to force Services to carry out at least one CPU cache invalidate on a
-  CPU cached buffer during allocation of the memory. Applicable to incoherent
-  systems, it must be used for buffers which are CPU cached and which will not
-  be 100% written to by the CPU before the GPU accesses it. For performance
-  reasons, avoid usage if the whole buffer that is allocated is written to by
-  the CPU anyway before the next GPU kick, or if the system is coherent.
+  Used to force Services to carry out at least one CPU cache flush and
+  invalidate on a CPU cached buffer during allocation of the memory. Applicable
+  to incoherent systems, it must be used for buffers which are CPU cached and
+  which will not be 100% written to by the CPU before the GPU accesses it. For
+  performance reasons, avoid usage if the whole buffer that is allocated is
+  written to by the CPU anyway before the next GPU kick, or if the system is
+  coherent.
  */
 #define PVRSRV_MEMALLOCFLAG_CPU_CACHE_CLEAN				(IMG_UINT64_C(1)<<19)
 
@@ -616,17 +625,65 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
 
 /*
  ************************************************************
- *                   PMR Misc flags                         *
+ *                         RI flags                         *
  ************************************************************
+ * The Flags are used exclusively by the RI (Reference Info)
+ * server for tracking KM allocations by various processes
+ *
+ * Import - Handle imported from other process
+ * Suballoc - Handle Suballocation of existing PMR
+ * FW Alloc - Used by FW during driver initialisation
  *
- * These 4 flags are used to indicate miscellaneous info
- * not otherwise available in the PMR
- * | 21                    | 22-24    |
- * | PMR can be suballoc'd | Reserved |
+ * --- RI FLAGS  21..23 (3-bits) ---
+ * | 21     | 22       | 23        |
+ * | Import | Suballoc | FW alloc  |
  *
  */
 
- /*! ----- Bit 25
+/*! ----- Bit 21
+  Used by RI server to register Allocation as an import from other process
+ */
+#define PVRSRV_MEMALLOCFLAG_RI_IMPORT					(IMG_UINT64_C(1)<<21)
+/*!
+  @Description    Macro checking whether the PVRSRV_MEMALLOCFLAG_RI_IMPORT flag is set.
+  @Input  uiFlags Allocation flags.
+  @Return         True if the flag is set, false otherwise
+ */
+#define PVRSRV_CHECK_RI_IMPORT(uiFlags)			(((uiFlags) & PVRSRV_MEMALLOCFLAG_RI_IMPORT) != 0U)
+
+/*! ----- Bit 22
+  Used by RI server to register Allocation as a suballocation of existing PMR
+ */
+#define PVRSRV_MEMALLOCFLAG_RI_SUBALLOC					(IMG_UINT64_C(1)<<22)
+/*!
+  @Description    Macro checking whether the PVRSRV_MEMALLOCFLAG_RI_SUBALLOC flag is set.
+  @Input  uiFlags Allocation flags.
+  @Return         True if the flag is set, false otherwise
+ */
+#define PVRSRV_CHECK_RI_SUBALLOC(uiFlags)			(((uiFlags) & PVRSRV_MEMALLOCFLAG_RI_SUBALLOC) != 0U)
+
+/*! ----- Bit 23
+  Used by RI server to register Allocation as FW/System process
+  'FW Alloc' also means the allocation is considered to belong to the SYS process
+  (ie that it will have a lifetime longer than the process which allocated it)
+ */
+#define PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC				(IMG_UINT64_C(1)<<23)
+/*!
+  @Description    Macro checking whether the PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC flag is set.
+  @Input  uiFlags Allocation flags.
+  @Return         True if the flag is set, false otherwise
+ */
+#define PVRSRV_CHECK_RI_FWKMD_ALLOC(uiFlags)			(((uiFlags) & PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC) != 0U)
+
+/*!
+  @Description    Macro passing the PVRSRV_MEMALLOCFLAG_RI_ Flags.
+  @Input  uiFlags Allocation flags.
+  @Return         Value of the RI server bit field
+ */
+#define PVRSRV_MEMALLOCFLAG_RI_MASK(uiFlags)			((uiFlags) & (IMG_UINT64_C(7)<<21))
+
+
+/*! ----- Bit 24
   *
     Not used.
  */
@@ -772,6 +829,26 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
 #define PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER           (IMG_UINT64_C(1)<<35)
 #define PVRSRV_CHECK_SHARED_BUFFER(uiFlags)             (((uiFlags) & PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER) != 0U)
 
+/*
+ *
+ *  **********************************************************
+ *  *                                                        *
+ *  *                OS Specific alloc flags                 *
+ *  *                                                        *
+ *  **********************************************************
+ *
+ * (Bits 36 to 37)
+ *
+ */
+#define PVRSRV_MEMALLOCFLAG_OS_ALLOCFLAG_OFFSET 36
+#define PVRSRV_MEMALLOCFLAG_OS_ALLOCFLAG_MASK          (IMG_UINT64_C(3) << PVRSRV_MEMALLOCFLAG_OS_ALLOCFLAG_OFFSET)
+
+#define PVRSRV_MEMALLOCFLAG_OS_LINUX_PREFER_CMA         (IMG_UINT64_C(1)<<36)
+#define PVRSRV_CHECK_OS_LINUX_PREFER_CMA(uiFlags)       (((uiFlags) & PVRSRV_MEMALLOCFLAG_OS_LINUX_PREFER_CMA) != 0U)
+
+#define PVRSRV_MEMALLOCFLAG_OS_LINUX_MOVABLE           (IMG_UINT64_C(1)<<37)
+#define PVRSRV_CHECK_OS_LINUX_MOVABLE(uiFlags)         (((uiFlags) & PVRSRV_MEMALLOCFLAG_OS_LINUX_MOVABLE) != 0U)
+
 /*
  *
  *  **********************************************************
@@ -930,6 +1007,7 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
                                             PVRSRV_MEMALLOCFLAG_ZERO_BACKING | \
                                             PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER | \
                                             PVRSRV_MEMALLOCFLAG_MANDATE_PHYSHEAP | \
+                                            PVRSRV_MEMALLOCFLAG_OS_ALLOCFLAG_MASK | \
                                             PVRSRV_MEMALLOCFLAG_IPA_POLICY_MASK | \
                                             PVRSRV_PHYS_HEAP_HINT_MASK)
 #else
@@ -947,6 +1025,7 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
                                             PVRSRV_MEMALLOCFLAG_ZERO_BACKING | \
                                             PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER | \
                                             PVRSRV_MEMALLOCFLAG_MANDATE_PHYSHEAP  | \
+                                            PVRSRV_MEMALLOCFLAG_OS_ALLOCFLAG_MASK | \
                                             PVRSRV_MEMALLOCFLAG_IPA_POLICY_MASK | \
                                             PVRSRV_PHYS_HEAP_HINT_MASK)
 #endif
@@ -1013,6 +1092,8 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
 #if defined(DEBUG)
 #define PVRSRV_MEMALLOCFLAGS_DEVMEMX_PHYSICAL_MASK (PVRSRV_MEMALLOCFLAGS_CPU_MMUFLAGSMASK | \
                                                     PVRSRV_MEMALLOCFLAG_GPU_CACHE_MODE_MASK | \
+                                                    PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE | \
+                                                    PVRSRV_MEMALLOCFLAG_GPU_READABLE | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_READ_PERMITTED | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_WRITE_PERMITTED | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_CACHE_CLEAN | \
@@ -1026,6 +1107,8 @@ typedef IMG_UINT64 PVRSRV_MEMALLOCFLAGS_T;
 #else
 #define PVRSRV_MEMALLOCFLAGS_DEVMEMX_PHYSICAL_MASK (PVRSRV_MEMALLOCFLAGS_CPU_MMUFLAGSMASK | \
                                                     PVRSRV_MEMALLOCFLAG_GPU_CACHE_MODE_MASK | \
+                                                    PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE | \
+                                                    PVRSRV_MEMALLOCFLAG_GPU_READABLE | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_READ_PERMITTED | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_WRITE_PERMITTED | \
                                                     PVRSRV_MEMALLOCFLAG_CPU_CACHE_CLEAN | \
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_pool.c b/drivers/gpu/drm/img-rogue/pvrsrv_pool.c
index d62a062a944c..9fa95ea98756 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_pool.c
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_pool.c
@@ -213,7 +213,7 @@ PVRSRV_ERROR PVRSRVPoolGet(PVRSRV_POOL *psPool,
 		psPool->uiNumFree--;
 	}
 
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
+#if defined(DEBUG)
 	/* Don't poison the IN buffer as that is copied from client and would be
 	 * waste of cycles.
 	 */
diff --git a/drivers/gpu/drm/img-rogue/pvrsrv_tlstreams.h b/drivers/gpu/drm/img-rogue/pvrsrv_tlstreams.h
index b15bcfa0c7d6..624b8eb1f47d 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrv_tlstreams.h
+++ b/drivers/gpu/drm/img-rogue/pvrsrv_tlstreams.h
@@ -45,7 +45,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef PVRSRV_TLSTREAMS_H
 #define PVRSRV_TLSTREAMS_H
 
-#define PVRSRV_TL_CTLR_STREAM "tlctrl"
+#define PVRSRV_TL_CTRL_STREAM "tlctrl"
 
 #define PVRSRV_TL_HWPERF_RGX_FW_STREAM      "hwperf_fw_"
 #define PVRSRV_TL_HWPERF_HOST_SERVER_STREAM "hwperf_host_"
diff --git a/drivers/gpu/drm/img-rogue/pvrsrvkm.mk b/drivers/gpu/drm/img-rogue/pvrsrvkm.mk
index 1b1f81e45593..002710884009 100644
--- a/drivers/gpu/drm/img-rogue/pvrsrvkm.mk
+++ b/drivers/gpu/drm/img-rogue/pvrsrvkm.mk
@@ -43,6 +43,7 @@ pvrsrvkm-y += \
  physmem_hostmem.o \
  physmem_lma.o \
  physmem_osmem.o \
+ physmem_ramem.o \
  pmr.o \
  power.o \
  process_stats.o \
@@ -69,9 +70,13 @@ pvrsrvkm-y += \
  rgxfwcmnctx.o \
  rgxfwdbg.o \
  rgxfwimageutils.o \
+ rgxfwriscv.o \
  rgxfwtrace_strings.o \
  rgxhwperf_common.o \
+ rgxlayer_impl_common.o \
  rgxmem.o \
+ rgxmmuinit.o \
+ rgxpower.o \
  rgxregconfig.o \
  rgxshader.o \
  rgxsyncutils.o \
@@ -80,20 +85,18 @@ pvrsrvkm-y += \
  rgxtimerquery.o \
  rgxutils.o \
  rgxdebug.o \
- rgxfwriscv.o \
  rgxfwutils.o \
  rgxhwperf.o \
  rgxinit.o \
  rgxlayer_impl.o \
  rgxmipsmmuinit.o \
- rgxmmuinit.o \
  rgxmulticore.o \
- rgxpower.o \
  rgxsrvinit.o \
  rgxstartstop.o \
  rgxta3d.o \
  rgxtransfer.o \
  allocmem.o \
+ dkf_server.o \
  event.o \
  fwload.o \
  handle_idr.o \
@@ -106,6 +109,7 @@ pvrsrvkm-y += \
  physmem_extmem_linux.o \
  physmem_osmem_linux.o \
  physmem_test.o \
+ pmr_env.o \
  pmr_os.o \
  pvr_bridge_k.o \
  pvr_buffer_sync.o \
@@ -113,6 +117,7 @@ pvrsrvkm-y += \
  pvr_debug.o \
  pvr_debugfs.o \
  pvr_drm.o \
+ pvr_export_fence.o \
  pvr_fence.o \
  pvr_gputrace.o \
  pvr_platform_drv.o \
diff --git a/drivers/gpu/drm/img-rogue/pvrversion.h b/drivers/gpu/drm/img-rogue/pvrversion.h
index 67b258ccb32d..1026b039627b 100644
--- a/drivers/gpu/drm/img-rogue/pvrversion.h
+++ b/drivers/gpu/drm/img-rogue/pvrversion.h
@@ -44,22 +44,22 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef PVRVERSION_H
 #define PVRVERSION_H
 
-#define PVRVERSION_MAJ               23U
+#define PVRVERSION_MAJ               24U
 #define PVRVERSION_MIN               2U
 
 #define PVRVERSION_FAMILY           "rogueddk"
-#define PVRVERSION_BRANCHNAME       "23.2"
-#define PVRVERSION_BUILD             6460340
+#define PVRVERSION_BRANCHNAME       "24.2"
+#define PVRVERSION_BUILD             6603887
 #define PVRVERSION_BSCONTROL        "Rogue_DDK_Linux_WS"
 
-#define PVRVERSION_STRING           "Rogue_DDK_Linux_WS rogueddk 23.2@6460340"
-#define PVRVERSION_STRING_SHORT     "23.2@6460340"
+#define PVRVERSION_STRING           "Rogue_DDK_Linux_WS rogueddk 24.2@6603887"
+#define PVRVERSION_STRING_SHORT     "24.2@6603887"
 
 #define COPYRIGHT_TXT               "Copyright (c) Imagination Technologies Ltd. All Rights Reserved."
 
-#define PVRVERSION_BUILD_HI          646
-#define PVRVERSION_BUILD_LO          340
-#define PVRVERSION_STRING_NUMERIC   "23.2.646.340"
+#define PVRVERSION_BUILD_HI          660
+#define PVRVERSION_BUILD_LO          3887
+#define PVRVERSION_STRING_NUMERIC   "24.2.660.3887"
 
 #define PVRVERSION_PACK(MAJOR,MINOR) (((IMG_UINT32)((IMG_UINT32)(MAJOR) & 0xFFFFU) << 16U) | (((MINOR) & 0xFFFFU) << 0U))
 #define PVRVERSION_UNPACK_MAJ(VERSION) (((VERSION) >> 16U) & 0xFFFFU)
diff --git a/drivers/gpu/drm/img-rogue/ra.c b/drivers/gpu/drm/img-rogue/ra.c
index 90c05717fef5..d1646b309f6d 100644
--- a/drivers/gpu/drm/img-rogue/ra.c
+++ b/drivers/gpu/drm/img-rogue/ra.c
@@ -172,9 +172,17 @@ struct _RA_ARENA_
 	RA_LENGTH_T uQuantum;
 
 	/* import interface, if provided */
-	PFN_RA_ALLOC pImportAlloc;
-
-	PFN_RA_FREE pImportFree;
+	union {
+		void* pImportAlloc;
+		PFN_RA_IMPORT_ALLOC_SINGLE pImportAllocSingle;
+		PFN_RA_IMPORT_ALLOC_MULTI pImportAllocMulti;
+	};
+	enum RA_IMPORT_ALLOC_METHOD {
+		RA_IMPORT_ALLOC_METHOD_SINGLE,
+		RA_IMPORT_ALLOC_METHOD_MULTI,
+	} eImportAllocMethod;
+
+	PFN_RA_IMPORT_FREE pImportFree;
 
 	/* Arbitrary handle provided by arena owner to be passed into the
 	 * import alloc and free hooks
@@ -208,6 +216,9 @@ struct _RA_ARENA_
 
 };
 
+static_assert(sizeof(void*) == sizeof(PFN_RA_IMPORT_ALLOC_SINGLE), "pImportAlloc == pImportAllocSingle. Import callbacks must be pointers of the same size.");
+static_assert(sizeof(void*) == sizeof(PFN_RA_IMPORT_ALLOC_MULTI), "pImportAlloc == pImportAllocMulti. Import callbacks must be pointers of the same size.");
+
 struct _RA_ARENA_ITERATOR_
 {
 	RA_ARENA *pArena;
@@ -215,6 +226,12 @@ struct _RA_ARENA_ITERATOR_
 	IMG_BOOL bIncludeFreeSegments;
 };
 
+/* Enum for selecting behaviour of _ConvertAndFree* functions*/
+typedef enum {
+	CONVERT_AND_FREE = 0,
+	CONVERT_DONT_FREE = 1
+} RA_CONVERT_AND_FREE_BEHAVIOUR;
+
 static PVRSRV_ERROR _RA_FreeMultiUnlocked(RA_ARENA *pArena,
                                    RA_BASE_ARRAY_T aBaseArray,
                                    RA_BASE_ARRAY_SIZE_T uiBaseArraySize);
@@ -234,9 +251,9 @@ _RA_FreeMultiUnlockedSparse(RA_ARENA *pArena,
 @Input          _uSize - requested allocation size
 @Input          _uflags - allocation flags
 @Input          _uBaseAlignment - Alignment for the returned allocated base
-@Input          _pBase - receives allocated base
-@Output         _pActualSize - actual allocation size
-@Input          _pRef - user reference
+
+
+@Output         _psImport - The base and size of the span to insert.
 @Return         PVRSRV_ERROR_RA_REQUEST_ALLOC_FAIL, this function always fails
                 to allocate.
 */ /**************************************************************************/
@@ -246,18 +263,14 @@ _RequestAllocFail(RA_PERARENA_HANDLE _h,
                   RA_FLAGS_T _uFlags,
                   RA_LENGTH_T _uBaseAlignment,
                   const IMG_CHAR *_pszAnnotation,
-                  RA_BASE_T *_pBase,
-                  RA_LENGTH_T *_pActualSize,
-                  RA_PERISPAN_HANDLE *_phPriv)
+                  RA_IMPORT *_psImport)
 {
 	PVR_UNREFERENCED_PARAMETER(_h);
 	PVR_UNREFERENCED_PARAMETER(_uSize);
-	PVR_UNREFERENCED_PARAMETER(_pActualSize);
-	PVR_UNREFERENCED_PARAMETER(_phPriv);
 	PVR_UNREFERENCED_PARAMETER(_uFlags);
 	PVR_UNREFERENCED_PARAMETER(_uBaseAlignment);
-	PVR_UNREFERENCED_PARAMETER(_pBase);
 	PVR_UNREFERENCED_PARAMETER(_pszAnnotation);
+	PVR_UNREFERENCED_PARAMETER(_psImport);
 
 	return PVRSRV_ERROR_RA_REQUEST_ALLOC_FAIL;
 }
@@ -377,7 +390,7 @@ _IsInFreeList(RA_ARENA *pArena, BT *pBT)
 	PVR_ASSERT(uIndex < FREE_TABLE_LIMIT);
 
 	pArena->per_flags_buckets = PVRSRVSplay(pBT->uFlags, pArena->per_flags_buckets);
-	if ((pArena->per_flags_buckets == NULL) || (pArena->per_flags_buckets->flags != pBT->uFlags))
+	if ((pArena->per_flags_buckets == NULL) || (pArena->per_flags_buckets->uiFlags != pBT->uFlags))
 	{
 		return 0;
 	}
@@ -824,6 +837,8 @@ _RemoveResourceSpan(RA_ARENA *pArena, BT *pBT)
 		pBT->is_rightmost)
 	{
 		_SegmentListRemove(pArena, pBT);
+		pArena->ui64TotalArenaSize -= pBT->uSize;
+		pArena->ui64FreeArenaSize -= pBT->uSize;
 		pArena->pImportFree(pArena->pImportHandle, pBT->base, pBT->hPriv);
 		OSFreeMem(pBT);
 
@@ -1146,28 +1161,32 @@ _ConvertGhostBaseToReal(RA_ARENA *pArena,
 }
 
 /*************************************************************************/ /*!
- *  @Function   _FreeGhostBasesFromReal
+ *  @Function   _ConvertAndFreeStartFromGhost
  *
- *  @Description   Given a ghost base and size, free the contiguous ghost bases from the
- *                 real base. This has the effect of shrinking the size of the real base.
- *                 If ghost pages remain after the free region, a new Real base will be
+ *  @Description   Given a ghost base and size, convert and free contiguous
+ *                 ghost bases. This has the effect of shrinking the size of
+ *                 the real base holding the range to free. If ghost pages
+ *                 remain after the free region, a new Real base will be
  *                 created to host them.
+ *
  *  @Input pArena - The RA Arena to free the Ghost Bases from.
  *  @Input aBaseArray - The array to remove bases from
  *  @Input uiBaseArraySize - The size of the Base array to free from.
  *  @Input uiChunkSize - The chunk size used to generate the Ghost Bases.
  *  @Input ui32GhostBaseIndex - The index into the array of the initial Ghost base to free
  *  @Input ui32FreeCount - The number of Ghost bases to free from the Real base.
+ *  @Input eBehaviour - Specifies if the function should convert and free or only convert.
  *
  *  @Return PVRSRV_OK on Success, PVRSRV_ERROR code on Failure.
 */ /**************************************************************************/
 static PVRSRV_ERROR
-_FreeGhostBasesFromReal(RA_ARENA *pArena,
-                        RA_BASE_ARRAY_T aBaseArray,
-                        RA_BASE_ARRAY_SIZE_T uiBaseArraySize,
-                        RA_LENGTH_T uiChunkSize,
-                        IMG_UINT32 ui32GhostBaseIndex,
-                        IMG_UINT32 ui32FreeCount)
+_ConvertAndFreeStartFromGhost(RA_ARENA *pArena,
+                              RA_BASE_ARRAY_T aBaseArray,
+                              RA_BASE_ARRAY_SIZE_T uiBaseArraySize,
+                              RA_LENGTH_T uiChunkSize,
+                              IMG_UINT32 ui32GhostBaseIndex,
+                              IMG_UINT32 ui32FreeCount,
+                              RA_CONVERT_AND_FREE_BEHAVIOUR eBehaviour)
 {
 	PVRSRV_ERROR eError;
 	RA_BASE_T uiRealBase;
@@ -1207,17 +1226,20 @@ _FreeGhostBasesFromReal(RA_ARENA *pArena,
 		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
 	}
 
-	/* Free the region calculated */
-	eError = _FreeSingleBaseArray(pArena,
-	                              &aBaseArray[ui32GhostBaseIndex],
-	                              ui32FreeCount);
-	PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
+	if (eBehaviour == CONVERT_AND_FREE)
+	{
+		/* Free the region calculated */
+		eError = _FreeSingleBaseArray(pArena,
+		                              &aBaseArray[ui32GhostBaseIndex],
+		                              ui32FreeCount);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
+	}
 
 	return eError;
 }
 
 /*************************************************************************/ /*!
- *  @Function   _ConvertGhostBaseFreeReal
+ *  @Function   _ConvertAndFreeStartFromReal
  *
  *  @Description   Used in the case that we want to keep some indices that are ghost pages
  *                 but the indices to free start with the real base. In this case we can
@@ -1228,15 +1250,17 @@ _FreeGhostBasesFromReal(RA_ARENA *pArena,
  *  @Input aBaseArray - The Base array to free from.
  *  @Input uiChunkSize - The chunk size used to generate the Ghost bases.
  *  @Input uiGhostBaseIndex - The index into the array of the Ghost base to convert.
+ *  @Input eBehaviour - Specifies if the function should convert and free or only convert.
  *
  *  @Return PVRSRV_OK on Success, PVRSRV_ERROR code on Failure.
 */ /**************************************************************************/
 static PVRSRV_ERROR
-_ConvertGhostBaseFreeReal(RA_ARENA *pArena,
-                          RA_BASE_ARRAY_T aBaseArray,
-                          RA_LENGTH_T uiChunkSize,
-                          IMG_UINT32 uiRealBaseIndex,
-                          IMG_UINT32 uiGhostBaseIndex)
+_ConvertAndFreeStartFromReal(RA_ARENA *pArena,
+                             RA_BASE_ARRAY_T aBaseArray,
+                             RA_LENGTH_T uiChunkSize,
+                             IMG_UINT32 uiRealBaseIndex,
+                             IMG_UINT32 uiGhostBaseIndex,
+                             RA_CONVERT_AND_FREE_BEHAVIOUR eBehaviour)
 {
 	PVRSRV_ERROR eError;
 	RA_BASE_T uiRealBase = aBaseArray[uiRealBaseIndex];
@@ -1249,18 +1273,22 @@ _ConvertGhostBaseFreeReal(RA_ARENA *pArena,
 	                                 uiChunkSize);
 	PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
 
-	eError = _FreeSingleBaseArray(pArena,
-	                              &aBaseArray[uiRealBaseIndex],
-	                              uiGhostBaseIndex - uiRealBaseIndex);
-	PVR_LOG_RETURN_IF_ERROR(eError, "_FreeBaseArray");
+	if (eBehaviour == CONVERT_AND_FREE)
+	{
+		eError = _FreeSingleBaseArray(pArena,
+		                              &aBaseArray[uiRealBaseIndex],
+		                              uiGhostBaseIndex - uiRealBaseIndex);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_FreeBaseArray");
+	}
 
 	return eError;
 }
 
 /*************************************************************************/ /*!
- *  @Function   _FreeBaseArraySlice
+ *  @Function   _ConvertAndFreeBaseArraySlice
  *
- *  @Description   Free Bases in an Array Slice.
+ *  @Description   Convert and maybe free Bases in an Array Slice.
+ *                 This function might convert some ghosts into real bases.
  *                 This function assumes that the slice is within a single Real base alloc.
  *                 i.e the uiFreeStartIndex and uiFreeCount remain fully within a single real
  *                 base alloc and do not cross into another Real base region.
@@ -1271,16 +1299,18 @@ _ConvertGhostBaseFreeReal(RA_ARENA *pArena,
  *  @Input uiChunkSize - The base chunk size used to generate the Ghost bases.
  *  @Input uiFreeStartIndex - The index in the array to start freeing from
  *  @Input uiFreeCount - The number of bases to free.
+ *  @Input eBehaviour - Specifies if the function should convert and free or only convert.
  *
  *  @Return PVRSRV_OK on Success, PVRSRV_ERROR code on Failure.
 */ /**************************************************************************/
 static PVRSRV_ERROR
-_FreeBaseArraySlice(RA_ARENA *pArena,
-                    RA_BASE_ARRAY_T aBaseArray,
-                    RA_BASE_ARRAY_SIZE_T uiBaseArraySize,
-                    RA_LENGTH_T uiChunkSize,
-                    IMG_UINT32 uiFreeStartIndex,
-                    IMG_UINT32 uiFreeCount)
+_ConvertAndFreeBaseArraySlice(RA_ARENA *pArena,
+                             RA_BASE_ARRAY_T aBaseArray,
+                             RA_BASE_ARRAY_SIZE_T uiBaseArraySize,
+                             RA_LENGTH_T uiChunkSize,
+                             IMG_UINT32 uiFreeStartIndex,
+                             IMG_UINT32 uiFreeCount,
+                             RA_CONVERT_AND_FREE_BEHAVIOUR eBehaviour)
 {
 	/*3 cases:
 	 * Key: () = Region to Free
@@ -1322,32 +1352,37 @@ _FreeBaseArraySlice(RA_ARENA *pArena,
 		    RA_BASE_IS_REAL(aBaseArray[uiFreeStartIndex + uiFreeCount]) ||
 		    RA_BASE_IS_INVALID(aBaseArray[uiFreeStartIndex + uiFreeCount]))
 		{
-			eError = _FreeSingleBaseArray(pArena,
-			                              &aBaseArray[uiFreeStartIndex],
-			                              uiFreeCount);
-			PVR_LOG_RETURN_IF_ERROR(eError, "_FreeBaseArray");
+			if (eBehaviour == CONVERT_AND_FREE)
+			{
+				eError = _FreeSingleBaseArray(pArena,
+				                              &aBaseArray[uiFreeStartIndex],
+				                              uiFreeCount);
+				PVR_LOG_RETURN_IF_ERROR(eError, "_FreeBaseArray");
+			}
 		}
 		/* Case 2*/
 		else
 		{
-			eError = _ConvertGhostBaseFreeReal(pArena,
-			                                   aBaseArray,
-			                                   uiChunkSize,
-			                                   uiFreeStartIndex,
-			                                   uiFreeStartIndex + uiFreeCount);
-			PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
+			eError = _ConvertAndFreeStartFromReal(pArena,
+			                                      aBaseArray,
+			                                      uiChunkSize,
+			                                      uiFreeStartIndex,
+			                                      uiFreeStartIndex + uiFreeCount,
+			                                      eBehaviour);
+			PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertAndFreeStartFromReal");
 		}
 	}
 	/* Case 3 */
 	else if (RA_BASE_IS_GHOST(aBaseArray[uiFreeStartIndex]))
 	{
-		eError = _FreeGhostBasesFromReal(pArena,
-		                                 aBaseArray,
-		                                 uiBaseArraySize,
-		                                 uiChunkSize,
-		                                 uiFreeStartIndex,
-		                                 uiFreeCount);
-		PVR_LOG_RETURN_IF_ERROR(eError, "_FreeGhostBasesFromReal");
+		eError = _ConvertAndFreeStartFromGhost(pArena,
+		                                       aBaseArray,
+		                                       uiBaseArraySize,
+		                                       uiChunkSize,
+		                                       uiFreeStartIndex,
+		                                       uiFreeCount,
+		                                       eBehaviour);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertAndFreeStartFromGhost");
 	}
 	/* Attempt to free an invalid base, this could be a duplicated
 	 * value in the free sparse index array */
@@ -1355,7 +1390,7 @@ _FreeBaseArraySlice(RA_ARENA *pArena,
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 		        "Attempt to free already free base Index %u", uiFreeStartIndex));
-		PVR_ASSERT(!"Attempted double free.")
+		PVR_ASSERT(!"Attempted double free.");
 		return PVRSRV_ERROR_RA_FREE_INVALID_CHUNK;
 	}
 
@@ -1767,57 +1802,73 @@ _AttemptAllocAlignedAssured(RA_ARENA *pArena,
 	return PVRSRV_ERROR_RA_ATTEMPT_ALLOC_ALIGNED_FAILED;
 }
 
+/* Used as an inout parameter to reduce required memory allocations.
+ * The import callbacks return one or more RA_IMPORT which is then converted into a BT*.
+ * Once a RA_IMPORT is converted to a BT*, it is no longer needed. Therefore,
+ * the space taken up by the RA_IMPORT can be reused. */
+typedef union {
+	RA_IMPORT import;
+	BT *pBT;
+} RA_IMPORT_INTERNAL;
+
+
+static_assert(sizeof(RA_IMPORT_INTERNAL) == sizeof(RA_IMPORT),
+              "An RA_IMPORT[] array must be equivalent to an RA_IMPORT_INTERNAL[] array. "
+              "This allows RA_IMPORT[] returned by callbacks to be reused internally "
+              "as BT*[] without leaking scope to the user API.");
+
+static_assert(offsetof(RA_IMPORT_INTERNAL, pBT) == 0,
+              "The pBT member must be at offset 0 to match a BT*[].");
+
+/* Support importing 16 spans at once before allocating more memory.
+ * Almost all imports will only require a single span.
+ * However, if importing multiple spans, shouldn't always require memory allocations.
+ * Nominal use of multi imports shouldn't require many spans. */
+#define RA_DEFAULT_IMPORTS_BUFFER_SIZE (16 * (sizeof(RA_IMPORT) / sizeof(BT*)))
+
+static_assert((RA_DEFAULT_IMPORTS_BUFFER_SIZE * sizeof(BT*)) >= sizeof(RA_IMPORT),
+              "The default must be able to hold at least a single RA_IMPORT.");
+
+typedef struct {
+	BT **apsBTs;
+	IMG_UINT32 uiBTCount;
+} BT_PTR_ARRAY;
+
 /*************************************************************************/ /*!
-@Function       _AttemptImportSpanAlloc
-@Description    Attempt to Import more memory and create a new span.
+@Function       _AttemptImportSpanAllocSingle
+@Description    Attempt to import more memory and create a new span.
                 Function attempts to import more memory from the callback
                 provided at RA creation time, if successful the memory
                 will form a new span in the RA.
 @Input          pArena            The arena.
 @Input          uRequestSize      The requested allocation size.
-@Input          uImportMultiplier Import x-times more for future requests if
-                                  we have to import new memory.
 @Input          uImportFlags      Flags influencing allocation policy.
 @Input          uAlignment        The alignment requirements of the allocation
                                   Required uAlignment, or 0.
                                   Must be a power of 2 if not 0
-@Input          pszAnnotation     String to describe the allocation
-@Output         pImportBase       Allocated import base
-                                  (non-optional, must not be NULL)
-@Output         pImportSize       Allocated import size
-@Output         pImportBT         Allocated import BT
-@Return         PVRSRV_OK - success
+@Input          pszAnnotation     String to describe the allocation.
+@Output         psImportInternal  The pBT member must be set to the new span.
+                                  Unless an error is returned.
+@Return         PVRSRV_OK - Success
 */ /**************************************************************************/
 static PVRSRV_ERROR
-_AttemptImportSpanAlloc(RA_ARENA *pArena,
-                        RA_LENGTH_T uRequestSize,
-                        IMG_UINT8 uImportMultiplier,
-                        RA_FLAGS_T uImportFlags,
-                        RA_LENGTH_T uAlignment,
-                        const IMG_CHAR *pszAnnotation,
-                        RA_BASE_T *pImportBase,
-                        RA_LENGTH_T *pImportSize,
-                        BT **pImportBT)
+_AttemptImportSpanAllocSingle(RA_ARENA *pArena,
+                              RA_LENGTH_T uRequestSize,
+                              RA_FLAGS_T uImportFlags,
+                              RA_LENGTH_T uAlignment,
+                              const IMG_CHAR *pszAnnotation,
+                              RA_IMPORT_INTERNAL *psImportInternal)
 {
-	IMG_HANDLE hPriv;
+	PVRSRV_ERROR eError;
 	RA_FLAGS_T uFlags = (uImportFlags & PVRSRV_MEMALLOCFLAGS_RA_DIFFERENTIATION_MASK);
+	RA_IMPORT *psImport = &psImportInternal->import;
 	BT *pBT;
-	PVRSRV_ERROR eError;
-
-	*pImportSize = uRequestSize;
 
-	/* apply over-allocation multiplier after all alignment adjustments */
-	*pImportSize *= uImportMultiplier;
-
-	/* ensure that we import according to the quanta of this arena */
-	*pImportSize = PVR_ALIGN(*pImportSize, pArena->uQuantum);
-
-	eError = pArena->pImportAlloc(pArena->pImportHandle,
-								  *pImportSize, uImportFlags,
-								  uAlignment,
-								  pszAnnotation,
-								  pImportBase, pImportSize,
-								  &hPriv);
+	eError = pArena->pImportAllocSingle(pArena->pImportHandle,
+	                                    uRequestSize, uImportFlags,
+	                                    uAlignment,
+	                                    pszAnnotation,
+	                                    psImport);
 	if (PVRSRV_OK != eError)
 	{
 		return eError;
@@ -1826,12 +1877,12 @@ _AttemptImportSpanAlloc(RA_ARENA *pArena,
 	/* If we successfully import more resource, create a span to
 	 * represent it else free the resource we imported.
 	 */
-	pBT = _InsertResourceSpan(pArena, *pImportBase, *pImportSize, uFlags);
+	pBT = _InsertResourceSpan(pArena, psImport->base, psImport->uSize, uFlags);
 	if (pBT == NULL)
 	{
 		/* insufficient resources to insert the newly acquired span,
 		   so free it back again */
-		pArena->pImportFree(pArena->pImportHandle, *pImportBase, hPriv);
+		pArena->pImportFree(pArena->pImportHandle, psImport->base, psImport->hPriv);
 
 		PVR_DPF((PVR_DBG_MESSAGE, "%s: name='%s', "
 		        "size=0x%llx failed!", __func__, pArena->name,
@@ -1841,20 +1892,233 @@ _AttemptImportSpanAlloc(RA_ARENA *pArena,
 		return PVRSRV_ERROR_RA_INSERT_RESOURCE_SPAN_FAILED;
 	}
 
-	pBT->hPriv = hPriv;
-	*pImportBT = pBT;
+	pBT->hPriv = psImport->hPriv;
+	/* Replace the RA_IMPORT with a BT*.
+	 * To free an import we only need the BT so we can reuse the elements slot in ppsImports. */
+	psImportInternal->pBT = pBT;
+
+	pArena->ui64TotalArenaSize += pBT->uSize;
+	pArena->ui64FreeArenaSize += pBT->uSize;
 
 	return eError;
 }
 
-IMG_INTERNAL RA_ARENA *
-RA_Create(IMG_CHAR *name,
-          RA_LOG2QUANTUM_T uLog2Quantum,
-          IMG_UINT32 ui32LockClass,
-          PFN_RA_ALLOC imp_alloc,
-          PFN_RA_FREE imp_free,
-          RA_PERARENA_HANDLE arena_handle,
-          RA_POLICY_T ui32PolicyFlags)
+/*************************************************************************/ /*!
+@Function       _AttemptImportSpanAllocMulti
+@Description    Attempt to import more memory and create new span(s).
+                Function attempts to import more memory from the callback
+                provided at RA creation time, if successful the memory
+                will form at least one new span in the RA.
+@Input          pArena            The arena.
+@Input          uRequestSize      The requested allocation size.
+@Input          uImportFlags      Flags influencing allocation policy.
+@Input          uAlignment        The alignment requirements of the allocation
+                                  Required uAlignment, or 0.
+                                  Must be a power of 2 if not 0
+@Input          pszAnnotation     String to describe the allocation.
+@Inout          puiBTCount        The number of elements in *ppsImports. The
+                                  count will be modified to reflect how many
+                                  BT*s have been created.
+@Inout          ppsImports        Pointer to an array of RA_IMPORT_INTERNAL.
+                                  If the must be array resized, this will point
+                                  to the new array. It will be freed higher up
+                                  the callstack if necessary. If successful,
+                                  the pBT member must be set to a new span for
+                                  every element in the array of length puiBTCount.
+@Return         PVRSRV_OK - Success
+*/ /**************************************************************************/
+static PVRSRV_ERROR
+_AttemptImportSpanAllocMulti(RA_ARENA *pArena,
+                             RA_LENGTH_T uRequestSize,
+                             RA_FLAGS_T uImportFlags,
+                             RA_LENGTH_T uAlignment,
+                             const IMG_CHAR *pszAnnotation,
+                             IMG_UINT32 *puiImportCount,
+                             RA_IMPORT_INTERNAL **ppsImports)
+{
+	PVRSRV_ERROR eError;
+	RA_FLAGS_T uFlags = (uImportFlags & PVRSRV_MEMALLOCFLAGS_RA_DIFFERENTIATION_MASK);
+	IMG_UINT32 i;
+
+	eError = pArena->pImportAllocMulti(pArena->pImportHandle,
+	                                   uRequestSize, uImportFlags,
+	                                   uAlignment,
+	                                   pszAnnotation,
+	                                   puiImportCount,
+	                                   (RA_IMPORT**) ppsImports);
+	PVR_RETURN_IF_ERROR(eError);
+
+	/* An error should be returned by the callback if the count == 0. */
+	PVR_ASSERT(*puiImportCount >= 1);
+	/* An error should be returned by the callback if *ppsImports == NULL. */
+	PVR_ASSERT(*ppsImports != NULL);
+
+	/* If we successfully import more resource, create spans to represent it. */
+	for (i = 0; i < *puiImportCount; i++)
+	{
+		BT *pBT;
+		RA_IMPORT *psImport = &(*ppsImports)[i].import;
+
+		pBT = _InsertResourceSpan(pArena, psImport->base, psImport->uSize, uFlags);
+		PVR_GOTO_IF_FALSE(pBT != NULL, release_bts);
+
+		pBT->hPriv = psImport->hPriv;
+		pArena->ui64TotalArenaSize += pBT->uSize;
+		pArena->ui64FreeArenaSize += pBT->uSize;
+
+		/* Replace the RA_IMPORT with a BT*.
+		 * To free an import we only need the BT so we can reuse the elements slot in ppsImports. */
+		(*ppsImports)[i].pBT = pBT;
+	}
+
+	return PVRSRV_OK;
+
+release_bts:
+	{
+		/* Free the just imported span that failed to allocate a BT. */
+		IMG_UINT32 j;
+		RA_IMPORT *psImport = &(*ppsImports)[i].import;
+
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: name='%s', "
+		        "request=0x%llx size=0x%llx failed!", __func__, pArena->name,
+		        (unsigned long long)uRequestSize, (unsigned long long)psImport->uSize));
+
+		/* Insufficient resources to insert the newly acquired span so free it back again. */
+		pArena->pImportFree(pArena->pImportHandle, psImport->base, psImport->hPriv);
+
+		/* Remove the previously inserted BTs. */
+		for (j = 0; j < i; j++)
+		{
+			BT *pBT = (*ppsImports)[j].pBT;
+			pArena->ui64TotalArenaSize -= pBT->uSize;
+			pArena->ui64FreeArenaSize -= pBT->uSize;
+			_FreeBT(pArena, pBT);
+		}
+
+		return PVRSRV_ERROR_RA_INSERT_RESOURCE_SPAN_FAILED;
+	}
+}
+
+/*************************************************************************/ /*!
+@Function       _AttemptImportSpanAlloc
+@Description    Attempt to import more memory and create new span(s).
+                Function attempts to import more memory from the callback
+                provided at RA creation time, if successful the memory
+                will form a new span in the RA.
+@Input          pArena            The arena.
+@Input          uRequestSize      The requested allocation size.
+@Input          uImportMultiplier Import x-times more for future requests if
+                                  we have to import new memory.
+@Input          uImportFlags      Flags influencing allocation policy.
+@Input          uAlignment        The alignment requirements of the allocation
+                                  Required uAlignment, or 0.
+                                  Must be a power of 2 if not 0
+@Input          pszAnnotation     String to describe the allocation
+@Inout          psBTArray         A container to a BT*[] and it's length.
+                                  If the array is not large enough, a new array
+                                  will be returned and must be freed with OSFreeMem
+                                  regardless of the return error code.
+                                  On error, the array may be NULL!
+@Return         PVRSRV_OK - Success
+*/ /**************************************************************************/
+static PVRSRV_ERROR
+_AttemptImportSpanAlloc(RA_ARENA *pArena,
+                        RA_LENGTH_T uRequestSize,
+                        IMG_UINT8 uImportMultiplier,
+                        RA_FLAGS_T uImportFlags,
+                        RA_LENGTH_T uAlignment,
+                        const IMG_CHAR *pszAnnotation,
+                        BT_PTR_ARRAY *psBTArray)
+{
+	PVRSRV_ERROR eError = PVRSRV_ERROR_RA_INSERT_RESOURCE_SPAN_FAILED;
+	RA_IMPORT_INTERNAL *psImports;
+
+	/* Interpret the BT*[] as a RA_IMPORT_INTERNAL[].
+	 * Any extra space is ignored.
+	 * Example:
+	 * |---BT*--|---BT*--|---BT*--|---BT*--|---BT*--|---BT*--|---BT*--|
+	 * |----RA_IMPORT_INTERNAL----|----RA_IMPORT_INTERNAL----|........|
+	 *
+	 * It must be able to hold at least 1 RA_IMPORT_INTERNAL.
+	 * This should never fail if RA_DEFAULT_IMPORTS_BUFFER_SIZE is used. */
+	PVR_ASSERT(psBTArray->uiBTCount * sizeof(BT*) >= sizeof(RA_IMPORT_INTERNAL));
+	PVR_ASSERT(psBTArray != NULL && psBTArray->apsBTs != NULL);
+	psImports = (RA_IMPORT_INTERNAL*) psBTArray->apsBTs;
+
+	/* apply over-allocation multiplier after all alignment adjustments */
+	uRequestSize *= uImportMultiplier;
+	/* ensure that we import according to the quanta of this arena */
+	uRequestSize = PVR_ALIGN(uRequestSize, pArena->uQuantum);
+
+	switch (pArena->eImportAllocMethod)
+	{
+	/* Exactly 1 BT will be created. */
+	case RA_IMPORT_ALLOC_METHOD_SINGLE:
+	{
+		eError = _AttemptImportSpanAllocSingle(pArena, uRequestSize, uImportFlags, uAlignment, pszAnnotation,  &psImports[0]);
+		PVR_GOTO_IF_ERROR(eError, err_);
+		psBTArray->uiBTCount = 1;
+
+		/* Reinterpret the RA_IMPORT_INTERNAL[] back into a BT*[].
+		 * We only care about psBTArray->apsBTs[0] being valid as we return a count of 1. */
+		psBTArray->apsBTs = (BT**) psImports;
+		break;
+	}
+	/* 1 or more BTs will be created. */
+	case RA_IMPORT_ALLOC_METHOD_MULTI:
+	{
+		/* The number of RA_IMPORT_INTERNAL that can be stored using the same space. */
+		IMG_UINT32 uiImportCount = (psBTArray->uiBTCount) / (sizeof(RA_IMPORT_INTERNAL) / sizeof(BT*));
+
+		eError = _AttemptImportSpanAllocMulti(pArena, uRequestSize, uImportFlags, uAlignment, pszAnnotation, &uiImportCount, &psImports);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_AttemptImportSpanAllocMulti");
+
+		/* Reinterpret the RA_IMPORT_INTERNAL[] back into a BT*[]. */
+		psBTArray->apsBTs = (BT**) psImports;
+
+		/* If a BT* is smaller than an RA_IMPORT_INTERNAL, the array of BT*s will not be tightly packed.
+		 * Therefore, it is not a valid BT*[] and the elements need to be compressed.
+		 * Example: Given the array below
+		 * |----RA_IMPORT_INTERNAL-0--|----RA_IMPORT_INTERNAL-1--|........|
+		 * |--BT*-0-|.................|--BT*-1-|..........................|
+		 * It must be packed into this:
+		 * |--BT*-0-|--BT*-1-|............................................| */
+		if (sizeof(BT*) < sizeof(RA_IMPORT_INTERNAL))
+		{
+			IMG_UINT32 i;
+			/* The first element will always be in the correct place. Skip redundant move. */
+			for (i = 1; i < uiImportCount; i++)
+			{
+				psBTArray->apsBTs[i] = psImports[i].pBT;
+			}
+		}
+		psBTArray->uiBTCount = uiImportCount;
+		break;
+	}
+	default:
+		PVR_ASSERT(!"unreachable");
+		break;
+	}
+
+	return eError;
+
+err_:
+	if ((void*) psImports != (void*) psBTArray->apsBTs && psImports != NULL)
+	{
+		OSFreeMem(psImports);
+	}
+	return eError;
+}
+
+static RA_ARENA*
+RA_CreateCommon(IMG_CHAR *name,
+                 RA_LOG2QUANTUM_T uLog2Quantum,
+                 IMG_UINT32 ui32LockClass,
+                 enum RA_IMPORT_ALLOC_METHOD eImportAllocMethod,
+                 void* imp_alloc,
+                 PFN_RA_IMPORT_FREE imp_free,
+                 RA_PERARENA_HANDLE arena_handle,
+                 RA_POLICY_T ui32PolicyFlags)
 {
 	RA_ARENA *pArena;
 	PVRSRV_ERROR eError;
@@ -1886,12 +2150,18 @@ RA_Create(IMG_CHAR *name,
 		goto hash_fail;
 	}
 
-	OSStringLCopy(pArena->name, name, RA_MAX_NAME_LENGTH);
-	pArena->pImportAlloc = (imp_alloc!=NULL) ? imp_alloc : &_RequestAllocFail;
+	if (imp_alloc == NULL) {
+		eImportAllocMethod = RA_IMPORT_ALLOC_METHOD_SINGLE;
+		imp_alloc = &_RequestAllocFail;
+	}
+
+	OSStringSafeCopy(pArena->name, name, RA_MAX_NAME_LENGTH);
+	pArena->eImportAllocMethod = eImportAllocMethod;
+	pArena->pImportAlloc = imp_alloc; /* import callback union */
 	pArena->pImportFree = imp_free;
 	pArena->pImportHandle = arena_handle;
 	pArena->pHeadSegment = NULL;
-	pArena->uQuantum = 1ULL << uLog2Quantum;
+	pArena->uQuantum = IMG_PAGE2BYTES64(uLog2Quantum);
 	pArena->per_flags_buckets = NULL;
 	pArena->ui32LockClass = ui32LockClass;
 	pArena->ui32PolicyFlags = ui32PolicyFlags;
@@ -1910,6 +2180,46 @@ RA_Create(IMG_CHAR *name,
 	return NULL;
 }
 
+IMG_INTERNAL RA_ARENA *
+RA_Create(IMG_CHAR *name,
+          RA_LOG2QUANTUM_T uLog2Quantum,
+          IMG_UINT32 ui32LockClass,
+          PFN_RA_IMPORT_ALLOC_SINGLE imp_alloc,
+          PFN_RA_IMPORT_FREE imp_free,
+          RA_PERARENA_HANDLE arena_handle,
+          RA_POLICY_T ui32PolicyFlags)
+{
+	return RA_CreateCommon(name,
+	                       uLog2Quantum,
+	                       ui32LockClass,
+	                       RA_IMPORT_ALLOC_METHOD_SINGLE,
+	                       imp_alloc,
+	                       imp_free,
+	                       arena_handle,
+	                       ui32PolicyFlags
+	);
+}
+
+IMG_INTERNAL RA_ARENA *
+RA_CreateMulti(IMG_CHAR *name,
+               RA_LOG2QUANTUM_T uLog2Quantum,
+               IMG_UINT32 ui32LockClass,
+               PFN_RA_IMPORT_ALLOC_MULTI imp_alloc,
+               PFN_RA_IMPORT_FREE imp_free,
+               RA_PERARENA_HANDLE arena_handle,
+               RA_POLICY_T ui32PolicyFlags)
+{
+	return RA_CreateCommon(name,
+	                       uLog2Quantum,
+	                       ui32LockClass,
+	                       RA_IMPORT_ALLOC_METHOD_MULTI,
+	                       imp_alloc,
+	                       imp_free,
+	                       arena_handle,
+	                       ui32PolicyFlags
+	);
+}
+
 static void _LogRegionCreation(const char *pszMemType,
                                IMG_UINT64 ui64CpuPA,
                                IMG_UINT64 ui64DevPA,
@@ -1984,7 +2294,7 @@ IMG_INTERNAL void
 RA_Delete(RA_ARENA *pArena)
 {
 	IMG_UINT32 uIndex;
-	IMG_BOOL bWarn = IMG_TRUE;
+	IMG_BOOL bPrintWarn = IMG_TRUE;
 
 	PVR_ASSERT(pArena != NULL);
 
@@ -2005,15 +2315,27 @@ RA_Delete(RA_ARENA *pArena)
 
 		if (pBT->type != btt_free)
 		{
-			if (bWarn)
+#if !defined(DEBUG)
+			if (bPrintWarn)
 			{
-				PVR_DPF((PVR_DBG_ERROR, "%s: Allocations still exist in the arena that is being destroyed", __func__));
+				PVR_DPF((PVR_DBG_ERROR, "%s: Allocations still exist in the arena that is being destroyed. Arena Name: %s", __func__, pArena->name));
 				PVR_DPF((PVR_DBG_ERROR, "%s: Likely Cause: client drivers not freeing allocations before destroying devmem context", __func__));
 				PVR_DPF((PVR_DBG_ERROR, "%s: base = 0x%llx size=0x%llx", __func__,
 					  (unsigned long long)pBT->base, (unsigned long long)pBT->uSize));
 				PVR_DPF((PVR_DBG_ERROR, "%s: This warning will be issued only once for the first allocation found!", __func__));
-				bWarn = IMG_FALSE;
+				bPrintWarn = IMG_FALSE;
 			}
+#else
+			if (bPrintWarn)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: Allocations still exist in the arena that is being destroyed. Arena Name: %s", __func__, pArena->name));
+				PVR_DPF((PVR_DBG_ERROR, "%s: Likely Cause: client drivers not freeing allocations before destroying devmem context", __func__));
+				bPrintWarn = IMG_FALSE;
+			}
+			PVR_DPF((PVR_DBG_ERROR, "%s: base = 0x%llx size=0x%llx flags=0x%llx", __func__,
+				  (unsigned long long)pBT->base, (unsigned long long)pBT->uSize,
+				  (unsigned long long)pBT->uFlags));
+#endif
 		}
 		else
 		{
@@ -2132,9 +2454,11 @@ RA_Alloc(RA_ARENA *pArena,
 	bResult = _AttemptAllocAligned(pArena, uSize, uFlags, uAlignment, base, phPriv);
 	if (!bResult)
 	{
-		RA_BASE_T uImportBase;
-		RA_LENGTH_T uImportSize;
-		BT *pBT = NULL;
+		BT *apsBTsStatic[RA_DEFAULT_IMPORTS_BUFFER_SIZE];
+		BT_PTR_ARRAY sBTs = {
+			.uiBTCount = ARRAY_SIZE(apsBTsStatic),
+			.apsBTs = apsBTsStatic,
+		};
 
 		eError = _AttemptImportSpanAlloc(pArena,
 		                                 uSize,
@@ -2142,11 +2466,13 @@ RA_Alloc(RA_ARENA *pArena,
 		                                 uImportFlags,
 		                                 uAlignment,
 		                                 pszAnnotation,
-		                                 &uImportBase,
-		                                 &uImportSize,
-		                                 &pBT);
+		                                 &sBTs);
 		if (eError != PVRSRV_OK)
 		{
+			if (sBTs.apsBTs != apsBTsStatic)
+			{
+				OSFreeMem(sBTs.apsBTs);
+			}
 			OSLockRelease(pArena->hLock);
 			return eError;
 		}
@@ -2154,6 +2480,7 @@ RA_Alloc(RA_ARENA *pArena,
 		bResult = _AttemptAllocAligned(pArena, uSize, uFlags, uAlignment, base, phPriv);
 		if (!bResult)
 		{
+			IMG_UINT32 i;
 			PVR_DPF((PVR_DBG_ERROR,
 			        "%s: name='%s' second alloc failed!",
 			        __func__, pArena->name));
@@ -2163,32 +2490,50 @@ RA_Alloc(RA_ARENA *pArena,
 			  of failure, the imported segment may have been used and freed, or
 			  left untouched. If the later, we need to return it.
 			*/
-			_FreeBT(pArena, pBT);
+			for (i = 0; i < sBTs.uiBTCount; i++)
+			{
+				_FreeBT(pArena, sBTs.apsBTs[i]);
+			}
 
+			if (sBTs.apsBTs != apsBTsStatic)
+			{
+				OSFreeMem(sBTs.apsBTs);
+			}
 			OSLockRelease(pArena->hLock);
 			return PVRSRV_ERROR_RA_ATTEMPT_ALLOC_ALIGNED_FAILED;
 		}
 		else
 		{
-			/* Check if the new allocation was in the span we just added... */
-			if (*base < uImportBase  ||  *base > (uImportBase + uImportSize))
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-				        "%s: name='%s' alloc did not occur in the imported span!",
-				        __func__, pArena->name));
+			IMG_UINT32 i;
+			IMG_BOOL bBaseInNewSpans = IMG_FALSE;
 
-				/*
-				  Remove the imported span which should not be in use (if it is then
-				  that is okay, but essentially no span should exist that is not used).
-				*/
-				_FreeBT(pArena, pBT);
+			for (i = 0; i < sBTs.uiBTCount; i++)
+			{
+				BT *pBT = sBTs.apsBTs[i];
+				/* Check if the new allocation was in a span we just added... */
+				if (*base >= pBT->base && *base < (pBT->base + pBT->uSize))
+				{
+					bBaseInNewSpans = IMG_TRUE;
+					break;
+				}
 			}
-			else
+			if (!bBaseInNewSpans)
 			{
-				pArena->ui64FreeArenaSize += uImportSize;
-				pArena->ui64TotalArenaSize += uImportSize;
+				PVR_DPF((PVR_DBG_ERROR,
+				         "%s: name='%s' alloc did not occur in the imported span!",
+				         __func__, pArena->name));
+				/* Remove the imported spans which should not be in use (if it is then that is okay).
+				 * No spans should exist and not be used unless added through the import multiplier. */
+				for (i = 0; i < sBTs.uiBTCount; i++)
+				{
+					_FreeBT(pArena, sBTs.apsBTs[i]);
+				}
 			}
 		}
+		if (sBTs.apsBTs != apsBTsStatic)
+		{
+			OSFreeMem(sBTs.apsBTs);
+		}
 	}
 
 	PVR_DPF((PVR_DBG_MESSAGE, "%s: name='%s', size=0x%llx, "
@@ -2223,8 +2568,8 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 	                        "One of the necessary parameters is 0",
 	                        PVRSRV_ERROR_INVALID_PARAMS);
 
-	PVR_ASSERT((uRequestSize & ((1 << uiLog2ChunkSize) - 1)) == 0)
-	PVR_LOG_RETURN_IF_FALSE((uRequestSize & ((1 << uiLog2ChunkSize) - 1)) == 0,
+	PVR_ASSERT((uRequestSize & (IMG_PAGE2BYTES64(uiLog2ChunkSize) - 1)) == 0);
+	PVR_LOG_RETURN_IF_FALSE((uRequestSize & (IMG_PAGE2BYTES64(uiLog2ChunkSize) - 1)) == 0,
 	                        "Require uiLog2ChunkSize pow 2 & multiple of uRequestSize",
 	                        PVRSRV_ERROR_INVALID_PARAMS);
 
@@ -2235,15 +2580,12 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 		                    PVRSRV_ERROR_INVALID_PARAMS);
 
 	/* Ensure Base Array is large enough for intended allocation */
-	PVR_LOG_RETURN_IF_FALSE(((RA_LENGTH_T)uiBaseArraySize * (1 << uiLog2ChunkSize)) >= uRequestSize,
+	PVR_LOG_RETURN_IF_FALSE(((RA_LENGTH_T)uiBaseArraySize * (IMG_PAGE2BYTES64(uiLog2ChunkSize)) >= uRequestSize),
 		                    "Not enough array space to store alloc bases",
 		                    PVRSRV_ERROR_INVALID_PARAMS);
 
 	PVR_ASSERT(is_arena_valid(pArena));
 
-	/* Must be a power of 2 */
-	PVR_ASSERT((uAlignment & (uAlignment - 1)) == 0);
-
 	PVR_DPF((PVR_DBG_MESSAGE,
 	        "%s: arena='%s', size=0x%llx(0x%llx), "
 	        "log2ChunkSize=0x%llx", __func__, pArena->name,
@@ -2257,15 +2599,17 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 	                                      uSize,
 	                                      uiLog2ChunkSize,
 	                                      uFlags,
-	                                      1ULL << uiLog2ChunkSize,
+	                                      IMG_PAGE2BYTES64(uiLog2ChunkSize),
 	                                      aBaseArray,
 	                                      bSparseAlloc,
 	                                      bPhysContig);
 	if (eError)
 	{
-		RA_BASE_T uImportBase;
-		RA_LENGTH_T uImportSize;
-		BT *pBT;
+		BT *apsBTsStatic[RA_DEFAULT_IMPORTS_BUFFER_SIZE];
+		BT_PTR_ARRAY sBTs = {
+			.uiBTCount = ARRAY_SIZE(apsBTsStatic),
+			.apsBTs = apsBTsStatic,
+		};
 
 		if (eError == PVRSRV_ERROR_RA_OUT_OF_RESOURCE)
 		{
@@ -2293,29 +2637,29 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 		                                 uSize,
 		                                 uImportMultiplier,
 		                                 uFlags,
-		                                 1ULL << uiLog2ChunkSize,
+		                                 IMG_PAGE2BYTES64(uiLog2ChunkSize),
 		                                 pszAnnotation,
-		                                 &uImportBase,
-		                                 &uImportSize,
-		                                 &pBT);
+		                                 &sBTs);
 		if (eError != PVRSRV_OK)
 		{
+			if (sBTs.apsBTs != apsBTsStatic)
+			{
+				OSFreeMem(sBTs.apsBTs);
+			}
 			return eError;
 		}
 
-		pArena->ui64FreeArenaSize += uImportSize;
-		pArena->ui64TotalArenaSize += uImportSize;
-
 		eError = _AttemptAllocAlignedAssured(pArena,
 		                                      uSize,
 		                                      uiLog2ChunkSize,
 		                                      uFlags,
-		                                      1Ull << uiLog2ChunkSize,
+		                                      IMG_PAGE2BYTES64(uiLog2ChunkSize),
 		                                      aBaseArray,
 		                                      bSparseAlloc,
 		                                      bPhysContig);
 		if (eError)
 		{
+			IMG_UINT32 i;
 			PVR_DPF((PVR_DBG_ERROR,
 					 "%s: name='%s' second alloc failed!",
 					 __func__, pArena->name));
@@ -2324,8 +2668,15 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 			  of failure, the imported segment may have been used and freed, or
 			  left untouched. If the later, we need to return it.
 			*/
-			_FreeBT(pArena, pBT);
+			for (i = 0; i < sBTs.uiBTCount; i++)
+			{
+				_FreeBT(pArena, sBTs.apsBTs[i]);
+			}
 
+			if (sBTs.apsBTs != apsBTsStatic)
+			{
+				OSFreeMem(sBTs.apsBTs);
+			}
 			return PVRSRV_ERROR_RA_ATTEMPT_ALLOC_ALIGNED_FAILED;
 		}
 #if defined(DEBUG)
@@ -2333,47 +2684,54 @@ _RA_AllocMultiUnlocked(RA_ARENA *pArena,
 		 * This block of code checks to see if the extra memory we just imported was
 		 * used for the second allocation. If we imported memory but did not use it,
 		 * it indicates there is a bug in the allocation logic. We can still recover by
-		 * freeing the imported span but we emit an error to signal that there is an
+		 * freeing the imported span(s) but we emit an error to signal that there is an
 		 * issue.
 		 * */
 		else
 		{
-			IMG_UINT32 i;
+			IMG_UINT32 bt_index;
+			IMG_UINT32 base_index;
 			IMG_BOOL bBasesInNewSpan = IMG_FALSE;
 
-			for (i = 0; i < uiBaseArraySize; i++)
+			for (bt_index = 0; bt_index < sBTs.uiBTCount && !bBasesInNewSpan; bt_index++)
 			{
-				RA_BASE_T uiBase = RA_BASE_STRIP_GHOST_BIT(aBaseArray[i]);
-
-				/* If the base hasn't been allocated then skip it */
-				if (aBaseArray[i] == INVALID_BASE_ADDR)
+				BT *pBT = sBTs.apsBTs[bt_index];
+				for (base_index = 0; base_index < uiBaseArraySize; base_index++)
 				{
-					continue;
-				}
-
-				if (uiBase >= uImportBase &&
-				    uiBase <= uImportBase + uImportSize)
-				{
-					bBasesInNewSpan = IMG_TRUE;
+					RA_BASE_T uiBase = RA_BASE_STRIP_GHOST_BIT(aBaseArray[base_index]);
+
+					/* If the base hasn't been allocated then skip it */
+					if (aBaseArray[base_index] == INVALID_BASE_ADDR)
+					{
+						continue;
+					}
+
+					if (uiBase >= pBT->base &&
+					    uiBase <= pBT->base + pBT->uSize)
+					{
+						bBasesInNewSpan = IMG_TRUE;
+						break;
+					}
 				}
 			}
-
 			if (!bBasesInNewSpan)
 			{
 				PVR_DPF((PVR_DBG_ERROR,
 						"%s: name='%s' alloc did not occur in the imported span!",
 						__func__, pArena->name));
-				/*
-				  Remove the imported span which should not be in use (if it is then
-				  that is okay, but essentially no span should exist that is not used).
-				*/
-				_FreeBT(pArena, pBT);
-
-				pArena->ui64FreeArenaSize -= uImportSize;
-				pArena->ui64TotalArenaSize -= uImportSize;
+				/* Remove the imported spans which should not be in use (if it is then that is okay).
+				 * No spans should exist and not be used unless added through the import multiplier. */
+				for (bt_index = 0; bt_index < sBTs.uiBTCount; bt_index++)
+				{
+					_FreeBT(pArena, sBTs.apsBTs[bt_index]);
+				}
 			}
 		}
 #endif
+		if (sBTs.apsBTs != apsBTsStatic)
+		{
+			OSFreeMem(sBTs.apsBTs);
+		}
 	}
 
 	PVR_ASSERT(is_arena_valid(pArena));
@@ -2458,7 +2816,7 @@ RA_AllocMultiSparse(RA_ARENA *pArena,
 	if (uiAllocCount == 1)
 	{
 		eError = _RA_AllocMultiUnlocked(pArena,
-		                                 1ULL << uiLog2ChunkSize,
+		                                 IMG_PAGE2BYTES64(uiLog2ChunkSize),
 		                                 uiLog2ChunkSize,
 		                                 uImportMultiplier,
 		                                 uImportFlags,
@@ -2492,7 +2850,7 @@ RA_AllocMultiSparse(RA_ARENA *pArena,
 		}
 
 		eError = _RA_AllocMultiUnlocked(pArena,
-		                                 (IMG_UINT64) uiConsolidate << uiLog2ChunkSize,
+		                                 IMG_PAGES2BYTES64(uiConsolidate, uiLog2ChunkSize),
 		                                 uiLog2ChunkSize,
 		                                 uImportMultiplier,
 		                                 uImportFlags,
@@ -2515,7 +2873,7 @@ RA_AllocMultiSparse(RA_ARENA *pArena,
 		eFreeError = _RA_FreeMultiUnlockedSparse(pArena,
 		                                          aBaseArray,
 		                                          uiBaseArraySize,
-		                                          1ULL << uiLog2ChunkSize,
+		                                          IMG_PAGE2BYTES64(uiLog2ChunkSize),
 		                                          puiAllocIndices,
 		                                          &i);
 		PVR_LOG_IF_ERROR(eFreeError, "_RA_FreeMultiUnlockedSparse");
@@ -2714,8 +3072,6 @@ RA_Free(RA_ARENA *pArena, RA_BASE_T base)
 {
 	BT *pBT;
 
-	PVR_ASSERT(pArena != NULL);
-
 	if (pArena == NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: invalid parameter - pArena", __func__));
@@ -2802,13 +3158,14 @@ _RA_FreeMultiUnlockedSparse(RA_ARENA *pArena,
 	/* Handle case where we only have 1 base to free. */
 	if (uiFreeCount == 1)
 	{
-		eError = _FreeBaseArraySlice(pArena,
-		                             aBaseArray,
-		                             uiBaseArraySize,
-		                             uiChunkSize,
-		                             puiFreeIndices[0],
-		                             1);
-		PVR_LOG_IF_ERROR(eError, "_FreeBaseArraySlice");
+		eError = _ConvertAndFreeBaseArraySlice(pArena,
+		                                      aBaseArray,
+		                                      uiBaseArraySize,
+		                                      uiChunkSize,
+		                                      puiFreeIndices[0],
+		                                      1,
+		                                      CONVERT_AND_FREE);
+		PVR_LOG_IF_ERROR(eError, "_ConvertAndFreeBaseArraySlice");
 		if (eError == PVRSRV_OK)
 		{
 			*puiFreeCount = uiFreeCount;
@@ -2825,19 +3182,21 @@ _RA_FreeMultiUnlockedSparse(RA_ARENA *pArena,
 
 		for (j = i;
 		     puiFreeIndices[j + 1] == puiFreeIndices[j] + 1 &&
-		     RA_BASE_IS_GHOST(aBaseArray[puiFreeIndices[j + 1]]);
+		     RA_BASE_IS_GHOST(aBaseArray[puiFreeIndices[j + 1]]) &&
+		     j + 1 < uiFreeCount;
 		     j++)
 		{
 			uiConsolidate++;
 		}
 
-		eError = _FreeBaseArraySlice(pArena,
-		                             aBaseArray,
-		                             uiBaseArraySize,
-		                             uiChunkSize,
-		                             puiFreeIndices[i],
-		                             uiConsolidate);
-		PVR_LOG_RETURN_IF_ERROR(eError, "_FreeBaseArraySlice");
+		eError = _ConvertAndFreeBaseArraySlice(pArena,
+		                                      aBaseArray,
+		                                      uiBaseArraySize,
+		                                      uiChunkSize,
+		                                      puiFreeIndices[i],
+		                                      uiConsolidate,
+		                                      CONVERT_AND_FREE);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertAndFreeBaseArraySlice");
 
 		i += uiConsolidate;
 		*puiFreeCount += uiConsolidate;
@@ -2878,7 +3237,7 @@ RA_FreeMultiSparse(RA_ARENA *pArena,
 	eError = _RA_FreeMultiUnlockedSparse(pArena,
 	                                      aBaseArray,
 	                                      uiBaseArraySize,
-	                                      1ULL << uiLog2ChunkSize,
+	                                      IMG_PAGE2BYTES64(uiLog2ChunkSize),
 	                                      puiFreeIndices,
 	                                      puiFreeCount);
 	OSLockRelease(pArena->hLock);
@@ -2886,6 +3245,151 @@ RA_FreeMultiSparse(RA_ARENA *pArena,
 	return eError;
 }
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+/*************************************************************************/ /*!
+ *  @Function   _RA_RealiseMultiSparseIndicesUnlocked
+ *
+ *  @Description   Given an array of indices to extract, prepares the base
+ *                 array so that the indices in puiExtractIndices can be
+ *                 moved to another base array.
+ *                 Called when some pages of the base array need to be
+ *                 transferred to another base array. As a result of this call,
+ *                 some ghost addresses in aBaseArray might be converted to
+ *                 real addresses.
+ *
+ *  @Input  pArena - The RA Arena to free the bases on.
+ *  @Input  aBaseArray - The Base array to free from
+ *  @Input  uiBaseArraySize - The Size of the base array to free.
+ *  @Input  uiChunkSize -  The Base chunk size used to generate ghost entries
+ *  @Input  puiExtractIndices - Array of indices to extract
+ *  @Input  puiExtractCount - Number of indices to extract
+ *
+ *  @Return PVRSRV_OK on Success, PVRSRV_ERROR code otherwise.
+*/ /**************************************************************************/
+static PVRSRV_ERROR
+_RA_RealiseMultiSparseIndicesUnlocked(RA_ARENA *pArena,
+                                      RA_BASE_ARRAY_T aBaseArray,
+                                      RA_BASE_ARRAY_SIZE_T uiBaseArraySize,
+                                      RA_LENGTH_T uiChunkSize,
+                                      IMG_UINT32 *puiExtractIndices,
+                                      IMG_UINT32 *puiExtractCount)
+{
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 uiExtractCount = *puiExtractCount;
+	*puiExtractCount = 0;
+
+	/* Handle case where we only have 1 base to extract. */
+	if (uiExtractCount == 1)
+	{
+		eError = _ConvertAndFreeBaseArraySlice(pArena,
+		                                      aBaseArray,
+		                                      uiBaseArraySize,
+		                                      uiChunkSize,
+		                                      puiExtractIndices[0],
+		                                      1,
+		                                      CONVERT_DONT_FREE);
+		PVR_LOG_IF_ERROR(eError, "_ConvertAndFreeBaseArraySlice");
+		if (eError == PVRSRV_OK)
+		{
+			*puiExtractCount = uiExtractCount;
+		}
+		return eError;
+	}
+
+	for (i = 0; i < uiExtractCount;)
+	{
+		IMG_UINT32 j;
+		IMG_UINT32 uiConsolidate = 1;
+
+		PVR_ASSERT(RA_BASE_IS_REAL(aBaseArray[i]));
+
+		for (j = i;
+		     puiExtractIndices[j + 1] == puiExtractIndices[j] + 1 &&
+		     RA_BASE_IS_GHOST(aBaseArray[puiExtractIndices[j + 1]]) &&
+		     j + 1 < uiExtractCount;
+		     j++)
+		{
+			uiConsolidate++;
+		}
+
+		eError = _ConvertAndFreeBaseArraySlice(pArena,
+		                                      aBaseArray,
+		                                      uiBaseArraySize,
+		                                      uiChunkSize,
+		                                      puiExtractIndices[i],
+		                                      uiConsolidate,
+		                                      CONVERT_DONT_FREE);
+		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertAndFreeBaseArraySlice");
+
+		i += uiConsolidate;
+		*puiExtractCount += uiConsolidate;
+	}
+
+	return PVRSRV_OK;
+}
+
+IMG_INTERNAL PVRSRV_ERROR
+RA_TransferMultiSparseIndices(RA_ARENA *pArena,
+                              RA_BASE_ARRAY_T aSrcBaseArray,
+                              RA_BASE_ARRAY_SIZE_T uiSrcBaseArraySize,
+                              RA_BASE_ARRAY_T aDstBaseArray,
+                              RA_BASE_ARRAY_SIZE_T uiDstBaseArraySize,
+                              IMG_UINT32 uiLog2ChunkSize,
+                              IMG_UINT32 *puiTransferIndices,
+                              IMG_UINT32 *puiTransferCount)
+{
+	PVRSRV_ERROR eError;
+	IMG_UINT32 i;
+
+	PVR_LOG_RETURN_IF_FALSE(puiTransferCount != NULL,
+		                        "puiTransferCount Required",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+
+	/* Ensure source Base Array is large enough for intended extract */
+	PVR_LOG_RETURN_IF_FALSE(uiSrcBaseArraySize >= *puiTransferCount,
+		                        "Attempt to transfer more bases than src array holds",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+
+	/* Ensure dst Base Array is large enough for intended extract */
+	PVR_LOG_RETURN_IF_FALSE(uiDstBaseArraySize <= *puiTransferCount,
+		                        "Attempt to transfer more bases than dst array holds",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+
+	PVR_LOG_RETURN_IF_FALSE(puiTransferIndices != NULL,
+		                        "puiTransferIndices Required",
+		                        PVRSRV_ERROR_INVALID_PARAMS);
+
+	PVR_LOG_RETURN_IF_FALSE(uiLog2ChunkSize >= RA_BASE_FLAGS_LOG2 &&
+	                        uiLog2ChunkSize <= RA_BASE_CHUNK_LOG2_MAX,
+		                    "Log2 chunk size must be 12-64",
+		                    PVRSRV_ERROR_INVALID_PARAMS);
+
+	OSLockAcquireNested(pArena->hLock, pArena->ui32LockClass);
+	/* First prepare the base array for subsequent transfer */
+	eError = _RA_RealiseMultiSparseIndicesUnlocked(pArena,
+	                                               aSrcBaseArray,
+	                                               uiSrcBaseArraySize,
+	                                               IMG_PAGE2BYTES64(uiLog2ChunkSize),
+	                                               puiTransferIndices,
+	                                               puiTransferCount);
+	OSLockRelease(pArena->hLock);
+	PVR_GOTO_IF_ERROR(eError, e0);
+
+	/* Now do the transfer */
+	for (i=0; i<*puiTransferCount; i++)
+	{
+		IMG_UINT32 idxSrc = puiTransferIndices[i];
+		aDstBaseArray[i] = aSrcBaseArray[idxSrc];
+		aSrcBaseArray[idxSrc] = INVALID_BASE_ADDR;
+	}
+
+	return PVRSRV_OK;
+e0:
+	return eError;
+}
+#endif /* defined(SUPPORT_PMR_PAGES_DEFERRED_FREE) */
+
 static PVRSRV_ERROR
 _TrimBlockMakeReal(RA_ARENA *pArena,
                    RA_BASE_ARRAY_T aBaseArray,
@@ -2917,7 +3421,7 @@ _TrimBlockMakeReal(RA_ARENA *pArena,
 		                                 sRealBase,
 		                                 uiRealBaseIndex,
 		                                 uiStartIndex,
-		                                 1ULL << uiLog2ChunkSize);
+		                                 IMG_PAGE2BYTES64(uiLog2ChunkSize));
 		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
 	}
 
@@ -2935,7 +3439,7 @@ _TrimBlockMakeReal(RA_ARENA *pArena,
 		                                 sRealBase,
 		                                 uiRealBaseIndex,
 		                                 uiEndIndex + 1,
-		                                 1ULL << uiLog2ChunkSize);
+		                                 IMG_PAGE2BYTES64(uiLog2ChunkSize));
 		PVR_LOG_RETURN_IF_ERROR(eError, "_ConvertGhostBaseToReal");
 	}
 
@@ -3195,6 +3699,70 @@ RA_IteratorNext(RA_ARENA_ITERATOR *pIter, RA_ITERATOR_DATA *pData)
 	return IMG_TRUE;
 }
 
+IMG_INTERNAL IMG_BOOL
+RA_IteratorNextSpan(RA_ARENA_ITERATOR *pIter, RA_ITERATOR_DATA *pData)
+{
+	BT *pNext;
+
+	PVR_ASSERT(pIter != NULL);
+
+	if (pIter == NULL)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "pIter in %s() is NULL", __func__));
+		return IMG_FALSE;
+	}
+
+	/* We have no more iterations to perform */
+	if (pIter->pCurrent == NULL)
+	{
+		return IMG_FALSE;
+	}
+
+	pNext = pIter->pCurrent;
+
+	_DBG("(%s()) current segment=%px, size=0x%" IMG_UINT64_FMTSPECx ", "
+	     "type=%u", __func__, (void *) pNext->base, pNext->uSize,
+	     pNext->type);
+
+	/* Extract details of current span */
+	pData->uiAddr = pIter->pCurrent->base;
+	pData->uiSize = pIter->pCurrent->uSize;
+	pData->bFree = pIter->pCurrent->free_import;
+
+	/* If this BT is a full span, can occur if we have no allocations
+	 * on a span.
+	 */
+	if (pNext->is_leftmost == 1 &&
+	    pNext->is_rightmost == 1)
+	{
+		pNext = pNext->pNextSegment;
+	}
+	else
+	{
+		/* combine contiguous segments of span, these are allocations
+		 * and free segments in a span.
+		 */
+		while ((pNext = pNext->pNextSegment) != NULL &&
+		        pNext->is_leftmost == 0)
+		{
+			_DBG("(%s()) combining segment=%px, size=0x%" IMG_UINT64_FMTSPECx ", "
+				 "type=%u", __func__, (void *) pNext->base, pNext->uSize,
+				 pNext->type);
+			pData->uiSize += pNext->uSize;
+		}
+	}
+
+	_DBG("(%s()) next segment=%px, size=0x%" IMG_UINT64_FMTSPECx ", "
+	     "type=%u", __func__,
+	     pNext != NULL ? (void *) pNext->base : NULL,
+	     pNext != NULL ? pNext->uSize : 0,
+	     pNext != NULL ? pNext->type : 0);
+
+	pIter->pCurrent = pNext;
+
+	return IMG_TRUE;
+}
+
 IMG_INTERNAL PVRSRV_ERROR
 RA_BlockDump(RA_ARENA *pArena, void (*pfnLogDump)(void*, IMG_CHAR*, ...), void *pPrivData)
 {
diff --git a/drivers/gpu/drm/img-rogue/ra.h b/drivers/gpu/drm/img-rogue/ra.h
index 654c24d40275..ee4492afa1ed 100644
--- a/drivers/gpu/drm/img-rogue/ra.h
+++ b/drivers/gpu/drm/img-rogue/ra.h
@@ -61,6 +61,9 @@ typedef struct _RA_ARENA_ITERATOR_ RA_ARENA_ITERATOR;
 typedef struct _RA_ITERATOR_DATA_ {
 	IMG_UINT64 uiAddr;
 	IMG_UINT64 uiSize;
+	/* Standard Iteration: is the segment free
+	 * Span Iteration: is the span a free import
+	 */
 	IMG_BOOL bFree;
 } RA_ITERATOR_DATA;
 
@@ -70,7 +73,7 @@ typedef struct _RA_ITERATOR_DATA_ {
 typedef struct _RA_USAGE_STATS {
 	IMG_UINT64	ui64TotalArenaSize;
 	IMG_UINT64	ui64FreeArenaSize;
-}RA_USAGE_STATS, *PRA_USAGE_STATS;
+} RA_USAGE_STATS, *PRA_USAGE_STATS;
 
 /*
  * Per-Arena handle - this is private data for the caller of the RA.
@@ -115,16 +118,7 @@ typedef IMG_UINT32 RA_BASE_ARRAY_SIZE_T;
  * they appear Real from another perspective but we the RA know they are a ghost of the
  * Real Base.
  * */
-#if defined(__GNUC__) && GCC_VERSION_AT_LEAST(9, 0)
-/* Use C99 dynamic arrays, older compilers do not support this. */
-typedef RA_BASE_T RA_BASE_ARRAY_T[];
-#else
-/* Variable length array work around, will contain at least 1 element.
- * Causes errors on newer compilers, in which case use dynamic arrays (see above).
- */
-#define RA_FLEX_ARRAY_ONE_OR_MORE_ELEMENTS 1U
-typedef RA_BASE_T RA_BASE_ARRAY_T[RA_FLEX_ARRAY_ONE_OR_MORE_ELEMENTS];
-#endif
+typedef RA_BASE_T RA_BASE_ARRAY_T[IMG_FLEX_ARRAY_MEMBER];
 
 /* Since 0x0 is a valid BaseAddr, we rely on max 64-bit value to be an invalid
  * page address.
@@ -146,10 +140,13 @@ typedef RA_BASE_T RA_BASE_ARRAY_T[RA_FLEX_ARRAY_ONE_OR_MORE_ELEMENTS];
 
 typedef struct _RA_MULTIBASE_ITERATOR_ RA_MULTIBASE_ITERATOR;
 
-/* Lock classes: describes the level of nesting between different arenas. */
+/* Lock classes: describes the level of nesting between different arenas.
+ * A RA with lockclass x is permitted to obtain locks of a lockclass less than x.
+ * A RA with lockclass 0 cannot obtain the lock of any other RA. */
 #define RA_LOCKCLASS_0 0
 #define RA_LOCKCLASS_1 1
 #define RA_LOCKCLASS_2 2
+#define RA_LOCKCLASS_3 3
 
 #define RA_NO_IMPORT_MULTIPLIER 1
 
@@ -225,38 +222,73 @@ typedef struct _RA_MULTIBASE_ITERATOR_ RA_MULTIBASE_ITERATOR;
  */
 typedef IMG_UINT64 RA_FLAGS_T;
 
+typedef struct _RA_IMPORT_ {
+	RA_BASE_T base;           /* Allocation base */
+	RA_LENGTH_T uSize;        /* Allocation size */
+	RA_PERISPAN_HANDLE hPriv; /* Per import private data */
+} RA_IMPORT;
+
+/*************************************************************************/ /*!
+@Function       Callback function PFN_RA_IMPORT_ALLOC_SINGLE
+@Description    RA import allocate function create a single span when
+                requesting extra resource for the arena.
+@Input          RA_PERARENA_HANDLE RA handle
+@Input          RA_LENGTH_T        Request size
+@Input          RA_FLAGS_T         RA flags
+@Input          RA_LENGTH_T        Base Alignment
+@Input          IMG_CHAR           Annotation
+@Output         RA_IMPORT          Attributes of an import.
+@Return         PVRSRV_ERROR       PVRSRV_OK or error code
+*/ /**************************************************************************/
+typedef PVRSRV_ERROR (*PFN_RA_IMPORT_ALLOC_SINGLE)(RA_PERARENA_HANDLE,
+                                                   RA_LENGTH_T,
+                                                   RA_FLAGS_T,
+                                                   RA_LENGTH_T,
+                                                   const IMG_CHAR*,
+                                                   RA_IMPORT*);
+
 /*************************************************************************/ /*!
-@Function       Callback function PFN_RA_ALLOC
-@Description    RA import allocate function
+@Function       Callback function PFN_RA_IMPORT_ALLOC_MULTI
+@Description    RA import allocate function is able to create multiple spans
+                for a single import request.
+                The pointer to the array of inputs will be provided but
+                can be set to a larger array via OSAllocMem
+                if the count is not large enough.
+                The pointer will be freed by OSFreeMem after the callback.
+                It is permissible for the callback to set:
+                count == 0 or array pointer == NULL
+                but the callback MUST return an error in these cases.
 @Input          RA_PERARENA_HANDLE RA handle
 @Input          RA_LENGTH_T        Request size
 @Input          RA_FLAGS_T         RA flags
 @Input          RA_LENGTH_T        Base Alignment
 @Input          IMG_CHAR           Annotation
-@Input          RA_BASE_T          Allocation base
-@Input          RA_LENGTH_T        Actual size
-@Input          RA_PERISPAN_HANDLE Per import private data
+@Inout          IMG_UINT32         Num of imports = Num of elements in array below.
+                                   Will always be >= 1. Must be set to the number of
+                                   imports returned.
+@Inout          RA_IMPORT          Pointer to array of imports. Will always point
+                                   to an array of equal length as Num of Imports.
+                                   Will be freed by OSFreeMem.
 @Return         PVRSRV_ERROR       PVRSRV_OK or error code
 */ /**************************************************************************/
-typedef PVRSRV_ERROR (*PFN_RA_ALLOC)(RA_PERARENA_HANDLE,
-									 RA_LENGTH_T,
-									 RA_FLAGS_T,
-									 RA_LENGTH_T,
-									 const IMG_CHAR*,
-									 RA_BASE_T*,
-									 RA_LENGTH_T*,
-									 RA_PERISPAN_HANDLE*);
+typedef PVRSRV_ERROR (*PFN_RA_IMPORT_ALLOC_MULTI)(RA_PERARENA_HANDLE,
+                                                  RA_LENGTH_T,
+                                                  RA_FLAGS_T,
+                                                  RA_LENGTH_T,
+                                                  const IMG_CHAR*,
+                                                  IMG_UINT32*,
+                                                  RA_IMPORT**);
 
 /*************************************************************************/ /*!
-@Function       Callback function PFN_RA_FREE
+@Function       Callback function PFN_RA_IMPORT_FREE
 @Description    RA free imported allocation
 @Input          RA_PERARENA_HANDLE   RA handle
 @Input          RA_BASE_T            Allocation base
-@Output         RA_PERISPAN_HANDLE   Per import private data
+@Input          RA_PERISPAN_HANDLE   Per import private data
 */ /**************************************************************************/
-typedef void (*PFN_RA_FREE)(RA_PERARENA_HANDLE,
-							RA_BASE_T,
-							RA_PERISPAN_HANDLE);
+typedef void (*PFN_RA_IMPORT_FREE)(RA_PERARENA_HANDLE,
+                                   RA_BASE_T,
+                                   RA_PERISPAN_HANDLE);
 
 /**
  *  @Function   RA_Create
@@ -277,11 +309,35 @@ RA_Create(IMG_CHAR *name,
           /* subsequent imports: */
           RA_LOG2QUANTUM_T uLog2Quantum,
           IMG_UINT32 ui32LockClass,
-          PFN_RA_ALLOC imp_alloc,
-          PFN_RA_FREE imp_free,
+          PFN_RA_IMPORT_ALLOC_SINGLE imp_alloc,
+          PFN_RA_IMPORT_FREE imp_free,
           RA_PERARENA_HANDLE per_arena_handle,
           RA_POLICY_T ui32PolicyFlags);
 
+/**
+ *  @Function   RA_CreateMulti
+ *
+ *  @Description    To create a resource arena using the
+ *                  ALLOC_MULTI callback.
+ *
+ *  @Input name - the name of the arena for diagnostic purposes.
+ *  @Input uLog2Quantum - the arena allocation quantum.
+ *  @Input ui32LockClass - the lock class level this arena uses.
+ *  @Input imp_alloc - a resource allocation callback or 0.
+ *  @Input imp_free - a resource de-allocation callback or 0.
+ *  @Input arena_handle - private handle passed to alloc and free or 0.
+ *  @Input ui32PolicyFlags - Policies that govern the arena.
+ *  @Return pointer to arena, or NULL.
+ */
+RA_ARENA *
+RA_CreateMulti(IMG_CHAR *name,
+               RA_LOG2QUANTUM_T uLog2Quantum,
+               IMG_UINT32 ui32LockClass,
+               PFN_RA_IMPORT_ALLOC_MULTI imp_alloc,
+               PFN_RA_IMPORT_FREE imp_free,
+               RA_PERARENA_HANDLE arena_handle,
+               RA_POLICY_T ui32PolicyFlags);
+
 /**
  *  @Function   RA_Create_With_Span
  *
@@ -521,6 +577,39 @@ RA_FreeMultiSparse(RA_ARENA *pArena,
                     IMG_UINT32 *puiFreeIndices,
                     IMG_UINT32 *puiFreeCount);
 
+#if defined(SUPPORT_PMR_PAGES_DEFERRED_FREE)
+/**
+ *  @Function   RA_TransferMultiSparseIndices
+ *
+ *  @Description   Transfers a set of indices specified in puiTransferIndices from
+ *                 aSrcBaseArray to aDstBaseArray.
+ *                 Called when some pages of the base array need to be
+ *                 transfered to another base array. As a result of this call,
+ *                 some ghost addresses in aBaseArray might be converted to
+ *                 real addresses before being transferred..
+ *
+ *  @Input  pArena     - The arena the segment was originally allocated from.
+ *  @Input  aSrcBaseArray - The array to transfer bases from.
+ *  @Input  uiSrcBaseArraySize - Size of the array to transfer bases from.
+ *  @Input  aDstBaseArray - The array to transfer bases to.
+ *  @Input  uiDstBaseArraySize - Size of the array to transfer bases to.
+ *  @Input  uiLog2ChunkSize - The log2 chunk size used to generate the Ghost bases.
+ *  @Input  puiTransferIndices - The indices into the array to be extracted.
+ *  @InOut  puiTransferCount - The number of bases to prepare for extraction.
+ *
+ *  @Return PVRSRV_OK - success
+ */
+PVRSRV_ERROR
+RA_TransferMultiSparseIndices(RA_ARENA *pArena,
+                              RA_BASE_ARRAY_T aSrcBaseArray,
+                              RA_BASE_ARRAY_SIZE_T uiSrcBaseArraySize,
+                              RA_BASE_ARRAY_T aDstBaseArray,
+                              RA_BASE_ARRAY_SIZE_T uiDstBaseArraySize,
+                              IMG_UINT32 uiLog2ChunkSize,
+                              IMG_UINT32 *puiTransferIndices,
+                              IMG_UINT32 *puiTransferCount);
+#endif /* defined(SUPPORT_PMR_PAGES_DEFERRED_FREE) */
+
 /**
  *  @Function   RA_Alloc_Range
  *
@@ -623,9 +712,39 @@ RA_IteratorReset(RA_ARENA_ITERATOR *pIter);
 IMG_INTERNAL void
 RA_IteratorRelease(RA_ARENA_ITERATOR *pIter);
 
+/*************************************************************************/ /*!
+@Function       RA_IteratorNext
+@Description    Function used to iterate over segments in the arena. Segments
+                can either be allocated or free. Iteration can be configured
+                to include free segments when creating the iterator via
+                RA_IteratorAcquire.
+
+@Input          pIter        Iteration handle used to keep state between calls
+@InOut          pData        Data about current block iteration, base and size
+                             etc...
+@Return         IMG_BOOL     Boolean value signalling if next element exists
+*/ /**************************************************************************/
 IMG_INTERNAL IMG_BOOL
 RA_IteratorNext(RA_ARENA_ITERATOR *pIter, RA_ITERATOR_DATA *pData);
 
+/*************************************************************************/ /*
+@Function       RA_IteratorNextSpan
+@Description    Function used to iterate over spans in the arena. Spans
+                can either be allocated or free. Iteration can be configured
+                to include free spans when creating the iterator via
+                RA_IteratorAcquire. Spans are not allocations on the arena but
+                instead the regions of resource added that allocations can
+                be made from.
+                See RA_Add().
+
+@Input          pIter        Iteration handle used to keep state between calls
+@InOut          pData        Data about current block iteration, base and size
+                             etc...
+@Return         IMG_BOOL     Boolean value signalling if next element exists
+*/ /**************************************************************************/
+IMG_INTERNAL IMG_BOOL
+RA_IteratorNextSpan(RA_ARENA_ITERATOR *pIter, RA_ITERATOR_DATA *pData);
+
 /*************************************************************************/ /*!
 @Function       RA_BlockDump
 @Description    Debug dump of all memory allocations within the RA and the space
diff --git a/drivers/gpu/drm/img-rogue/rgx_bridge.h b/drivers/gpu/drm/img-rogue/rgx_bridge.h
index af6d0af25238..5168f6f23ea5 100644
--- a/drivers/gpu/drm/img-rogue/rgx_bridge.h
+++ b/drivers/gpu/drm/img-rogue/rgx_bridge.h
@@ -50,8 +50,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 extern "C" {
 #endif
 
-#include "rgx_fwif_km.h"
-
 #define RGXFWINITPARAMS_VERSION   1
 #define RGXFWINITPARAMS_EXTENSION 128
 
diff --git a/drivers/gpu/drm/img-rogue/rgx_bridge_init.c b/drivers/gpu/drm/img-rogue/rgx_bridge_init.c
index 5ab1a0a2f778..1de4f08dd2b6 100644
--- a/drivers/gpu/drm/img-rogue/rgx_bridge_init.c
+++ b/drivers/gpu/drm/img-rogue/rgx_bridge_init.c
@@ -55,51 +55,112 @@ PVRSRV_ERROR InitRGXRAYBridge(void);
 void DeinitRGXRAYBridge(void);
 #endif
 
-PVRSRV_ERROR DeviceDepBridgeInit(PVRSRV_RGXDEV_INFO *psDevInfo)
+/* Reference counts for device-conditional
+ * bridges. This ensures that bridges remain
+ * valid while there are still devices using
+ * them.
+ */
+static ATOMIC_T i32RGXCMPBridgeRefCt;
+static ATOMIC_T i32RGXTQ2BridgeRefCt;
+#if defined(SUPPORT_RGXRAY_BRIDGE)
+static ATOMIC_T i32RGXRayBridgeRefCt;
+#endif
+static IMG_BOOL bAtomicsInitialised = IMG_FALSE;
+
+void RGXBridgeDriverInit(void)
+{
+	if (!bAtomicsInitialised)
+	{
+		bAtomicsInitialised = IMG_TRUE;
+		OSAtomicWrite(&i32RGXCMPBridgeRefCt, 0);
+		OSAtomicWrite(&i32RGXTQ2BridgeRefCt, 0);
+#if defined(SUPPORT_RGXRAY_BRIDGE)
+		OSAtomicWrite(&i32RGXRayBridgeRefCt, 0);
+#endif
+	}
+}
+
+PVRSRV_ERROR RGXRegisterBridges(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	PVRSRV_ERROR eError;
 
+	if (!bAtomicsInitialised)
+	{
+		eError = PVRSRV_ERROR_NOT_INITIALISED;
+		PVR_LOG_RETURN_IF_ERROR(eError, "RGXBridgeRefCts");
+	}
+
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, COMPUTE))
 	{
-		eError = InitRGXCMPBridge();
-		PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXCMPBridge");
+		if (OSAtomicIncrement(&i32RGXCMPBridgeRefCt) == 1)
+		{
+			eError = InitRGXCMPBridge();
+			if (eError != PVRSRV_OK)
+			{
+				OSAtomicDecrement(&i32RGXCMPBridgeRefCt);
+			}
+			PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXCMPBridge");
+		}
 	}
 
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, FASTRENDER_DM))
 	{
-		eError = InitRGXTQ2Bridge();
-		PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXTQ2Bridge");
+		if (OSAtomicIncrement(&i32RGXTQ2BridgeRefCt) == 1)
+		{
+			eError = InitRGXTQ2Bridge();
+			if (eError != PVRSRV_OK)
+			{
+				OSAtomicDecrement(&i32RGXTQ2BridgeRefCt);
+			}
+			PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXTQ2Bridge");
+		}
 	}
 
 #if defined(SUPPORT_RGXRAY_BRIDGE)
 	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, RAY_TRACING_ARCH) &&
 		RGX_GET_FEATURE_VALUE(psDevInfo, RAY_TRACING_ARCH) > 0)
 	{
-		eError = InitRGXRAYBridge();
-		PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXRAYBridge");
+		if (OSAtomicIncrement(&i32RGXRayBridgeRefCt) == 1)
+		{
+			eError = InitRGXRAYBridge();
+			if (eError != PVRSRV_OK)
+			{
+				OSAtomicDecrement(&i32RGXRayBridgeRefCt);
+			}
+			PVR_LOG_RETURN_IF_ERROR(eError, "InitRGXRAYBridge");
+		}
 	}
 #endif
 
 	return PVRSRV_OK;
 }
 
-void DeviceDepBridgeDeInit(PVRSRV_RGXDEV_INFO *psDevInfo)
+void RGXUnregisterBridges(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, COMPUTE))
 	{
-		DeinitRGXCMPBridge();
+		if (OSAtomicDecrement(&i32RGXCMPBridgeRefCt) == 0)
+		{
+			DeinitRGXCMPBridge();
+		}
 	}
 
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, FASTRENDER_DM))
 	{
-		DeinitRGXTQ2Bridge();
+		if (OSAtomicDecrement(&i32RGXTQ2BridgeRefCt) == 0)
+		{
+			DeinitRGXTQ2Bridge();
+		}
 	}
 
 #if defined(SUPPORT_RGXRAY_BRIDGE)
 	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, RAY_TRACING_ARCH) &&
 		RGX_GET_FEATURE_VALUE(psDevInfo, RAY_TRACING_ARCH) > 0)
 	{
-		DeinitRGXRAYBridge();
+		if (OSAtomicDecrement(&i32RGXRayBridgeRefCt) == 0)
+		{
+			DeinitRGXRAYBridge();
+		}
 	}
 #endif
 }
diff --git a/drivers/gpu/drm/img-rogue/rgx_bridge_init.h b/drivers/gpu/drm/img-rogue/rgx_bridge_init.h
index 10e8e72ca095..8622848b51b1 100644
--- a/drivers/gpu/drm/img-rogue/rgx_bridge_init.h
+++ b/drivers/gpu/drm/img-rogue/rgx_bridge_init.h
@@ -49,7 +49,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "device.h"
 #include "rgxdevice.h"
 
-PVRSRV_ERROR DeviceDepBridgeInit(PVRSRV_RGXDEV_INFO *psDevInfo);
-void DeviceDepBridgeDeInit(PVRSRV_RGXDEV_INFO *psDevInfo);
+void RGXBridgeDriverInit(void);
+PVRSRV_ERROR RGXRegisterBridges(PVRSRV_RGXDEV_INFO *psDevInfo);
+void RGXUnregisterBridges(PVRSRV_RGXDEV_INFO *psDevInfo);
 
 #endif /* RGX_BRIDGE_INIT_H */
diff --git a/drivers/gpu/drm/img-rogue/rgx_common.h b/drivers/gpu/drm/img-rogue/rgx_common.h
index 6a79b9bfdba7..55b0ed450e1c 100644
--- a/drivers/gpu/drm/img-rogue/rgx_common.h
+++ b/drivers/gpu/drm/img-rogue/rgx_common.h
@@ -54,6 +54,10 @@ extern "C" {
 
 #include "rgx_common_asserts.h"
 
+typedef struct RGXFWIF_DEV_VIRTADDR_
+{
+	IMG_UINT32	ui32Addr;
+} RGXFWIF_DEV_VIRTADDR;
 
 /* Virtualisation validation builds are meant to test the VZ-related hardware without a fully virtualised platform.
  * As such a driver can support either the vz-validation code or real virtualisation. */
@@ -68,6 +72,19 @@ extern "C" {
 #error "Both RGX_FEATURE_TLA and RGX_FEATURE_FASTRENDER_DM defined. Fix code to handle this!"
 #endif
 
+#define FW_OSID							(0U)
+#define MMU_CONTEXT_MAPPING_FWPRIV		(0U) /* FW code/private data */
+
+#if (RGX_FW_HEAP_OSID_ASSIGNMENT == RGX_FW_HEAP_USES_FIRMWARE_OSID) || defined(RGX_FEATURE_MIPS)
+/* The Firmware accesses its private code & data and the interface
+ * memory it shares with the KM drivers using the same MMU context */
+#define MMU_CONTEXT_MAPPING_FWIF		MMU_CONTEXT_MAPPING_FWPRIV
+#else
+/* The Firmware accesses the interface memory it shares
+ * with the KM drivers using a reserved MMU context */
+#define MMU_CONTEXT_MAPPING_FWIF		(7U)
+#endif
+
 /*! The master definition for data masters known to the firmware of RGX.
  * When a new DM is added to this list, relevant entry should be added to
  * RGX_HWPERF_DM enum list.
@@ -105,6 +122,8 @@ typedef IMG_UINT32 RGX_KICK_TYPE_DM;
 
 /* Maximum number of DM in use: GP, 2D/TDM, GEOM, 3D, CDM, RDM, GEOM2, GEOM3, GEOM4 */
 #define RGXFWIF_DM_MAX			(RGXFWIF_DM_LAST + 1U)
+/* The set of DMs for gathering stats on GPU utilisation excludes GP */
+#define RGXFWIF_GPU_UTIL_DM_MAX (RGXFWIF_DM_MAX - 1U)
 
 /*
  * Data Master Tags to be appended to resources created on behalf of each RGX
@@ -176,7 +195,13 @@ typedef IMG_UINT32 RGX_KICK_TYPE_DM;
 #define RGXFWIF_GPU_UTIL_STATE_ACTIVE    (1U)
 #define RGXFWIF_GPU_UTIL_STATE_BLOCKED   (2U)
 #define RGXFWIF_GPU_UTIL_STATE_NUM       (3U)
+/* the state below "combines" IDLE and BLOCKED
+ * and is used when we only care about GPU being in ACTIVE or not */
+#define RGXFWIF_GPU_UTIL_STATE_INACTIVE  (0U)
+/* when we combine IDLE and BLOCKED we end up with one state less */
+#define RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM       (RGXFWIF_GPU_UTIL_STATE_NUM-1U)
 #define RGXFWIF_GPU_UTIL_STATE_MASK      IMG_UINT64_C(0x0000000000000003)
+#define RGXFWIF_GPU_UTIL_STATE_MASK32    IMG_UINT32_C(0x00000003)
 
 
 /*
@@ -184,7 +209,7 @@ typedef IMG_UINT32 RGX_KICK_TYPE_DM;
  * programmer (FW or META DMA). This is not a HW limitation, it is only
  * a protection against malformed inputs to the register programmer.
  */
-#define RGX_MAX_NUM_REGISTER_PROGRAMMER_WRITES  (128U)
+#define RGX_MAX_NUM_REGISTER_PROGRAMMER_WRITES  (256U)
 
 /* FW common context priority. */
 /*!
@@ -221,6 +246,11 @@ typedef IMG_UINT32 RGX_KICK_TYPE_DM;
 typedef IMG_UINT32 RGX_CONTEXT_PROPERTY;
 #define RGX_CONTEXT_PROPERTY_FLAGS 0U /*!< Context flags */
 
+/* MMU4 supported number of ranges */
+#define RGX_MAX_NUM_MMU_PAGE_SIZE_RANGES (4U)
+#define RGX_MMU_RANGE_NON4KHEAP          (0U)
+#define RGX_MMU_RANGE_GLOBAL             (RGX_MAX_NUM_MMU_PAGE_SIZE_RANGES - 1)
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/drivers/gpu/drm/img-rogue/rgx_firmware_boot.h b/drivers/gpu/drm/img-rogue/rgx_firmware_boot.h
new file mode 100644
index 000000000000..b0a14683e1a3
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/rgx_firmware_boot.h
@@ -0,0 +1,91 @@
+/**************************************************************************/ /*!
+@File
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /***************************************************************************/
+
+#ifndef RGX_FIRMWARE_BOOT_H
+#define RGX_FIRMWARE_BOOT_H
+
+#include "img_types.h"
+#include "rgx_common.h"
+#include "powervr/mem_types.h"
+
+#define TD_MAX_NUM_MIPS_PAGETABLE_PAGES (4U)
+
+typedef union _PVRSRV_FW_BOOT_PARAMS_
+{
+	struct
+	{
+		IMG_DEV_VIRTADDR sFWCodeDevVAddr;
+		IMG_DEV_VIRTADDR sFWDataDevVAddr;
+		IMG_DEV_VIRTADDR sFWCorememCodeDevVAddr;
+		RGXFWIF_DEV_VIRTADDR sFWCorememCodeFWAddr;
+		IMG_DEVMEM_SIZE_T uiFWCorememCodeSize;
+		IMG_DEV_VIRTADDR sFWCorememDataDevVAddr;
+		RGXFWIF_DEV_VIRTADDR sFWCorememDataFWAddr;
+		IMG_UINT32 ui32NumThreads;
+	} sMeta;
+
+	struct
+	{
+		IMG_DEV_PHYADDR sGPURegAddr;
+		IMG_DEV_PHYADDR asFWPageTableAddr[TD_MAX_NUM_MIPS_PAGETABLE_PAGES];
+		IMG_DEV_PHYADDR sFWStackAddr;
+		IMG_UINT32 ui32FWPageTableLog2PageSize;
+		IMG_UINT32 ui32FWPageTableNumPages;
+	} sMips;
+
+	struct
+	{
+		IMG_DEV_VIRTADDR sFWCodeDevVAddr;
+		IMG_DEV_VIRTADDR sFWDataDevVAddr;
+
+		IMG_DEV_VIRTADDR sFWCorememCodeDevVAddr;
+		RGXFWIF_DEV_VIRTADDR sFWCorememCodeFWAddr;
+		IMG_DEVMEM_SIZE_T uiFWCorememCodeSize;
+
+		IMG_DEV_VIRTADDR sFWCorememDataDevVAddr;
+		RGXFWIF_DEV_VIRTADDR sFWCorememDataFWAddr;
+		IMG_DEVMEM_SIZE_T uiFWCorememDataSize;
+	} sRISCV;
+
+} PVRSRV_FW_BOOT_PARAMS;
+
+
+#endif /* RGX_FIRMWARE_BOOT_H */
diff --git a/drivers/gpu/drm/img-rogue/rgx_fwif_alignchecks.h b/drivers/gpu/drm/img-rogue/rgx_fwif_alignchecks.h
index 84a916a51888..a33b6d541c65 100644
--- a/drivers/gpu/drm/img-rogue/rgx_fwif_alignchecks.h
+++ b/drivers/gpu/drm/img-rogue/rgx_fwif_alignchecks.h
@@ -159,7 +159,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 		offsetof(RGXFWIF_SYSINIT, sFaultPhysAddr),                   \
 		offsetof(RGXFWIF_SYSINIT, sPDSExecBase),                     \
 		offsetof(RGXFWIF_SYSINIT, sUSCExecBase),                     \
-		offsetof(RGXFWIF_SYSINIT, asSigBufCtl),                      \
+		offsetof(RGXFWIF_SYSINIT, aui32TPUTrilinearFracMask),        \
 		offsetof(RGXFWIF_SYSINIT, sTraceBufCtl),                     \
 		offsetof(RGXFWIF_SYSINIT, sFwSysData),                       \
 		(IMG_UINT32)sizeof(RGXFWIF_OSINIT),                                      \
diff --git a/drivers/gpu/drm/img-rogue/rgx_fwif_km.h b/drivers/gpu/drm/img-rogue/rgx_fwif_km.h
index 8612383519e2..22da7ec4cc9d 100644
--- a/drivers/gpu/drm/img-rogue/rgx_fwif_km.h
+++ b/drivers/gpu/drm/img-rogue/rgx_fwif_km.h
@@ -52,82 +52,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgx_mips.h"
 #include "rgxheapconfig.h"
 
-
-/*************************************************************************/ /*!
- Logging type
-*/ /**************************************************************************/
-#define RGXFWIF_LOG_TYPE_NONE			0x00000000U
-#define RGXFWIF_LOG_TYPE_TRACE			0x00000001U
-#define RGXFWIF_LOG_TYPE_GROUP_MAIN		0x00000002U
-#define RGXFWIF_LOG_TYPE_GROUP_MTS		0x00000004U
-#define RGXFWIF_LOG_TYPE_GROUP_CLEANUP	0x00000008U
-#define RGXFWIF_LOG_TYPE_GROUP_CSW		0x00000010U
-#define RGXFWIF_LOG_TYPE_GROUP_BIF		0x00000020U
-#define RGXFWIF_LOG_TYPE_GROUP_PM		0x00000040U
-#define RGXFWIF_LOG_TYPE_GROUP_RTD		0x00000080U
-#define RGXFWIF_LOG_TYPE_GROUP_SPM		0x00000100U
-#define RGXFWIF_LOG_TYPE_GROUP_POW		0x00000200U
-#define RGXFWIF_LOG_TYPE_GROUP_HWR		0x00000400U
-#define RGXFWIF_LOG_TYPE_GROUP_HWP		0x00000800U
-#define RGXFWIF_LOG_TYPE_GROUP_RPM		0x00001000U
-#define RGXFWIF_LOG_TYPE_GROUP_DMA		0x00002000U
-#define RGXFWIF_LOG_TYPE_GROUP_MISC		0x00004000U
-#define RGXFWIF_LOG_TYPE_GROUP_DEBUG	0x80000000U
-#define RGXFWIF_LOG_TYPE_GROUP_MASK		0x80007FFEU
-#define RGXFWIF_LOG_TYPE_MASK			0x80007FFFU
-
-/* String used in pvrdebug -h output */
-#define RGXFWIF_LOG_GROUPS_STRING_LIST   "main,mts,cleanup,csw,bif,pm,rtd,spm,pow,hwr,hwp,rpm,dma,misc,debug"
-
-/* Table entry to map log group strings to log type value */
-typedef struct {
-	const IMG_CHAR* pszLogGroupName;
-	IMG_UINT32      ui32LogGroupType;
-} RGXFWIF_LOG_GROUP_MAP_ENTRY;
-
-/*
-  Macro for use with the RGXFWIF_LOG_GROUP_MAP_ENTRY type to create a lookup
-  table where needed. Keep log group names short, no more than 20 chars.
-*/
-#define RGXFWIF_LOG_GROUP_NAME_VALUE_MAP { "none",    RGXFWIF_LOG_TYPE_NONE }, \
-                                         { "main",    RGXFWIF_LOG_TYPE_GROUP_MAIN }, \
-                                         { "mts",     RGXFWIF_LOG_TYPE_GROUP_MTS }, \
-                                         { "cleanup", RGXFWIF_LOG_TYPE_GROUP_CLEANUP }, \
-                                         { "csw",     RGXFWIF_LOG_TYPE_GROUP_CSW }, \
-                                         { "bif",     RGXFWIF_LOG_TYPE_GROUP_BIF }, \
-                                         { "pm",      RGXFWIF_LOG_TYPE_GROUP_PM }, \
-                                         { "rtd",     RGXFWIF_LOG_TYPE_GROUP_RTD }, \
-                                         { "spm",     RGXFWIF_LOG_TYPE_GROUP_SPM }, \
-                                         { "pow",     RGXFWIF_LOG_TYPE_GROUP_POW }, \
-                                         { "hwr",     RGXFWIF_LOG_TYPE_GROUP_HWR }, \
-                                         { "hwp",     RGXFWIF_LOG_TYPE_GROUP_HWP }, \
-                                         { "rpm",     RGXFWIF_LOG_TYPE_GROUP_RPM }, \
-                                         { "dma",     RGXFWIF_LOG_TYPE_GROUP_DMA }, \
-                                         { "misc",    RGXFWIF_LOG_TYPE_GROUP_MISC }, \
-                                         { "debug",   RGXFWIF_LOG_TYPE_GROUP_DEBUG }
-
-
-/* Used in print statements to display log group state, one %s per group defined */
-#define RGXFWIF_LOG_ENABLED_GROUPS_LIST_PFSPEC  "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"
-
-/* Used in a print statement to display log group state, one per group */
-#define RGXFWIF_LOG_ENABLED_GROUPS_LIST(types)  ((((types) & RGXFWIF_LOG_TYPE_GROUP_MAIN) != 0U)	?("main ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_MTS) != 0U)		?("mts ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_CLEANUP) != 0U)	?("cleanup ")	:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_CSW) != 0U)		?("csw ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_BIF) != 0U)		?("bif ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_PM) != 0U)		?("pm ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_RTD) != 0U)		?("rtd ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_SPM) != 0U)		?("spm ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_POW) != 0U)		?("pow ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_HWR) != 0U)		?("hwr ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_HWP) != 0U)		?("hwp ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_RPM) != 0U)		?("rpm ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_DMA) != 0U)		?("dma ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_MISC) != 0U)	?("misc ")		:("")),		\
-                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_DEBUG) != 0U)	?("debug ")		:(""))
-
-
 /************************************************************************
 * RGX FW signature checks
 ************************************************************************/
@@ -135,104 +59,8 @@ typedef struct {
 
 #define RGXFWIF_TIMEDIFF_ID			((0x1UL << 28) | RGX_CR_TIMER)
 
-/*!
- ******************************************************************************
- * Trace Buffer
- *****************************************************************************/
-
-/*! Min, Max, and Default size of RGXFWIF_TRACEBUF_SPACE in DWords */
-#define RGXFW_TRACE_BUF_MIN_SIZE_IN_DWORDS      8192U  /*  32KB */
-#define RGXFW_TRACE_BUF_DEFAULT_SIZE_IN_DWORDS 12000U  /* ~48KB */
-#define RGXFW_TRACE_BUF_MAX_SIZE_IN_DWORDS     32768U  /* 128KB */
-
-#define RGXFW_TRACE_BUFFER_ASSERT_SIZE 200U
-#if defined(RGXFW_META_SUPPORT_2ND_THREAD)
-#define RGXFW_THREAD_NUM 2U
-#else
-#define RGXFW_THREAD_NUM 1U
-#endif
-
 #define RGXFW_POLL_TYPE_SET 0x80000000U
 
-#define RGXFW_PROCESS_NAME_LEN	(16)
-
-typedef struct
-{
-	IMG_CHAR	szPath[RGXFW_TRACE_BUFFER_ASSERT_SIZE];
-	IMG_CHAR	szInfo[RGXFW_TRACE_BUFFER_ASSERT_SIZE];
-	IMG_UINT32	ui32LineNum;
-} UNCACHED_ALIGN RGXFWIF_FILE_INFO_BUF;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_FILE_INFO_BUF) == 408,
-				"RGXFWIF_FILE_INFO_BUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*!
- * @Defgroup SRVAndFWTracing Services and Firmware Tracing data interface
- * @Brief The document groups/lists the data structures and the interfaces related to Services and Firmware Tracing
- * @{
- */
-
-/*!
- * @Brief Firmware trace buffer details
- */
-typedef struct
-{
-	IMG_UINT32                         ui32TracePointer;          /*!< Trace pointer (write index into Trace Buffer) */
-	IMG_UINT32                         ui32WrapCount;             /*!< Number of times the Trace Buffer has wrapped */
-
-	RGXFWIF_DEV_VIRTADDR               pui32RGXFWIfTraceBuffer;   /*!< Trace buffer address (FW address), to be used by firmware for writing into trace buffer */
-
-	RGXFWIF_FILE_INFO_BUF RGXFW_ALIGN  sAssertBuf;
-} UNCACHED_ALIGN RGXFWIF_TRACEBUF_SPACE;
-
-/*! @} End of Defgroup SRVAndFWTracing */
-
-#define RGXFWIF_FWFAULTINFO_MAX		(8U)			/* Total number of FW fault logs stored */
-
-typedef struct
-{
-	IMG_UINT64 RGXFW_ALIGN	ui64CRTimer;
-	IMG_UINT64 RGXFW_ALIGN	ui64OSTimer;
-	IMG_UINT64 RGXFW_ALIGN	ui64Data;
-	RGXFWIF_FILE_INFO_BUF	sFaultBuf;
-} UNCACHED_ALIGN RGX_FWFAULTINFO;
-
-
-#define RGXFWIF_POW_STATES \
-  X(RGXFWIF_POW_OFF)			/* idle and handshaked with the host (ready to full power down) */ \
-  X(RGXFWIF_POW_ON)				/* running HW commands */ \
-  X(RGXFWIF_POW_FORCED_IDLE)	/* forced idle */ \
-  X(RGXFWIF_POW_IDLE)			/* idle waiting for host handshake */
-
-typedef enum
-{
-#define X(NAME) NAME,
-	RGXFWIF_POW_STATES
-#undef X
-} RGXFWIF_POW_STATE;
-
-/* Firmware HWR states */
-#define RGXFWIF_HWR_HARDWARE_OK			(IMG_UINT32_C(0x1) << 0U)	/*!< The HW state is ok or locked up */
-#define RGXFWIF_HWR_RESET_IN_PROGRESS	(IMG_UINT32_C(0x1) << 1U)	/*!< Tells if a HWR reset is in progress */
-#define RGXFWIF_HWR_GENERAL_LOCKUP		(IMG_UINT32_C(0x1) << 3U)	/*!< A DM unrelated lockup has been detected */
-#define RGXFWIF_HWR_DM_RUNNING_OK		(IMG_UINT32_C(0x1) << 4U)	/*!< At least one DM is running without being close to a lockup */
-#define RGXFWIF_HWR_DM_STALLING			(IMG_UINT32_C(0x1) << 5U)	/*!< At least one DM is close to lockup */
-#define RGXFWIF_HWR_FW_FAULT			(IMG_UINT32_C(0x1) << 6U)	/*!< The FW has faulted and needs to restart */
-#define RGXFWIF_HWR_RESTART_REQUESTED	(IMG_UINT32_C(0x1) << 7U)	/*!< The FW has requested the host to restart it */
-
-#define RGXFWIF_PHR_STATE_SHIFT			(8U)
-#define RGXFWIF_PHR_RESTART_REQUESTED	(IMG_UINT32_C(1) << RGXFWIF_PHR_STATE_SHIFT)	/*!< The FW has requested the host to restart it, per PHR configuration */
-#define RGXFWIF_PHR_RESTART_FINISHED	(IMG_UINT32_C(2) << RGXFWIF_PHR_STATE_SHIFT)	/*!< A PHR triggered GPU reset has just finished */
-#define RGXFWIF_PHR_RESTART_MASK		(RGXFWIF_PHR_RESTART_REQUESTED | RGXFWIF_PHR_RESTART_FINISHED)
-
-#define RGXFWIF_PHR_MODE_OFF			(0UL)
-#define RGXFWIF_PHR_MODE_RD_RESET		(1UL)
-#define RGXFWIF_PHR_MODE_FULL_RESET		(2UL)
-
-typedef IMG_UINT32 RGXFWIF_HWR_STATEFLAGS;
-
 /* Firmware per-DM HWR states */
 #define RGXFWIF_DM_STATE_WORKING					(0x00U)		/*!< DM is working if all flags are cleared */
 #define RGXFWIF_DM_STATE_READY_FOR_HWR				(IMG_UINT32_C(0x1) << 0)	/*!< DM is idle and ready for HWR */
@@ -245,15 +73,22 @@ typedef IMG_UINT32 RGXFWIF_HWR_STATEFLAGS;
 #define RGXFWIF_DM_STATE_INNOCENT_OVERRUNING		(IMG_UINT32_C(0x1) << 8)	/*!< DM was innocently affected by another DM over-running which caused HWR */
 #define RGXFWIF_DM_STATE_HARD_CONTEXT_SWITCH		(IMG_UINT32_C(0x1) << 9)	/*!< DM was forced into HWR as it delayed more important workloads */
 #define RGXFWIF_DM_STATE_GPU_ECC_HWR				(IMG_UINT32_C(0x1) << 10)	/*!< DM was forced into HWR due to an uncorrected GPU ECC error */
+#define RGXFWIF_DM_STATE_GPU_PARITY_HWR				(IMG_UINT32_C(0x1) << 11)	/*!< DM was forced into HWR due to an uncorrected GPU PARITY error */
+#define RGXFWIF_DM_STATE_GPU_LATENT_HWR				(IMG_UINT32_C(0x1) << 12)	/*!< DM was forced into HWR due to an uncorrected GPU LATENT error */
+
 
 /* Firmware's connection state */
 typedef IMG_UINT32 RGXFWIF_CONNECTION_FW_STATE;
-#define RGXFW_CONNECTION_FW_OFFLINE		0U	/*!< Firmware is offline */
-#define RGXFW_CONNECTION_FW_READY		1U	/*!< Firmware is initialised */
-#define RGXFW_CONNECTION_FW_ACTIVE		2U	/*!< Firmware connection is fully established */
-#define RGXFW_CONNECTION_FW_OFFLOADING	3U	/*!< Firmware is clearing up connection data */
-#define RGXFW_CONNECTION_FW_COOLDOWN	4U	/*!< Firmware connection is in cooldown period */
-#define RGXFW_CONNECTION_FW_STATE_COUNT	5U
+#define RGXFW_CONNECTION_FW_OFFLINE				0U	/*!< Firmware is offline */
+#define RGXFW_CONNECTION_FW_READY				1U	/*!< Firmware is initialised */
+#define RGXFW_CONNECTION_FW_ACTIVE				2U	/*!< Firmware connection is fully established */
+#define RGXFW_CONNECTION_FW_GRACEFUL_OFFLOAD	3U	/*!< Firmware is clearing up connection data */
+#define RGXFW_CONNECTION_FW_FORCED_OFFLOAD		4U	/*!< Firmware is clearing up connection data */
+#define RGXFW_CONNECTION_FW_COOLDOWN			5U	/*!< Firmware connection is in cooldown period */
+#define RGXFW_CONNECTION_FW_STATE_COUNT			6U
+
+#define RGXFW_FORCED_OFFLOAD_HCS_DEADLINE_MS	2U		/*!< Workloads of Guest being forcefully offloaded must be stopped quickly */
+#define RGXFW_GRACEFUL_OFFLOAD_HCS_DEADLINE_MS	1000U	/*!< Workloads of Guest being gracefully offloaded are allowed more time to finish */
 
 /* OS' connection state */
 typedef enum
@@ -264,322 +99,11 @@ typedef enum
 	RGXFW_CONNECTION_OS_STATE_COUNT
 } RGXFWIF_CONNECTION_OS_STATE;
 
-typedef struct
-{
-	IMG_UINT			bfOsState		: 3;
-	IMG_UINT			bfFLOk			: 1;
-	IMG_UINT			bfFLGrowPending	: 1;
-	IMG_UINT			bfReserved		: 27;
-} RGXFWIF_OS_RUNTIME_FLAGS;
-
-typedef IMG_UINT32 RGXFWIF_HWR_RECOVERYFLAGS;
-
-#if defined(PVRSRV_STALLED_CCB_ACTION)
-#define PVR_SLR_LOG_ENTRIES 10U
-#define PVR_SLR_LOG_STRLEN  30 /*!< MAX_CLIENT_CCB_NAME not visible to this header */
-
-typedef struct
-{
-	IMG_UINT64 RGXFW_ALIGN	ui64Timestamp;
-	IMG_UINT32				ui32FWCtxAddr;
-	IMG_UINT32				ui32NumUFOs;
-	IMG_CHAR				aszCCBName[PVR_SLR_LOG_STRLEN];
-} UNCACHED_ALIGN RGXFWIF_SLR_ENTRY;
-#endif
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-#define MAX_THREAD_NUM 2
-
-static_assert(RGXFW_THREAD_NUM <= MAX_THREAD_NUM,
-				"RGXFW_THREAD_NUM is outside of allowable range for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*!
- * @InGroup SRVAndFWTracing
- * @Brief Firmware trace control data
- */
-typedef struct
-{
-	IMG_UINT32              ui32LogType;                  /*!< FW trace log group configuration */
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	RGXFWIF_TRACEBUF_SPACE  sTraceBuf[MAX_THREAD_NUM];  /*!< FW Trace buffer */
-#else
-	RGXFWIF_TRACEBUF_SPACE  sTraceBuf[RGXFW_THREAD_NUM];  /*!< FW Trace buffer */
-#endif
-	IMG_UINT32              ui32TraceBufSizeInDWords;     /*!< FW Trace buffer size in dwords, Member initialised only when sTraceBuf is actually allocated
-															(in RGXTraceBufferInitOnDemandResources) */
-	IMG_UINT32              ui32TracebufFlags;            /*!< Compatibility and other flags */
-} UNCACHED_ALIGN RGXFWIF_TRACEBUF;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_TRACEBUF) == 880,
-				"RGXFWIF_TRACEBUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*! @Brief Firmware system data shared with the Host driver */
-typedef struct
-{
-	IMG_UINT32                 ui32ConfigFlags;                       /*!< Configuration flags from host */
-	IMG_UINT32                 ui32ConfigFlagsExt;                    /*!< Extended configuration flags from host */
-	volatile RGXFWIF_POW_STATE ePowState;
-	struct {
-		volatile IMG_UINT32        ui32HWPerfRIdx;
-		volatile IMG_UINT32        ui32HWPerfWIdx;
-		volatile IMG_UINT32        ui32HWPerfWrapCount;
-	} sHWPerfCtrl; /* Struct used to inval/flush HWPerfCtrl members */
-	IMG_UINT32                 ui32HWPerfSize;                        /*!< Constant after setup, needed in FW */
-	IMG_UINT32                 ui32HWPerfDropCount;                   /*!< The number of times the FW drops a packet due to buffer full */
-
-	/* ui32HWPerfUt, ui32FirstDropOrdinal, ui32LastDropOrdinal only valid when FW is built with
-	 * RGX_HWPERF_UTILIZATION & RGX_HWPERF_DROP_TRACKING defined in rgxfw_hwperf.c */
-	IMG_UINT32                 ui32HWPerfUt;                          /*!< Buffer utilisation, high watermark of bytes in use */
-	IMG_UINT32                 ui32FirstDropOrdinal;                  /*!< The ordinal of the first packet the FW dropped */
-	IMG_UINT32                 ui32LastDropOrdinal;                   /*!< The ordinal of the last packet the FW dropped */
-	RGXFWIF_OS_RUNTIME_FLAGS   asOsRuntimeFlagsMirror[RGXFW_MAX_NUM_OSIDS];/*!< State flags for each Operating System mirrored from Fw coremem */
-	RGX_FWFAULTINFO            sFaultInfo[RGXFWIF_FWFAULTINFO_MAX];   /*!< Firmware fault info */
-	IMG_UINT32                 ui32FWFaults;                          /*!< Firmware faults count */
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_UINT32                 aui32CrPollAddr[MAX_THREAD_NUM];     /*!< Failed poll address */
-	IMG_UINT32                 aui32CrPollMask[MAX_THREAD_NUM];     /*!< Failed poll mask */
-	IMG_UINT32                 aui32CrPollCount[MAX_THREAD_NUM];    /*!< Failed poll count */
-#else
-	IMG_UINT32                 aui32CrPollAddr[RGXFW_THREAD_NUM];     /*!< Failed poll address */
-	IMG_UINT32                 aui32CrPollMask[RGXFW_THREAD_NUM];     /*!< Failed poll mask */
-	IMG_UINT32                 aui32CrPollCount[RGXFW_THREAD_NUM];    /*!< Failed poll count */
-#endif
-	IMG_UINT64 RGXFW_ALIGN     ui64StartIdleTime;
-
-#if defined(SUPPORT_RGXFW_STATS_FRAMEWORK) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-#define RGXFWIF_STATS_FRAMEWORK_LINESIZE    (8)
-#define RGXFWIF_STATS_FRAMEWORK_MAX         (2048*RGXFWIF_STATS_FRAMEWORK_LINESIZE)
-	IMG_UINT32 RGXFW_ALIGN     aui32FWStatsBuf[RGXFWIF_STATS_FRAMEWORK_MAX];
-#endif
-	RGXFWIF_HWR_STATEFLAGS     ui32HWRStateFlags; /*!< Firmware's Current HWR state */
-	RGXFWIF_HWR_RECOVERYFLAGS  aui32HWRRecoveryFlags[RGXFWIF_DM_MAX]; /*!< Each DM's HWR state */
-	IMG_UINT32                 ui32FwSysDataFlags;                      /*!< Compatibility and other flags */
-	IMG_UINT32                 ui32McConfig;                            /*!< Identify whether MC config is P-P or P-S */
-	IMG_UINT32                 ui32MemFaultCheck;                       /*!< Device mem fault check on PCI systems */
-} UNCACHED_ALIGN RGXFWIF_SYSDATA;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_SYSDATA) == 3624,
-				"RGXFWIF_SYSDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER == 3624");
-#endif
-
-
-/*!
- * @InGroup ContextSwitching
- * @Brief Firmware per-os data and configuration
- */
-typedef struct
-{
-	IMG_UINT32                 ui32FwOsConfigFlags;                   /*!< Configuration flags from an OS */
-	IMG_UINT32                 ui32FWSyncCheckMark;                   /*!< Markers to signal that the host should perform a full sync check */
-	IMG_UINT32                 ui32HostSyncCheckMark;                  /*!< Markers to signal that the Firmware should perform a full sync check */
-#if defined(PVRSRV_STALLED_CCB_ACTION) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_UINT32                 ui32ForcedUpdatesRequested;
-	IMG_UINT8                  ui8SLRLogWp;
-	RGXFWIF_SLR_ENTRY          sSLRLogFirst;
-	RGXFWIF_SLR_ENTRY          sSLRLog[PVR_SLR_LOG_ENTRIES];
-	IMG_UINT64 RGXFW_ALIGN     ui64LastForcedUpdateTime;
-#endif
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	volatile IMG_UINT32        aui32InterruptCount[MAX_THREAD_NUM]; /*!< Interrupt count from Threads > */
-#else
-	volatile IMG_UINT32        aui32InterruptCount[RGXFW_THREAD_NUM]; /*!< Interrupt count from Threads > */
-#endif
-	IMG_UINT32                 ui32KCCBCmdsExecuted;                  /*!< Executed Kernel CCB command count */
-	RGXFWIF_DEV_VIRTADDR       sPowerSync;                            /*!< Sync prim used to signal the host the power off state */
-	IMG_UINT32                 ui32FwOsDataFlags;                       /*!< Compatibility and other flags */
-#if defined(SUPPORT_VALIDATION)
-	IMG_UINT32                 aui32KickCount[RGXFWIF_DM_MAX];        /*!< Count of the number of kicks per DM */
-	IMG_UINT32                 aui32KickPipelineCount[RGXFWIF_DM_MAX];/*!< Count of the number of kicks which pipelined per DM */
-	IMG_UINT32                 aui32KickCancelledCount[RGXFWIF_DM_MAX];/*!< Count of the number of kicks which are cancelled per DM */
-#endif
-} UNCACHED_ALIGN RGXFWIF_OSDATA;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_OSDATA) == 584,
-				"RGXFWIF_OSDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/* Firmware trace time-stamp field breakup */
-
-/* RGX_CR_TIMER register read (48 bits) value*/
-#define RGXFWT_TIMESTAMP_TIME_SHIFT                   (0U)
-#define RGXFWT_TIMESTAMP_TIME_CLRMSK                  (IMG_UINT64_C(0xFFFF000000000000))
-
-/* Extra debug-info (16 bits) */
-#define RGXFWT_TIMESTAMP_DEBUG_INFO_SHIFT             (48U)
-#define RGXFWT_TIMESTAMP_DEBUG_INFO_CLRMSK            ~RGXFWT_TIMESTAMP_TIME_CLRMSK
-
-
-/* Debug-info sub-fields */
-/* Bit 0: RGX_CR_EVENT_STATUS_MMU_PAGE_FAULT bit from RGX_CR_EVENT_STATUS register */
-#define RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SHIFT        (0U)
-#define RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SET          (1U << RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SHIFT)
-
-/* Bit 1: RGX_CR_BIF_MMU_ENTRY_PENDING bit from RGX_CR_BIF_MMU_ENTRY register */
-#define RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SHIFT     (1U)
-#define RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SET       (1U << RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SHIFT)
-
-/* Bit 2: RGX_CR_SLAVE_EVENT register is non-zero */
-#define RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SHIFT          (2U)
-#define RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SET            (1U << RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SHIFT)
-
-/* Bit 3-15: Unused bits */
-
-#define RGXFWT_DEBUG_INFO_STR_MAXLEN                  64
-#define RGXFWT_DEBUG_INFO_STR_PREPEND                 " (debug info: "
-#define RGXFWT_DEBUG_INFO_STR_APPEND                  ")"
-
-/* Table of debug info sub-field's masks and corresponding message strings
- * to be appended to firmware trace
- *
- * Mask     : 16 bit mask to be applied to debug-info field
- * String   : debug info message string
- */
-
-#define RGXFWT_DEBUG_INFO_MSKSTRLIST \
-/*Mask,                                           String*/ \
-X(RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SET,      "mmu pf") \
-X(RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SET,   "mmu pending") \
-X(RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SET,        "slave events")
-
-/*!
- ******************************************************************************
- * HWR Data
- *****************************************************************************/
-/*!
- * @Defgroup HWRInfo FW HWR shared data interface
- * @Brief Types grouping data structures and defines used in realising the HWR record.
- * @{
- */
-/*! @Brief HWR Lockup types */
-typedef enum
-{
-	RGX_HWRTYPE_UNKNOWNFAILURE = 0, /*!< Unknown failure */
-	RGX_HWRTYPE_OVERRUN        = 1, /*!< DM overrun */
-	RGX_HWRTYPE_POLLFAILURE    = 2, /*!< Poll failure */
-	RGX_HWRTYPE_BIF0FAULT      = 3, /*!< BIF0 fault */
-	RGX_HWRTYPE_BIF1FAULT      = 4, /*!< BIF1 fault */
-	RGX_HWRTYPE_TEXASBIF0FAULT = 5, /*!< TEXASBIF0 fault */
-	RGX_HWRTYPE_MMUFAULT       = 6, /*!< MMU fault */
-	RGX_HWRTYPE_MMUMETAFAULT   = 7, /*!< MMU META fault */
-	RGX_HWRTYPE_MIPSTLBFAULT   = 8, /*!< MIPS TLB fault */
-	RGX_HWRTYPE_ECCFAULT       = 9, /*!< ECC fault */
-	RGX_HWRTYPE_MMURISCVFAULT  = 10, /*!< MMU RISCV fault */
-} RGX_HWRTYPE;
-
-#define RGXFWIF_HWRTYPE_BIF_BANK_GET(eHWRType) (((eHWRType) == RGX_HWRTYPE_BIF0FAULT) ? 0 : 1)
-
-#define RGXFWIF_HWRTYPE_PAGE_FAULT_GET(eHWRType) ((((eHWRType) == RGX_HWRTYPE_BIF0FAULT)      ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_BIF1FAULT)      ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_TEXASBIF0FAULT) ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_MMUFAULT)       ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_MMUMETAFAULT)   ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_MIPSTLBFAULT)   ||       \
-                                                   ((eHWRType) == RGX_HWRTYPE_MMURISCVFAULT)) ? true : false)
-
-typedef struct
-{
-	IMG_UINT64	RGXFW_ALIGN		ui64BIFReqStatus; /*!< BIF request status */
-	IMG_UINT64	RGXFW_ALIGN		ui64BIFMMUStatus; /*!< MMU status */
-	IMG_UINT64	RGXFW_ALIGN		ui64PCAddress; /*!< phys address of the page catalogue */
-	IMG_UINT64	RGXFW_ALIGN		ui64Reserved;
-} RGX_BIFINFO;
-
-typedef struct
-{
-	IMG_UINT32 ui32FaultGPU; /*!< ECC fault in GPU */
-} RGX_ECCINFO;
-
-typedef struct
-{
-	IMG_UINT64	RGXFW_ALIGN		aui64MMUStatus[2]; /*!< MMU status */
-	IMG_UINT64	RGXFW_ALIGN		ui64PCAddress; /*!< phys address of the page catalogue */
-	IMG_UINT64	RGXFW_ALIGN		ui64Reserved;
-} RGX_MMUINFO;
-
-typedef struct
-{
-	IMG_UINT32	ui32ThreadNum; /*!< Thread ID performing poll operation */
-	IMG_UINT32	ui32CrPollAddr; /*!< CR Poll Address */
-	IMG_UINT32	ui32CrPollMask; /*!< CR Poll mask */
-	IMG_UINT32	ui32CrPollLastValue; /*!< CR Poll last value */
-	IMG_UINT64	RGXFW_ALIGN ui64Reserved;
-} UNCACHED_ALIGN RGX_POLLINFO;
-
-typedef struct
-{
-	IMG_UINT32 ui32BadVAddr; /*!< VA address */
-	IMG_UINT32 ui32EntryLo;
-} RGX_TLBINFO;
-
-/*! @Brief Structure to keep information specific to a lockup e.g. DM, timer, lockup type etc. */
-typedef struct
-{
-	union
-	{
-		RGX_BIFINFO  sBIFInfo; /*!< BIF failure details */
-		RGX_MMUINFO  sMMUInfo; /*!< MMU failure details */
-		RGX_POLLINFO sPollInfo; /*!< Poll failure details */
-		RGX_TLBINFO  sTLBInfo; /*!< TLB failure details */
-		RGX_ECCINFO  sECCInfo; /*!< ECC failure details */
-	} uHWRData;
-
-	IMG_UINT64 RGXFW_ALIGN ui64CRTimer; /*!< Timer value at the time of lockup */
-	IMG_UINT64 RGXFW_ALIGN ui64OSTimer; /*!< OS timer value at the time of lockup */
-	IMG_UINT32             ui32FrameNum; /*!< Frame number of the workload */
-	IMG_UINT32             ui32PID; /*!< PID belonging to the workload */
-	IMG_UINT32             ui32ActiveHWRTData; /*!< HWRT data of the workload */
-	IMG_UINT32             ui32HWRNumber; /*!< HWR number */
-	IMG_UINT32             ui32EventStatus; /*!< Core specific event status register at the time of lockup */
-	IMG_UINT32             ui32HWRRecoveryFlags; /*!< DM state flags */
-	RGX_HWRTYPE            eHWRType; /*!< Type of lockup */
-	RGXFWIF_DM             eDM; /*!< Recovery triggered for the DM */
-	IMG_UINT32             ui32CoreID; /*!< Core ID of the GPU */
-	IMG_UINT64 RGXFW_ALIGN ui64CRTimeOfKick; /*!< Workload kick time */
-	IMG_UINT64 RGXFW_ALIGN ui64CRTimeHWResetStart; /*!< HW reset start time */
-	IMG_UINT64 RGXFW_ALIGN ui64CRTimeHWResetFinish; /*!< HW reset stop time */
-	IMG_UINT64 RGXFW_ALIGN ui64CRTimeFreelistReady; /*!< freelist ready time on the last HWR */
-	IMG_CHAR   RGXFW_ALIGN szProcName[RGXFW_PROCESS_NAME_LEN]; /*!< User process name */
-} UNCACHED_ALIGN RGX_HWRINFO;
-
-#define RGXFWIF_HWINFO_MAX_FIRST 8U							/* Number of first HWR logs recorded (never overwritten by newer logs) */
-#define RGXFWIF_HWINFO_MAX_LAST 8U							/* Number of latest HWR logs (older logs are overwritten by newer logs) */
-#define RGXFWIF_HWINFO_MAX (RGXFWIF_HWINFO_MAX_FIRST + RGXFWIF_HWINFO_MAX_LAST)	/* Total number of HWR logs stored in a buffer */
-#define RGXFWIF_HWINFO_LAST_INDEX (RGXFWIF_HWINFO_MAX - 1U)	/* Index of the last log in the HWR log buffer */
-
-/*! @Brief Firmware HWR information structure allocated by the Services and used by the Firmware to update recovery information. */
-typedef struct
-{
-	RGX_HWRINFO sHWRInfo[RGXFWIF_HWINFO_MAX]; /*!< Max number of recovery record */
-	IMG_UINT32  ui32HwrCounter; /*!< HWR counter used in FL reconstruction */
-	IMG_UINT32  ui32WriteIndex; /*!< Index for updating recovery information in sHWRInfo */
-	IMG_UINT32  ui32DDReqCount; /*!< Count of DebugDump requested to the host after recovery */
-	IMG_UINT32  ui32HWRInfoBufFlags; /* Compatibility and other flags */
-	IMG_UINT32  aui32HwrDmLockedUpCount[RGXFWIF_DM_MAX]; /*!< Lockup count for each DM */
-	IMG_UINT32  aui32HwrDmOverranCount[RGXFWIF_DM_MAX]; /*!< Overrun count for each DM */
-	IMG_UINT32  aui32HwrDmRecoveredCount[RGXFWIF_DM_MAX]; /*!< Lockup + Overrun count for each DM */
-	IMG_UINT32  aui32HwrDmFalseDetectCount[RGXFWIF_DM_MAX]; /*!< False lockup detection count for each DM */
-} UNCACHED_ALIGN RGXFWIF_HWRINFOBUF;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_HWRINFOBUF) == 2336,
-				"RGXFWIF_HWRINFOBUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*! @} End of HWRInfo */
-
 #define RGXFWIF_CTXSWITCH_PROFILE_FAST_EN		(IMG_UINT32_C(0x1))
 #define RGXFWIF_CTXSWITCH_PROFILE_MEDIUM_EN		(IMG_UINT32_C(0x2))
 #define RGXFWIF_CTXSWITCH_PROFILE_SLOW_EN		(IMG_UINT32_C(0x3))
 #define RGXFWIF_CTXSWITCH_PROFILE_NODELAY_EN	(IMG_UINT32_C(0x4))
 
-#define RGXFWIF_CDM_ARBITRATION_TASK_DEMAND_EN	(IMG_UINT32_C(0x1))
-#define RGXFWIF_CDM_ARBITRATION_ROUND_ROBIN_EN	(IMG_UINT32_C(0x2))
-
 #define RGXFWIF_ISP_SCHEDMODE_VER1_IPP			(IMG_UINT32_C(0x1))
 #define RGXFWIF_ISP_SCHEDMODE_VER2_ISP			(IMG_UINT32_C(0x2))
 /*!
@@ -612,16 +136,14 @@ static_assert(sizeof(RGXFWIF_HWRINFOBUF) == 2336,
 #define RGXFWIF_INICFG_CTXSWITCH_PROFILE_MASK			(IMG_UINT32_C(0x7) << RGXFWIF_INICFG_CTXSWITCH_PROFILE_SHIFT)
 #define RGXFWIF_INICFG_DISABLE_DM_OVERLAP				(IMG_UINT32_C(0x1) << 19)
 #define RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER			(IMG_UINT32_C(0x1) << 20)
-#define RGXFWIF_INICFG_FABRIC_COHERENCY_ENABLED			(IMG_UINT32_C(0x1) << 21)
+#define RGXFWIF_INICFG_INJECT_ICS_FAULT					(IMG_UINT32_C(0x1) << 21)
 #define RGXFWIF_INICFG_VALIDATE_IRQ						(IMG_UINT32_C(0x1) << 22)
 #define RGXFWIF_INICFG_DISABLE_PDP_EN					(IMG_UINT32_C(0x1) << 23)
 #define RGXFWIF_INICFG_SPU_POWER_STATE_MASK_CHANGE_EN	(IMG_UINT32_C(0x1) << 24)
 #define RGXFWIF_INICFG_WORKEST							(IMG_UINT32_C(0x1) << 25)
 #define RGXFWIF_INICFG_PDVFS							(IMG_UINT32_C(0x1) << 26)
-#define RGXFWIF_INICFG_CDM_ARBITRATION_SHIFT			(27)
-#define RGXFWIF_INICFG_CDM_ARBITRATION_TASK_DEMAND		(RGXFWIF_CDM_ARBITRATION_TASK_DEMAND_EN << RGXFWIF_INICFG_CDM_ARBITRATION_SHIFT)
-#define RGXFWIF_INICFG_CDM_ARBITRATION_ROUND_ROBIN		(RGXFWIF_CDM_ARBITRATION_ROUND_ROBIN_EN << RGXFWIF_INICFG_CDM_ARBITRATION_SHIFT)
-#define RGXFWIF_INICFG_CDM_ARBITRATION_MASK				(IMG_UINT32_C(0x3) << RGXFWIF_INICFG_CDM_ARBITRATION_SHIFT)
+/* 27 unused */
+/* 28 unused */
 #define RGXFWIF_INICFG_ISPSCHEDMODE_SHIFT				(29)
 #define RGXFWIF_INICFG_ISPSCHEDMODE_NONE				(0)
 #define RGXFWIF_INICFG_ISPSCHEDMODE_VER1_IPP			(RGXFWIF_ISP_SCHEDMODE_VER1_IPP << RGXFWIF_INICFG_ISPSCHEDMODE_SHIFT)
@@ -715,13 +237,6 @@ typedef IMG_UINT32 RGX_RD_POWER_ISLAND_CONF;
 #endif
 #endif
 
-#if defined(RGX_FIRMWARE)
-typedef DLLIST_NODE							RGXFWIF_DLLIST_NODE;
-#else
-typedef struct {RGXFWIF_DEV_VIRTADDR p;
-                RGXFWIF_DEV_VIRTADDR n;}	RGXFWIF_DLLIST_NODE;
-#endif
-
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_SIGBUFFER;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_TRACEBUF;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_SYSDATA;
@@ -732,28 +247,22 @@ typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_TBIBUF;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_HWPERFBUF;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_HWRINFOBUF;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_RUNTIME_CFG;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_GPU_UTIL_FWCB;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_GPU_UTIL_FW;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_REG_CFG;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_HWPERF_CTL;
 typedef RGXFWIF_DEV_VIRTADDR  PRGX_HWPERF_CONFIG_MUX_CNTBLK;
 typedef RGXFWIF_DEV_VIRTADDR  PRGX_HWPERF_CONFIG_CNTBLK;
 typedef RGXFWIF_DEV_VIRTADDR  PRGX_HWPERF_SELECT_CUSTOM_CNTRS;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCB_CTL;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCB;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCB_RTN_SLOTS;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FWMEMCONTEXT;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FWCOMMONCONTEXT;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_ZSBUFFER;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_COMMONCTX_STATE;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CORE_CLK_RATE;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_COUNTERBUFFER;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FIRMWAREGCOVBUFFER;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCCB;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCCB_CTL;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FREELIST;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_HWRTDATA;
 typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_TIMESTAMP_ADDR;
-typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_RF_CMD;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCB_CTL;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCB;
 
 #if defined(SUPPORT_FW_HOST_SIDE_RECOVERY)
 /*!
@@ -821,7 +330,6 @@ typedef struct
 	/* FW-accessible TA state which must be written out to memory on context store */
 	IMG_UINT64	RGXFW_ALIGN uTAReg_VDM_CALL_STACK_POINTER;		 /*!< VDM control stream stack pointer, to store in mid-TA */
 	IMG_UINT64	RGXFW_ALIGN uTAReg_VDM_CALL_STACK_POINTER_Init;	 /*!< Initial value of VDM control stream stack pointer (in case is 'lost' due to a lock-up) */
-	IMG_UINT32	uTAReg_VBS_SO_PRIM[4];
 	IMG_UINT16	ui16TACurrentIdx;
 } UNCACHED_ALIGN RGXFWIF_TACTX_STATE_PER_GEOM;
 
@@ -900,72 +408,16 @@ typedef struct
 
 #define MAX_ZSSTORE_DISABLE 8
 
-/*!
- * @InGroup WorkloadContexts
- * @Brief Firmware Common Context (or FWCC)
- */
-typedef struct RGXFWIF_FWCOMMONCONTEXT_
+typedef struct
 {
-	/* CCB details for this firmware context */
-	PRGXFWIF_CCCB_CTL		psCCBCtl;				/*!< CCB control */
-	PRGXFWIF_CCCB			psCCB;					/*!< CCB base */
-	RGXFWIF_DMA_ADDR		sCCBMetaDMAAddr;
-
-	/* Context suspend state */
-	PRGXFWIF_COMMONCTX_STATE	RGXFW_ALIGN psContextState;		/*!< TA/3D context suspend state, read/written by FW */
-
-	/* Flags e.g. for context switching */
-	IMG_UINT32				ui32FWComCtxFlags;
-	IMG_INT32				i32Priority;  /*!< Priority level */
-	IMG_UINT32				ui32PrioritySeqNum;
-
-	/* Framework state */
-	PRGXFWIF_RF_CMD			RGXFW_ALIGN psRFCmd;		/*!< Register updates for Framework */
-
-	/* Misc and compatibility flags */
-	IMG_UINT32				ui32CompatFlags;
-
-	/* Statistic updates waiting to be passed back to the host... */
-	IMG_INT32				i32StatsNumStores;		/*!< Number of stores on this context since last update */
-	IMG_INT32				i32StatsNumOutOfMemory;		/*!< Number of OOMs on this context since last update */
-	IMG_INT32				i32StatsNumPartialRenders;	/*!< Number of PRs on this context since last update */
-	RGXFWIF_DM				eDM;				/*!< Data Master type */
-	IMG_UINT64				RGXFW_ALIGN  ui64WaitSignalAddress;	/*!< Device Virtual Address of the signal the context is waiting on */
-	RGXFWIF_DLLIST_NODE		RGXFW_ALIGN  sWaitSignalNode;			/*!< List entry for the wait-signal list */
-	RGXFWIF_DLLIST_NODE		RGXFW_ALIGN  sBufStalledNode;			/*!< List entry for the buffer stalled list */
-	IMG_UINT64				RGXFW_ALIGN  ui64CBufQueueCtrlAddr;	/*!< Address of the circular buffer queue pointers */
-
-	IMG_UINT64				RGXFW_ALIGN  ui64RobustnessAddress;
-	IMG_UINT32				ui32MaxDeadlineMS;			/*!< Max HWR deadline limit in ms */
-	bool					bReadOffsetNeedsReset;			/*!< Following HWR circular buffer read-offset needs resetting */
-
-	RGXFWIF_DLLIST_NODE		RGXFW_ALIGN sWaitingNode;		/*!< List entry for the waiting list */
-	RGXFWIF_DLLIST_NODE		RGXFW_ALIGN sRunNode;			/*!< List entry for the run list */
-	RGXFWIF_UFO				sLastFailedUFO;			/*!< UFO that last failed (or NULL) */
-
-	PRGXFWIF_FWMEMCONTEXT	psFWMemContext;					/*!< Memory context */
-
-	/* References to the host side originators */
-	IMG_UINT32				ui32ServerCommonContextID;	/*!< the Server Common Context */
-	IMG_UINT32				ui32PID;			/*!< associated process ID */
-
-	IMG_BOOL				bGeomOOMDisabled;		/*!< True when Geom DM OOM is not allowed */
-	IMG_CHAR				szProcName[RGXFW_PROCESS_NAME_LEN];	/*!< User process name */
-	IMG_UINT32				ui32DeferCount;		/*!< Number of context defers before forced scheduling of context */
-} UNCACHED_ALIGN RGXFWIF_FWCOMMONCONTEXT;
-
-static_assert(sizeof(RGXFWIF_FWCOMMONCONTEXT) <= 256U,
-              "Size of structure RGXFWIF_FWCOMMONCONTEXT exceeds maximum expected size.");
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_FWCOMMONCONTEXT) == 168,
-				"RGXFWIF_FWCOMMONCONTEXT is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
+	bool       bSaved;
+	IMG_UINT64 ui64CheckSum[4];
+}RGXFWIF_TRP_CHECKSUM_GEOM_ENTRY;
 
 typedef IMG_UINT64 RGXFWIF_TRP_CHECKSUM_TQ[RGX_TRP_MAX_NUM_CORES][1];
 typedef IMG_UINT64 RGXFWIF_TRP_CHECKSUM_2D[RGX_TRP_MAX_NUM_CORES][2];
 typedef IMG_UINT64 RGXFWIF_TRP_CHECKSUM_3D[RGX_TRP_MAX_NUM_CORES][4];
-typedef IMG_UINT64 RGXFWIF_TRP_CHECKSUM_GEOM[RGX_TRP_MAX_NUM_CORES][2];
+typedef RGXFWIF_TRP_CHECKSUM_GEOM_ENTRY RGXFWIF_TRP_CHECKSUM_GEOM[RGX_TRP_MAX_NUM_CORES];
 
 /*!
  * @InGroup WorkloadContexts
@@ -1007,7 +459,6 @@ typedef struct
 
 	IMG_UINT32 ui32ComputeCtxFlags; /*!< Compatibility and other flags */
 
-	IMG_UINT32		ui32WGPState;
 	IMG_UINT32		aui32WGPChecksum[RGX_WGP_MAX_NUM_CORES];
 } UNCACHED_ALIGN RGXFWIF_FWCOMPUTECONTEXT;
 
@@ -1031,7 +482,6 @@ typedef struct
 	RGXFWIF_FWCOMMONCONTEXT	sTQContext;			 /*!< Firmware context for TQ3D */
 
 #if defined(SUPPORT_TRP)
-	IMG_UINT32				ui32TRPState;		/*!< Used by Firmware to track current state of a protected kick */
 	RGXFWIF_TRP_CHECKSUM_TQ aui64TRPChecksumsTQ;/*!< Used by Firmware to store checksums during TQ WRR */
 #endif
 } UNCACHED_ALIGN RGXFWIF_FWTRANSFERCONTEXT;
@@ -1081,17 +531,10 @@ static_assert(sizeof(RGXFWIF_CCB_CTL) == 16,
 
 #if !defined(__KERNEL__)
 
-#if !defined(RGX_FEATURE_SLC_VIVT)
 #define RGXFWIF_MMUCACHEDATA_FLAGS_PMTLB   (0x10U) /* can't use PM_TLB0 bit from BIFPM_CTRL reg because it collides with PT bit from BIF_CTRL reg */
 #define RGXFWIF_MMUCACHEDATA_FLAGS_TLB     (RGXFWIF_MMUCACHEDATA_FLAGS_PMTLB | 0x8U) /* BIF_CTRL_INVAL_TLB1_EN */
 #define RGXFWIF_MMUCACHEDATA_FLAGS_CTX_ALL (0x0U) /* not used */
 
-#else /* RGX_FEATURE_SLC_VIVT */
-#define RGXFWIF_MMUCACHEDATA_FLAGS_PMTLB   (0x0U) /* not used */
-#define RGXFWIF_MMUCACHEDATA_FLAGS_TLB     (0x0U) /* not used */
-#define RGXFWIF_MMUCACHEDATA_FLAGS_CTX_ALL (0x800U) /* MMU_CTRL_INVAL_ALL_CONTEXTS_EN */
-#endif
-
 #else
 #define RGXFWIF_MMUCACHEDATA_FLAGS_PMTLB   (0x10U) /* can't use PM_TLB0 bit from BIFPM_CTRL reg because it collides with PT bit from BIF_CTRL reg */
 #define RGXFWIF_MMUCACHEDATA_FLAGS_TLB     (RGXFWIF_MMUCACHEDATA_FLAGS_PMTLB | 0x8U) /* BIF_CTRL_INVAL_TLB1_EN */
@@ -1223,7 +666,7 @@ typedef struct
 	RGXFWIF_POWER_TYPE					ePowType;					/*!< Type of power request */
 	union
 	{
-		IMG_UINT32						ui32NumOfDusts;			/*!< Number of active Dusts */
+		IMG_UINT32						ui32PowUnits;			/*!< Number of active Dusts */
 		IMG_BOOL						bForced;				/*!< If the operation is mandatory */
 		RGXFWIF_POWER_FORCE_IDLE_TYPE	ePowRequestType;		/*!< Type of Request. Consolidating Force Idle, Cancel Forced Idle, Host Timeout */
 	} uPowerReqData;
@@ -1309,22 +752,6 @@ typedef struct
 	IMG_BOOL				bDone;								/*!< action backing/unbacking succeeded */
 } RGXFWIF_ZSBUFFER_BACKING_DATA;
 
-#if defined(SUPPORT_VALIDATION)
-typedef struct
-{
-	IMG_UINT32 ui32RegWidth;
-	IMG_BOOL   bWriteOp;
-	IMG_UINT32 ui32RegAddr;
-	IMG_UINT64 RGXFW_ALIGN ui64RegVal;
-} RGXFWIF_RGXREG_DATA;
-
-typedef struct
-{
-	IMG_UINT64 ui64BaseAddress;
-	PRGXFWIF_FWCOMMONCONTEXT psContext;
-	IMG_UINT32 ui32Size;
-} RGXFWIF_GPUMAP_DATA;
-#endif
 
 /*!
  * @Brief Command data for \ref RGXFWIF_KCCB_CMD_FREELIST_GROW_UPDATE type command
@@ -1361,22 +788,22 @@ typedef struct
  ******************************************************************************
  * Proactive DVFS Structures
  *****************************************************************************/
-#define NUM_OPP_VALUES 16
+#define NUM_OPP_LEVELS 16
 
 typedef struct
 {
 	IMG_UINT32			ui32Volt; /* V  */
 	IMG_UINT32			ui32Freq; /* Hz */
-} UNCACHED_ALIGN PDVFS_OPP;
+} UNCACHED_ALIGN OPP_LEVEL;
 
 typedef struct
 {
-	PDVFS_OPP		asOPPValues[NUM_OPP_VALUES];
+	OPP_LEVEL		asOPPValues[NUM_OPP_LEVELS];
 #if defined(DEBUG)
 	IMG_UINT32		ui32MinOPPPoint;
 #endif
 	IMG_UINT32		ui32MaxOPPPoint;
-} UNCACHED_ALIGN RGXFWIF_PDVFS_OPP;
+} UNCACHED_ALIGN RGXFWIF_OPP_INFO;
 
 typedef struct
 {
@@ -1403,18 +830,6 @@ typedef enum
 	RGXFWIF_REGCFG_CMD_DISABLE			= 104
 } RGXFWIF_REGDATA_CMD_TYPE;
 
-typedef enum
-{
-	RGXFWIF_REG_CFG_TYPE_PWR_ON=0,      /* Sidekick power event */
-	RGXFWIF_REG_CFG_TYPE_DUST_CHANGE,   /* Rascal / dust power event */
-	RGXFWIF_REG_CFG_TYPE_TA,            /* TA kick */
-	RGXFWIF_REG_CFG_TYPE_3D,            /* 3D kick */
-	RGXFWIF_REG_CFG_TYPE_CDM,           /* Compute kick */
-	RGXFWIF_REG_CFG_TYPE_TLA,           /* TLA kick */
-	RGXFWIF_REG_CFG_TYPE_TDM,           /* TDM kick */
-	RGXFWIF_REG_CFG_TYPE_ALL            /* Applies to all types. Keep as last element */
-} RGXFWIF_REG_CFG_TYPE;
-
 typedef struct
 {
 	IMG_UINT64		ui64Addr;
@@ -1455,6 +870,13 @@ typedef struct
 	RGXFWIF_OS_STATE_CHANGE eNewOSState;
 } UNCACHED_ALIGN RGXFWIF_OS_STATE_CHANGE_DATA;
 
+typedef struct
+{
+	PRGXFWIF_FWCOMMONCONTEXT psContext;
+	IMG_UINT32               ui32FirstIntJobRefToCancel;
+	IMG_UINT32               ui32LastIntJobRefToCancel;
+} UNCACHED_ALIGN RGXFWIF_CANCEL_WORK_DATA;
+
 typedef enum
 {
 	RGXFWIF_PWR_COUNTER_DUMP_START = 1,
@@ -1488,7 +910,7 @@ typedef enum
 	RGXFWIF_KCCB_CMD_COMBINED_TA_3D_KICK				= 113U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< There is a TA and a 3D command in this single kick */
 	RGXFWIF_KCCB_CMD_OS_ONLINE_STATE_CONFIGURE			= 114U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Informs the FW that a Guest OS has come online / offline. */
 	RGXFWIF_KCCB_CMD_DISABLE_ZSSTORE					= 115U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Informs the FW to disable zs store of a running 3D or add it to queue of render context. */
-
+	RGXFWIF_KCCB_CMD_CANCEL_WORK						= 116U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Cancel all work up to and including a given intjobref for a given context */
 	/* Commands only permitted to the native or host OS */
 	RGXFWIF_KCCB_CMD_POW								= 200U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Power request */
 	RGXFWIF_KCCB_CMD_REGCONFIG							= 201U | RGX_CMD_MAGIC_DWORD_SHIFTED,
@@ -1499,14 +921,8 @@ typedef enum
 	RGXFWIF_KCCB_CMD_STATEFLAGS_CTRL					= 206U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Set or clear firmware state flags */
 	RGXFWIF_KCCB_CMD_PDVFS_LIMIT_MIN_FREQ				= 207U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Set a minimum frequency/OPP point */
 	RGXFWIF_KCCB_CMD_PHR_CFG							= 208U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Configure Periodic Hardware Reset behaviour */
-#if defined(SUPPORT_VALIDATION)
-	RGXFWIF_KCCB_CMD_RGXREG								= 209U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Read RGX Register from FW */
-#endif
 	RGXFWIF_KCCB_CMD_WDG_CFG							= 210U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Configure Safety Firmware Watchdog */
 	RGXFWIF_KCCB_CMD_COUNTER_DUMP						= 211U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Controls counter dumping in the FW */
-#if defined(SUPPORT_VALIDATION)
-	RGXFWIF_KCCB_CMD_GPUMAP								= 212U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Request a FW GPU mapping which is written into by the FW with a pattern */
-#endif
 	RGXFWIF_KCCB_CMD_VZ_DRV_TIME_SLICE					= 213U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Changes the GPU time slice for a particular driver. It can only be serviced for the Host DDK */
 	RGXFWIF_KCCB_CMD_VZ_DRV_TIME_SLICE_INTERVAL			= 214U | RGX_CMD_MAGIC_DWORD_SHIFTED, /*!< Changes the GPU time slice interval for all drivers. It can only be serviced for the Host DDK */
 
@@ -1558,10 +974,7 @@ typedef struct
 		RGXFWIF_COUNTER_DUMP_DATA			sCounterDumpConfigData; /*!< Data for dumping of register ranges */
 		RGXFWIF_KCCB_CMD_DISABLE_ZSSTORE_DATA	sDisableZSStoreData;	/*!< Data for disabling zs store of a 3D workload */
 		RGXFWIF_KCCB_CMD_FORCE_UPDATE_DATA  sForceUpdateData;       /*!< Data for signalling all unmet fences for a given CCB */
-#if defined(SUPPORT_VALIDATION) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-		RGXFWIF_RGXREG_DATA                 sFwRgxData;             /*!< Data for reading off an RGX register */
-		RGXFWIF_GPUMAP_DATA                 sGPUMapData;            /*!< Data for requesting a FW GPU mapping which is written into by the FW with a pattern */
-#endif
+		RGXFWIF_CANCEL_WORK_DATA			sCancelWorkData;		/*!< Data for cancelling work */
 	} UNCACHED_ALIGN uCmdData;
 } UNCACHED_ALIGN RGXFWIF_KCCB_CMD;
 
@@ -1665,12 +1078,6 @@ typedef enum
 	RGXFWIF_FWCCB_CMD_CORE_CLK_RATE_CHANGE          = 108U | RGX_CMD_MAGIC_DWORD_SHIFTED,
 	RGXFWIF_FWCCB_CMD_REQUEST_GPU_RESTART           = 109U | RGX_CMD_MAGIC_DWORD_SHIFTED,   /*!< Requests GPU restart
 	                                                                                          \n Command data: None */
-#if defined(SUPPORT_VALIDATION)
-	RGXFWIF_FWCCB_CMD_REG_READ                      = 110U | RGX_CMD_MAGIC_DWORD_SHIFTED,
-#if defined(SUPPORT_SOC_TIMER)
-	RGXFWIF_FWCCB_CMD_SAMPLE_TIMERS                 = 111U | RGX_CMD_MAGIC_DWORD_SHIFTED,
-#endif
-#endif
 	RGXFWIF_FWCCB_CMD_CONTEXT_FW_PF_NOTIFICATION    = 112U | RGX_CMD_MAGIC_DWORD_SHIFTED,   /*!< Notifies host of a FW pagefault
 	                                                                                          \n Command data: RGXFWIF_FWCCB_CMD_FW_PAGEFAULT_DATA */
 } RGXFWIF_FWCCB_CMD_TYPE;
@@ -1706,21 +1113,6 @@ typedef struct
 	IMG_UINT32 ui32CoreClkRate;
 } UNCACHED_ALIGN RGXFWIF_FWCCB_CMD_CORE_CLK_RATE_CHANGE_DATA;
 
-#if defined(SUPPORT_VALIDATION)
-typedef struct
-{
-	IMG_UINT64 ui64RegValue;
-} RGXFWIF_FWCCB_CMD_RGXREG_READ_DATA;
-
-#if defined(SUPPORT_SOC_TIMER)
-typedef struct
-{
-	IMG_UINT64 ui64timerGray;
-	IMG_UINT64 ui64timerBinary;
-	IMG_UINT64 aui64uscTimers[RGX_FEATURE_NUM_CLUSTERS];
-}  RGXFWIF_FWCCB_CMD_SAMPLE_TIMERS_DATA;
-#endif
-#endif
 
 /*!
  ******************************************************************************
@@ -1740,12 +1132,6 @@ typedef struct
 		RGXFWIF_FWCCB_CMD_UPDATE_STATS_DATA					sCmdUpdateStatsData;			/*!< Data for updating process stats */
 		RGXFWIF_FWCCB_CMD_CORE_CLK_RATE_CHANGE_DATA			sCmdCoreClkRateChange;
 		RGXFWIF_FWCCB_CMD_FW_PAGEFAULT_DATA					sCmdFWPagefault;				/*!< Data for context reset notification */
-#if defined(SUPPORT_VALIDATION) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-		RGXFWIF_FWCCB_CMD_RGXREG_READ_DATA					sCmdRgxRegReadData;
-#if defined(SUPPORT_SOC_TIMER)
-		RGXFWIF_FWCCB_CMD_SAMPLE_TIMERS_DATA				sCmdTimers;
-#endif
-#endif
 	} RGXFW_ALIGN uCmdData;
 } RGXFW_ALIGN RGXFWIF_FWCCB_CMD;
 
@@ -1765,6 +1151,7 @@ static_assert(sizeof(RGXFWIF_FWCCB_CMD) == 48,
 typedef struct
 {
 	IMG_UINT16 ui16ReturnDataIndex; /*!< Index for return data array */
+	IMG_UINT16 ui16CyclesTakenHigh;	/*!< Not used on Rogue GPU cores. */
 	IMG_UINT32 ui32CyclesTaken;     /*!< The cycles the workload took on the hardware */
 } RGXFWIF_WORKEST_FWCCB_CMD;
 
@@ -1812,17 +1199,21 @@ typedef IMG_UINT32 RGXFWIF_CCB_CMD_TYPE;
    bit cleared for POST_TIMESTAMPs. That's why we have 2 different cmd types.
 */
 #define RGXFWIF_CCB_CMD_TYPE_POST_TIMESTAMP (217U | RGX_CMD_MAGIC_DWORD_SHIFTED)
-#define RGXFWIF_CCB_CMD_TYPE_UNFENCED_UPDATE (218U | RGX_CMD_MAGIC_DWORD_SHIFTED) /*!< Unfenced fence updates of a command */
-#define RGXFWIF_CCB_CMD_TYPE_UNFENCED_RMW_UPDATE (219U | RGX_CMD_MAGIC_DWORD_SHIFTED) /*!< Unfenced fence updates related to workload resources */
+/* UNFENCED type is not supported but keeping defines as it is for now */
 
-#if defined(SUPPORT_VALIDATION)
-#define RGXFWIF_CCB_CMD_TYPE_REG_READ (220U | RGX_CMD_MAGIC_DWORD_SHIFTED)
-#endif
 
 #define RGXFWIF_CCB_CMD_TYPE_PADDING	(221U | RGX_CMD_MAGIC_DWORD_SHIFTED) /*!< Skip without action type command */
 #define RGXFWIF_CCB_CMD_TYPE_VK_TIMESTAMP	(223U | RGX_CMD_MAGIC_DWORD_SHIFTED | RGX_CCB_TYPE_TASK) /*!< Process a vulkan timestamp */
 /*! @} End of Client CCB command types */
 
+
+#define RGXFWIF_TRP_STATUS_UNKNOWN				0x000U
+#define RGXFWIF_TRP_STATUS_CHECKSUMS_OK			0x001U
+#define RGXFWIF_TRP_STATUS_CHECKSUMS_ERROR		0x002U
+
+#define RGXFWIF_CR_TRP_SIGNATURE_STATUS			(RGX_CR_SCRATCH10)
+
+
 typedef struct
 {
 	/* Index for the KM Workload estimation return data array */
@@ -1932,6 +1323,12 @@ typedef struct
 	IMG_BOOL					bUpdated;				/*!< Information is valid */
 } UNCACHED_ALIGN RGXFWIF_COMPCHECKS;
 
+typedef struct
+{
+	IMG_UINT32                 ui32NumCores;
+	IMG_UINT64 RGXFW_ALIGN     aui64MultiCoreCapabilities[RGX_MULTICORE_MAX_NOHW_CORES];
+} UNCACHED_ALIGN RGXFWIF_MULTICORE_INFO;
+
 /*! @Brief Firmware Runtime configuration data \ref RGXFWIF_RUNTIME_CFG
  * allocated by services and used by the Firmware on boot
  **/
@@ -1941,20 +1338,22 @@ typedef struct
 	IMG_UINT32         ui32RuntimeCfgFlags;                      /*!< Compatibility and other flags */
 	IMG_BOOL           bActivePMLatencyPersistant;               /*!< If set, APM latency does not reset to system default each GPU power transition */
 	IMG_UINT32         ui32CoreClockSpeed;                       /*!< Core clock speed, currently only used to calculate timer ticks */
-	IMG_UINT32         ui32DefaultDustsNumInit;                  /*!< Last number of dusts change requested by the host */
+#if defined(SUPPORT_SOC_TIMER)
+	IMG_UINT32         ui32SOCClockSpeed;                        /*!< SOC clock speed, used for deadline scheduling */
+#endif
+	IMG_UINT32         ui32PowUnitsState;                        /*!< Last number of dusts change requested by the host */
 	IMG_UINT32         ui32PHRMode;                              /*!< Periodic Hardware Reset configuration values */
 	IMG_UINT32         ui32HCSDeadlineMS;                        /*!< New number of milliseconds C/S is allowed to last */
 	IMG_UINT32         ui32WdgPeriodUs;                          /*!< The watchdog period in microseconds */
-	IMG_UINT32         aui32DriverPriority[RGXFW_MAX_NUM_OSIDS]; /*!< Array of priorities per OS */
+	IMG_INT32          ai32DriverPriority[RGXFW_MAX_NUM_OSIDS];  /*!< Array of priorities per OS */
 	IMG_UINT32         aui32DriverIsolationGroup[RGXFW_MAX_NUM_OSIDS]; /*!< Array of isolation groups per OS */
-	IMG_UINT32         aui32DriverTimeSlice[RGXFW_MAX_NUM_OSIDS]; /*!< Array of time slice per OS */
-	IMG_UINT32         ui32DriverTimeSliceInterval;				 /*!< Time slice interval */
+	IMG_UINT32         aui32TSPercentage[RGXFW_MAX_NUM_OSIDS];   /*!< Array of time slice per OS */
+	IMG_UINT32         ui32TSIntervalMs;                         /*!< Time slice interval */
 	IMG_UINT32         ui32VzConnectionCooldownPeriodInSec;      /*!< Vz Connection Cooldown period in secs */
 
 	PRGXFWIF_HWPERFBUF sHWPerfBuf;                               /*!< On-demand allocated HWPerf buffer address, to be passed to the FW */
-#if defined(SUPPORT_VALIDATION) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_BOOL           bInjectFWFault;                           /*!< Injecting firmware fault to validate recovery through Host */
-#endif
+	RGXFWIF_DMA_ADDR   sHWPerfDMABuf;
+	RGXFWIF_DMA_ADDR   sHWPerfCtlDMABuf;
 } RGXFWIF_RUNTIME_CFG;
 
 #if defined(SUPPORT_OPEN_SOURCE_DRIVER)
@@ -2111,6 +1510,7 @@ typedef struct
 	PRGXFWIF_OSDATA         sFwOsData; /*!<  Firmware per-os shared data */
 
 	RGXFWIF_COMPCHECKS      sRGXCompChecks; /*!< Compatibility checks to be populated by the Firmware */
+	RGXFWIF_MULTICORE_INFO  sRGXMulticoreInfo; /*! < Multicore capability info */
 
 } UNCACHED_ALIGN RGXFWIF_OSINIT;
 
@@ -2130,19 +1530,14 @@ typedef struct
 
 	IMG_DEV_VIRTADDR        RGXFW_ALIGN sPDSExecBase; /*!< PDS execution base */
 	IMG_DEV_VIRTADDR        RGXFW_ALIGN sUSCExecBase; /*!< USC execution base */
-	IMG_DEV_VIRTADDR        RGXFW_ALIGN sFBCDCStateTableBase; /*!< FBCDC bindless texture state table base */
-	IMG_DEV_VIRTADDR        RGXFW_ALIGN sFBCDCLargeStateTableBase;
-	IMG_DEV_VIRTADDR        RGXFW_ALIGN sTextureHeapBase; /*!< Texture state base */
 
 	IMG_UINT64              RGXFW_ALIGN ui64HWPerfFilter; /*! Event filter for Firmware events */
 
-	IMG_DEV_VIRTADDR        RGXFW_ALIGN sSLC3FenceDevVAddr; /*!< Address to use as a fence when issuing SLC3_CFI */
-
 	IMG_UINT32              RGXFW_ALIGN aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_LAST];
 
+#if defined(PDUMP)
 	RGXFWIF_SIGBUF_CTL      asSigBufCtl[RGXFWIF_DM_MAX]; /*!< Signature and Checksum Buffers for DMs */
-
-	RGXFWIF_PDVFS_OPP       sPDVFSOPPInfo;
+#endif
 
 	RGXFWIF_DMA_ADDR        sCorememDataStore; /*!< Firmware coremem data */
 
@@ -2162,7 +1557,7 @@ typedef struct
 	PRGXFWIF_TBIBUF         sTBIBuf; /*!< Tbi log buffer */
 #endif
 
-	PRGXFWIF_GPU_UTIL_FWCB  sGpuUtilFWCbCtl; /*!< GPU utilization buffer */
+	PRGXFWIF_GPU_UTIL_FW    sGpuUtilFWCtl; /*!< GPU utilization buffer */
 	PRGXFWIF_REG_CFG        sRegCfg; /*!< Firmware register user configuration */
 	PRGXFWIF_HWPERF_CTL     sHWPerfCtl; /*!< HWPerf counter block configuration.*/
 
@@ -2170,6 +1565,10 @@ typedef struct
 
 	IMG_UINT32              ui32InitialCoreClockSpeed; /*!< Core clock speed at FW boot time */
 
+#if defined(SUPPORT_SOC_TIMER)
+	IMG_UINT32              ui32InitialSOCClockSpeed; /*!< System/SOC clock speed at FW boot time */
+#endif
+
 	IMG_UINT32              ui32InitialActivePMLatencyms; /*!< APM latency in ms before signalling IDLE to the host */
 
 	IMG_BOOL                bFirmwareStarted; /*!< Flag to be set by the Firmware after successful start */
@@ -2178,16 +1577,18 @@ typedef struct
 
 	IMG_UINT32              ui32FirmwareStartedTimeStamp; /*!< Firmware initialization complete time */
 
-	IMG_UINT32              ui32JonesDisableMask;
-
 	FW_PERF_CONF            eFirmwarePerf; /*!< Firmware performance counter config */
 
+#if defined(SUPPORT_FW_OPP_TABLE)
+	RGXFWIF_OPP_INFO        RGXFW_ALIGN sOPPInfo;
+
 	/**
 	 * FW Pointer to memory containing core clock rate in Hz.
 	 * Firmware (PDVFS) updates the memory when running on non primary FW thread
 	 * to communicate to host driver.
 	 */
-	PRGXFWIF_CORE_CLK_RATE  sCoreClockRate;
+	PRGXFWIF_CORE_CLK_RATE  RGXFW_ALIGN sCoreClockRate;
+#endif
 
 #if defined(PDUMP)
 	RGXFWIF_PID_FILTER      sPIDFilter;
@@ -2302,9 +1703,12 @@ typedef struct
 
 /* See rgx_common.h for a list of GPU states */
 #define RGXFWIF_GPU_UTIL_TIME_MASK       (IMG_UINT64_C(0xFFFFFFFFFFFFFFFF) & ~RGXFWIF_GPU_UTIL_STATE_MASK)
+#define RGXFWIF_GPU_UTIL_TIME_MASK32     (IMG_UINT32_C(0xFFFFFFFF) & ~RGXFWIF_GPU_UTIL_STATE_MASK32)
 
-#define RGXFWIF_GPU_UTIL_GET_TIME(word)  ((word) & RGXFWIF_GPU_UTIL_TIME_MASK)
-#define RGXFWIF_GPU_UTIL_GET_STATE(word) ((word) & RGXFWIF_GPU_UTIL_STATE_MASK)
+#define RGXFWIF_GPU_UTIL_GET_TIME(word)    ((word) & RGXFWIF_GPU_UTIL_TIME_MASK)
+#define RGXFWIF_GPU_UTIL_GET_STATE(word)   ((word) & RGXFWIF_GPU_UTIL_STATE_MASK)
+#define RGXFWIF_GPU_UTIL_GET_TIME32(word)  ((IMG_UINT32)(word) & RGXFWIF_GPU_UTIL_TIME_MASK32)
+#define RGXFWIF_GPU_UTIL_GET_STATE32(word) ((IMG_UINT32)(word) & RGXFWIF_GPU_UTIL_STATE_MASK32)
 
 /* The OS timestamps computed by the FW are approximations of the real time,
  * which means they could be slightly behind or ahead the real timer on the Host.
@@ -2318,6 +1722,9 @@ typedef struct
 #define RGXFWIF_GPU_UTIL_MAKE_WORD(time,state) \
 	(RGXFWIF_GPU_UTIL_GET_TIME(time) | RGXFWIF_GPU_UTIL_GET_STATE(state))
 
+#define RGXFWIF_GPU_UTIL_MAKE_WORD32(time,state) \
+	(RGXFWIF_GPU_UTIL_GET_TIME32(time) | RGXFWIF_GPU_UTIL_GET_STATE32(state))
+
 
 /* The timer correlation array must be big enough to ensure old entries won't be
  * overwritten before all the HWPerf events linked to those entries are processed
@@ -2336,6 +1743,26 @@ typedef struct
 static_assert((RGXFWIF_TIME_CORR_ARRAY_SIZE & (RGXFWIF_TIME_CORR_ARRAY_SIZE - 1U)) == 0U,
 			  "RGXFWIF_TIME_CORR_ARRAY_SIZE must be a power of two");
 
+/* The time is stored in DM state time-stamps, and as a result in DMs states counters, in "approximately microseconds",
+ * dividing the time originally obtained in nanoseconds by 2^10 for the sake of reducing coremem usage */
+#define RGXFWIF_DM_OS_TIMESTAMP_SHIFT    10U
+
+typedef struct
+{
+	/* Last GPU DM per-OS states + OS time of the last state update */
+	IMG_UINT32 RGXFW_ALIGN aui32DMOSLastWord[RGXFWIF_GPU_UTIL_DM_MAX];
+	/* DMs time-stamps are cached in coremem - to reduce coremem usage we allocate 32 bits for each of them
+	 * and save their values divided by 2^10, so they wrap around in ~73 mins, consequently
+	 * we keep the count of the wrapping around instances */
+	IMG_UINT32 RGXFW_ALIGN aui32DMOSLastWordWrap[RGXFWIF_GPU_UTIL_DM_MAX];
+	/* Counters for the amount of time the GPU DMs were active or inactive(idle or blocked) */
+	IMG_UINT32 RGXFW_ALIGN aaui32DMOSStatsCounters[RGXFWIF_GPU_UTIL_DM_MAX][RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM];
+	/* DMs Counters are cached in coremem - to reduce coremem usage we allocate 32 bits for each of them
+	 * and save their values divided by 2^10, so they wrap around in ~73 mins, consequently
+	 * we keep the count of the wrapping around instances */
+	IMG_UINT32 RGXFW_ALIGN aaui32DMOSCountersWrap[RGXFWIF_GPU_UTIL_DM_MAX][RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM];
+} RGXFWIF_GPU_STATS;
+
 typedef struct
 {
 	RGXFWIF_TIME_CORR      sTimeCorr[RGXFWIF_TIME_CORR_ARRAY_SIZE];
@@ -2348,217 +1775,17 @@ typedef struct
 	IMG_UINT64 RGXFW_ALIGN ui64GpuLastWord;
 	/* Counters for the amount of time the GPU was active/idle/blocked */
 	IMG_UINT64 RGXFW_ALIGN aui64GpuStatsCounters[RGXFWIF_GPU_UTIL_STATE_NUM];
-
-	/* Last GPU DM per-OS states + OS time of the last state update */
-	IMG_UINT64 RGXFW_ALIGN aaui64DMOSLastWord[RGXFWIF_DM_MAX][RGXFW_MAX_NUM_OSIDS];
-	/* Counters for the amount of time the GPU DMs were active/idle/blocked */
-	IMG_UINT64 RGXFW_ALIGN aaaui64DMOSStatsCounters[RGXFWIF_DM_MAX][RGXFW_MAX_NUM_OSIDS][RGXFWIF_GPU_UTIL_STATE_NUM];
-} UNCACHED_ALIGN RGXFWIF_GPU_UTIL_FWCB;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_GPU_UTIL_FWCB) == 12584,
-				"RGXFWIF_GPU_UTIL_FWCB is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-typedef struct
-{
-	IMG_UINT32           ui32RenderTargetIndex;		//Render number
-	IMG_UINT32           ui32CurrentRenderTarget;	//index in RTA
-	IMG_UINT32           ui32ActiveRenderTargets;	//total active RTs
-	IMG_UINT32           ui32CumulActiveRenderTargets;   //total active RTs from the first TA kick, for OOM
-	RGXFWIF_DEV_VIRTADDR sValidRenderTargets;  //Array of valid RT indices
-	RGXFWIF_DEV_VIRTADDR sRTANumPartialRenders;  //Array of number of occurred partial renders per render target
-	IMG_UINT32           ui32MaxRTs;   //Number of render targets in the array
-	IMG_UINT32           ui32RTACtlFlags; /* Compatibility and other flags */
-} UNCACHED_ALIGN RGXFWIF_RTA_CTL;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_RTA_CTL) == 32,
-				"RGXFWIF_RTA_CTL is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*!
- * @InGroup RenderTarget
- * @Brief Firmware Freelist holding usage state of the Parameter Buffers
- */
-typedef struct
-{
-	IMG_DEV_VIRTADDR	RGXFW_ALIGN psFreeListDevVAddr;	/*!< Freelist page table base */
-	IMG_UINT64		RGXFW_ALIGN ui64CurrentDevVAddr;/*!< Freelist page table entry for current free page */
-	IMG_UINT32		ui32CurrentStackTop;		/*!< Freelist current free page */
-	IMG_UINT32		ui32MaxPages;			/*!< Max no. of pages can be added to the freelist */
-	IMG_UINT32		ui32GrowPages;			/*!< No pages to add in each freelist grow */
-	IMG_UINT32		ui32CurrentPages;		/*!< Total no. of pages made available to the PM HW */
-	IMG_UINT32		ui32AllocatedPageCount;		/*!< No. of pages allocated by PM HW */
-	IMG_UINT32		ui32AllocatedMMUPageCount;	/*!< No. of pages allocated for GPU MMU for PM*/
-#if defined(SUPPORT_SHADOW_FREELISTS) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_UINT32		ui32HWRCounter;
-	PRGXFWIF_FWMEMCONTEXT	psFWMemContext;
-#endif
-	IMG_UINT32		ui32FreeListID;			/*!< Unique Freelist ID */
-	IMG_BOOL		bGrowPending;			/*!< Freelist grow is pending */
-	IMG_UINT32		ui32ReadyPages;			/*!< Reserved pages to be used only on PM OOM event */
-	IMG_UINT32		ui32FreelistFlags;		/*!< Compatibility and other flags */
-#if defined(SUPPORT_AGP) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_UINT32		ui32PmGlobalPb;			/*!< PM Global PB on which Freelist is loaded */
-#endif
-} UNCACHED_ALIGN RGXFWIF_FREELIST;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_FREELIST) == 64,
-				"RGXFWIF_FREELIST is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*!
- ******************************************************************************
- * HWRTData
- *****************************************************************************/
-
-/* HWRTData flags */
-/* Deprecated flags 1:0 */
-#define HWRTDATA_HAS_LAST_TA              (IMG_UINT32_C(1) << 2)
-#define HWRTDATA_PARTIAL_RENDERED         (IMG_UINT32_C(1) << 3)
-#define HWRTDATA_DISABLE_TILE_REORDERING  (IMG_UINT32_C(1) << 4)
-#define HWRTDATA_NEED_BRN65101_BLIT       (IMG_UINT32_C(1) << 5)
-#define HWRTDATA_FIRST_BRN65101_STRIP     (IMG_UINT32_C(1) << 6)
-#define HWRTDATA_NEED_BRN67182_2ND_RENDER (IMG_UINT32_C(1) << 7)
-#if defined(SUPPORT_AGP)
-#define HWRTDATA_GLOBAL_PB_NUMBER_BIT0    (IMG_UINT32_C(1) << 8)
-#if defined(SUPPORT_AGP4)
-#define HWRTDATA_GLOBAL_PB_NUMBER_BIT1    (IMG_UINT32_C(1) << 9)
-#endif
-#define HWRTDATA_GEOM_NEEDS_RESUME        (IMG_UINT32_C(1) << 10)
-#endif
-
-typedef enum
-{
-	RGXFWIF_RTDATA_STATE_NONE = 0,
-	RGXFWIF_RTDATA_STATE_KICKTA,
-	RGXFWIF_RTDATA_STATE_KICKTAFIRST,
-	RGXFWIF_RTDATA_STATE_TAFINISHED,
-	RGXFWIF_RTDATA_STATE_KICK3D,
-	RGXFWIF_RTDATA_STATE_3DFINISHED,
-	RGXFWIF_RTDATA_STATE_3DCONTEXTSTORED,
-	RGXFWIF_RTDATA_STATE_TAOUTOFMEM,
-	RGXFWIF_RTDATA_STATE_PARTIALRENDERFINISHED,
-	/* In case of HWR, we can't set the RTDATA state to NONE,
-	 * as this will cause any TA to become a first TA.
-	 * To ensure all related TA's are skipped, we use the HWR state */
-	RGXFWIF_RTDATA_STATE_HWR,
-	RGXFWIF_RTDATA_STATE_UNKNOWN = 0x7FFFFFFFU
-} RGXFWIF_RTDATA_STATE;
-
-typedef struct
-{
-	IMG_BOOL							bTACachesNeedZeroing;
-
-	IMG_UINT32							ui32ScreenPixelMax;
-	IMG_UINT64							RGXFW_ALIGN ui64MultiSampleCtl;
-	IMG_UINT64							ui64FlippedMultiSampleCtl;
-	IMG_UINT32							ui32TPCStride;
-	IMG_UINT32							ui32TPCSize;
-	IMG_UINT32							ui32TEScreen;
-	IMG_UINT32							ui32MTileStride;
-	IMG_UINT32							ui32TEAA;
-	IMG_UINT32							ui32TEMTILE1;
-	IMG_UINT32							ui32TEMTILE2;
-	IMG_UINT32							ui32ISPMergeLowerX;
-	IMG_UINT32							ui32ISPMergeLowerY;
-	IMG_UINT32							ui32ISPMergeUpperX;
-	IMG_UINT32							ui32ISPMergeUpperY;
-	IMG_UINT32							ui32ISPMergeScaleX;
-	IMG_UINT32							ui32ISPMergeScaleY;
-	IMG_UINT32							uiRgnHeaderSize;
-	IMG_UINT32							ui32ISPMtileSize;
-} UNCACHED_ALIGN RGXFWIF_HWRTDATA_COMMON;
+	/* Device off period timestamp offset */
+	IMG_INT64 RGXFW_ALIGN i64DeviceTimestampOffset;
+	/* Stats per OSID/DriverID */
+	RGXFWIF_GPU_STATS sStats[RGXFW_MAX_NUM_OSIDS];
+} UNCACHED_ALIGN RGXFWIF_GPU_UTIL_FW;
 
 #if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_HWRTDATA_COMMON) == 88,
-				"RGXFWIF_HWRTDATA_COMMON is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+static_assert(sizeof(RGXFWIF_GPU_UTIL_FW) == 12584,
+				"RGXFWIF_GPU_UTIL_FW is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
 #endif
 
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-#define MAX_FREELISTS_SIZE 3
-
-static_assert(RGXFW_MAX_FREELISTS <= MAX_FREELISTS_SIZE,
-				"RGXFW_MAX_FREELISTS is outside of allowable range for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/*!
- * @InGroup RenderTarget
- * @Brief Firmware Render Target data i.e. HWRTDATA used to hold the PM context
- */
-typedef struct
-{
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN psPMMListDevVAddr;			/*!< MList Data Store */
-
-	IMG_UINT64			RGXFW_ALIGN ui64VCECatBase[1];			/*!< VCE Page Catalogue base */
-	IMG_UINT64			RGXFW_ALIGN ui64VCELastCatBase[1];
-	IMG_UINT64			RGXFW_ALIGN ui64TECatBase[1];			/*!< TE Page Catalogue base */
-	IMG_UINT64			RGXFW_ALIGN ui64TELastCatBase[1];
-	IMG_UINT64			RGXFW_ALIGN ui64AlistCatBase;			/*!< Alist Page Catalogue base */
-	IMG_UINT64			RGXFW_ALIGN ui64AlistLastCatBase;
-
-	IMG_UINT64			RGXFW_ALIGN ui64PMAListStackPointer;		/*!< Freelist page table entry for current Mlist page */
-	IMG_UINT32			ui32PMMListStackPointer;			/*!< Current Mlist page */
-
-	RGXFWIF_DEV_VIRTADDR		sHWRTDataCommonFwAddr;				/*!< Render target dimension dependent data */
-
-	IMG_UINT32			ui32HWRTDataFlags;
-	RGXFWIF_RTDATA_STATE		eState;						/*!< Current workload processing state of HWRTDATA */
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	PRGXFWIF_FREELIST		RGXFW_ALIGN apsFreeLists[MAX_FREELISTS_SIZE];	/*!< Freelist to use */
-	IMG_UINT32			aui32FreeListHWRSnapshot[MAX_FREELISTS_SIZE];
-#else
-	PRGXFWIF_FREELIST		RGXFW_ALIGN apsFreeLists[RGXFW_MAX_FREELISTS];	/*!< Freelist to use */
-	IMG_UINT32			aui32FreeListHWRSnapshot[RGXFW_MAX_FREELISTS];
-#endif
-
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN psVHeapTableDevVAddr;		/*!< VHeap table base */
-
-	RGXFWIF_RTA_CTL			sRTACtl;					/*!< Render target array data */
-
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN sTailPtrsDevVAddr;			/*!< Tail pointers base */
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN sMacrotileArrayDevVAddr;		/*!< Macrotiling array base */
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN sRgnHeaderDevVAddr;			/*!< Region headers base */
-	IMG_DEV_VIRTADDR		RGXFW_ALIGN sRTCDevVAddr;			/*!< Render target cache base */
-#if defined(RGX_FIRMWARE)
-	struct RGXFWIF_FWCOMMONCONTEXT_* RGXFW_ALIGN psOwnerGeom;
-#else
-	RGXFWIF_DEV_VIRTADDR		RGXFW_ALIGN pui32OwnerGeomNotUsedByHost;
-#endif
-#if defined(SUPPORT_TRP) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_UINT32			ui32KickFlagsCopy;
-	IMG_UINT32			ui32TRPState;	/*!< Used by Firmware to track current state of a protected kick */
-	IMG_UINT32			ui32TEPageCopy;
-	IMG_UINT32			ui32VCEPageCopy;
-#endif
-#if defined(SUPPORT_AGP) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
-	IMG_BOOL			bTACachesNeedZeroing;
-#endif
-
-	RGXFWIF_CLEANUP_CTL		RGXFW_ALIGN_DCACHEL sCleanupState;					/*!< Render target clean up state */
-} RGXFW_ALIGN_DCACHEL RGXFWIF_HWRTDATA;
-
-#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
-static_assert(sizeof(RGXFWIF_HWRTDATA) == 256,
-				"RGXFWIF_HWRTDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
-#endif
-
-/* Sync_checkpoint firmware object.
- * This is the FW-addressable structure use to hold the sync checkpoint's
- * state and other information which needs to be accessed by the firmware.
- */
-typedef struct
-{
-	IMG_UINT32	ui32State;          /*!< Holds the current state of the sync checkpoint */
-	IMG_UINT32	ui32FwRefCount;     /*!< Holds the FW reference count (num of fences/updates processed) */
-} SYNC_CHECKPOINT_FW_OBJ;
-
-/* Bit mask Firmware can use to test if a checkpoint has signalled or errored */
-#define SYNC_CHECKPOINT_SIGNALLED_MASK (0x1 << 0)
-
 #define RGXFWIF_KM_GENERAL_HEAP_TDM_SECURE_QUEUE_OFFSET_BYTES      RGX_HEAP_KM_GENERAL_RESERVED_REGION_OFFSET
 #define RGXFWIF_KM_GENERAL_HEAP_TDM_SECURE_QUEUE_MAX_SIZE_BYTES    2048U
 
@@ -2578,9 +1805,6 @@ typedef struct
  ******************************************************************************
  * Virtualisation and Security
  *****************************************************************************/
-#define FW_OSID							(0U)
-#define MMU_CONTEXT_MAPPING_FWPRIV		(0U) /* FW code/private data */
-
 #if defined(SECURE_FW_CODE_OSID)
 /* software workaround for SoCs without fw_code, fw_priv_data signals, MIPS only */
 #if defined(RGX_FEATURE_META)
@@ -2602,28 +1826,25 @@ static_assert((RGX_FW_HEAP_OSID_ASSIGNMENT == RGX_FW_HEAP_USES_FIRMWARE_OSID),
 /* Firmware and Host driver share the same OSID */
 #define FW_HEAP_OSID					(FW_OSID)
 
-#if (RGX_FW_HEAP_OSID_ASSIGNMENT == RGX_FW_HEAP_USES_FIRMWARE_OSID) || defined(RGX_FEATURE_MIPS)
-/* The Firmware accesses its private code & data and the interface
- * memory it shares with the KM drivers using the same MMU context */
-#define MMU_CONTEXT_MAPPING_FWIF		MMU_CONTEXT_MAPPING_FWPRIV
-#else
-/* The Firmware accesses the interface memory it shares
- * with the KM drivers using a reserved MMU context */
-#define MMU_CONTEXT_MAPPING_FWIF		(7U)
-#endif
-
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
 /* virtualization without security support */
 #define DRIVER_ID(osid)					(osid)
 #define OSID(did)						(did)
+/* Time slice support */
+/* Bits 30 and 31 reserved by FW private driver priority */
+#define RGXFW_VZ_PRIORITY_MAX_SHIFT	(30U)
+#define RGXFW_VZ_PRIORITY_MASK		((1U << RGXFW_VZ_PRIORITY_MAX_SHIFT) - 1U)
+#define RGXFW_VZ_TIME_SLICE_MAX		(100U)
+#define RGXFW_VZ_TIME_SLICE_MIN		(5U)
 #else
 #define DRIVER_ID(osid)					(0U)
 #define OSID(did)						(did)
+#define RGXFW_VZ_PRIORITY_MASK			(0U)
 #endif /* (RGX_NUM_DRIVERS_SUPPORTED > 1) */
 
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
 
-#define FOREACH_SUPPORTED_DRIVER(did)               for ((did)=RGXFW_HOST_DRIVER_ID; (did) < RGX_NUM_DRIVERS_SUPPORTED; (did)++)
+#define FOREACH_SUPPORTED_DRIVER(did)              for ((did)=RGXFW_HOST_DRIVER_ID; (did) < RGX_NUM_DRIVERS_SUPPORTED; (did)++)
 
 #if defined(__KERNEL__)
 /* Driver implementation */
@@ -2639,25 +1860,26 @@ static_assert((RGX_FW_HEAP_OSID_ASSIGNMENT == RGX_FW_HEAP_USES_FIRMWARE_OSID),
 /* Firmware implementation */
 #define FOREACH_ACTIVE_DRIVER(did)                 do {                                                                      \
                                                    unsigned int idx;                                                         \
-                                                   for ((idx)=RGXFW_HOST_DRIVER_ID, (did)=gsRGXFWCtl.aui32ActiveDrivers[0U]; \
-                                                        (idx) < RGXFW_NUM_ACTIVE_DRIVERS;                                         \
-                                                        ++(idx), (did)=gsRGXFWCtl.aui32ActiveDrivers[(idx)])  {
+                                                   for (idx = 0; idx < RGXFW_NUM_ACTIVE_DRIVERS; idx++)                      \
+                                                   {                                                                         \
+                                                       (did) = gsRGXFWCtl.aui32ActiveDrivers[idx];                           \
+                                                       {
 
-#define END_FOREACH_ACTIVE_DRIVER                    }} while (false);
+#define END_FOREACH_ACTIVE_DRIVER                  }}} while (false);
 #endif /* defined(__KERNEL__) */
 
 
 #else
-#define FOREACH_SUPPORTED_DRIVER(did)               for ((did)=RGXFW_HOST_DRIVER_ID; (did) <= RGXFW_HOST_DRIVER_ID; (did)++)
+#define FOREACH_SUPPORTED_DRIVER(did)              for ((did)=RGXFW_HOST_DRIVER_ID; (did) <= RGXFW_HOST_DRIVER_ID; (did)++)
 
-#define FOREACH_ACTIVE_DRIVER(did)                  FOREACH_SUPPORTED_DRIVER(did)
+#define FOREACH_ACTIVE_DRIVER(did)                 FOREACH_SUPPORTED_DRIVER(did)
 #define END_FOREACH_ACTIVE_DRIVER
 
 #endif /* (RGX_NUM_DRIVERS_SUPPORTED > 1) */
 
 #define FOREACH_VALIDATION_OSID(osid)              for ((osid)=0; (osid) < GPUVIRT_VALIDATION_NUM_OS; (osid)++)
 #define FOREACH_HW_OSID(osid)                      for ((osid)=0; (osid) < RGXFW_MAX_NUM_OSIDS; (osid)++)
-#define FOREACH_DRIVER_RAW_HEAP(did)               for ((did)=RGX_FIRST_RAW_HEAP_DRIVER_ID; (did) < ((PVRSRV_VZ_MODE_IS(NATIVE) ? 1 : RGX_NUM_DRIVERS_SUPPORTED)); (did)++)
+#define FOREACH_DRIVER_RAW_HEAP(did, _struct, dev) for ((did)=RGX_FIRST_RAW_HEAP_DRIVER_ID; (did) < ((PVRSRV_VZ_MODE_IS(NATIVE, _struct, dev) ? 1 : RGX_NUM_DRIVERS_SUPPORTED)); (did)++)
 
 #endif /* RGX_FWIF_KM_H */
 
diff --git a/drivers/gpu/drm/img-rogue/rgx_fwif_sf.h b/drivers/gpu/drm/img-rogue/rgx_fwif_sf.h
index 00b7763653dc..a190875b5e6d 100644
--- a/drivers/gpu/drm/img-rogue/rgx_fwif_sf.h
+++ b/drivers/gpu/drm/img-rogue/rgx_fwif_sf.h
@@ -69,7 +69,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 	X(RGXFW_GROUP_HWP,HWP)          \
 	X(RGXFW_GROUP_RPM,RPM)          \
 	X(RGXFW_GROUP_DMA,DMA)          \
-	X(RGXFW_GROUP_DBG,DBG)
+	X(RGXFW_GROUP_DBG,DBG)          \
+	X(RGXFW_GROUP_VZ,VZ)            \
+	X(RGXFW_GROUP_SAFETY,SAFETY)    \
+	X(RGXFW_GROUP_VERBOSE,VERBOSE)  \
+	X(RGXFW_GROUP_CUSTOMER,CUSTOMER)
 
 /*!
  * @InGroup SRVAndFWTracing
@@ -250,15 +254,15 @@ X(142, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TDM_OFFSET_READ_RESET, "Reset TDM Queue R
 X(143, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UMQ_MISMATCHED_READ_OFFSET, "User Mode Queue mismatched stream start: FWCtx 0x%08.8x, queue: 0x%08x%08x (Roff = %u, StreamStartOffset = %u)", 5) \
 X(144, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_GPU_DEINIT, "GPU deinit", 0) \
 X(145, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UNITS_DEINIT, "GPU units deinit", 0) \
-X(146, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CONFIG, "Initialised OS %u with config flags 0x%08x", 2) \
+X(146, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CONFIG_DEPRECATED, "Initialised OS %u with config flags 0x%08x", 2) \
 X(147, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_LIMIT, "UFO limit exceeded %u/%u", 2) \
 X(148, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_3D_62850KICK, "3D Dummy stencil store", 0) \
-X(149, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CONFIG_DEPRECATED, "Initialised OS %u with config flags 0x%08x and extended config flags 0x%08x", 3) \
+X(149, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CONFIG_DEPRECATED2, "Initialised OS %u with config flags 0x%08x and extended config flags 0x%08x", 3) \
 X(150, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UNKNOWN_COMMAND_DEPRECATED, "Unknown Command (eCmdType=0x%08x)", 1) \
 X(151, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_FORCED_UPDATE, "UFO forced update: FWCtx 0x%08.8x @ %u [0x%08.8x] = 0x%08.8x", 4) \
 X(152, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_FORCED_UPDATE_NOP_DEPRECATED, "UFO forced update NOP: FWCtx 0x%08.8x @ %u [0x%08.8x] = 0x%08.8x, reason %u", 5) \
 X(153, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TDM_BRN66075_CHECK, "TDM context switch check: Roff %u points to 0x%08x, Match=%u", 3) \
-X(154, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CCBS, "Driver ID %u CCB init status: %u (1-ok 0-fail): kCCBCtl@0x%x kCCB@0x%x fwCCBCtl@0x%x fwCCB@0x%x", 6) \
+X(154, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CCBS_DEPRECATED, "Driver ID %u CCB init status: %u (1-ok 0-fail): kCCBCtl@0x%x kCCB@0x%x fwCCBCtl@0x%x fwCCB@0x%x", 6) \
 X(155, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FWIRQ, "FW IRQ # %u @ %u", 2) \
 X(156, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_BREAKPOINT_SET, "Setting breakpoint: Addr 0x%08.8x DM%u usc_breakpoint_ctrl_dm = %u", 3) \
 X(157, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INVALID_KERNEL_CCB_DEPRECATED, "Invalid KCCB setup for OSid %u: KCCB 0x%08x, KCCB Ctrl 0x%08x", 3) \
@@ -269,8 +273,8 @@ X(161, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FLUSHINVAL_CMD_INVALID_DEPRECATED, "Disca
 X(162, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INVALID_NOTIFY_WRITE_OFFSET_UPDATE_DEPRECATED, "Invalid Write Offset update notification from OSid %u to DM %u: FWCtx 0x%08x, MemCtx 0x%08x", 4) \
 X(163, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INVALID_KCCB_KICK_CMD_DEPRECATED, "Null FWCtx in KCCB kick cmd for OSid %u: KCCB 0x%08x, ROff %u, WOff %u", 4) \
 X(164, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FULL_CHPTCCB, "Checkpoint CCB for Driver ID %u is full, signalling host for full check state (Roff = %u, Woff = %u)", 3) \
-X(165, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CCBS_DEPRECATED, "OSid %u CCB init status: %u (1-ok 0-fail): kCCBCtl@0x%x kCCB@0x%x fwCCBCtl@0x%x fwCCB@0x%x chptCCBCtl@0x%x chptCCB@0x%x", 8) \
-X(166, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_STATE_CHANGE, "Driver ID %u fw state transition request: from %u to %u (0-offline 1-ready 2-active 3-offloading 4-cooldown). Status %u (1-ok 0-fail)", 4) \
+X(165, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_INIT_CCBS_DEPRECATED2, "OSid %u CCB init status: %u (1-ok 0-fail): kCCBCtl@0x%x kCCB@0x%x fwCCBCtl@0x%x fwCCB@0x%x chptCCBCtl@0x%x chptCCB@0x%x", 8) \
+X(166, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_STATE_CHANGE_DEPRECATED, "Driver ID %u fw state transition request: from %u to %u (0-offline 1-ready 2-active 3-offloading 4-cooldown). Status %u (1-ok 0-fail)", 4) \
 X(167, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_STALE_KCCB_CMDS, "Driver ID %u has %u stale commands in its KCCB", 2) \
 X(168, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TA_VCE_PAUSE, "Applying VCE pause", 0) \
 X(169, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_KCCB_UPDATE_RTN_SLOT_DEPRECATED, "OSid %u KCCB slot %u value updated to %u", 3) \
@@ -288,7 +292,7 @@ X(181, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SIGNAL_UPDATE, "Signal update, Snoop Filt
 X(182, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_DEV_SERIES8_DEPRECATED, "WARNING: Skipping FW KCCB Cmd type %u which is not yet supported on Series8.", 1) \
 X(183, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INCONSISTENT_MMU_FLAGS, "MMU context cache data NULL, but cache flags=0x%x (sync counter=%u, update value=%u) OSId=%u", 4) \
 X(184, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SLC_FLUSH, "SLC range based flush: Context=%u VAddr=0x%02x%08x, Size=0x%08x, Invalidate=%u", 5) \
-X(185, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBSC_INVAL, "FBSC invalidate for Context Set [0x%08x]: Entry mask 0x%08x%08x.", 3) \
+X(185, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBSC_INVAL_DEPRECATED, "FBSC invalidate for Context Set [0x%08x]: Entry mask 0x%08x%08x.", 3) \
 X(186, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TDM_BRN66284_UPDATE, "TDM context switch check: Roff %u was not valid for kick starting at %u, moving back to %u", 3) \
 X(187, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SPFILTER_UPDATES, "Signal updates: FIFO: %u, Signals: 0x%08x", 2) \
 X(188, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INVALID_FBSC_CMD, "Invalid FBSC cmd: FWCtx 0x%08x, MemCtx 0x%08x", 2) \
@@ -299,7 +303,7 @@ X(192, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_NULL_RTAS, "Invalid RTA Set-up. The Valid
 X(193, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_INVALID_COUNTER, "Block 0x%x / Counter 0x%x INVALID and ignored", 2) \
 X(194, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_ECC_FAULT_DEPRECATED, "ECC fault GPU=0x%08x FW=0x%08x", 2) \
 X(195, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_PROCESS_XPU_EVENT, "Processing XPU event on DM = %u", 1) \
-X(196, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_VZ_WDG_TRIGGER, "Driver ID %u failed to respond to the virtualisation watchdog in time. Timestamp of its last input = %u", 2) \
+X(196, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_VZ_WDG_TRIGGER_DEPRECATED, "Driver ID %u failed to respond to the virtualisation watchdog in time. Timestamp of its last input = %u", 2) \
 X(197, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_HWR_HIT_LOCKUP, "GPU-%u has locked up (see HWR logs for more info)", 1) \
 X(198, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UPDATE_TILES_IN_FLIGHT, "Updating Tiles In Flight (Dusts=%u, PartitionMask=0x%08x, ISPCtl=0x%08x)", 3) \
 X(199, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_HWR_HIT_LOCKUP_DM, "GPU has locked up (see HWR logs for more info)", 0) \
@@ -312,12 +316,12 @@ X(205, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_COMPUTE_CORE_STALLED, "Compute stalled co
 X(206, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UMQ_MISMATCHED_CORE_READ_OFFSET, "User Mode Queue mismatched stream start: Core %u, FWCtx 0x%08.8x, queue: 0x%08x%08x (Roff = %u, StreamStartOffset = %u)", 6) \
 X(207, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TDM_RESUMED_FROM_STALL, "TDM resumed core %u (Roff = %u, Woff = %u)", 3) \
 X(208, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_COMPUTE_CORE_RESUMED_FROM_STALL, "Compute resumed core %u (Roff = %u, Woff = %u, Size = %u)", 4) \
-X(209, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_MTS_PERMISSION_CHANGED, " Updated permission for Driver ID %u to perform MTS kicks: %u (1 = allowed, 0 = not allowed)", 2) \
+X(209, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_MTS_PERMISSION_CHANGED_DEPRECATED, " Updated permission for Driver ID %u to perform MTS kicks: %u (1 = allowed, 0 = not allowed)", 2) \
 X(210, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TEST1, "Mask = 0x%X, mask2 = 0x%X", 2) \
 X(211, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TEST2, "  core %u, reg = %u, mask = 0x%X)", 3) \
 X(212, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_ECC_FAULT_SAFETY_BUS, "ECC fault received from safety bus: 0x%08x", 1) \
 X(213, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SAFETY_WDG_CONFIG, "Safety Watchdog threshold period set to 0x%x clock cycles", 1) \
-X(214, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SAFETY_WDG_TRIGGER, "MTS Safety Event trigged by the safety watchdog.", 0) \
+X(214, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SAFETY_WDG_TRIGGER, "MTS Safety Event triggered by the safety watchdog.", 0) \
 X(215, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_USC_TASKS_RANGE, "DM%u USC tasks range limit 0 - %u, stride %u", 3) \
 X(216, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_GPU_ECC_FAULT, "ECC fault GPU=0x%08x", 1) \
 X(217, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_GPU_SAFETY_RESET, "GPU Hardware units reset to prevent transient faults.", 0) \
@@ -347,13 +351,13 @@ X(240, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_CHECK_PENDING_PASS, "UFO Check: [0x%0
 X(241, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_PR_CHECK_PENDING_PASS, "UFO PR-Check: [0x%08.8x] is pending update to 0x%08.8x and therefore passes", 2) \
 X(242, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_DELAY_DM_TO_OVERLAP_PIPES, "Holding kick of DM %u pipe %u to encourage pipeline overlap", 2) \
 X(243, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_RELEASE_DM_PIPE, "Releasing kick for DM %u pipe %u", 2) \
-X(244, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_PRIORITY_CHANGE, "Changing Driver ID %u's priority from %u to %u", 3) \
-X(245, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_ISOLATION_GROUP_CHANGE, "Changing Driver ID %u's isolation group from %u to %u", 3) \
+X(244, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_PRIORITY_CHANGE_DEPRECATED3, "Changing Driver ID %u's priority from %u to %u", 3) \
+X(245, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_ISOLATION_GROUP_CHANGE_DEPRECATED, "Changing Driver ID %u's isolation group from %u to %u", 3) \
 X(246, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_VK_TIMESTAMP, "VK Timestamp: addr=0x%08x%08x, avail=0x%08x%08x stamp=0x%08x%08x", 6) \
 X(247, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SET_HCS_TRIGGERED, "DM %u failed to Context Switch on time (Current time: 0x%08x%08x, deadline: 0x%08x%08x). Triggered HCS (see HWR logs).", 5) \
 X(248, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_HWR_HIT_POLLFAILURE, "HWR has been triggered - GPU has failed a poll, RGX_CR_EVENT_STATUS=0x%08x (see HWR logs)", 1) \
-X(249, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBCDC_FAILURE_DETECTED, "FBCDC signature failure detected so block scheduling more work", 0) \
-X(250, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBCDC_FAILURE_CLEARED, "FBCDC signature cleared which unlocks scheduling more work", 0) \
+X(249, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBCDC_FAILURE_DETECTED_DEPRECATED, "FBCDC signature failure detected so block scheduling more work", 0) \
+X(250, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBCDC_FAILURE_CLEARED_DEPRECATED, "FBCDC signature cleared which unlocks scheduling more work", 0) \
 X(251, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FW_FAULT, "FW FAULT: At line %u in file 0x%08x%08x, additional data=0x%08x%08x", 5) \
 X(252, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_UFO_FORCED_UPDATE_NOP, "UFO forced update NOP: FWCtx 0x%08.8x @ %u, reason %u", 3) \
 X(253, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TDM_CONTEXT_STORED, "TDM FWCtx:0x%08.8x stored", 1) \
@@ -379,6 +383,22 @@ X(272, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TA_CANCEL_PIPELINE, "TA cancelled: Kick I
 X(273, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_3D_CANCEL_PIPELINE, "3D cancelled: Kick ID %u", 1) \
 X(274, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_CDM_CANCEL_PIPELINE, "Compute cancelled: Kick ID %u", 1) \
 X(275, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_RAY_CANCEL_PIPELINE, "Ray cancelled: Kick ID %u", 1) \
+X(276, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_MAX_DEPRECATED, "Time Slice: Update Failed, Max total allocations exceeded 100pc", 0)\
+X(277, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_DYNAMIC_LOW_DEPRECATED, "Time Slice: Dynamic time slice low, allocating zero time slice to dynamic drivers", 0)\
+X(278, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_UPDATE_SUCCESS_DEPRECATED, "Time Slice: Updated Successfully", 0)\
+X(279, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_DISCARD_FWCCB, "FWCCB for Driver ID %u is full, discarding command! (Roff = %u, Woff = %u)", 3) \
+X(280, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_CANCEL_WORK_CMD_RECEIVED_DEPRECATED, "Cancelling jobs with intjobref<0x%08x, DM = %u, FWCtx = 0x%08.8x", 3) \
+X(281, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_CANCEL_WORK_CMD_RECEIVED, "Cancelling jobs with intjobref from 0x%08x to 0x%08x, DM = %u, FWCtx = 0x%08.8x", 4) \
+X(282, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_MAX_DEPRECATED2, "Time Slice: Update Failed, Max total allocations exceeded 100pc", 0)\
+X(283, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_DYNAMIC_LOW_DEPRECATED2, "Time Slice: Dynamic time slice low, allocating zero time slice to dynamic drivers", 0)\
+X(284, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_TIME_SLICE_UPDATE_SUCCESS_DEPRECATED2, "Time Slice: Updated Successfully", 0)\
+X(285, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_OS_STATE_CHANGE_DEPRECATED2, "Driver ID %u fw state transition request: from %u to %u (0-offline 1-ready 2-active 3-graceful_offloading 4-forced_offloading 5-cooldown). Status %u (1-ok 0-fail)", 4) \
+X(286, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FBSC_INVAL, "FBSC invalidate for Context Set [0x%08x]", 1) \
+X(287, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_CANCEL_WORK_CMD_DROPPED, "Dropped cancel request with intjobref from 0x%08x to 0x%08x, DM = %u, FWCtx = 0x%08.8x", 4) \
+X(288, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_ZERO_LM, "Zeroing local memory after context storing FWCtx = 0x%08.8x", 1) \
+X(289, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_FAILED_IRQ_CLEAR, "Host failed to clear IRQ DriverID: %u Reg: 0x%08x",2) \
+X(290, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_KILLDM_ABORTED, "Kill DM%u aborted", 1) \
+X(291, RGXFW_GROUP_MAIN, RGXFW_SF_MAIN_SOC_CLOCK_SPEED_CHANGE, "SOC clock set to %u Hz", 1) \
 \
 X(  1, RGXFW_GROUP_MTS, RGXFW_SF_MTS_BG_KICK_DEPRECATED, "Bg Task DM = %u, counted = %u", 2) \
 X(  2, RGXFW_GROUP_MTS, RGXFW_SF_MTS_BG_COMPLETE_DEPRECATED, "Bg Task complete DM = %u", 1) \
@@ -523,32 +543,34 @@ X( 18, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SR_STRIP_MODE, "SR: Strip mode is %u", 1)
 X( 19, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SR_STRIP_INDEX, "SR: Strip Render start (strip %u)", 1) \
 X( 20, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SR_BUFFER_RENDERED, "SR: Strip Render complete (buffer %u)", 1) \
 X( 21, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SR_BUFFER_FAULT, "SR: Strip Render fault (buffer %u)", 1) \
-X( 22, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_DEPRECATED, "TRP state: %u", 1) \
-X( 23, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_FAILURE, "TRP failure: %u", 1) \
-X( 24, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SW_TRP_STATE, "SW TRP State: %u", 1) \
-X( 25, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SW_TRP_FAILURE_DEPRECATED, "SW TRP failure: %u", 1) \
-X( 26, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HW_KICK, "HW kick event (%u)", 1) \
-X( 27, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WGP_CHECKSUMS, "GPU core (%u/%u): checksum 0x%08x vs. 0x%08x", 4) \
-X( 28, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WGP_UNIT_CHECKSUMS, "GPU core (%u/%u), unit (%u,%u): checksum 0x%08x vs. 0x%08x", 6) \
-X( 29, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_CHECK_REG, "HWR: Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
-X( 30, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_USC_SLOTS_CHECK, "HWR: USC Core%u, ui32TotalSlotsUsedByDM=0x%08x, psDMHWCtl->ui32USCSlotsUsedByDM=0x%08x, bHWRNeeded=%u", 4) \
-X( 31, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_USC_REG_CHECK, "HWR: USC Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
-X( 32, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_HWRTDATA, "TRP HWRTData: 0x%08x, state: %u", 2) \
-X( 33, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_CNTX, "TRP Context: 0x%08x, state: %u", 2) \
-X( 34, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_FAILURE_CNTX, "TRP Context: 0x%08x, failure: %u", 2) \
-X( 35, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU, "Memory dump: Addr=0x%02x%08x, Size=%d, ContextId=%u, DM=%u", 5) \
-X( 36, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS4, "  0x%02x%08x  %08x %08x %08x %08x", 6) \
-X( 37, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS3, "  0x%02x%08x  %08x %08x %08x", 5) \
-X( 38, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS2, "  0x%02x%08x  %08x %08x", 4) \
-X( 39, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS1, "  0x%02x%08x  %08x", 3) \
-X( 40, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW, "Memory dump: Addr=0x%08x, Size=%d", 2) \
-X( 41, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS4, "  0x%08x  %08x %08x %08x %08x", 5) \
-X( 42, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS3, "  0x%08x  %08x %08x %08x", 4) \
-X( 43, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS2, "  0x%08x  %08x %08x", 3) \
-X( 44, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS1, "  0x%08x  %08x", 2) \
-X( 45, RGXFW_GROUP_MISC, RGXFW_SF_MISC_FBCDC_FAILURE_STATUS, "FBCDC: Core=0x%08x, Status=0x%08x, Signature status=0x%08x", 3) \
+X( 22, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_DEPRECATED2, "TRP state: %u", 1) \
+X( 23, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_FAILURE_DEPRECATED, "TRP failure: %u", 1) \
+X( 24, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SW_TRP_STATE_DEPRECATED, "SW TRP State: %u", 1) \
+X( 25, RGXFW_GROUP_MISC, RGXFW_SF_MISC_SW_TRP_FAILURE_DEPRECATED2, "SW TRP failure: %u", 1) \
+X( 26, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HW_KICK_DEPRECATED, "HW kick event (%u)", 1) \
+X( 27, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WGP_CHECKSUMS_DEPRECATED, "GPU core (%u/%u): checksum 0x%08x vs. 0x%08x", 4) \
+X( 28, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WGP_UNIT_CHECKSUMS_DEPRECATED, "GPU core (%u/%u), unit (%u,%u): checksum 0x%08x vs. 0x%08x", 6) \
+X( 29, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_CHECK_REG_DEPRECATED, "HWR: Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X( 30, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_USC_SLOTS_CHECK_DEPRECATED, "HWR: USC Core%u, ui32TotalSlotsUsedByDM=0x%08x, psDMHWCtl->ui32USCSlotsUsedByDM=0x%08x, bHWRNeeded=%u", 4) \
+X( 31, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HWR_USC_REG_CHECK_DEPRECATED, "HWR: USC Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X( 32, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_HWRTDATA_DEPRECATED, "TRP HWRTData: 0x%08x, state: %u", 2) \
+X( 33, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_STATE_CNTX_DEPRECATED, "TRP Context: 0x%08x, state: %u", 2) \
+X( 34, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_FAILURE_CNTX_DEPRECATED, "TRP Context: 0x%08x, failure: %u", 2) \
+X( 35, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DEPRECATED, "Memory dump: Addr=0x%02x%08x, Size=%d, ContextId=%u, DM=%u", 5) \
+X( 36, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS4_DEPRECATED, "  0x%02x%08x  %08x %08x %08x %08x", 6) \
+X( 37, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS3_DEPRECATED, "  0x%02x%08x  %08x %08x %08x", 5) \
+X( 38, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS2_DEPRECATED, "  0x%02x%08x  %08x %08x", 4) \
+X( 39, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_GPU_DWORDS1_DEPRECATED, "  0x%02x%08x  %08x", 3) \
+X( 40, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DEPRECATED, "Memory dump: Addr=0x%08x, Size=%d", 2) \
+X( 41, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS4_DEPRECATED, "  0x%08x  %08x %08x %08x %08x", 5) \
+X( 42, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS3_DEPRECATED, "  0x%08x  %08x %08x %08x", 4) \
+X( 43, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS2_DEPRECATED, "  0x%08x  %08x %08x", 3) \
+X( 44, RGXFW_GROUP_MISC, RGXFW_SF_MISC_HEXDUMP_FW_DWORDS1_DEPRECATED, "  0x%08x  %08x", 2) \
+X( 45, RGXFW_GROUP_MISC, RGXFW_SF_MISC_FBCDC_FAILURE_STATUS_DEPRECATED, "FBCDC: Core=0x%08x, Status=0x%08x, Signature status=0x%08x", 3) \
 X( 46, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WORK_CYCLES_PIPEDM_EN, "FWCtx 0x%08.8x, PipeDM state %04x, (start) %08x, (end) %08x, elapsed %08x", 5) \
 X( 47, RGXFW_GROUP_MISC, RGXFW_SF_MISC_WORK_CYCLES, "FWCtx 0x%08.8x, elapsed %08x", 2) \
+X( 48, RGXFW_GROUP_MISC, RGXFW_SF_MISC_TRP_UNEXPECTED_EVENT_DEPRECATED, "Unexpected TRP pass completion on DM: %u",1) \
+X( 49, RGXFW_GROUP_MISC, RGXFW_SF_MISC_FAILED_IRQ_CLEAR_DEPRECATED, "Host failed to clear IRQ, Reg: 0x%08x",1) \
 \
 X(  1, RGXFW_GROUP_PM, RGXFW_SF_PM_AMLIST, "ALIST%u SP = %u, MLIST%u SP = %u (VCE 0x%08x%08x, TE 0x%08x%08x, ALIST 0x%08x%08x)", 10) \
 X(  2, RGXFW_GROUP_PM, RGXFW_SF_PM_UFL_SHARED_DEPRECATED, "Is TA: %u, finished: %u on HW %u (HWRTData = 0x%08x, MemCtx = 0x%08x). FL different between TA/3D: global:%u, local:%u, mmu:%u", 8) \
@@ -624,7 +646,7 @@ X( 13, RGXFW_GROUP_RTD, RGXFW_SF_RTD_STORE_PB_DEPRECATED, "Store Freelist 0x%x t
 X( 14, RGXFW_GROUP_RTD, RGXFW_SF_RTD_TA_RTDATA_FINISHED, "TA RTData 0x%08x finished on HW context %u", 2) \
 X( 15, RGXFW_GROUP_RTD, RGXFW_SF_RTD_TA_RTDATA_LOADED, "TA RTData 0x%08x loaded on HW context %u", 2) \
 X( 16, RGXFW_GROUP_RTD, RGXFW_SF_RTD_STORE_PB_DEPRECATED2, "Store Freelist 0x%x type: %u (0:local,1:global,2:mmu) for DM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
-X( 17, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL_DEPRECATED2, "Load  Freelist 0x%x type: %u (0:local,1:global,2:mmu) for DM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
+X( 17, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL_DEPRECATED2, "Load Freelist 0x%x type: %u (0:local,1:global,2:mmu) for DM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
 X( 18, RGXFW_GROUP_RTD, RGXFW_SF_RTD_DEBUG_DEPRECATED, "Freelist 0x%x RESET!!!!!!!!", 1) \
 X( 19, RGXFW_GROUP_RTD, RGXFW_SF_RTD_DEBUG2_DEPRECATED, "Freelist 0x%x stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 5) \
 X( 20, RGXFW_GROUP_RTD, RGXFW_SF_RTD_FL_RECON_DEPRECATED, "Request reconstruction of Freelist 0x%x type: %u (0:local,1:global,2:mmu) on HW context %u", 3) \
@@ -638,11 +660,11 @@ X( 27, RGXFW_GROUP_RTD, RGXFW_SF_RTD_3D_RTDATA_BUFFER_ADDRS_DEPRECATED, "3D Buff
 X( 28, RGXFW_GROUP_RTD, RGXFW_SF_RTD_TA_RESTART_AFTER_PR_EXECUTED, "Restarting TA after partial render, HWRTData0State=0x%x, HWRTData1State=0x%x", 2) \
 X( 29, RGXFW_GROUP_RTD, RGXFW_SF_RTD_PB_SET_TO, "CONTEXT_PB_BASE set to 0x%x, FL different between TA/3D: local: %u, global: %u", 3) \
 X( 30, RGXFW_GROUP_RTD, RGXFW_SF_RTD_STORE_FL, "Store Freelist 0x%x type: %u (0:local,1:global) for PMDM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
-X( 31, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL, "Load  Freelist 0x%x type: %u (0:local,1:global) for PMDM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
+X( 31, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL, "Load Freelist 0x%x type: %u (0:local,1:global) for PMDM%u: FL Total Pages %u (max=%u,grow size=%u), FL-addr = 0x%08x%08x, stacktop = 0x%08x%08x, Alloc Page Count = %u, Alloc MMU Page Count = %u", 12) \
 X( 32, RGXFW_GROUP_RTD, RGXFW_SF_RTD_3D_RTDATA_BUFFER_ADDRS_DEPRECATED2, "3D Buffers: FWCtx 0x%08x, parent RT 0x%08x, RTData 0x%08x on ctx %u, (MemCtx 0x%08x)", 5) \
 X( 33, RGXFW_GROUP_RTD, RGXFW_SF_RTD_TA_RTDATA_BUFFER_ADDRS, "TA Buffers: FWCtx 0x%08x, RTData 0x%08x, VHeap 0x%08x%08x, TPC 0x%08x%08x (MemCtx 0x%08x)", 7) \
 X( 34, RGXFW_GROUP_RTD, RGXFW_SF_RTD_3D_RTDATA_BUFFER_ADDRS, "3D Buffers: FWCtx 0x%08x, RTData 0x%08x on ctx %u, (MemCtx 0x%08x)", 4) \
-X( 35, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL_V2, "Load  Freelist 0x%x type: %u (0:local,1:global) for PMDM%u: FL Total Pages %u (max=%u,grow size=%u)", 6) \
+X( 35, RGXFW_GROUP_RTD, RGXFW_SF_RTD_LOAD_FL_V2, "Load Freelist 0x%x type: %u (0:local,1:global) for PMDM%u: FL Total Pages %u (max=%u,grow size=%u)", 6) \
 X( 36, RGXFW_GROUP_RTD, RGXFW_SF_RTD_KILLED_TA, "TA RTData 0x%08x marked as killed.", 1) \
 X( 37, RGXFW_GROUP_RTD, RGXFW_SF_RTD_KILLED_3D, "3D RTData 0x%08x marked as killed.", 1) \
 X( 38, RGXFW_GROUP_RTD, RGXFW_SF_RTD_KILL_TA_AFTER_RESTART, "RTData 0x%08x will be killed after TA restart.", 1) \
@@ -689,7 +711,7 @@ X( 36, RGXFW_GROUP_SPM, RGXFW_SF_SPM_STATE_PR_RUNNING, "SPM State = PR running",
 X( 37, RGXFW_GROUP_SPM, RGXFW_SF_SPM_STATE_PR_AVOIDED, "SPM State = PR avoided", 0) \
 X( 38, RGXFW_GROUP_SPM, RGXFW_SF_SPM_STATE_PR_EXECUTED, "SPM State = PR executed", 0) \
 X( 39, RGXFW_GROUP_SPM, RGXFW_SF_SPM_FREELIST_MATCH, "3DMemFree matches freelist 0x%08x (FL type = %u)", 2) \
-X( 40, RGXFW_GROUP_SPM, RGXFW_SF_SPM_3DMEMFREE_FLAG_SET, "Raise the 3DMemFreeDedected flag", 0) \
+X( 40, RGXFW_GROUP_SPM, RGXFW_SF_SPM_3DMEMFREE_FLAG_SET, "Raise the 3DMemFreeDetected flag", 0) \
 X( 41, RGXFW_GROUP_SPM, RGXFW_SF_SPM_STATE_WAIT_FOR_PENDING_GROW, "Wait for pending grow on Freelist 0x%08x", 1) \
 X( 42, RGXFW_GROUP_SPM, RGXFW_SF_SPM_ZSBUFFER_BACKING_REQUEST_FAILED, "ZS Buffer failed to be populated (ID=0x%08x)", 1) \
 X( 43, RGXFW_GROUP_SPM, RGXFW_SF_SPM_FL_GROW_DEBUG, "Grow update inconsistency: FL addr: 0x%02x%08x, curr pages: %u, ready: %u, new: %u", 5) \
@@ -755,7 +777,7 @@ X( 43, RGXFW_GROUP_POW, RGXFW_SF_POW_HWREQ_RESULT, "HW Request Completed(1)/Abor
 X( 44, RGXFW_GROUP_POW, RGXFW_SF_POW_DUSTS_CHANGE_FIX_59042_DEPRECATED, "Allowed number of dusts is %u due to BRN59042.", 1) \
 X( 45, RGXFW_GROUP_POW, RGXFW_SF_POW_HOST_TIMEOUT_NOTIFICATION, "Host timed out while waiting for a forced idle state. Pow state int: 0x%x, ext: 0x%x, flags: 0x%x", 3) \
 X( 46, RGXFW_GROUP_POW, RGXFW_SF_POW_CHECK, "Check Pow state: Int: 0x%x, Ext: 0x%x, Pow flags: 0x%x, Fence Counters: Check: %u - Update: %u", 5) \
-X( 47, RGXFW_GROUP_POW, RGXFW_SF_POW_PDVFS_GPIO_SEND, "Proactive DVFS: OPP Point Sent = 0x%x, Success = 0x%x", 2) \
+X( 47, RGXFW_GROUP_POW, RGXFW_SF_POW_PDVFS_GPIO_SEND, "Custom/Proactive DVFS: OPP Point Sent = 0x%x, Success = 0x%x", 2) \
 X( 48, RGXFW_GROUP_POW, RGXFW_SF_POW_PDVFS_TO_IDLE, "Proactive DVFS: GPU transitioned to idle", 0) \
 X( 49, RGXFW_GROUP_POW, RGXFW_SF_POW_PDVFS_TO_ACTIVE, "Proactive DVFS: GPU transitioned to active", 0) \
 X( 50, RGXFW_GROUP_POW, RGXFW_SF_POW_POWDUMP_BUFFER_SIZE, "Power counter dumping: Data truncated writing register %u. Buffer too small.", 1) \
@@ -957,24 +979,74 @@ X( 23, RGXFW_GROUP_DBG, RGXFW_SF_DBG_6UNSIGNED, "%u %u %u %u %u %u", 6) \
 X( 24, RGXFW_GROUP_DBG, RGXFW_SF_DBG_7UNSIGNED, "%u %u %u %u %u %u %u", 7) \
 X( 25, RGXFW_GROUP_DBG, RGXFW_SF_DBG_8UNSIGNED, "%u %u %u %u %u %u %u %u", 8) \
 \
+X(  1, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_STATE_CHANGE, "[Host time %09u%09u%09u] Driver ID %u fw state transition request: from %u to %u (0-offline 1-ready 2-active 3-graceful_offloading 4-forced_offloading 5-cooldown). Status %u (1-ok 0-fail)", 7) \
+X(  2, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_MTS_PERMISSION_CHANGED, "[Host time %09u%09u%09u] Updated permission for Driver ID %u to perform MTS kicks: %u (1 = allowed, 0 = not allowed)", 5) \
+X(  3, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_INIT_CCBS, "[Host time %09u%09u%09u] Driver ID %u CCB init status: %u (1-ok 0-fail): kCCBCtl@0x%x kCCB@0x%x fwCCBCtl@0x%x fwCCB@0x%x", 9) \
+X(  4, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_INIT_CONFIG, "[Host time %09u%09u%09u] Initialised OS %u with config flags 0x%08x", 5) \
+X(  5, RGXFW_GROUP_VZ, RGXFW_SF_VZ_TIME_SLICE_MAX, "[Host time %09u%09u%09u] Time Slice: Update Failed, Max total allocations exceeded 100pc", 3)\
+X(  6, RGXFW_GROUP_VZ, RGXFW_SF_VZ_TIME_SLICE_DYNAMIC_LOW, "[Host time %09u%09u%09u] Time Slice: Dynamic time slice low, allocating zero time slice to dynamic drivers", 3)\
+X(  7, RGXFW_GROUP_VZ, RGXFW_SF_VZ_TIME_SLICE_UPDATE_SUCCESS, "[Host time %09u%09u%09u] Time Slice: Updated Successfully", 3)\
+X(  8, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_ISOLATION_GROUP_CHANGE, "[Host time %09u%09u%09u] Changing Driver ID %u's isolation group from %u to %u", 6) \
+X(  9, RGXFW_GROUP_VZ, RGXFW_SF_VZ_OS_PRIORITY_CHANGE, "[Host time %09u%09u%09u] Changing Driver ID %u's priority from %u to %u", 6) \
+X( 10, RGXFW_GROUP_VZ, RGXFW_SF_VZ_WDG_TRIGGER, "[Host time %09u%09u%09u] Driver ID %u failed to respond to the virtualisation watchdog in time. Timestamp of its last input = %u", 5) \
+\
+\
+X(  1, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_FBCDC_FAILURE_STATUS, "FBCDC: Core=0x%08x, Status=0x%08x, Signature status=0x%08x", 3) \
+X(  2, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_FBCDC_FAILURE_DETECTED, "FBCDC signature failure detected so block scheduling more work", 0) \
+X(  3, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_FBCDC_FAILURE_CLEARED, "FBCDC signature cleared which unlocks scheduling more work", 0) \
+X(  4, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_TRP_FAILURE, "TRP failure: %u", 1) \
+X(  5, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_SW_TRP_STATE, "SW TRP State: %u", 1) \
+X(  6, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_WGP_HW_KICK, "HW kick event (%u)", 1) \
+X(  7, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_WGP_CHECKSUMS, "GPU core (%u/%u): checksum 0x%08x vs. 0x%08x", 4) \
+X(  8, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_WGP_UNIT_CHECKSUMS, "GPU core (%u/%u), unit (%u,%u): checksum 0x%08x vs. 0x%08x", 6) \
+X(  9, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_HWR_CHECK_REG, "HWR: Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X( 10, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_HWR_USC_SLOTS_CHECK, "HWR: USC Core%u, ui32TotalSlotsUsedByDM=0x%08x, psDMHWCtl->ui32USCSlotsUsedByDM=0x%08x, bHWRNeeded=%u", 4) \
+X( 11, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_HWR_USC_REG_CHECK, "HWR: USC Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X( 12, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_TRP_STATE_HWRTDATA_DEPRECATED, "TRP HWRTData: 0x%08x, state: %u", 2) \
+X( 13, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_TRP_STATE_CNTX_DEPRECATED, "TRP Context: 0x%08x, state: %u", 2) \
+X( 14, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_TRP_FAILURE_CNTX, "TRP Context: 0x%08x, failure: %u", 2) \
+X( 15, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_TRP_UNEXPECTED_EVENT_DEPRECATED, "Unexpected TRP pass completion on DM: %u",1) \
+X( 16, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_ENABLED, "ICS enabled for DM: %u",1) \
+X( 17, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_INTERVAL,"ICS: interval: %u cycles, threshold: %u cycles",2) \
+X( 18, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_FAULT,"ICS fault detected, GPU cores mask 0x%08x",1) \
+X( 19, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_MODE,"Set ICS mode to: %u ",1) \
+X( 20, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_TESTS_COMPLETION_FAILURE,"ICS tests not completed in mode %u",1) \
+X( 21, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_ICS_TESTS_START_FAILURE,"ICS tests failed to start",0) \
+X( 22, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_SELF_TEST_START,"Start Safety self-test",0) \
+X( 23, RGXFW_GROUP_SAFETY, RGXFW_SF_SAFETY_SELF_TEST_END,"Safety self-test completed",0) \
+\
+X(  1, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HWR_CHECK_REG, "HWR: Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X(  2, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HWR_USC_SLOTS_CHECK, "HWR: USC Core%u, ui32TotalSlotsUsedByDM=0x%08x, psDMHWCtl->ui32USCSlotsUsedByDM=0x%08x, bHWRNeeded=%u", 4) \
+X(  3, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HWR_USC_REG_CHECK, "HWR: USC Core%u, Register=0x%08x, OldValue=0x%08x%08x, CurrValue=0x%08x%08x", 6) \
+X(  4, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_GPU, "Memory dump: Addr=0x%02x%08x, Size=%d, ContextId=%u, DM=%u", 5) \
+X(  5, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_GPU_DWORDS4, "  0x%02x%08x  %08x %08x %08x %08x", 6) \
+X(  6, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_GPU_DWORDS3, "  0x%02x%08x  %08x %08x %08x", 5) \
+X(  7, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_GPU_DWORDS2, "  0x%02x%08x  %08x %08x", 4) \
+X(  8, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_GPU_DWORDS1, "  0x%02x%08x  %08x", 3) \
+X(  9, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_FW, "Memory dump: Addr=0x%08x, Size=%d", 2) \
+X(  0, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_FW_DWORDS4, "  0x%08x  %08x %08x %08x %08x", 5) \
+X( 11, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_FW_DWORDS3, "  0x%08x  %08x %08x %08x", 4) \
+X( 12, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_FW_DWORDS2, "  0x%08x  %08x %08x", 3) \
+X( 13, RGXFW_GROUP_VERBOSE, RGXFW_SF_VERBOSE_HEXDUMP_FW_DWORDS1, "  0x%08x  %08x", 2) \
+\
 X(65535, RGXFW_GROUP_NULL, RGXFW_SF_LAST, "You should not use this string", 15)
 
 
 /*  The symbolic names found in the table above are assigned an ui32 value of
  *  the following format:
- *  31 30 28 27       20   19  16    15  12      11            0   bits
- *  -   ---   ---- ----     ----      ----        ---- ---- ----
- *     0-11: id number
- *    12-15: group id number
- *    16-19: number of parameters
- *    20-27: unused
- *    28-30: active: identify SF packet, otherwise regular int32
- *       31: reserved for signed/unsigned compatibility
+ *  31 30 28 26      20   19  16    15  12      11  10           0   bits
+ *  -   ---   --- ----     ----      ----        -   --- ---- ----
+ *        0-10: id number
+ *    12-15,11: group id number (bits 0-3 and bit 4)
+ *       16-19: number of parameters
+ *       20-26: unused
+ *       28-30: active: identify SF packet, otherwise regular int32
+ *          31: reserved for signed/unsigned compatibility
  *
  *   The following macro assigns those values to the enum generated SF ids list.
  */
 #define RGXFW_LOG_IDMARKER			(0x70000000U)
-#define RGXFW_LOG_CREATESFID(a,b,e) ((IMG_UINT32)(a) | ((IMG_UINT32)(b)<<12U) | ((IMG_UINT32)(e)<<16U)) | RGXFW_LOG_IDMARKER
+#define RGXFW_LOG_CREATESFID(a,b,e) ((IMG_UINT32)(a) | (((IMG_UINT32)(b)&0x10U)<<7U) | (((IMG_UINT32)(b)&0xFU)<<12U) | ((IMG_UINT32)(e)<<16U)) | RGXFW_LOG_IDMARKER
 
 #define RGXFW_LOG_IDMASK			(0xFFF00000U)
 #define RGXFW_LOG_VALIDID(I)		(((I) & RGXFW_LOG_IDMASK) == RGXFW_LOG_IDMARKER)
@@ -986,9 +1058,9 @@ typedef enum {
 } RGXFW_LOG_SFids;
 
 /* Return the group id number that the given (enum generated) id belongs to */
-#define RGXFW_SF_GID(x) (((IMG_UINT32)(x)>>12) & 0xfU)
+#define RGXFW_SF_GID(x) ((((IMG_UINT32)(x)>>12) & 0xfU)|(((IMG_UINT32)(x)>>7) & 0x10U))
 /* Return the id number that the given (enum generated) id belongs to */
-#define RGXFW_SF_ID(x) ((IMG_UINT32)(x) & 0xfffU)
+#define RGXFW_SF_ID(x) ((IMG_UINT32)(x) & 0x7ffU)
 /* Returns how many arguments the SF(string format) for the given (enum generated) id requires */
 #define RGXFW_SF_PARAMNUM(x) (((IMG_UINT32)(x)>>16) & 0xfU)
 
diff --git a/drivers/gpu/drm/img-rogue/rgx_fwif_shared.h b/drivers/gpu/drm/img-rogue/rgx_fwif_shared.h
index 3fe7eb5fe3b4..ccab45ae8fc0 100644
--- a/drivers/gpu/drm/img-rogue/rgx_fwif_shared.h
+++ b/drivers/gpu/drm/img-rogue/rgx_fwif_shared.h
@@ -84,11 +84,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 #define RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE	(1024U)
 
-typedef struct RGXFWIF_DEV_VIRTADDR_
-{
-	IMG_UINT32	ui32Addr;
-} RGXFWIF_DEV_VIRTADDR;
-
 typedef struct
 {
 	IMG_DEV_VIRTADDR        RGXFW_ALIGN psDevVirtAddr;
@@ -263,12 +258,6 @@ typedef struct
 		IMG_UINT64	uTAReg_VDM_CONTEXT_RESUME_TASK0; /*!< VDM context resume task 0 */
 		IMG_UINT64	uTAReg_VDM_CONTEXT_RESUME_TASK1; /*!< VDM context resume task 1 */
 		IMG_UINT64	uTAReg_VDM_CONTEXT_RESUME_TASK2; /*!< VDM context resume task 2 */
-
-		IMG_UINT64	uTAReg_VDM_CONTEXT_STORE_TASK3;
-		IMG_UINT64	uTAReg_VDM_CONTEXT_STORE_TASK4;
-
-		IMG_UINT64	uTAReg_VDM_CONTEXT_RESUME_TASK3;
-		IMG_UINT64	uTAReg_VDM_CONTEXT_RESUME_TASK4;
 	} asTAState[2];
 
 } RGXFWIF_TAREGISTERS_CSWITCH;
@@ -331,6 +320,11 @@ typedef enum
 	RGX_CONTEXT_RESET_REASON_HOST_WDG_FW_ERR     = 15,	/*!< Host watchdog detected FW error */
 	RGX_CONTEXT_GEOM_OOM_DISABLED                = 16,	/*!< Geometry DM OOM event is not allowed */
 	RGX_CONTEXT_PVRIC_SIGNATURE_MISMATCH         = 17,	/*!< PVRIC Signature mismatch */
+	RGX_CONTEXT_RESET_REASON_FW_PTE_PARITY_ERR   = 18,	/*!< Parity error in MMU Page Table Entry */
+	RGX_CONTEXT_RESET_REASON_FW_PARITY_ERR       = 19,	/*!< Parity error in MH, system bus or Control Status registers */
+	RGX_CONTEXT_RESET_REASON_GPU_PARITY_HWR      = 20,	/*!< Parity error in system bus or Control Status registers */
+	RGX_CONTEXT_RESET_REASON_GPU_LATENT_HWR      = 21,	/*!< Latent/ICS signature mismatch error */
+	RGX_CONTEXT_RESET_REASON_DCLS_ERR            = 22,	/*!< Dual Core Lock Step FW error detected */
 } RGX_CONTEXT_RESET_REASON;
 
 /*!
@@ -348,12 +342,797 @@ typedef struct
 
 #define RGX_HEAP_UM_USC_RESERVED_SIZE               DEVMEM_HEAP_RESERVED_SIZE_GRANULARITY
 #define RGX_HEAP_UM_USC_RESERVED_REGION_OFFSET      0
-#define RGX_HEAP_USC_RESERVED_TOTAL_SIZE            RGX_HEAP_UM_USC_RESERVED_SIZE
+#define RGX_HEAP_KM_USC_RESERVED_REGION_OFFSET      RGX_HEAP_UM_USC_RESERVED_SIZE
 
 #define RGX_HEAP_UM_GENERAL_RESERVED_SIZE           DEVMEM_HEAP_RESERVED_SIZE_GRANULARITY
 #define RGX_HEAP_UM_GENERAL_RESERVED_REGION_OFFSET  0
 #define RGX_HEAP_KM_GENERAL_RESERVED_REGION_OFFSET  RGX_HEAP_UM_GENERAL_RESERVED_SIZE
 
+/*************************************************************************/ /*!
+ Logging type
+*/ /**************************************************************************/
+#define RGXFWIF_LOG_TYPE_NONE			0x00000000U
+#define RGXFWIF_LOG_TYPE_TRACE			0x00000001U
+#define RGXFWIF_LOG_TYPE_GROUP_MAIN		0x00000002U
+#define RGXFWIF_LOG_TYPE_GROUP_MTS		0x00000004U
+#define RGXFWIF_LOG_TYPE_GROUP_CLEANUP	0x00000008U
+#define RGXFWIF_LOG_TYPE_GROUP_CSW		0x00000010U
+#define RGXFWIF_LOG_TYPE_GROUP_BIF		0x00000020U
+#define RGXFWIF_LOG_TYPE_GROUP_PM		0x00000040U
+#define RGXFWIF_LOG_TYPE_GROUP_RTD		0x00000080U
+#define RGXFWIF_LOG_TYPE_GROUP_SPM		0x00000100U
+#define RGXFWIF_LOG_TYPE_GROUP_POW		0x00000200U
+#define RGXFWIF_LOG_TYPE_GROUP_HWR		0x00000400U
+#define RGXFWIF_LOG_TYPE_GROUP_HWP		0x00000800U
+#define RGXFWIF_LOG_TYPE_GROUP_RPM		0x00001000U
+#define RGXFWIF_LOG_TYPE_GROUP_DMA		0x00002000U
+#define RGXFWIF_LOG_TYPE_GROUP_MISC		0x00004000U
+#define RGXFWIF_LOG_TYPE_GROUP_VZ		0x00008000U
+#define RGXFWIF_LOG_TYPE_GROUP_SAFETY	0x00010000U
+#define RGXFWIF_LOG_TYPE_GROUP_VERBOSE	0x00020000U
+#define RGXFWIF_LOG_TYPE_GROUP_CUSTOMER	0x00040000U
+#define RGXFWIF_LOG_TYPE_GROUP_DEBUG	0x80000000U
+#define RGXFWIF_LOG_TYPE_GROUP_MASK		0x8007FFFEU
+#define RGXFWIF_LOG_TYPE_MASK			0x8007FFFFU
+
+/* String used in pvrdebug -h output */
+#define RGXFWIF_LOG_GROUPS_STRING_LIST   "main,mts,cleanup,csw,bif,pm,rtd,spm,pow,hwr,hwp,rpm,dma,misc,vz,safety,verbose,customer,debug"
+
+/* Table entry to map log group strings to log type value */
+typedef struct {
+	const IMG_CHAR* pszLogGroupName;
+	IMG_UINT32      ui32LogGroupType;
+} RGXFWIF_LOG_GROUP_MAP_ENTRY;
+
+/*
+  Macro for use with the RGXFWIF_LOG_GROUP_MAP_ENTRY type to create a lookup
+  table where needed. Keep log group names short, no more than 20 chars.
+*/
+#define RGXFWIF_LOG_GROUP_NAME_VALUE_MAP { "none",    RGXFWIF_LOG_TYPE_NONE }, \
+                                         { "main",    RGXFWIF_LOG_TYPE_GROUP_MAIN }, \
+                                         { "mts",     RGXFWIF_LOG_TYPE_GROUP_MTS }, \
+                                         { "cleanup", RGXFWIF_LOG_TYPE_GROUP_CLEANUP }, \
+                                         { "csw",     RGXFWIF_LOG_TYPE_GROUP_CSW }, \
+                                         { "bif",     RGXFWIF_LOG_TYPE_GROUP_BIF }, \
+                                         { "pm",      RGXFWIF_LOG_TYPE_GROUP_PM }, \
+                                         { "rtd",     RGXFWIF_LOG_TYPE_GROUP_RTD }, \
+                                         { "spm",     RGXFWIF_LOG_TYPE_GROUP_SPM }, \
+                                         { "pow",     RGXFWIF_LOG_TYPE_GROUP_POW }, \
+                                         { "hwr",     RGXFWIF_LOG_TYPE_GROUP_HWR }, \
+                                         { "hwp",     RGXFWIF_LOG_TYPE_GROUP_HWP }, \
+                                         { "rpm",     RGXFWIF_LOG_TYPE_GROUP_RPM }, \
+                                         { "dma",     RGXFWIF_LOG_TYPE_GROUP_DMA }, \
+                                         { "misc",    RGXFWIF_LOG_TYPE_GROUP_MISC }, \
+                                         { "vz",      RGXFWIF_LOG_TYPE_GROUP_VZ }, \
+                                         { "safety",  RGXFWIF_LOG_TYPE_GROUP_SAFETY }, \
+                                         { "verbose", RGXFWIF_LOG_TYPE_GROUP_VERBOSE }, \
+                                         { "customer",RGXFWIF_LOG_TYPE_GROUP_CUSTOMER }, \
+                                         { "debug",   RGXFWIF_LOG_TYPE_GROUP_DEBUG }
+
+/* Used in print statements to display log group state, one %s per group defined */
+#define RGXFWIF_LOG_ENABLED_GROUPS_LIST_PFSPEC  "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"
+
+/* Used in a print statement to display log group state, one per group */
+#define RGXFWIF_LOG_ENABLED_GROUPS_LIST(types)  ((((types) & RGXFWIF_LOG_TYPE_GROUP_MAIN) != 0U)	?("main ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_MTS) != 0U)		?("mts ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_CLEANUP) != 0U)	?("cleanup ")	:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_CSW) != 0U)		?("csw ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_BIF) != 0U)		?("bif ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_PM) != 0U)		?("pm ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_RTD) != 0U)		?("rtd ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_SPM) != 0U)		?("spm ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_POW) != 0U)		?("pow ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_HWR) != 0U)		?("hwr ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_HWP) != 0U)		?("hwp ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_RPM) != 0U)		?("rpm ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_DMA) != 0U)		?("dma ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_MISC) != 0U)	?("misc ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_VZ) != 0U)		?("vz ")		:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_SAFETY) != 0U)	?("safety ")	:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_VERBOSE) != 0U)	?("verbose ")	:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_CUSTOMER) != 0U)?("customer ")	:("")),		\
+                                                ((((types) & RGXFWIF_LOG_TYPE_GROUP_DEBUG) != 0U)	?("debug ")		:(""))
+
+/*!
+ ******************************************************************************
+ * Trace Buffer
+ *****************************************************************************/
+
+/*! Min, Max, and Default size of RGXFWIF_TRACEBUF_SPACE in DWords */
+#define RGXFW_TRACE_BUF_MIN_SIZE_IN_DWORDS      8192U  /*  32KB */
+#define RGXFW_TRACE_BUF_DEFAULT_SIZE_IN_DWORDS 12000U  /* ~48KB */
+#define RGXFW_TRACE_BUF_MAX_SIZE_IN_DWORDS     32768U  /* 128KB */
+
+#define RGXFW_TRACE_BUFFER_ASSERT_SIZE 200U
+#if defined(RGXFW_META_SUPPORT_2ND_THREAD)
+#define RGXFW_THREAD_NUM 2U
+#else
+#define RGXFW_THREAD_NUM 1U
+#endif
+
+typedef struct
+{
+	IMG_CHAR	szPath[RGXFW_TRACE_BUFFER_ASSERT_SIZE];
+	IMG_CHAR	szInfo[RGXFW_TRACE_BUFFER_ASSERT_SIZE];
+	IMG_UINT32	ui32LineNum;
+} UNCACHED_ALIGN RGXFWIF_FILE_INFO_BUF;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_FILE_INFO_BUF) == 408,
+				"RGXFWIF_FILE_INFO_BUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/*!
+ * @Defgroup SRVAndFWTracing Services and Firmware Tracing data interface
+ * @Brief The document groups/lists the data structures and the interfaces related to Services and Firmware Tracing
+ * @{
+ */
+
+/*!
+ * @Brief Firmware trace buffer details
+ */
+typedef struct
+{
+	IMG_UINT32                         ui32TracePointer;          /*!< Trace pointer (write index into Trace Buffer) */
+	IMG_UINT32                         ui32WrapCount;             /*!< Number of times the Trace Buffer has wrapped */
+
+	RGXFWIF_DEV_VIRTADDR               pui32RGXFWIfTraceBuffer;   /*!< Trace buffer address (FW address), to be used by firmware for writing into trace buffer */
+
+	RGXFWIF_FILE_INFO_BUF RGXFW_ALIGN  sAssertBuf;
+} UNCACHED_ALIGN RGXFWIF_TRACEBUF_SPACE;
+
+/*! @} End of Defgroup SRVAndFWTracing */
+
+/*!
+ * @InGroup SRVAndFWTracing
+ * @Brief Firmware trace control data
+ */
+typedef struct
+{
+	IMG_UINT32              ui32LogType;                  /*!< FW trace log group configuration */
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	RGXFWIF_TRACEBUF_SPACE  sTraceBuf[MAX_THREAD_NUM];  /*!< FW Trace buffer */
+#else
+	RGXFWIF_TRACEBUF_SPACE  sTraceBuf[RGXFW_THREAD_NUM];  /*!< FW Trace buffer */
+#endif
+	IMG_UINT32              ui32TraceBufSizeInDWords;     /*!< FW Trace buffer size in dwords, Member initialised only when sTraceBuf is actually allocated
+															(in RGXTraceBufferInitOnDemandResources) */
+	IMG_UINT32              ui32TracebufFlags;            /*!< Compatibility and other flags */
+} UNCACHED_ALIGN RGXFWIF_TRACEBUF;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_TRACEBUF) == 880,
+				"RGXFWIF_TRACEBUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/* Debug-info sub-fields */
+/* Bit 0: RGX_CR_EVENT_STATUS_MMU_PAGE_FAULT bit from RGX_CR_EVENT_STATUS register */
+#define RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SHIFT        (0U)
+#define RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SET          (1U << RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SHIFT)
+
+/* Bit 1: RGX_CR_BIF_MMU_ENTRY_PENDING bit from RGX_CR_BIF_MMU_ENTRY register */
+#define RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SHIFT     (1U)
+#define RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SET       (1U << RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SHIFT)
+
+/* Bit 2: RGX_CR_SLAVE_EVENT register is non-zero */
+#define RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SHIFT          (2U)
+#define RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SET            (1U << RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SHIFT)
+
+/* Bit 3-15: Unused bits */
+
+#define RGXFWT_DEBUG_INFO_STR_MAXLEN                  64
+#define RGXFWT_DEBUG_INFO_STR_PREPEND                 " (debug info: "
+#define RGXFWT_DEBUG_INFO_STR_APPEND                  ")"
+
+/* Table of debug info sub-field's masks and corresponding message strings
+ * to be appended to firmware trace
+ *
+ * Mask     : 16 bit mask to be applied to debug-info field
+ * String   : debug info message string
+ */
+
+#define RGXFWT_DEBUG_INFO_MSKSTRLIST \
+/*Mask,                                           String*/ \
+X(RGXFWT_DEBUG_INFO_MMU_PAGE_FAULT_SET,      "mmu pf") \
+X(RGXFWT_DEBUG_INFO_MMU_ENTRY_PENDING_SET,   "mmu pending") \
+X(RGXFWT_DEBUG_INFO_SLAVE_EVENTS_SET,        "slave events")
+
+/* Firmware trace time-stamp field breakup */
+
+/* RGX_CR_TIMER register read (48 bits) value*/
+#define RGXFWT_TIMESTAMP_TIME_SHIFT                   (0U)
+#define RGXFWT_TIMESTAMP_TIME_CLRMSK                  (IMG_UINT64_C(0xFFFF000000000000))
+
+/* Extra debug-info (16 bits) */
+#define RGXFWT_TIMESTAMP_DEBUG_INFO_SHIFT             (48U)
+#define RGXFWT_TIMESTAMP_DEBUG_INFO_CLRMSK            ~RGXFWT_TIMESTAMP_TIME_CLRMSK
+
+typedef struct
+{
+	IMG_UINT			bfOsState		: 3;
+	IMG_UINT			bfFLOk			: 1;
+	IMG_UINT			bfFLGrowPending	: 1;
+	IMG_UINT			bfReserved		: 27;
+} RGXFWIF_OS_RUNTIME_FLAGS;
+
+#define RGXFWIF_FWFAULTINFO_MAX		(8U)			/* Total number of FW fault logs stored */
+
+typedef struct
+{
+	IMG_UINT64 RGXFW_ALIGN	ui64CRTimer;
+	IMG_UINT64 RGXFW_ALIGN	ui64OSTimer;
+	IMG_UINT64 RGXFW_ALIGN	ui64Data;
+	RGXFWIF_FILE_INFO_BUF	sFaultBuf;
+} UNCACHED_ALIGN RGX_FWFAULTINFO;
+
+#define RGXFWIF_POW_STATES \
+  X(RGXFWIF_POW_OFF)			/* idle and handshaked with the host (ready to full power down) */ \
+  X(RGXFWIF_POW_ON)				/* running HW commands */ \
+  X(RGXFWIF_POW_FORCED_IDLE)	/* forced idle */ \
+  X(RGXFWIF_POW_IDLE)			/* idle waiting for host handshake */
+
+typedef enum
+{
+#define X(NAME) NAME,
+	RGXFWIF_POW_STATES
+#undef X
+} RGXFWIF_POW_STATE;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+#define MAX_THREAD_NUM 2
+
+static_assert(RGXFW_THREAD_NUM <= MAX_THREAD_NUM,
+				"RGXFW_THREAD_NUM is outside of allowable range for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/* Firmware HWR states */
+#define RGXFWIF_HWR_HARDWARE_OK			(IMG_UINT32_C(0x1) << 0U)	/*!< The HW state is ok or locked up */
+#define RGXFWIF_HWR_RESET_IN_PROGRESS	(IMG_UINT32_C(0x1) << 1U)	/*!< Tells if a HWR reset is in progress */
+#define RGXFWIF_HWR_GENERAL_LOCKUP		(IMG_UINT32_C(0x1) << 3U)	/*!< A DM unrelated lockup has been detected */
+#define RGXFWIF_HWR_DM_RUNNING_OK		(IMG_UINT32_C(0x1) << 4U)	/*!< At least one DM is running without being close to a lockup */
+#define RGXFWIF_HWR_DM_STALLING			(IMG_UINT32_C(0x1) << 5U)	/*!< At least one DM is close to lockup */
+#define RGXFWIF_HWR_FW_FAULT			(IMG_UINT32_C(0x1) << 6U)	/*!< The FW has faulted and needs to restart */
+#define RGXFWIF_HWR_RESTART_REQUESTED	(IMG_UINT32_C(0x1) << 7U)	/*!< The FW has requested the host to restart it */
+
+#define RGXFWIF_PHR_MODE_OFF			(0UL)
+#define RGXFWIF_PHR_MODE_RD_RESET		(1UL)
+
+typedef IMG_UINT32 RGXFWIF_HWR_STATEFLAGS;
+
+typedef IMG_UINT32 RGXFWIF_HWR_RECOVERYFLAGS;
+
+/*! @Brief Firmware system data shared with the Host driver */
+typedef struct
+{
+	IMG_UINT32                 ui32ConfigFlags;                       /*!< Configuration flags from host */
+	IMG_UINT32                 ui32ConfigFlagsExt;                    /*!< Extended configuration flags from host */
+	volatile RGXFWIF_POW_STATE ePowState;
+	struct {
+		volatile IMG_UINT32        ui32HWPerfRIdx;
+		volatile IMG_UINT32        ui32HWPerfWIdx;
+		volatile IMG_UINT32        ui32HWPerfWrapCount;
+	} sHWPerfCtrl; /* Struct used to inval/flush HWPerfCtrl members */
+	IMG_UINT32                 ui32HWPerfSize;                        /*!< Constant after setup, needed in FW */
+	IMG_UINT32                 ui32HWPerfDropCount;                   /*!< The number of times the FW drops a packet due to buffer full */
+
+	/* ui32HWPerfUt, ui32FirstDropOrdinal, ui32LastDropOrdinal only valid when FW is built with
+	 * RGX_HWPERF_UTILIZATION & RGX_HWPERF_DROP_TRACKING defined in rgxfw_hwperf.c */
+	IMG_UINT32                 ui32HWPerfUt;                          /*!< Buffer utilisation, high watermark of bytes in use */
+	IMG_UINT32                 ui32FirstDropOrdinal;                  /*!< The ordinal of the first packet the FW dropped */
+	IMG_UINT32                 ui32LastDropOrdinal;                   /*!< The ordinal of the last packet the FW dropped */
+	RGXFWIF_OS_RUNTIME_FLAGS   asOsRuntimeFlagsMirror[RGXFW_MAX_NUM_OSIDS];/*!< State flags for each Operating System mirrored from Fw coremem */
+	RGX_FWFAULTINFO            sFaultInfo[RGXFWIF_FWFAULTINFO_MAX];   /*!< Firmware fault info */
+	IMG_UINT32                 ui32FWFaults;                          /*!< Firmware faults count */
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_UINT32                 aui32CrPollAddr[MAX_THREAD_NUM];     /*!< Failed poll address */
+	IMG_UINT32                 aui32CrPollMask[MAX_THREAD_NUM];     /*!< Failed poll mask */
+	IMG_UINT32                 aui32CrPollCount[MAX_THREAD_NUM];    /*!< Failed poll count */
+#else
+	IMG_UINT32                 aui32CrPollAddr[RGXFW_THREAD_NUM];     /*!< Failed poll address */
+	IMG_UINT32                 aui32CrPollMask[RGXFW_THREAD_NUM];     /*!< Failed poll mask */
+	IMG_UINT32                 aui32CrPollCount[RGXFW_THREAD_NUM];    /*!< Failed poll count */
+#endif
+	IMG_UINT64 RGXFW_ALIGN     ui64StartIdleTime;
+	IMG_UINT32                 aui32TSMirror[RGXFW_MAX_NUM_OSIDS];    /*!< Array of time slice per OS Mirrored from the FW */
+
+#if defined(SUPPORT_RGXFW_STATS_FRAMEWORK) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
+#define RGXFWIF_STATS_FRAMEWORK_LINESIZE    (8)
+#define RGXFWIF_STATS_FRAMEWORK_MAX         (2048*RGXFWIF_STATS_FRAMEWORK_LINESIZE)
+	IMG_UINT32 RGXFW_ALIGN     aui32FWStatsBuf[RGXFWIF_STATS_FRAMEWORK_MAX];
+#endif
+	RGXFWIF_HWR_STATEFLAGS     ui32HWRStateFlags; /*!< Firmware's Current HWR state */
+	RGXFWIF_HWR_RECOVERYFLAGS  aui32HWRRecoveryFlags[RGXFWIF_DM_MAX]; /*!< Each DM's HWR state */
+	IMG_UINT32                 ui32FwSysDataFlags;                      /*!< Compatibility and other flags */
+	IMG_UINT32                 ui32McConfig;                            /*!< Identify whether MC config is P-P or P-S */
+	IMG_UINT32                 ui32MemFaultCheck;                       /*!< Device mem fault check on PCI systems */
+} UNCACHED_ALIGN RGXFWIF_SYSDATA;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_SYSDATA) == 3624,
+				"RGXFWIF_SYSDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER == 3624");
+#endif
+
+#if defined(PVRSRV_STALLED_CCB_ACTION)
+#define PVR_SLR_LOG_ENTRIES 10U
+#define PVR_SLR_LOG_STRLEN  30 /*!< MAX_CLIENT_CCB_NAME not visible to this header */
+
+typedef struct
+{
+	IMG_UINT64 RGXFW_ALIGN	ui64Timestamp;
+	IMG_UINT32				ui32FWCtxAddr;
+	IMG_UINT32				ui32NumUFOs;
+	IMG_CHAR				aszCCBName[PVR_SLR_LOG_STRLEN];
+} UNCACHED_ALIGN RGXFWIF_SLR_ENTRY;
+#endif
+
+#define RGXFWIF_OFFLINE_DATA_BUFFER_SIZE_IN_WORDS (128U)
+
+/*!
+ * @InGroup ContextSwitching
+ * @Brief Firmware per-os data and configuration
+ */
+typedef struct
+{
+	IMG_UINT32                 ui32FwOsConfigFlags;                   /*!< Configuration flags from an OS */
+	IMG_UINT32                 ui32FWSyncCheckMark;                   /*!< Markers to signal that the host should perform a full sync check */
+	IMG_UINT32                 ui32HostSyncCheckMark;                  /*!< Markers to signal that the Firmware should perform a full sync check */
+#if defined(PVRSRV_STALLED_CCB_ACTION) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_UINT32                 ui32ForcedUpdatesRequested;
+	IMG_UINT8                  ui8SLRLogWp;
+	RGXFWIF_SLR_ENTRY          sSLRLogFirst;
+	RGXFWIF_SLR_ENTRY          sSLRLog[PVR_SLR_LOG_ENTRIES];
+	IMG_UINT64 RGXFW_ALIGN     ui64LastForcedUpdateTime;
+#endif
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	volatile IMG_UINT32        aui32InterruptCount[MAX_THREAD_NUM]; /*!< Interrupt count from Threads > */
+#else
+	volatile IMG_UINT32        aui32InterruptCount[RGXFW_THREAD_NUM]; /*!< Interrupt count from Threads > */
+#endif
+	IMG_UINT32                 ui32KCCBCmdsExecuted;                  /*!< Executed Kernel CCB command count */
+	RGXFWIF_DEV_VIRTADDR       sPowerSync;                            /*!< Sync prim used to signal the host the power off state */
+	IMG_UINT32                 ui32FwOsDataFlags;                       /*!< Compatibility and other flags */
+	IMG_UINT32                 aui32OfflineBuffer[RGXFWIF_OFFLINE_DATA_BUFFER_SIZE_IN_WORDS];
+} UNCACHED_ALIGN RGXFWIF_OSDATA;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_OSDATA) == 584,
+				"RGXFWIF_OSDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+/*!
+ ******************************************************************************
+ * HWR Data
+ *****************************************************************************/
+/*!
+ * @Defgroup HWRInfo FW HWR shared data interface
+ * @Brief Types grouping data structures and defines used in realising the HWR record.
+ * @{
+ */
+
+#define RGXFW_PROCESS_NAME_LEN	(16)
+
+/*! @Brief HWR Lockup types */
+typedef enum
+{
+	RGX_HWRTYPE_UNKNOWNFAILURE = 0, /*!< Unknown failure */
+	RGX_HWRTYPE_OVERRUN        = 1, /*!< DM overrun */
+	RGX_HWRTYPE_POLLFAILURE    = 2, /*!< Poll failure */
+	RGX_HWRTYPE_BIF0FAULT      = 3, /*!< BIF0 fault */
+	RGX_HWRTYPE_BIF1FAULT      = 4, /*!< BIF1 fault */
+	RGX_HWRTYPE_TEXASBIF0FAULT = 5, /*!< TEXASBIF0 fault */
+	RGX_HWRTYPE_MMUFAULT       = 6, /*!< MMU fault */
+	RGX_HWRTYPE_MMUMETAFAULT   = 7, /*!< MMU META fault */
+	RGX_HWRTYPE_MIPSTLBFAULT   = 8, /*!< MIPS TLB fault */
+	RGX_HWRTYPE_ECCFAULT       = 9, /*!< ECC fault */
+	RGX_HWRTYPE_MMURISCVFAULT  = 10, /*!< MMU RISCV fault */
+} RGX_HWRTYPE;
+
+#define RGXFWIF_HWRTYPE_BIF_BANK_GET(eHWRType) (((eHWRType) == RGX_HWRTYPE_BIF0FAULT) ? 0 : 1)
+
+#define RGXFWIF_HWRTYPE_PAGE_FAULT_GET(eHWRType) ((((eHWRType) == RGX_HWRTYPE_BIF0FAULT)      ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_BIF1FAULT)      ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_TEXASBIF0FAULT) ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_MMUFAULT)       ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_MMUMETAFAULT)   ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_MIPSTLBFAULT)   ||       \
+                                                   ((eHWRType) == RGX_HWRTYPE_MMURISCVFAULT)) ? true : false)
+
+/************************
+ *  GPU HW error codes  *
+ ************************/
+typedef enum
+{
+	RGX_HW_ERR_NA = 0x0,
+	RGX_HW_ERR_PRIMID_FAILURE_DURING_DMKILL = 0x101,
+} RGX_HW_ERR;
+
+typedef struct
+{
+	IMG_UINT64	RGXFW_ALIGN		ui64BIFReqStatus; /*!< BIF request status */
+	IMG_UINT64	RGXFW_ALIGN		ui64BIFMMUStatus; /*!< MMU status */
+	IMG_UINT64	RGXFW_ALIGN		ui64PCAddress; /*!< phys address of the page catalogue */
+	IMG_UINT64	RGXFW_ALIGN		ui64Reserved;
+} RGX_BIFINFO;
+
+typedef struct
+{
+	IMG_UINT32 ui32FaultGPU; /*!< ECC fault in GPU */
+} RGX_ECCINFO;
+
+typedef struct
+{
+	IMG_UINT64	RGXFW_ALIGN		aui64MMUStatus[2]; /*!< MMU status */
+	IMG_UINT64	RGXFW_ALIGN		ui64PCAddress; /*!< phys address of the page catalogue */
+	IMG_UINT64	RGXFW_ALIGN		ui64Reserved;
+} RGX_MMUINFO;
+
+typedef struct
+{
+	IMG_UINT32	ui32ThreadNum; /*!< Thread ID performing poll operation */
+	IMG_UINT32	ui32CrPollAddr; /*!< CR Poll Address */
+	IMG_UINT32	ui32CrPollMask; /*!< CR Poll mask */
+	IMG_UINT32	ui32CrPollLastValue; /*!< CR Poll last value */
+	IMG_UINT64	RGXFW_ALIGN ui64Reserved;
+} UNCACHED_ALIGN RGX_POLLINFO;
+
+typedef struct
+{
+	IMG_UINT32 ui32BadVAddr; /*!< VA address */
+	IMG_UINT32 ui32EntryLo;
+} RGX_TLBINFO;
+
+/*! @Brief Structure to keep information specific to a lockup e.g. DM, timer, lockup type etc. */
+typedef struct
+{
+	union
+	{
+		RGX_BIFINFO  sBIFInfo; /*!< BIF failure details */
+		RGX_MMUINFO  sMMUInfo; /*!< MMU failure details */
+		RGX_POLLINFO sPollInfo; /*!< Poll failure details */
+		RGX_TLBINFO  sTLBInfo; /*!< TLB failure details */
+		RGX_ECCINFO  sECCInfo; /*!< ECC failure details */
+	} uHWRData;
+
+	IMG_UINT64 RGXFW_ALIGN ui64CRTimer; /*!< Timer value at the time of lockup */
+	IMG_UINT64 RGXFW_ALIGN ui64OSTimer; /*!< OS timer value at the time of lockup */
+	IMG_UINT32             ui32FrameNum; /*!< Frame number of the workload */
+	IMG_UINT32             ui32PID; /*!< PID belonging to the workload */
+	IMG_UINT32             ui32ActiveHWRTData; /*!< HWRT data of the workload */
+	IMG_UINT32             ui32HWRNumber; /*!< HWR number */
+	IMG_UINT32             ui32EventStatus; /*!< Core specific event status register at the time of lockup */
+	IMG_UINT32             ui32HWRRecoveryFlags; /*!< DM state flags */
+	RGX_HWRTYPE            eHWRType; /*!< Type of lockup */
+	RGXFWIF_DM             eDM; /*!< Recovery triggered for the DM */
+	IMG_UINT32             ui32CoreID; /*!< Core ID of the GPU */
+	RGX_HW_ERR             eHWErrorCode; /*!< Error code used to determine HW fault */
+	IMG_UINT64 RGXFW_ALIGN ui64CRTimeOfKick; /*!< Workload kick time */
+	IMG_UINT64 RGXFW_ALIGN ui64CRTimeHWResetStart; /*!< HW reset start time */
+	IMG_UINT64 RGXFW_ALIGN ui64CRTimeHWResetFinish; /*!< HW reset stop time */
+	IMG_UINT64 RGXFW_ALIGN ui64CRTimeFreelistReady; /*!< freelist ready time on the last HWR */
+	IMG_CHAR   RGXFW_ALIGN szProcName[RGXFW_PROCESS_NAME_LEN]; /*!< User process name */
+} UNCACHED_ALIGN RGX_HWRINFO;
+
+#define RGXFWIF_HWINFO_MAX_FIRST 8U							/* Number of first HWR logs recorded (never overwritten by newer logs) */
+#define RGXFWIF_HWINFO_MAX_LAST 8U							/* Number of latest HWR logs (older logs are overwritten by newer logs) */
+#define RGXFWIF_HWINFO_MAX (RGXFWIF_HWINFO_MAX_FIRST + RGXFWIF_HWINFO_MAX_LAST)	/* Total number of HWR logs stored in a buffer */
+#define RGXFWIF_HWINFO_LAST_INDEX (RGXFWIF_HWINFO_MAX - 1U)	/* Index of the last log in the HWR log buffer */
+
+/*! @Brief Firmware HWR information structure allocated by the Services and used by the Firmware to update recovery information. */
+typedef struct
+{
+	RGX_HWRINFO sHWRInfo[RGXFWIF_HWINFO_MAX]; /*!< Max number of recovery record */
+	IMG_UINT32  ui32HwrCounter; /*!< HWR counter used in FL reconstruction */
+	IMG_UINT32  ui32WriteIndex; /*!< Index for updating recovery information in sHWRInfo */
+	IMG_UINT32  ui32DDReqCount; /*!< Count of DebugDump requested to the host after recovery */
+	IMG_UINT32  ui32HWRInfoBufFlags; /* Compatibility and other flags */
+	IMG_UINT32  aui32HwrDmLockedUpCount[RGXFWIF_DM_MAX]; /*!< Lockup count for each DM */
+	IMG_UINT32  aui32HwrDmOverranCount[RGXFWIF_DM_MAX]; /*!< Overrun count for each DM */
+	IMG_UINT32  aui32HwrDmRecoveredCount[RGXFWIF_DM_MAX]; /*!< Lockup + Overrun count for each DM */
+	IMG_UINT32  aui32HwrDmFalseDetectCount[RGXFWIF_DM_MAX]; /*!< False lockup detection count for each DM */
+} UNCACHED_ALIGN RGXFWIF_HWRINFOBUF;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_HWRINFOBUF) == 2336,
+				"RGXFWIF_HWRINFOBUF is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/*! @} End of HWRInfo */
+
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCCB;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_CCCB_CTL;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_COMMONCTX_STATE;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_RF_CMD;
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FWMEMCONTEXT;
+
+/*!
+ * @InGroup RenderTarget
+ * @Brief Firmware Freelist holding usage state of the Parameter Buffers
+ */
+typedef struct
+{
+	IMG_DEV_VIRTADDR	RGXFW_ALIGN psFreeListDevVAddr;	/*!< Freelist page table base */
+	IMG_UINT64		RGXFW_ALIGN ui64CurrentDevVAddr;/*!< Freelist page table entry for current free page */
+	IMG_UINT32		ui32CurrentStackTop;		/*!< Freelist current free page */
+	IMG_UINT32		ui32MaxPages;			/*!< Max no. of pages can be added to the freelist */
+	IMG_UINT32		ui32GrowPages;			/*!< No pages to add in each freelist grow */
+	IMG_UINT32		ui32CurrentPages;		/*!< Total no. of pages made available to the PM HW */
+	IMG_UINT32		ui32AllocatedPageCount;		/*!< No. of pages allocated by PM HW */
+	IMG_UINT32		ui32AllocatedMMUPageCount;	/*!< No. of pages allocated for GPU MMU for PM*/
+#if defined(SUPPORT_SHADOW_FREELISTS) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_UINT32		ui32HWRCounter;
+	PRGXFWIF_FWMEMCONTEXT	psFWMemContext;
+#endif
+	IMG_UINT32		ui32FreeListID;			/*!< Unique Freelist ID */
+	IMG_BOOL		bGrowPending;			/*!< Freelist grow is pending */
+	IMG_UINT32		ui32ReadyPages;			/*!< Reserved pages to be used only on PM OOM event */
+	IMG_UINT32		ui32FreelistFlags;		/*!< Compatibility and other flags */
+#if defined(SUPPORT_AGP) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_UINT32		ui32PmGlobalPb;			/*!< PM Global PB on which Freelist is loaded */
+#endif
+} UNCACHED_ALIGN RGXFWIF_FREELIST;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_FREELIST) == 64,
+				"RGXFWIF_FREELIST is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+typedef struct {RGXFWIF_DEV_VIRTADDR sNext;
+                RGXFWIF_DEV_VIRTADDR sPrev;}	RGXFW_DLLIST_NODE;
+
+#define RGXFWIF_MAX_NUM_CANCEL_REQUESTS		(8U)		/* Maximum number of workload cancellation requests */
+
+/*!
+ * @InGroup WorkloadContexts
+ * @Brief Firmware Common Context (or FWCC)
+ */
+typedef struct RGXFWIF_FWCOMMONCONTEXT_
+{
+	/* CCB details for this firmware context */
+	PRGXFWIF_CCCB_CTL		psCCBCtl;				/*!< CCB control */
+	PRGXFWIF_CCCB			psCCB;					/*!< CCB base */
+
+	/* Context suspend state */
+	PRGXFWIF_COMMONCTX_STATE	RGXFW_ALIGN psContextState;		/*!< TA/3D context suspend state, read/written by FW */
+
+	/* Flags e.g. for context switching */
+	IMG_UINT32				ui32FWComCtxFlags;
+	IMG_INT32				i32Priority;  /*!< Priority level */
+	IMG_UINT32				ui32PrioritySeqNum;
+
+	/* Framework state */
+	PRGXFWIF_RF_CMD			RGXFW_ALIGN psRFCmd;		/*!< Register updates for Framework */
+
+	/* Misc and compatibility flags */
+	IMG_UINT32				ui32CompatFlags;
+
+	/* Statistic updates waiting to be passed back to the host... */
+	IMG_INT32				i32StatsNumStores;		/*!< Number of stores on this context since last update */
+	IMG_INT32				i32StatsNumOutOfMemory;		/*!< Number of OOMs on this context since last update */
+	IMG_INT32				i32StatsNumPartialRenders;	/*!< Number of PRs on this context since last update */
+	RGXFWIF_DM				eDM;				/*!< Data Master type */
+	RGXFW_DLLIST_NODE		RGXFW_ALIGN  sBufStalledNode;			/*!< List entry for the buffer stalled list */
+	IMG_UINT64				RGXFW_ALIGN  ui64CBufQueueCtrlAddr;	/*!< Address of the circular buffer queue pointers */
+
+	IMG_UINT64				RGXFW_ALIGN  ui64RobustnessAddress;
+	IMG_UINT32				ui32MaxDeadlineMS;			/*!< Max HWR deadline limit in ms */
+	bool					bReadOffsetNeedsReset;			/*!< Following HWR circular buffer read-offset needs resetting */
+
+	RGXFW_DLLIST_NODE		RGXFW_ALIGN sWaitingNode;		/*!< List entry for the waiting list */
+	RGXFW_DLLIST_NODE		RGXFW_ALIGN sRunNode;			/*!< List entry for the run list */
+	RGXFWIF_UFO				sLastFailedUFO;			/*!< UFO that last failed (or NULL) */
+
+	PRGXFWIF_FWMEMCONTEXT	psFWMemContext;					/*!< Memory context */
+
+	/* References to the host side originators */
+	IMG_UINT32				ui32ServerCommonContextID;	/*!< the Server Common Context */
+	IMG_UINT32				ui32PID;			/*!< associated process ID */
+
+	IMG_BOOL				bGeomOOMDisabled;		/*!< True when Geom DM OOM is not allowed */
+	IMG_CHAR				szProcName[RGXFW_PROCESS_NAME_LEN];	/*!< User process name */
+	IMG_UINT32				ui32DeferCount;		/*!< Number of context defers before forced scheduling of context */
+	IMG_UINT32				aui32FirstIntJobRefToCancel[RGXFWIF_MAX_NUM_CANCEL_REQUESTS];	/*!< Saved values of the beginning of range of IntJobRefs at and above which workloads will be discarded */
+	IMG_UINT32				aui32FirstValidIntJobRef[RGXFWIF_MAX_NUM_CANCEL_REQUESTS];	/*!< Saved values of the end of range of IntJobRef below which workloads will be discarded */
+	IMG_BOOL				bCancelRangesActive;	/*!< True if any active ranges in aui32FirstIntJobRefToCancel and aui32FirstValidIntJobRef arrays */
+	IMG_BOOL				bLastKickedCmdWasSafetyOnly;
+	IMG_UINT32				ui32UID;			/*!< associated process UID used in FW managed gpu work period hwperf events */
+} UNCACHED_ALIGN RGXFWIF_FWCOMMONCONTEXT;
+
+static_assert(sizeof(RGXFWIF_FWCOMMONCONTEXT) <= 256U,
+              "Size of structure RGXFWIF_FWCOMMONCONTEXT exceeds maximum expected size.");
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_FWCOMMONCONTEXT) == 168,
+				"RGXFWIF_FWCOMMONCONTEXT is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/*!
+ ******************************************************************************
+ * HWRTData
+ *****************************************************************************/
+
+typedef RGXFWIF_DEV_VIRTADDR  PRGXFWIF_FREELIST;
+
+/* HWRTData flags */
+/* Deprecated flags 1:0 */
+#define HWRTDATA_HAS_LAST_TA              (IMG_UINT32_C(1) << 2)
+#define HWRTDATA_PARTIAL_RENDERED         (IMG_UINT32_C(1) << 3)
+#define HWRTDATA_DISABLE_TILE_REORDERING  (IMG_UINT32_C(1) << 4)
+#define HWRTDATA_NEED_BRN65101_BLIT       (IMG_UINT32_C(1) << 5)
+#define HWRTDATA_FIRST_BRN65101_STRIP     (IMG_UINT32_C(1) << 6)
+#define HWRTDATA_NEED_BRN67182_2ND_RENDER (IMG_UINT32_C(1) << 7)
+#if defined(SUPPORT_AGP)
+#define HWRTDATA_GLOBAL_PB_NUMBER_BIT0    (IMG_UINT32_C(1) << 8)
+#if defined(SUPPORT_AGP4)
+#define HWRTDATA_GLOBAL_PB_NUMBER_BIT1    (IMG_UINT32_C(1) << 9)
+#endif
+#define HWRTDATA_GEOM_NEEDS_RESUME        (IMG_UINT32_C(1) << 10)
+#endif
+#if defined(SUPPORT_TRP)
+#define HWRTDATA_GEOM_TRP_IN_PROGRESS          (IMG_UINT32_C(1) << 9)
+#endif
+
+typedef enum
+{
+	RGXFWIF_RTDATA_STATE_NONE = 0,
+	RGXFWIF_RTDATA_STATE_KICKTA,
+	RGXFWIF_RTDATA_STATE_KICKTAFIRST,
+	RGXFWIF_RTDATA_STATE_TAFINISHED,
+	RGXFWIF_RTDATA_STATE_KICK3D,
+	RGXFWIF_RTDATA_STATE_3DFINISHED,
+	RGXFWIF_RTDATA_STATE_3DCONTEXTSTORED,
+	RGXFWIF_RTDATA_STATE_TAOUTOFMEM,
+	RGXFWIF_RTDATA_STATE_PARTIALRENDERFINISHED,
+	/* In case of HWR, we can't set the RTDATA state to NONE,
+	 * as this will cause any TA to become a first TA.
+	 * To ensure all related TA's are skipped, we use the HWR state */
+	RGXFWIF_RTDATA_STATE_HWR,
+	RGXFWIF_RTDATA_STATE_UNKNOWN = 0x7FFFFFFFU
+} RGXFWIF_RTDATA_STATE;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+#define MAX_FREELISTS_SIZE 3
+
+static_assert(RGXFW_MAX_FREELISTS <= MAX_FREELISTS_SIZE,
+				"RGXFW_MAX_FREELISTS is outside of allowable range for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+typedef struct
+{
+	IMG_BOOL							bTACachesNeedZeroing;
+
+	IMG_UINT32							ui32ScreenPixelMax;
+	IMG_UINT64							RGXFW_ALIGN ui64MultiSampleCtl;
+	IMG_UINT64							ui64FlippedMultiSampleCtl;
+	IMG_UINT32							ui32TPCStride;
+	IMG_UINT32							ui32TPCSize;
+	IMG_UINT32							ui32TEScreen;
+	IMG_UINT32							ui32MTileStride;
+	IMG_UINT32							ui32TEAA;
+	IMG_UINT32							ui32TEMTILE1;
+	IMG_UINT32							ui32TEMTILE2;
+	IMG_UINT32							ui32ISPMergeLowerX;
+	IMG_UINT32							ui32ISPMergeLowerY;
+	IMG_UINT32							ui32ISPMergeUpperX;
+	IMG_UINT32							ui32ISPMergeUpperY;
+	IMG_UINT32							ui32ISPMergeScaleX;
+	IMG_UINT32							ui32ISPMergeScaleY;
+	IMG_UINT32							uiRgnHeaderSize;
+	IMG_UINT32							ui32ISPMtileSize;
+} UNCACHED_ALIGN RGXFWIF_HWRTDATA_COMMON;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_HWRTDATA_COMMON) == 88,
+				"RGXFWIF_HWRTDATA_COMMON is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+typedef struct
+{
+	IMG_UINT32           ui32RenderTargetIndex;		//Render number
+	IMG_UINT32           ui32CurrentRenderTarget;	//index in RTA
+	IMG_UINT32           ui32ActiveRenderTargets;	//total active RTs
+	IMG_UINT32           ui32CumulActiveRenderTargets;   //total active RTs from the first TA kick, for OOM
+	RGXFWIF_DEV_VIRTADDR sValidRenderTargets;  //Array of valid RT indices
+	RGXFWIF_DEV_VIRTADDR sRTANumPartialRenders;  //Array of number of occurred partial renders per render target
+	IMG_UINT32           ui32MaxRTs;   //Number of render targets in the array
+	IMG_UINT32           ui32RTACtlFlags; /* Compatibility and other flags */
+} UNCACHED_ALIGN RGXFWIF_RTA_CTL;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_RTA_CTL) == 32,
+				"RGXFWIF_RTA_CTL is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/*!
+ * @InGroup RenderTarget
+ * @Brief Firmware Render Target data i.e. HWRTDATA used to hold the PM context
+ */
+typedef struct
+{
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN psPMMListDevVAddr;			/*!< MList Data Store */
+
+	IMG_UINT64			RGXFW_ALIGN ui64VCECatBase[1];			/*!< VCE Page Catalogue base */
+	IMG_UINT64			RGXFW_ALIGN ui64VCELastCatBase[1];
+	IMG_UINT64			RGXFW_ALIGN ui64TECatBase[1];			/*!< TE Page Catalogue base */
+	IMG_UINT64			RGXFW_ALIGN ui64TELastCatBase[1];
+	IMG_UINT64			RGXFW_ALIGN ui64AlistCatBase;			/*!< Alist Page Catalogue base */
+	IMG_UINT64			RGXFW_ALIGN ui64AlistLastCatBase;
+
+	IMG_UINT64			RGXFW_ALIGN ui64PMAListStackPointer;		/*!< Freelist page table entry for current Mlist page */
+	IMG_UINT32			ui32PMMListStackPointer;			/*!< Current Mlist page */
+
+	RGXFWIF_DEV_VIRTADDR		sHWRTDataCommonFwAddr;				/*!< Render target dimension dependent data */
+
+	IMG_UINT32			ui32HWRTDataFlags;
+	RGXFWIF_RTDATA_STATE		eState;						/*!< Current workload processing state of HWRTDATA */
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	PRGXFWIF_FREELIST		RGXFW_ALIGN apsFreeLists[MAX_FREELISTS_SIZE];	/*!< Freelist to use */
+	IMG_UINT32			aui32FreeListHWRSnapshot[MAX_FREELISTS_SIZE];
+#else
+	PRGXFWIF_FREELIST		RGXFW_ALIGN apsFreeLists[RGXFW_MAX_FREELISTS];	/*!< Freelist to use */
+	IMG_UINT32			aui32FreeListHWRSnapshot[RGXFW_MAX_FREELISTS];
+#endif
+
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN psVHeapTableDevVAddr;		/*!< VHeap table base */
+
+	RGXFWIF_RTA_CTL			sRTACtl;					/*!< Render target array data */
+
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN sTailPtrsDevVAddr;			/*!< Tail pointers base */
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN sMacrotileArrayDevVAddr;		/*!< Macrotiling array base */
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN sRgnHeaderDevVAddr;			/*!< Region headers base */
+	IMG_DEV_VIRTADDR		RGXFW_ALIGN sRTCDevVAddr;			/*!< Render target cache base */
+#if defined(RGX_FIRMWARE)
+	struct RGXFWIF_FWCOMMONCONTEXT_* RGXFW_ALIGN psOwnerGeom;
+#else
+	RGXFWIF_DEV_VIRTADDR		RGXFW_ALIGN pui32OwnerGeomNotUsedByHost;
+#endif
+#if defined(SUPPORT_TRP) && !defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_UINT32			ui32KickFlagsCopy;
+	IMG_UINT32			ui32TEPageCopy;
+	IMG_UINT32			ui32VCEPageCopy;
+#endif
+#if defined(SUPPORT_AGP) || defined(SUPPORT_OPEN_SOURCE_DRIVER)
+	IMG_BOOL			bTACachesNeedZeroing;
+#endif
+
+	RGXFWIF_CLEANUP_CTL		RGXFW_ALIGN_DCACHEL sCleanupState;					/*!< Render target clean up state */
+} RGXFW_ALIGN_DCACHEL RGXFWIF_HWRTDATA;
+
+#if defined(SUPPORT_OPEN_SOURCE_DRIVER)
+static_assert(sizeof(RGXFWIF_HWRTDATA) == 256,
+				"RGXFWIF_HWRTDATA is incorrect size for SUPPORT_OPEN_SOURCE_DRIVER");
+#endif
+
+/* Sync_checkpoint firmware object.
+ * This is the FW-addressable structure used to hold the sync checkpoint's
+ * state and other information which needs to be accessed by the firmware.
+ */
+typedef struct
+{
+	IMG_UINT32	ui32State;          /*!< Holds the current state of the sync checkpoint */
+	IMG_UINT32	ui32FwRefCount;     /*!< Holds the FW reference count (num of fences/updates processed) */
+} SYNC_CHECKPOINT_FW_OBJ;
+
+/* Bit mask Firmware can use to test if a checkpoint has signalled or errored */
+#define SYNC_CHECKPOINT_SIGNALLED_MASK (0x1 << 0)
+
+typedef enum
+{
+	RGXFWIF_REG_CFG_TYPE_PWR_ON=0,      /* Sidekick power event */
+	RGXFWIF_REG_CFG_TYPE_DUST_CHANGE,   /* Rascal / dust power event */
+	RGXFWIF_REG_CFG_TYPE_TA,            /* TA kick */
+	RGXFWIF_REG_CFG_TYPE_3D,            /* 3D kick */
+	RGXFWIF_REG_CFG_TYPE_CDM,           /* Compute kick */
+	RGXFWIF_REG_CFG_TYPE_TLA,           /* TLA kick */
+	RGXFWIF_REG_CFG_TYPE_TDM,           /* TDM kick */
+	RGXFWIF_REG_CFG_TYPE_ALL            /* Applies to all types. Keep as last element */
+} RGXFWIF_REG_CFG_TYPE;
+
+#define RGXFWIF_KM_USC_TQ_SHADER_CODE_OFFSET_BYTES                 RGX_HEAP_KM_USC_RESERVED_REGION_OFFSET
+#define RGXFWIF_KM_USC_TQ_SHADER_CODE_MAX_SIZE_BYTES               (1U << 19)
+
+#define RGX_HEAP_KM_USC_RESERVED_SIZE                              RGXFWIF_KM_USC_TQ_SHADER_CODE_MAX_SIZE_BYTES
+#define RGX_HEAP_USC_RESERVED_TOTAL_SIZE                           RGX_HEAP_UM_USC_RESERVED_SIZE + RGX_HEAP_KM_USC_RESERVED_SIZE
+
 #endif /*  RGX_FWIF_SHARED_H */
 
 /******************************************************************************
diff --git a/drivers/gpu/drm/img-rogue/rgx_heap_firmware.h b/drivers/gpu/drm/img-rogue/rgx_heap_firmware.h
index f02deeb1ea92..2628cd82e38e 100644
--- a/drivers/gpu/drm/img-rogue/rgx_heap_firmware.h
+++ b/drivers/gpu/drm/img-rogue/rgx_heap_firmware.h
@@ -114,13 +114,22 @@ static_assert((RGX_FIRMWARE_RAW_HEAP_SIZE) >= IMG_UINT32_C(0x800000), "MIPS GPU
  *  MMU objects required: 65536 PTEs; 16 PDEs; 1 PCE; */
 #define RGX_FIRMWARE_MAX_PAGETABLE_SIZE (1 * 1024 * 1024)
 
+#define RGX_FW_CONFIG_HEAP_SIZE (1 << RGX_FW_HEAP_SHIFT)
+#define RGX_FW_MAX_HEAP_SIZE (1 << 28)
 /*
- * The maximum configurable size via RGX_FW_HEAP_SHIFT is 32MiB (1<<25) and
- * the minimum is 4MiB (1<<22); the default firmware heap size is set to
- * maximum 32MiB.
+ * The maximum configurable size via RGX_FW_HEAP_SHIFT is 256MiB (1<<28) and
+ * the minimum is 4MiB (1<<22); the firmware heap size is dependent
+ * on the number of drivers supported.
  */
-#if defined(RGX_FW_HEAP_SHIFT) && (RGX_FW_HEAP_SHIFT < 22 || RGX_FW_HEAP_SHIFT > 25)
-#error "RGX_FW_HEAP_SHIFT is outside valid range [22, 25]"
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+	#if defined(RGX_FW_HEAP_SHIFT) && (RGX_FW_HEAP_SHIFT < 22 || (RGX_FW_CONFIG_HEAP_SIZE > (RGX_FW_MAX_HEAP_SIZE / RGX_NUM_DRIVERS_SUPPORTED)))
+	#error "RGX_FW_HEAP_SHIFT is outside valid range"
+	#endif
+#else
+	#if defined(RGX_FW_HEAP_SHIFT) && (RGX_FW_HEAP_SHIFT < 22 || RGX_FW_HEAP_SHIFT > 28)
+	#error "RGX_FW_HEAP_SHIFT is outside valid range [22,28]"
+	#endif
 #endif
 
+
 #endif /* RGX_HEAP_FIRMWARE_H */
diff --git a/drivers/gpu/drm/img-rogue/rgx_heaps.h b/drivers/gpu/drm/img-rogue/rgx_heaps.h
index e41e4002b2c4..f8fcfe1fe27e 100644
--- a/drivers/gpu/drm/img-rogue/rgx_heaps.h
+++ b/drivers/gpu/drm/img-rogue/rgx_heaps.h
@@ -52,7 +52,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGX_PDSCODEDATA_HEAP_IDENT          "PDS Code and Data"         /*!< RGX PDS Code/Data Heap Identifier */
 #define RGX_USCCODE_HEAP_IDENT              "USC Code"                  /*!< RGX USC Code Heap Identifier */
 #define RGX_VK_CAPT_REPLAY_HEAP_IDENT       "Vulkan Capture Replay"     /*!< RGX Vulkan capture replay buffer Heap Identifier */
-#define RGX_SIGNALS_HEAP_IDENT              "Signals"                   /*!< Signals Heap Identifier */
 #define RGX_FBCDC_HEAP_IDENT                "FBCDC"                     /*!< RGX FBCDC State Table Heap Identifier */
 #define RGX_FBCDC_LARGE_HEAP_IDENT          "Large FBCDC"               /*!< RGX Large FBCDC State Table Heap Identifier */
 #define RGX_CMP_MISSION_RMW_HEAP_IDENT      "Compute Mission RMW"       /*!< Compute Mission RMW Heap Identifier */
diff --git a/drivers/gpu/drm/img-rogue/rgx_heaps_server.h b/drivers/gpu/drm/img-rogue/rgx_heaps_server.h
new file mode 100644
index 000000000000..a1dd31113fa3
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/rgx_heaps_server.h
@@ -0,0 +1,86 @@
+/*************************************************************************/ /*!
+@File
+@Title          RGX heap (server) definitions
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+#if !defined RGX_HEAPS_SERVER_H
+#define RGX_HEAPS_SERVER_H
+
+#include "img_types.h"
+#include "rgx_heaps.h"
+
+/*
+ *  Supported log2 page size values for RGX_GENERAL_NON_4K_HEAP_ID
+ */
+#define RGX_HEAP_PAGE_SHIFTS_DEF \
+	X(4KB, 12U) \
+	X(16KB, 14U) \
+	X(64KB, 16U) \
+	X(256KB, 18U) \
+	X(1MB, 20U) \
+	X(2MB, 21U)
+
+typedef enum RGX_HEAP_PAGE_SHIFTS_TAG
+{
+#define X(_name, _shift) RGX_HEAP_ ## _name ## _PAGE_SHIFT = _shift,
+	RGX_HEAP_PAGE_SHIFTS_DEF
+#undef X
+} RGX_HEAP_PAGE_SHIFTS;
+
+/* Base and size alignment 2MB */
+#define RGX_HEAP_BASE_SIZE_ALIGN 0x200000UL
+#define RGX_GENERAL_SVM_BASE_SIZE_ALIGNMENT 0x8000UL
+
+/*************************************************************************/ /*!
+@Function       RGXGetValidHeapPageSizeMask
+@Description    Returns a bitmask indicating all supported virtual heap page sizes.
+
+@Return         IMG_UINT32  A 32-bit mask with enabled bits indicating valid
+                            page sizes.
+*/ /**************************************************************************/
+static inline IMG_UINT32 RGXGetValidHeapPageSizeMask(void)
+{
+	/* Generates a bit mask with the values of RGX_HEAP_PAGE_SHIFTS_DEF.
+	 * 0 is required for the first shift to properly bitwise OR. */
+#define X(_name, _shift) | (1 << _shift)
+	return 0 RGX_HEAP_PAGE_SHIFTS_DEF;
+#undef X
+}
+
+#endif /* RGX_HEAPS_SERVER_H */
diff --git a/drivers/gpu/drm/img-rogue/rgx_hwperf_common.h b/drivers/gpu/drm/img-rogue/rgx_hwperf_common.h
index 6f73eeee1743..23576c7832ac 100644
--- a/drivers/gpu/drm/img-rogue/rgx_hwperf_common.h
+++ b/drivers/gpu/drm/img-rogue/rgx_hwperf_common.h
@@ -146,6 +146,7 @@ typedef IMG_UINT32 RGX_HWPERF_EVENT_TYPE;
 #define RGX_HWPERF_HW_NULLKICK			0x2AU /*!< NULL event */
 
 #define RGX_HWPERF_HW_EVENT_RANGE1_LAST_TYPE 0x2AU
+#define RGX_HWPERF_TRACE_EVENT_GPU_WORK_PERIOD		0x2BU
 
 /*! context switch types 0x30..0x31 */
 #define RGX_HWPERF_CSW_START			0x30U /*!< HW context store started */
@@ -323,7 +324,7 @@ RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_V2_PACKET_HDR);
 #define RGX_HWPERF_TYPEID_META_DMA_MASK	0x00080000U
 #define RGX_HWPERF_TYPEID_M_CORE_MASK	0x00100000U
 #define RGX_HWPERF_TYPEID_PIPEDM_MASK	0x00200000U
-#define RGX_HWPERF_TYPEID_OSID_MASK		0x07000000U
+#define RGX_HWPERF_TYPEID_OSID_MASK		0x1f000000U
 
 /*! Meta thread macros for encoding the ID into the type field of a packet */
 #define RGX_HWPERF_META_THREAD_SHIFT	15U
@@ -422,17 +423,13 @@ static_assert(((IMG_UINT32)RGX_HWPERF_STREAM_ID_LAST - 1U) < (RGX_HWPERF_TYPEID_
  * Other Common Defines
  *****************************************************************************/
 
-/*! This macro is not a real array size, but indicates the array has a variable
- * length only known at run-time but always contains at least 1 element. The
- * final size of the array is deduced from the size field of a packet header.
- */
-#define RGX_HWPERF_ONE_OR_MORE_ELEMENTS  1U
-
-/*! This macro is not a real array size, but indicates the array is optional
- * and if present has a variable length only known at run-time. The final
- * size of the array is deduced from the size field of a packet header. */
-#define RGX_HWPERF_ZERO_OR_MORE_ELEMENTS 1U
-
+/*! Used to align structs using a flexible array member as the definition of the member
+ * size can change between C standards */
+#if (IMG_FLEX_ARRAY_MEMBER + 0)
+#define RGX_HWPERF_FLEX_ARRAY_ALIGN(_align_var) _align_var
+#else
+#define RGX_HWPERF_FLEX_ARRAY_ALIGN(...)
+#endif
 
 /*! Masks for use with the IMG_UINT32 ui32BlkInfo field */
 #define RGX_HWPERF_BLKINFO_BLKCOUNT_MASK	0xFFFF0000U
@@ -534,6 +531,18 @@ typedef struct
 RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_FW_DATA);
 
 
+/*! This structure holds the data of a gpu work period packet. */
+typedef struct
+{
+	IMG_UINT64 ui64GPUWorkPeriodStartTime;
+	IMG_UINT32 ui32UID;               /*!< Process identifier */
+	IMG_UINT32 ui32TimeCorrIndex;     /*!< Index to the time correlation at the beginning of gpu work period */
+	IMG_UINT32 ui32StartTimeCorrIndex;     /*!< Index to the time correlation at the time the packet was generated */
+	IMG_UINT32 ui32Padding2;          /*!< Reserved. To ensure correct alignment (not written in the packet) */
+} RGX_HWPERF_GPU_WORK_PERIOD_DATA;
+
+RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_GPU_WORK_PERIOD_DATA);
+
 /*! This structure holds the data of a hardware packet, including counters. */
 typedef struct
 {
@@ -555,8 +564,8 @@ typedef struct
 	IMG_UINT32 ui32GPUIdMask;         /*!< GPU IDs active within this event */
 	IMG_UINT32 ui32KickInfo;          /*!< <31..8> Back End start time lowest 24 bits <7..0> GPU Pipeline DM kick ID, 0 if not using Pipeline DMs */
 	IMG_UINT32 ui32KickEndTime;       /*!< Back End finish time for Pipeline DMs */
-	IMG_UINT32 aui32CountBlksStream[RGX_HWPERF_ZERO_OR_MORE_ELEMENTS]; /*!< Optional variable length Counter data */
-	IMG_UINT32 ui32Padding2;          /*!< Reserved. To ensure correct alignment (not written in the packet) */
+	IMG_UINT32 aui32CountBlksStream[IMG_FLEX_ARRAY_MEMBER]; /*!< Optional variable length Counter data */
+	RGX_HWPERF_FLEX_ARRAY_ALIGN(IMG_UINT32 uiReserved);          /*!< Reserved. To ensure correct alignment (not written in the packet) */
 } RGX_HWPERF_HW_DATA;
 
 RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_HW_DATA);
@@ -600,7 +609,8 @@ typedef struct
 	IMG_UINT32		ui32TxtActCyc;			/*!< Meta TXTACTCYC register value */
 	IMG_UINT32		ui32PerfCycle;			/*!< Cycle count. Used to measure HW context store latency */
 	IMG_UINT32		ui32PerfPhase;			/*!< Phase. Used to determine geometry content */
-	IMG_UINT32		ui32Padding[2];			/*!< Padding to 8 DWords */
+	IMG_UINT32		ui32GPUIdMask;			/*!< GPU IDs active within this event */
+	IMG_UINT32		ui32Padding;			/*!< Padding to 8 DWords */
 } RGX_HWPERF_CSW_DATA;
 
 RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_CSW_DATA);
@@ -674,8 +684,8 @@ typedef struct
 	IMG_UINT32  ui32StreamVersion;  /*!< Version word, HWPERF_PWR_EST_V1_SIG */
 	IMG_UINT32  ui32StreamSize;     /*!< Size of array in bytes of stream data
 	                                     held in the aui32StreamData member */
-	IMG_UINT32  aui32StreamData[RGX_HWPERF_ONE_OR_MORE_ELEMENTS]; /*!< Counter data */
-	IMG_UINT32  ui32Padding; /*!< Reserved. To ensure correct alignment */
+	IMG_UINT32  aui32StreamData[IMG_FLEX_ARRAY_MEMBER]; /*!< Counter data */
+	RGX_HWPERF_FLEX_ARRAY_ALIGN(IMG_UINT32 uiReserved); /*!< Reserved. To ensure correct alignment */
 } RGX_HWPERF_PWR_EST_DATA;
 
 RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_PWR_EST_DATA);
@@ -762,7 +772,7 @@ typedef union
 	struct
 	{
 		IMG_UINT32     ui32Frequency;            /*!< Required freq to achieve average 90% utilisation */
-		IMG_UINT32     ui32Utilisation;          /*!< GPU utilisation since last update */
+		IMG_UINT32     ui32Utilisation;          /*!< GPU utilisation since last update in percentage points (0..100%) */
 		IMG_UINT32     ui32TxtActCyc;            /*!< Meta TXTACTCYC register value */
 	} sDVFSCalc;
 
@@ -771,15 +781,15 @@ typedef union
 	{
 		IMG_UINT32     ui32CyclesPrediction;     /*!< Predicted cycle count for this workload */
 		IMG_UINT32     ui32CyclesTaken;          /*!< Actual cycle count for this workload */
-		RGXFWIF_DM     eDM;                      /*!< Target DM */
+		RGX_HWPERF_DM  eDM;                      /*!< Target DM */
 		IMG_UINT32     ui32ReturnDataIndex;      /*!< Index into workload estimation table */
 		IMG_UINT32     ui32TxtActCyc;            /*!< Meta TXTACTCYC register value */
 	} sWorkEst;
 
-	/*! This structure holds the data of an OPP clock frequency transition packet. */
+	/*! This structure holds the data of an Operating Performance Points (OPP) clock frequency transition packet. */
 	struct
 	{
-		IMG_UINT32     ui32OPPData;              /*!< OPP transition */
+		IMG_UINT32     ui32OPPData;              /*!< New Operating Performance Point (OPP) */
 	} sOPP;
 
 } RGX_HWPERF_DVFS_DETAIL;
@@ -845,8 +855,8 @@ typedef struct
 	                                 stream and stream data offset in the
 	                                 payload */
 	RGX_HWPERF_DM eDM;             /*!< Data Master number, see RGX_HWPERF_DM */
-	IMG_UINT32 ui32Padding;        /*!< Unused, reserved */
-	IMG_UINT32 aui32StreamData[RGX_HWPERF_ONE_OR_MORE_ELEMENTS];  /*!< Series of tuples holding UFO objects data */
+	IMG_UINT32 aui32StreamData[IMG_FLEX_ARRAY_MEMBER];  /*!< Series of tuples holding UFO objects data */
+	RGX_HWPERF_FLEX_ARRAY_ALIGN(IMG_UINT32 uiReserved);        /*!< Unused, reserved */
 } RGX_HWPERF_UFO_DATA;
 
 RGX_FW_STRUCT_SIZE_ASSERT(RGX_HWPERF_UFO_DATA);
@@ -915,12 +925,13 @@ typedef union
 	struct RGX_RESOURCE_CAPTURE_RENDER_SURFACES
 	{
 		IMG_UINT32 ui32RenderSurfaceCount;
-		RGX_RESOURCE_PER_SURFACE_INFO sSurface[RGX_HWPERF_ONE_OR_MORE_ELEMENTS];
+		RGX_RESOURCE_PER_SURFACE_INFO sSurface[IMG_FLEX_ARRAY_MEMBER];
 	} sRenderSurfaces;
 
 	struct RGX_RESOURCE_CAPTURE_TILE_LIFETIME_BUFFERS
 	{
-		RGX_RESOURCE_PER_TLT_BUFFER_INFO sTLTBufInfo[RGX_HWPERF_ONE_OR_MORE_ELEMENTS];
+		IMG_UINT32 uiReserved;
+		RGX_RESOURCE_PER_TLT_BUFFER_INFO sTLTBufInfo[IMG_FLEX_ARRAY_MEMBER];
 	} sTLTBuffers;
 } RGX_RESOURCE_CAPTURE_DETAIL;
 
@@ -1126,10 +1137,8 @@ typedef struct
 	 * array member need to add a special case for Smatch static code analyser. */
 	IMG_UINT32 aui32StreamData[];
 #else
-	IMG_UINT32 aui32StreamData[RGX_HWPERF_ONE_OR_MORE_ELEMENTS];
-	                             /*!< Series of tuples holding UFO objects data */
-
-	IMG_UINT32 ui32Padding;      /*!< Reserved, align structure size to 8 bytes */
+	IMG_UINT32 aui32StreamData[IMG_FLEX_ARRAY_MEMBER];       /*!< Series of tuples holding UFO objects data */
+	RGX_HWPERF_FLEX_ARRAY_ALIGN(IMG_UINT32 uiReserved);      /*!< Reserved, align structure size to 8 bytes */
 #endif
 } RGX_HWPERF_HOST_UFO_DATA;
 
@@ -1421,13 +1430,13 @@ typedef union
 	{
 		IMG_UINT64 ui64TotalMemoryUsage;   /*!< Total memory usage (bytes) */
 		/*! Detailed memory usage */
-		struct
+		struct _RGX_HWPERF_HOST_INFO_PER_PROC_USAGE_
 		{
 			IMG_UINT32 ui32Pid;              /*!< Process ID */
 			IMG_UINT32 ui32Padding;          /*!< Padding */
 			IMG_UINT64 ui64KernelMemUsage;   /*!< Kernel memory usage (bytes) */
 			IMG_UINT64 ui64GraphicsMemUsage; /*!< GPU memory usage (bytes) */
-		} sPerProcessUsage[RGX_HWPERF_ZERO_OR_MORE_ELEMENTS];
+		} sPerProcessUsage[IMG_FLEX_ARRAY_MEMBER];
 	} sMemUsageStats;
 } RGX_HWPERF_HOST_INFO_DETAIL;
 
@@ -1534,7 +1543,7 @@ typedef struct
 {
 	IMG_PID uiClientPID; /*!< Client process identifier */
 	IMG_UINT32 ui32Length;  /*!< Number of bytes present in ``acName`` */
-	IMG_CHAR acName[RGX_HWPERF_ONE_OR_MORE_ELEMENTS]; /*!< Process name string, null terminated */
+	IMG_CHAR acName[IMG_FLEX_ARRAY_MEMBER]; /*!< Process name string, null terminated */
 } RGX_HWPERF_HOST_CLIENT_PROC_NAME;
 
 #define RGX_HWPERF_HOST_CLIENT_PROC_NAME_SIZE(ui32NameLen) \
@@ -1545,13 +1554,13 @@ typedef union
 	struct
 	{
 		IMG_UINT32 ui32Count; /*!< Number of elements in ``asProcNames`` */
-		RGX_HWPERF_HOST_CLIENT_PROC_NAME asProcNames[RGX_HWPERF_ONE_OR_MORE_ELEMENTS];
+		RGX_HWPERF_HOST_CLIENT_PROC_NAME asProcNames[IMG_FLEX_ARRAY_MEMBER];
 	} sProcName;
 } RGX_HWPERF_HOST_CLIENT_INFO_DETAIL;
 
 typedef struct
 {
-	IMG_UINT32 uiReserved1; /*!< Reserved. Align structure size to 8 bytes */
+	IMG_UINT32 uiReserved; /*!< Reserved. Align structure size to 8 bytes */
 	RGX_HWPERF_HOST_CLIENT_INFO_TYPE eType;
 	                        /*!< Type of the subevent, see
 	                         RGX_HWPERF_HOST_CLIENT_INFO_TYPE */
@@ -1559,12 +1568,8 @@ typedef struct
 	                        /*!< Union of structures. Size of data
 	                         varies with union member that is present,
 	                         check ``eType`` value to decode */
-
 } RGX_HWPERF_HOST_CLIENT_INFO_DATA;
 
-static_assert((sizeof(RGX_HWPERF_HOST_CLIENT_INFO_DATA) & (PVRSRVTL_PACKET_ALIGNMENT-1U)) == 0U,
-			  "sizeof(RGX_HWPERF_HOST_CLIENT_INFO_DATA) must be a multiple PVRSRVTL_PACKET_ALIGNMENT");
-
 /*! This type is a union of packet payload data structures associated with
  * various FW and Host events */
 typedef union
@@ -1574,6 +1579,8 @@ typedef union
 	RGX_HWPERF_HW_DATA             sHW;           /*!< Hardware event packet data,
 	                                               events ``0x07-0x19``, ``0x28-0x29``
 	                                               See RGX_HWPERF_HW_DATA */
+	RGX_HWPERF_GPU_WORK_PERIOD_DATA sGPUWorkPeriod;
+
 	RGX_HWPERF_CLKS_CHG_DATA       sCLKSCHG;      /*!< Clock change event packet
 	                                               data, events ``0x1A`` */
 	RGX_HWPERF_GPU_STATE_CHG_DATA  sGPUSTATECHG;  /*!< GPU utilisation state
diff --git a/drivers/gpu/drm/img-rogue/rgx_hwperf_table.c b/drivers/gpu/drm/img-rogue/rgx_hwperf_table.c
index 268ba65207ae..78d731c98eb6 100644
--- a/drivers/gpu/drm/img-rogue/rgx_hwperf_table.c
+++ b/drivers/gpu/drm/img-rogue/rgx_hwperf_table.c
@@ -83,15 +83,12 @@ static bool rgxfw_hwperf_pow_st_direct(RGX_HWPERF_CNTBLK_ID eBlkType, IMG_UINT8
 	PVR_UNREFERENCED_PARAMETER(eBlkType);
 	PVR_UNREFERENCED_PARAMETER(ui8UnitId);
 
-#if defined(RGX_FEATURE_S7_TOP_INFRASTRUCTURE)
-	/* S7XT: JONES */
-	return (eBlkType == RGX_CNTBLK_ID_JONES);
-#elif defined(RGX_FEATURE_XT_TOP_INFRASTRUCTURE)
+#if defined(RGX_FEATURE_XT_TOP_INFRASTRUCTURE)
 	/* S6XT: TA, TORNADO */
 	return true;
 #else
 	/* S6  : TA, HUB, RASTER (RASCAL) */
-	return (gsPowCtl.eUnitsPowState & RGXFW_POW_ST_RD_ON) != 0U;
+	return rgxfw_pow_is_rd_on();
 #endif
 }
 
@@ -102,8 +99,7 @@ static bool rgxfw_hwperf_pow_st_indirect(RGX_HWPERF_CNTBLK_ID eBlkType, IMG_UINT
 {
 	IMG_UINT32 ui32NumDustsEnabled = rgxfw_pow_get_enabled_units();
 
-	if (((gsPowCtl.eUnitsPowState & RGXFW_POW_ST_RD_ON) != 0U) &&
-			(ui32NumDustsEnabled > 0U))
+	if (rgxfw_pow_is_rd_on() && (ui32NumDustsEnabled > 0U))
 	{
 #if defined(RGX_FEATURE_DYNAMIC_DUST_POWER)
 		IMG_UINT32 ui32NumUscEnabled = ui32NumDustsEnabled*2U;
@@ -111,9 +107,6 @@ static bool rgxfw_hwperf_pow_st_indirect(RGX_HWPERF_CNTBLK_ID eBlkType, IMG_UINT
 		switch (eBlkType)
 		{
 		case RGX_CNTBLK_ID_TPU_MCU0:                   /* S6 and S6XT */
-#if defined(RGX_FEATURE_S7_TOP_INFRASTRUCTURE)
-		case RGX_CNTBLK_ID_TEXAS0:                     /* S7 */
-#endif
 			if (ui8UnitId >= ui32NumDustsEnabled)
 			{
 				return false;
@@ -156,8 +149,8 @@ static bool rgxfw_hwperf_pow_st_indirect(RGX_HWPERF_CNTBLK_ID eBlkType, IMG_UINT
 
 #else /* !defined(RGX_FIRMWARE) || !defined(RGX_FEATURE_PERFBUS) */
 
-# define rgxfw_hwperf_pow_st_direct   ((void*)NULL)
-# define rgxfw_hwperf_pow_st_indirect ((void*)NULL)
+# define rgxfw_hwperf_pow_st_direct   ((PFN_RGXFW_HWPERF_CNTBLK_POWERED)NULL)
+# define rgxfw_hwperf_pow_st_indirect ((PFN_RGXFW_HWPERF_CNTBLK_POWERED)NULL)
 
 #endif /* !defined(RGX_FIRMWARE) || !defined(RGX_FEATURE_PERFBUS) */
 
@@ -309,7 +302,7 @@ static IMG_BOOL rgx_hwperf_blk_present_xttop(const RGXFW_HWPERF_CNTBLK_TYPE_MODE
 	return IMG_FALSE;
 }
 
-/* Used for block types: JONES, TPU_MCU, TEXAS, BLACKPERL, PBE */
+/* Used for block types: JONES, TPU_MCU, TEXAS, BLACKPEARL, PBE */
 static IMG_BOOL rgx_hwperf_blk_present_s7top(const RGXFW_HWPERF_CNTBLK_TYPE_MODEL* psBlkTypeDesc, const void *pvDev_km, void *pvRtInfo)
 {
 	DBG_ASSERT(psBlkTypeDesc != NULL);
@@ -320,6 +313,7 @@ static IMG_BOOL rgx_hwperf_blk_present_s7top(const RGXFW_HWPERF_CNTBLK_TYPE_MODE
 			(psBlkTypeDesc->ui32CntBlkIdBase == RGX_CNTBLK_ID_PBE0));
 
 #if defined(__KERNEL__) /* Server context */
+#if defined(RGX_FEATURE_S7_TOP_INFRASTRUCTURE_IDX)
 	PVR_ASSERT(pvDev_km != NULL);
 	PVR_ASSERT(pvRtInfo != NULL);
 	{
@@ -359,6 +353,7 @@ static IMG_BOOL rgx_hwperf_blk_present_s7top(const RGXFW_HWPERF_CNTBLK_TYPE_MODE
 			}
 		}
 	}
+#endif
 #else /* FW context */
 	PVR_UNREFERENCED_PARAMETER(pvDev_km);
 	PVR_UNREFERENCED_PARAMETER(psBlkTypeDesc);
@@ -385,8 +380,7 @@ static IMG_BOOL rgx_hwperf_blk_present_not_s7top(const RGXFW_HWPERF_CNTBLK_TYPE_
 	{
 		RGX_HWPERF_CNTBLK_RT_INFO *psRtInfo = (RGX_HWPERF_CNTBLK_RT_INFO *) pvRtInfo;
 		const PVRSRV_RGXDEV_INFO *psDevInfo = (const PVRSRV_RGXDEV_INFO *)pvDev_km;
-		if (!RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE) &&
-				RGX_IS_FEATURE_SUPPORTED(psDevInfo, PERFBUS))
+		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, PERFBUS))
 		{
 			if (psBlkTypeDesc->ui32CntBlkIdBase == RGX_CNTBLK_ID_TA)
 			{
diff --git a/drivers/gpu/drm/img-rogue/rgx_meta.h b/drivers/gpu/drm/img-rogue/rgx_meta.h
index ae91ddf7401a..1e6214c9ba1c 100644
--- a/drivers/gpu/drm/img-rogue/rgx_meta.h
+++ b/drivers/gpu/drm/img-rogue/rgx_meta.h
@@ -231,6 +231,16 @@ typedef struct
 /* All threads can access and writable */
 #define RGXFW_SEGMMU_ALLTHRS_WRITEABLE	(RGXFW_SEGMMU_ALLTHRS | RGXFW_SEGMMU_WRITEABLE)
 
+/* Direct map region 8 optionally used for custom mappings - max 8MB */
+#define RGXFW_SEGMMU_DMAP_CUSTOM0_ID			(8U)
+#define RGXFW_SEGMMU_DMAP_CUSTOM0_ADDR_START	(0x06000000U)
+#define RGXFW_SEGMMU_DMAP_CUSTOM0_MAX_SIZE		(0x00800000U)
+
+/* Direct map region 9 optionally used for custom mappings - max 8MB */
+#define RGXFW_SEGMMU_DMAP_CUSTOM1_ID			(9U)
+#define RGXFW_SEGMMU_DMAP_CUSTOM1_ADDR_START	(0x06800000U)
+#define RGXFW_SEGMMU_DMAP_CUSTOM1_MAX_SIZE		(0x00800000U)
+
 /* Direct map region 10 used for mapping GPU memory - max 8MB */
 #define RGXFW_SEGMMU_DMAP_GPU_ID			(10U)
 #define RGXFW_SEGMMU_DMAP_GPU_ADDR_START	(0x07000000U)
@@ -261,7 +271,7 @@ typedef struct
                                                               ((IMG_UINT64)((IMG_UINT64)(bifdm) & 0xFU) << 40U))
 
 #define RGXFW_SEGMMU_META_BIFDM_ID   (0x7U)
-#if !defined(__KERNEL__) && defined(RGX_FEATURE_META)
+#if !(defined(__KERNEL__) || defined(TEE_DDK)) && defined(RGX_FEATURE_META)
 #if defined(RGX_FEATURE_SLC_VIVT)
 #define RGXFW_SEGMMU_OUTADDR_TOP_SLC_CACHED    RGXFW_SEGMMU_OUTADDR_TOP_VIVT_SLC_CACHED
 #define RGXFW_SEGMMU_OUTADDR_TOP_SLC_UNCACHED  RGXFW_SEGMMU_OUTADDR_TOP_VIVT_SLC_UNCACHED
@@ -329,7 +339,7 @@ typedef struct
 #define RGX_META_COREMEM_DATA_ADDR   (0x82000000U)
 #define RGX_META_COREMEM_OFFSET_MASK (0x01ffffffU)
 
-#if defined(__KERNEL__)
+#if defined(__KERNEL__) || defined(TEE_DDK)
 #define RGX_META_IS_COREMEM_CODE(A, B)  (((A) >= RGX_META_COREMEM_CODE_ADDR) && ((A) < (RGX_META_COREMEM_CODE_ADDR + (B))))
 #define RGX_META_IS_COREMEM_DATA(A, B)  (((A) >= RGX_META_COREMEM_DATA_ADDR) && ((A) < (RGX_META_COREMEM_DATA_ADDR + (B))))
 #endif
@@ -348,7 +358,7 @@ typedef struct
 #define META_CR_CORE_ID_VER_SHIFT	(16U)
 #define META_CR_CORE_ID_VER_CLRMSK	(0XFF00FFFFU)
 
-#if !defined(__KERNEL__) && defined(RGX_FEATURE_META)
+#if !(defined(__KERNEL__) || defined(TEE_DDK)) && defined(RGX_FEATURE_META)
 
 	#if (RGX_FEATURE_META == MTP218)
 	#define RGX_CR_META_CORE_ID_VALUE 0x19
diff --git a/drivers/gpu/drm/img-rogue/rgx_options.h b/drivers/gpu/drm/img-rogue/rgx_options.h
index 364b8db3ad3d..df9c949f4a1f 100644
--- a/drivers/gpu/drm/img-rogue/rgx_options.h
+++ b/drivers/gpu/drm/img-rogue/rgx_options.h
@@ -71,6 +71,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define OPTIONS_FW_IRQ_REG_COUNTERS_EN			(0x1UL << 14)
 #define OPTIONS_VALIDATION_EN					(0x1UL << 15)
 #define OPTIONS_NO_HARDWARE_EN					(0x1UL << 16)
+#define OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN                  (0x1UL << 17)
+#define OPTIONS_NUM_DRIVERS_SUPPORTED_MASK                      (0x1fUL << 18)
+#define OPTIONS_NUM_DRIVERS_SUPPORTED_SHIFT                     (18)
+/* Option bits[22:18] are used for max number of drivers supported by the FW. */
 
 #define OPTIONS_PERCONTEXT_FREELIST_EN			(0x1UL << 31)
 
@@ -90,11 +94,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 			 OPTIONS_AUTOVZ_HW_REGS_EN			| \
 			 OPTIONS_FW_IRQ_REG_COUNTERS_EN		| \
 			 OPTIONS_VALIDATION_EN				| \
-			 OPTIONS_NO_HARDWARE_EN)
-
+			 OPTIONS_NO_HARDWARE_EN				| \
+			 OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN)
 
 #define RGX_BUILD_OPTIONS_MASK_FW \
 			(RGX_BUILD_OPTIONS_MASK_KM & \
+			 ~OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN & \
+			 ~OPTIONS_NUM_DRIVERS_SUPPORTED_MASK & \
 			 ~OPTIONS_BUFFER_SYNC_EN)
 
 /* Build options that the FW must have if the present on the KM */
@@ -273,14 +279,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif /* RGX_FW_IRQ_OS_COUNTERS */
 
 #define VALIDATION_OPTION	"VALIDATION  "
-#if defined(SUPPORT_VALIDATION)
-	#define OPTIONS_BIT15		OPTIONS_VALIDATION_EN
-	#if OPTIONS_BIT15 > RGX_BUILD_OPTIONS_MASK_KM
-	#error "Bit exceeds reserved range"
-	#endif
-#else
 	#define OPTIONS_BIT15		0x0UL
-#endif /* SUPPORT_VALIDATION */
 
 #define NO_HARDWARE_OPTION	"NO_HARDWARE  "
 #if defined(NO_HARDWARE)
@@ -292,6 +291,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 	#define OPTIONS_BIT16		0x0UL
 #endif /* NO_HARDWARE */
 
+#define NUM_DRIVERS_SUPPORTED_CHECK_OPTION	"NUM_DRIVERS_SUPPORTED_CHECK  "
+	#define OPTIONS_BIT17		OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN
+	#if OPTIONS_BIT17 > RGX_BUILD_OPTIONS_MASK_KM
+	#error "Bit exceeds reserved range"
+	#endif /* NUM_DRIVERS_SUPPORTED_CHECK */
+/* Option bits[22:18] are used for max number of drivers supported by the FW. */
+
 #define OPTIONS_BIT31		OPTIONS_PERCONTEXT_FREELIST_EN
 #if OPTIONS_BIT31 <= RGX_BUILD_OPTIONS_MASK_KM
 #error "Bit exceeds reserved range"
@@ -314,7 +320,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 	 OPTIONS_BIT13				|\
 	 OPTIONS_BIT14				|\
 	 OPTIONS_BIT15				|\
-	 OPTIONS_BIT16)
+	 OPTIONS_BIT16				|\
+	 OPTIONS_BIT17)
 
 #define RGX_BUILD_OPTIONS (RGX_BUILD_OPTIONS_KM | OPTIONS_BIT31)
 
@@ -336,7 +343,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 		AUTOVZ_HW_REGS_OPTION,			\
 		RGX_FW_IRQ_OS_COUNTERS_OPTION,	\
 		VALIDATION_OPTION,				\
-		NO_HARDWARE_OPTION				\
+		NO_HARDWARE_OPTION,				\
+		NUM_DRIVERS_SUPPORTED_CHECK_OPTION				\
 	}
 
 #endif /* RGX_OPTIONS_H */
diff --git a/drivers/gpu/drm/img-rogue/rgx_riscv.h b/drivers/gpu/drm/img-rogue/rgx_riscv.h
index 4c064384608d..f98b77658d8f 100644
--- a/drivers/gpu/drm/img-rogue/rgx_riscv.h
+++ b/drivers/gpu/drm/img-rogue/rgx_riscv.h
@@ -49,18 +49,28 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
 /* Utility defines to convert regions to virtual addresses and remaps */
-#define RGXRISCVFW_GET_REGION_BASE(r)           IMG_UINT32_C((r) << 28)
-#define RGXRISCVFW_GET_REGION(a)                IMG_UINT32_C((a) >> 28)
-#define RGXRISCVFW_MAX_REGION_SIZE              IMG_UINT32_C(1 << 28)
+#define RGXRISCVFW_NUM_REGIONS_LOG2             IMG_UINT32_C(4)
+#define RGXRISCVFW_REGION_SIZE_LOG2             IMG_UINT32_C(28)
+#define RGXRISCVFW_NUM_REGIONS                  (IMG_UINT32_C(1) << RGXRISCVFW_NUM_REGIONS_LOG2)
+#define RGXRISCVFW_GET_REGION_BASE(r)           ((r) << RGXRISCVFW_REGION_SIZE_LOG2)
+#define RGXRISCVFW_GET_REGION(a)                ((a) >> RGXRISCVFW_REGION_SIZE_LOG2)
+#define RGXRISCVFW_MAX_REGION_SIZE              (IMG_UINT32_C(1) << RGXRISCVFW_REGION_SIZE_LOG2)
 #define RGXRISCVFW_GET_REMAP(r)                 (RGX_CR_FWCORE_ADDR_REMAP_CONFIG0 + ((r) * 8U))
 
+#define RGXRISCVFW_REGION_MASK                  (RGXRISCVFW_GET_REGION_BASE(RGXRISCVFW_NUM_REGIONS - IMG_UINT32_C(1)))
+
+#if !defined(RGXRISCVFW_ASSEMBLY_CODE)
+static_assert(RGXRISCVFW_NUM_REGIONS_LOG2 + RGXRISCVFW_REGION_SIZE_LOG2 == 32,
+              "Mismatch between number of remap regions and remap size");
+#endif
+
 /* RISCV remap output is aligned to 4K */
 #define RGXRISCVFW_REMAP_CONFIG_DEVVADDR_ALIGN  (0x1000U)
 
 /*
  * FW bootloader defines
  */
-#define RGXRISCVFW_BOOTLDR_CODE_REGION          IMG_UINT32_C(0xC)
+#define RGXRISCVFW_BOOTLDR_CODE_REGION          (IMG_UINT32_C(0xC0000000) >> RGXRISCVFW_REGION_SIZE_LOG2)
 #define RGXRISCVFW_BOOTLDR_DATA_REGION          IMG_UINT32_C(0x5)
 #define RGXRISCVFW_BOOTLDR_CODE_BASE            (RGXRISCVFW_GET_REGION_BASE(RGXRISCVFW_BOOTLDR_CODE_REGION))
 #define RGXRISCVFW_BOOTLDR_DATA_BASE            (RGXRISCVFW_GET_REGION_BASE(RGXRISCVFW_BOOTLDR_DATA_REGION))
@@ -82,8 +92,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /*
  * Host-FW shared data defines
  */
-#define RGXRISCVFW_SHARED_CACHED_DATA_REGION    (0x6UL)
-#define RGXRISCVFW_SHARED_UNCACHED_DATA_REGION  (0xDUL)
+#define RGXRISCVFW_SHARED_CACHED_DATA_REGION    (0x0UL)
+#define RGXRISCVFW_SHARED_UNCACHED_DATA_REGION  (0x1UL)
 #define RGXRISCVFW_SHARED_CACHED_DATA_BASE      (RGXRISCVFW_GET_REGION_BASE(RGXRISCVFW_SHARED_CACHED_DATA_REGION))
 #define RGXRISCVFW_SHARED_UNCACHED_DATA_BASE    (RGXRISCVFW_GET_REGION_BASE(RGXRISCVFW_SHARED_UNCACHED_DATA_REGION))
 #define RGXRISCVFW_SHARED_CACHED_DATA_REMAP     (RGXRISCVFW_GET_REMAP(RGXRISCVFW_SHARED_CACHED_DATA_REGION))
diff --git a/drivers/gpu/drm/img-rogue/rgxapi_km.h b/drivers/gpu/drm/img-rogue/rgxapi_km.h
index 65ba85d20b4b..7d7efd0afb5e 100644
--- a/drivers/gpu/drm/img-rogue/rgxapi_km.h
+++ b/drivers/gpu/drm/img-rogue/rgxapi_km.h
@@ -44,22 +44,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef RGXAPI_KM_H
 #define RGXAPI_KM_H
 
-#if defined(SUPPORT_SHARED_SLC)
-/*************************************************************************/ /*!
-@Function       RGXInitSLC
-@Description    Init the SLC after a power up. It is required to call this
-                 function if using SUPPORT_SHARED_SLC. Otherwise, it shouldn't
-                 be called.
-
-@Input          hDevHandle   RGX Device Node
-@Return         PVRSRV_ERROR System error code
-*/ /**************************************************************************/
-PVRSRV_ERROR RGXInitSLC(IMG_HANDLE hDevHandle);
-#endif
-
 #include "rgx_hwperf.h"
 
-
 /******************************************************************************
  * RGX HW Performance Profiling Control API(s)
  *****************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/rgxbvnc.c b/drivers/gpu/drm/img-rogue/rgxbvnc.c
index 2d551b26872c..9f82ff1260bb 100644
--- a/drivers/gpu/drm/img-rogue/rgxbvnc.c
+++ b/drivers/gpu/drm/img-rogue/rgxbvnc.c
@@ -2,7 +2,7 @@
 @File
 @Title          BVNC handling specific routines
 @Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
-@Description    Functions used for BNVC related work
+@Description    Functions used for BVNC related work
 @License        Dual MIT/GPLv2
 
 The contents of this file are subject to the MIT license as set out below.
@@ -177,9 +177,13 @@ static void _RGXBvncDumpParsedConfig(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "CSF:      ", CDM_CONTROL_STREAM_FORMAT);
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "FBCDCA:   ", FBCDC_ARCHITECTURE);
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "META:     ", META);
+#if defined(RGX_FEATURE_META_COREMEM_BANKS_IDX)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "MCMB:     ", META_COREMEM_BANKS);
+#endif
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "MCMS:     ", META_COREMEM_SIZE);
+#if defined(RGX_FEATURE_META_DMA_CHANNEL_COUNT_IDX)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "MDMACnt:  ", META_DMA_CHANNEL_COUNT);
+#endif
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "NIIP:     ", NUM_ISP_IPP_PIPES);
 #if defined(RGX_FEATURE_NUM_ISP_PER_SPU_MAX_VALUE_IDX)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "NIPS:     ", NUM_ISP_PER_SPU);
@@ -189,8 +193,12 @@ static void _RGXBvncDumpParsedConfig(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "NSPU:     ", NUM_SPU);
 #endif
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "PBW:      ", PHYS_BUS_WIDTH);
+#if defined(RGX_FEATURE_SCALABLE_TE_ARCH_IDX)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "STEArch:  ", SCALABLE_TE_ARCH);
+#endif
+#if defined(RGX_FEATURE_SCALABLE_VCE_IDX)
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "SVCEA:    ", SCALABLE_VCE);
+#endif
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "SLCBanks: ", SLC_BANKS);
 	PVR_LOG_DUMP_FEATURE_VALUE(psDevInfo, "SLCCLS:   ", SLC_CACHE_LINE_SIZE_BITS);
 	PVR_LOG(("SLCSize:   %d",  psDevInfo->sDevFeatureCfg.ui32SLCSizeInBytes));
@@ -302,6 +310,7 @@ static PVRSRV_ERROR _RGXBvncParseFeatureValues(PVRSRV_RGXDEV_INFO *psDevInfo,
 		}
 	}
 
+
 #if defined(RGX_FEATURE_POWER_ISLAND_VERSION_MAX_VALUE_IDX)
 	/* Code path for Volcanic */
 
@@ -379,12 +388,12 @@ static PVRSRV_ERROR _RGXBvncParseFeatureValues(PVRSRV_RGXDEV_INFO *psDevInfo,
 	/* Get the max number of dusts in the core */
 	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, NUM_CLUSTERS))
 	{
-		psDevInfo->sDevFeatureCfg.ui32MAXDustCount = MAX(1, (RGX_GET_FEATURE_VALUE(psDevInfo, NUM_CLUSTERS) / 2));
+		psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount = MAX(1, (RGX_GET_FEATURE_VALUE(psDevInfo, NUM_CLUSTERS) / 2));
 	}
 	else
 	{
 		/* This case should never be reached as all cores have clusters */
-		psDevInfo->sDevFeatureCfg.ui32MAXDustCount = RGX_FEATURE_VALUE_INVALID;
+		psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount = RGX_FEATURE_VALUE_INVALID;
 		PVR_DPF((PVR_DBG_ERROR, "%s: Number of clusters feature value missing!", __func__));
 		PVR_ASSERT(0);
 		return PVRSRV_ERROR_FEATURE_DISABLED;
@@ -463,7 +472,7 @@ static PVRSRV_ERROR _RGXBvncAcquireAppHint(IMG_CHAR *pszBVNC, const IMG_UINT32 u
 
 		if (ui32BVNCCount == ui32RGXDevCount)
 		{
-			OSStringLCopy(pszBVNC, pszCurrentBVNC, RGX_BVNC_STR_SIZE_MAX);
+			OSStringSafeCopy(pszBVNC, pszCurrentBVNC, RGX_BVNC_STR_SIZE_MAX);
 			OSFreeMem(pszBVNCAppHint);
 			return PVRSRV_OK;
 		}
@@ -479,7 +488,7 @@ static PVRSRV_ERROR _RGXBvncAcquireAppHint(IMG_CHAR *pszBVNC, const IMG_UINT32 u
 	 * devices detected */
 	if (1 == ui32BVNCCount)
 	{
-		OSStringLCopy(pszBVNC, pszBVNCAppHint, RGX_BVNC_STR_SIZE_MAX);
+		OSStringSafeCopy(pszBVNC, pszBVNCAppHint, RGX_BVNC_STR_SIZE_MAX);
 	}
 
 	OSFreeMem(pszBVNCAppHint);
@@ -672,10 +681,10 @@ PVRSRV_ERROR RGXBvncInitialiseConfiguration(PVRSRV_DEVICE_NODE *psDeviceNode)
 	/* Try to detect the RGX BVNC from the HW device */
 	if ((NULL == pui64Cfg) && !psDevInfo->bIgnoreHWReportedBVNC)
 	{
-		IMG_BOOL bPowerDown = (psDeviceNode->psDevConfig->pfnGpuDomainPower(psDeviceNode) == PVRSRV_SYS_POWER_STATE_OFF);
+		IMG_BOOL bPowerDown = ! PVRSRVIsSystemPowered(psDeviceNode);
 
 		/* Power-up the device as required to read the registers */
-		if (bPowerDown)
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) && bPowerDown)
 		{
 			eError = PVRSRVSetSystemPowerState(psDeviceNode->psDevConfig, PVRSRV_SYS_POWER_STATE_ON);
 			PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState ON");
@@ -687,7 +696,7 @@ PVRSRV_ERROR RGXBvncInitialiseConfiguration(PVRSRV_DEVICE_NODE *psDeviceNode)
 		PVR_LOG(("Read BVNC " RGX_BVNC_STR_FMTSPEC
 				" from HW device registers", B, V, N, C));
 
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			/* Read the number of cores in the system for newer BVNC (Branch ID > 20) */
 			if (B > 20)
@@ -700,7 +709,7 @@ PVRSRV_ERROR RGXBvncInitialiseConfiguration(PVRSRV_DEVICE_NODE *psDeviceNode)
 		ui32SLCSize = _RGXBvncReadSLCSize(psDeviceNode);
 		PVR_DPF((PVR_DBG_MESSAGE, "%s: SLC Size reported as %u", __func__, ui32SLCSize));
 
-		if (bPowerDown)
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) && bPowerDown)
 		{
 			eError = PVRSRVSetSystemPowerState(psDeviceNode->psDevConfig, PVRSRV_SYS_POWER_STATE_OFF);
 			PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState OFF");
@@ -713,7 +722,7 @@ PVRSRV_ERROR RGXBvncInitialiseConfiguration(PVRSRV_DEVICE_NODE *psDeviceNode)
 			pui64Cfg = RGX_SEARCH_BVNC_TABLE(gaFeatures, ui64BVNC);
 			PVR_LOG_IF_FALSE((pui64Cfg != NULL), "HW device BVNC configuration not found!");
 		}
-		else if (!PVRSRV_VZ_MODE_IS(GUEST))
+		else if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			/*
 			 * On host OS we should not get here as CORE_ID should not be zero, so flag an error.
@@ -813,7 +822,8 @@ PVRSRV_ERROR RGXBvncInitialiseConfiguration(PVRSRV_DEVICE_NODE *psDeviceNode)
 	psDevInfo->sDevFeatureCfg.ui32SLCSizeInBytes = ui32SLCSize;
 
 	/* Message to confirm configuration look up was a success */
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT))
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT) &&
+		!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 #if defined(NO_HARDWARE)
 		{
@@ -944,25 +954,6 @@ PVRSRV_ERROR RGXVerifyBVNC(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_UINT64 ui64Give
 		}
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE) && defined(PDUMP)
-		/* check upper DWORD */
-		eError = PDUMPREGPOL(psDeviceNode, RGX_PDUMPREG_NAME,
-		                     (RGX_CR_CORE_ID + 4) + (i << 16),
-		                     (IMG_UINT32)(ui64MatchBVNC >> 32),
-		                     0xFFFFFFFF,
-		                     PDUMP_FLAGS_CONTINUOUS,
-		                     PDUMP_POLL_OPERATOR_EQUAL);
-		if (eError == PVRSRV_OK)
-		{
-			/* check lower DWORD */
-			eError = PDUMPREGPOL(psDeviceNode, RGX_PDUMPREG_NAME,
-			                     RGX_CR_CORE_ID + (i << 16),
-			                     (IMG_UINT32)(ui64MatchBVNC & 0xFFFFFFFF),
-			                     0xFFFFFFFF,
-			                     PDUMP_FLAGS_CONTINUOUS,
-			                     PDUMP_POLL_OPERATOR_EQUAL);
-		}
-#endif
 	}
 
 	return eError;
diff --git a/drivers/gpu/drm/img-rogue/rgxccb.c b/drivers/gpu/drm/img-rogue/rgxccb.c
index 10fa9443b6b1..b30a36d41157 100644
--- a/drivers/gpu/drm/img-rogue/rgxccb.c
+++ b/drivers/gpu/drm/img-rogue/rgxccb.c
@@ -126,7 +126,6 @@ struct _RGX_CLIENT_CCB_ {
 	DEVMEM_MEMDESC				*psClientCCBCtrlMemDesc;		/*!< MemDesc for the CCB control */
 	IMG_UINT32					ui32HostWriteOffset;			/*!< CCB write offset from the driver side */
 	IMG_UINT32					ui32LastPDumpWriteOffset;		/*!< CCB write offset from the last time we submitted a command in capture range */
-	IMG_UINT32					ui32FinishedPDumpWriteOffset;	/*!< Trails LastPDumpWriteOffset for last finished command, used for HW CB driven DMs */
 	IMG_UINT32					ui32LastROff;					/*!< Last CCB Read offset to help detect any CCB wedge */
 	IMG_UINT32					ui32LastWOff;					/*!< Last CCB Write offset to help detect any CCB wedge */
 	IMG_UINT32					ui32ByteCount;					/*!< Count of the number of bytes written to CCCB */
@@ -177,36 +176,17 @@ PVRSRV_ERROR RGXCCBPDumpDrainCCB(RGX_CLIENT_CCB *psClientCCB,
 	PVRSRV_RGXDEV_INFO *psDevInfo = FWCommonContextGetRGXDevInfo(psClientCCB->psServerCommonContext);
 #endif
 
-	if (BIT_ISSET(psClientCCB->ui32CCBFlags, CCB_FLAGS_CCB_STATE_OPEN))
-	{
-		/* Draining CCB on a command that hasn't finished, and FW isn't expected
-		 * to have updated Roff up to Woff. Only drain to the first
-		 * finished command prior to this. The Roff for this
-		 * is stored in ui32FinishedPDumpWriteOffset.
-		 */
-		ui32PollOffset = psClientCCB->ui32FinishedPDumpWriteOffset;
-
-		PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode,
-							  ui32PDumpFlags,
-							  "cCCB(%s@%p): Draining open CCB rgxfw_roff < woff (%d)",
-							  psClientCCB->szName,
-							  psClientCCB,
-							  ui32PollOffset);
-	}
-	else
-	{
-		/* Command to a finished CCB stream and FW is drained to empty
-		 * out remaining commands until R==W.
-		 */
-		ui32PollOffset = psClientCCB->ui32LastPDumpWriteOffset;
+	/* Command to a finished CCB stream and FW is drained to empty
+	 * out remaining commands until R==W.
+	 */
+	ui32PollOffset = psClientCCB->ui32LastPDumpWriteOffset;
 
-		PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode,
-							  ui32PDumpFlags,
-							  "cCCB(%s@%p): Draining CCB rgxfw_roff == woff (%d)",
-							  psClientCCB->szName,
-							  psClientCCB,
-							  ui32PollOffset);
-	}
+	PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode,
+						  ui32PDumpFlags,
+						  "cCCB(%s@%p): Draining CCB rgxfw_roff == woff (%d)",
+						  psClientCCB->szName,
+						  psClientCCB,
+						  ui32PollOffset);
 
 	return DevmemPDumpDevmemPol32(psClientCCB->psClientCCBCtrlMemDesc,
 									offsetof(RGXFWIF_CCCB_CTL, ui32ReadOffset),
@@ -327,10 +307,12 @@ static void RGXCCBPDumpFastForwardCCB(RGX_CLIENT_CCB *psClientCCB, IMG_UINT32 ui
 static PVRSRV_ERROR _RGXCCBPDumpTransition(void *pvData, void *pvDevice, PDUMP_TRANSITION_EVENT eEvent, IMG_UINT32 ui32PDumpFlags)
 {
 	RGX_CLIENT_CCB *psClientCCB = (RGX_CLIENT_CCB *) pvData;
+	PVRSRV_ERROR eError;
 #if defined(PDUMP)
 	PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO *) pvDevice;
+#else
+	PVR_UNREFERENCED_PARAMETER(pvDevice);
 #endif
-	PVRSRV_ERROR eError;
 
 	/* Block mode:
 	 * Here is block structure at transition (ui32BlockLength=N frames):
@@ -393,6 +375,12 @@ static PVRSRV_ERROR _RGXCCBPDumpTransition(void *pvData, void *pvDevice, PDUMP_T
 				}
 				break;
 			}
+		case PDUMP_TRANSITION_EVENT_RANGE_APPEND:
+			{
+				/* Capture range already entered. Skip dump sync and fast forward.
+				 */
+				break;
+			}
 		case PDUMP_TRANSITION_EVENT_RANGE_EXITED:
 			{
 				/* Nothing to do */
@@ -617,7 +605,9 @@ PVRSRV_ERROR RGXCreateCCB(PVRSRV_RGXDEV_INFO	*psDevInfo,
 								PVRSRV_MEMALLOCFLAG_GPU_READABLE |
 								PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
 								PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC |
-								PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC |
+#if defined(DEBUG)
+								PVRSRV_MEMALLOCFLAG_POISON_ON_ALLOC |
+#endif
 								PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE |
 								PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN);
 
@@ -805,7 +795,6 @@ PVRSRV_ERROR RGXCreateCCB(PVRSRV_RGXDEV_INFO	*psDevInfo,
 
 	psClientCCB->ui32HostWriteOffset = 0;
 	psClientCCB->ui32LastPDumpWriteOffset = 0;
-	psClientCCB->ui32FinishedPDumpWriteOffset = 0;
 	psClientCCB->ui32Size = ui32AllocSize;
 	psClientCCB->ui32LastROff = ui32AllocSize - 1;
 	psClientCCB->ui32ByteCount = 0;
@@ -921,9 +910,7 @@ static PVRSRV_ERROR _RGXCCBMemChangeSparse(RGX_CLIENT_CCB *psClientCCB,
 	PVRSRV_ERROR eError;
 	IMG_UINT32	 i;
 
-#ifdef PVRSRV_UNMAP_ON_SPARSE_CHANGE
 	DevmemReleaseCpuVirtAddr(psClientCCB->psClientCCBMemDesc);
-#endif
 
 	for (i = 0; i < ui32AllocPageCount; i++)
 	{
@@ -936,28 +923,22 @@ static PVRSRV_ERROR _RGXCCBMemChangeSparse(RGX_CLIENT_CCB *psClientCCB,
 									psClientCCB->pui32MappingTable,
 									0,
 									NULL,
-#if !defined(PVRSRV_UNMAP_ON_SPARSE_CHANGE)
-									SPARSE_MAP_CPU_ADDR |
-#endif
 									SPARSE_RESIZE_ALLOC);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "RGXAcquireCCB: Failed to grow RGX client CCB (%s)",
 				PVRSRVGetErrorString(eError)));
 
-#ifdef PVRSRV_UNMAP_ON_SPARSE_CHANGE
 		if (DevmemAcquireCpuVirtAddr(psClientCCB->psClientCCBMemDesc,
 									&psClientCCB->pvClientCCB) != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "RGXAcquireCCB: Failed to reacquire CCB mapping"));
 			psClientCCB->pvClientCCB = NULL;
 		}
-#endif
 
 		return eError;
 	}
 
-#ifdef PVRSRV_UNMAP_ON_SPARSE_CHANGE
 	eError = DevmemAcquireCpuVirtAddr(psClientCCB->psClientCCBMemDesc,
 									&psClientCCB->pvClientCCB);
 	if (eError != PVRSRV_OK)
@@ -966,7 +947,6 @@ static PVRSRV_ERROR _RGXCCBMemChangeSparse(RGX_CLIENT_CCB *psClientCCB,
 				PVRSRVGetErrorString(eError)));
 		return eError;
 	}
-#endif
 
 	return PVRSRV_OK;
 }
@@ -1077,15 +1057,20 @@ PVRSRV_ERROR RGXAcquireCCB(RGX_CLIENT_CCB *psClientCCB,
 		bPDumpEnabled &&
 		!PDumpCheckFlagsWrite(psDeviceNode, PDUMP_FLAGS_NONE))
 	{
+		PDUMP_TRANSITION_EVENT eTransitionEvent = BIT_ISSET(psClientCCB->ui32CCBFlags, CCB_FLAGS_CCB_STATE_OPEN) ?
+			PDUMP_TRANSITION_EVENT_RANGE_APPEND : PDUMP_TRANSITION_EVENT_RANGE_ENTERED;
+
 		eError = PDumpTransition(psDeviceNode,
 		                         psClientCCB->psPDumpConnectionData,
-		                         PDUMP_TRANSITION_EVENT_RANGE_ENTERED,
+		                         eTransitionEvent,
 		                         ui32PDumpFlags);
 		if (eError != PVRSRV_OK)
 		{
 			return eError;
 		}
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
 #endif
 
 	/* Check that the CCB can hold this command + padding */
@@ -1365,11 +1350,15 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 								IMG_UINT32		ui32CmdSize,
 								IMG_UINT32		ui32PDumpFlags)
 {
+	IMG_UINT32 ui32NewWriteOffset;
+
 #if defined(PDUMP)
 	PVRSRV_RGXDEV_INFO *psDevInfo = FWCommonContextGetRGXDevInfo(psClientCCB->psServerCommonContext);
 	PVRSRV_DEVICE_NODE *psDeviceNode = psDevInfo->psDeviceNode;
 	IMG_BOOL	bPDumpEnabled = PDumpCheckFlagsWrite(psDeviceNode, ui32PDumpFlags);
 	IMG_BOOL	bPDumpFlagsContinuous = PDUMP_IS_CONTINUOUS(ui32PDumpFlags);
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
 #endif
 
 #if defined(PVRSRV_ENABLE_CCCB_GROW)
@@ -1422,6 +1411,8 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 				IMG_UINT32  ui32NumUFOs = psCmdHeader->ui32CmdSize / sizeof(RGXFWIF_UFO);
 				RGXFWIF_UFO *psUFOPtr   = IMG_OFFSET_ADDR(pvBufferStart, sizeof(RGXFWIF_CCB_CMD_HEADER));
 
+				PVR_ASSERT(ui32NumUFOs != 0);
+
 				psClientCCB->ui32UpdateEntries = 0;
 				while (ui32NumUFOs-- > 0)
 				{
@@ -1438,6 +1429,8 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 				IMG_UINT32  ui32NumUFOs = psCmdHeader->ui32CmdSize / sizeof(RGXFWIF_UFO);
 				RGXFWIF_UFO *psUFOPtr   = IMG_OFFSET_ADDR(pvBufferStart, sizeof(RGXFWIF_CCB_CMD_HEADER));
 
+				PVR_ASSERT(ui32NumUFOs != 0);
+
 				while (ui32NumUFOs-- > 0)
 				{
 					PVR_ASSERT(psUFOPtr->puiAddrUFO.ui32Addr != 0);
@@ -1477,13 +1470,14 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 					psUFOPtr++;
 				}
 			}
-			else if (psCmdHeader->eCmdType == RGXFWIF_CCB_CMD_TYPE_FENCE_PR  ||
-					 psCmdHeader->eCmdType == RGXFWIF_CCB_CMD_TYPE_UNFENCED_UPDATE)
+			else if (psCmdHeader->eCmdType == RGXFWIF_CCB_CMD_TYPE_FENCE_PR)
 			{
 				/* For all other UFO ops check the UFO address is not NULL. */
 				IMG_UINT32  ui32NumUFOs = psCmdHeader->ui32CmdSize / sizeof(RGXFWIF_UFO);
 				RGXFWIF_UFO *psUFOPtr   = IMG_OFFSET_ADDR(pvBufferStart, sizeof(RGXFWIF_CCB_CMD_HEADER));
 
+				PVR_ASSERT(ui32NumUFOs != 0);
+
 				while (ui32NumUFOs-- > 0)
 				{
 					PVR_ASSERT(psUFOPtr->puiAddrUFO.ui32Addr != 0);
@@ -1517,20 +1511,23 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 
 	}
 #endif
-	/* Flush the CCB data */
-	RGXFwSharedMemFlushCCB(psClientCCB->pvClientCCB,
-	                       psClientCCB->psClientCCBCtrl->ui32ReadOffset,
-	                       psClientCCB->ui32HostWriteOffset,
-	                       psClientCCB->psClientCCBCtrl->ui32WrapMask + 1);
 
+	ui32NewWriteOffset = psClientCCB->ui32HostWriteOffset;
 	/*
 	 * Update the CCB write offset.
 	 */
-	UPDATE_CCB_OFFSET(psClientCCB->ui32HostWriteOffset,
-					  ui32CmdSize,
-					  psClientCCB->ui32Size);
+	UPDATE_CCB_OFFSET(ui32NewWriteOffset, ui32CmdSize,
+	                  psClientCCB->ui32Size);
 	psClientCCB->ui32ByteCount += ui32CmdSize;
 
+	/* Flush the CCB data */
+	RGXFwSharedMemFlushCCB(psClientCCB->pvClientCCB,
+	                       psClientCCB->ui32HostWriteOffset,
+	                       ui32NewWriteOffset,
+	                       psClientCCB->psClientCCBCtrl->ui32WrapMask + 1);
+
+	psClientCCB->ui32HostWriteOffset = ui32NewWriteOffset;
+
 #if defined(PVRSRV_ENABLE_CCCB_UTILISATION_INFO)
 	_RGXUpdateCCBUtilisation(psClientCCB);
 #endif
@@ -1560,14 +1557,6 @@ void RGXReleaseCCB(RGX_CLIENT_CCB *psClientCCB,
 
 	if (bPDumpEnabled)
 	{
-		if (!BIT_ISSET(psClientCCB->ui32CCBFlags, CCB_FLAGS_CCB_STATE_OPEN))
-		{
-			/* Store offset to last finished CCB command. This offset can
-			 * be needed when appending commands to a non finished CCB.
-			 */
-			psClientCCB->ui32FinishedPDumpWriteOffset = psClientCCB->ui32LastPDumpWriteOffset;
-		}
-
 		/* Update the PDump write offset to show we PDumped this command */
 		psClientCCB->ui32LastPDumpWriteOffset = psClientCCB->ui32HostWriteOffset;
 	}
@@ -1622,8 +1611,6 @@ void RGXCmdHelperInitCmdCCB_CommandSize(PVRSRV_RGXDEV_INFO *psDevInfo,
                                         PRGXFWIF_UFO_ADDR         *ppRMWUFOAddr,
                                         RGX_CCB_CMD_HELPER_DATA *psCmdHelperData)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = psDevInfo->psDeviceNode;
-	IMG_BOOL bCacheInval = IMG_TRUE;
 	IMG_UINT32 ui32FenceCmdSize = 0;
 	IMG_UINT32 ui32UpdateCmdSize = 0;
 
@@ -1634,32 +1621,13 @@ void RGXCmdHelperInitCmdCCB_CommandSize(PVRSRV_RGXDEV_INFO *psDevInfo,
 	psCmdHelperData->ui32PostTimeStampCmdSize = 0;
 	psCmdHelperData->ui32RMWUFOCmdSize = 0;
 
-	/* Only compile if RGX_FEATURE_PDS_INSTRUCTION_CACHE_AUTO_INVALIDATE is defined to avoid
-	 * compilation errors on rogue cores.
-	 */
-#if defined(RGX_FEATURE_PDS_INSTRUCTION_CACHE_AUTO_INVALIDATE)
-	bCacheInval = !(PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, PDS_INSTRUCTION_CACHE_AUTO_INVALIDATE) &&
-				    PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, USC_INSTRUCTION_CACHE_AUTO_INVALIDATE) &&
-				    PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, TDM_SLC_MMU_AUTO_CACHE_OPS) &&
-				    PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, GEOM_SLC_MMU_AUTO_CACHE_OPS) &&
-				    PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, FRAG_SLC_MMU_AUTO_CACHE_OPS) &&
-				    PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, COMPUTE_SLC_MMU_AUTO_CACHE_OPS)) ||
-				    RGX_IS_BRN_SUPPORTED(psDevInfo, 71960) ||
-				    RGX_IS_BRN_SUPPORTED(psDevInfo, 72143);
-#else
-	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
-#endif
-
 	/* Total FBSC invalidate command size (header plus command data) */
-	if (bCacheInval)
+	if (ui64FBSCEntryMask != 0)
 	{
-		if (ui64FBSCEntryMask != 0)
-		{
-			psCmdHelperData->ui32FBSCInvalCmdSize =
+		psCmdHelperData->ui32FBSCInvalCmdSize =
 			        RGX_CCB_FWALLOC_ALIGN(sizeof(psCmdHelperData->ui64FBSCEntryMask) +
 			                              sizeof(RGXFWIF_CCB_CMD_HEADER));
-			psCmdHelperData->ui64FBSCEntryMask = ui64FBSCEntryMask;
-		}
+		psCmdHelperData->ui64FBSCEntryMask = ui64FBSCEntryMask;
 	}
 
 	/* total DM command size (header plus command data) */
@@ -1716,7 +1684,8 @@ void RGXCmdHelperInitCmdCCB_CommandSize(PVRSRV_RGXDEV_INFO *psDevInfo,
 /*
 	Work out how much space this command will require
 */
-void RGXCmdHelperInitCmdCCB_OtherData(RGX_CLIENT_CCB            *psClientCCB,
+void RGXCmdHelperInitCmdCCB_OtherData(PVRSRV_RGXDEV_INFO        *psDevInfo,
+                                      RGX_CLIENT_CCB            *psClientCCB,
                                       IMG_UINT32                ui32ClientFenceCount,
                                       PRGXFWIF_UFO_ADDR         *pauiFenceUFOAddress,
                                       IMG_UINT32                *paui32FenceValue,
@@ -1737,8 +1706,6 @@ void RGXCmdHelperInitCmdCCB_OtherData(RGX_CLIENT_CCB            *psClientCCB,
                                       IMG_BOOL                  bCCBStateOpen,
                                       RGX_CCB_CMD_HELPER_DATA   *psCmdHelperData)
 {
-	PVRSRV_RGXDEV_INFO *psDevInfo = NULL;
-
 	/* Job reference values */
 	psCmdHelperData->ui32ExtJobRef = ui32ExtJobRef;
 	psCmdHelperData->ui32IntJobRef = ui32IntJobRef;
@@ -1747,9 +1714,8 @@ void RGXCmdHelperInitCmdCCB_OtherData(RGX_CLIENT_CCB            *psClientCCB,
 	psCmdHelperData->psClientCCB = psClientCCB;
 #if defined(PDUMP)
 	psCmdHelperData->ui32PDumpFlags = ui32PDumpFlags;
-	psDevInfo = FWCommonContextGetRGXDevInfo(psCmdHelperData->psClientCCB->psServerCommonContext);
 #else
-	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
 #endif
 	psCmdHelperData->pszCommandName = pszCommandName;
 	if (bCCBStateOpen)
@@ -1794,11 +1760,14 @@ void RGXCmdHelperInitCmdCCB_OtherData(RGX_CLIENT_CCB            *psClientCCB,
 			FWCommonContextGetFWAddress(psClientCCB->psServerCommonContext).ui32Addr);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		/* Workload Data added */
 		psCmdHelperData->psWorkEstKickData = psWorkEstKickData;
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+	PVR_UNREFERENCED_PARAMETER(psWorkEstKickData);
 #endif
 }
 
@@ -1838,7 +1807,8 @@ void RGXCmdHelperInitCmdCCB(PVRSRV_RGXDEV_INFO		*psDevInfo,
 	                                 ppRMWUFOAddr,
 	                                 psCmdHelperData);
 
-	RGXCmdHelperInitCmdCCB_OtherData(psClientCCB,
+	RGXCmdHelperInitCmdCCB_OtherData(psDevInfo,
+	                                 psClientCCB,
 	                                 ui32ClientFenceCount,
 	                                 pauiFenceUFOAddress,
 	                                 paui32FenceValue,
@@ -1860,6 +1830,36 @@ void RGXCmdHelperInitCmdCCB(PVRSRV_RGXDEV_INFO		*psDevInfo,
 	                                 psCmdHelperData);
 }
 
+#if defined(SUPPORT_WORKLOAD_ESTIMATION)
+/*************************************************************************/ /*!
+@Function       RGXIsValidWorkloadEstCCBCommand
+
+@Description    Checks if command type can be used for workload estimation
+
+@Input          eType       Command type to check
+
+
+@Return        IMG_BOOL
+******************************************************************************/
+FORCE_INLINE IMG_BOOL RGXIsValidWorkloadEstCCBCommand(RGXFWIF_CCB_CMD_TYPE eType)
+{
+	switch (eType)
+	{
+			case RGXFWIF_CCB_CMD_TYPE_GEOM:
+			case RGXFWIF_CCB_CMD_TYPE_3D:
+			case RGXFWIF_CCB_CMD_TYPE_CDM:
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+			case RGXFWIF_CCB_CMD_TYPE_RAY:
+#endif
+			case RGXFWIF_CCB_CMD_TYPE_TQ_TDM:
+				return IMG_TRUE;
+			default:
+				PVR_ASSERT(IMG_FALSE);
+				return IMG_FALSE;
+	}
+}
+#endif
+
 static inline void RGXWriteCmdHeader(void *pvCCB, IMG_UINT32 eCmdType, IMG_UINT32 ui32TotalSize,
 									 IMG_UINT32 ui32ExtJobRef, IMG_UINT32 ui32IntJobRef,
 									 RGXFWIF_WORKEST_KICK_DATA *psWorkEstKickData)
@@ -1872,25 +1872,23 @@ static inline void RGXWriteCmdHeader(void *pvCCB, IMG_UINT32 eCmdType, IMG_UINT3
 	sCmdHeader.ui32IntJobRef = ui32IntJobRef;
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (psWorkEstKickData != NULL &&
+		RGXIsValidWorkloadEstCCBCommand(eCmdType))
 	{
-		if (psWorkEstKickData != NULL &&
-			RGXIsValidWorkloadEstCCBCommand(eCmdType))
-		{
-			sCmdHeader.sWorkEstKickData = *psWorkEstKickData;
-		}
-		else
-		{
-			sCmdHeader.sWorkEstKickData.ui16ReturnDataIndex = 0;
-			sCmdHeader.sWorkEstKickData.ui64Deadline = 0;
-			sCmdHeader.sWorkEstKickData.ui32CyclesPrediction = 0;
-		}
+		sCmdHeader.sWorkEstKickData = *psWorkEstKickData;
+	}
+	else
+	{
+		sCmdHeader.sWorkEstKickData.ui16ReturnDataIndex = 0;
+		sCmdHeader.sWorkEstKickData.ui64Deadline = 0;
+		sCmdHeader.sWorkEstKickData.ui32CyclesPrediction = 0;
 	}
 #else
 	PVR_UNREFERENCED_PARAMETER(psWorkEstKickData);
 #endif
 
 	OSCachedMemCopy(pvCCB, &sCmdHeader, sizeof(RGXFWIF_CCB_CMD_HEADER));
+
 }
 
 /*
@@ -1903,9 +1901,7 @@ PVRSRV_ERROR RGXCmdHelperAcquireCmdCCB(IMG_UINT32 ui32CmdCount,
 	IMG_UINT32 i;
 	void *pvStartPtr;
 	PVRSRV_ERROR eError;
-#if defined(PDUMP)
 	PVRSRV_RGXDEV_INFO *psDevInfo = FWCommonContextGetRGXDevInfo(asCmdHelperData->psClientCCB->psServerCommonContext);
-#endif
 	RGXFWIF_UFO asUFOs[RGXFWIF_CCB_CMD_MAX_UFOS];
 
 	/*
@@ -2082,7 +2078,7 @@ PVRSRV_ERROR RGXCmdHelperAcquireCmdCCB(IMG_UINT32 ui32CmdCount,
 							  psCmdHelperData->ui32DMCmdSize,
 							  psCmdHelperData->ui32ExtJobRef,
 							  psCmdHelperData->ui32IntJobRef,
-							  psCmdHelperData->psWorkEstKickData);
+							  (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo)) ? NULL : psCmdHelperData->psWorkEstKickData);
 
 			OSCachedMemCopy(IMG_OFFSET_ADDR(pvCmdPtr, sizeof(RGXFWIF_CCB_CMD_HEADER)),
 							psCmdHelperData->pui8DMCmd,
@@ -2253,6 +2249,9 @@ void RGXCmdHelperReleaseCmdCCB(IMG_UINT32 ui32CmdCount,
 									  psCmdHelperData->pauiUpdateUFOAddress,
 									  psCmdHelperData->paui32UpdateValue);
 		}
+#else
+	PVR_UNREFERENCED_PARAMETER(pcszDMName);
+	PVR_UNREFERENCED_PARAMETER(ui32CtxAddr);
 #endif
 
 		/*
@@ -2319,11 +2318,9 @@ static const char *_CCBCmdTypename(RGXFWIF_CCB_CMD_TYPE cmdType)
 		case RGXFWIF_CCB_CMD_TYPE_UPDATE: return "UPDATE";
 		case RGXFWIF_CCB_CMD_TYPE_FENCE_PR: return "FENCE_PR";
 		case RGXFWIF_CCB_CMD_TYPE_PRIORITY: return "PRIORITY";
-		case RGXFWIF_CCB_CMD_TYPE_UNFENCED_UPDATE: return "UNFENCED_UPDATE";
 		case RGXFWIF_CCB_CMD_TYPE_PRE_TIMESTAMP: return "PRE_TIMESTAMP";
 		case RGXFWIF_CCB_CMD_TYPE_RMW_UPDATE: return "RMW_UPDATE";
 		case RGXFWIF_CCB_CMD_TYPE_POST_TIMESTAMP: return "POST_TIMESTAMP";
-		case RGXFWIF_CCB_CMD_TYPE_UNFENCED_RMW_UPDATE: return "UNFENCED_RMW_UPDATE";
 		case RGXFWIF_CCB_CMD_TYPE_PADDING: return "PADDING";
 
 		default:
@@ -2551,7 +2548,6 @@ void DumpCCB(PVRSRV_RGXDEV_INFO *psDevInfo,
 		switch (psCmdHeader->eCmdType)
 		{
 			case RGXFWIF_CCB_CMD_TYPE_UPDATE:
-			case RGXFWIF_CCB_CMD_TYPE_UNFENCED_UPDATE:
 			case RGXFWIF_CCB_CMD_TYPE_FENCE:
 			case RGXFWIF_CCB_CMD_TYPE_FENCE_PR:
 			{
@@ -2583,7 +2579,6 @@ void DumpCCB(PVRSRV_RGXDEV_INFO *psDevInfo,
 				break;
 			}
 			case RGXFWIF_CCB_CMD_TYPE_RMW_UPDATE:
-			case RGXFWIF_CCB_CMD_TYPE_UNFENCED_RMW_UPDATE:
 			{
 				for (i = 0; i < ui32NoOfUpdates; i++, psUFOPtr++)
 				{
@@ -2617,7 +2612,7 @@ void DumpCCB(PVRSRV_RGXDEV_INFO *psDevInfo,
 		}
 
 		/* Check the command size is valid, otherwise if corruption was present this loop might hang... */
-		if ((psCmdHeader->ui32CmdSize == 0) || (ui32Offset == ui32NextOffset) ||
+		if ((ui32Offset == ui32NextOffset) ||
 		    ((ui32Offset + psCmdHeader->ui32CmdSize + sizeof(RGXFWIF_CCB_CMD_HEADER)) > ui32WrapMask+1))
 		{
 			PVR_DUMPDEBUG_LOG("  `--Invalid CCB offset!");
@@ -2771,7 +2766,7 @@ void DumpStalledContextInfo(PVRSRV_RGXDEV_INFO *psDevInfo)
 				OSClockMonotonicns64(&psDevInfo->psRGXFWIfFwOsData->sSLRLogFirst.ui64Timestamp);
 				psDevInfo->psRGXFWIfFwOsData->sSLRLogFirst.ui32NumUFOs = (IMG_UINT32)(psCommandHeader->ui32CmdSize/sizeof(RGXFWIF_UFO));
 				psDevInfo->psRGXFWIfFwOsData->sSLRLogFirst.ui32FWCtxAddr = FWCommonContextGetFWAddress(psStalledClientCCB->psServerCommonContext).ui32Addr;
-				OSStringLCopy(psDevInfo->psRGXFWIfFwOsData->sSLRLogFirst.aszCCBName,
+				OSStringSafeCopy(psDevInfo->psRGXFWIfFwOsData->sSLRLogFirst.aszCCBName,
 				              psStalledClientCCB->szName,
 				              MAX_CLIENT_CCB_NAME);
 			}
@@ -2780,7 +2775,7 @@ void DumpStalledContextInfo(PVRSRV_RGXDEV_INFO *psDevInfo)
 				OSClockMonotonicns64(&psDevInfo->psRGXFWIfFwOsData->sSLRLog[psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp].ui64Timestamp);
 				psDevInfo->psRGXFWIfFwOsData->sSLRLog[psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp].ui32NumUFOs = (IMG_UINT32)(psCommandHeader->ui32CmdSize/sizeof(RGXFWIF_UFO));
 				psDevInfo->psRGXFWIfFwOsData->sSLRLog[psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp].ui32FWCtxAddr = FWCommonContextGetFWAddress(psStalledClientCCB->psServerCommonContext).ui32Addr;
-				OSStringLCopy(psDevInfo->psRGXFWIfFwOsData->sSLRLog[psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp].aszCCBName,
+				OSStringSafeCopy(psDevInfo->psRGXFWIfFwOsData->sSLRLog[psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp].aszCCBName,
 				              psStalledClientCCB->szName,
 				              MAX_CLIENT_CCB_NAME);
 				psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp = (psDevInfo->psRGXFWIfFwOsData->ui8SLRLogWp + 1) % PVR_SLR_LOG_ENTRIES;
diff --git a/drivers/gpu/drm/img-rogue/rgxccb.h b/drivers/gpu/drm/img-rogue/rgxccb.h
index 1389fd05bb77..e9edd9a37bc3 100644
--- a/drivers/gpu/drm/img-rogue/rgxccb.h
+++ b/drivers/gpu/drm/img-rogue/rgxccb.h
@@ -279,7 +279,8 @@ void RGXCmdHelperInitCmdCCB_CommandSize(PVRSRV_RGXDEV_INFO *psDevInfo,
                                         PRGXFWIF_UFO_ADDR       *ppRMWUFOAddr,
                                         RGX_CCB_CMD_HELPER_DATA *psCmdHelperData);
 
-void RGXCmdHelperInitCmdCCB_OtherData(RGX_CLIENT_CCB *psClientCCB,
+void RGXCmdHelperInitCmdCCB_OtherData(PVRSRV_RGXDEV_INFO *psDevInfo,
+                                      RGX_CLIENT_CCB *psClientCCB,
                                       IMG_UINT32 ui32ClientFenceCount,
                                       PRGXFWIF_UFO_ADDR *pauiFenceUFOAddress,
                                       IMG_UINT32 *paui32FenceValue,
diff --git a/drivers/gpu/drm/img-rogue/rgxcompute.c b/drivers/gpu/drm/img-rogue/rgxcompute.c
index e2d044c3f42e..119dc69a57c4 100644
--- a/drivers/gpu/drm/img-rogue/rgxcompute.c
+++ b/drivers/gpu/drm/img-rogue/rgxcompute.c
@@ -58,6 +58,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxhwperf.h"
 #include "ospvr_gputrace.h"
 #include "htbserver.h"
+#include "rgxshader.h"
 
 #include "sync_server.h"
 #include "sync_internal.h"
@@ -73,6 +74,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "rgxtimerquery.h"
 
+
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
 #include "rgxworkest.h"
 
@@ -188,7 +190,7 @@ PVRSRV_ERROR PVRSRVRGXCreateComputeContextKM(CONNECTION_DATA			*psConnection,
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		WorkEstInitCompute(psDevInfo, &psComputeContext->sWorkEstData);
 	}
@@ -326,16 +328,9 @@ PVRSRV_ERROR PVRSRVRGXDestroyComputeContextKM(RGX_SERVER_COMPUTE_CONTEXT *psComp
 											  RGXFWIF_DM_CDM,
 											  PDUMP_FLAGS_NONE);
 
-	if (RGXIsErrorAndDeviceRecoverable(psComputeContext->psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psComputeContext->psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 #if defined(SUPPORT_BUFFER_SYNC)
 	/* remove after RGXFWRequestCommonContextCleanUp() because we might return
@@ -348,7 +343,7 @@ PVRSRV_ERROR PVRSRVRGXDestroyComputeContextKM(RGX_SERVER_COMPUTE_CONTEXT *psComp
 #endif
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		RGXFWIF_FWCOMPUTECONTEXT	*psFWComputeContext;
 		IMG_UINT32 ui32WorkEstCCBSubmitted;
@@ -388,7 +383,7 @@ PVRSRV_ERROR PVRSRVRGXDestroyComputeContextKM(RGX_SERVER_COMPUTE_CONTEXT *psComp
 	OSWRLockReleaseWrite(psDevInfo->hComputeCtxListLock);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		WorkEstDeInitCompute(psDevInfo, &psComputeContext->sWorkEstData);
 	}
@@ -413,7 +408,6 @@ PVRSRV_ERROR PVRSRVRGXDestroyComputeContextKM(RGX_SERVER_COMPUTE_CONTEXT *psComp
 	return PVRSRV_OK;
 }
 
-
 PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 								IMG_UINT32					ui32ClientUpdateCount,
 								SYNC_PRIMITIVE_BLOCK		**pauiClientUpdateUFODevVarBlock,
@@ -423,6 +417,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 								PVRSRV_TIMELINE				iUpdateTimeline,
 								PVRSRV_FENCE				*piUpdateFence,
 								IMG_CHAR					pszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
+								PVRSRV_FENCE				iExportFenceToSignal,
 								IMG_UINT32					ui32CmdSize,
 								IMG_PBYTE					pui8DMCmd,
 								IMG_UINT32					ui32PDumpFlags,
@@ -432,7 +427,8 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 								PMR							**ppsSyncPMRs,
 								IMG_UINT32					ui32NumWorkgroups,
 								IMG_UINT32					ui32NumWorkitems,
-								IMG_UINT64					ui64DeadlineInus)
+								IMG_UINT64					ui64DeadlineInus,
+								IMG_PUINT32					pui32IntJobRef)
 {
 	RGXFWIF_KCCB_CMD		sCmpKCCBCmd;
 	RGX_CCB_CMD_HELPER_DATA	asCmdHelperData[1];
@@ -466,6 +462,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	IMG_UINT64 uiCheckFenceUID = 0;
 	IMG_UINT64 uiUpdateFenceUID = 0;
 	PSYNC_CHECKPOINT psUpdateSyncCheckpoint = NULL;
+	PSYNC_CHECKPOINT psExportFenceSyncCheckpoint = NULL;
 	PSYNC_CHECKPOINT *apsFenceSyncCheckpoints = NULL;
 	IMG_UINT32 ui32FenceSyncCheckpointCount = 0;
 	IMG_UINT32 *pui32IntAllocatedUpdateValues = NULL;
@@ -484,9 +481,17 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 
 	if (iUpdateTimeline >= 0 && !piUpdateFence)
 	{
+		PVR_DPF((PVR_DBG_ERROR, "%s:   "
+				"iUpdateTimeline=%d but piUpdateFence is NULL - PVRSRV_ERROR_INVALID_PARAMS",
+				__func__, iUpdateTimeline));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	if (pui32IntJobRef)
+	{
+		*pui32IntJobRef = ui32IntJobRef;
+	}
+
 	/* Ensure we haven't been given a null ptr to
 	 * update values if we have been told we
 	 * have updates
@@ -500,7 +505,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	}
 
 	/* Ensure the string is null-terminated (Required for safety) */
-	pszUpdateFenceName[31] = '\0';
+	pszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH-1] = '\0';
 
 	OSLockAcquire(psComputeContext->hLock);
 
@@ -606,6 +611,9 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 			ui32IntClientUpdateCount++;
 		}
 #else /* defined(SUPPORT_BUFFER_SYNC) */
+		PVR_UNREFERENCED_PARAMETER(paui32SyncPMRFlags);
+		PVR_UNREFERENCED_PARAMETER(ppsSyncPMRs);
+
 		PVR_DPF((PVR_DBG_ERROR, "%s: Buffer sync not supported but got %u buffers",
 		        __func__, ui32SyncPMRCount));
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
@@ -625,7 +633,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 		CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, returned ERROR (%s)", __func__, PVRSRVGetErrorString(eError)));
 		goto fail_free_buffer_sync_data;
 	}
-	CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, fence %d contained %d checkpoints (apsFenceSyncCheckpoints=<%p>)", __func__, iCheckFence, ui32FenceSyncCheckpointCount, (void*)apsFenceSyncCheckpoints));
+	CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, iCheckFence %d contained %d checkpoints (apsFenceSyncCheckpoints=<%p>)", __func__, iCheckFence, ui32FenceSyncCheckpointCount, (void*)apsFenceSyncCheckpoints));
 #if defined(CMP_CHECKPOINT_DEBUG)
 	if (ui32FenceSyncCheckpointCount > 0)
 	{
@@ -633,7 +641,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 		for (ii=0; ii<ui32FenceSyncCheckpointCount; ii++)
 		{
 			PSYNC_CHECKPOINT psNextCheckpoint = *(apsFenceSyncCheckpoints + ii);
-			CHKPT_DBG((PVR_DBG_ERROR, "%s:    apsFenceSyncCheckpoints[%d]=<%p>", __func__, ii, (void*)psNextCheckpoint));
+			CHKPT_DBG((PVR_DBG_ERROR, "%s:    apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, ii, (void*)psNextCheckpoint, SyncCheckpointGetFirmwareAddr(psNextCheckpoint)));
 		}
 	}
 #endif
@@ -660,6 +668,48 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 
 		CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned from SyncCheckpointCreateFence (iUpdateFence=%d, psFenceTimelineUpdateSync=<%p>, ui32FenceTimelineUpdateValue=%u)", __func__, iUpdateFence, psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue));
 
+		CHKPT_DBG((PVR_DBG_ERROR, "%s: iExportFenceToSignal=%d", __func__, iExportFenceToSignal));
+		/* Resolve the iExportFenceToSignal (if required) */
+		if (iExportFenceToSignal != PVRSRV_NO_FENCE)
+		{
+			CHKPT_DBG((PVR_DBG_ERROR, "%s: SyncCheckpointResolveExportFence(iExportFenceToSignal=%d), ui32FenceSyncCheckpointCount=%d", __func__, iExportFenceToSignal, ui32FenceSyncCheckpointCount));
+			eError = SyncCheckpointResolveExportFence(iExportFenceToSignal,
+			                                          psComputeContext->psDeviceNode->hSyncCheckpointContext,
+			                                          &psExportFenceSyncCheckpoint,
+			                                          ui32PDumpFlags);
+			if (eError != PVRSRV_OK)
+			{
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned error (%s) psExportFenceSyncCheckpoint=<%p>", __func__, PVRSRVGetErrorString(eError), psExportFenceSyncCheckpoint));
+				goto fail_resolve_export_fence;
+			}
+
+			/* Check that the export fence was not also included as part of the
+			 * check fence (which is an error and would lead to a stalled kick).
+			 */
+			if (ui32FenceSyncCheckpointCount > 0)
+			{
+				CHKPT_DBG((PVR_DBG_ERROR, "%s:   Checking export fence is not part of check fence...", __func__));
+				CHKPT_DBG((PVR_DBG_ERROR, "%s:   ui32FenceSyncCheckpointCount=%d",
+						   __func__, ui32FenceSyncCheckpointCount));
+				if (ui32FenceSyncCheckpointCount > 0)
+				{
+					IMG_UINT32 iii;
+
+					for (iii=0; iii<ui32FenceSyncCheckpointCount; iii++)
+					{
+						CHKPT_DBG((PVR_DBG_ERROR, "%s: apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, iii, apsFenceSyncCheckpoints[iii], SyncCheckpointGetFirmwareAddr(apsFenceSyncCheckpoints[iii])));
+						if (apsFenceSyncCheckpoints[iii] == psExportFenceSyncCheckpoint)
+						{
+							CHKPT_DBG((PVR_DBG_ERROR, "%s: ERROR psExportFenceSyncCheckpoint=<%p>", __func__, psExportFenceSyncCheckpoint));
+							eError = PVRSRV_ERROR_INVALID_PARAMS;
+							PVR_DPF((PVR_DBG_ERROR, " %s - iCheckFence includes iExportFenceToSignal", PVRSRVGetErrorString(eError)));
+							goto fail_check_fence_includes_export_fence;
+						}
+					}
+				}
+			}
+		}
+
 		CHKPT_DBG((PVR_DBG_ERROR, "%s: ui32IntClientUpdateCount=%u, psFenceTimelineUpdateSync=<%p>", __func__, ui32IntClientUpdateCount, (void*)psFenceTimelineUpdateSync));
 		/* Append the sync prim update for the timeline (if required) */
 		if (psFenceTimelineUpdateSync)
@@ -729,15 +779,13 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	{
 		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append %d sync checkpoints to Compute CDM Fence (&psComputeContext->sSyncAddrListFence=<%p>)...", __func__, ui32FenceSyncCheckpointCount, (void*)&psComputeContext->sSyncAddrListFence));
 #if defined(CMP_CHECKPOINT_DEBUG)
-		if (ui32IntClientUpdateCount > 0)
+		if (ui32FenceSyncCheckpointCount > 0)
 		{
 			IMG_UINT32 iii;
-			IMG_UINT32 *pui32Tmp = (IMG_UINT32*)pauiIntFenceUFOAddress;
 
-			for (iii=0; iii<ui32IntClientUpdateCount; iii++)
+			for (iii=0; iii<ui32FenceSyncCheckpointCount; iii++)
 			{
-				CHKPT_DBG((PVR_DBG_ERROR, "%s: pui32IntAllocatedUpdateValues[%d](<%p>) = 0x%x", __func__, iii, (void*)pui32Tmp, *pui32Tmp));
-				pui32Tmp++;
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, iii, apsFenceSyncCheckpoints[iii], SyncCheckpointGetFirmwareAddr(apsFenceSyncCheckpoints[iii])));
 			}
 		}
 #endif
@@ -793,6 +841,34 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 		}
 #endif
 	}
+
+	if (psExportFenceSyncCheckpoint)
+	{
+		/* Append the update (from export fence) */
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append 1 sync checkpoint to Compute CDM Update (&psComputeContext->sSyncAddrListUpdate=<%p>, psExportFenceSyncCheckpoint=<%p>)...", __func__, (void*)&psComputeContext->sSyncAddrListUpdate , (void*)psExportFenceSyncCheckpoint));
+		SyncAddrListAppendCheckpoints(&psComputeContext->sSyncAddrListUpdate,
+									  1,
+									  &psExportFenceSyncCheckpoint);
+		if (!pauiIntUpdateUFOAddress)
+		{
+			pauiIntUpdateUFOAddress = psComputeContext->sSyncAddrListUpdate.pasFWAddrs;
+		}
+		ui32IntClientUpdateCount++;
+#if defined(CMP_CHECKPOINT_DEBUG)
+		if (ui32IntClientUpdateCount > 0)
+		{
+			IMG_UINT32 iii;
+			IMG_UINT32 *pui32Tmp = (IMG_UINT32*)pauiIntUpdateUFOAddress;
+
+			CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress=<%p>, pui32Tmp=<%p>, ui32IntClientUpdateCount=%u", __func__, (void*)pauiIntUpdateUFOAddress, (void*)pui32Tmp, ui32IntClientUpdateCount));
+			for (iii=0; iii<ui32IntClientUpdateCount; iii++)
+			{
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress[%d](<%p>) = 0x%x", __func__, iii, (void*)pui32Tmp, *pui32Tmp));
+				pui32Tmp++;
+			}
+		}
+#endif
+	}
 	CHKPT_DBG((PVR_DBG_ERROR, "%s:   (after pvr_sync) ui32IntClientFenceCount=%d, ui32IntClientUpdateCount=%d", __func__, ui32IntClientFenceCount, ui32IntClientUpdateCount));
 
 #if (ENABLE_CMP_UFO_DUMP == 1)
@@ -847,7 +923,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 #endif
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psComputeContext->psDeviceNode))
 	{
 		sWorkloadCharacteristics.sCompute.ui32NumberOfWorkgroups = ui32NumWorkgroups;
 		sWorkloadCharacteristics.sCompute.ui32NumberOfWorkitems  = ui32NumWorkitems;
@@ -861,6 +937,10 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 				ui64DeadlineInus,
 				&sWorkloadKickDataCompute);
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32NumWorkgroups);
+	PVR_UNREFERENCED_PARAMETER(ui32NumWorkitems);
+	PVR_UNREFERENCED_PARAMETER(ui64DeadlineInus);
 #endif
 
 	RGX_GetTimestampCmdHelper((PVRSRV_RGXDEV_INFO*) psComputeContext->psDeviceNode->pvDevice,
@@ -898,7 +978,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	eError = RGXCmdHelperAcquireCmdCCB(ARRAY_SIZE(asCmdHelperData), asCmdHelperData);
 	if (eError != PVRSRV_OK)
 	{
-		goto fail_cmdaquire;
+		goto fail_cmdacquire;
 	}
 
 
@@ -937,7 +1017,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	RGXCmdHelperReleaseCmdCCB(1, asCmdHelperData, "CDM", FWCommonContextGetFWAddress(psComputeContext->psServerCommonContext).ui32Addr);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 	{
 		/* The following is used to determine the offset of the command header containing
 		   the workload estimation data so that can be accessed when the KCCB is read */
@@ -968,7 +1048,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 
 	/* Add the Workload data into the KCCB kick */
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 	{
 		/* Store the offset to the CCCB command header so that it can be referenced
 		 * when the KCCB command reaches the FW */
@@ -1005,7 +1085,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	/*
 	 * Submit the compute command to the firmware.
 	 */
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommandWithoutPowerLock(psComputeContext->psDeviceNode->pvDevice,
 									RGXFWIF_DM_CDM,
@@ -1016,7 +1096,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
 
@@ -1039,15 +1119,28 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	/* If NO_HARDWARE, signal the output fence's sync checkpoint and sync prim */
 	if (psUpdateSyncCheckpoint)
 	{
-		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Signalling NOHW sync checkpoint<%p>, ID:%d, FwAddr=0x%x", __func__, (void*)psUpdateSyncCheckpoint, SyncCheckpointGetId(psUpdateSyncCheckpoint), SyncCheckpointGetFirmwareAddr(psUpdateSyncCheckpoint)));
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Signalling NOHW sync checkpoint<%p>, ID:%d, FwAddr=0x%x", __func__,
+		           (void*)psUpdateSyncCheckpoint, SyncCheckpointGetId(psUpdateSyncCheckpoint),
+		           SyncCheckpointGetFirmwareAddr(psUpdateSyncCheckpoint)));
 		SyncCheckpointSignalNoHW(psUpdateSyncCheckpoint);
 	}
 	if (psFenceTimelineUpdateSync)
 	{
-		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Updating NOHW sync prim<%p> to %d", __func__, (void*)psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue));
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Updating NOHW sync prim<%p> to %d", __func__,
+		           (void*)psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue));
 		SyncPrimNoHwUpdate(psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue);
 	}
 	SyncCheckpointNoHWUpdateTimelines(NULL);
+
+	if (psExportFenceSyncCheckpoint)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Signalling NOHW sync checkpoint<%p>, ID:%d, FwAddr=0x%x", __func__,
+		           (void*)psExportFenceSyncCheckpoint, SyncCheckpointGetId(psExportFenceSyncCheckpoint),
+		           SyncCheckpointGetFirmwareAddr(psExportFenceSyncCheckpoint)));
+		SyncCheckpointSignalNoHW(psExportFenceSyncCheckpoint);
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   SyncCheckpointNoHWSignalExportFence(iExportFenceToSignal=%d)", __func__, iExportFenceToSignal));
+		SyncCheckpointNoHWSignalExportFence(iExportFenceToSignal);
+	}
 #endif /* defined(NO_HARDWARE) */
 
 #if defined(SUPPORT_BUFFER_SYNC)
@@ -1091,13 +1184,19 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 
 fail_schedulecmd:
 fail_acquirepowerlock:
-fail_cmdaquire:
+fail_cmdacquire:
 #if defined(RGX_FBSC_INVALIDATE_COMMAND_SUPPORTED)
 fail_cmdinvalfbsc:
 #endif
 	SyncAddrListRollbackCheckpoints(psComputeContext->psDeviceNode, &psComputeContext->sSyncAddrListFence);
 	SyncAddrListRollbackCheckpoints(psComputeContext->psDeviceNode, &psComputeContext->sSyncAddrListUpdate);
 fail_alloc_update_values_mem:
+	if (psExportFenceSyncCheckpoint)
+	{
+		SyncCheckpointRollbackExportFence(iExportFenceToSignal);
+	}
+fail_check_fence_includes_export_fence:
+fail_resolve_export_fence:
 	if (iUpdateFence != PVRSRV_NO_FENCE)
 	{
 		SyncCheckpointRollbackFenceData(iUpdateFence, pvUpdateFenceFinaliseData);
@@ -1138,6 +1237,38 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 	return eError;
 }
 
+PVRSRV_ERROR PVRSRVRGXSendCancelCmdKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext, IMG_UINT32 ui32FirstIntJobRefToCancel, IMG_UINT32 ui32LastIntJobRefToCancel)
+{
+	RGXFWIF_KCCB_CMD sCancelWorkKCCBCmd;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	sCancelWorkKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_CANCEL_WORK;
+	sCancelWorkKCCBCmd.uCmdData.sCancelWorkData.psContext = FWCommonContextGetFWAddress(psComputeContext->psServerCommonContext);
+	sCancelWorkKCCBCmd.uCmdData.sCancelWorkData.ui32FirstIntJobRefToCancel = ui32FirstIntJobRefToCancel;
+	sCancelWorkKCCBCmd.uCmdData.sCancelWorkData.ui32LastIntJobRefToCancel = ui32LastIntJobRefToCancel;
+
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
+	{
+		eError = RGXScheduleCommand(psComputeContext->psDeviceNode->pvDevice,
+		                            RGXFWIF_DM_CDM,
+		                            &sCancelWorkKCCBCmd,
+		                            PDUMP_FLAGS_CONTINUOUS);
+
+		/* Iterate if we hit a PVRSRV_ERROR_KERNEL_CCB_FULL error */
+		if ((eError != PVRSRV_ERROR_RETRY) &&
+		    (eError != PVRSRV_ERROR_KERNEL_CCB_FULL))
+		{
+			break;
+		}
+		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+	} END_LOOP_UNTIL_TIMEOUT_US();
+
+	PVR_DPF((PVR_DBG_MESSAGE, "Sending compute cancel command for context <%p>. Work with IntJobRef below ui32FirstValidIntJobRef=0x%x might be discarded.",
+	    psComputeContext->psServerCommonContext, ui32LastIntJobRefToCancel + 1));
+
+	return eError;
+}
+
 PVRSRV_ERROR PVRSRVRGXFlushComputeDataKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext)
 {
 	RGXFWIF_KCCB_CMD sFlushCmd;
@@ -1156,7 +1287,7 @@ PVRSRV_ERROR PVRSRVRGXFlushComputeDataKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeCo
 
 	OSLockAcquire(psComputeContext->hLock);
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommandAndGetKCCBSlot(psDevInfo,
 									RGXFWIF_DM_CDM,
@@ -1170,7 +1301,7 @@ PVRSRV_ERROR PVRSRVRGXFlushComputeDataKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeCo
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (eError != PVRSRV_OK)
 	{
@@ -1234,7 +1365,7 @@ PVRSRV_ERROR PVRSRVRGXNotifyComputeWriteOffsetUpdateKM(RGX_SERVER_COMPUTE_CONTEX
 		sKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_NOTIFY_WRITE_OFFSET_UPDATE;
 		sKCCBCmd.uCmdData.sWriteOffsetUpdateData.psContext = FWCommonContextGetFWAddress(psComputeContext->psServerCommonContext);
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			eError = RGXScheduleCommand(psComputeContext->psDeviceNode->pvDevice,
 										RGXFWIF_DM_CDM,
@@ -1245,7 +1376,7 @@ PVRSRV_ERROR PVRSRVRGXNotifyComputeWriteOffsetUpdateKM(RGX_SERVER_COMPUTE_CONTEX
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		if (eError != PVRSRV_OK)
 		{
@@ -1381,6 +1512,9 @@ PVRSRV_ERROR PVRSRVRGXGetLastDeviceErrorKM(CONNECTION_DATA    *psConnection,
  */
 PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext,
                                            PVRSRV_FENCE iCheckFence,
+										   PVRSRV_TIMELINE iUpdateTimeline,
+										   PVRSRV_FENCE *piUpdateFence,
+                                           IMG_CHAR pszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
                                            IMG_UINT32 ui32CmdSize,
                                            IMG_PBYTE pui8DMCmd,
                                            IMG_UINT32 ui32ExtJobRef)
@@ -1390,74 +1524,182 @@ PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psCompute
 	RGX_CCB_CMD_HELPER_DATA	asCmdHelperData[1];
 	IMG_UINT32 ui32IntJobRef = OSAtomicIncrement(&psDevInfo->iCCBSubmissionOrdinal);
 	IMG_UINT32 ui32PDumpFlags = 0;
+	IMG_UINT32 ui32IntClientFenceCount = 0;
+	PRGXFWIF_UFO_ADDR *pauiIntFenceUFOAddress = NULL;
+	IMG_UINT32 ui32IntClientUpdateCount = 0;
+	PRGXFWIF_UFO_ADDR *pauiIntUpdateUFOAddress = NULL;
+	IMG_UINT32 *paui32IntUpdateValue = NULL;
+	PVRSRV_FENCE  iUpdateFence = PVRSRV_NO_FENCE;
 	IMG_UINT64 uiCheckFenceUID = 0;
+	IMG_UINT64 uiUpdateFenceUID = 0;
+	PSYNC_CHECKPOINT psUpdateSyncCheckpoint = NULL;
 	PSYNC_CHECKPOINT *apsFenceSyncCheckpoints = NULL;
 	IMG_UINT32 ui32FenceSyncCheckpointCount = 0;
+	IMG_UINT32 *paui32ClientUpdateValue = NULL;
+	IMG_UINT32 *pui32IntAllocatedUpdateValues = NULL;
 	RGXFWIF_KCCB_CMD sCmpKCCBCmd;
 	PVRSRV_ERROR eError;
+    PVRSRV_CLIENT_SYNC_PRIM *psFenceTimelineUpdateSync = NULL;
+    IMG_UINT32 ui32FenceTimelineUpdateValue = 0;
+    void *pvUpdateFenceFinaliseData = NULL;
+
+	if (iUpdateTimeline >= 0 && !piUpdateFence)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	/* Ensure the string is null-terminated (Required for safety) */
+	pszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH-1] = '\0';
 
 	OSLockAcquire(psComputeContext->hLock);
 
-	if (iCheckFence != PVRSRV_NO_FENCE)
+	eError = SyncAddrListPopulate(&psComputeContext->sSyncAddrListFence,
+									0,
+									NULL,
+									NULL);
+	if (eError != PVRSRV_OK)
 	{
+		goto err_populate_sync_addr_list;
+	}
 
-		eError = SyncAddrListPopulate(&psComputeContext->sSyncAddrListFence,
-										0,
-										NULL,
-										NULL);
-		if (eError != PVRSRV_OK)
+	eError = SyncAddrListPopulate(&psComputeContext->sSyncAddrListUpdate,
+									0,
+									NULL,
+									NULL);
+	if (eError != PVRSRV_OK)
+	{
+		goto err_populate_sync_addr_list;
+	}
+	if (ui32IntClientUpdateCount)
+	{
+		pauiIntUpdateUFOAddress = psComputeContext->sSyncAddrListUpdate.pasFWAddrs;
+	}
+	paui32IntUpdateValue = paui32ClientUpdateValue;
+
+
+	CHKPT_DBG((PVR_DBG_ERROR, "%s: calling SyncCheckpointResolveFence (iCheckFence=%d), psComputeContext->psDeviceNode->hSyncCheckpointContext=<%p>...", __func__, iCheckFence, (void*)psComputeContext->psDeviceNode->hSyncCheckpointContext));
+	/* Resolve the sync checkpoints that make up the input fence */
+	eError = SyncCheckpointResolveFence(psComputeContext->psDeviceNode->hSyncCheckpointContext,
+										iCheckFence,
+										&ui32FenceSyncCheckpointCount,
+										&apsFenceSyncCheckpoints,
+	                                    &uiCheckFenceUID, ui32PDumpFlags);
+	if (eError != PVRSRV_OK)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, returned ERROR (%s)", __func__, PVRSRVGetErrorString(eError)));
+		goto err_populate_sync_addr_list;
+	}
+	CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, fence %d contained %d checkpoints (apsFenceSyncCheckpoints=<%p>)", __func__, iCheckFence, ui32FenceSyncCheckpointCount, (void*)apsFenceSyncCheckpoints));
+#if defined(CMP_CHECKPOINT_DEBUG)
+	if (ui32FenceSyncCheckpointCount > 0)
+	{
+		IMG_UINT32 ii;
+		for (ii=0; ii<ui32FenceSyncCheckpointCount; ii++)
 		{
-			goto err_populate_sync_addr_list;
+			PSYNC_CHECKPOINT psNextCheckpoint = *(apsFenceSyncCheckpoints + ii);
+			CHKPT_DBG((PVR_DBG_ERROR, "%s:    apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, ii, (void*)psNextCheckpoint, SyncCheckpointGetFirmwareAddr(psNextCheckpoint)));
 		}
-
-		CHKPT_DBG((PVR_DBG_ERROR, "%s: calling SyncCheckpointResolveFence (iCheckFence=%d), psComputeContext->psDeviceNode->hSyncCheckpointContext=<%p>...", __func__, iCheckFence, (void*)psComputeContext->psDeviceNode->hSyncCheckpointContext));
-		/* Resolve the sync checkpoints that make up the input fence */
-		eError = SyncCheckpointResolveFence(psComputeContext->psDeviceNode->hSyncCheckpointContext,
-		                                    iCheckFence,
-		                                    &ui32FenceSyncCheckpointCount,
-		                                    &apsFenceSyncCheckpoints,
-		                                    &uiCheckFenceUID, ui32PDumpFlags);
+	}
+#endif
+	/* Create the output fence (if required) */
+	if (iUpdateTimeline != PVRSRV_NO_TIMELINE)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s: calling SyncCheckpointCreateFence (iUpdateFence=%d, iUpdateTimeline=%d,  psComputeContext->psDeviceNode->hSyncCheckpointContext=<%p>)...", __func__, iUpdateFence, iUpdateTimeline, (void*)psComputeContext->psDeviceNode->hSyncCheckpointContext));
+		eError = SyncCheckpointCreateFence(psComputeContext->psDeviceNode,
+		                                   pszUpdateFenceName,
+										   iUpdateTimeline,
+										   psComputeContext->psDeviceNode->hSyncCheckpointContext,
+										   &iUpdateFence,
+										   &uiUpdateFenceUID,
+										   &pvUpdateFenceFinaliseData,
+										   &psUpdateSyncCheckpoint,
+										   (void*)&psFenceTimelineUpdateSync,
+										   &ui32FenceTimelineUpdateValue,
+										   ui32PDumpFlags);
 		if (eError != PVRSRV_OK)
 		{
-			CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, returned ERROR (%s)", __func__, PVRSRVGetErrorString(eError)));
-			goto fail_resolve_fence;
+			CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned error (%s)", __func__, PVRSRVGetErrorString(eError)));
+			goto fail_create_output_fence;
 		}
-		CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, fence %d contained %d checkpoints (apsFenceSyncCheckpoints=<%p>)", __func__, iCheckFence, ui32FenceSyncCheckpointCount, (void*)apsFenceSyncCheckpoints));
-#if defined(CMP_CHECKPOINT_DEBUG)
-		if (ui32FenceSyncCheckpointCount > 0)
+
+		CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned from SyncCheckpointCreateFence (iUpdateFence=%d, psFenceTimelineUpdateSync=<%p>, ui32FenceTimelineUpdateValue=%u)", __func__, iUpdateFence, psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue));
+
+		CHKPT_DBG((PVR_DBG_ERROR, "%s: ui32IntClientUpdateCount=%u, psFenceTimelineUpdateSync=<%p>", __func__, ui32IntClientUpdateCount, (void*)psFenceTimelineUpdateSync));
+		/* Append the sync prim update for the timeline (if required) */
+		if (psFenceTimelineUpdateSync)
 		{
-			IMG_UINT32 ii;
-			for (ii=0; ii<ui32FenceSyncCheckpointCount; ii++)
+			IMG_UINT32 *pui32TimelineUpdateWp = NULL;
+
+			/* Allocate memory to hold the list of update values (including our timeline update) */
+			pui32IntAllocatedUpdateValues = OSAllocMem(sizeof(*pui32IntAllocatedUpdateValues) * (ui32IntClientUpdateCount+1));
+			if (!pui32IntAllocatedUpdateValues)
 			{
-				PSYNC_CHECKPOINT psNextCheckpoint = *(apsFenceSyncCheckpoints + ii);
-				CHKPT_DBG((PVR_DBG_ERROR, "%s:    apsFenceSyncCheckpoints[%d]=<%p>", __func__, ii, (void*)psNextCheckpoint));
+				/* Failed to allocate memory */
+				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto fail_alloc_update_values_mem;
 			}
-		}
-#endif
-		/* Append the checks (from input fence) */
-		if (ui32FenceSyncCheckpointCount > 0)
-		{
-			CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append %d sync checkpoints to Compute CDM Fence (&psComputeContext->sSyncAddrListFence=<%p>)...", __func__, ui32FenceSyncCheckpointCount, (void*)&psComputeContext->sSyncAddrListFence));
-			eError = SyncAddrListAppendCheckpoints(&psComputeContext->sSyncAddrListFence,
-			                                       ui32FenceSyncCheckpointCount,
-			                                       apsFenceSyncCheckpoints);
-			if (eError != PVRSRV_OK)
+			OSCachedMemSet(pui32IntAllocatedUpdateValues, 0xbb, sizeof(*pui32IntAllocatedUpdateValues) * (ui32IntClientUpdateCount+1));
+			/* Copy the update values into the new memory, then append our timeline update value */
+			if (paui32IntUpdateValue)
 			{
-				CHKPT_DBG((PVR_DBG_ERROR, "%s: ...done, returned ERROR (%s)", __func__, PVRSRVGetErrorString(eError)));
-				goto fail_append_checkpoints;
+				OSCachedMemCopy(pui32IntAllocatedUpdateValues, paui32IntUpdateValue, sizeof(*pui32IntAllocatedUpdateValues) * ui32IntClientUpdateCount);
 			}
+
+			/* Now set the additional update value */
+			pui32TimelineUpdateWp = pui32IntAllocatedUpdateValues + ui32IntClientUpdateCount;
+			*pui32TimelineUpdateWp = ui32FenceTimelineUpdateValue;
+			ui32IntClientUpdateCount++;
+			/* Now make sure paui32ClientUpdateValue points to pui32IntAllocatedUpdateValues */
+			paui32ClientUpdateValue = pui32IntAllocatedUpdateValues;
+
+			CHKPT_DBG((PVR_DBG_ERROR, "%s: append the timeline sync prim addr <%p> to the compute context update list", __func__,  (void*)psFenceTimelineUpdateSync));
+			/* Now append the timeline sync prim addr to the compute context update list */
+			SyncAddrListAppendSyncPrim(&psComputeContext->sSyncAddrListUpdate,
+			                           psFenceTimelineUpdateSync);
+
+			/* Ensure paui32IntUpdateValue is now pointing to our new array of update values */
+			paui32IntUpdateValue = pui32IntAllocatedUpdateValues;
+		}
+	}
+
+	/* Append the checks (from input fence) */
+	if (ui32FenceSyncCheckpointCount > 0)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append %d sync checkpoints to Compute CDM Fence (&psComputeContext->sSyncAddrListFence=<%p>)...", __func__, ui32FenceSyncCheckpointCount, (void*)&psComputeContext->sSyncAddrListFence));
+
+		SyncAddrListAppendCheckpoints(&psComputeContext->sSyncAddrListFence,
+									  ui32FenceSyncCheckpointCount,
+									  apsFenceSyncCheckpoints);
+		if (!pauiIntFenceUFOAddress)
+		{
+			pauiIntFenceUFOAddress = psComputeContext->sSyncAddrListFence.pasFWAddrs;
 		}
+		ui32IntClientFenceCount += ui32FenceSyncCheckpointCount;
+	}
+
+	if (psUpdateSyncCheckpoint)
+	{
+		/* Append the update (from output fence) */
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append 1 sync checkpoint to Compute CDM Update (&psComputeContext->sSyncAddrListUpdate=<%p>, psUpdateSyncCheckpoint=<%p>)...", __func__, (void*)&psComputeContext->sSyncAddrListUpdate , (void*)psUpdateSyncCheckpoint));
+		SyncAddrListAppendCheckpoints(&psComputeContext->sSyncAddrListUpdate,
+									  1,
+									  &psUpdateSyncCheckpoint);
+		if (!pauiIntUpdateUFOAddress)
+		{
+			pauiIntUpdateUFOAddress = psComputeContext->sSyncAddrListUpdate.pasFWAddrs;
+		}
+		ui32IntClientUpdateCount++;
 	}
 
 	RGXCmdHelperInitCmdCCB(psDevInfo,
 	                       psClientCCB,
 	                       0, /* empty ui64FBSCEntryMask */
-	                       ui32FenceSyncCheckpointCount,
-	                       psComputeContext->sSyncAddrListFence.pasFWAddrs,
-	                       NULL,
-	                       0,
-	                       NULL,
+	                       ui32IntClientFenceCount,
+	                       pauiIntFenceUFOAddress,
 	                       NULL,
+	                       ui32IntClientUpdateCount,
+	                       pauiIntUpdateUFOAddress,
+	                       paui32IntUpdateValue,
 	                       ui32CmdSize,
 	                       pui8DMCmd,
 	                       NULL,
@@ -1474,7 +1716,7 @@ PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psCompute
 
 	eError = RGXCmdHelperAcquireCmdCCB(ARRAY_SIZE(asCmdHelperData), asCmdHelperData);
 
-	PVR_LOG_GOTO_IF_ERROR(eError, "RGXCmdHelperAcquireCmdCCB", fail_cmdaquire);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXCmdHelperAcquireCmdCCB", fail_cmdacquire);
 
 	eError = PVRSRVPowerLock(psDevInfo->psDeviceNode);
 	if (unlikely(eError != PVRSRV_OK))
@@ -1505,7 +1747,7 @@ PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psCompute
 	 * command to the firmware.
 	 */
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommandWithoutPowerLock(psComputeContext->psDeviceNode->pvDevice,
 		                            RGXFWIF_DM_CDM,
@@ -1516,11 +1758,43 @@ PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psCompute
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
 
-	PVR_LOG_GOTO_IF_ERROR(eError, "RGXScheduleCommand", fail_cmdaquire);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s failed to schedule kernel CCB command (%s)",
+				 __func__,
+				 PVRSRVGetErrorString(eError)));
+		goto fail_schedulecmd;
+	}
+
+#if defined(NO_HARDWARE)
+	/* If NO_HARDWARE, signal the output fence's sync checkpoint and sync prim */
+	if (psUpdateSyncCheckpoint)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Signalling NOHW sync checkpoint<%p>, ID:%d, FwAddr=0x%x", __func__, (void*)psUpdateSyncCheckpoint, SyncCheckpointGetId(psUpdateSyncCheckpoint), SyncCheckpointGetFirmwareAddr(psUpdateSyncCheckpoint)));
+		SyncCheckpointSignalNoHW(psUpdateSyncCheckpoint);
+	}
+	if (psFenceTimelineUpdateSync)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Updating NOHW sync prim<%p> to %d", __func__, (void*)psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue));
+		SyncPrimNoHwUpdate(psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue);
+	}
+	SyncCheckpointNoHWUpdateTimelines(NULL);
+#endif /* defined(NO_HARDWARE) */
+
+
+	*piUpdateFence = iUpdateFence;
+
+	if (pvUpdateFenceFinaliseData && (iUpdateFence != PVRSRV_NO_FENCE))
+	{
+		SyncCheckpointFinaliseFence(psComputeContext->psDeviceNode, iUpdateFence,
+		                            pvUpdateFenceFinaliseData,
+									psUpdateSyncCheckpoint, pszUpdateFenceName);
+	}
 
 	/* Drop the references taken on the sync checkpoints in the
 	 * resolved input fence */
@@ -1533,30 +1807,66 @@ PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psCompute
 		SyncCheckpointFreeCheckpointListMem(apsFenceSyncCheckpoints);
 	}
 
+	/* Free memory allocated to hold the internal list of update values */
+	if (pui32IntAllocatedUpdateValues)
+	{
+		OSFreeMem(pui32IntAllocatedUpdateValues);
+		pui32IntAllocatedUpdateValues = NULL;
+	}
+
 	OSLockRelease(psComputeContext->hLock);
+
 	return PVRSRV_OK;
 
+fail_schedulecmd:
 fail_acquirepowerlock:
-fail_cmdaquire:
-	SyncAddrListRollbackCheckpoints(psComputeContext->psDeviceNode,
-	                                &psComputeContext->sSyncAddrListFence);
-
-fail_append_checkpoints:
+fail_cmdacquire:
+	SyncAddrListRollbackCheckpoints(psComputeContext->psDeviceNode, &psComputeContext->sSyncAddrListFence);
+	SyncAddrListRollbackCheckpoints(psComputeContext->psDeviceNode, &psComputeContext->sSyncAddrListUpdate);
+fail_alloc_update_values_mem:
+	if (iUpdateFence != PVRSRV_NO_FENCE)
+	{
+		SyncCheckpointRollbackFenceData(iUpdateFence, pvUpdateFenceFinaliseData);
+	}
+fail_create_output_fence:
 	/* Drop the references taken on the sync checkpoints in the
 	 * resolved input fence */
 	SyncAddrListDeRefCheckpoints(ui32FenceSyncCheckpointCount,
 	                             apsFenceSyncCheckpoints);
-	/* Free memory allocated to hold the resolved fence's checkpoints */
+err_populate_sync_addr_list:
+	/* Free the memory that was allocated for the sync checkpoint list returned by ResolveFence() */
 	if (apsFenceSyncCheckpoints)
 	{
 		SyncCheckpointFreeCheckpointListMem(apsFenceSyncCheckpoints);
 	}
-fail_resolve_fence:
-err_populate_sync_addr_list:
+	/* Free memory allocated to hold the internal list of update values */
+	if (pui32IntAllocatedUpdateValues)
+	{
+		OSFreeMem(pui32IntAllocatedUpdateValues);
+		pui32IntAllocatedUpdateValues = NULL;
+	}
 	OSLockRelease(psComputeContext->hLock);
 	return eError;
 }
 
+PVRSRV_ERROR PVRSRVRGXCDMGetSharedMemoryKM(
+	CONNECTION_DATA           * psConnection,
+	PVRSRV_DEVICE_NODE        * psDeviceNode,
+	PMR                      ** ppsCLIPMRMem)
+{
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVRSRVTQAcquireShaders(psDeviceNode, ppsCLIPMRMem);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR PVRSRVRGXCDMReleaseSharedMemoryKM(PMR * psPMRMem)
+{
+	PVR_UNREFERENCED_PARAMETER(psPMRMem);
+
+	return PVRSRV_OK;
+}
+
 /******************************************************************************
  End of file (rgxcompute.c)
 ******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/rgxcompute.h b/drivers/gpu/drm/img-rogue/rgxcompute.h
index a0ab9c9c25fb..b93c42efc044 100644
--- a/drivers/gpu/drm/img-rogue/rgxcompute.h
+++ b/drivers/gpu/drm/img-rogue/rgxcompute.h
@@ -108,7 +108,6 @@ PVRSRV_ERROR PVRSRVRGXCreateComputeContextKM(CONNECTION_DATA			*psConnection,
 ******************************************************************************/
 PVRSRV_ERROR PVRSRVRGXDestroyComputeContextKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext);
 
-
 /*!
 *******************************************************************************
  @Function	PVRSRVRGXKickCDMKM
@@ -127,6 +126,7 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 								PVRSRV_TIMELINE				iUpdateTimeline,
 								PVRSRV_FENCE				*piUpdateFence,
 								IMG_CHAR					pcszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
+								PVRSRV_FENCE				iExportFenceToSignal,
 								IMG_UINT32					ui32CmdSize,
 								IMG_PBYTE					pui8DMCmd,
 								IMG_UINT32					ui32PDumpFlags,
@@ -136,7 +136,8 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 								PMR							**ppsSyncPMRs,
 								IMG_UINT32					ui32NumWorkgroups,
 								IMG_UINT32					ui32NumWorkitems,
-								IMG_UINT64					ui64DeadlineInus);
+								IMG_UINT64					ui64DeadlineInus,
+								IMG_PUINT32					pui32IntJobRef);
 
 /*!
 *******************************************************************************
@@ -151,6 +152,25 @@ PVRSRV_ERROR PVRSRVRGXKickCDMKM(RGX_SERVER_COMPUTE_CONTEXT	*psComputeContext,
 ******************************************************************************/
 PVRSRV_ERROR PVRSRVRGXFlushComputeDataKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext);
 
+
+
+/*!
+*******************************************************************************
+ @Function	PVRSRVRGXSendCancelCmd
+
+ @Description
+	Server-side implementation of RGXSendCancelCmd
+
+ @Input psComputeContext - Compute context to cancel work on
+ @Input ui32LastIntJobRefToCancel - Last IntJobRef to cancel
+
+ @Return   PVRSRV_ERROR
+******************************************************************************/
+PVRSRV_ERROR PVRSRVRGXSendCancelCmdKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext,
+                                      IMG_UINT32 ui32FirstIntJobRefToCancel,
+                                      IMG_UINT32 ui32LastIntJobRefToCancel);
+
+
 /*!
 *******************************************************************************
 
@@ -180,6 +200,9 @@ PVRSRV_ERROR PVRSRVRGXGetLastDeviceErrorKM(CONNECTION_DATA    *psConnection,
 
 PVRSRV_ERROR PVRSRVRGXKickTimestampQueryKM(RGX_SERVER_COMPUTE_CONTEXT *psComputeContext,
                                            PVRSRV_FENCE iCheckFence,
+										   PVRSRV_TIMELINE iUpdateTimeline,
+										   PVRSRV_FENCE *piUpdateFence,
+                                           IMG_CHAR pszUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
                                            IMG_UINT32 ui32CmdSize,
                                            IMG_PBYTE pui8DMCmd,
                                            IMG_UINT32 ui32ExtJobRef);
@@ -193,4 +216,11 @@ void DumpComputeCtxtsInfo(PVRSRV_RGXDEV_INFO *psDevInfo,
 /* Debug/Watchdog - check if client compute contexts are stalled */
 IMG_UINT32 CheckForStalledClientComputeCtxt(PVRSRV_RGXDEV_INFO *psDevInfo);
 
+PVRSRV_ERROR PVRSRVRGXCDMGetSharedMemoryKM(
+	CONNECTION_DATA           * psConnection,
+	PVRSRV_DEVICE_NODE        * psDeviceNode,
+	PMR                      ** ppsCLIPMRMem);
+
+PVRSRV_ERROR PVRSRVRGXCDMReleaseSharedMemoryKM(PMR * psUSCPMRMem);
+
 #endif /* RGXCOMPUTE_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxdebug.c b/drivers/gpu/drm/img-rogue/rgxdebug.c
index 23382dca2353..93738fdf6f9a 100644
--- a/drivers/gpu/drm/img-rogue/rgxdebug.c
+++ b/drivers/gpu/drm/img-rogue/rgxdebug.c
@@ -176,126 +176,6 @@ static const IMG_FLAGS2DESC asDmState2Description[] =
 	{RGXFWIF_DM_STATE_GPU_ECC_HWR, " GPU ECC hwr;"},
 };
 
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-const IMG_CHAR * const gapszMipsPermissionPTFlags[4] =
-{
-	"    ",
-	"XI  ",
-	"RI  ",
-	"RIXI"
-};
-
-const IMG_CHAR * const gapszMipsCoherencyPTFlags[8] =
-{
-	"C",
-	"C",
-	" ",
-	"C",
-	"C",
-	"C",
-	"C",
-	" "
-};
-
-const IMG_CHAR * const gapszMipsDirtyGlobalValidPTFlags[8] =
-{
-	"   ",
-	"  G",
-	" V ",
-	" VG",
-	"D  ",
-	"D G",
-	"DV ",
-	"DVG"
-};
-
-#if !defined(NO_HARDWARE)
-/* Translation of MIPS exception encoding */
-typedef struct _MIPS_EXCEPTION_ENCODING_
-{
-	const IMG_CHAR *const pszStr;	/* Error type */
-	const IMG_BOOL bIsFatal;	/* Error is fatal or non-fatal */
-} MIPS_EXCEPTION_ENCODING;
-
-static const MIPS_EXCEPTION_ENCODING apsMIPSExcCodes[] =
-{
-	{"Interrupt", IMG_FALSE},
-	{"TLB modified exception", IMG_FALSE},
-	{"TLB exception (load/instruction fetch)", IMG_FALSE},
-	{"TLB exception (store)", IMG_FALSE},
-	{"Address error exception (load/instruction fetch)", IMG_TRUE},
-	{"Address error exception (store)", IMG_TRUE},
-	{"Bus error exception (instruction fetch)", IMG_TRUE},
-	{"Bus error exception (load/store)", IMG_TRUE},
-	{"Syscall exception", IMG_FALSE},
-	{"Breakpoint exception (FW assert)", IMG_FALSE},
-	{"Reserved instruction exception", IMG_TRUE},
-	{"Coprocessor Unusable exception", IMG_FALSE},
-	{"Arithmetic Overflow exception", IMG_FALSE},
-	{"Trap exception", IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{"Implementation-Specific Exception 1 (COP2)", IMG_FALSE},
-	{"CorExtend Unusable", IMG_FALSE},
-	{"Coprocessor 2 exceptions", IMG_FALSE},
-	{"TLB Read-Inhibit", IMG_TRUE},
-	{"TLB Execute-Inhibit", IMG_TRUE},
-	{NULL, IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{"Reference to WatchHi/WatchLo address", IMG_FALSE},
-	{"Machine check", IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{"DSP Module State Disabled exception", IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{NULL, IMG_FALSE},
-	{NULL, IMG_FALSE},
-	/* Can only happen in MIPS debug mode */
-	{"Parity error", IMG_FALSE},
-	{NULL, IMG_FALSE}
-};
-
-static IMG_CHAR const *_GetMIPSExcString(IMG_UINT32 ui32ExcCode)
-{
-	if (ui32ExcCode >= sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING))
-	{
-		PVR_DPF((PVR_DBG_WARNING,
-		         "Only %lu exceptions available in MIPS, %u is not a valid exception code",
-		         (unsigned long)sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING), ui32ExcCode));
-		return NULL;
-	}
-
-	return apsMIPSExcCodes[ui32ExcCode].pszStr;
-}
-#endif
-
-typedef struct _RGXMIPSFW_C0_DEBUG_TBL_ENTRY_
-{
-    IMG_UINT32 ui32Mask;
-    const IMG_CHAR * pszExplanation;
-} RGXMIPSFW_C0_DEBUG_TBL_ENTRY;
-
-#if !defined(NO_HARDWARE)
-static const RGXMIPSFW_C0_DEBUG_TBL_ENTRY sMIPS_C0_DebugTable[] =
-{
-    { RGXMIPSFW_C0_DEBUG_DSS,      "Debug single-step exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DBP,      "Debug software breakpoint exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DDBL,     "Debug data break exception occurred on a load" },
-    { RGXMIPSFW_C0_DEBUG_DDBS,     "Debug data break exception occurred on a store" },
-    { RGXMIPSFW_C0_DEBUG_DIB,      "Debug instruction break exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DINT,     "Debug interrupt exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DIBIMPR,  "Imprecise debug instruction break exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DDBLIMPR, "Imprecise debug data break load exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DDBSIMPR, "Imprecise debug data break store exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_IEXI,     "Imprecise error exception inhibit controls exception occurred" },
-    { RGXMIPSFW_C0_DEBUG_DBUSEP,   "Data access Bus Error exception pending" },
-    { RGXMIPSFW_C0_DEBUG_CACHEEP,  "Imprecise Cache Error pending" },
-    { RGXMIPSFW_C0_DEBUG_MCHECKP,  "Imprecise Machine Check exception pending" },
-    { RGXMIPSFW_C0_DEBUG_IBUSEP,   "Instruction fetch Bus Error exception pending" },
-    { (IMG_UINT32)RGXMIPSFW_C0_DEBUG_DBD,      "Debug exception occurred in branch delay slot" }
-};
-#endif
-#endif
-
 static const IMG_CHAR * const apszFwOsStateName[RGXFW_CONNECTION_FW_STATE_COUNT] =
 {
 	"offline",
@@ -310,7 +190,6 @@ static const IMG_FLAGS2DESC asPHRConfig2Description[] =
 {
 	{BIT_ULL(RGXFWIF_PHR_MODE_OFF), "off"},
 	{BIT_ULL(RGXFWIF_PHR_MODE_RD_RESET), "reset RD hardware"},
-	{BIT_ULL(RGXFWIF_PHR_MODE_FULL_RESET), "full gpu reset "},
 };
 #endif
 
@@ -1145,7 +1024,7 @@ static void _RGXDecodeBIFReqTags(PVRSRV_RGXDEV_INFO	*psDevInfo,
 
  @Input ui32MMULevel	 - MMU level
 
- @Return   IMG_CHAR* to the sting describing the MMU level that faulted.
+ @Return   IMG_CHAR* to the string describing the MMU level that faulted.
 
 ******************************************************************************/
 static const IMG_CHAR* _RGXDecodeMMULevel(IMG_UINT32 ui32MMULevel)
@@ -1164,456 +1043,6 @@ static const IMG_CHAR* _RGXDecodeMMULevel(IMG_UINT32 ui32MMULevel)
 }
 
 
-/*!
-*******************************************************************************
-
- @Function	_RGXDecodeMMUReqTags
-
- @Description
-
- Decodes the MMU Tag ID and Sideband data fields from RGX_CR_MMU_FAULT_META_STATUS and
- RGX_CR_MMU_FAULT_STATUS regs.
-
- @Input ui32TagID           - Tag ID value
- @Input ui32TagSB           - Tag Sideband data
- @Input bRead               - Read flag
- @Output ppszTagID          - Decoded string from the Tag ID
- @Output ppszTagSB          - Decoded string from the Tag SB
- @Output pszScratchBuf      - Buffer provided to the function to generate the debug strings
- @Input ui32ScratchBufSize  - Size of the provided buffer
-
- @Return   void
-
-******************************************************************************/
-static void _RGXDecodeMMUReqTags(PVRSRV_RGXDEV_INFO    *psDevInfo,
-								 IMG_UINT32  ui32TagID,
-								 IMG_UINT32  ui32TagSB,
-								 IMG_BOOL    bRead,
-								 IMG_CHAR    **ppszTagID,
-								 IMG_CHAR    **ppszTagSB,
-								 IMG_CHAR    *pszScratchBuf,
-								 IMG_UINT32  ui32ScratchBufSize)
-{
-	IMG_INT32  i32SideBandType = -1;
-	IMG_CHAR   *pszTagID = "-";
-	IMG_CHAR   *pszTagSB = "-";
-
-	PVR_ASSERT(ppszTagID != NULL);
-	PVR_ASSERT(ppszTagSB != NULL);
-
-
-	switch (ui32TagID)
-	{
-		case  0: pszTagID = "META (Jones)"; i32SideBandType = RGXDBG_META; break;
-		case  1: pszTagID = "TLA (Jones)"; i32SideBandType = RGXDBG_TLA; break;
-		case  2: pszTagID = "DMA (Jones)"; i32SideBandType = RGXDBG_DMA; break;
-		case  3: pszTagID = "VDMM (Jones)"; i32SideBandType = RGXDBG_VDMM; break;
-		case  4: pszTagID = "CDM (Jones)"; i32SideBandType = RGXDBG_CDM; break;
-		case  5: pszTagID = "IPP (Jones)"; i32SideBandType = RGXDBG_IPP; break;
-		case  6: pszTagID = "PM (Jones)"; i32SideBandType = RGXDBG_PM; break;
-		case  7: pszTagID = "Tiling (Jones)"; i32SideBandType = RGXDBG_TILING; break;
-		case  8: pszTagID = "MCU (Texas 0)"; i32SideBandType = RGXDBG_MCU; break;
-		case 12: pszTagID = "VDMS (Black Pearl 0)"; i32SideBandType = RGXDBG_VDMS; break;
-		case 13: pszTagID = "IPF (Black Pearl 0)"; i32SideBandType = RGXDBG_IPF; break;
-		case 14: pszTagID = "ISP (Black Pearl 0)"; i32SideBandType = RGXDBG_ISP; break;
-		case 15: pszTagID = "TPF (Black Pearl 0)"; i32SideBandType = RGXDBG_TPF; break;
-		case 16: pszTagID = "USCS (Black Pearl 0)"; i32SideBandType = RGXDBG_USCS; break;
-		case 17: pszTagID = "PPP (Black Pearl 0)"; i32SideBandType = RGXDBG_PPP; break;
-		case 20: pszTagID = "MCU (Texas 1)"; i32SideBandType = RGXDBG_MCU; break;
-		case 24: pszTagID = "MCU (Texas 2)"; i32SideBandType = RGXDBG_MCU; break;
-		case 28: pszTagID = "VDMS (Black Pearl 1)"; i32SideBandType = RGXDBG_VDMS; break;
-		case 29: pszTagID = "IPF (Black Pearl 1)"; i32SideBandType = RGXDBG_IPF; break;
-		case 30: pszTagID = "ISP (Black Pearl 1)"; i32SideBandType = RGXDBG_ISP; break;
-		case 31: pszTagID = "TPF (Black Pearl 1)"; i32SideBandType = RGXDBG_TPF; break;
-		case 32: pszTagID = "USCS (Black Pearl 1)"; i32SideBandType = RGXDBG_USCS; break;
-		case 33: pszTagID = "PPP (Black Pearl 1)"; i32SideBandType = RGXDBG_PPP; break;
-		case 36: pszTagID = "MCU (Texas 3)"; i32SideBandType = RGXDBG_MCU; break;
-		case 40: pszTagID = "MCU (Texas 4)"; i32SideBandType = RGXDBG_MCU; break;
-		case 44: pszTagID = "VDMS (Black Pearl 2)"; i32SideBandType = RGXDBG_VDMS; break;
-		case 45: pszTagID = "IPF (Black Pearl 2)"; i32SideBandType = RGXDBG_IPF; break;
-		case 46: pszTagID = "ISP (Black Pearl 2)"; i32SideBandType = RGXDBG_ISP; break;
-		case 47: pszTagID = "TPF (Black Pearl 2)"; i32SideBandType = RGXDBG_TPF; break;
-		case 48: pszTagID = "USCS (Black Pearl 2)"; i32SideBandType = RGXDBG_USCS; break;
-		case 49: pszTagID = "PPP (Black Pearl 2)"; i32SideBandType = RGXDBG_PPP; break;
-		case 52: pszTagID = "MCU (Texas 5)"; i32SideBandType = RGXDBG_MCU; break;
-		case 56: pszTagID = "MCU (Texas 6)"; i32SideBandType = RGXDBG_MCU; break;
-		case 60: pszTagID = "VDMS (Black Pearl 3)"; i32SideBandType = RGXDBG_VDMS; break;
-		case 61: pszTagID = "IPF (Black Pearl 3)"; i32SideBandType = RGXDBG_IPF; break;
-		case 62: pszTagID = "ISP (Black Pearl 3)"; i32SideBandType = RGXDBG_ISP; break;
-		case 63: pszTagID = "TPF (Black Pearl 3)"; i32SideBandType = RGXDBG_TPF; break;
-		case 64: pszTagID = "USCS (Black Pearl 3)"; i32SideBandType = RGXDBG_USCS; break;
-		case 65: pszTagID = "PPP (Black Pearl 3)"; i32SideBandType = RGXDBG_PPP; break;
-		case 68: pszTagID = "MCU (Texas 7)"; i32SideBandType = RGXDBG_MCU; break;
-	}
-	if (('-' == pszTagID[0]) && '\n' == pszTagID[1])
-	{
-
-		if (RGX_IS_ERN_SUPPORTED(psDevInfo, 50539) ||
-			(RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, FBCDC_ARCHITECTURE) && RGX_GET_FEATURE_VALUE(psDevInfo, FBCDC_ARCHITECTURE) >= 3))
-		{
-			switch (ui32TagID)
-			{
-			case 18: pszTagID = "TPF_CPF (Black Pearl 0)"; i32SideBandType = RGXDBG_TPF_CPF; break;
-			case 19: pszTagID = "IPF_CPF (Black Pearl 0)"; i32SideBandType = RGXDBG_IPF_CPF; break;
-			case 34: pszTagID = "TPF_CPF (Black Pearl 1)"; i32SideBandType = RGXDBG_TPF_CPF; break;
-			case 35: pszTagID = "IPF_CPF (Black Pearl 1)"; i32SideBandType = RGXDBG_IPF_CPF; break;
-			case 50: pszTagID = "TPF_CPF (Black Pearl 2)"; i32SideBandType = RGXDBG_TPF_CPF; break;
-			case 51: pszTagID = "IPF_CPF (Black Pearl 2)"; i32SideBandType = RGXDBG_IPF_CPF; break;
-			case 66: pszTagID = "TPF_CPF (Black Pearl 3)"; i32SideBandType = RGXDBG_TPF_CPF; break;
-			case 67: pszTagID = "IPF_CPF (Black Pearl 3)"; i32SideBandType = RGXDBG_IPF_CPF; break;
-			}
-
-			if (RGX_IS_ERN_SUPPORTED(psDevInfo, 50539))
-			{
-				switch (ui32TagID)
-				{
-				case 9:	pszTagID = "PBE (Texas 0)"; i32SideBandType = RGXDBG_PBE; break;
-				case 10: pszTagID = "PDS (Texas 0)"; i32SideBandType = RGXDBG_PDS; break;
-				case 11: pszTagID = "FBCDC (Texas 0)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 21: pszTagID = "PBE (Texas 1)"; i32SideBandType = RGXDBG_PBE; break;
-				case 22: pszTagID = "PDS (Texas 1)"; i32SideBandType = RGXDBG_PDS; break;
-				case 23: pszTagID = "FBCDC (Texas 1)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 25: pszTagID = "PBE (Texas 2)"; i32SideBandType = RGXDBG_PBE; break;
-				case 26: pszTagID = "PDS (Texas 2)"; i32SideBandType = RGXDBG_PDS; break;
-				case 27: pszTagID = "FBCDC (Texas 2)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 37: pszTagID = "PBE (Texas 3)"; i32SideBandType = RGXDBG_PBE; break;
-				case 38: pszTagID = "PDS (Texas 3)"; i32SideBandType = RGXDBG_PDS; break;
-				case 39: pszTagID = "FBCDC (Texas 3)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 41: pszTagID = "PBE (Texas 4)"; i32SideBandType = RGXDBG_PBE; break;
-				case 42: pszTagID = "PDS (Texas 4)"; i32SideBandType = RGXDBG_PDS; break;
-				case 43: pszTagID = "FBCDC (Texas 4)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 53: pszTagID = "PBE (Texas 5)"; i32SideBandType = RGXDBG_PBE; break;
-				case 54: pszTagID = "PDS (Texas 5)"; i32SideBandType = RGXDBG_PDS; break;
-				case 55: pszTagID = "FBCDC (Texas 5)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 57: pszTagID = "PBE (Texas 6)"; i32SideBandType = RGXDBG_PBE; break;
-				case 58: pszTagID = "PDS (Texas 6)"; i32SideBandType = RGXDBG_PDS; break;
-				case 59: pszTagID = "FBCDC (Texas 6)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 69: pszTagID = "PBE (Texas 7)"; i32SideBandType = RGXDBG_PBE; break;
-				case 70: pszTagID = "PDS (Texas 7)"; i32SideBandType = RGXDBG_PDS; break;
-				case 71: pszTagID = "FBCDC (Texas 7)"; i32SideBandType = RGXDBG_FBCDC; break;
-				}
-			}else
-			{
-				switch (ui32TagID)
-				{
-				case 9:	pszTagID = "PDS (Texas 0)"; i32SideBandType = RGXDBG_PDS; break;
-				case 10: pszTagID = "PBE (Texas 0)"; i32SideBandType = RGXDBG_PBE; break;
-				case 11: pszTagID = "FBCDC (Texas 0)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 21: pszTagID = "PDS (Texas 1)"; i32SideBandType = RGXDBG_PDS; break;
-				case 22: pszTagID = "PBE (Texas 1)"; i32SideBandType = RGXDBG_PBE; break;
-				case 23: pszTagID = "FBCDC (Texas 1)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 25: pszTagID = "PDS (Texas 2)"; i32SideBandType = RGXDBG_PDS; break;
-				case 26: pszTagID = "PBE (Texas 2)"; i32SideBandType = RGXDBG_PBE; break;
-				case 27: pszTagID = "FBCDC (Texas 2)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 37: pszTagID = "PDS (Texas 3)"; i32SideBandType = RGXDBG_PDS; break;
-				case 38: pszTagID = "PBE (Texas 3)"; i32SideBandType = RGXDBG_PBE; break;
-				case 39: pszTagID = "FBCDC (Texas 3)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 41: pszTagID = "PDS (Texas 4)"; i32SideBandType = RGXDBG_PDS; break;
-				case 42: pszTagID = "PBE (Texas 4)"; i32SideBandType = RGXDBG_PBE; break;
-				case 43: pszTagID = "FBCDC (Texas 4)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 53: pszTagID = "PDS (Texas 5)"; i32SideBandType = RGXDBG_PDS; break;
-				case 54: pszTagID = "PBE (Texas 5)"; i32SideBandType = RGXDBG_PBE; break;
-				case 55: pszTagID = "FBCDC (Texas 5)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 57: pszTagID = "PDS (Texas 6)"; i32SideBandType = RGXDBG_PDS; break;
-				case 58: pszTagID = "PBE (Texas 6)"; i32SideBandType = RGXDBG_PBE; break;
-				case 59: pszTagID = "FBCDC (Texas 6)"; i32SideBandType = RGXDBG_FBCDC; break;
-				case 69: pszTagID = "PDS (Texas 7)"; i32SideBandType = RGXDBG_PDS; break;
-				case 70: pszTagID = "PBE (Texas 7)"; i32SideBandType = RGXDBG_PBE; break;
-				case 71: pszTagID = "FBCDC (Texas 7)"; i32SideBandType = RGXDBG_FBCDC; break;
-				}
-			}
-		}else
-		{
-			switch (ui32TagID)
-			{
-			case 9:	pszTagID = "PDS (Texas 0)"; i32SideBandType = RGXDBG_PDS; break;
-			case 10: pszTagID = "PBE0 (Texas 0)"; i32SideBandType = RGXDBG_PBE; break;
-			case 11: pszTagID = "PBE1 (Texas 0)"; i32SideBandType = RGXDBG_PBE; break;
-			case 18: pszTagID = "VCE (Black Pearl 0)"; i32SideBandType = RGXDBG_VCE; break;
-			case 19: pszTagID = "FBCDC (Black Pearl 0)"; i32SideBandType = RGXDBG_FBCDC; break;
-			case 21: pszTagID = "PDS (Texas 1)"; i32SideBandType = RGXDBG_PDS; break;
-			case 22: pszTagID = "PBE0 (Texas 1)"; i32SideBandType = RGXDBG_PBE; break;
-			case 23: pszTagID = "PBE1 (Texas 1)"; i32SideBandType = RGXDBG_PBE; break;
-			case 25: pszTagID = "PDS (Texas 2)"; i32SideBandType = RGXDBG_PDS; break;
-			case 26: pszTagID = "PBE0 (Texas 2)"; i32SideBandType = RGXDBG_PBE; break;
-			case 27: pszTagID = "PBE1 (Texas 2)"; i32SideBandType = RGXDBG_PBE; break;
-			case 34: pszTagID = "VCE (Black Pearl 1)"; i32SideBandType = RGXDBG_VCE; break;
-			case 35: pszTagID = "FBCDC (Black Pearl 1)"; i32SideBandType = RGXDBG_FBCDC; break;
-			case 37: pszTagID = "PDS (Texas 3)"; i32SideBandType = RGXDBG_PDS; break;
-			case 38: pszTagID = "PBE0 (Texas 3)"; i32SideBandType = RGXDBG_PBE; break;
-			case 39: pszTagID = "PBE1 (Texas 3)"; i32SideBandType = RGXDBG_PBE; break;
-			case 41: pszTagID = "PDS (Texas 4)"; i32SideBandType = RGXDBG_PDS; break;
-			case 42: pszTagID = "PBE0 (Texas 4)"; i32SideBandType = RGXDBG_PBE; break;
-			case 43: pszTagID = "PBE1 (Texas 4)"; i32SideBandType = RGXDBG_PBE; break;
-			case 50: pszTagID = "VCE (Black Pearl 2)"; i32SideBandType = RGXDBG_VCE; break;
-			case 51: pszTagID = "FBCDC (Black Pearl 2)"; i32SideBandType = RGXDBG_FBCDC; break;
-			case 53: pszTagID = "PDS (Texas 5)"; i32SideBandType = RGXDBG_PDS; break;
-			case 54: pszTagID = "PBE0 (Texas 5)"; i32SideBandType = RGXDBG_PBE; break;
-			case 55: pszTagID = "PBE1 (Texas 5)"; i32SideBandType = RGXDBG_PBE; break;
-			case 57: pszTagID = "PDS (Texas 6)"; i32SideBandType = RGXDBG_PDS; break;
-			case 58: pszTagID = "PBE0 (Texas 6)"; i32SideBandType = RGXDBG_PBE; break;
-			case 59: pszTagID = "PBE1 (Texas 6)"; i32SideBandType = RGXDBG_PBE; break;
-			case 66: pszTagID = "VCE (Black Pearl 3)"; i32SideBandType = RGXDBG_VCE; break;
-			case 67: pszTagID = "FBCDC (Black Pearl 3)"; i32SideBandType = RGXDBG_FBCDC; break;
-			case 69: pszTagID = "PDS (Texas 7)"; i32SideBandType = RGXDBG_PDS; break;
-			case 70: pszTagID = "PBE0 (Texas 7)"; i32SideBandType = RGXDBG_PBE; break;
-			case 71: pszTagID = "PBE1 (Texas 7)"; i32SideBandType = RGXDBG_PBE; break;
-			}
-		}
-
-	}
-
-	switch (i32SideBandType)
-	{
-		case RGXDBG_META:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "DCache - Thread 0"; break;
-				case 0x1: pszTagSB = "ICache - Thread 0"; break;
-				case 0x2: pszTagSB = "JTag - Thread 0"; break;
-				case 0x3: pszTagSB = "Slave bus - Thread 0"; break;
-				case 0x4: pszTagSB = "DCache - Thread 1"; break;
-				case 0x5: pszTagSB = "ICache - Thread 1"; break;
-				case 0x6: pszTagSB = "JTag - Thread 1"; break;
-				case 0x7: pszTagSB = "Slave bus - Thread 1"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_TLA:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "Pixel data"; break;
-				case 0x1: pszTagSB = "Command stream data"; break;
-				case 0x2: pszTagSB = "Fence or flush"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_VDMM:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "Control Stream - Read Only"; break;
-				case 0x1: pszTagSB = "PPP State - Read Only"; break;
-				case 0x2: pszTagSB = "Indices - Read Only"; break;
-				case 0x4: pszTagSB = "Call Stack - Read/Write"; break;
-				case 0x6: pszTagSB = "DrawIndirect - Read Only"; break;
-				case 0xA: pszTagSB = "Context State - Write Only"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_CDM:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "Control Stream"; break;
-				case 0x1: pszTagSB = "Indirect Data"; break;
-				case 0x2: pszTagSB = "Event Write"; break;
-				case 0x3: pszTagSB = "Context State"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_IPP:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "Macrotile Header"; break;
-				case 0x1: pszTagSB = "Region Header"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_PM:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "PMA_TAFSTACK"; break;
-				case 0x1: pszTagSB = "PMA_TAMLIST"; break;
-				case 0x2: pszTagSB = "PMA_3DFSTACK"; break;
-				case 0x3: pszTagSB = "PMA_3DMLIST"; break;
-				case 0x4: pszTagSB = "PMA_PMCTX0"; break;
-				case 0x5: pszTagSB = "PMA_PMCTX1"; break;
-				case 0x6: pszTagSB = "PMA_MAVP"; break;
-				case 0x7: pszTagSB = "PMA_UFSTACK"; break;
-				case 0x8: pszTagSB = "PMD_TAFSTACK"; break;
-				case 0x9: pszTagSB = "PMD_TAMLIST"; break;
-				case 0xA: pszTagSB = "PMD_3DFSTACK"; break;
-				case 0xB: pszTagSB = "PMD_3DMLIST"; break;
-				case 0xC: pszTagSB = "PMD_PMCTX0"; break;
-				case 0xD: pszTagSB = "PMD_PMCTX1"; break;
-				case 0xF: pszTagSB = "PMD_UFSTACK"; break;
-				case 0x10: pszTagSB = "PMA_TAMMUSTACK"; break;
-				case 0x11: pszTagSB = "PMA_3DMMUSTACK"; break;
-				case 0x12: pszTagSB = "PMD_TAMMUSTACK"; break;
-				case 0x13: pszTagSB = "PMD_3DMMUSTACK"; break;
-				case 0x14: pszTagSB = "PMA_TAUFSTACK"; break;
-				case 0x15: pszTagSB = "PMA_3DUFSTACK"; break;
-				case 0x16: pszTagSB = "PMD_TAUFSTACK"; break;
-				case 0x17: pszTagSB = "PMD_3DUFSTACK"; break;
-				case 0x18: pszTagSB = "PMA_TAVFP"; break;
-				case 0x19: pszTagSB = "PMD_3DVFP"; break;
-				case 0x1A: pszTagSB = "PMD_TAVFP"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_TILING:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "PSG Control Stream TP0"; break;
-				case 0x1: pszTagSB = "TPC TP0"; break;
-				case 0x2: pszTagSB = "VCE0"; break;
-				case 0x3: pszTagSB = "VCE1"; break;
-				case 0x4: pszTagSB = "PSG Control Stream TP1"; break;
-				case 0x5: pszTagSB = "TPC TP1"; break;
-				case 0x8: pszTagSB = "PSG Region Header TP0"; break;
-				case 0xC: pszTagSB = "PSG Region Header TP1"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_VDMS:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "Context State - Write Only"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_IPF:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x00:
-				case 0x20: pszTagSB = "CPF"; break;
-				case 0x01: pszTagSB = "DBSC"; break;
-				case 0x02:
-				case 0x04:
-				case 0x06:
-				case 0x08:
-				case 0x0A:
-				case 0x0C:
-				case 0x0E:
-				case 0x10: pszTagSB = "Control Stream"; break;
-				case 0x03:
-				case 0x05:
-				case 0x07:
-				case 0x09:
-				case 0x0B:
-				case 0x0D:
-				case 0x0F:
-				case 0x11: pszTagSB = "Primitive Block"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_ISP:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x00: pszTagSB = "ZLS read/write"; break;
-				case 0x20: pszTagSB = "Occlusion query read/write"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_TPF:
-		{
-			switch (ui32TagSB)
-			{
-				case 0x0: pszTagSB = "TPF0: Primitive Block"; break;
-				case 0x1: pszTagSB = "TPF0: Depth Bias"; break;
-				case 0x2: pszTagSB = "TPF0: Per Primitive IDs"; break;
-				case 0x3: pszTagSB = "CPF - Tables"; break;
-				case 0x4: pszTagSB = "TPF1: Primitive Block"; break;
-				case 0x5: pszTagSB = "TPF1: Depth Bias"; break;
-				case 0x6: pszTagSB = "TPF1: Per Primitive IDs"; break;
-				case 0x7: pszTagSB = "CPF - Data: Pipe 0"; break;
-				case 0x8: pszTagSB = "TPF2: Primitive Block"; break;
-				case 0x9: pszTagSB = "TPF2: Depth Bias"; break;
-				case 0xA: pszTagSB = "TPF2: Per Primitive IDs"; break;
-				case 0xB: pszTagSB = "CPF - Data: Pipe 1"; break;
-				case 0xC: pszTagSB = "TPF3: Primitive Block"; break;
-				case 0xD: pszTagSB = "TPF3: Depth Bias"; break;
-				case 0xE: pszTagSB = "TPF3: Per Primitive IDs"; break;
-				case 0xF: pszTagSB = "CPF - Data: Pipe 2"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_FBCDC:
-		{
-			/*
-			 * FBC faults on a 4-cluster phantom does not always set SB
-			 * bit 5, but since FBC is write-only and FBDC is read-only,
-			 * we can set bit 5 if this is a write fault, before decoding.
-			 */
-			if (bRead == IMG_FALSE)
-			{
-				ui32TagSB |= 0x20;
-			}
-
-			switch (ui32TagSB)
-			{
-				case 0x00: pszTagSB = "FBDC Request, originator ZLS"; break;
-				case 0x02: pszTagSB = "FBDC Request, originator MCU Dust 0"; break;
-				case 0x03: pszTagSB = "FBDC Request, originator MCU Dust 1"; break;
-				case 0x20: pszTagSB = "FBC Request, originator ZLS"; break;
-				case 0x22: pszTagSB = "FBC Request, originator PBE Dust 0, Cluster 0"; break;
-				case 0x23: pszTagSB = "FBC Request, originator PBE Dust 0, Cluster 1"; break;
-				case 0x24: pszTagSB = "FBC Request, originator PBE Dust 1, Cluster 0"; break;
-				case 0x25: pszTagSB = "FBC Request, originator PBE Dust 1, Cluster 1"; break;
-				case 0x28: pszTagSB = "FBC Request, originator ZLS Fence"; break;
-				case 0x2a: pszTagSB = "FBC Request, originator PBE Dust 0, Cluster 0, Fence"; break;
-				case 0x2b: pszTagSB = "FBC Request, originator PBE Dust 0, Cluster 1, Fence"; break;
-				case 0x2c: pszTagSB = "FBC Request, originator PBE Dust 1, Cluster 0, Fence"; break;
-				case 0x2d: pszTagSB = "FBC Request, originator PBE Dust 1, Cluster 1, Fence"; break;
-			}
-			break;
-		}
-
-		case RGXDBG_MCU:
-		{
-			IMG_UINT32 ui32SetNumber = (ui32TagSB >> 5) & 0x7;
-			IMG_UINT32 ui32WayNumber = (ui32TagSB >> 2) & 0x7;
-			IMG_UINT32 ui32Group     = ui32TagSB & 0x3;
-
-			IMG_CHAR* pszGroup = "";
-
-			switch (ui32Group)
-			{
-				case 0x0: pszGroup = "Banks 0-1"; break;
-				case 0x1: pszGroup = "Banks 2-3"; break;
-				case 0x2: pszGroup = "Banks 4-5"; break;
-				case 0x3: pszGroup = "Banks 6-7"; break;
-			}
-
-			OSSNPrintf(pszScratchBuf, ui32ScratchBufSize,
-			           "Set=%d, Way=%d, %s", ui32SetNumber, ui32WayNumber, pszGroup);
-			pszTagSB = pszScratchBuf;
-			break;
-		}
-
-		default:
-		{
-			OSSNPrintf(pszScratchBuf, ui32ScratchBufSize, "SB=0x%02x", ui32TagSB);
-			pszTagSB = pszScratchBuf;
-			break;
-		}
-	}
-
-	*ppszTagID = pszTagID;
-	*ppszTagSB = pszTagSB;
-}
-
-
 /*!
 *******************************************************************************
 
@@ -1739,75 +1168,6 @@ static_assert((RGX_CR_BIF_FAULT_BANK0_REQ_STATUS_ADDRESS_SHIFT == RGX_CR_FWCORE_
 static_assert((RGX_CR_BIF_FAULT_BANK0_REQ_STATUS_ADDRESS_ALIGNSHIFT == RGX_CR_FWCORE_MEM_FAULT_REQ_STATUS_ADDRESS_ALIGNSHIFT),
 			  "RGX_CR_FWCORE_MEM_FAULT_REQ_STATUS_ADDRESS_ALIGNSHIFT mismatch!");
 
-/*!
-*******************************************************************************
-
- @Function	_RGXDumpRGXMMUFaultStatus
-
- @Description
-
- Dump MMU Fault status in human readable form.
-
- @Input pfnDumpDebugPrintf   - The debug printf function
- @Input pvDumpDebugFile      - Optional file identifier to be passed to the
-                               'printf' function if required
- @Input psDevInfo            - RGX device info
- @Input ui64MMUStatus        - MMU Status register value
- @Input pszMetaOrCore        - string representing call is for META or MMU core
- @Return   void
-
-******************************************************************************/
-static void _RGXDumpRGXMMUFaultStatus(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-					void *pvDumpDebugFile,
-					PVRSRV_RGXDEV_INFO *psDevInfo,
-					IMG_UINT64 ui64MMUStatus,
-					const IMG_PCHAR pszMetaOrCore,
-					const IMG_CHAR *pszIndent)
-{
-	if (ui64MMUStatus == 0x0)
-	{
-		PVR_DUMPDEBUG_LOG("%sMMU (%s) - OK", pszIndent, pszMetaOrCore);
-	}
-	else
-	{
-		IMG_UINT32 ui32PC        = (ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_CONTEXT_CLRMSK) >>
-		                           RGX_CR_MMU_FAULT_STATUS_CONTEXT_SHIFT;
-		IMG_UINT64 ui64Addr      = ((ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_ADDRESS_CLRMSK) >>
-		                           RGX_CR_MMU_FAULT_STATUS_ADDRESS_SHIFT) <<  4; /* align shift */
-		IMG_UINT32 ui32Requester = (ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_REQ_ID_CLRMSK) >>
-		                           RGX_CR_MMU_FAULT_STATUS_REQ_ID_SHIFT;
-		IMG_UINT32 ui32SideBand  = (ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_TAG_SB_CLRMSK) >>
-		                           RGX_CR_MMU_FAULT_STATUS_TAG_SB_SHIFT;
-		IMG_UINT32 ui32MMULevel  = (ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_LEVEL_CLRMSK) >>
-		                           RGX_CR_MMU_FAULT_STATUS_LEVEL_SHIFT;
-		IMG_BOOL bRead           = (ui64MMUStatus & RGX_CR_MMU_FAULT_STATUS_RNW_EN) != 0;
-		IMG_BOOL bFault          = (ui64MMUStatus & RGX_CR_MMU_FAULT_STATUS_FAULT_EN) != 0;
-		IMG_BOOL bROFault        = ((ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_TYPE_CLRMSK) >>
-		                            RGX_CR_MMU_FAULT_STATUS_TYPE_SHIFT) == 0x2;
-		IMG_BOOL bProtFault      = ((ui64MMUStatus & ~RGX_CR_MMU_FAULT_STATUS_TYPE_CLRMSK) >>
-		                            RGX_CR_MMU_FAULT_STATUS_TYPE_SHIFT) == 0x3;
-		IMG_CHAR aszScratch[RGX_DEBUG_STR_SIZE];
-		IMG_CHAR *pszTagID;
-		IMG_CHAR *pszTagSB;
-
-		_RGXDecodeMMUReqTags(psDevInfo, ui32Requester, ui32SideBand, bRead, &pszTagID, &pszTagSB, aszScratch, RGX_DEBUG_STR_SIZE);
-
-		PVR_DUMPDEBUG_LOG("%sMMU (%s) - FAULT:", pszIndent, pszMetaOrCore);
-		PVR_DUMPDEBUG_LOG("%s  * MMU status (0x%016" IMG_UINT64_FMTSPECx "): PC = %d, %s 0x%010" IMG_UINT64_FMTSPECx ", %s (%s)%s%s%s%s.",
-						  pszIndent,
-						  ui64MMUStatus,
-						  ui32PC,
-						  (bRead)?"Reading from":"Writing to",
-						  ui64Addr,
-						  pszTagID,
-						  pszTagSB,
-						  (bFault)?", Fault":"",
-						  (bROFault)?", Read Only fault":"",
-						  (bProtFault)?", PM/FW core protection fault":"",
-						  _RGXDecodeMMULevel(ui32MMULevel));
-
-	}
-}
 static_assert((RGX_CR_MMU_FAULT_STATUS_CONTEXT_CLRMSK == RGX_CR_MMU_FAULT_STATUS_META_CONTEXT_CLRMSK),
 			  "RGX_CR_MMU_FAULT_STATUS_META mismatch!");
 static_assert((RGX_CR_MMU_FAULT_STATUS_CONTEXT_SHIFT == RGX_CR_MMU_FAULT_STATUS_META_CONTEXT_SHIFT),
@@ -1843,364 +1203,6 @@ static_assert((RGX_CR_MMU_FAULT_STATUS_TYPE_SHIFT == RGX_CR_MMU_FAULT_STATUS_MET
 
 
 #if !defined(NO_HARDWARE)
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-static PVRSRV_ERROR _RGXMipsExtraDebug(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_MIPS_STATE *psMIPSState)
-{
-	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
-	IMG_UINT32 ui32RegRead;
-	IMG_UINT32 eError = PVRSRV_OK;
-	IMG_UINT32 volatile *pui32SyncFlag;
-
-	/* Acquire the NMI operations lock */
-	OSLockAcquire(psDevInfo->hNMILock);
-
-	/* Make sure the synchronisation flag is set to 0 */
-	pui32SyncFlag = &psDevInfo->psRGXFWIfSysInit->sMIPSState.ui32Sync;
-	*pui32SyncFlag = 0;
-
-	/* Readback performed as a part of memory barrier */
-	OSWriteMemoryBarrier(pui32SyncFlag);
-	RGXFwSharedMemCacheOpPtr(pui32SyncFlag,
-	                         FLUSH);
-
-
-	/* Enable NMI issuing in the MIPS wrapper */
-	OSWriteHWReg64(pvRegsBaseKM,
-				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE,
-				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE_EVENT_EN);
-	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_ENABLE);
-
-	/* Check the MIPS is not in error state already (e.g. it is booting or an NMI has already been requested) */
-	ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
-				   RGX_CR_MIPS_EXCEPTION_STATUS);
-	if ((ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN) || (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN))
-	{
-
-		eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
-		goto fail;
-	}
-	ui32RegRead = 0;
-
-	/* Issue NMI */
-	OSWriteHWReg32(pvRegsBaseKM,
-				   RGX_CR_MIPS_WRAPPER_NMI_EVENT,
-				   RGX_CR_MIPS_WRAPPER_NMI_EVENT_TRIGGER_EN);
-	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_EVENT);
-
-
-	/* Wait for NMI Taken to be asserted */
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
-	{
-		ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
-									RGX_CR_MIPS_EXCEPTION_STATUS);
-		if (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN)
-		{
-			break;
-		}
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
-
-	if ((ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN) == 0)
-	{
-			eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
-			goto fail;
-	}
-	ui32RegRead = 0;
-
-	/* Allow the firmware to proceed */
-	*pui32SyncFlag = 1;
-
-	/* Readback performed as a part of memory barrier */
-	OSWriteMemoryBarrier(pui32SyncFlag);
-	RGXFwSharedMemCacheOpPtr(pui32SyncFlag,
-	                         FLUSH);
-
-
-	/* Wait for the FW to have finished the NMI routine */
-	ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
-								RGX_CR_MIPS_EXCEPTION_STATUS);
-
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
-	{
-		ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
-									RGX_CR_MIPS_EXCEPTION_STATUS);
-		if (!(ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN))
-		{
-			break;
-		}
-		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
-	if (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN)
-	{
-			eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
-			goto fail;
-	}
-	ui32RegRead = 0;
-
-	/* Copy state */
-	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->sMIPSState,
-	                           INVALIDATE);
-	OSDeviceMemCopy(psMIPSState, &psDevInfo->psRGXFWIfSysInit->sMIPSState, sizeof(*psMIPSState));
-
-	--(psMIPSState->ui32ErrorEPC);
-	--(psMIPSState->ui32EPC);
-
-	/* Disable NMI issuing in the MIPS wrapper */
-	OSWriteHWReg32(pvRegsBaseKM,
-				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE,
-				   0);
-	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_ENABLE);
-
-fail:
-	/* Release the NMI operations lock */
-	OSLockRelease(psDevInfo->hNMILock);
-	return eError;
-}
-
-/* Print decoded information from cause register */
-static void _RGXMipsDumpCauseDecode(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-                                    void *pvDumpDebugFile,
-                                    IMG_UINT32 ui32Cause,
-                                    IMG_UINT32 ui32ErrorState)
-{
-#define INDENT "    "
-	const IMG_UINT32 ui32ExcCode = RGXMIPSFW_C0_CAUSE_EXCCODE(ui32Cause);
-	const IMG_CHAR * const pszException = _GetMIPSExcString(ui32ExcCode);
-
-	if (ui32ErrorState != 0 &&
-	    pszException != NULL)
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "Cause exception: %s", pszException);
-	}
-
-	if (ui32Cause & RGXMIPSFW_C0_CAUSE_FDCIPENDING)
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "FDC interrupt pending");
-	}
-
-	if (!(ui32Cause & RGXMIPSFW_C0_CAUSE_IV))
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "Interrupt uses general interrupt vector");
-	}
-
-	if (ui32Cause & RGXMIPSFW_C0_CAUSE_PCIPENDING)
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "Performance Counter Interrupt pending");
-	}
-
-	/* Unusable Coproc exception */
-	if (ui32ExcCode == 11)
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "Unusable Coprocessor: %d", RGXMIPSFW_C0_CAUSE_UNUSABLE_UNIT(ui32Cause));
-	}
-
-#undef INDENT
-}
-
-static IMG_BOOL _IsFWCodeException(IMG_UINT32 ui32ExcCode)
-{
-	if (ui32ExcCode >= sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING))
-	{
-		PVR_DPF((PVR_DBG_WARNING,
-		         "Only %lu exceptions available in MIPS, %u is not a valid exception code",
-		         (unsigned long)sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING), ui32ExcCode));
-		return IMG_FALSE;
-	}
-
-	return apsMIPSExcCodes[ui32ExcCode].bIsFatal;
-}
-
-static void _RGXMipsDumpDebugDecode(PVRSRV_RGXDEV_INFO *psDevInfo,
-					DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-					void *pvDumpDebugFile,
-					IMG_UINT32 ui32Debug,
-					IMG_UINT32 ui32DEPC)
-{
-	const IMG_CHAR *pszDException = NULL;
-	IMG_UINT32 i;
-#define INDENT "    "
-
-	if (!(ui32Debug & RGXMIPSFW_C0_DEBUG_DM))
-	{
-		return;
-	}
-
-	PVR_DUMPDEBUG_LOG("DEBUG                        :");
-
-	pszDException = _GetMIPSExcString(RGXMIPSFW_C0_DEBUG_EXCCODE(ui32Debug));
-
-	if (pszDException != NULL)
-	{
-		PVR_DUMPDEBUG_LOG(INDENT "Debug exception: %s", pszDException);
-	}
-
-	for (i = 0; i < ARRAY_SIZE(sMIPS_C0_DebugTable); ++i)
-	{
-		const RGXMIPSFW_C0_DEBUG_TBL_ENTRY * const psDebugEntry = &sMIPS_C0_DebugTable[i];
-
-		if (ui32Debug & psDebugEntry->ui32Mask)
-		{
-			PVR_DUMPDEBUG_LOG(INDENT "%s", psDebugEntry->pszExplanation);
-		}
-	}
-#undef INDENT
-	PVR_DUMPDEBUG_LOG("DEPC                    :0x%08X", ui32DEPC);
-}
-
-static inline void _GetMipsTLBPARanges(const RGX_MIPS_TLB_ENTRY *psTLBEntry,
-                                       const RGX_MIPS_REMAP_ENTRY *psRemapEntry0,
-                                       const RGX_MIPS_REMAP_ENTRY *psRemapEntry1,
-                                       IMG_UINT64 *pui64PA0Start,
-                                       IMG_UINT64 *pui64PA0End,
-                                       IMG_UINT64 *pui64PA1Start,
-                                       IMG_UINT64 *pui64PA1End)
-{
-	IMG_BOOL bUseRemapOutput = (psRemapEntry0 != NULL && psRemapEntry1 != NULL) ? IMG_TRUE : IMG_FALSE;
-	IMG_UINT64 ui64PageSize = RGXMIPSFW_TLB_GET_PAGE_SIZE(psTLBEntry->ui32TLBPageMask);
-
-	if ((psTLBEntry->ui32TLBLo0 & RGXMIPSFW_TLB_VALID) == 0)
-	{
-		/* Dummy values to fail the range checks later */
-		*pui64PA0Start = -1ULL;
-		*pui64PA0End   = -1ULL;
-	}
-	else if (bUseRemapOutput)
-	{
-		*pui64PA0Start = (IMG_UINT64)psRemapEntry0->ui32RemapAddrOut << 12;
-		*pui64PA0End   = *pui64PA0Start + ui64PageSize - 1;
-	}
-	else
-	{
-		*pui64PA0Start = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo0);
-		*pui64PA0End   = *pui64PA0Start + ui64PageSize - 1;
-	}
-
-	if ((psTLBEntry->ui32TLBLo1 & RGXMIPSFW_TLB_VALID) == 0)
-	{
-		/* Dummy values to fail the range checks later */
-		*pui64PA1Start = -1ULL;
-		*pui64PA1End   = -1ULL;
-	}
-	else if (bUseRemapOutput)
-	{
-		*pui64PA1Start = (IMG_UINT64)psRemapEntry1->ui32RemapAddrOut << 12;
-		*pui64PA1End   = *pui64PA1Start + ui64PageSize - 1;
-	}
-	else
-	{
-		*pui64PA1Start = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo1);
-		*pui64PA1End   = *pui64PA1Start + ui64PageSize - 1;
-	}
-}
-
-static void _CheckMipsTLBDuplicatePAs(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-                                      void *pvDumpDebugFile,
-                                      const RGX_MIPS_TLB_ENTRY *psTLB,
-                                      const RGX_MIPS_REMAP_ENTRY *psRemap)
-{
-	IMG_UINT64 ui64PA0StartI, ui64PA1StartI, ui64PA0StartJ, ui64PA1StartJ;
-	IMG_UINT64 ui64PA0EndI,   ui64PA1EndI,   ui64PA0EndJ,   ui64PA1EndJ;
-	IMG_UINT32 i, j;
-
-#define RANGES_OVERLAP(start0,end0,start1,end1)  ((start0) < (end1) && (start1) < (end0))
-
-	for (i = 0; i < RGXMIPSFW_NUMBER_OF_TLB_ENTRIES; i++)
-	{
-		_GetMipsTLBPARanges(&psTLB[i],
-		                    psRemap ? &psRemap[i] : NULL,
-		                    psRemap ? &psRemap[i + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
-		                    &ui64PA0StartI, &ui64PA0EndI,
-		                    &ui64PA1StartI, &ui64PA1EndI);
-
-		for (j = i + 1; j < RGXMIPSFW_NUMBER_OF_TLB_ENTRIES; j++)
-		{
-			_GetMipsTLBPARanges(&psTLB[j],
-			                    psRemap ? &psRemap[j] : NULL,
-			                    psRemap ? &psRemap[j + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
-			                    &ui64PA0StartJ, &ui64PA0EndJ,
-			                    &ui64PA1StartJ, &ui64PA1EndJ);
-
-			if (RANGES_OVERLAP(ui64PA0StartI, ui64PA0EndI, ui64PA0StartJ, ui64PA0EndJ) ||
-			    RANGES_OVERLAP(ui64PA0StartI, ui64PA0EndI, ui64PA1StartJ, ui64PA1EndJ) ||
-			    RANGES_OVERLAP(ui64PA1StartI, ui64PA1EndI, ui64PA0StartJ, ui64PA0EndJ) ||
-			    RANGES_OVERLAP(ui64PA1StartI, ui64PA1EndI, ui64PA1StartJ, ui64PA1EndJ)  )
-			{
-				PVR_DUMPDEBUG_LOG("Overlap between TLB entry %u and %u", i , j);
-			}
-		}
-	}
-}
-
-static inline IMG_UINT32 _GetMIPSRemapRegionSize(IMG_UINT32 ui32RegionSizeEncoding)
-{
-    return 1U << ((ui32RegionSizeEncoding + 1U) << 1U);
-}
-
-static inline void _RGXMipsDumpTLBEntry(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-                                        void *pvDumpDebugFile,
-                                        const RGX_MIPS_TLB_ENTRY *psTLBEntry,
-                                        const RGX_MIPS_REMAP_ENTRY *psRemapEntry0,
-                                        const RGX_MIPS_REMAP_ENTRY *psRemapEntry1,
-                                        IMG_UINT32 ui32Index)
-{
-	IMG_BOOL bDumpRemapEntries = (psRemapEntry0 != NULL && psRemapEntry1 != NULL) ? IMG_TRUE : IMG_FALSE;
-	IMG_UINT64 ui64PA0 = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo0);
-	IMG_UINT64 ui64PA1 = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo1);
-	IMG_UINT64 ui64Remap0AddrOut = 0, ui64Remap1AddrOut = 0;
-	IMG_UINT32 ui32Remap0AddrIn = 0, ui32Remap1AddrIn = 0;
-
-	if (bDumpRemapEntries)
-	{
-		/* RemapAddrIn is always 4k aligned and on 32 bit */
-		ui32Remap0AddrIn = psRemapEntry0->ui32RemapAddrIn << 12;
-		ui32Remap1AddrIn = psRemapEntry1->ui32RemapAddrIn << 12;
-
-		/* RemapAddrOut is always 4k aligned and on 32 or 36 bit */
-		ui64Remap0AddrOut = (IMG_UINT64)psRemapEntry0->ui32RemapAddrOut << 12;
-		ui64Remap1AddrOut = (IMG_UINT64)psRemapEntry1->ui32RemapAddrOut << 12;
-
-		/* If TLB and remap entries match, then merge them else, print them separately */
-		if ((IMG_UINT32)ui64PA0 == ui32Remap0AddrIn &&
-		    (IMG_UINT32)ui64PA1 == ui32Remap1AddrIn)
-		{
-			ui64PA0 = ui64Remap0AddrOut;
-			ui64PA1 = ui64Remap1AddrOut;
-			bDumpRemapEntries = IMG_FALSE;
-		}
-	}
-
-	PVR_DUMPDEBUG_LOG("%2u) VA 0x%08X (%3uk) -> PA0 0x%08" IMG_UINT64_FMTSPECx " %s%s%s, "
-	                                           "PA1 0x%08" IMG_UINT64_FMTSPECx " %s%s%s",
-	                  ui32Index,
-	                  psTLBEntry->ui32TLBHi,
-	                  RGXMIPSFW_TLB_GET_PAGE_SIZE(psTLBEntry->ui32TLBPageMask),
-	                  ui64PA0,
-	                  gapszMipsPermissionPTFlags[RGXMIPSFW_TLB_GET_INHIBIT(psTLBEntry->ui32TLBLo0)],
-	                  gapszMipsDirtyGlobalValidPTFlags[RGXMIPSFW_TLB_GET_DGV(psTLBEntry->ui32TLBLo0)],
-	                  gapszMipsCoherencyPTFlags[RGXMIPSFW_TLB_GET_COHERENCY(psTLBEntry->ui32TLBLo0)],
-	                  ui64PA1,
-	                  gapszMipsPermissionPTFlags[RGXMIPSFW_TLB_GET_INHIBIT(psTLBEntry->ui32TLBLo1)],
-	                  gapszMipsDirtyGlobalValidPTFlags[RGXMIPSFW_TLB_GET_DGV(psTLBEntry->ui32TLBLo1)],
-	                  gapszMipsCoherencyPTFlags[RGXMIPSFW_TLB_GET_COHERENCY(psTLBEntry->ui32TLBLo1)]);
-
-	if (bDumpRemapEntries)
-	{
-		PVR_DUMPDEBUG_LOG("    Remap %2u : IN 0x%08X (%3uk) => OUT 0x%08" IMG_UINT64_FMTSPECx,
-		                  ui32Index,
-		                  ui32Remap0AddrIn,
-		                  _GetMIPSRemapRegionSize(psRemapEntry0->ui32RemapRegionSize),
-		                  ui64Remap0AddrOut);
-
-		PVR_DUMPDEBUG_LOG("    Remap %2u : IN 0x%08X (%3uk) => OUT 0x%08" IMG_UINT64_FMTSPECx,
-		                  ui32Index + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES,
-		                  ui32Remap1AddrIn,
-		                  _GetMIPSRemapRegionSize(psRemapEntry1->ui32RemapRegionSize),
-		                  ui64Remap1AddrOut);
-	}
-}
-#endif
-
-
 static inline IMG_CHAR const *_GetRISCVException(IMG_UINT32 ui32Mcause)
 {
 	switch (ui32Mcause)
@@ -2222,6 +1224,31 @@ static inline IMG_CHAR const *_GetRISCVException(IMG_UINT32 ui32Mcause)
 #endif /* !defined(NO_HARDWARE) */
 
 
+static const IMG_FLAGS2DESC asHWErrorState[] =
+{
+	{RGX_HW_ERR_NA, "N/A"},
+	{RGX_HW_ERR_PRIMID_FAILURE_DURING_DMKILL, "Primitive ID failure during DM kill."},
+};
+
+/*
+ *  Translate ID code to descriptive string.
+ *  Returns on the first match.
+ */
+static void _ID2Description(IMG_CHAR *psDesc, IMG_UINT32 ui32DescSize, const IMG_FLAGS2DESC *psConvTable, IMG_UINT32 ui32TableSize, IMG_UINT32 ui32ID)
+{
+	IMG_UINT32 ui32Idx;
+
+	for (ui32Idx = 0; ui32Idx < ui32TableSize; ui32Idx++)
+	{
+		if (ui32ID == psConvTable[ui32Idx].uiFlag)
+		{
+			OSStringSafeCopy(psDesc, psConvTable[ui32Idx].pszLabel, ui32DescSize);
+			return;
+		}
+	}
+}
+
+
 /*!
 *******************************************************************************
 
@@ -2347,7 +1374,7 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	IMG_UINT32        dm, i;
 	IMG_UINT32        ui32LineSize;
 	IMG_CHAR          *pszLine, *pszTemp;
-	const IMG_CHAR    *apszDmNames[RGXFWIF_DM_MAX] = {"GP", "TDM", "TA", "3D", "CDM", "RAY", "TA2", "TA3", "TA4"};
+	const IMG_CHAR    *apszDmNames[RGXFWIF_DM_MAX] = {"GP", "TDM", "GEOM", "3D", "CDM", "RAY", "GEOM2", "GEOM3", "GEOM4"};
 	const IMG_CHAR    szMsgHeader[] = "Number of HWR: ";
 	const IMG_CHAR    szMsgFalse[] = "FALSE(";
 	IMG_CHAR          *pszLockupType = "";
@@ -2371,15 +1398,15 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		}
 	}
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST) && !bAnyLocked && (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_HARDWARE_OK))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo) && !bAnyLocked && (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_HARDWARE_OK))
 	{
 		/* No HWR situation, print nothing */
 		return;
 	}
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
-		IMG_BOOL bAnyHWROccured = IMG_FALSE;
+		IMG_BOOL bAnyHWROccurred = IMG_FALSE;
 
 		for (dm = 0; dm < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; dm++)
 		{
@@ -2387,12 +1414,12 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 				psHWRInfoBuf->aui32HwrDmLockedUpCount[dm] != 0 ||
 				psHWRInfoBuf->aui32HwrDmOverranCount[dm] !=0)
 				{
-					bAnyHWROccured = IMG_TRUE;
+					bAnyHWROccurred = IMG_TRUE;
 					break;
 				}
 		}
 
-		if (!bAnyHWROccured)
+		if (!bAnyHWROccurred)
 		{
 			return;
 		}
@@ -2419,7 +1446,7 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		return;
 	}
 
-	OSStringLCopy(pszLine, szMsgHeader, ui32LineSize);
+	OSStringSafeCopy(pszLine, szMsgHeader, ui32LineSize);
 	pszTemp = pszLine + ui32MsgHeaderCharCount;
 
 	for (dm = 0; dm < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; dm++)
@@ -2457,7 +1484,7 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		}
 		else
 		{
-			if (!PVRSRV_VZ_MODE_IS(GUEST))
+			if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 			{
 				IMG_UINT32 ui32HWRRecoveryFlags = psFwSysData->aui32HWRRecoveryFlags[dm];
 				IMG_CHAR sPerDmHwrDescription[RGX_DEBUG_STR_SIZE];
@@ -2465,7 +1492,7 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 				if (ui32HWRRecoveryFlags == RGXFWIF_DM_STATE_WORKING)
 				{
-					OSStringLCopy(sPerDmHwrDescription, " working;", RGX_DEBUG_STR_SIZE);
+					OSStringSafeCopy(sPerDmHwrDescription, " working;", RGX_DEBUG_STR_SIZE);
 				}
 				else
 				{
@@ -2539,6 +1566,17 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 				                   psHWRInfo->ui32EventStatus,
 				                   pszLockupType);
 				}
+
+				if (psHWRInfo->eHWErrorCode != RGX_HW_ERR_NA)
+				{
+					IMG_CHAR sHWDebugInfo[RGX_DEBUG_STR_SIZE] = "";
+
+					_ID2Description(sHWDebugInfo, RGX_DEBUG_STR_SIZE, asHWErrorState, ARRAY_SIZE(asHWErrorState),
+						psHWRInfo->eHWErrorCode);
+					PVR_DUMPDEBUG_LOG("  HW error code = 0x%X: %s",
+									  psHWRInfo->eHWErrorCode, sHWDebugInfo);
+				}
+
 				pszTemp = &aui8RecoveryNum[0];
 				while (*pszTemp != '\0')
 				{
@@ -2546,7 +1584,7 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 				}
 
 				/* There's currently no time correlation for the Guest OSes on the Firmware so there's no point printing OS Timestamps on Guests */
-				if (!PVRSRV_VZ_MODE_IS(GUEST))
+				if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 				{
 					PVR_DUMPDEBUG_LOG("  %s CRTimer = 0x%012"IMG_UINT64_FMTSPECX", OSTimer = %" IMG_UINT64_FMTSPEC ".%09" IMG_UINT64_FMTSPEC ", CyclesElapsed = %" IMG_INT64_FMTSPECd,
 									   aui8RecoveryNum,
@@ -2596,17 +1634,48 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 					}
 				}
 
+#if defined(HW_ERN_65104_BIT_MASK)
+				if (RGX_IS_ERN_SUPPORTED(psDevInfo, 65104))
+				{
+					PVR_DUMPDEBUG_LOG("    Active PDS DM USCs = 0x%08x", psHWRInfo->ui32PDSActiveDMUSCs);
+				}
+#endif
+
+#if defined(HW_ERN_69700_BIT_MASK)
+				if (RGX_IS_ERN_SUPPORTED(psDevInfo, 69700))
+				{
+					PVR_DUMPDEBUG_LOG("    DMs stalled waiting on PDS Store space = 0x%08x", psHWRInfo->ui32PDSStalledDMs);
+				}
+#endif
+
 				switch (psHWRInfo->eHWRType)
 				{
 					case RGX_HWRTYPE_BIF0FAULT:
 					case RGX_HWRTYPE_BIF1FAULT:
 					{
-						if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE)))
+						_RGXDumpRGXBIFBank(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, RGXFWIF_HWRTYPE_BIF_BANK_GET(psHWRInfo->eHWRType),
+										psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus,
+										psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus,
+										DD_NORMAL_INDENT);
+
+						bPageFault = IMG_TRUE;
+						sFaultDevVAddr.uiAddr = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus & ~RGX_CR_BIF_FAULT_BANK0_REQ_STATUS_ADDRESS_CLRMSK);
+						ui32PC = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus & ~RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_CAT_BASE_CLRMSK) >>
+								RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_CAT_BASE_SHIFT;
+						bPMFault = (ui32PC >= 8);
+						ui32PageSize = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus & ~RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_PAGE_SIZE_CLRMSK) >>
+									RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_PAGE_SIZE_SHIFT;
+						sPCDevPAddr.uiAddr = psHWRInfo->uHWRData.sBIFInfo.ui64PCAddress;
+					}
+					break;
+					case RGX_HWRTYPE_TEXASBIF0FAULT:
+					{
+						if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, CLUSTER_GROUPING))
 						{
-							_RGXDumpRGXBIFBank(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, RGXFWIF_HWRTYPE_BIF_BANK_GET(psHWRInfo->eHWRType),
-											psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus,
-											psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus,
-											DD_NORMAL_INDENT);
+							_RGXDumpRGXBIFBank(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, RGXDBG_TEXAS_BIF,
+										psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus,
+										psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus,
+										DD_NORMAL_INDENT);
 
 							bPageFault = IMG_TRUE;
 							sFaultDevVAddr.uiAddr = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus & ~RGX_CR_BIF_FAULT_BANK0_REQ_STATUS_ADDRESS_CLRMSK);
@@ -2619,29 +1688,6 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 						}
 					}
 					break;
-					case RGX_HWRTYPE_TEXASBIF0FAULT:
-					{
-						if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE)))
-						{
-							if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, CLUSTER_GROUPING))
-							{
-								_RGXDumpRGXBIFBank(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, RGXDBG_TEXAS_BIF,
-											psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus,
-											psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus,
-											DD_NORMAL_INDENT);
-
-								bPageFault = IMG_TRUE;
-								sFaultDevVAddr.uiAddr = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFReqStatus & ~RGX_CR_BIF_FAULT_BANK0_REQ_STATUS_ADDRESS_CLRMSK);
-								ui32PC = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus & ~RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_CAT_BASE_CLRMSK) >>
-										RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_CAT_BASE_SHIFT;
-								bPMFault = (ui32PC >= 8);
-								ui32PageSize = (psHWRInfo->uHWRData.sBIFInfo.ui64BIFMMUStatus & ~RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_PAGE_SIZE_CLRMSK) >>
-											RGX_CR_BIF_FAULT_BANK0_MMU_STATUS_PAGE_SIZE_SHIFT;
-								sPCDevPAddr.uiAddr = psHWRInfo->uHWRData.sBIFInfo.ui64PCAddress;
-							}
-						}
-					}
-					break;
 
 					case RGX_HWRTYPE_ECCFAULT:
 					{
@@ -2651,42 +1697,11 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 					case RGX_HWRTYPE_MMUFAULT:
 					{
-						if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-						{
-							_RGXDumpRGXMMUFaultStatus(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo,
-											psHWRInfo->uHWRData.sMMUInfo.aui64MMUStatus[0],
-											"Core",
-											DD_NORMAL_INDENT);
-
-							bPageFault = IMG_TRUE;
-							sFaultDevVAddr.uiAddr =   psHWRInfo->uHWRData.sMMUInfo.aui64MMUStatus[0];
-							sFaultDevVAddr.uiAddr &=  ~RGX_CR_MMU_FAULT_STATUS_ADDRESS_CLRMSK;
-							sFaultDevVAddr.uiAddr >>= RGX_CR_MMU_FAULT_STATUS_ADDRESS_SHIFT;
-							sFaultDevVAddr.uiAddr <<= 4; /* align shift */
-							ui32PC  = (psHWRInfo->uHWRData.sMMUInfo.aui64MMUStatus[0] & ~RGX_CR_MMU_FAULT_STATUS_CONTEXT_CLRMSK) >>
-													   RGX_CR_MMU_FAULT_STATUS_CONTEXT_SHIFT;
-							bPMFault = (ui32PC <= 8);
-							sPCDevPAddr.uiAddr = psHWRInfo->uHWRData.sMMUInfo.ui64PCAddress;
-						}
 					}
 					break;
 
 					case RGX_HWRTYPE_MMUMETAFAULT:
 					{
-						if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-						{
-							_RGXDumpRGXMMUFaultStatus(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo,
-											psHWRInfo->uHWRData.sMMUInfo.aui64MMUStatus[0],
-											"Meta",
-											DD_NORMAL_INDENT);
-
-							bPageFault = IMG_TRUE;
-							sFaultDevVAddr.uiAddr =   psHWRInfo->uHWRData.sMMUInfo.aui64MMUStatus[0];
-							sFaultDevVAddr.uiAddr &=  ~RGX_CR_MMU_FAULT_STATUS_ADDRESS_CLRMSK;
-							sFaultDevVAddr.uiAddr >>= RGX_CR_MMU_FAULT_STATUS_ADDRESS_SHIFT;
-							sFaultDevVAddr.uiAddr <<= 4; /* align shift */
-							sPCDevPAddr.uiAddr = psHWRInfo->uHWRData.sMMUInfo.ui64PCAddress;
-						}
 					}
 					break;
 
@@ -2782,68 +1797,6 @@ static void _RGXDumpFWHWRInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 }
 
 
-#if defined(SUPPORT_VALIDATION)
-static void _RGXDumpFWKickCountInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-                                    void *pvDumpDebugFile,
-                                    const RGXFWIF_OSDATA *psFwOsData,
-                                    PVRSRV_RGXDEV_INFO *psDevInfo)
-{
-	IMG_UINT32        ui32DMIndex, ui32LineSize;
-	IMG_CHAR          *pszLine, *pszTemp;
-	const IMG_CHAR    *apszDmNames[RGXFWIF_DM_MAX] = {"GP", "TDM", "TA", "3D", "CDM", "RAY", "TA2", "TA3", "TA4"};
-	const IMG_CHAR    szKicksHeader[] = "RGX Kicks: ";
-	const IMG_UINT32  ui32KicksHeaderCharCount = ARRAY_SIZE(szKicksHeader) - 1; /* size includes the null */
-
-	if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, FASTRENDER_DM)))
-	{
-		apszDmNames[RGXFWIF_DM_TDM] = "2D";
-	}
-
-	ui32LineSize = sizeof(IMG_CHAR) *
-	                  (ui32KicksHeaderCharCount +
-	                  (psDevInfo->sDevFeatureCfg.ui32MAXDMCount *
-	                      ( 5   /*DM name + equal sign*/ +
-	                       10   /*UINT32 max num of digits*/ +
-	                        3   /*comma + space*/)) +
-	                        1); /* \0 */
-
-	pszLine = OSAllocMem(ui32LineSize);
-	if (pszLine == NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"%s: Out of mem allocating line string (size: %d)",
-			__func__,
-			ui32LineSize));
-		return;
-	}
-
-	/* Print the number of kicks in general... */
-	OSStringLCopy(pszLine, szKicksHeader, ui32LineSize);
-	pszTemp = pszLine + ui32KicksHeaderCharCount;
-
-	/* Invalidate the whole array before reading */
-	RGXFwSharedMemCacheOpValue(psFwOsData->aui32KickCount,
-	                           INVALIDATE);
-
-	for (ui32DMIndex = 1 /*Skip GP*/;  ui32DMIndex < psDevInfo->sDevFeatureCfg.ui32MAXDMCount;  ui32DMIndex++)
-	{
-		pszTemp += OSSNPrintf(pszTemp,
-				5 + 1 + 10 + 1 + 1 + 1
-				/* name + equal sign + UINT32 + comma + space + \0 */,
-				"%s=%u, ",
-				apszDmNames[ui32DMIndex],
-				psFwOsData->aui32KickCount[ui32DMIndex]);
-	}
-
-	/* Go back 2 spaces and remove the last comma+space... */
-	pszTemp -= 2;
-	*pszTemp = '\0';
-
-	PVR_DUMPDEBUG_LOG("%s", pszLine);
-
-	OSFreeMem(pszLine);
-}
-#endif
 
 
 #if !defined(NO_HARDWARE)
@@ -2856,6 +1809,7 @@ static void _RGXDumpFWKickCountInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
  @Description
 
  Check if the MMU indicates it is blocked on a pending page
+ MMU4 does not support pending pages, so return false.
 
  @Input psDevInfo	 - RGX device info
 
@@ -2864,6 +1818,11 @@ static void _RGXDumpFWKickCountInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 ******************************************************************************/
 static INLINE IMG_BOOL _CheckForPendingPage(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	/* MMU4 doesn't support pending pages */
+	return (RGX_GET_FEATURE_VALUE(psDevInfo, MMU_VERSION) < 4) &&
+		   (OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MMU_ENTRY) & RGX_CR_MMU_ENTRY_PENDING_EN);
+#else
 	IMG_UINT32 ui32BIFMMUEntry;
 
 	ui32BIFMMUEntry = OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_BIF_MMU_ENTRY);
@@ -2876,6 +1835,7 @@ static INLINE IMG_BOOL _CheckForPendingPage(PVRSRV_RGXDEV_INFO *psDevInfo)
 	{
 		return IMG_FALSE;
 	}
+#endif
 }
 
 /*!
@@ -2890,14 +1850,12 @@ static INLINE IMG_BOOL _CheckForPendingPage(PVRSRV_RGXDEV_INFO *psDevInfo)
  @Input psDevInfo	 - RGX device info
  @Output psDevVAddr      - The device virtual address of the pending MMU address translation
  @Output pui32CatBase    - The page catalog base
- @Output pui32DataType   - The MMU entry data type
 
  @Return   void
 
 ******************************************************************************/
 static void _GetPendingPageInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_DEV_VIRTADDR *psDevVAddr,
-									IMG_UINT32 *pui32CatBase,
-									IMG_UINT32 *pui32DataType)
+								IMG_UINT32 *pui32CatBase)
 {
 	IMG_UINT64 ui64BIFMMUEntryStatus;
 
@@ -2907,9 +1865,6 @@ static void _GetPendingPageInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_DEV_VIRTADDR
 
 	*pui32CatBase = (ui64BIFMMUEntryStatus & ~RGX_CR_BIF_MMU_ENTRY_STATUS_CAT_BASE_CLRMSK) >>
 								RGX_CR_BIF_MMU_ENTRY_STATUS_CAT_BASE_SHIFT;
-
-	*pui32DataType = (ui64BIFMMUEntryStatus & ~RGX_CR_BIF_MMU_ENTRY_STATUS_DATA_TYPE_CLRMSK) >>
-								RGX_CR_BIF_MMU_ENTRY_STATUS_DATA_TYPE_SHIFT;
 }
 
 #endif
@@ -2919,7 +1874,6 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 					PVRSRV_RGXDEV_INFO *psDevInfo,
 					IMG_BOOL bRGXPoweredON)
 {
-	IMG_CHAR *pszState, *pszReason;
 	const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
 	const RGXFWIF_TRACEBUF *psRGXFWIfTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
 	IMG_UINT32 ui32DriverID;
@@ -2935,19 +1889,8 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #if defined(NO_HARDWARE)
 	PVR_UNREFERENCED_PARAMETER(bRGXPoweredON);
 #else
-	if ((bRGXPoweredON) && !PVRSRV_VZ_MODE_IS(GUEST))
+	if ((bRGXPoweredON) && !PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
-		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-		{
-			IMG_UINT64	ui64RegValMMUStatus;
-
-			ui64RegValMMUStatus = OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_MMU_FAULT_STATUS);
-			_RGXDumpRGXMMUFaultStatus(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, ui64RegValMMUStatus, "Core", DD_SUMMARY_INDENT);
-
-			ui64RegValMMUStatus = OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_MMU_FAULT_STATUS_META);
-			_RGXDumpRGXMMUFaultStatus(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, ui64RegValMMUStatus, "Meta", DD_SUMMARY_INDENT);
-		}
-		else
 		{
 			IMG_UINT64	ui64RegValMMUStatus, ui64RegValREQStatus;
 
@@ -3000,12 +1943,11 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		if (_CheckForPendingPage(psDevInfo))
 		{
 			IMG_UINT32 ui32CatBase;
-			IMG_UINT32 ui32DataType;
 			IMG_DEV_VIRTADDR sDevVAddr;
 
 			PVR_DUMPDEBUG_LOG("MMU Pending page: Yes");
 
-			_GetPendingPageInfo(psDevInfo, &sDevVAddr, &ui32CatBase, &ui32DataType);
+			_GetPendingPageInfo(psDevInfo, &sDevVAddr, &ui32CatBase);
 
 			if (ui32CatBase >= 8)
 			{
@@ -3062,36 +2004,10 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	}
 #endif /* NO_HARDWARE */
 
-	/* Firmware state */
-	switch (OSAtomicRead(&psDevInfo->psDeviceNode->eHealthStatus))
-	{
-		case PVRSRV_DEVICE_HEALTH_STATUS_OK:  pszState = "OK";  break;
-		case PVRSRV_DEVICE_HEALTH_STATUS_NOT_RESPONDING:  pszState = "NOT RESPONDING";  break;
-		case PVRSRV_DEVICE_HEALTH_STATUS_DEAD:  pszState = "DEAD";  break;
-		case PVRSRV_DEVICE_HEALTH_STATUS_FAULT:  pszState = "FAULT";  break;
-		case PVRSRV_DEVICE_HEALTH_STATUS_UNDEFINED:  pszState = "UNDEFINED";  break;
-		default:  pszState = "UNKNOWN";  break;
-	}
-
-	switch (OSAtomicRead(&psDevInfo->psDeviceNode->eHealthReason))
-	{
-		case PVRSRV_DEVICE_HEALTH_REASON_NONE:  pszReason = "";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_ASSERTED:  pszReason = " - Asserted";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_POLL_FAILING:  pszReason = " - Poll failing";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_TIMEOUTS:  pszReason = " - Global Event Object timeouts rising";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_QUEUE_CORRUPT:  pszReason = " - KCCB offset invalid";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_QUEUE_STALLED:  pszReason = " - KCCB stalled";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_IDLING:  pszReason = " - Idling";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_RESTARTING:  pszReason = " - Restarting";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_MISSING_INTERRUPTS:  pszReason = " - Missing interrupts";  break;
-		case PVRSRV_DEVICE_HEALTH_REASON_PCI_ERROR:  pszReason = " - PCI error";  break;
-		default:  pszReason = " - Unknown reason";  break;
-	}
-
 #if !defined(NO_HARDWARE)
 	/* Determine the type virtualisation support used */
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo))
 	{
 #if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
 #if defined(SUPPORT_AUTOVZ)
@@ -3110,7 +2026,7 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #endif /* (RGX_NUM_DRIVERS_SUPPORTED > 1) */
 
 #if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) || (defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1))
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo))
 	{
 		RGXFWIF_CONNECTION_FW_STATE eFwState;
 		RGXFWIF_CONNECTION_OS_STATE eOsState;
@@ -3130,7 +2046,7 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #endif
 
 #if defined(SUPPORT_AUTOVZ) && defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	if (!PVRSRV_VZ_MODE_IS(NATIVE))
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo))
 	{
 		IMG_UINT32 ui32FwAliveTS;
 		IMG_UINT32 ui32OsAliveTS;
@@ -3147,25 +2063,18 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #endif
 #endif /* !defined(NO_HARDWARE) */
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		IMG_CHAR sHwrStateDescription[RGX_DEBUG_STR_SIZE];
 		IMG_BOOL bDriverIsolationEnabled = IMG_FALSE;
 		IMG_UINT32 ui32HostIsolationGroup;
 
-		if (psFwSysData == NULL)
-		{
-			/* can't dump any more information */
-			PVR_DUMPDEBUG_LOG("RGX FW State: %s%s", pszState, pszReason);
-			return;
-		}
-
 		sHwrStateDescription[0] = '\0';
 
 		DebugCommonFlagStrings(sHwrStateDescription, RGX_DEBUG_STR_SIZE,
 			asHwrState2Description, ARRAY_SIZE(asHwrState2Description),
 			psFwSysData->ui32HWRStateFlags);
-		PVR_DUMPDEBUG_LOG("RGX FW State: %s%s (HWRState 0x%08x:%s)", pszState, pszReason, psFwSysData->ui32HWRStateFlags, sHwrStateDescription);
+		PVR_DUMPDEBUG_LOG("RGX HWR State 0x%08x:%s", psFwSysData->ui32HWRStateFlags, sHwrStateDescription);
 		PVR_DUMPDEBUG_LOG("RGX FW Power State: %s (APM %s: %d ok, %d denied, %d non-idle, %d retry, %d other, %d total. Latency: %u ms)",
 		                  (psFwSysData->ePowState < ARRAY_SIZE(pszPowStateName) ? pszPowStateName[psFwSysData->ePowState] : "???"),
 		                  (psDevInfo->pvAPMISRData)?"enabled":"disabled",
@@ -3219,17 +2128,25 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #if !defined(NO_HARDWARE)
 			if (bRGXPoweredON)
 			{
-				bMTSEnabled = (RGX_IS_BRN_SUPPORTED(psDevInfo, 64502) || !RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_VIRTUALISATION)) ?
+				bMTSEnabled = (
+#if defined(FIX_HW_BRN_64502_BIT_MASK)
+								RGX_IS_BRN_SUPPORTED(psDevInfo, 64502) ||
+#endif
+								!RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_VIRTUALISATION)) ?
 								IMG_TRUE : ((OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MTS_SCHEDULE_ENABLE) & BIT(ui32DriverID)) != 0);
 			}
 #endif
 
-			PVR_DUMPDEBUG_LOG("RGX FW OS %u - State: %s; Freelists: %s%s; Priority: %u; Isolation group: %u; %s", ui32DriverID,
+			PVR_DUMPDEBUG_LOG("RGX FW OS %u - State: %s; Freelists: %s%s; Priority: %u; Isolation group: %u;  Time Slice%s: %u%% (%ums); %s", ui32DriverID,
 							  apszFwOsStateName[sFwRunFlags.bfOsState],
 							  (sFwRunFlags.bfFLOk) ? "Ok" : "Not Ok",
 							  (sFwRunFlags.bfFLGrowPending) ? "; Grow Request Pending" : "",
-							  psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverPriority[ui32DriverID],
+							  psDevInfo->psRGXFWIfRuntimeCfg->ai32DriverPriority[ui32DriverID],
 							  ui32IsolationGroup,
+							  (psDevInfo->psRGXFWIfRuntimeCfg->aui32TSPercentage[ui32DriverID] != 0) ? "" : "*",
+							  psFwSysData->aui32TSMirror[ui32DriverID],
+							  (psFwSysData->aui32TSMirror[ui32DriverID] *
+							   psDevInfo->psRGXFWIfRuntimeCfg->ui32TSIntervalMs / 100),
 							  (bMTSEnabled) ? "MTS on;" : "MTS off;"
 							 );
 
@@ -3237,6 +2154,12 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 			{
 				bDriverIsolationEnabled = IMG_TRUE;
 			}
+
+			if (PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo))
+			{
+				/* don't print guest information on native mode drivers */
+				break;
+			}
 		}
 
 #if defined(PVR_ENABLE_PHR)
@@ -3277,9 +2200,6 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfHWRInfoBufCtl, INVALIDATE);
 	_RGXDumpFWHWRInfo(pfnDumpDebugPrintf, pvDumpDebugFile, psFwSysData, psDevInfo->psRGXFWIfHWRInfoBufCtl, psDevInfo);
-#if defined(SUPPORT_VALIDATION)
-	_RGXDumpFWKickCountInfo(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo->psRGXFWIfFwOsData, psDevInfo);
-#endif
 
 #if defined(SUPPORT_RGXFW_STATS_FRAMEWORK)
 	/* Dump all non-zero values in lines of 8... */
@@ -3313,238 +2233,7 @@ void RGXDumpRGXDebugSummary(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 }
 
 #if !defined(NO_HARDWARE)
-static void _RGXDumpMetaSPExtraDebugInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-						void *pvDumpDebugFile,
-						PVRSRV_RGXDEV_INFO *psDevInfo)
-{
-/* List of extra META Slave Port debug registers */
-#define RGX_META_SP_EXTRA_DEBUG \
-			X(RGX_CR_META_SP_MSLVCTRL0) \
-			X(RGX_CR_META_SP_MSLVCTRL1) \
-			X(RGX_CR_META_SP_MSLVDATAX) \
-			X(RGX_CR_META_SP_MSLVIRQSTATUS) \
-			X(RGX_CR_META_SP_MSLVIRQENABLE) \
-			X(RGX_CR_META_SP_MSLVIRQLEVEL)
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-/* Order in these two initialisers and the one above must match */
-#define RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_EQ1_AND_MRUA_ACCESSES \
-			X(RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_EQ1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_EQ1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQENABLE__HOST_SECURITY_EQ1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQLEVEL__HOST_SECURITY_EQ1_AND_MRUA)
-
-#define RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_GT1_AND_MRUA_ACCESSES \
-			X(RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_GT1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQENABLE__HOST_SECURITY_GT1_AND_MRUA) \
-			X(RGX_CR_META_SP_MSLVIRQLEVEL__HOST_SECURITY_GT1_AND_MRUA)
-#endif
-
-	IMG_UINT32 ui32Idx;
-	IMG_UINT32 ui32RegVal;
-	IMG_UINT32 ui32RegAddr;
-
-	const IMG_UINT32* pui32DebugRegAddr;
-	const IMG_UINT32 aui32DebugRegAddr[] = {
-#define X(A) A,
-		RGX_META_SP_EXTRA_DEBUG
-#undef X
-		};
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	const IMG_UINT32 aui32DebugRegAddrUAHSV1[] = {
-#define X(A) A,
-		RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_EQ1_AND_MRUA_ACCESSES
-#undef X
-		};
-
-	const IMG_UINT32 aui32DebugRegAddrUAHSGT1[] = {
-#define X(A) A,
-		RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_GT1_AND_MRUA_ACCESSES
-#undef X
-		};
-#endif
-
-	const IMG_CHAR* apszDebugRegName[] = {
-#define X(A) #A,
-	RGX_META_SP_EXTRA_DEBUG
-#undef X
-	};
-
-	PVR_DUMPDEBUG_LOG("META Slave Port extra debug:");
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	/* array of register offset values depends on feature. But don't augment names in apszDebugRegName */
-	PVR_ASSERT(sizeof(aui32DebugRegAddrUAHSGT1) == sizeof(aui32DebugRegAddr));
-	PVR_ASSERT(sizeof(aui32DebugRegAddrUAHSV1) == sizeof(aui32DebugRegAddr));
-	pui32DebugRegAddr = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
-						((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ? (aui32DebugRegAddrUAHSGT1) : (aui32DebugRegAddrUAHSV1)) : aui32DebugRegAddr;
-#else
-	pui32DebugRegAddr = aui32DebugRegAddr;
-#endif
-
-	/* dump set of Slave Port debug registers */
-	for (ui32Idx = 0; ui32Idx < sizeof(aui32DebugRegAddr)/sizeof(IMG_UINT32); ui32Idx++)
-	{
-		const IMG_CHAR* pszRegName = apszDebugRegName[ui32Idx];
-
-		ui32RegAddr = pui32DebugRegAddr[ui32Idx];
-		ui32RegVal = OSReadHWReg32(psDevInfo->pvRegsBaseKM, ui32RegAddr);
-		PVR_DUMPDEBUG_LOG("  * %s: 0x%8.8X", pszRegName, ui32RegVal);
-	}
-}
-#endif /* !defined(NO_HARDWARE) */
-
-
-/* Helper macros to emit data */
-#define REG32_FMTSPEC   "%-30s: 0x%08X"
-#define REG64_FMTSPEC   "%-30s: 0x%016" IMG_UINT64_FMTSPECX
-#define DDLOG32(R)      PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, #R, OSReadHWReg32(pvRegsBaseKM, RGX_CR_##R));
-#define DDLOG64(R)      PVR_DUMPDEBUG_LOG(REG64_FMTSPEC, #R, OSReadHWReg64(pvRegsBaseKM, RGX_CR_##R));
-#define DDLOG32_DPX(R)  PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, #R, OSReadHWReg32(pvRegsBaseKM, DPX_CR_##R));
-#define DDLOG64_DPX(R)  PVR_DUMPDEBUG_LOG(REG64_FMTSPEC, #R, OSReadHWReg64(pvRegsBaseKM, DPX_CR_##R));
-#define DDLOGVAL32(S,V) PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, S, V);
-
-#if !defined(NO_HARDWARE)
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-static RGX_MIPS_REMAP_ENTRY RGXDecodeMIPSRemap(IMG_UINT64 ui64RemapReg)
-{
-	RGX_MIPS_REMAP_ENTRY sRemapInfo;
-
-	sRemapInfo.ui32RemapAddrIn =
-			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_BASE_ADDR_IN_CLRMSK)
-				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_BASE_ADDR_IN_SHIFT;
-
-	sRemapInfo.ui32RemapAddrOut =
-			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_ADDR_OUT_CLRMSK)
-				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_ADDR_OUT_SHIFT;
-
-	sRemapInfo.ui32RemapRegionSize =
-			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_REGION_SIZE_CLRMSK)
-				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_REGION_SIZE_SHIFT;
-
-	return sRemapInfo;
-}
-
-static void RGXDumpMIPSState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-							 void *pvDumpDebugFile,
-							 PVRSRV_RGXDEV_INFO *psDevInfo)
-{
-	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
-	RGX_MIPS_STATE sMIPSState = {0};
-	PVRSRV_ERROR eError;
-
-	eError = _RGXMipsExtraDebug(psDevInfo, &sMIPSState);
-	PVR_DUMPDEBUG_LOG("---- [ MIPS internal state ] ----");
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DUMPDEBUG_LOG("MIPS extra debug not available");
-	}
-	else
-	{
-		DDLOGVAL32("PC", sMIPSState.ui32ErrorEPC);
-		DDLOGVAL32("STATUS_REGISTER", sMIPSState.ui32StatusRegister);
-		DDLOGVAL32("CAUSE_REGISTER", sMIPSState.ui32CauseRegister);
-		_RGXMipsDumpCauseDecode(pfnDumpDebugPrintf, pvDumpDebugFile,
-								sMIPSState.ui32CauseRegister, sMIPSState.ui32ErrorState);
-		DDLOGVAL32("BAD_REGISTER", sMIPSState.ui32BadRegister);
-		DDLOGVAL32("EPC", sMIPSState.ui32EPC);
-		DDLOGVAL32("SP", sMIPSState.ui32SP);
-		DDLOGVAL32("BAD_INSTRUCTION", sMIPSState.ui32BadInstr);
-		_RGXMipsDumpDebugDecode(psDevInfo, pfnDumpDebugPrintf, pvDumpDebugFile,
-								sMIPSState.ui32Debug, sMIPSState.ui32DEPC);
-
-		{
-			IMG_UINT32 ui32Idx;
-			RGX_MIPS_REMAP_ENTRY *psMipsRemaps = NULL;
-
-			IMG_BOOL bCheckBRN63553WA =
-				RGX_IS_BRN_SUPPORTED(psDevInfo, 63553) &&
-				(OSReadHWReg32(pvRegsBaseKM, RGX_CR_MIPS_ADDR_REMAP5_CONFIG1) == (0x0 | RGX_CR_MIPS_ADDR_REMAP5_CONFIG1_MODE_ENABLE_EN));
-
-			IMG_BOOL bUseRemapRanges = RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH) > 32;
-
-			if (bUseRemapRanges)
-			{
-				psMipsRemaps = OSAllocMem(sizeof(RGX_MIPS_REMAP_ENTRY) * RGXMIPSFW_NUMBER_OF_REMAP_ENTRIES);
-				PVR_LOG_RETURN_VOID_IF_FALSE(psMipsRemaps != NULL, "psMipsRemaps alloc failed.");
-			}
-
-			PVR_DUMPDEBUG_LOG("TLB                           :");
-
-			for (ui32Idx = 0; ui32Idx < ARRAY_SIZE(sMIPSState.asTLB); ui32Idx++)
-			{
-				if (bUseRemapRanges)
-				{
-					psMipsRemaps[ui32Idx] =
-							RGXDecodeMIPSRemap(sMIPSState.aui64Remap[ui32Idx]);
-
-					psMipsRemaps[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] =
-							RGXDecodeMIPSRemap(sMIPSState.aui64Remap[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES]);
-				}
-
-				_RGXMipsDumpTLBEntry(pfnDumpDebugPrintf,
-								     pvDumpDebugFile,
-								     &sMIPSState.asTLB[ui32Idx],
-								     (bUseRemapRanges) ? &psMipsRemaps[ui32Idx] : NULL,
-								     (bUseRemapRanges) ? &psMipsRemaps[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
-								     ui32Idx);
-
-				if (bCheckBRN63553WA)
-				{
-					const RGX_MIPS_TLB_ENTRY *psTLBEntry = &sMIPSState.asTLB[ui32Idx];
-
-					#define BRN63553_TLB_IS_NUL(X)  (((X) & RGXMIPSFW_TLB_VALID) && (RGXMIPSFW_TLB_GET_PA(X) == 0x0))
-
-					if (BRN63553_TLB_IS_NUL(psTLBEntry->ui32TLBLo0) || BRN63553_TLB_IS_NUL(psTLBEntry->ui32TLBLo1))
-					{
-						PVR_DUMPDEBUG_LOG("BRN63553 WA present with a valid TLB entry mapping address 0x0.");
-					}
-				}
-			}
-
-			/* This implicitly also checks for overlaps between memory and regbank addresses */
-			_CheckMipsTLBDuplicatePAs(pfnDumpDebugPrintf,
-									  pvDumpDebugFile,
-									  sMIPSState.asTLB,
-									  bUseRemapRanges ? psMipsRemaps : NULL);
-
-			if (bUseRemapRanges)
-			{
-				/* Dump unmapped address if it was dumped in FW, otherwise it will be 0 */
-				if (sMIPSState.ui32UnmappedAddress)
-				{
-					PVR_DUMPDEBUG_LOG("Remap unmapped address => 0x%08X",
-									  sMIPSState.ui32UnmappedAddress);
-				}
-			}
-
-			if (psMipsRemaps != NULL)
-			{
-				OSFreeMem(psMipsRemaps);
-			}
-		}
-
-		/* Check FW code corruption in case of known errors */
-		if (_IsFWCodeException(RGXMIPSFW_C0_CAUSE_EXCCODE(sMIPSState.ui32CauseRegister)))
-		{
-			eError = RGXValidateFWImage(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DUMPDEBUG_LOG("Failed to validate any FW code corruption");
-			}
-		}
-	}
-	PVR_DUMPDEBUG_LOG("--------------------------------");
-}
-#endif
-
-static PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 									  void *pvDumpDebugFile,
 									  PVRSRV_RGXDEV_INFO *psDevInfo)
 {
@@ -3563,12 +2252,26 @@ static PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	DDLOG64(FWCORE_MEM_CAT_BASE7);
 
 	/* Limit dump to what is currently being used */
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG4);
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG5);
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG6);
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG12);
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG13);
-	DDLOG64(FWCORE_ADDR_REMAP_CONFIG14);
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4)
+	{
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG4__HOST_SECURITY_GEQ4);
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG5__HOST_SECURITY_GEQ4);
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG6__HOST_SECURITY_GEQ4);
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG12__HOST_SECURITY_GEQ4);
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG13__HOST_SECURITY_GEQ4);
+		DDLOGUNCHECKED64(FWCORE_ADDR_REMAP_CONFIG14__HOST_SECURITY_GEQ4);
+	}
+	else
+#endif
+	{
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG4);
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG5);
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG6);
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG12);
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG13);
+		DDLOG64(FWCORE_ADDR_REMAP_CONFIG14);
+	}
 
 	DDLOG32(FWCORE_MEM_FAULT_MMU_STATUS);
 	DDLOG64(FWCORE_MEM_FAULT_REQ_STATUS);
@@ -3578,7 +2281,7 @@ static PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 	PVR_DUMPDEBUG_LOG("---- [ RISC-V internal state ] ----");
 
-#if defined(SUPPORT_VALIDATION) || defined(SUPPORT_RISCV_GDB)
+#if  defined(SUPPORT_RISCV_GDB)
 	if (RGXRiscvIsHalted(psDevInfo))
 	{
 		/* Avoid resuming the RISC-V FW as most operations
@@ -3621,45 +2324,12 @@ static PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 	return eError;
 }
-#endif /* !defined(NO_HARDWARE) */
 
-PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+void RGXDumpCoreRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 								 void *pvDumpDebugFile,
 								 PVRSRV_RGXDEV_INFO *psDevInfo)
 {
-#if defined(NO_HARDWARE)
-	PVR_DUMPDEBUG_LOG("------[ RGX registers ]------");
-	PVR_DUMPDEBUG_LOG("(Not supported for NO_HARDWARE builds)");
-
-	return PVRSRV_OK;
-#else /* !defined(NO_HARDWARE) */
-	IMG_UINT32   ui32Meta = RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META) ? RGX_GET_FEATURE_VALUE(psDevInfo, META) : 0;
-	IMG_UINT32   ui32TACycles, ui323DCycles, ui32TAOr3DCycles, ui32TAAnd3DCycles;
-	IMG_UINT32   ui32RegVal;
-	IMG_BOOL     bFirmwarePerf;
-	IMG_BOOL     bS7Infra = RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE);
-	IMG_BOOL     bMulticore = RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT);
 	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
-	PVRSRV_ERROR eError;
-
-	PVR_DUMPDEBUG_LOG("------[ RGX registers ]------");
-	PVR_DUMPDEBUG_LOG("RGX Register Base Address (Linear):   0x%p", psDevInfo->pvRegsBaseKM);
-	PVR_DUMPDEBUG_LOG("RGX Register Base Address (Physical): 0x%08lX", (unsigned long)psDevInfo->sRegsPhysBase.uiAddr);
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
-	{
-		PVR_DUMPDEBUG_LOG("RGX Host Secure Register Base Address (Linear):   0x%p",
-							psDevInfo->pvSecureRegsBaseKM);
-		PVR_DUMPDEBUG_LOG("RGX Host Secure Register Base Address (Physical): 0x%08lX",
-							(unsigned long)psDevInfo->sRegsPhysBase.uiAddr + RGX_HOST_SECURE_REGBANK_OFFSET);
-	}
-#endif
-
-	/* Check if firmware perf was set at Init time */
-	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->eFirmwarePerf,
-	                           INVALIDATE);
-	bFirmwarePerf = (psDevInfo->psRGXFWIfSysInit->eFirmwarePerf != FW_PERF_CONF_NONE);
 
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, PBVNC_COREID_REG))
 	{
@@ -3673,49 +2343,36 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	DDLOG32(DESIGNER_REV_FIELD1);
 	DDLOG32(DESIGNER_REV_FIELD2);
 	DDLOG64(CHANGESET_NUMBER);
-	if (ui32Meta)
-	{
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-		IMG_UINT32 ui32MSlvCtrl1Reg = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
-				((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ?
-					RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA :
-					RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA) :
-				RGX_CR_META_SP_MSLVCTRL1;
-
-		/* Forcing bit 6 of MslvCtrl1 to 0 to avoid internal reg read going through the core */
-		OSWriteUncheckedHWReg32(psDevInfo->pvSecureRegsBaseKM, ui32MSlvCtrl1Reg, 0x0);
-#else
-		/* Forcing bit 6 of MslvCtrl1 to 0 to avoid internal reg read going through the core */
-		OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_META_SP_MSLVCTRL1, 0x0);
+}
 
-		DDLOG32(META_SP_MSLVIRQSTATUS);
-#endif
-	}
+void RGXDumpMulticoreRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
 
-	if (bMulticore)
-	{
-		DDLOG32(MULTICORE_SYSTEM);
-		DDLOG32(MULTICORE_GPU);
-	}
+	DDLOG32(MULTICORE_SYSTEM);
+	DDLOG32(MULTICORE_GPU);
+}
+
+void RGXDumpClkRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
 
 	DDLOG64(CLK_CTRL);
 	DDLOG64(CLK_STATUS);
 	DDLOG64(CLK_CTRL2);
 	DDLOG64(CLK_STATUS2);
+}
+
+void RGXDumpMMURegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
 
-	if (bS7Infra)
-	{
-		DDLOG64(CLK_XTPLUS_CTRL);
-		DDLOG64(CLK_XTPLUS_STATUS);
-	}
-	DDLOG32(EVENT_STATUS);
-	DDLOG64(TIMER);
-	if (bS7Infra)
-	{
-		DDLOG64(MMU_FAULT_STATUS);
-		DDLOG64(MMU_FAULT_STATUS_META);
-	}
-	else
 	{
 		DDLOG32(BIF_FAULT_BANK0_MMU_STATUS);
 		DDLOG64(BIF_FAULT_BANK0_REQ_STATUS);
@@ -3726,13 +2383,6 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	DDLOG32(BIF_MMU_ENTRY);
 	DDLOG64(BIF_MMU_ENTRY_STATUS);
 
-	if (bS7Infra)
-	{
-		DDLOG32(BIF_JONES_OUTSTANDING_READ);
-		DDLOG32(BIF_BLACKPEARL_OUTSTANDING_READ);
-		DDLOG32(BIF_DUST_OUTSTANDING_READ);
-	}
-	else
 	{
 		if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, XT_TOP_INFRASTRUCTURE)))
 		{
@@ -3745,15 +2395,6 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		DDLOG32(BIFPM_READS_INT_STATUS);
 	}
 
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, SLC_VIVT))
-	{
-		DDLOG64(CONTEXT_MAPPING0);
-		DDLOG64(CONTEXT_MAPPING1);
-		DDLOG64(CONTEXT_MAPPING2);
-		DDLOG64(CONTEXT_MAPPING3);
-		DDLOG64(CONTEXT_MAPPING4);
-	}
-	else
 	{
 		DDLOG64(BIF_CAT_BASE_INDEX);
 		DDLOG64(BIF_CAT_BASE0);
@@ -3768,6 +2409,14 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 	DDLOG32(BIF_CTRL_INVAL);
 	DDLOG32(BIF_CTRL);
+}
+
+void RGXDumpDMRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
+	IMG_UINT32   ui32TACycles, ui323DCycles, ui32TAOr3DCycles, ui32TAAnd3DCycles;
 
 	DDLOG64(BIF_PM_CAT_BASE_VCE0);
 	DDLOG64(BIF_PM_CAT_BASE_TE0);
@@ -3776,7 +2425,7 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	DDLOG64(BIF_PM_CAT_BASE_TE1);
 	DDLOG64(BIF_PM_CAT_BASE_ALIST1);
 
-	if (bMulticore)
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT))
 	{
 		DDLOG32(MULTICORE_GEOMETRY_CTRL_COMMON);
 		DDLOG32(MULTICORE_FRAGMENT_CTRL_COMMON);
@@ -3814,11 +2463,6 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 
 	DDLOG32(ISP_CTL);
 	DDLOG32(ISP_STATUS);
-	DDLOG32(MTS_INTCTX);
-	DDLOG32(MTS_BGCTX);
-	DDLOG32(MTS_BGCTX_COUNTED_SCHEDULE);
-	DDLOG32(MTS_SCHEDULE);
-	DDLOG32(MTS_GPU_INT_STATUS);
 
 	DDLOG32(CDM_CONTEXT_STORE_STATUS);
 	DDLOG64(CDM_CONTEXT_PDS0);
@@ -3831,15 +2475,14 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		DDLOG64(CDM_CONTEXT_LOAD_PDS0);
 		DDLOG64(CDM_CONTEXT_LOAD_PDS1);
 	}
+}
 
-	if (bS7Infra)
-	{
-		DDLOG32(JONES_IDLE);
-	}
-
-	DDLOG32(SIDEKICK_IDLE);
+void RGXDumpSLCRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
 
-	if (!bS7Infra)
 	{
 		DDLOG32(SLC_IDLE);
 		DDLOG32(SLC_STATUS0);
@@ -3860,12 +2503,15 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		}
 		DDLOG64(SLC_CTRL_MISC);
 	}
-	else
-	{
-		DDLOG32(SLC3_IDLE);
-		DDLOG64(SLC3_STATUS);
-		DDLOG32(SLC3_FAULT_STOP_STATUS);
-	}
+}
+
+void RGXDumpMiscRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
+
+	DDLOG32(SIDEKICK_IDLE);
 
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, ROGUEXE) &&
 		RGX_IS_FEATURE_SUPPORTED(psDevInfo, WATCHDOG_TIMER))
@@ -3898,151 +2544,8 @@ PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		DDLOG32(SCRATCH14);
 		DDLOG32(SCRATCH15);
 	}
-
-	if (ui32Meta)
-	{
-		IMG_BOOL bIsT0Enabled = IMG_FALSE, bIsFWFaulted = IMG_FALSE;
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-		IMG_UINT32 ui32MSlvIrqStatusReg = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
-				((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ?
-					RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA :
-					RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_EQ1_AND_MRUA) :
-				RGX_CR_META_SP_MSLVIRQSTATUS;
-
-		PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, "META_SP_MSLVIRQSTATUS", OSReadUncheckedHWReg32(psDevInfo->pvSecureRegsBaseKM, ui32MSlvIrqStatusReg));
-#endif
-
-		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0ENABLE_OFFSET, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-		DDLOGVAL32("T0 TXENABLE", ui32RegVal);
-		if (ui32RegVal & META_CR_TXENABLE_ENABLE_BIT)
-		{
-			bIsT0Enabled = IMG_TRUE;
-		}
-
-		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0STATUS_OFFSET, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-		DDLOGVAL32("T0 TXSTATUS", ui32RegVal);
-
-		/* check for FW fault */
-		if (((ui32RegVal >> 20) & 0x3) == 0x2)
-		{
-			bIsFWFaulted = IMG_TRUE;
-		}
-
-		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0DEFR_OFFSET, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-		DDLOGVAL32("T0 TXDEFR", ui32RegVal);
-
-		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_PC, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-		DDLOGVAL32("T0 PC", ui32RegVal);
-
-		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_PCX, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-		DDLOGVAL32("T0 PCX", ui32RegVal);
-
-		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_SP, &ui32RegVal);
-		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-		DDLOGVAL32("T0 SP", ui32RegVal);
-
-		if ((ui32Meta == MTP218) || (ui32Meta == MTP219))
-		{
-			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1ENABLE_OFFSET, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-			DDLOGVAL32("T1 TXENABLE", ui32RegVal);
-
-			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1STATUS_OFFSET, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-			DDLOGVAL32("T1 TXSTATUS", ui32RegVal);
-
-			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1DEFR_OFFSET, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-			DDLOGVAL32("T1 TXDEFR", ui32RegVal);
-
-			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_PC, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-			DDLOGVAL32("T1 PC", ui32RegVal);
-
-			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_PCX, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-			DDLOGVAL32("T1 PCX", ui32RegVal);
-
-			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_SP, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
-			DDLOGVAL32("T1 SP", ui32RegVal);
-		}
-
-		if (bFirmwarePerf)
-		{
-			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_PERF_COUNT0, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-			DDLOGVAL32("META_CR_PERF_COUNT0", ui32RegVal);
-
-			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_PERF_COUNT1, &ui32RegVal);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
-			DDLOGVAL32("META_CR_PERF_COUNT1", ui32RegVal);
-		}
-
-		if (bIsT0Enabled & bIsFWFaulted)
-		{
-			eError = RGXValidateFWImage(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DUMPDEBUG_LOG("Failed to validate any FW code corruption");
-			}
-		}
-		else if (bIsFWFaulted)
-		{
-			PVR_DUMPDEBUG_LOG("Skipping FW code memory corruption checking as META is disabled");
-		}
-	}
-
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
-	{
-		DDLOG32(MIPS_ADDR_REMAP1_CONFIG1);
-		DDLOG64(MIPS_ADDR_REMAP1_CONFIG2);
-		DDLOG32(MIPS_ADDR_REMAP2_CONFIG1);
-		DDLOG64(MIPS_ADDR_REMAP2_CONFIG2);
-		DDLOG32(MIPS_ADDR_REMAP3_CONFIG1);
-		DDLOG64(MIPS_ADDR_REMAP3_CONFIG2);
-		DDLOG32(MIPS_ADDR_REMAP4_CONFIG1);
-		DDLOG64(MIPS_ADDR_REMAP4_CONFIG2);
-		DDLOG32(MIPS_ADDR_REMAP5_CONFIG1);
-		DDLOG64(MIPS_ADDR_REMAP5_CONFIG2);
-		DDLOG64(MIPS_WRAPPER_CONFIG);
-		DDLOG32(MIPS_EXCEPTION_STATUS);
-
-		RGXDumpMIPSState(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
-	}
-#endif
-
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
-	{
-		eError = RGXDumpRISCVState(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
-		PVR_RETURN_IF_ERROR(eError);
-	}
-
-	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, TFBC_VERSION))
-	{
-		DDLOGVAL32("TFBC_VERSION", RGX_GET_FEATURE_VALUE(psDevInfo, TFBC_VERSION));
-	}
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_LOSSY_37_PERCENT) ||
-	    RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_DELTA_CORRELATION))
-	{
-		DDLOGVAL32("TFBC_COMPRESSION_CONTROL", psDevInfo->psRGXFWIfSysInit->ui32TFBCCompressionControl);
-	}
-	return PVRSRV_OK;
-
-_METASPError:
-	PVR_DUMPDEBUG_LOG("Dump Slave Port debug information");
-	_RGXDumpMetaSPExtraDebugInfo(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
-
-	return eError;
-#endif /* defined(NO_HARDWARE) */
 }
+#endif /* !defined(NO_HARDWARE) */
 
 #undef REG32_FMTSPEC
 #undef REG64_FMTSPEC
diff --git a/drivers/gpu/drm/img-rogue/rgxdebug_common.c b/drivers/gpu/drm/img-rogue/rgxdebug_common.c
index 4b1393558a51..21a260848711 100644
--- a/drivers/gpu/drm/img-rogue/rgxdebug_common.c
+++ b/drivers/gpu/drm/img-rogue/rgxdebug_common.c
@@ -64,6 +64,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "debug_common.h"
 #include "info_page.h"
 #include "osfunc.h"
+#if defined(SUPPORT_SOC_TIMER)
+#include "rgxtimecorr.h"
+#endif
 
 #define MAX_FW_DESCRIPTION_LENGTH	(600U)
 
@@ -129,14 +132,12 @@ static const IMG_FLAGS2DESC asMisc2Description[] =
 	{RGXFWIF_INICFG_DM_KILL_MODE_RAND_EN, " CDM Random kill;"},
 	{RGXFWIF_INICFG_DISABLE_DM_OVERLAP, " DM Overlap Off;"},
 	{RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER, " Assert on HWR;"},
-	{RGXFWIF_INICFG_FABRIC_COHERENCY_ENABLED, " Coherent fabric on;"},
+	{RGXFWIF_INICFG_INJECT_ICS_FAULT, " Inject ICS Fault;"},
 	{RGXFWIF_INICFG_VALIDATE_IRQ, " Validate IRQ;"},
 	{RGXFWIF_INICFG_DISABLE_PDP_EN, " PDUMP Panic off;"},
 	{RGXFWIF_INICFG_SPU_POWER_STATE_MASK_CHANGE_EN, " SPU Pow mask change on;"},
 	{RGXFWIF_INICFG_WORKEST, " Workload Estim;"},
 	{RGXFWIF_INICFG_PDVFS, " PDVFS;"},
-	{RGXFWIF_INICFG_CDM_ARBITRATION_TASK_DEMAND, " CDM task demand arbitration;"},
-	{RGXFWIF_INICFG_CDM_ARBITRATION_ROUND_ROBIN, " CDM round-robin arbitration;"},
 	{RGXFWIF_INICFG_ISPSCHEDMODE_VER1_IPP, " ISP v1 scheduling;"},
 	{RGXFWIF_INICFG_ISPSCHEDMODE_VER2_ISP, " ISP v2 scheduling;"},
 	{RGXFWIF_INICFG_VALIDATE_SOCUSC_TIMER, " Validate SOC&USC timers;"},
@@ -158,8 +159,142 @@ static const IMG_FLAGS2DESC asFwOsCfg2Description[] =
 #if defined(SUPPORT_RAY_TRACING)
 	{RGXFWIF_INICFG_OS_LOW_PRIO_CS_RDM, " LowPrio RDM;"},
 #endif
+#if defined(SUPPORT_ICS)
+	{RGXFWIF_INICFG_OS_ICS_TDM_EN, " TDM;"},
+	{RGXFWIF_INICFG_OS_ICS_GEOM_EN, " GEOM;"},
+	{RGXFWIF_INICFG_OS_ICS_3D_EN, " 3D;"},
+	{RGXFWIF_INICFG_OS_ICS_CDM_EN, " CDM;"},
+#if defined(SUPPORT_RAY_TRACING)
+	{RGXFWIF_INICFG_OS_ICS_RDM_EN, " RDM;"},
+#endif
+	{RGXFWIF_INICFG_OS_FDTI_PROFILE_LONG, " Long FDTI profile;"},
+	{RGXFWIF_INICFG_OS_FDTI_PROFILE_MEDIUM, " Medium FDTI profile;"},
+	{RGXFWIF_INICFG_OS_FDTI_PROFILE_SHORT, " Short FDTI profile;"},
+#endif
+};
+
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+const IMG_CHAR * const gapszMipsPermissionPTFlags[4] =
+{
+	"    ",
+	"XI  ",
+	"RI  ",
+	"RIXI"
+};
+
+const IMG_CHAR * const gapszMipsCoherencyPTFlags[8] =
+{
+	"C",
+	"C",
+	" ",
+	"C",
+	"C",
+	"C",
+	"C",
+	" "
+};
+
+const IMG_CHAR * const gapszMipsDirtyGlobalValidPTFlags[8] =
+{
+	"   ",
+	"  G",
+	" V ",
+	" VG",
+	"D  ",
+	"D G",
+	"DV ",
+	"DVG"
+};
+
+#if !defined(NO_HARDWARE)
+/* Translation of MIPS exception encoding */
+typedef struct _MIPS_EXCEPTION_ENCODING_
+{
+	const IMG_CHAR *const pszStr;	/* Error type */
+	const IMG_BOOL bIsFatal;	/* Error is fatal or non-fatal */
+} MIPS_EXCEPTION_ENCODING;
+
+static const MIPS_EXCEPTION_ENCODING apsMIPSExcCodes[] =
+{
+	{"Interrupt", IMG_FALSE},
+	{"TLB modified exception", IMG_FALSE},
+	{"TLB exception (load/instruction fetch)", IMG_FALSE},
+	{"TLB exception (store)", IMG_FALSE},
+	{"Address error exception (load/instruction fetch)", IMG_TRUE},
+	{"Address error exception (store)", IMG_TRUE},
+	{"Bus error exception (instruction fetch)", IMG_TRUE},
+	{"Bus error exception (load/store)", IMG_TRUE},
+	{"Syscall exception", IMG_FALSE},
+	{"Breakpoint exception (FW assert)", IMG_FALSE},
+	{"Reserved instruction exception", IMG_TRUE},
+	{"Coprocessor Unusable exception", IMG_FALSE},
+	{"Arithmetic Overflow exception", IMG_FALSE},
+	{"Trap exception", IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{"Implementation-Specific Exception 1 (COP2)", IMG_FALSE},
+	{"CorExtend Unusable", IMG_FALSE},
+	{"Coprocessor 2 exceptions", IMG_FALSE},
+	{"TLB Read-Inhibit", IMG_TRUE},
+	{"TLB Execute-Inhibit", IMG_TRUE},
+	{NULL, IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{"Reference to WatchHi/WatchLo address", IMG_FALSE},
+	{"Machine check", IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{"DSP Module State Disabled exception", IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{NULL, IMG_FALSE},
+	{NULL, IMG_FALSE},
+	/* Can only happen in MIPS debug mode */
+	{"Parity error", IMG_FALSE},
+	{NULL, IMG_FALSE}
 };
 
+static IMG_CHAR const *_GetMIPSExcString(IMG_UINT32 ui32ExcCode)
+{
+	if (ui32ExcCode >= sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING))
+	{
+		PVR_DPF((PVR_DBG_WARNING,
+		         "Only %lu exceptions available in MIPS, %u is not a valid exception code",
+		         (unsigned long)sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING), ui32ExcCode));
+		return NULL;
+	}
+
+	return apsMIPSExcCodes[ui32ExcCode].pszStr;
+}
+#endif
+
+typedef struct _RGXMIPSFW_C0_DEBUG_TBL_ENTRY_
+{
+    IMG_UINT32 ui32Mask;
+    const IMG_CHAR * pszExplanation;
+} RGXMIPSFW_C0_DEBUG_TBL_ENTRY;
+
+#if !defined(NO_HARDWARE)
+static const RGXMIPSFW_C0_DEBUG_TBL_ENTRY sMIPS_C0_DebugTable[] =
+{
+    { RGXMIPSFW_C0_DEBUG_DSS,      "Debug single-step exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DBP,      "Debug software breakpoint exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DDBL,     "Debug data break exception occurred on a load" },
+    { RGXMIPSFW_C0_DEBUG_DDBS,     "Debug data break exception occurred on a store" },
+    { RGXMIPSFW_C0_DEBUG_DIB,      "Debug instruction break exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DINT,     "Debug interrupt exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DIBIMPR,  "Imprecise debug instruction break exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DDBLIMPR, "Imprecise debug data break load exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DDBSIMPR, "Imprecise debug data break store exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_IEXI,     "Imprecise error exception inhibit controls exception occurred" },
+    { RGXMIPSFW_C0_DEBUG_DBUSEP,   "Data access Bus Error exception pending" },
+    { RGXMIPSFW_C0_DEBUG_CACHEEP,  "Imprecise Cache Error pending" },
+    { RGXMIPSFW_C0_DEBUG_MCHECKP,  "Imprecise Machine Check exception pending" },
+    { RGXMIPSFW_C0_DEBUG_IBUSEP,   "Instruction fetch Bus Error exception pending" },
+    { (IMG_UINT32)RGXMIPSFW_C0_DEBUG_DBD,      "Debug exception occurred in branch delay slot" }
+};
+#endif
+#endif
+#endif /* !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)*/
+
 #define NARGS_MASK ~(0xF<<16)
 static IMG_BOOL _FirmwareTraceIntegrityCheck(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 						void *pvDumpDebugFile)
@@ -199,6 +334,7 @@ static IMG_BOOL _FirmwareTraceIntegrityCheck(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebug
 				{
 					/* Double % is a printable % sign and not a format string... */
 					ui32Count--;
+					pszString++;
 				}
 			}
 		}
@@ -320,7 +456,7 @@ static void RGXPrepareExtraDebugInfo(IMG_CHAR *pszBuffer, IMG_UINT32 ui32BufferS
 	IMG_BOOL   bHasExtraDebugInfo = IMG_FALSE;
 
 	/* Add prepend string */
-	OSStringLCopy(pszBuffer, RGXFWT_DEBUG_INFO_STR_PREPEND, ui32BufferSize);
+	OSStringSafeCopy(pszBuffer, RGXFWT_DEBUG_INFO_STR_PREPEND, ui32BufferSize);
 
 	/* Add debug info strings */
 	for (i = 0; i < ui32NumFields; i++)
@@ -373,6 +509,9 @@ static void RGXDumpFirmwareTraceLines(PVRSRV_RGXDEV_INFO *psDevInfo,
 	IMG_UINT32           ui32TraceBufSizeInDWords;
 
 	RGXFwSharedMemCacheOpValue(psRGXFWIfTraceBufCtl->sTraceBuf[ui32TID], INVALIDATE);
+	RGXFwSharedMemCacheOpExec(psDevInfo->apui32TraceBuffer[ui32TID],
+	                          psDevInfo->ui32TraceBufSizeInDWords * sizeof(IMG_UINT32),
+	                          PVRSRV_CACHE_OP_INVALIDATE);
 
 	pui32FWWrapCount = &(psRGXFWIfTraceBufCtl->sTraceBuf[ui32TID].ui32WrapCount);
 	pui32FWTracePtr  = &(psRGXFWIfTraceBufCtl->sTraceBuf[ui32TID].ui32TracePointer);
@@ -669,6 +808,7 @@ void RGXDumpFirmwareTraceBinary(PVRSRV_RGXDEV_INFO *psDevInfo,
 	OSFreeMem(pszLine);
 }
 
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
 void RGXDocumentFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
 				DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 				void *pvDumpDebugFile,
@@ -717,7 +857,7 @@ void RGXDocumentFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
 						  BITMASK_HAS(ui64PTE, RGX_MMUCTRL_PT_DATA_VALID_EN)           ? "V" : " ");
 	}
 }
-
+#endif /* !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION) */
 
 #if !defined(NO_HARDWARE)
 static PVRSRV_ERROR
@@ -841,8 +981,6 @@ PVRSRV_ERROR RGXValidateFWImage(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 #endif
 	RGXFWIF_DEV_VIRTADDR sFWAddr;
 	IMG_UINT32 ui32StartOffset = 0;
-	RGX_LAYER_PARAMS sLayerParams;
-	sLayerParams.psDevInfo = psDevInfo;
 
 #if defined(EMULATOR)
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
@@ -885,7 +1023,7 @@ PVRSRV_ERROR RGXValidateFWImage(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	}
 
 	/* Load FW image */
-	eError = RGXLoadAndGetFWData(psDevInfo->psDeviceNode, &psRGXFW, &pbRGXFirmware);
+	eError = RGXLoadAndGetFWData(psDevInfo->psDeviceNode, &psRGXFW);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to load FW image file (%s).",
@@ -894,23 +1032,25 @@ PVRSRV_ERROR RGXValidateFWImage(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		goto cleanup_initfw;
 	}
 
+	pbRGXFirmware = (const IMG_BYTE *)OSFirmwareData(psRGXFW);
+
 	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META))
 	{
-		eError = ProcessLDRCommandStream(&sLayerParams, pbRGXFirmware,
+		eError = ProcessLDRCommandStream(&psDevInfo->sLayerParams, pbRGXFirmware,
 						(void*) pui32HostFWCode, NULL,
 						(void*) pui32HostFWCoremem, NULL, NULL);
 	}
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
 	{
-		eError = ProcessELFCommandStream(&sLayerParams, pbRGXFirmware,
+		eError = ProcessELFCommandStream(&psDevInfo->sLayerParams, pbRGXFirmware,
 		                                 pui32HostFWCode, NULL,
 		                                 NULL, NULL);
 	}
 #endif
 	else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
 	{
-		eError = ProcessELFCommandStream(&sLayerParams, pbRGXFirmware,
+		eError = ProcessELFCommandStream(&psDevInfo->sLayerParams, pbRGXFirmware,
 		                                 pui32HostFWCode, NULL,
 		                                 pui32HostFWCoremem, NULL);
 	}
@@ -1147,7 +1287,7 @@ static void _GetFwSysFlagsDescription(IMG_CHAR *psDesc, IMG_UINT32 ui32DescSize,
 	size_t uLabelLen = sizeof(szCswLabel) - 1;
 	const size_t uiBytesPerDesc = (ui32DescSize - uLabelLen) / 2U - 1U;
 
-	OSStringLCopy(psDesc, szCswLabel, ui32DescSize);
+	OSStringSafeCopy(psDesc, szCswLabel, ui32DescSize);
 
 	DebugCommonFlagStrings(psDesc, uiBytesPerDesc + uLabelLen, asCswOpts2Description, ARRAY_SIZE(asCswOpts2Description), ui32RawFlags);
 	DebugCommonFlagStrings(psDesc, ui32DescSize, asMisc2Description, ARRAY_SIZE(asMisc2Description), ui32RawFlags);
@@ -1159,7 +1299,7 @@ static void _GetFwOsFlagsDescription(IMG_CHAR *psDesc, IMG_UINT32 ui32DescSize,
 	size_t uLabelLen = sizeof(szCswLabel) - 1;
 	const size_t uiBytesPerDesc = (ui32DescSize - uLabelLen) / 2U - 1U;
 
-	OSStringLCopy(psDesc, szCswLabel, ui32DescSize);
+	OSStringSafeCopy(psDesc, szCswLabel, ui32DescSize);
 
 	DebugCommonFlagStrings(psDesc, uiBytesPerDesc + uLabelLen, asFwOsCfg2Description, ARRAY_SIZE(asFwOsCfg2Description), ui32RawFlags);
 }
@@ -1473,13 +1613,13 @@ static void _FillAppForFWFaults(PVRSRV_RGXDEV_INFO *psDevInfo,
 			if (!psProcInfo)
 			{
 				bFound = RGXPCPIDToProcessInfo(psDevInfo,
-									psProcInfo->uiPID,
-									psProcInfo);
+								psProcInfo->uiPID,
+								psProcInfo);
 				if (!bFound)
 				{
-					OSStringLCopy(psProcInfo->szProcessName,
-									"(unknown)",
-									sizeof(psProcInfo->szProcessName));
+					OSStringSafeCopy(psProcInfo->szProcessName,
+								"(unknown)",
+								sizeof(psProcInfo->szProcessName));
 				}
 			}
 		}
@@ -1601,7 +1741,7 @@ static void _RecordFaultInfo(PVRSRV_RGXDEV_INFO *psDevInfo,
 			bIsPMFault = IMG_TRUE;
 			bFound = IMG_TRUE;
 			sProcessInfo.uiPID = RGXMEM_SERVER_PID_PM;
-			OSStringLCopy(sProcessInfo.szProcessName, "PM", sizeof(sProcessInfo.szProcessName));
+			OSStringSafeCopy(sProcessInfo.szProcessName, "PM", sizeof(sProcessInfo.szProcessName));
 			sProcessInfo.szProcessName[sizeof(sProcessInfo.szProcessName) - 1] = '\0';
 			sProcessInfo.bUnregistered = IMG_FALSE;
 		}
@@ -1777,6 +1917,826 @@ void RGXConvertOSTimestampToSAndNS(IMG_UINT64 ui64OSTimer,
 	*pui64Nanoseconds = ui64OSTimer - (*pui64Seconds * 1000000000ULL);
 }
 
+#if !defined(NO_HARDWARE)
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+static PVRSRV_ERROR _RGXMipsExtraDebug(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_MIPS_STATE *psMIPSState)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
+	IMG_UINT32 ui32RegRead;
+	IMG_UINT32 eError = PVRSRV_OK;
+	IMG_UINT32 volatile *pui32SyncFlag;
+
+	/* Acquire the NMI operations lock */
+	OSLockAcquire(psDevInfo->hNMILock);
+
+	/* Make sure the synchronisation flag is set to 0 */
+	pui32SyncFlag = &psDevInfo->psRGXFWIfSysInit->sMIPSState.ui32Sync;
+	*pui32SyncFlag = 0;
+
+	/* Readback performed as a part of memory barrier */
+	OSWriteMemoryBarrier(pui32SyncFlag);
+	RGXFwSharedMemCacheOpPtr(pui32SyncFlag,
+	                         FLUSH);
+
+
+	/* Enable NMI issuing in the MIPS wrapper */
+	OSWriteHWReg64(pvRegsBaseKM,
+				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE,
+				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE_EVENT_EN);
+	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_ENABLE);
+
+	/* Check the MIPS is not in error state already (e.g. it is booting or an NMI has already been requested) */
+	ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
+				   RGX_CR_MIPS_EXCEPTION_STATUS);
+	if ((ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN) || (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN))
+	{
+
+		eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
+		goto fail;
+	}
+	ui32RegRead = 0;
+
+	/* Issue NMI */
+	OSWriteHWReg32(pvRegsBaseKM,
+				   RGX_CR_MIPS_WRAPPER_NMI_EVENT,
+				   RGX_CR_MIPS_WRAPPER_NMI_EVENT_TRIGGER_EN);
+	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_EVENT);
+
+
+	/* Wait for NMI Taken to be asserted */
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
+	{
+		ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
+									RGX_CR_MIPS_EXCEPTION_STATUS);
+		if (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN)
+		{
+			break;
+		}
+		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+	} END_LOOP_UNTIL_TIMEOUT_US();
+
+	if ((ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_NMI_TAKEN_EN) == 0)
+	{
+		eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
+		goto fail;
+	}
+	ui32RegRead = 0;
+
+	/* Allow the firmware to proceed */
+	*pui32SyncFlag = 1;
+
+	/* Readback performed as a part of memory barrier */
+	OSWriteMemoryBarrier(pui32SyncFlag);
+	RGXFwSharedMemCacheOpPtr(pui32SyncFlag,
+	                         FLUSH);
+
+
+	/* Wait for the FW to have finished the NMI routine */
+	ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
+								RGX_CR_MIPS_EXCEPTION_STATUS);
+
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
+	{
+		ui32RegRead = OSReadHWReg32(pvRegsBaseKM,
+									RGX_CR_MIPS_EXCEPTION_STATUS);
+		if (!(ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN))
+		{
+			break;
+		}
+		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
+	} END_LOOP_UNTIL_TIMEOUT_US();
+	if (ui32RegRead & RGX_CR_MIPS_EXCEPTION_STATUS_SI_ERL_EN)
+	{
+		eError = PVRSRV_ERROR_MIPS_STATUS_UNAVAILABLE;
+		goto fail;
+	}
+	ui32RegRead = 0;
+
+	/* Copy state */
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->sMIPSState,
+	                           INVALIDATE);
+	OSDeviceMemCopy(psMIPSState, &psDevInfo->psRGXFWIfSysInit->sMIPSState, sizeof(*psMIPSState));
+
+	--(psMIPSState->ui32ErrorEPC);
+	--(psMIPSState->ui32EPC);
+
+	/* Disable NMI issuing in the MIPS wrapper */
+	OSWriteHWReg32(pvRegsBaseKM,
+				   RGX_CR_MIPS_WRAPPER_NMI_ENABLE,
+				   0);
+	(void) OSReadHWReg64(pvRegsBaseKM, RGX_CR_MIPS_WRAPPER_NMI_ENABLE);
+
+fail:
+	/* Release the NMI operations lock */
+	OSLockRelease(psDevInfo->hNMILock);
+	return eError;
+}
+
+/* Print decoded information from cause register */
+static void _RGXMipsDumpCauseDecode(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+                                    void *pvDumpDebugFile,
+                                    IMG_UINT32 ui32Cause,
+                                    IMG_UINT32 ui32ErrorState)
+{
+#define INDENT "    "
+	const IMG_UINT32 ui32ExcCode = RGXMIPSFW_C0_CAUSE_EXCCODE(ui32Cause);
+	const IMG_CHAR * const pszException = _GetMIPSExcString(ui32ExcCode);
+
+	if (ui32ErrorState != 0 &&
+	    pszException != NULL)
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "Cause exception: %s", pszException);
+	}
+
+	if (ui32Cause & RGXMIPSFW_C0_CAUSE_FDCIPENDING)
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "FDC interrupt pending");
+	}
+
+	if (!(ui32Cause & RGXMIPSFW_C0_CAUSE_IV))
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "Interrupt uses general interrupt vector");
+	}
+
+	if (ui32Cause & RGXMIPSFW_C0_CAUSE_PCIPENDING)
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "Performance Counter Interrupt pending");
+	}
+
+	/* Unusable Coproc exception */
+	if (ui32ExcCode == 11)
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "Unusable Coprocessor: %d", RGXMIPSFW_C0_CAUSE_UNUSABLE_UNIT(ui32Cause));
+	}
+
+#undef INDENT
+}
+
+static IMG_BOOL _IsFWCodeException(IMG_UINT32 ui32ExcCode)
+{
+	if (ui32ExcCode >= sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING))
+	{
+		PVR_DPF((PVR_DBG_WARNING,
+		         "Only %lu exceptions available in MIPS, %u is not a valid exception code",
+		         (unsigned long)sizeof(apsMIPSExcCodes)/sizeof(MIPS_EXCEPTION_ENCODING), ui32ExcCode));
+		return IMG_FALSE;
+	}
+
+	return apsMIPSExcCodes[ui32ExcCode].bIsFatal;
+}
+
+static void _RGXMipsDumpDebugDecode(PVRSRV_RGXDEV_INFO *psDevInfo,
+					DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+					void *pvDumpDebugFile,
+					IMG_UINT32 ui32Debug,
+					IMG_UINT32 ui32DEPC)
+{
+	const IMG_CHAR *pszDException = NULL;
+	IMG_UINT32 i;
+#define INDENT "    "
+
+	if (!(ui32Debug & RGXMIPSFW_C0_DEBUG_DM))
+	{
+		return;
+	}
+
+	PVR_DUMPDEBUG_LOG("DEBUG                        :");
+
+	pszDException = _GetMIPSExcString(RGXMIPSFW_C0_DEBUG_EXCCODE(ui32Debug));
+
+	if (pszDException != NULL)
+	{
+		PVR_DUMPDEBUG_LOG(INDENT "Debug exception: %s", pszDException);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sMIPS_C0_DebugTable); ++i)
+	{
+		const RGXMIPSFW_C0_DEBUG_TBL_ENTRY * const psDebugEntry = &sMIPS_C0_DebugTable[i];
+
+		if (ui32Debug & psDebugEntry->ui32Mask)
+		{
+			PVR_DUMPDEBUG_LOG(INDENT "%s", psDebugEntry->pszExplanation);
+		}
+	}
+#undef INDENT
+	PVR_DUMPDEBUG_LOG("DEPC                    :0x%08X", ui32DEPC);
+}
+
+static inline void _GetMipsTLBPARanges(const RGX_MIPS_TLB_ENTRY *psTLBEntry,
+                                       const RGX_MIPS_REMAP_ENTRY *psRemapEntry0,
+                                       const RGX_MIPS_REMAP_ENTRY *psRemapEntry1,
+                                       IMG_UINT64 *pui64PA0Start,
+                                       IMG_UINT64 *pui64PA0End,
+                                       IMG_UINT64 *pui64PA1Start,
+                                       IMG_UINT64 *pui64PA1End)
+{
+	IMG_BOOL bUseRemapOutput = (psRemapEntry0 != NULL && psRemapEntry1 != NULL) ? IMG_TRUE : IMG_FALSE;
+	IMG_UINT64 ui64PageSize = RGXMIPSFW_TLB_GET_PAGE_SIZE(psTLBEntry->ui32TLBPageMask);
+
+	if ((psTLBEntry->ui32TLBLo0 & RGXMIPSFW_TLB_VALID) == 0)
+	{
+		/* Dummy values to fail the range checks later */
+		*pui64PA0Start = -1ULL;
+		*pui64PA0End   = -1ULL;
+	}
+	else if (bUseRemapOutput)
+	{
+		*pui64PA0Start = (IMG_UINT64)psRemapEntry0->ui32RemapAddrOut << 12;
+		*pui64PA0End   = *pui64PA0Start + ui64PageSize - 1;
+	}
+	else
+	{
+		*pui64PA0Start = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo0);
+		*pui64PA0End   = *pui64PA0Start + ui64PageSize - 1;
+	}
+
+	if ((psTLBEntry->ui32TLBLo1 & RGXMIPSFW_TLB_VALID) == 0)
+	{
+		/* Dummy values to fail the range checks later */
+		*pui64PA1Start = -1ULL;
+		*pui64PA1End   = -1ULL;
+	}
+	else if (bUseRemapOutput)
+	{
+		*pui64PA1Start = (IMG_UINT64)psRemapEntry1->ui32RemapAddrOut << 12;
+		*pui64PA1End   = *pui64PA1Start + ui64PageSize - 1;
+	}
+	else
+	{
+		*pui64PA1Start = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo1);
+		*pui64PA1End   = *pui64PA1Start + ui64PageSize - 1;
+	}
+}
+
+static void _CheckMipsTLBDuplicatePAs(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+                                      void *pvDumpDebugFile,
+                                      const RGX_MIPS_TLB_ENTRY *psTLB,
+                                      const RGX_MIPS_REMAP_ENTRY *psRemap)
+{
+	IMG_UINT64 ui64PA0StartI, ui64PA1StartI, ui64PA0StartJ, ui64PA1StartJ;
+	IMG_UINT64 ui64PA0EndI,   ui64PA1EndI,   ui64PA0EndJ,   ui64PA1EndJ;
+	IMG_UINT32 i, j;
+
+#define RANGES_OVERLAP(start0,end0,start1,end1)  ((start0) < (end1) && (start1) < (end0))
+
+	for (i = 0; i < RGXMIPSFW_NUMBER_OF_TLB_ENTRIES; i++)
+	{
+		_GetMipsTLBPARanges(&psTLB[i],
+		                    psRemap ? &psRemap[i] : NULL,
+		                    psRemap ? &psRemap[i + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
+		                    &ui64PA0StartI, &ui64PA0EndI,
+		                    &ui64PA1StartI, &ui64PA1EndI);
+
+		for (j = i + 1; j < RGXMIPSFW_NUMBER_OF_TLB_ENTRIES; j++)
+		{
+			_GetMipsTLBPARanges(&psTLB[j],
+			                    psRemap ? &psRemap[j] : NULL,
+			                    psRemap ? &psRemap[j + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
+			                    &ui64PA0StartJ, &ui64PA0EndJ,
+			                    &ui64PA1StartJ, &ui64PA1EndJ);
+
+			if (RANGES_OVERLAP(ui64PA0StartI, ui64PA0EndI, ui64PA0StartJ, ui64PA0EndJ) ||
+			    RANGES_OVERLAP(ui64PA0StartI, ui64PA0EndI, ui64PA1StartJ, ui64PA1EndJ) ||
+			    RANGES_OVERLAP(ui64PA1StartI, ui64PA1EndI, ui64PA0StartJ, ui64PA0EndJ) ||
+			    RANGES_OVERLAP(ui64PA1StartI, ui64PA1EndI, ui64PA1StartJ, ui64PA1EndJ)  )
+			{
+				PVR_DUMPDEBUG_LOG("Overlap between TLB entry %u and %u", i , j);
+			}
+		}
+	}
+}
+
+static inline IMG_UINT32 _GetMIPSRemapRegionSize(IMG_UINT32 ui32RegionSizeEncoding)
+{
+    return 1U << ((ui32RegionSizeEncoding + 1U) << 1U);
+}
+
+static inline void _RGXMipsDumpTLBEntry(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+                                        void *pvDumpDebugFile,
+                                        const RGX_MIPS_TLB_ENTRY *psTLBEntry,
+                                        const RGX_MIPS_REMAP_ENTRY *psRemapEntry0,
+                                        const RGX_MIPS_REMAP_ENTRY *psRemapEntry1,
+                                        IMG_UINT32 ui32Index)
+{
+	IMG_BOOL bDumpRemapEntries = (psRemapEntry0 != NULL && psRemapEntry1 != NULL) ? IMG_TRUE : IMG_FALSE;
+	IMG_UINT64 ui64PA0 = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo0);
+	IMG_UINT64 ui64PA1 = RGXMIPSFW_TLB_GET_PA(psTLBEntry->ui32TLBLo1);
+	IMG_UINT64 ui64Remap0AddrOut = 0, ui64Remap1AddrOut = 0;
+	IMG_UINT32 ui32Remap0AddrIn = 0, ui32Remap1AddrIn = 0;
+
+	if (bDumpRemapEntries)
+	{
+		/* RemapAddrIn is always 4k aligned and on 32 bit */
+		ui32Remap0AddrIn = psRemapEntry0->ui32RemapAddrIn << 12;
+		ui32Remap1AddrIn = psRemapEntry1->ui32RemapAddrIn << 12;
+
+		/* RemapAddrOut is always 4k aligned and on 32 or 36 bit */
+		ui64Remap0AddrOut = (IMG_UINT64)psRemapEntry0->ui32RemapAddrOut << 12;
+		ui64Remap1AddrOut = (IMG_UINT64)psRemapEntry1->ui32RemapAddrOut << 12;
+
+		/* If TLB and remap entries match, then merge them else, print them separately */
+		if ((IMG_UINT32)ui64PA0 == ui32Remap0AddrIn &&
+		    (IMG_UINT32)ui64PA1 == ui32Remap1AddrIn)
+		{
+			ui64PA0 = ui64Remap0AddrOut;
+			ui64PA1 = ui64Remap1AddrOut;
+			bDumpRemapEntries = IMG_FALSE;
+		}
+	}
+
+	PVR_DUMPDEBUG_LOG("%2u) VA 0x%08X (%3uk) -> PA0 0x%08" IMG_UINT64_FMTSPECx " %s%s%s, "
+	                                           "PA1 0x%08" IMG_UINT64_FMTSPECx " %s%s%s",
+	                  ui32Index,
+	                  psTLBEntry->ui32TLBHi,
+	                  RGXMIPSFW_TLB_GET_PAGE_SIZE(psTLBEntry->ui32TLBPageMask),
+	                  ui64PA0,
+	                  gapszMipsPermissionPTFlags[RGXMIPSFW_TLB_GET_INHIBIT(psTLBEntry->ui32TLBLo0)],
+	                  gapszMipsDirtyGlobalValidPTFlags[RGXMIPSFW_TLB_GET_DGV(psTLBEntry->ui32TLBLo0)],
+	                  gapszMipsCoherencyPTFlags[RGXMIPSFW_TLB_GET_COHERENCY(psTLBEntry->ui32TLBLo0)],
+	                  ui64PA1,
+	                  gapszMipsPermissionPTFlags[RGXMIPSFW_TLB_GET_INHIBIT(psTLBEntry->ui32TLBLo1)],
+	                  gapszMipsDirtyGlobalValidPTFlags[RGXMIPSFW_TLB_GET_DGV(psTLBEntry->ui32TLBLo1)],
+	                  gapszMipsCoherencyPTFlags[RGXMIPSFW_TLB_GET_COHERENCY(psTLBEntry->ui32TLBLo1)]);
+
+	if (bDumpRemapEntries)
+	{
+		PVR_DUMPDEBUG_LOG("    Remap %2u : IN 0x%08X (%3uk) => OUT 0x%08" IMG_UINT64_FMTSPECx,
+		                  ui32Index,
+		                  ui32Remap0AddrIn,
+		                  _GetMIPSRemapRegionSize(psRemapEntry0->ui32RemapRegionSize),
+		                  ui64Remap0AddrOut);
+
+		PVR_DUMPDEBUG_LOG("    Remap %2u : IN 0x%08X (%3uk) => OUT 0x%08" IMG_UINT64_FMTSPECx,
+		                  ui32Index + RGXMIPSFW_NUMBER_OF_TLB_ENTRIES,
+		                  ui32Remap1AddrIn,
+		                  _GetMIPSRemapRegionSize(psRemapEntry1->ui32RemapRegionSize),
+		                  ui64Remap1AddrOut);
+	}
+}
+
+static RGX_MIPS_REMAP_ENTRY RGXDecodeMIPSRemap(IMG_UINT64 ui64RemapReg)
+{
+	RGX_MIPS_REMAP_ENTRY sRemapInfo;
+
+	sRemapInfo.ui32RemapAddrIn =
+			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_BASE_ADDR_IN_CLRMSK)
+				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_BASE_ADDR_IN_SHIFT;
+
+	sRemapInfo.ui32RemapAddrOut =
+			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_ADDR_OUT_CLRMSK)
+				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_ADDR_OUT_SHIFT;
+
+	sRemapInfo.ui32RemapRegionSize =
+			(ui64RemapReg & ~RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_REGION_SIZE_CLRMSK)
+				>> RGX_CR_MIPS_ADDR_REMAP_RANGE_DATA_REGION_SIZE_SHIFT;
+
+	return sRemapInfo;
+}
+
+static void RGXDumpMIPSState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+							 void *pvDumpDebugFile,
+							 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
+	RGX_MIPS_STATE sMIPSState = {0};
+	PVRSRV_ERROR eError;
+
+	eError = _RGXMipsExtraDebug(psDevInfo, &sMIPSState);
+	PVR_DUMPDEBUG_LOG("---- [ MIPS internal state ] ----");
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DUMPDEBUG_LOG("MIPS extra debug not available");
+	}
+	else
+	{
+		DDLOGVAL32("PC", sMIPSState.ui32ErrorEPC);
+		DDLOGVAL32("STATUS_REGISTER", sMIPSState.ui32StatusRegister);
+		DDLOGVAL32("CAUSE_REGISTER", sMIPSState.ui32CauseRegister);
+		_RGXMipsDumpCauseDecode(pfnDumpDebugPrintf, pvDumpDebugFile,
+								sMIPSState.ui32CauseRegister, sMIPSState.ui32ErrorState);
+		DDLOGVAL32("BAD_REGISTER", sMIPSState.ui32BadRegister);
+		DDLOGVAL32("EPC", sMIPSState.ui32EPC);
+		DDLOGVAL32("SP", sMIPSState.ui32SP);
+		DDLOGVAL32("BAD_INSTRUCTION", sMIPSState.ui32BadInstr);
+		_RGXMipsDumpDebugDecode(psDevInfo, pfnDumpDebugPrintf, pvDumpDebugFile,
+								sMIPSState.ui32Debug, sMIPSState.ui32DEPC);
+
+		{
+			IMG_UINT32 ui32Idx;
+			RGX_MIPS_REMAP_ENTRY *psMipsRemaps = NULL;
+
+			IMG_BOOL bCheckBRN63553WA =
+				RGX_IS_BRN_SUPPORTED(psDevInfo, 63553) &&
+				(OSReadHWReg32(pvRegsBaseKM, RGX_CR_MIPS_ADDR_REMAP5_CONFIG1) == (0x0 | RGX_CR_MIPS_ADDR_REMAP5_CONFIG1_MODE_ENABLE_EN));
+
+			IMG_BOOL bUseRemapRanges = RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH) > 32;
+
+			if (bUseRemapRanges)
+			{
+				psMipsRemaps = OSAllocMem(sizeof(RGX_MIPS_REMAP_ENTRY) * RGXMIPSFW_NUMBER_OF_REMAP_ENTRIES);
+				PVR_LOG_RETURN_VOID_IF_FALSE(psMipsRemaps != NULL, "psMipsRemaps alloc failed.");
+			}
+
+			PVR_DUMPDEBUG_LOG("TLB                           :");
+
+			for (ui32Idx = 0; ui32Idx < ARRAY_SIZE(sMIPSState.asTLB); ui32Idx++)
+			{
+				if (bUseRemapRanges)
+				{
+					psMipsRemaps[ui32Idx] =
+							RGXDecodeMIPSRemap(sMIPSState.aui64Remap[ui32Idx]);
+
+					psMipsRemaps[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] =
+							RGXDecodeMIPSRemap(sMIPSState.aui64Remap[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES]);
+				}
+
+				_RGXMipsDumpTLBEntry(pfnDumpDebugPrintf,
+								     pvDumpDebugFile,
+								     &sMIPSState.asTLB[ui32Idx],
+								     (bUseRemapRanges) ? &psMipsRemaps[ui32Idx] : NULL,
+								     (bUseRemapRanges) ? &psMipsRemaps[ui32Idx+RGXMIPSFW_NUMBER_OF_TLB_ENTRIES] : NULL,
+								     ui32Idx);
+
+				if (bCheckBRN63553WA)
+				{
+					const RGX_MIPS_TLB_ENTRY *psTLBEntry = &sMIPSState.asTLB[ui32Idx];
+
+					#define BRN63553_TLB_IS_NUL(X)  (((X) & RGXMIPSFW_TLB_VALID) && (RGXMIPSFW_TLB_GET_PA(X) == 0x0))
+
+					if (BRN63553_TLB_IS_NUL(psTLBEntry->ui32TLBLo0) || BRN63553_TLB_IS_NUL(psTLBEntry->ui32TLBLo1))
+					{
+						PVR_DUMPDEBUG_LOG("BRN63553 WA present with a valid TLB entry mapping address 0x0.");
+					}
+				}
+			}
+
+			/* This implicitly also checks for overlaps between memory and regbank addresses */
+			_CheckMipsTLBDuplicatePAs(pfnDumpDebugPrintf,
+									  pvDumpDebugFile,
+									  sMIPSState.asTLB,
+									  bUseRemapRanges ? psMipsRemaps : NULL);
+
+			if (bUseRemapRanges)
+			{
+				/* Dump unmapped address if it was dumped in FW, otherwise it will be 0 */
+				if (sMIPSState.ui32UnmappedAddress)
+				{
+					PVR_DUMPDEBUG_LOG("Remap unmapped address => 0x%08X",
+									  sMIPSState.ui32UnmappedAddress);
+				}
+			}
+
+			if (psMipsRemaps != NULL)
+			{
+				OSFreeMem(psMipsRemaps);
+			}
+		}
+
+		/* Check FW code corruption in case of known errors */
+		if (_IsFWCodeException(RGXMIPSFW_C0_CAUSE_EXCCODE(sMIPSState.ui32CauseRegister)))
+		{
+			eError = RGXValidateFWImage(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DUMPDEBUG_LOG("Failed to validate any FW code corruption");
+			}
+		}
+	}
+	PVR_DUMPDEBUG_LOG("--------------------------------");
+}
+#endif /* defined(RGX_FEATURE_MIPS_BIT_MASK) */
+
+static void _RGXDumpMetaSPExtraDebugInfo(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+						void *pvDumpDebugFile,
+						PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+/* List of extra META Slave Port debug registers */
+#define RGX_META_SP_EXTRA_DEBUG \
+			X(RGX_CR_META_SP_MSLVCTRL0) \
+			X(RGX_CR_META_SP_MSLVCTRL1) \
+			X(RGX_CR_META_SP_MSLVDATAX) \
+			X(RGX_CR_META_SP_MSLVIRQSTATUS) \
+			X(RGX_CR_META_SP_MSLVIRQENABLE) \
+			X(RGX_CR_META_SP_MSLVIRQLEVEL)
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+/* Order in these two initialisers and the one above must match */
+#define RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_EQ1_AND_MRUA_ACCESSES \
+			X(RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_EQ1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_EQ1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQENABLE__HOST_SECURITY_EQ1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQLEVEL__HOST_SECURITY_EQ1_AND_MRUA)
+
+#define RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_GT1_AND_MRUA_ACCESSES \
+			X(RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_GT1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQENABLE__HOST_SECURITY_GT1_AND_MRUA) \
+			X(RGX_CR_META_SP_MSLVIRQLEVEL__HOST_SECURITY_GT1_AND_MRUA)
+#endif
+
+	IMG_UINT32 ui32Idx;
+	IMG_UINT32 ui32RegVal;
+	IMG_UINT32 ui32RegAddr;
+
+	const IMG_UINT32* pui32DebugRegAddr;
+	const IMG_UINT32 aui32DebugRegAddr[] = {
+#define X(A) A,
+		RGX_META_SP_EXTRA_DEBUG
+#undef X
+		};
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	const IMG_UINT32 aui32DebugRegAddrUAHSV1[] = {
+#define X(A) A,
+		RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_EQ1_AND_MRUA_ACCESSES
+#undef X
+		};
+
+	const IMG_UINT32 aui32DebugRegAddrUAHSGT1[] = {
+#define X(A) A,
+		RGX_META_SP_EXTRA_DEBUG__HOST_SECURITY_GT1_AND_MRUA_ACCESSES
+#undef X
+		};
+#endif
+
+	const IMG_CHAR* apszDebugRegName[] = {
+#define X(A) #A,
+	RGX_META_SP_EXTRA_DEBUG
+#undef X
+	};
+
+	PVR_DUMPDEBUG_LOG("META Slave Port extra debug:");
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	/* array of register offset values depends on feature. But don't augment names in apszDebugRegName */
+	PVR_ASSERT(sizeof(aui32DebugRegAddrUAHSGT1) == sizeof(aui32DebugRegAddr));
+	PVR_ASSERT(sizeof(aui32DebugRegAddrUAHSV1) == sizeof(aui32DebugRegAddr));
+	pui32DebugRegAddr = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
+						((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ? (aui32DebugRegAddrUAHSGT1) : (aui32DebugRegAddrUAHSV1)) : aui32DebugRegAddr;
+#else
+	pui32DebugRegAddr = aui32DebugRegAddr;
+#endif
+
+	/* dump set of Slave Port debug registers */
+	for (ui32Idx = 0; ui32Idx < sizeof(aui32DebugRegAddr)/sizeof(IMG_UINT32); ui32Idx++)
+	{
+		const IMG_CHAR* pszRegName = apszDebugRegName[ui32Idx];
+
+		ui32RegAddr = pui32DebugRegAddr[ui32Idx];
+		ui32RegVal = OSReadUncheckedHWReg32(RGX_GET_RISCV_REGS_BASE(psDevInfo), ui32RegAddr);
+		PVR_DUMPDEBUG_LOG("  * %s: 0x%8.8X", pszRegName, ui32RegVal);
+	}
+}
+#endif
+#endif /* !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION) */
+
+PVRSRV_ERROR RGXDumpRGXRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+#if defined(NO_HARDWARE)
+	PVR_DUMPDEBUG_LOG("------[ RGX registers ]------");
+	PVR_DUMPDEBUG_LOG("(Not supported for NO_HARDWARE builds)");
+
+	return PVRSRV_OK;
+#else /* !defined(NO_HARDWARE) */
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
+	IMG_UINT32   ui32Meta = RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META) ? RGX_GET_FEATURE_VALUE(psDevInfo, META) : 0;
+#endif
+	IMG_BOOL     bFirmwarePerf;
+	void __iomem *pvRegsBaseKM = psDevInfo->pvRegsBaseKM;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	PVR_DUMPDEBUG_LOG("------[ RGX registers ]------");
+	PVR_DUMPDEBUG_LOG("RGX Register Base Address (Linear):   0x%p", psDevInfo->pvRegsBaseKM);
+	PVR_DUMPDEBUG_LOG("RGX Register Base Address (Physical): 0x%08lX", (unsigned long)psDevInfo->sRegsPhysBase.uiAddr);
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
+	{
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(SUPPORT_SECURITY_VALIDATION)
+		PVR_DUMPDEBUG_LOG("RGX Host Secure Register Base Address (Linear): N/A in REE ");
+#else
+		PVR_DUMPDEBUG_LOG("RGX Host Secure Register Base Address (Linear):   0x%p",
+							psDevInfo->pvSecureRegsBaseKM);
+#endif
+		PVR_DUMPDEBUG_LOG("RGX Host Secure Register Base Address (Physical): 0x%08lX",
+							(unsigned long)psDevInfo->sRegsPhysBase.uiAddr + RGX_HOST_SECURE_REGBANK_OFFSET);
+	}
+#endif
+
+	/* Check if firmware perf was set at Init time */
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->eFirmwarePerf,
+	                           INVALIDATE);
+	bFirmwarePerf = (psDevInfo->psRGXFWIfSysInit->eFirmwarePerf != FW_PERF_CONF_NONE);
+
+	RGXDumpCoreRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
+	if (ui32Meta)
+	{
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+		IMG_UINT32 ui32MSlvCtrl1Reg = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
+				((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ?
+					RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA :
+					RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA) :
+				RGX_CR_META_SP_MSLVCTRL1;
+
+		/* Forcing bit 6 of MslvCtrl1 to 0 to avoid internal reg read going through the core */
+		OSWriteUncheckedHWReg32(psDevInfo->pvSecureRegsBaseKM, ui32MSlvCtrl1Reg, 0x0);
+#else
+		/* Forcing bit 6 of MslvCtrl1 to 0 to avoid internal reg read going through the core */
+		OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_META_SP_MSLVCTRL1, 0x0);
+#endif
+
+		DDLOG32(META_SP_MSLVIRQSTATUS);
+	}
+#endif /* !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION) */
+
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT))
+	{
+		RGXDumpMulticoreRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+	}
+
+	RGXDumpClkRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+	DDLOG32(EVENT_STATUS);
+	DDLOG64(TIMER);
+
+	RGXDumpMMURegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+	RGXDumpDMRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+	DDLOG32(MTS_INTCTX);
+	DDLOG32(MTS_BGCTX);
+	DDLOG32(MTS_BGCTX_COUNTED_SCHEDULE);
+	DDLOG32(MTS_SCHEDULE);
+	DDLOG32(MTS_GPU_INT_STATUS);
+
+	RGXDumpSLCRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+	RGXDumpMiscRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	PVR_DUMPDEBUG_LOG("FW Core Registers not available to REE");
+#else
+	if (ui32Meta)
+	{
+		IMG_BOOL bIsT0Enabled = IMG_FALSE, bIsFWFaulted = IMG_FALSE;
+		IMG_UINT32 ui32RegVal;
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+		IMG_UINT32 ui32MSlvIrqStatusReg = RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES) ?
+				((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1) ?
+					RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA :
+					RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_EQ1_AND_MRUA) :
+				RGX_CR_META_SP_MSLVIRQSTATUS;
+
+		PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, "META_SP_MSLVIRQSTATUS", OSReadUncheckedHWReg32(psDevInfo->pvSecureRegsBaseKM, ui32MSlvIrqStatusReg));
+#endif
+
+		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0ENABLE_OFFSET, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+		DDLOGVAL32("T0 TXENABLE", ui32RegVal);
+		if (ui32RegVal & META_CR_TXENABLE_ENABLE_BIT)
+		{
+			bIsT0Enabled = IMG_TRUE;
+		}
+
+		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0STATUS_OFFSET, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+		DDLOGVAL32("T0 TXSTATUS", ui32RegVal);
+
+		/* check for FW fault */
+		if (((ui32RegVal >> 20) & 0x3) == 0x2)
+		{
+			bIsFWFaulted = IMG_TRUE;
+		}
+
+		eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T0DEFR_OFFSET, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+		DDLOGVAL32("T0 TXDEFR", ui32RegVal);
+
+		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_PC, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+		DDLOGVAL32("T0 PC", ui32RegVal);
+
+		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_PCX, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+		DDLOGVAL32("T0 PCX", ui32RegVal);
+
+		eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR0_SP, &ui32RegVal);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+		DDLOGVAL32("T0 SP", ui32RegVal);
+
+		if ((ui32Meta == MTP218) || (ui32Meta == MTP219))
+		{
+			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1ENABLE_OFFSET, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+			DDLOGVAL32("T1 TXENABLE", ui32RegVal);
+
+			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1STATUS_OFFSET, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+			DDLOGVAL32("T1 TXSTATUS", ui32RegVal);
+
+			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_T1DEFR_OFFSET, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+			DDLOGVAL32("T1 TXDEFR", ui32RegVal);
+
+			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_PC, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+			DDLOGVAL32("T1 PC", ui32RegVal);
+
+			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_PCX, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+			DDLOGVAL32("T1 PCX", ui32RegVal);
+
+			eError = RGXReadMetaCoreReg(psDevInfo, META_CR_THR1_SP, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadMetaCoreReg", _METASPError);
+			DDLOGVAL32("T1 SP", ui32RegVal);
+		}
+
+		if (bFirmwarePerf)
+		{
+			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_PERF_COUNT0, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+			DDLOGVAL32("META_CR_PERF_COUNT0", ui32RegVal);
+
+			eError = RGXReadFWModuleAddr(psDevInfo, META_CR_PERF_COUNT1, &ui32RegVal);
+			PVR_LOG_GOTO_IF_ERROR(eError, "RGXReadFWModuleAddr", _METASPError);
+			DDLOGVAL32("META_CR_PERF_COUNT1", ui32RegVal);
+		}
+
+		if (bIsT0Enabled & bIsFWFaulted)
+		{
+			eError = RGXValidateFWImage(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DUMPDEBUG_LOG("Failed to validate any FW code corruption");
+			}
+		}
+		else if (bIsFWFaulted)
+		{
+			PVR_DUMPDEBUG_LOG("Skipping FW code memory corruption checking as META is disabled");
+		}
+	}
+
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
+	{
+		DDLOG32(MIPS_ADDR_REMAP1_CONFIG1);
+		DDLOG64(MIPS_ADDR_REMAP1_CONFIG2);
+		DDLOG32(MIPS_ADDR_REMAP2_CONFIG1);
+		DDLOG64(MIPS_ADDR_REMAP2_CONFIG2);
+		DDLOG32(MIPS_ADDR_REMAP3_CONFIG1);
+		DDLOG64(MIPS_ADDR_REMAP3_CONFIG2);
+		DDLOG32(MIPS_ADDR_REMAP4_CONFIG1);
+		DDLOG64(MIPS_ADDR_REMAP4_CONFIG2);
+		DDLOG32(MIPS_ADDR_REMAP5_CONFIG1);
+		DDLOG64(MIPS_ADDR_REMAP5_CONFIG2);
+		DDLOG64(MIPS_WRAPPER_CONFIG);
+		DDLOG32(MIPS_EXCEPTION_STATUS);
+
+		RGXDumpMIPSState(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+	}
+#endif
+
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
+	{
+		eError = RGXDumpRISCVState(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+		PVR_RETURN_IF_ERROR(eError);
+	}
+#endif /* defined(SUPPORT_TRUSTED_DEVICE) && !defined(SUPPORT_SECURITY_VALIDATION) */
+
+#if defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX)
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, TFBC_VERSION))
+	{
+		DDLOGVAL32("TFBC_VERSION", RGX_GET_FEATURE_VALUE(psDevInfo, TFBC_VERSION));
+	}
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_LOSSY_37_PERCENT) ||
+	    RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_DELTA_CORRELATION))
+	{
+		DDLOGVAL32("TFBC_COMPRESSION_CONTROL", psDevInfo->psRGXFWIfSysInit->ui32TFBCCompressionControl);
+	}
+#endif
+
+	return eError;
+
+#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(SUPPORT_SECURITY_VALIDATION)
+_METASPError:
+	PVR_DUMPDEBUG_LOG("Dump Slave Port debug information");
+	_RGXDumpMetaSPExtraDebugInfo(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
+
+	return eError;
+#endif
+#endif /* defined(NO_HARDWARE) */
+}
+
 
 /*!
 *******************************************************************************
@@ -1805,21 +2765,40 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	PVRSRV_ERROR eError;
 	PVRSRV_DEVICE_NODE *psDeviceNode = psDevInfo->psDeviceNode;
 	PVRSRV_DEV_POWER_STATE  ePowerState;
+#if defined(SUPPORT_SOC_TIMER)
+	PVRSRV_DEVICE_CONFIG *psDevConfig = psDeviceNode->psDevConfig;
+#endif
 	IMG_BOOL                bRGXPoweredON;
 	RGXFWIF_TRACEBUF        *psRGXFWIfTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
 	const RGXFWIF_OSDATA    *psFwOsData = psDevInfo->psRGXFWIfFwOsData;
 	IMG_BOOL                bPwrLockAlreadyHeld;
+	IMG_BOOL                bPwrLockAcquired = IMG_TRUE;
+	IMG_UINT8               ui8FwOsCount;
 
 	bPwrLockAlreadyHeld = PVRSRVPwrLockIsLockedByMe(psDeviceNode);
 	if (!bPwrLockAlreadyHeld)
 	{
 		/* Only acquire the power-lock if not already held by the calling context */
-		eError = PVRSRVPowerLock(psDeviceNode);
-		if (eError != PVRSRV_OK)
+		eError = PVRSRVPowerTryLockWaitForTimeout(psDeviceNode);
+		if (eError == PVRSRV_ERROR_TIMEOUT)
 		{
+			bPwrLockAcquired = IMG_FALSE;
+#if defined(DEBUG)
+			PVR_DPF((PVR_DBG_WARNING, "Power lock owner: PID = %u at timestamp %" IMG_UINT64_FMTSPEC " (%s:%u)",
+		             psDeviceNode->uiPwrLockOwnerPID, psDeviceNode->sPowerLockOwner.ui64Timestamp,
+		             psDeviceNode->sPowerLockOwner.pszFile, psDeviceNode->sPowerLockOwner.ui32LineNum));
+#endif
 			PVR_DPF((PVR_DBG_ERROR, "%s: failed to acquire lock (%s)",
 					__func__,
 					PVRSRVGetErrorString(eError)));
+#if !defined(DEBUG_OVERRIDE_PWRLOCK)
+			/* Bail out if another thread has the power lock and may be
+			 * powering down the device. */
+			return;
+#endif
+		}
+		else if (eError != PVRSRV_OK)
+		{
 			return;
 		}
 	}
@@ -1835,7 +2814,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		goto Exit;
 	}
 
-	if (PVRSRV_VZ_MODE_IS(NATIVE) && (RGX_NUM_DRIVERS_SUPPORTED > 1))
+	if (PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode) && (RGX_NUM_DRIVERS_SUPPORTED > 1))
 	{
 		PVR_DUMPDEBUG_LOG("Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
 						   1, RGX_NUM_DRIVERS_SUPPORTED);
@@ -1856,11 +2835,20 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	PVR_DUMPDEBUG_LOG("RGX Device State: %s", PVRSRVGetDebugDevStateString(psDeviceNode->eDevState));
 	PVR_DUMPDEBUG_LOG("RGX Power State: %s", _RGXGetDebugDevPowerStateString(ePowerState));
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	PVR_DUMPDEBUG_LOG("RGX Health Status: %s, Reason: %s",PVRSRVGetDebugHealthStatusString(OSAtomicRead(&psDevInfo->psDeviceNode->eHealthStatus)),
+						PVRSRVGetDebugHealthReasonString(OSAtomicRead(&psDevInfo->psDeviceNode->eHealthReason)));
+
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		if (psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.bUpdated)
 		{
 			PVR_DUMP_FIRMWARE_INFO(psDevInfo->psRGXFWIfOsInit->sRGXCompChecks);
+			ui8FwOsCount = psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.sInitOptions.ui8OsCountSupport;
+			if (ui8FwOsCount != RGX_NUM_DRIVERS_SUPPORTED)
+			{
+				PVR_DUMPDEBUG_LOG("Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
+						RGX_NUM_DRIVERS_SUPPORTED, ui8FwOsCount);
+			}
 		}
 		else
 		{
@@ -1870,6 +2858,16 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	else
 	{
 		PVR_DUMP_FIRMWARE_INFO_HDR(psDevInfo->sFWInfoHeader);
+		if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode) && BITMASK_HAS(psDevInfo->sFWInfoHeader.ui32Flags, OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN))
+		{
+			ui8FwOsCount = (psDevInfo->sFWInfoHeader.ui32Flags & OPTIONS_NUM_DRIVERS_SUPPORTED_MASK) >> OPTIONS_NUM_DRIVERS_SUPPORTED_SHIFT;
+			ui8FwOsCount++;
+			if (ui8FwOsCount != RGX_NUM_DRIVERS_SUPPORTED)
+			{
+				PVR_DUMPDEBUG_LOG("Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
+						RGX_NUM_DRIVERS_SUPPORTED, ui8FwOsCount);
+			}
+		}
 	}
 
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TILE_REGION_PROTECTION))
@@ -1898,6 +2896,24 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		PVR_DUMPDEBUG_LOG("WGP: HW support - No");
 	}
 
+#if defined(SUPPORT_SOC_TIMER)
+	if (psDevConfig && psDevConfig->pfnSoCTimerRead)
+	{
+		RGX_DATA *psRGXData = (RGX_DATA*)psDevConfig->hDevData;
+		RGX_TIMING_INFORMATION *psRGXTimingInfo = psRGXData->psRGXTimingInfo;
+		IMG_UINT32 ui32Remainder;
+		IMG_UINT64 ui64CurrentSoCTime = psDevConfig->pfnSoCTimerRead(psDevConfig->hSysData);
+		IMG_UINT64 ui64CurrentSoCTimeInNS =
+			OSDivide64r64(ui64CurrentSoCTime * SECONDS_TO_MICROSECONDS, RGXFWIF_CONVERT_TO_KHZ(psRGXTimingInfo->ui32SOCClockSpeed), &ui32Remainder);
+		IMG_UINT64 ui64Seconds, ui64Nanoseconds;
+
+		RGXConvertOSTimestampToSAndNS(ui64CurrentSoCTimeInNS, &ui64Seconds, &ui64Nanoseconds);
+		PVR_DUMPDEBUG_LOG("SoC timer counter: 0x%" IMG_UINT64_FMTSPECx, ui64CurrentSoCTime);
+		PVR_DUMPDEBUG_LOG("SoC timer: %" IMG_UINT64_FMTSPEC ".%09" IMG_UINT64_FMTSPEC " seconds",
+				ui64Seconds, ui64Nanoseconds);
+	}
+#endif
+
 	RGXDumpRGXDebugSummary(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo, bRGXPoweredON);
 
 	/* Dump out the kernel CCB. */
@@ -1929,7 +2945,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Dump out the Workload estimation CCB. */
 		const RGXFWIF_CCB_CTL *psWorkEstCCBCtl = psDevInfo->psWorkEstFirmwareCCBCtl;
@@ -2012,7 +3028,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		/* Dump the IRQ info for threads or OS IDs */
 #if defined(RGX_FW_IRQ_OS_COUNTERS)
 		/* only Host has access to registers containing IRQ counters */
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 #endif
 		{
 			IMG_UINT32 ui32idx;
@@ -2037,7 +3053,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	}
 
 	/* Dump the FW Sys config flags on the Host */
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
 		IMG_CHAR sFwSysFlagsDescription[MAX_FW_DESCRIPTION_LENGTH];
@@ -2069,7 +3085,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 		PVR_DUMPDEBUG_LOG("FW OS config flags = 0x%08X (%s)", psFwOsData->ui32FwOsConfigFlags, sFwOsFlagsDescription);
 	}
 
-	if ((bRGXPoweredON) && !PVRSRV_VZ_MODE_IS(GUEST))
+	if ((bRGXPoweredON) && !PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = RGXDumpRGXRegisters(pfnDumpDebugPrintf, pvDumpDebugFile, psDevInfo);
 		if (eError != PVRSRV_OK)
@@ -2082,7 +3098,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	}
 	else
 	{
-		PVR_DUMPDEBUG_LOG(" (!) %s. No registers dumped", PVRSRV_VZ_MODE_IS(GUEST) ? "Guest Mode of operation" : "RGX power is down");
+		PVR_DUMPDEBUG_LOG(" (!) %s. No registers dumped", PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) ? "Guest Mode of operation" : "RGX power is down");
 	}
 
 	PVR_DUMPDEBUG_LOG("------[ RGX FW Trace Info ]------");
@@ -2168,7 +3184,7 @@ void RGXDebugRequestProcess(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 	PVR_DUMPDEBUG_LOG("------[ RGX Device ID:%d End ]------", psDevInfo->psDeviceNode->sDevId.ui32InternalID);
 
 Exit:
-	if (!bPwrLockAlreadyHeld)
+	if (!bPwrLockAlreadyHeld && bPwrLockAcquired)
 	{
 		PVRSRVPowerUnlock(psDeviceNode);
 	}
diff --git a/drivers/gpu/drm/img-rogue/rgxdebug_common.h b/drivers/gpu/drm/img-rogue/rgxdebug_common.h
index d8d5611a599d..f7707b87fa9f 100644
--- a/drivers/gpu/drm/img-rogue/rgxdebug_common.h
+++ b/drivers/gpu/drm/img-rogue/rgxdebug_common.h
@@ -72,7 +72,7 @@ extern const IMG_CHAR * const gapszMipsDirtyGlobalValidPTFlags[8];
 #define get_irq_cnt_val(ui32Dest, ui32idx, psRgxDevInfo) \
 	do { \
 		extern const IMG_UINT32 gaui32FwOsIrqCntRegAddr[RGXFW_MAX_NUM_OSIDS]; \
-		ui32Dest = PVRSRV_VZ_MODE_IS(GUEST) ? 0 : OSReadHWReg32((psRgxDevInfo)->pvRegsBaseKM, gaui32FwOsIrqCntRegAddr[ui32idx]); \
+		ui32Dest = PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psRgxDevInfo) ? 0 : OSReadHWReg32((psRgxDevInfo)->pvRegsBaseKM, gaui32FwOsIrqCntRegAddr[ui32idx]); \
 	} while (false)
 
 #define MSG_IRQ_CNT_TYPE "OS"
@@ -113,6 +113,8 @@ static inline void RGXDEBUG_PRINT_IRQ_COUNT(PVRSRV_RGXDEV_INFO* psRgxDevInfo)
 			        (psRgxDevInfo)->aui32SampleIRQCount[ui32idx]));
 		}
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psRgxDevInfo);
 #endif /* PVRSRV_NEED_PVR_DPF */
 }
 
@@ -155,6 +157,49 @@ void RGXDumpFirmwareTraceDecoded(PVRSRV_RGXDEV_INFO *psDevInfo,
 				RGXFWIF_TRACEBUF *psRGXFWIfTraceBufCtl,
 				IMG_UINT32 ui32TID);
 
+
+/* Helper macros to emit data */
+#define REG32_FMTSPEC   "%-30s: 0x%08X"
+#define REG64_FMTSPEC   "%-30s: 0x%016" IMG_UINT64_FMTSPECX
+#define DDLOG32(R)      PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, #R, OSReadHWReg32(pvRegsBaseKM, RGX_CR_##R));
+#define DDLOG64(R)      PVR_DUMPDEBUG_LOG(REG64_FMTSPEC, #R, OSReadHWReg64(pvRegsBaseKM, RGX_CR_##R));
+#define DDLOGUNCHECKED64(R)      PVR_DUMPDEBUG_LOG(REG64_FMTSPEC, #R, OSReadUncheckedHWReg64(pvRegsBaseKM, RGX_CR_##R));
+#define DDLOG32_DPX(R)  PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, #R, OSReadHWReg32(pvRegsBaseKM, DPX_CR_##R));
+#define DDLOG64_DPX(R)  PVR_DUMPDEBUG_LOG(REG64_FMTSPEC, #R, OSReadHWReg64(pvRegsBaseKM, DPX_CR_##R));
+#define DDLOGVAL32(S,V) PVR_DUMPDEBUG_LOG(REG32_FMTSPEC, S, V);
+
+PVRSRV_ERROR RGXDumpRISCVState(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+									  void *pvDumpDebugFile,
+									  PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpCoreRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpMulticoreRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpClkRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpMMURegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpDMRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpSLCRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
+void RGXDumpMiscRegisters(DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+								 void *pvDumpDebugFile,
+								 PVRSRV_RGXDEV_INFO *psDevInfo);
+
 /*!
 *******************************************************************************
 
@@ -376,13 +421,13 @@ void RGXDumpFaultAddressHostView(MMU_FAULT_DATA *psFaultData,
 					const IMG_CHAR* pszIndent);
 
 void RGXDumpFaultInfo(PVRSRV_RGXDEV_INFO *psDevInfo,
-                      DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
-                      void *pvDumpDebugFile,
-					  const RGX_HWRINFO *psHWRInfo,
-                      IMG_UINT32 ui32ReadIndex,
-                      IMG_DEV_VIRTADDR *psFaultDevVAddr,
-                      IMG_DEV_PHYADDR *psPCDevPAddr,
-                      bool bPMFault,
-                      IMG_UINT32 ui32PageSize);
+					DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
+					void *pvDumpDebugFile,
+					const RGX_HWRINFO *psHWRInfo,
+					IMG_UINT32 ui32ReadIndex,
+					IMG_DEV_VIRTADDR *psFaultDevVAddr,
+					IMG_DEV_PHYADDR *psPCDevPAddr,
+					bool bPMFault,
+					IMG_UINT32 ui32PageSize);
 
 #endif /* RGXDEBUG_COMMON_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxdevice.h b/drivers/gpu/drm/img-rogue/rgxdevice.h
index 8ae09cdf7694..95e0a0b53cca 100644
--- a/drivers/gpu/drm/img-rogue/rgxdevice.h
+++ b/drivers/gpu/drm/img-rogue/rgxdevice.h
@@ -69,7 +69,7 @@ typedef struct {
  *****************************************************************************/
 #define RGXKM_DEVICE_STATE_ZERO_FREELIST                          (0x1)  /*!< Zeroing the physical pages of reconstructed free lists */
 #define RGXKM_DEVICE_STATE_DISABLE_DW_LOGGING_EN                  (0x2)  /*!< Used to disable the Devices Watchdog logging */
-#define RGXKM_DEVICE_STATE_GPU_UNITS_POWER_CHANGE_EN              (0x4)  /*!< Used for validation to inject dust requests every TA/3D kick */
+#define RGXKM_DEVICE_STATE_GPU_UNITS_POWER_CHANGE_EN              (0x4)  /*!< Used for validation to inject power units state change every DM kick */
 #define RGXKM_DEVICE_STATE_CCB_GROW_EN                            (0x8)  /*!< Used to indicate CCB grow is permitted */
 #define RGXKM_DEVICE_STATE_ENABLE_SPU_UNITS_POWER_MASK_CHANGE_EN  (0x10) /*!< Used for validation to enable SPU power state mask change */
 #define RGXKM_DEVICE_STATE_MASK                                   (0x1F)
@@ -97,16 +97,18 @@ typedef struct {
 #define RGX_GPU_DVFS_TRANSITION_CALIBRATION_TIME_US  150000    /* Time required for a recalibration after a DVFS transition */
 #define RGX_GPU_DVFS_PERIODIC_CALIBRATION_TIME_US    10000000  /* Time before the next periodic calibration and correlation */
 
+
 /*!
  ******************************************************************************
  * Global flags for driver validation
  *****************************************************************************/
-#define RGX_VAL_FBDC_SIG_CHECK_NOERR_EN          (0U)     /*!< Not supported on Rogue cores */
-#define RGX_VAL_FBDC_SIG_CHECK_ERR_EN            (0U)     /*!< Not supported on Rogue cores */
+#define RGX_VAL_FBDC_SIG_CHECK_NOERR_EN           (0x2U)  /*!< Enable FBDC signature check. Signatures must match */
+#define RGX_VAL_FBDC_SIG_CHECK_ERR_EN             (0x4U)  /*!< Enable FBDC signature check. Signatures must not match */
+#define RGX_VAL_GPUSTATEPIN_EN                    (0x8U)  /*!< Enable GPU state pin check */
 #define RGX_VAL_WGP_SIG_CHECK_NOERR_EN           (0x10U)  /*!< Enable WGP signature check. Signatures must match */
 #define RGX_VAL_WGP_SIG_CHECK_ERR_EN             (0x20U)  /*!< Enable WGP signature check. Signatures must not match */
-#define RGX_VAL_TRP_SIG_CHECK_NOERR_EN           (0U)     /*!< Not supported on Rogue cores */
-#define RGX_VAL_TRP_SIG_CHECK_ERR_EN             (0U)     /*!< Not supported on Rogue cores */
+#define RGX_VAL_TRP_SIG_CHECK_NOERR_EN           (0x40U)  /*!< Enable TRP signature check. Signatures must match */
+#define RGX_VAL_TRP_SIG_CHECK_ERR_EN             (0x80U)  /*!< Enable TRP signature check. Signatures must not match */
 
 /*!
  ******************************************************************************
@@ -180,7 +182,7 @@ typedef struct _RGX_GPU_DVFS_TABLE_
 
 typedef struct _RGXFWIF_TEMP_GPU_UTIL_STATS_
 {
-	IMG_UINT64 aaaui64DMOSTmpCounters[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED][RGXFWIF_GPU_UTIL_STATE_NUM];
+	IMG_UINT64 aaaui64DMOSTmpCounters[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED][RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM];
 	IMG_UINT64 aaui64DMOSTmpLastWord[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 aaui64DMOSTmpLastState[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 aaui64DMOSTmpLastPeriod[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];
@@ -196,10 +198,9 @@ typedef struct _RGXFWIF_GPU_UTIL_STATS_
 	IMG_UINT64 ui64GpuStatIdle;       /* GPU idle statistic */
 	IMG_UINT64 ui64GpuStatCumulative; /* Sum of active/blocked/idle stats */
 
-	IMG_UINT64 aaui64DMOSStatActive[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];     /* Per-DM per-OS active statistic */
-	IMG_UINT64 aaui64DMOSStatBlocked[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];    /* Per-DM per-OS blocked statistic */
-	IMG_UINT64 aaui64DMOSStatIdle[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];       /* Per-DM per-OS idle statistic */
-	IMG_UINT64 aaui64DMOSStatCumulative[RGXFWIF_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED]; /* Per-DM per-OS sum of active/blocked/idle stats */
+	IMG_UINT64 aaui64DMOSStatInactive[RGXFWIF_GPU_UTIL_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];   /* Per-DM per-OS sum of idle and blocked stats */
+	IMG_UINT64 aaui64DMOSStatActive[RGXFWIF_GPU_UTIL_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED];     /* Per-DM per-OS active statistic */
+	IMG_UINT64 aaui64DMOSStatCumulative[RGXFWIF_GPU_UTIL_DM_MAX][RGX_NUM_DRIVERS_SUPPORTED]; /* Per-DM per-OS sum of active/blocked/idle stats */
 
 	IMG_UINT64 ui64TimeStamp;         /* Timestamp of the most recent sample of the GPU stats */
 
@@ -217,12 +218,6 @@ typedef struct _RGX_REG_CONFIG_
 
 typedef struct _PVRSRV_STUB_PBDESC_ PVRSRV_STUB_PBDESC;
 
-typedef struct
-{
-	IMG_UINT32			ui32DustCount1;
-	IMG_UINT32			ui32DustCount2;
-	IMG_BOOL			bToggle;
-} RGX_DUST_STATE;
 
 typedef struct _PVRSRV_DEVICE_FEATURE_CONFIG_
 {
@@ -234,7 +229,10 @@ typedef struct _PVRSRV_DEVICE_FEATURE_CONFIG_
 	IMG_UINT32 ui32C;
 	IMG_UINT32 ui32FeaturesValues[RGX_FEATURE_WITH_VALUES_MAX_IDX];
 	IMG_UINT32 ui32MAXDMCount;
-	IMG_UINT32 ui32MAXDustCount;
+	IMG_UINT32 ui32MAXPowUnitCount;
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	IMG_UINT32 ui32MAXRACCount;
+#endif
 	IMG_UINT32 ui32SLCSizeInBytes;
 	IMG_PCHAR  pszBVNCString;
 }PVRSRV_DEVICE_FEATURE_CONFIG;
@@ -308,6 +306,15 @@ typedef union _RGX_WORKLOAD_
 		IMG_UINT32				ui32Characteristic1;
 		IMG_UINT32				ui32Characteristic2;
 	} sTransfer;
+
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	struct
+	{
+		IMG_UINT32				ui32DispatchSize;
+		IMG_UINT32				ui32AccStructSize;
+	} sRay;
+#endif
+
 } RGX_WORKLOAD;
 
 /*!
@@ -358,6 +365,13 @@ typedef struct _WORKEST_HOST_DATA_
 		{
 			WORKLOAD_MATCHING_DATA	sDataTDM;	/*!< matching data for TDM-TQ commands */
 		} sTransfer;
+
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+		struct
+		{
+			WORKLOAD_MATCHING_DATA	sDataRDM;	/*!< matching data for RDM commands */
+		} sRay;
+#endif
 	} uWorkloadMatchingData;
 
 	/*
@@ -387,6 +401,11 @@ typedef struct _WORKEST_RETURN_DATA_
 #endif
 
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+#define RGX_MAX_NUM_MMU_PAGE_SIZE_RANGES    4
+#endif
+
+
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 typedef struct
 {
@@ -439,6 +458,11 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	/* Kernel mode linear address of device registers */
 	void __iomem			*pvRegsBaseKM;
 
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	/* Kernel mode linear address of device registers */
+	void __iomem			*pvSecureRegsBaseKM;
+#endif
+
 	IMG_HANDLE				hRegMapping;
 
 	/* System physical address of device registers */
@@ -531,8 +555,13 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	DEVMEM_MEMDESC			*psRGXFWSig3DChecksMemDesc;
 	IMG_UINT32				ui32Sig3DChecksSize;
 
-	DEVMEM_MEMDESC			*psRGXFWSigTDM2DChecksMemDesc;
-	IMG_UINT32				ui32SigTDM2DChecksSize;
+	DEVMEM_MEMDESC			*psRGXFWSigTDMChecksMemDesc;
+	IMG_UINT32				ui32SigTDMChecksSize;
+
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	DEVMEM_MEMDESC			*psRGXFWSigRDMChecksMemDesc;
+	IMG_UINT32				ui32SigRDMChecksSize;
+#endif
 
 	IMG_BOOL				bDumpedKCCBCtlAlready;
 
@@ -564,8 +593,8 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	IMG_UINT32				ui32ClockSource;
 	IMG_UINT32				ui32LastClockSource;
 
-	DEVMEM_MEMDESC			*psRGXFWIfGpuUtilFWCbCtlMemDesc;
-	RGXFWIF_GPU_UTIL_FWCB	*psRGXFWIfGpuUtilFWCb;
+	DEVMEM_MEMDESC			*psRGXFWIfGpuUtilFWCtlMemDesc;
+	RGXFWIF_GPU_UTIL_FW     *psRGXFWIfGpuUtilFW;
 
 	DEVMEM_MEMDESC			*psRGXFWIfHWPerfBufMemDesc;
 	IMG_BYTE				*psRGXFWIfHWPerfBuf;
@@ -738,7 +767,7 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	POS_LOCK				hGPUUtilLock;
 
 	/* Register configuration */
-	RGX_REG_CONFIG			sRegCongfig;
+	RGX_REG_CONFIG			sRegConfig;
 
 	IMG_BOOL				bRGXPowered;
 	DLLIST_NODE				sMemoryContextList;
@@ -775,10 +804,10 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	POS_LOCK				hNMILock; /*!< Lock to protect NMI operations */
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	IMG_UINT32				ui32ValidationFlags;	/*!< Validation flags for host driver */
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	IMG_UINT32				ui32AvailablePowUnitsMask;
+	IMG_UINT32				ui32AvailableRACMask;
 #endif
-	RGX_DUST_STATE			sDustReqState;
 
 	RGX_LAYER_PARAMS		sLayerParams;
 
@@ -802,31 +831,16 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	IMG_UINT32				ui32FirmwareGcovSize;
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER)
-	struct
-	{
-		IMG_UINT64 ui64timerGray;
-		IMG_UINT64 ui64timerBinary;
-		IMG_UINT64 *pui64uscTimers;
-	} sRGXTimerValues;
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	/* Value to store for each page size range config register in MMU4 */
+	IMG_UINT64				aui64MMUPageSizeRangeValue[RGX_MAX_NUM_MMU_PAGE_SIZE_RANGES];
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	struct
-	{
-		IMG_UINT64 ui64RegVal;
-		struct completion sRegComp;
-	} sFwRegs;
-#endif
+
 
 	IMG_HANDLE				hTQCLISharedMem;		/*!< TQ Client Shared Mem PMR */
 	IMG_HANDLE				hTQUSCSharedMem;		/*!< TQ USC Shared Mem PMR */
 
-#if defined(SUPPORT_VALIDATION)
-	IMG_UINT32				ui32TestSLRInterval; /* Don't enqueue an update sync checkpoint every nth kick */
-	IMG_UINT32				ui32TestSLRCount;    /* (used to test SLR operation) */
-	IMG_UINT32				ui32SLRSkipFWAddr;
-#endif
 
 #if defined(SUPPORT_SECURITY_VALIDATION)
 	DEVMEM_MEMDESC			*psRGXFWIfSecureBufMemDesc;
@@ -857,10 +871,6 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 	IMG_UINT32				ui32HostSafetyEventMask;/*!< mask of the safety events handled by the driver */
 
 	RGX_CONTEXT_RESET_REASON	eLastDeviceError;	/*!< device error reported to client */
-#if defined(SUPPORT_VALIDATION)
-	IMG_UINT32 ui32ECCRAMErrInjModule;
-	IMG_UINT32 ui32ECCRAMErrInjInterval;
-#endif
 
 #if defined(SUPPORT_SECURE_ALLOC_KM)
 	PMR						*psGenHeapSecMem;		/*!< An allocation of secure memory mapped to
@@ -869,6 +879,10 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 													  various purposes. See rgx_fwif_km.h for all use cases. */
 #endif
 
+#if defined(SUPPORT_SECURE_CONTEXT_SWITCH)
+	DEVMEM_MEMDESC			*psRGXFWScratchBufMemDesc;
+#endif
+
 	RGX_FWT_LOGTYPE			eDebugDumpFWTLogType;
 
 	RGX_FW_INFO_HEADER      sFWInfoHeader;
@@ -877,6 +891,9 @@ typedef struct _PVRSRV_RGXDEV_INFO_
 													  setting for those cores which support
 													  this feature. */
 #endif
+	RGXFWIF_GPU_UTIL_STATS	sGpuUtilStats;          /*!< GPU usage statistics */
+	POS_LOCK				hGpuUtilStatsLock;
+
 } PVRSRV_RGXDEV_INFO;
 
 
@@ -886,6 +903,9 @@ typedef struct _RGX_TIMING_INFORMATION_
 	/*! GPU default core clock speed in Hz */
 	IMG_UINT32			ui32CoreClockSpeed;
 
+	/*! Default SOC clock speed in Hz */
+	IMG_UINT32			ui32SOCClockSpeed;
+
 	/*! Active Power Management: GPU actively requests the host driver to be powered off */
 	IMG_BOOL			bEnableActivePM;
 
@@ -903,6 +923,12 @@ typedef struct _RGX_DATA_
 	RGX_TIMING_INFORMATION	*psRGXTimingInfo;
 } RGX_DATA;
 
+typedef enum _RGX_QUERY_TIMESTAMP_TYPE_
+{
+	RGX_QUERY_HOST_TIMESTAMP,
+	RGX_QUERY_DEVICE_TIMESTAMP,
+} RGX_QUERY_TIMESTAMP_TYPE;
+
 
 /*
 	RGX PDUMP register bank name (prefix)
diff --git a/drivers/gpu/drm/img-rogue/rgxfwcmnctx.c b/drivers/gpu/drm/img-rogue/rgxfwcmnctx.c
index dc39be0d3c19..d340307d542d 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwcmnctx.c
+++ b/drivers/gpu/drm/img-rogue/rgxfwcmnctx.c
@@ -48,6 +48,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rogue_trace_events.h"
 #endif
 
+#if defined(__linux__) && defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+#include "linux/cred.h"
+#include "linux/pid.h"
+#endif
 /*
  * Maximum length of time a DM can run for before the DM will be marked
  * as out-of-time. CDM has an increased value due to longer running kernels.
@@ -63,6 +67,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGXFWIF_MAX_WORKLOAD_DEADLINE_MS     (40000)
 #define RGXFWIF_MAX_CDM_WORKLOAD_DEADLINE_MS (600000)
 #endif
+#define RGXFWIF_MAX_RDM_WORKLOAD_DEADLINE_MS (36000000)
 
 struct _RGX_SERVER_COMMON_CONTEXT_ {
 	PVRSRV_RGXDEV_INFO *psDevInfo;
@@ -84,6 +89,32 @@ struct _RGX_SERVER_COMMON_CONTEXT_ {
 	RGX_CCB_REQUESTOR_TYPE eRequestor;
 };
 
+#if defined(__linux__) && defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+static IMG_UINT32 _GetUID(IMG_PID pid)
+{
+	struct task_struct *psTask;
+	struct pid *psPid;
+
+	psPid = find_get_pid((pid_t)pid);
+	if (!psPid)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to lookup PID %u.",
+		                        __func__, pid));
+		return 0;
+	}
+
+	psTask = get_pid_task(psPid, PIDTYPE_PID);
+	if (!psTask)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to get pid task for PID %u.",
+		                        __func__, pid));
+	}
+	put_pid(psPid);
+
+	return psTask ? from_kuid(&init_user_ns, psTask->cred->uid) : 0;
+}
+#endif
+
 /*************************************************************************/ /*!
 @Function       _CheckPriority
 @Description    Check if priority is allowed for requestor type
@@ -245,6 +276,7 @@ PVRSRV_ERROR FWCommonContextAllocate(CONNECTION_DATA *psConnection,
 						  0, RFW_FWADDR_FLAG_NONE);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXSetFirmwareAddress:2", fail_cccbctrlfwaddr);
 
+#if defined(RGX_FEATURE_META_DMA_BIT_MASK)
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_DMA))
 	{
 		RGXSetMetaDMAAddress(&sFWCommonContext.sCCBMetaDMAAddr,
@@ -252,6 +284,7 @@ PVRSRV_ERROR FWCommonContextAllocate(CONNECTION_DATA *psConnection,
 							 &sFWCommonContext.psCCB,
 							 0);
 	}
+#endif
 
 	/* Set the memory context device address */
 	psServerCommonContext->psFWMemContextMemDesc = psFWMemContextMemDesc;
@@ -285,16 +318,29 @@ PVRSRV_ERROR FWCommonContextAllocate(CONNECTION_DATA *psConnection,
 
 	sFWCommonContext.i32Priority = i32Priority;
 	sFWCommonContext.ui32PrioritySeqNum = 0;
-	sFWCommonContext.ui32MaxDeadlineMS = MIN(ui32MaxDeadlineMS,
-											   (eDM == RGXFWIF_DM_CDM ?
-												RGXFWIF_MAX_CDM_WORKLOAD_DEADLINE_MS :
-												RGXFWIF_MAX_WORKLOAD_DEADLINE_MS));
+
+	if (eDM == RGXFWIF_DM_CDM)
+	{
+		sFWCommonContext.ui32MaxDeadlineMS = MIN(ui32MaxDeadlineMS, RGXFWIF_MAX_CDM_WORKLOAD_DEADLINE_MS);
+	}
+	else if (eDM == RGXFWIF_DM_RAY)
+	{
+		sFWCommonContext.ui32MaxDeadlineMS = MIN(ui32MaxDeadlineMS, RGXFWIF_MAX_RDM_WORKLOAD_DEADLINE_MS);
+	}
+	else
+	{
+		sFWCommonContext.ui32MaxDeadlineMS = MIN(ui32MaxDeadlineMS, RGXFWIF_MAX_WORKLOAD_DEADLINE_MS);
+	}
+
 	sFWCommonContext.ui64RobustnessAddress = ui64RobustnessAddress;
 
 	/* Store a references to Server Common Context and PID for notifications back from the FW. */
 	sFWCommonContext.ui32ServerCommonContextID = psServerCommonContext->ui32ContextID;
 	sFWCommonContext.ui32PID                   = OSGetCurrentClientProcessIDKM();
-	OSStringLCopy(sFWCommonContext.szProcName, psConnection->pszProcName, RGXFW_PROCESS_NAME_LEN);
+#if defined(__linux__) && defined(PVRSRV_ANDROID_TRACE_GPU_WORK_PERIOD)
+	sFWCommonContext.ui32UID                   = _GetUID(sFWCommonContext.ui32PID);
+#endif
+	OSStringSafeCopy(sFWCommonContext.szProcName, psConnection->pszProcName, RGXFW_PROCESS_NAME_LEN);
 
 	/* Set the firmware GPU context state buffer */
 	psServerCommonContext->psContextStateMemDesc = psContextStateMemDesc;
@@ -547,6 +593,8 @@ PVRSRV_ERROR ContextSetPriority(RGX_SERVER_COMMON_CONTEXT *psContext,
 	PVRSRV_ERROR			eError;
 	RGX_CLIENT_CCB *psClientCCB = FWCommonContextGetClientCCB(psContext);
 
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	eError = _CheckPriority(psDevInfo, i32Priority, psContext->eRequestor);
 	PVR_LOG_GOTO_IF_ERROR(eError, "_CheckPriority", fail_checkpriority);
 
@@ -611,7 +659,7 @@ PVRSRV_ERROR ContextSetPriority(RGX_SERVER_COMMON_CONTEXT *psContext,
 	sPriorityCmd.uCmdData.sCmdKickData.ui32WorkEstCmdHeaderOffset = 0;
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 									eDM,
@@ -622,7 +670,7 @@ PVRSRV_ERROR ContextSetPriority(RGX_SERVER_COMMON_CONTEXT *psContext,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (eError != PVRSRV_OK)
 	{
diff --git a/drivers/gpu/drm/img-rogue/rgxfwdbg.c b/drivers/gpu/drm/img-rogue/rgxfwdbg.c
index 9a6add28b218..2271adf3ea9c 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwdbg.c
+++ b/drivers/gpu/drm/img-rogue/rgxfwdbg.c
@@ -66,13 +66,13 @@ PVRSRVRGXFWDebugQueryFWLogKM(
 	PVRSRV_RGXDEV_INFO *psDevInfo;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	if (!psDeviceNode || !pui32RGXFWLogType)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
 	psDevInfo = psDeviceNode->pvDevice;
 
 	if (!psDevInfo || !psDevInfo->psRGXFWIfTraceBufCtl)
@@ -95,14 +95,21 @@ PVRSRVRGXFWDebugSetFWLogKM(
 	RGXFWIF_KCCB_CMD sLogTypeUpdateCmd;
 	PVRSRV_DEV_POWER_STATE ePowerState;
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
+	PVRSRV_RGXDEV_INFO* psDevInfo;
 	IMG_UINT32 ui32OldRGXFWLogTpe;
 	IMG_UINT32 ui32kCCBCommandSlot;
 	IMG_BOOL bWaitForFwUpdate = IMG_FALSE;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
 
+	if (!psDeviceNode)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
+
+	psDevInfo = psDeviceNode->pvDevice;
 	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfTraceBufCtl->ui32LogType, INVALIDATE);
 	ui32OldRGXFWLogTpe = psDevInfo->psRGXFWIfTraceBufCtl->ui32LogType;
 
@@ -212,17 +219,19 @@ PVRSRVRGXFWDebugMapGuestHeapKM(
 	IMG_UINT32 ui32DriverID,
 	IMG_UINT64 ui64GuestHeapBase)
 {
+#if defined(ENABLE_PVRDEBUG_PRIVILEGED_CMDS)
 	PVRSRV_ERROR eError;
 	IMG_UINT32 ui32DeviceID = psDeviceNode->sDevId.ui32InternalID;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	if (PVRSRV_VZ_MODE_IS(HOST))
+	if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode))
 	{
 		if (ui64GuestHeapBase == IMG_UINT64_MAX)
 		{
 			/* unmap heap and set DriverID to offline */
 			eError = PvzServerUnmapDevPhysHeap(ui32DriverID, ui32DeviceID);
+			PVR_LOG_RETURN_IF_ERROR(eError, "PvzServerUnmapDevPhysHeap()");
 			eError = PvzServerOnVmOffline(ui32DriverID, ui32DeviceID);
 		}
 		else
@@ -231,6 +240,7 @@ PVRSRVRGXFWDebugMapGuestHeapKM(
 			if (!IsVmOnline(ui32DriverID, ui32DeviceID))
 			{
 				eError = PvzServerOnVmOnline(ui32DriverID, ui32DeviceID);
+				PVR_LOG_RETURN_IF_ERROR(eError, "PvzServerOnVmOnline()");
 			}
 
 			eError = PvzServerMapDevPhysHeap(ui32DriverID, ui32DeviceID, RGX_FIRMWARE_RAW_HEAP_SIZE, ui64GuestHeapBase);
@@ -243,52 +253,60 @@ PVRSRVRGXFWDebugMapGuestHeapKM(
 	}
 
 	return eError;
+#else
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(ui32DriverID);
+	PVR_UNREFERENCED_PARAMETER(ui64GuestHeapBase);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
 }
 
 PVRSRV_ERROR
 PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
-	IMG_UINT32  ui32DriverTimeSliceInterval)
+	IMG_UINT32  ui32TSIntervalMs)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
-	RGXFWIF_KCCB_CMD sVzTimeSliceIntervalCmd = { 0 };
+	RGXFWIF_KCCB_CMD sVzTSIntervalCmd = { 0 };
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	if (psDevInfo->psRGXFWIfRuntimeCfg == NULL)
 	{
 		return PVRSRV_ERROR_NOT_INITIALISED;
 	}
 
-	sVzTimeSliceIntervalCmd.eCmdType = RGXFWIF_KCCB_CMD_VZ_DRV_TIME_SLICE_INTERVAL;
-	psDevInfo->psRGXFWIfRuntimeCfg->ui32DriverTimeSliceInterval = ui32DriverTimeSliceInterval;
-	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->ui32DriverTimeSliceInterval);
+	sVzTSIntervalCmd.eCmdType = RGXFWIF_KCCB_CMD_VZ_DRV_TIME_SLICE_INTERVAL;
+	psDevInfo->psRGXFWIfRuntimeCfg->ui32TSIntervalMs = ui32TSIntervalMs;
+	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->ui32TSIntervalMs);
 
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "Updating the timeslice interval inside RGXFWIfRuntimeCfg");
 	DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfRuntimeCfgMemDesc,
-							  offsetof(RGXFWIF_RUNTIME_CFG, ui32DriverTimeSliceInterval),
-							  ui32DriverTimeSliceInterval,
+							  offsetof(RGXFWIF_RUNTIME_CFG, ui32TSIntervalMs),
+							  ui32TSIntervalMs,
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 									RGXFWIF_DM_GP,
-									&sVzTimeSliceIntervalCmd,
+									&sVzTSIntervalCmd,
 									PDUMP_FLAGS_CONTINUOUS);
 		if (eError != PVRSRV_ERROR_RETRY)
 		{
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -298,18 +316,18 @@ PVRSRVRGXFWDebugSetDriverTimeSliceKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_UINT32  ui32DriverID,
-	IMG_UINT32  ui32DriverTimeSlice)
+	IMG_UINT32  ui32TSPercentage)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	RGXFWIF_KCCB_CMD sVzTimeSliceCmd = { 0 };
 	PVRSRV_RGXDEV_INFO *psDevInfo;
 	RGXFWIF_RUNTIME_CFG *psRuntimeCfg;
-	IMG_INT32 ui32TimeSliceMax = 0;
+	IMG_INT32 ui32TSPercentageMax = 0;
 	IMG_UINT32 ui32DriverIDLoop;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	if (ui32DriverID >= RGX_NUM_DRIVERS_SUPPORTED)
 	{
@@ -327,37 +345,40 @@ PVRSRVRGXFWDebugSetDriverTimeSliceKM(
 	 * Use '0' to disable time slice based CSW for the driver.
 	 */
 	 /* Check if the sum exceeds PVRSRV_VZ_TIME_SLICE_MAX */
-	if (ui32DriverTimeSlice)
+	if (ui32TSPercentage)
 	{
+		PVR_RETURN_IF_FALSE(ui32TSPercentage <= PVRSRV_VZ_TIME_SLICE_MAX, PVRSRV_ERROR_INVALID_PARAMS);
+
 		FOREACH_SUPPORTED_DRIVER(ui32DriverIDLoop)
 		{
 			if (ui32DriverID != ui32DriverIDLoop)
 			{
-				ui32TimeSliceMax += psRuntimeCfg->aui32DriverTimeSlice[ui32DriverIDLoop];
+				ui32TSPercentageMax += psRuntimeCfg->aui32TSPercentage[ui32DriverIDLoop];
 			}
 			else
 			{
-				ui32TimeSliceMax += ui32DriverTimeSlice;
+				ui32TSPercentageMax += ui32TSPercentage;
 			}
 
-			PVR_RETURN_IF_FALSE(ui32TimeSliceMax <= PVRSRV_VZ_TIME_SLICE_MAX, PVRSRV_ERROR_INVALID_PARAMS);
+			PVR_RETURN_IF_FALSE(ui32TSPercentageMax <= PVRSRV_VZ_TIME_SLICE_MAX, PVRSRV_ERROR_INVALID_PARAMS);
 		}
 	}
 
 	sVzTimeSliceCmd.eCmdType = RGXFWIF_KCCB_CMD_VZ_DRV_TIME_SLICE;
-	psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverTimeSlice[ui32DriverID] = ui32DriverTimeSlice;
-	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverTimeSlice[ui32DriverID]);
+	psDevInfo->psRGXFWIfRuntimeCfg->aui32TSPercentage[ui32DriverID] = ui32TSPercentage;
+	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->aui32TSPercentage[ui32DriverID]);
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfRuntimeCfg->aui32TSPercentage[ui32DriverID], FLUSH);
 
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "Updating the timeslice of DriverID %u inside RGXFWIfRuntimeCfg", ui32DriverID);
 	DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfRuntimeCfgMemDesc,
-							  offsetof(RGXFWIF_RUNTIME_CFG, aui32DriverTimeSlice) + (ui32DriverID * sizeof(ui32DriverTimeSlice)),
-							  ui32DriverTimeSlice,
+							  offsetof(RGXFWIF_RUNTIME_CFG, aui32TSPercentage) + (ui32DriverID * sizeof(ui32TSPercentage)),
+							  ui32TSPercentage,
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 									RGXFWIF_DM_GP,
@@ -368,7 +389,7 @@ PVRSRVRGXFWDebugSetDriverTimeSliceKM(
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -378,7 +399,7 @@ PVRSRVRGXFWDebugSetDriverPriorityKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_UINT32  ui32DriverID,
-	IMG_UINT32  ui32DriverPriority)
+	IMG_INT32   i32DriverPriority)
 {
 	PVRSRV_ERROR eError;
 	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
@@ -386,7 +407,7 @@ PVRSRVRGXFWDebugSetDriverPriorityKM(
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	if (psDevInfo->psRGXFWIfRuntimeCfg == NULL)
 	{
@@ -398,21 +419,26 @@ PVRSRVRGXFWDebugSetDriverPriorityKM(
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	if ((i32DriverPriority & ~RGXFW_VZ_PRIORITY_MASK) != 0)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
 	sVzPriorityCmd.eCmdType = RGXFWIF_KCCB_CMD_VZ_DRV_ARRAY_CHANGE;
-	psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverPriority[ui32DriverID] = ui32DriverPriority;
-	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverPriority[ui32DriverID]);
-	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfRuntimeCfg->aui32DriverPriority[ui32DriverID], FLUSH);
+	psDevInfo->psRGXFWIfRuntimeCfg->ai32DriverPriority[ui32DriverID] = i32DriverPriority;
+	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->ai32DriverPriority[ui32DriverID]);
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfRuntimeCfg->ai32DriverPriority[ui32DriverID], FLUSH);
 
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "Updating the priority of DriverID %u inside RGXFWIfRuntimeCfg", ui32DriverID);
 	DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfRuntimeCfgMemDesc,
-							  offsetof(RGXFWIF_RUNTIME_CFG, aui32DriverPriority) + (ui32DriverID * sizeof(ui32DriverPriority)),
-							  ui32DriverPriority,
+							  offsetof(RGXFWIF_RUNTIME_CFG, ai32DriverPriority) + (ui32DriverID * sizeof(i32DriverPriority)),
+							  i32DriverPriority,
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 									RGXFWIF_DM_GP,
@@ -423,7 +449,7 @@ PVRSRVRGXFWDebugSetDriverPriorityKM(
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -441,7 +467,7 @@ PVRSRVRGXFWDebugSetDriverIsolationGroupKM(
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	if (psDevInfo->psRGXFWIfRuntimeCfg == NULL)
 	{
@@ -467,7 +493,7 @@ PVRSRVRGXFWDebugSetDriverIsolationGroupKM(
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 				RGXFWIF_DM_GP,
@@ -478,7 +504,7 @@ PVRSRVRGXFWDebugSetDriverIsolationGroupKM(
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -490,12 +516,26 @@ PVRSRVRGXFWDebugSetOSNewOnlineStateKM(
 	IMG_UINT32  ui32DriverID,
 	IMG_UINT32  ui32OSNewState)
 {
+#if defined(ENABLE_PVRDEBUG_PRIVILEGED_CMDS)
 	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
 	RGXFWIF_OS_STATE_CHANGE eState;
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
+	if (ui32DriverID >= RGX_NUM_DRIVERS_SUPPORTED)
+	{
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
 	eState = (ui32OSNewState) ? (RGXFWIF_OS_ONLINE) : (RGXFWIF_OS_OFFLINE);
 	return RGXFWSetFwOsState(psDevInfo, ui32DriverID, eState);
+#else
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(ui32DriverID);
+	PVR_UNREFERENCED_PARAMETER(ui32OSNewState);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
 }
 
 PVRSRV_ERROR
@@ -560,19 +600,27 @@ PVRSRVRGXFWDebugInjectFaultKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode)
 {
+#if defined(ENABLE_PVRDEBUG_PRIVILEGED_CMDS)
 	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
 	return RGXFWInjectFault(psDevInfo);
+#else
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
 }
 
 PVRSRV_ERROR
-PVRSRVRGXFWDebugSuspendDeviceKM(
+PVRSRVRGXFWDebugPowerOffKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
+#if defined(ENABLE_PVRDEBUG_PRIVILEGED_CMDS)
 #if defined(SUPPORT_AUTOVZ)
 	psDeviceNode->bAutoVzFwIsUp = IMG_FALSE;
 #endif
@@ -580,18 +628,29 @@ PVRSRVRGXFWDebugSuspendDeviceKM(
 	return PVRSRVSetDeviceSystemPowerState(psDeviceNode,
 					       PVRSRV_SYS_POWER_STATE_OFF,
 					       PVRSRV_POWER_FLAGS_NONE);
+#else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
 }
 
 PVRSRV_ERROR
-PVRSRVRGXFWDebugResumeDeviceKM(
+PVRSRVRGXFWDebugPowerOnKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode)
 {
+#if defined(ENABLE_PVRDEBUG_PRIVILEGED_CMDS)
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
 	return PVRSRVSetDeviceSystemPowerState(psDeviceNode,
 					       PVRSRV_SYS_POWER_STATE_ON,
 					       PVRSRV_POWER_FLAGS_NONE);
+#else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+#endif
 }
 
 PVRSRV_ERROR
@@ -605,4 +664,3 @@ PVRSRVRGXFWDebugSetVzConnectionCooldownPeriodInSecKM(
 
 	return RGXFWSetVzConnectionCooldownPeriod(psDevInfo, ui32VzConnectionCooldownPeriodInSec);
 }
-
diff --git a/drivers/gpu/drm/img-rogue/rgxfwdbg.h b/drivers/gpu/drm/img-rogue/rgxfwdbg.h
index eb0eb0bf1c0c..59c48ed5f4f8 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwdbg.h
+++ b/drivers/gpu/drm/img-rogue/rgxfwdbg.h
@@ -84,20 +84,20 @@ PVRSRVRGXFWDebugSetDriverTimeSliceKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_UINT32  ui32DriverID,
-	IMG_UINT32  ui32DriverTimeSlice);
+	IMG_UINT32  ui32TSPercentage);
 
 PVRSRV_ERROR
 PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
-	IMG_UINT32  ui32DriverTimeSliceInterval);
+	IMG_UINT32  ui32TSIntervalMs);
 
 PVRSRV_ERROR
 PVRSRVRGXFWDebugSetDriverPriorityKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_UINT32  ui32DriverID,
-	IMG_UINT32  ui32DriverPriority);
+	IMG_INT32   i32DriverPriority);
 
 PVRSRV_ERROR
 PVRSRVRGXFWDebugSetDriverIsolationGroupKM(
@@ -143,12 +143,12 @@ PVRSRVRGXFWDebugInjectFaultKM(
 	PVRSRV_DEVICE_NODE *psDeviceNode);
 
 PVRSRV_ERROR
-PVRSRVRGXFWDebugSuspendDeviceKM(
+PVRSRVRGXFWDebugPowerOffKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode);
 
 PVRSRV_ERROR
-PVRSRVRGXFWDebugResumeDeviceKM(
+PVRSRVRGXFWDebugPowerOnKM(
 	CONNECTION_DATA *psConnection,
 	PVRSRV_DEVICE_NODE *psDeviceNode);
 
diff --git a/drivers/gpu/drm/img-rogue/rgxfwimageutils.c b/drivers/gpu/drm/img-rogue/rgxfwimageutils.c
index 24976382e167..afc69f7228f8 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwimageutils.c
+++ b/drivers/gpu/drm/img-rogue/rgxfwimageutils.c
@@ -48,10 +48,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * Any new code should be built on top of the existing abstraction layer,
  * which should be extended when necessary. */
 #include "rgxfwimageutils.h"
-#include "rgxfwutils.h"
-#include "pvrsrv.h"
 #include "pvrversion.h"
 
+#if defined(CONFIG_ARM64) && defined(__linux__) && defined(SUPPORT_CPUCACHED_FWMEMCTX)
+#include "rgxfwutils.h"
+#endif
 
 /************************************************************************
 * FW layout information
@@ -253,11 +254,13 @@ static void RGXFWConfigureSegMMU(const void       *hPrivate,
 	/* Configure Segment MMU */
 	RGXCommentLog(hPrivate, "********** FW configure Segment MMU **********");
 
+#if defined(RGX_FEATURE_SLC_VIVT_BIT_MASK)
 	if (RGX_DEVICE_HAS_FEATURE(hPrivate, SLC_VIVT))
 	{
 		ui64SegOutAddrTop = RGXFW_SEGMMU_OUTADDR_TOP_VIVT_SLC_CACHED(MMU_CONTEXT_MAPPING_FWPRIV);
 	}
 	else
+#endif
 	{
 		ui64SegOutAddrTop = RGXFW_SEGMMU_OUTADDR_TOP_SLC(MMU_CONTEXT_MAPPING_FWPRIV, RGXFW_SEGMMU_META_BIFDM_ID);
 	}
@@ -509,7 +512,9 @@ PVRSRV_ERROR ProcessLDRCommandStream(const void *hPrivate,
 					           pvWriteAddr,
 					           psL2Block->aui32BlockData,
 					           ui32DataSize);
+#if defined(CONFIG_ARM64) && defined(__linux__) && defined(SUPPORT_CPUCACHED_FWMEMCTX)
 					RGXFwSharedMemCacheOpExec(pvWriteAddr, ui32DataSize, PVRSRV_CACHE_OP_FLUSH);
+#endif
 				}
 
 				break;
@@ -560,7 +565,9 @@ PVRSRV_ERROR ProcessLDRCommandStream(const void *hPrivate,
 				if (pvWriteAddr)
 				{
 					RGXMemSet(hPrivate, pvWriteAddr, 0, ui32ByteCount);
+#if defined(CONFIG_ARM64) && defined(__linux__) && defined(SUPPORT_CPUCACHED_FWMEMCTX)
 					RGXFwSharedMemCacheOpExec(pvWriteAddr, ui32ByteCount, PVRSRV_CACHE_OP_FLUSH);
+#endif
 				}
 
 				break;
@@ -719,7 +726,9 @@ PVRSRV_ERROR ProcessELFCommandStream(const void *hPrivate,
 			          0,
 			          psProgramHeader->ui32Pmemsz - psProgramHeader->ui32Pfilesz);
 
+#if defined(CONFIG_ARM64) && defined(__linux__) && defined(SUPPORT_CPUCACHED_FWMEMCTX)
 			RGXFwSharedMemCacheOpExec(pvWriteAddr, psProgramHeader->ui32Pmemsz, PVRSRV_CACHE_OP_FLUSH);
+#endif
 		}
 	}
 
@@ -1062,12 +1071,14 @@ PVRSRV_ERROR RGXProcessFWImage(const void *hPrivate,
 				*pui32BootConf++ = 0;
 			}
 
+#if defined(RGX_FEATURE_META_DMA_BIT_MASK)
 			if (RGX_DEVICE_HAS_FEATURE(hPrivate, META_DMA))
 			{
 				*pui32BootConf++ = (IMG_UINT32) (puFWParams->sMeta.sFWCorememCodeDevVAddr.uiAddr >> 32);
 				*pui32BootConf++ = (IMG_UINT32) puFWParams->sMeta.sFWCorememCodeDevVAddr.uiAddr;
 			}
 			else
+#endif
 			{
 				*pui32BootConf++ = 0;
 				*pui32BootConf++ = 0;
diff --git a/drivers/gpu/drm/img-rogue/rgxfwmemctx.h b/drivers/gpu/drm/img-rogue/rgxfwmemctx.h
index 2cb40991fee9..49f37b1c27aa 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwmemctx.h
+++ b/drivers/gpu/drm/img-rogue/rgxfwmemctx.h
@@ -71,18 +71,12 @@ static INLINE void RGXFwSharedMemCPUCacheMode(PVRSRV_DEVICE_NODE *psDeviceNode,
 		return;
 	}
 
-	if (PVRSRV_CHECK_UNCACHED(*puiFlags))
-	{
-		/* We don't need to upgrade uncached allocations */
-		return;
-	}
-
 	/* Clear the existing CPU cache flags */
 	*puiFlags &= ~(PVRSRV_MEMALLOCFLAG_CPU_CACHE_MODE_MASK);
 
 	if (PVRSRVSystemSnoopingOfCPUCache(psDeviceNode->psDevConfig))
 	{
-		*puiFlags |= PVRSRV_MEMALLOCFLAG_CPU_CACHED;
+		*puiFlags |= PVRSRV_MEMALLOCFLAG_CPU_CACHE_INCOHERENT;
 	}
 	else
 	{
@@ -117,7 +111,6 @@ static INLINE PVRSRV_ERROR RGXFwSharedMemCacheOpExec(const volatile void *pvVirt
 					   uiUnusedPhysAddr,
 					   uiUnusedPhysAddr,
 					   uiCacheOp);
-	return PVRSRV_OK;
 }
 
 #define RGXFwSharedMemCacheOpValue(value, cacheop) (RGXFwSharedMemCacheOpExec(&value, sizeof(value), PVRSRV_CACHE_OP_##cacheop))
diff --git a/drivers/gpu/drm/img-rogue/rgxfwriscv.c b/drivers/gpu/drm/img-rogue/rgxfwriscv.c
index 15fd27c05dad..555691010517 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwriscv.c
+++ b/drivers/gpu/drm/img-rogue/rgxfwriscv.c
@@ -47,11 +47,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 #define RGX_GET_DMI_REG(psDevInfo, value) \
 	((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4) ? \
-	 RGX_CR_FWCORE_DMI_##value##__RISCV_AND_HOST_SECURITY_GEQ4 : RGX_CR_FWCORE_DMI_##value)
-#define RGX_GET_RISCV_REGS_BASE(psDevInfo) ((psDevInfo)->pvSecureRegsBaseKM)
+	 RGX_CR_FWCORE_DMI_##value##__HOST_SECURITY_GEQ4 : RGX_CR_FWCORE_DMI_##value)
 #else
 #define RGX_GET_DMI_REG(psDevInfo, value) RGX_CR_FWCORE_DMI_##value
-#define RGX_GET_RISCV_REGS_BASE(psDevInfo) ((psDevInfo)->pvRegsBaseKM)
 #endif
 
 /*
@@ -91,7 +89,7 @@ PVRSRV_ERROR RGXRiscvHalt(PVRSRV_RGXDEV_INFO *psDevInfo)
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Send halt request (no need to select one or more harts on this RISC-V core) */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
 	               RGX_CR_FWCORE_DMI_DMCONTROL_HALTREQ_EN |
 	               RGX_CR_FWCORE_DMI_DMCONTROL_DMACTIVE_EN);
 
@@ -103,12 +101,12 @@ PVRSRV_ERROR RGXRiscvHalt(PVRSRV_RGXDEV_INFO *psDevInfo)
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Hart not halted (0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 
 	/* Clear halt request */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
 	               RGX_CR_FWCORE_DMI_DMCONTROL_DMACTIVE_EN);
 #endif
 
@@ -128,7 +126,7 @@ IMG_BOOL RGXRiscvIsHalted(PVRSRV_RGXDEV_INFO *psDevInfo)
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 	IMG_UINT32 ui32_DMI_DMSTATUS_Reg = RGX_GET_DMI_REG(psDevInfo, DMSTATUS);
 
-	return (OSReadHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg) &
+	return (OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg) &
 	        RGX_CR_FWCORE_DMI_DMSTATUS_ALLHALTED_EN) != 0U;
 #endif
 }
@@ -170,7 +168,7 @@ PVRSRV_ERROR RGXRiscvResume(PVRSRV_RGXDEV_INFO *psDevInfo)
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Send resume request (no need to select one or more harts on this RISC-V core) */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
 	               RGX_CR_FWCORE_DMI_DMCONTROL_RESUMEREQ_EN |
 	               RGX_CR_FWCORE_DMI_DMCONTROL_DMACTIVE_EN);
 
@@ -182,12 +180,12 @@ PVRSRV_ERROR RGXRiscvResume(PVRSRV_RGXDEV_INFO *psDevInfo)
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Hart not resumed (0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMSTATUS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 
 	/* Clear resume request */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DMCONTROL_Reg,
 	               RGX_CR_FWCORE_DMI_DMCONTROL_DMACTIVE_EN);
 #endif
 
@@ -225,7 +223,7 @@ static RGXRISCVFW_ABSTRACT_CMD_ERR RGXRiscvCheckAbstractCmdError(PVRSRV_RGXDEV_I
 	void __iomem *pvRegsBaseKM = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Check error status */
-	eCmdErr = (OSReadHWReg32(pvRegsBaseKM, ui32_DMI_ABSTRACTCS_Reg)
+	eCmdErr = (OSReadUncheckedHWReg32(pvRegsBaseKM, ui32_DMI_ABSTRACTCS_Reg)
 	          & ~RGX_CR_FWCORE_DMI_ABSTRACTCS_CMDERR_CLRMSK)
 	          >> RGX_CR_FWCORE_DMI_ABSTRACTCS_CMDERR_SHIFT;
 
@@ -234,7 +232,7 @@ static RGXRISCVFW_ABSTRACT_CMD_ERR RGXRiscvCheckAbstractCmdError(PVRSRV_RGXDEV_I
 		PVR_DPF((PVR_DBG_WARNING, "RISC-V FW abstract command error %u", eCmdErr));
 
 		/* Clear the error (note CMDERR field is write-1-to-clear) */
-		OSWriteHWReg32(pvRegsBaseKM, ui32_DMI_ABSTRACTCS_Reg,
+		OSWriteUncheckedHWReg32(pvRegsBaseKM, ui32_DMI_ABSTRACTCS_Reg,
 		               ~RGX_CR_FWCORE_DMI_ABSTRACTCS_CMDERR_CLRMSK);
 	}
 #endif
@@ -264,7 +262,7 @@ PVRSRV_ERROR RGXRiscvReadReg(PVRSRV_RGXDEV_INFO *psDevInfo,
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Send abstract register read command */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_COMMAND_Reg,
 	               (RGXRISCVFW_DMI_COMMAND_ACCESS_REGISTER << RGX_CR_FWCORE_DMI_COMMAND_CMDTYPE_SHIFT) |
 	               RGXRISCVFW_DMI_COMMAND_READ |
@@ -279,14 +277,14 @@ PVRSRV_ERROR RGXRiscvReadReg(PVRSRV_RGXDEV_INFO *psDevInfo,
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Abstract command did not complete in time (abstractcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 
 	if (RGXRiscvCheckAbstractCmdError(psDevInfo) == RISCV_ABSTRACT_CMD_NO_ERROR)
 	{
 		/* Read register value */
-		*pui32Value = OSReadHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
+		*pui32Value = OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
 	}
 	else
 	{
@@ -392,10 +390,10 @@ PVRSRV_ERROR RGXRiscvWriteReg(PVRSRV_RGXDEV_INFO *psDevInfo,
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Prepare data to be written to register */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg, ui32Value);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg, ui32Value);
 
 	/* Send abstract register write command */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_COMMAND_Reg,
 	               (RGXRISCVFW_DMI_COMMAND_ACCESS_REGISTER << RGX_CR_FWCORE_DMI_COMMAND_CMDTYPE_SHIFT) |
 	               RGXRISCVFW_DMI_COMMAND_WRITE |
@@ -410,7 +408,7 @@ PVRSRV_ERROR RGXRiscvWriteReg(PVRSRV_RGXDEV_INFO *psDevInfo,
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Abstract command did not complete in time (abstractcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 #endif
@@ -447,7 +445,7 @@ static __maybe_unused RGXRISCVFW_SYSBUS_ERR RGXRiscvCheckSysBusError(PVRSRV_RGXD
 #else
 	void __iomem *pvRegsBaseKM = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
-	eSBError = (OSReadHWReg32(pvRegsBaseKM, ui32_DMI_SBCS_Reg)
+	eSBError = (OSReadUncheckedHWReg32(pvRegsBaseKM, ui32_DMI_SBCS_Reg)
 	         & ~RGX_CR_FWCORE_DMI_SBCS_SBERROR_CLRMSK)
 	         >> RGX_CR_FWCORE_DMI_SBCS_SBERROR_SHIFT;
 
@@ -456,7 +454,7 @@ static __maybe_unused RGXRISCVFW_SYSBUS_ERR RGXRiscvCheckSysBusError(PVRSRV_RGXD
 		PVR_DPF((PVR_DBG_WARNING, "RISC-V FW system bus error %u", eSBError));
 
 		/* Clear the error (note SBERROR field is write-1-to-clear) */
-		OSWriteHWReg32(pvRegsBaseKM, ui32_DMI_SBCS_Reg,
+		OSWriteUncheckedHWReg32(pvRegsBaseKM, ui32_DMI_SBCS_Reg,
 		               ~RGX_CR_FWCORE_DMI_SBCS_SBERROR_CLRMSK);
 	}
 #endif
@@ -499,10 +497,10 @@ RGXRiscvReadAbstractMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Prepare read address */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DATA1_Reg, ui32Addr);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA1_Reg, ui32Addr);
 
 	/* Send abstract memory read command */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_COMMAND_Reg,
 	               (RGXRISCVFW_DMI_COMMAND_ACCESS_MEMORY << RGX_CR_FWCORE_DMI_COMMAND_CMDTYPE_SHIFT) |
 	               RGXRISCVFW_DMI_COMMAND_READ |
@@ -516,14 +514,14 @@ RGXRiscvReadAbstractMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Abstract command did not complete in time (abstractcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 
 	if (RGXRiscvCheckAbstractCmdError(psDevInfo) == RISCV_ABSTRACT_CMD_NO_ERROR)
 	{
 		/* Read memory value */
-		*pui32Value = OSReadHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
+		*pui32Value = OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
 	}
 	else
 	{
@@ -640,13 +638,13 @@ RGXRiscvReadSysBusMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_UI
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Configure system bus to read 32 bit every time a new address is provided */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_SBCS_Reg,
 	               (RGXRISCVFW_DMI_SBCS_SBACCESS_32BIT << RGX_CR_FWCORE_DMI_SBCS_SBACCESS_SHIFT) |
 	               RGX_CR_FWCORE_DMI_SBCS_SBREADONADDR_EN);
 
 	/* Perform read */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_SBADDRESS0_Reg, ui32Addr);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_SBADDRESS0_Reg, ui32Addr);
 
 	/* Wait until system bus is idle */
 	if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
@@ -656,14 +654,14 @@ RGXRiscvReadSysBusMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_UI
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: System Bus did not go idle in time (sbcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_SBCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_SBCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 
 	if (RGXRiscvCheckSysBusError(psDevInfo) == RISCV_SYSBUS_NO_ERROR)
 	{
 		/* Read value from debug system bus */
-		*pui32Value = OSReadHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
+		*pui32Value = OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg);
 	}
 	else
 	{
@@ -835,13 +833,13 @@ RGXRiscvWriteAbstractMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Prepare write address */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DATA1_Reg, ui32Addr);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA1_Reg, ui32Addr);
 
 	/* Prepare write data */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg, ui32Value);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_DATA0_Reg, ui32Value);
 
 	/* Send abstract memory write command */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_COMMAND_Reg,
 	               (RGXRISCVFW_DMI_COMMAND_ACCESS_MEMORY << RGX_CR_FWCORE_DMI_COMMAND_CMDTYPE_SHIFT) |
 	               RGXRISCVFW_DMI_COMMAND_WRITE |
@@ -855,7 +853,7 @@ RGXRiscvWriteAbstractMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Abstract command did not complete in time (abstractcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_ABSTRACTCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 #endif
@@ -917,15 +915,15 @@ RGXRiscvWriteSysBusMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_U
 	IMG_UINT32 __iomem *pui32RegsBase = RGX_GET_RISCV_REGS_BASE(psDevInfo);
 
 	/* Configure system bus for 32 bit accesses */
-	OSWriteHWReg32(pui32RegsBase,
+	OSWriteUncheckedHWReg32(pui32RegsBase,
 	               ui32_DMI_SBCS_Reg,
 	               RGXRISCVFW_DMI_SBCS_SBACCESS_32BIT << RGX_CR_FWCORE_DMI_SBCS_SBACCESS_SHIFT);
 
 	/* Prepare write address */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_SBADDRESS0_Reg, ui32Addr);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_SBADDRESS0_Reg, ui32Addr);
 
 	/* Prepare write data and initiate write */
-	OSWriteHWReg32(pui32RegsBase, ui32_DMI_SBDATA0_Reg, ui32Value);
+	OSWriteUncheckedHWReg32(pui32RegsBase, ui32_DMI_SBDATA0_Reg, ui32Value);
 
 	/* Wait until system bus is idle */
 	if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
@@ -935,7 +933,7 @@ RGXRiscvWriteSysBusMem(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Addr, IMG_U
 	                         POLL_FLAG_LOG_ERROR, NULL) != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: System Bus did not go idle in time (sbcs = 0x%x)",
-		         __func__, OSReadHWReg32(pui32RegsBase, ui32_DMI_SBCS_Reg)));
+		         __func__, OSReadUncheckedHWReg32(pui32RegsBase, ui32_DMI_SBCS_Reg)));
 		return PVRSRV_ERROR_TIMEOUT;
 	}
 #endif
@@ -973,7 +971,7 @@ PVRSRV_ERROR RGXRiscvDmiOp(PVRSRV_RGXDEV_INFO *psDevInfo,
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 #else
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-#define DMI_BASE     ((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4) ? RGX_CR_FWCORE_DMI_RESERVED00__RISCV_AND_HOST_SECURITY_GEQ4 : RGX_CR_FWCORE_DMI_RESERVED00)
+#define DMI_BASE     ((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4) ? RGX_CR_FWCORE_DMI_RESERVED00__HOST_SECURITY_GEQ4 : RGX_CR_FWCORE_DMI_RESERVED00)
 #else
 #define DMI_BASE     RGX_CR_FWCORE_DMI_RESERVED00
 #endif
@@ -1035,13 +1033,13 @@ PVRSRV_ERROR RGXRiscvDmiOp(PVRSRV_RGXDEV_INFO *psDevInfo,
 				ui64Op = DMI_OP_STATUS_SUCCESS;
 				break;
 			case DMI_OP_WRITE:
-				OSWriteHWReg32(pvRegsBase,
+				OSWriteUncheckedHWReg32(pvRegsBase,
 						DMI_REG(ui64Address),
 						(IMG_UINT32)ui64Data);
 				ui64Op = DMI_OP_STATUS_SUCCESS;
 				break;
 			case DMI_OP_READ:
-				ui64Data = (IMG_UINT64)OSReadHWReg32(pvRegsBase,
+				ui64Data = (IMG_UINT64)OSReadUncheckedHWReg32(pvRegsBase,
 						DMI_REG(ui64Address));
 				ui64Op = DMI_OP_STATUS_SUCCESS;
 				break;
diff --git a/drivers/gpu/drm/img-rogue/rgxfwriscv.h b/drivers/gpu/drm/img-rogue/rgxfwriscv.h
index 4a9ac7aedc08..7821c167fa2a 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwriscv.h
+++ b/drivers/gpu/drm/img-rogue/rgxfwriscv.h
@@ -48,6 +48,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define RGXRISCVFW_GET_REMAP_SECURE(r)          (RGX_CR_FWCORE_ADDR_REMAP_CONFIG0__HOST_SECURITY_GEQ4 + ((r) * 8U))
 #define RGXRISCVFW_BOOTLDR_CODE_REMAP_SECURE    (RGXRISCVFW_GET_REMAP_SECURE(RGXRISCVFW_BOOTLDR_CODE_REGION))
 #define RGXRISCVFW_BOOTLDR_DATA_REMAP_SECURE    (RGXRISCVFW_GET_REMAP_SECURE(RGXRISCVFW_BOOTLDR_DATA_REGION))
+#define RGX_GET_RISCV_REGS_BASE(psDevInfo) \
+	((RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4) ? \
+	 (psDevInfo)->pvSecureRegsBaseKM : (psDevInfo)->pvRegsBaseKM)
+#else
+#define RGX_GET_RISCV_REGS_BASE(psDevInfo) ((psDevInfo)->pvRegsBaseKM)
 #endif
 
 /*!
diff --git a/drivers/gpu/drm/img-rogue/rgxfwutils.c b/drivers/gpu/drm/img-rogue/rgxfwutils.c
index fc81cb4d904d..56d4940d2a6c 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwutils.c
+++ b/drivers/gpu/drm/img-rogue/rgxfwutils.c
@@ -125,10 +125,11 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxpdvfs.h"
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER)
-#include "rgxsoctimer.h"
+#if defined(SUPPORT_FW_OPP_TABLE) && defined(CONFIG_OF)
+#include "pvr_dvfs_common.h"
 #endif
 
+
 #include "vz_vmm_pvz.h"
 #include "rgx_heaps.h"
 
@@ -157,7 +158,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /* Firmware CCB length */
 #if defined(NO_HARDWARE) && defined(PDUMP)
 #define RGXFWIF_FWCCB_NUMCMDS_LOG2   (10)
-#elif defined(SUPPORT_PDVFS)
+#elif defined(SUPPORT_PDVFS) || defined(SUPPORT_WORKLOAD_ESTIMATION)
 #define RGXFWIF_FWCCB_NUMCMDS_LOG2   (8)
 #else
 #define RGXFWIF_FWCCB_NUMCMDS_LOG2   (5)
@@ -182,6 +183,18 @@ typedef struct
 	PVRSRV_RGXDEV_INFO      *psDevInfo;
 } RGX_DEFERRED_KCCB_CMD;
 
+typedef struct
+{
+	IMG_INT32  i32Priority;
+	IMG_UINT32 ui32IsolationGroups;
+	IMG_UINT32 ui32TSPercentage;
+}RGX_QOS_DEFAULTS;
+
+#define RGX_QOS_DEFAULTS_INIT(osid) \
+	{RGX_DRIVERID_##osid##_DEFAULT_PRIORITY,\
+	RGX_DRIVERID_##osid##_DEFAULT_ISOLATION_GROUP,\
+	RGX_DRIVERID_##osid##_DEFAULT_TIME_SLICE}
+
 #if defined(PDUMP)
 /* ensure PIDs are 32-bit because a 32-bit PDump load is generated for the
  * PID filter example entries
@@ -192,75 +205,15 @@ static_assert(sizeof(IMG_PID) == sizeof(IMG_UINT32),
 #endif
 
 #if (RGXFW_MAX_NUM_OSIDS > 1)
-static_assert(((IMG_UINT8)RGX_DRIVERID_0_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_1_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_2_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_3_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_4_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_5_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_6_DEFAULT_TIME_SLICE +
-			   (IMG_UINT8)RGX_DRIVERID_7_DEFAULT_TIME_SLICE) <= PVRSRV_VZ_TIME_SLICE_MAX, "Invalid driverid time slice aggregate");
+static_assert(RGX_DRIVER_DEFAULT_TIME_SLICES_SUM <= PVRSRV_VZ_TIME_SLICE_MAX, "Invalid driverid time slice aggregate");
 #endif
 
 static void RGXFreeFwOsData(PVRSRV_RGXDEV_INFO *psDevInfo);
 static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo);
 
-#if defined(RGX_FEATURE_SLC_VIVT_BIT_MASK)
-static PVRSRV_ERROR _AllocateSLC3Fence(PVRSRV_RGXDEV_INFO* psDevInfo, RGXFWIF_SYSINIT* psFwSysInit)
-{
-	PVRSRV_ERROR eError;
-	DEVMEM_MEMDESC** ppsSLC3FenceMemDesc = &psDevInfo->psSLC3FenceMemDesc;
-	IMG_UINT32 ui32CacheLineSize = GET_ROGUE_CACHE_LINE_SIZE(
-			RGX_GET_FEATURE_VALUE(psDevInfo, SLC_CACHE_LINE_SIZE_BITS));
-
-	PVR_DPF_ENTERED;
-
-	eError = DevmemAllocate(psDevInfo->psFirmwareMainHeap,
-			1,
-			ui32CacheLineSize,
-			PVRSRV_MEMALLOCFLAG_GPU_READABLE |
-			PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
-			PVRSRV_MEMALLOCFLAG_GPU_UNCACHED |
-			PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN),
-			"FwSLC3FenceWA",
-			ppsSLC3FenceMemDesc);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF_RETURN_RC(eError);
-	}
-
-	/* We need to map it so the heap for this allocation is set */
-	eError = DevmemMapToDevice(*ppsSLC3FenceMemDesc,
-							   psDevInfo->psFirmwareMainHeap,
-							   &psFwSysInit->sSLC3FenceDevVAddr);
-	if (eError != PVRSRV_OK)
-	{
-		DevmemFree(*ppsSLC3FenceMemDesc);
-		*ppsSLC3FenceMemDesc = NULL;
-	}
-
-	PVR_DPF_RETURN_RC1(eError, *ppsSLC3FenceMemDesc);
-}
-
-static void _FreeSLC3Fence(PVRSRV_RGXDEV_INFO* psDevInfo)
-{
-	DEVMEM_MEMDESC* psSLC3FenceMemDesc = psDevInfo->psSLC3FenceMemDesc;
-
-	if (psSLC3FenceMemDesc)
-	{
-		DevmemReleaseDevVirtAddr(psSLC3FenceMemDesc);
-		DevmemFree(psSLC3FenceMemDesc);
-	}
-}
-#endif
 
 static void __MTSScheduleWrite(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32Value)
 {
-	/* Ensure any uncached/WC memory writes are flushed from CPU write buffers
-	 * before kicking MTS.
-	 */
-	OSWriteMemoryBarrier(NULL);
-
 	/* This should *NOT* happen. Try to trace what caused this and avoid a NPE
 	 * with the Write/Read at the foot of the function.
 	 */
@@ -560,10 +513,9 @@ static PVRSRV_ERROR RGXFWSetupFirmwareGcovBuffer(PVRSRV_RGXDEV_INFO*			psDevInfo
 static PVRSRV_ERROR RGXFWSetupCounterBuffer(PVRSRV_RGXDEV_INFO* psDevInfo,
 		DEVMEM_MEMDESC**			ppsBufferMemDesc,
 		IMG_UINT32					ui32CounterDataBufferSize,
-		RGXFWIF_COUNTER_DUMP_CTL*	psCounterDumpCtl,
-		const IMG_CHAR*				pszBufferName)
+		RGXFWIF_COUNTER_DUMP_CTL*	psCounterDumpCtl)
 {
-	PVRSRV_ERROR	eError;
+	PVRSRV_ERROR eError;
 
 	eError = RGXSetupFwAllocation(psDevInfo,
 								  (RGX_FWSHAREDMEM_CPU_RO_ALLOCFLAGS |
@@ -577,6 +529,7 @@ static PVRSRV_ERROR RGXFWSetupCounterBuffer(PVRSRV_RGXDEV_INFO* psDevInfo,
 	PVR_LOG_RETURN_IF_ERROR(eError, "RGXSetupFwAllocation");
 
 	psCounterDumpCtl->ui32SizeInDwords = ui32CounterDataBufferSize >> 2;
+	RGXFwSharedMemCacheOpValue(psCounterDumpCtl->ui32SizeInDwords, FLUSH);
 
 	return PVRSRV_OK;
 }
@@ -702,7 +655,7 @@ PVRSRV_ERROR RGXSetFirmwareAddress(RGXFWIF_DEV_VIRTADDR	*ppDest,
 		bCachedInMETA = (PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(FIRMWARE_CACHED) & uiDevFlags) != 0;
 
 		/* Honour the SLC cache flags */
-		eError = DevmemDeviceCacheMode(psDeviceNode, uiDevFlags, &uiGPUCacheMode);
+		eError = DevmemDeviceCacheMode(uiDevFlags, &uiGPUCacheMode);
 		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemDeviceCacheMode", failDevCacheMode);
 
 		/*
@@ -931,7 +884,7 @@ static PVRSRV_ERROR RGXSetupCCB(PVRSRV_RGXDEV_INFO	*psDevInfo,
 
 	if (unlikely(iStrLen < 0))
 	{
-		OSStringLCopy(szCCBCtlName, "FwCCBControl", DEVMEM_ANNOTATION_MAX_LEN);
+		OSStringSafeCopy(szCCBCtlName, "FwCCBControl", DEVMEM_ANNOTATION_MAX_LEN);
 	}
 
 	/* Allocate memory for the CCB control.*/
@@ -997,14 +950,20 @@ static void RGXSetupFaultReadRegisterRollback(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	PMR *psPMR;
 
-	if (psDevInfo->psRGXFaultAddressMemDesc)
+#if defined(RGX_FEATURE_SLC_FAULT_ACCESS_ADDR_PHYS_BIT_MASK)
+	/* Run-time check feature support */
+	if (PVRSRV_IS_FEATURE_SUPPORTED(psDevInfo->psDeviceNode, SLC_FAULT_ACCESS_ADDR_PHYS))
+#endif
 	{
-		if (DevmemServerGetImportHandle(psDevInfo->psRGXFaultAddressMemDesc, (void **)&psPMR) == PVRSRV_OK)
+		if (psDevInfo->psRGXFaultAddressMemDesc)
 		{
-			PMRUnlockSysPhysAddresses(psPMR);
+			if (DevmemServerGetImportHandle(psDevInfo->psRGXFaultAddressMemDesc, (void **)&psPMR) == PVRSRV_OK)
+			{
+				PMRUnlockSysPhysAddresses(psPMR);
+			}
+			DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFaultAddressMemDesc);
+			psDevInfo->psRGXFaultAddressMemDesc = NULL;
 		}
-		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFaultAddressMemDesc);
-		psDevInfo->psRGXFaultAddressMemDesc = NULL;
 	}
 }
 
@@ -1017,8 +976,16 @@ static PVRSRV_ERROR RGXSetupFaultReadRegister(PVRSRV_DEVICE_NODE *psDeviceNode,
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 	PMR					*psPMR;
 
+#if defined(RGX_FEATURE_SLC_FAULT_ACCESS_ADDR_PHYS_BIT_MASK)
+	/* Run-time check feature support */
+	if (!PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, SLC_FAULT_ACCESS_ADDR_PHYS))
+	{
+		return PVRSRV_OK;
+	}
+#endif
+
 	/* Allocate page of memory to use for page faults on non-blocking memory transactions.
-	 * Doesn't need to be cleared as it is initialised with the 0xDEADBEE0 pattern below. */
+	 * Doesn't need to be cleared as it is initialised with the 0xDEADBEEF pattern below. */
 	psDevInfo->psRGXFaultAddressMemDesc = NULL;
 	eError = DevmemFwAllocateExportable(psDeviceNode,
 			ui32PageSize,
@@ -1051,7 +1018,7 @@ static PVRSRV_ERROR RGXSetupFaultReadRegister(PVRSRV_DEVICE_NODE *psDeviceNode,
 		/* fill the page with a known pattern when booting the firmware */
 		for (i = 0; i < ui32PageSize/sizeof(IMG_UINT32); i++)
 		{
-			*(pui32MemoryVirtAddr + i) = 0xDEADBEE0;
+			*(pui32MemoryVirtAddr + i) = 0xDEADBEEF;
 		}
 
 		OSWriteMemoryBarrier(pui32MemoryVirtAddr);
@@ -1130,6 +1097,14 @@ static PVRSRV_ERROR RGXPDumpFaultReadRegister(PVRSRV_RGXDEV_INFO *psDevInfo)
 	PMR *psFWInitPMR, *psFaultAddrPMR;
 	IMG_UINT32 ui32Dstoffset;
 
+#if defined(RGX_FEATURE_SLC_FAULT_ACCESS_ADDR_PHYS_BIT_MASK)
+	/* Run-time check feature support */
+	if (!PVRSRV_IS_FEATURE_SUPPORTED(psDevInfo->psDeviceNode, SLC_FAULT_ACCESS_ADDR_PHYS))
+	{
+		return PVRSRV_OK;
+	}
+#endif
+
 	psFWInitPMR = (PMR *)(psDevInfo->psRGXFWIfSysInitMemDesc->psImport->hPMR);
 	ui32Dstoffset = psDevInfo->psRGXFWIfSysInitMemDesc->uiOffset + offsetof(RGXFWIF_SYSINIT, sFaultPhysAddr.uiAddr);
 
@@ -1149,38 +1124,6 @@ static PVRSRV_ERROR RGXPDumpFaultReadRegister(PVRSRV_RGXDEV_INFO *psDevInfo)
 #endif
 
 #if defined(SUPPORT_TBI_INTERFACE)
-/*************************************************************************/ /*!
-@Function       RGXTBIBufferIsInitRequired
-
-@Description    Returns true if the firmware tbi buffer is not allocated and
-		might be required by the firmware soon. TBI buffer allocated
-		on-demand to reduce RAM footprint on systems not needing
-		tbi.
-
-@Input          psDevInfo	 RGX device info
-
-@Return		IMG_BOOL	Whether on-demand allocation(s) is/are needed
-				or not
-*/ /**************************************************************************/
-INLINE IMG_BOOL RGXTBIBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo)
-{
-	RGXFWIF_TRACEBUF*  psTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
-
-	RGXFwSharedMemCacheOpValue(psTraceBufCtl->ui32LogType, INVALIDATE);
-
-	/* The firmware expects a tbi buffer only when:
-	 *	- Logtype is "tbi"
-	 */
-	if ((psDevInfo->psRGXFWIfTBIBufferMemDesc == NULL)
-		 && (psTraceBufCtl->ui32LogType & ~RGXFWIF_LOG_TYPE_TRACE)
-		 && (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_GROUP_MASK))
-	{
-		return IMG_TRUE;
-	}
-
-	return IMG_FALSE;
-}
-
 /*************************************************************************/ /*!
 @Function       RGXTBIBufferDeinit
 
@@ -1257,41 +1200,6 @@ PVRSRV_ERROR RGXTBIBufferInitOnDemandResources(PVRSRV_RGXDEV_INFO *psDevInfo)
 }
 #endif
 
-/*************************************************************************/ /*!
-@Function       RGXTraceBufferIsInitRequired
-
-@Description    Returns true if the firmware trace buffer is not allocated and
-		might be required by the firmware soon. Trace buffer allocated
-		on-demand to reduce RAM footprint on systems not needing
-		firmware trace.
-
-@Input          psDevInfo	 RGX device info
-
-@Return		IMG_BOOL	Whether on-demand allocation(s) is/are needed
-				or not
-*/ /**************************************************************************/
-INLINE IMG_BOOL RGXTraceBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo)
-{
-	RGXFWIF_TRACEBUF*  psTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
-
-	RGXFwSharedMemCacheOpValue(psTraceBufCtl->ui32LogType, INVALIDATE);
-
-	/* The firmware expects a trace buffer only when:
-	 *	- Logtype is "trace" AND
-	 *	- at least one LogGroup is configured
-	 *	- the Driver Mode is not Guest
-	 */
-	if ((psDevInfo->psRGXFWIfTraceBufferMemDesc[0] == NULL)
-		&& (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_TRACE)
-		&& (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_GROUP_MASK)
-		&& !PVRSRV_VZ_MODE_IS(GUEST))
-	{
-		return IMG_TRUE;
-	}
-
-	return IMG_FALSE;
-}
-
 /*************************************************************************/ /*!
 @Function       RGXTraceBufferDeinit
 
@@ -1412,14 +1320,14 @@ PVRSRV_ERROR RGXTraceBufferInitOnDemandResources(PVRSRV_RGXDEV_INFO* psDevInfo,
 @Input          psDevInfo RGX device info
  */ /*************************************************************************/
 static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
-								   IMG_UINT32         ui32HWPerfCountersDataSize,
-								   IMG_BOOL           bEnableSignatureChecks)
+								   RGX_INIT_APPHINTS  *psApphints,
+								   IMG_UINT32         ui32HWPerfCountersDataSize)
 {
-	IMG_UINT32 ui32ConfigFlags    = psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags;
-	IMG_UINT32 ui32FwOsCfgFlags   = psDevInfo->psRGXFWIfFwOsData->ui32FwOsConfigFlags;
+	IMG_UINT32 ui32ConfigFlags  = psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags;
+	IMG_UINT32 ui32FwOsCfgFlags = psDevInfo->psRGXFWIfFwOsData->ui32FwOsConfigFlags;
 
 	PDUMPCOMMENT(psDevInfo->psDeviceNode, "Dump RGXFW Init data");
-	if (!bEnableSignatureChecks)
+	if (!psApphints->bEnableSignatureChecks)
 	{
 		PDUMPCOMMENT(psDevInfo->psDeviceNode,
 					 "(to enable rgxfw signatures place the following line after the RTCONF line)");
@@ -1513,10 +1421,6 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 				 "( Ctx Switch Soft Reset Enable:              0x%08x)", RGXFWIF_INICFG_CTXSWITCH_SRESET_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Enable HWPerf:                             0x%08x)", RGXFWIF_INICFG_HWPERF_EN);
-#if defined(SUPPORT_VALIDATION)
-	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "( Enable generic DM Killing Rand mode:       0x%08x)", RGXFWIF_INICFG_DM_KILL_MODE_RAND_EN);
-#endif /* defined(SUPPORT_VALIDATION) */
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Rascal+Dust Power Island:                  0x%08x)", RGXFWIF_INICFG_POW_RASCALDUST);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
@@ -1526,6 +1430,12 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Disable Auto Clock Gating:                 0x%08x)", RGXFWIF_INICFG_DISABLE_CLKGATING_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+#if defined(RGX_FEATURE_PIPELINED_DATAMASTERS_VERSION_MAX_VALUE_IDX)
+				 "( Try overlapping DM pipelines:              0x%08x)", RGXFWIF_INICFG_TRY_OVERLAPPING_DM_PIPELINES_EN);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( Enable DM pipeline roadblocks:             0x%08x)", RGXFWIF_INICFG_DM_PIPELINE_ROADBLOCKS_EN);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+#endif
 				 "( Enable register configuration:             0x%08x)", RGXFWIF_INICFG_REGCONFIG_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Assert on TA Out-of-Memory:                0x%08x)", RGXFWIF_INICFG_ASSERT_ON_OUTOFMEMORY);
@@ -1537,14 +1447,12 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 				 "( Disable DM overlap (except TA during SPM): 0x%08x)", RGXFWIF_INICFG_DISABLE_DM_OVERLAP);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Assert on HWR trigger (page fault, lockup, overrun or poll failure): 0x%08x)", RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER);
-	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "( Enable coherent memory accesses:           0x%08x)", RGXFWIF_INICFG_FABRIC_COHERENCY_ENABLED);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Enable IRQ validation:                     0x%08x)", RGXFWIF_INICFG_VALIDATE_IRQ);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( SPU power state mask change Enable:        0x%08x)", RGXFWIF_INICFG_SPU_POWER_STATE_MASK_CHANGE_EN);
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		PDUMPCOMMENT(psDevInfo->psDeviceNode,
 					 "( Enable Workload Estimation:                0x%08x)", RGXFWIF_INICFG_WORKEST);
@@ -1554,8 +1462,6 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 #endif /* defined(SUPPORT_PDVFS) */
 	}
 #endif /* defined(SUPPORT_WORKLOAD_ESTIMATION) */
-	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "( CDM Arbitration Mode (task demand=b'01, round robin=b'10): 0x%08x)", RGXFWIF_INICFG_CDM_ARBITRATION_MASK);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( ISP Scheduling Mode (v1=b'01, v2=b'10):    0x%08x)", RGXFWIF_INICFG_ISPSCHEDMODE_MASK);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
@@ -1574,11 +1480,15 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Ctx Switch TDM Enable:                     0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_TDM_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "( Ctx Switch TA Enable:                      0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_GEOM_EN);
+				 "( Ctx Switch GEOM Enable:                    0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_GEOM_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Ctx Switch 3D Enable:                      0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_3D_EN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Ctx Switch CDM Enable:                     0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_CDM_EN);
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( Ctx Switch RDM Enable:                     0x%08x)", RGXFWIF_INICFG_OS_CTXSWITCH_RDM_EN);
+#endif
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Lower Priority Ctx Switch  2D Enable:      0x%08x)", RGXFWIF_INICFG_OS_LOW_PRIO_CS_TDM);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
@@ -1587,12 +1497,50 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 				 "( Lower Priority Ctx Switch  3D Enable:      0x%08x)", RGXFWIF_INICFG_OS_LOW_PRIO_CS_3D);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( Lower Priority Ctx Switch CDM Enable:      0x%08x)", RGXFWIF_INICFG_OS_LOW_PRIO_CS_CDM);
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( Lower Priority Ctx Switch RDM Enable:      0x%08x)", RGXFWIF_INICFG_OS_LOW_PRIO_CS_RDM);
+#endif
 
 	DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfFwOsDataMemDesc,
 							  offsetof(RGXFWIF_OSDATA, ui32FwOsConfigFlags),
 							  ui32FwOsCfgFlags,
 							  PDUMP_FLAGS_CONTINUOUS);
 
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	{
+		PDUMP_FLAGS_T      ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
+		IMG_UINT32         ui32AllPowUnitsMask = (1 << psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount) - 1;
+		IMG_BOOL           bRunTimeUpdate = IMG_FALSE;
+		IMG_UINT32         ui32DstOffset = psDevInfo->psRGXFWIfRuntimeCfgMemDesc->uiOffset + offsetof(RGXFWIF_RUNTIME_CFG, ui32PowUnitsState);
+		IMG_CHAR           aszPowUnitsMaskRegVar[] = ":SYSMEM:$1";
+		IMG_CHAR           aszPowUnitsEnable[] = "RUNTIME_POW_UNITS_MASK";
+		PMR                *psPMR = (PMR *)(psDevInfo->psRGXFWIfRuntimeCfgMemDesc->psImport->hPMR);
+
+
+		if (bRunTimeUpdate)
+		{
+			PDUMPIF(psDevInfo->psDeviceNode, aszPowUnitsEnable, ui32PDumpFlags);
+		}
+
+		PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode, ui32PDumpFlags,
+		                      "Load initial value power units mask in FW runtime configuration");
+		DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfRuntimeCfgMemDesc,
+								  ui32DstOffset,
+								  psDevInfo->psRGXFWIfRuntimeCfg->ui32PowUnitsState,
+								  ui32PDumpFlags);
+
+		if (bRunTimeUpdate)
+		{
+			PDUMPELSE(psDevInfo->psDeviceNode, aszPowUnitsEnable, ui32PDumpFlags);
+			PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode, ui32PDumpFlags, "Read initial SPU mask value from HW registers");
+			PDumpRegRead32ToInternalVar(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME, RGX_CR_SPU_ENABLE, aszPowUnitsMaskRegVar, ui32PDumpFlags);
+			PDumpWriteVarANDValueOp(psDevInfo->psDeviceNode, aszPowUnitsMaskRegVar, ui32AllPowUnitsMask, ui32PDumpFlags);
+			PDumpInternalVarToMemLabel(psPMR, ui32DstOffset, aszPowUnitsMaskRegVar, ui32PDumpFlags);
+			PDUMPFI(psDevInfo->psDeviceNode, aszPowUnitsEnable, ui32PDumpFlags);
+		}
+	}
+#endif
 
 #if defined(SUPPORT_SECURITY_VALIDATION)
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
@@ -1664,7 +1612,11 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "(Set the log config here)");
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "( Log Type: set bit 0 for TRACE, reset for TBI)");
+				 "( Log Type: TRACE mode using shared memory buffer: 0x00000001)");
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "(           TBI mode via external interface or sim support: 0x00000000)");
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "(           Note: TBI mode will hang on most hardware devices!)");
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( MAIN Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_MAIN);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
@@ -1687,15 +1639,16 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 				 "( HWR Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_HWR);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( HWP Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_HWP);
-
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_DMA))
-	{
-		PDUMPCOMMENT(psDevInfo->psDeviceNode,
-					 "( DMA Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_DMA);
-	}
-
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( MISC Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_MISC);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( VZ Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_VZ);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( SAFETY Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_SAFETY);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( VERBOSE Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_VERBOSE);
+	PDUMPCOMMENT(psDevInfo->psDeviceNode,
+				 "( CUSTOMER Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_CUSTOMER);
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
 				 "( DEBUG Group Enable: 0x%08x)", RGXFWIF_LOG_TYPE_GROUP_DEBUG);
 	DevmemPDumpLoadMemValue32(psDevInfo->psRGXFWIfTraceBufCtlMemDesc,
@@ -1712,13 +1665,19 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 
 #if defined(SUPPORT_USER_REGISTER_CONFIGURATION)
 	PDUMPCOMMENT(psDevInfo->psDeviceNode,
-				 "(Number of registers configurations for types(byte index): pow on(%d), dust change(%d), ta(%d), 3d(%d), cdm(%d), tla(%d), TDM(%d))",
+				 "(Number of registers configurations for types(byte index): pow on(%d), dust change(%d), ta(%d), 3d(%d), cdm(%d), "
+#if defined(RGX_FEATURE_TLA_BIT_MASK)
+				 "tla(%d), "
+#endif
+				 "tdm(%d))",
 				 RGXFWIF_REG_CFG_TYPE_PWR_ON,
 				 RGXFWIF_REG_CFG_TYPE_DUST_CHANGE,
 				 RGXFWIF_REG_CFG_TYPE_TA,
 				 RGXFWIF_REG_CFG_TYPE_3D,
 				 RGXFWIF_REG_CFG_TYPE_CDM,
+#if defined(RGX_FEATURE_TLA_BIT_MASK)
 				 RGXFWIF_REG_CFG_TYPE_TLA,
+#endif
 				 RGXFWIF_REG_CFG_TYPE_TDM);
 
 	{
@@ -1757,7 +1716,7 @@ static void RGXPDumpLoadFWInitData(PVRSRV_RGXDEV_INFO *psDevInfo,
 
  @Description Allocate a Guard Page at the start of a Guest's Main Heap
 
- @Input       psDevceNode
+ @Input       psDevInfo
 
  @Return      PVRSRV_ERROR
 ******************************************************************************/
@@ -1789,31 +1748,21 @@ static PVRSRV_ERROR RGXSetupFwGuardPage(PVRSRV_RGXDEV_INFO *psDevInfo)
  @Return      PVRSRV_ERROR
 ******************************************************************************/
 static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
-									  IMG_BOOL                 bEnableSignatureChecks,
-									  IMG_UINT32               ui32SignatureChecksBufSize,
-									  IMG_UINT32               ui32HWPerfFWBufSizeKB,
-									  IMG_UINT64               ui64HWPerfFilter,
+									  RGX_INIT_APPHINTS        *psApphints,
 									  IMG_UINT32               ui32ConfigFlags,
 									  IMG_UINT32               ui32ConfigFlagsExt,
-									  IMG_UINT32               ui32LogType,
-									  IMG_UINT32               ui32FilterFlags,
-									  IMG_UINT32               ui32JonesDisableMask,
-									  IMG_UINT32               ui32HWPerfCountersDataSize,
-									  IMG_UINT32               *pui32TPUTrilinearFracMask,
-									  RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandConf,
-									  FW_PERF_CONF             eFirmwarePerf)
+									  IMG_UINT32               ui32HWPerfCountersDataSize)
 {
 	PVRSRV_ERROR eError;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	IMG_UINT32         ui32AllPowUnitsMask = (1 << psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount) - 1;
+	IMG_UINT32         ui32AllRACMask = (1 << psDevInfo->sDevFeatureCfg.ui32MAXRACCount) - 1;
+#endif
 	RGXFWIF_SYSINIT    *psFwSysInitScratch = NULL;
-#if defined(SUPPORT_VALIDATION)
-	/* Create AppHint reference handle for use in SUPPORT_VALIDATION case.
-	 * This is freed on exit from this routine.
-	 */
-	IMG_UINT32 ui32AppHintDefault = 0;
-	void *pvAppHintState = NULL;
-	OSCreateAppHintState(&pvAppHintState);
-#endif /* defined(SUPPORT_VALIDATION) */
+#if defined(PDUMP)
+	IMG_UINT32         ui32SignatureChecksBufSize = psApphints->ui32SignatureChecksBufSize;
+#endif
 
 	psFwSysInitScratch = OSAllocZMem(sizeof(*psFwSysInitScratch));
 	PVR_LOG_GOTO_IF_NOMEM(psFwSysInitScratch, eError, fail);
@@ -1843,51 +1792,72 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	{
 		RGX_DATA *psRGXData = (RGX_DATA*) psDeviceNode->psDevConfig->hDevData;
 		IMG_BOOL bSysEnableRDPowIsland = psRGXData->psRGXTimingInfo->bEnableRDPowIsland;
-		IMG_BOOL bEnableRDPowIsland = ((eRGXRDPowerIslandConf == RGX_RD_POWER_ISLAND_DEFAULT) && bSysEnableRDPowIsland) ||
-		                               (eRGXRDPowerIslandConf == RGX_RD_POWER_ISLAND_FORCE_ON);
+		IMG_BOOL bEnableRDPowIsland = ((psApphints->eRGXRDPowerIslandConf == RGX_RD_POWER_ISLAND_DEFAULT) && bSysEnableRDPowIsland) ||
+		                               (psApphints->eRGXRDPowerIslandConf == RGX_RD_POWER_ISLAND_FORCE_ON);
 
 		ui32ConfigFlags |= bEnableRDPowIsland? RGXFWIF_INICFG_POW_RASCALDUST : 0;
 	}
 
-#if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
+#if defined(SUPPORT_WORKLOAD_ESTIMATION)
 		ui32ConfigFlags |= RGXFWIF_INICFG_WORKEST;
-#if defined(SUPPORT_PDVFS)
+#endif
+#if defined(SUPPORT_FW_OPP_TABLE)
 		{
-			RGXFWIF_PDVFS_OPP   *psPDVFSOPPInfo;
+			RGXFWIF_OPP_INFO    *psOPPInfo;
 			IMG_DVFS_DEVICE_CFG *psDVFSDeviceCfg;
 
 			/* Pro-active DVFS depends on Workload Estimation */
-			psPDVFSOPPInfo = &psFwSysInitScratch->sPDVFSOPPInfo;
+			psOPPInfo = &psFwSysInitScratch->sOPPInfo;
 			psDVFSDeviceCfg = &psDeviceNode->psDevConfig->sDVFS.sDVFSDeviceCfg;
-			PVR_LOG_IF_FALSE(psDVFSDeviceCfg->pasOPPTable, "RGXSetupFwSysData: Missing OPP Table");
-
-			if (psDVFSDeviceCfg->pasOPPTable != NULL)
+#if defined(CONFIG_OF) && defined(CONFIG_PM_OPP) && !defined(NO_HARDWARE)
+			if (psDVFSDeviceCfg->bDTConfig)
 			{
-				if (psDVFSDeviceCfg->ui32OPPTableSize > ARRAY_SIZE(psPDVFSOPPInfo->asOPPValues))
+				/* OPP table configured from Device tree */
+				eError = DVFSCopyOPPTable(psDeviceNode,
+										  psOPPInfo,
+										  ARRAY_SIZE(psOPPInfo->asOPPValues));
+				if (eError != PVRSRV_OK)
 				{
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: OPP Table too large: Size = %u, Maximum size = %lu",
-							 __func__,
-							 psDVFSDeviceCfg->ui32OPPTableSize,
-							 (unsigned long)(ARRAY_SIZE(psPDVFSOPPInfo->asOPPValues))));
-					eError = PVRSRV_ERROR_INVALID_PARAMS;
+					PVR_DPF((PVR_DBG_ERROR, "Unable to copy OPP table to FW init buffer (%u)", eError));
 					goto fail;
 				}
+			}
+#endif
+			if (!psDVFSDeviceCfg->bDTConfig)
+			{
+				PVR_LOG_IF_FALSE(psDVFSDeviceCfg->pasOPPTable, "RGXSetupFwSysData: Missing OPP Table");
+
+				if (psDVFSDeviceCfg->pasOPPTable != NULL)
+				{
+					if (psDVFSDeviceCfg->ui32OPPTableSize > ARRAY_SIZE(psOPPInfo->asOPPValues))
+					{
+						PVR_DPF((PVR_DBG_ERROR,
+								 "%s: OPP Table too large: Size = %u, Maximum size = %lu",
+								 __func__,
+								 psDVFSDeviceCfg->ui32OPPTableSize,
+								 (unsigned long)(ARRAY_SIZE(psOPPInfo->asOPPValues))));
+						eError = PVRSRV_ERROR_INVALID_PARAMS;
+						goto fail;
+					}
 
-				OSDeviceMemCopy(psPDVFSOPPInfo->asOPPValues,
-								psDVFSDeviceCfg->pasOPPTable,
-								sizeof(psPDVFSOPPInfo->asOPPValues));
+					OSDeviceMemCopy(psOPPInfo->asOPPValues,
+									psDVFSDeviceCfg->pasOPPTable,
+									sizeof(psOPPInfo->asOPPValues));
 
-				psPDVFSOPPInfo->ui32MaxOPPPoint = psDVFSDeviceCfg->ui32OPPTableSize - 1;
+					psOPPInfo->ui32MaxOPPPoint = psDVFSDeviceCfg->ui32OPPTableSize - 1;
 
-				ui32ConfigFlags |= RGXFWIF_INICFG_PDVFS;
+				}
 			}
+
+#if defined(SUPPORT_PDVFS)
+			ui32ConfigFlags |= RGXFWIF_INICFG_PDVFS;
+#endif
 		}
-#endif /* defined(SUPPORT_PDVFS) */
+#endif /* defined(SUPPORT_FW_OPP_TABLE) */
 	}
-#endif /* defined(SUPPORT_WORKLOAD_ESTIMATION) */
 
 	/* FW trace control structure */
 	eError = RGXSetupFwAllocation(psDevInfo,
@@ -1904,15 +1874,15 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	if (!psDeviceNode->bAutoVzFwIsUp)
 	{
 		/* Set initial firmware log type/group(s) */
-		if (ui32LogType & ~RGXFWIF_LOG_TYPE_MASK)
+		if (psApphints->ui32LogType & ~RGXFWIF_LOG_TYPE_MASK)
 		{
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 			PVR_DPF((PVR_DBG_ERROR,
 			         "%s: Invalid initial log type (0x%X)",
-			         __func__, ui32LogType));
+			         __func__, psApphints->ui32LogType));
 			goto fail;
 		}
-		psDevInfo->psRGXFWIfTraceBufCtl->ui32LogType = ui32LogType;
+		psDevInfo->psRGXFWIfTraceBufCtl->ui32LogType = psApphints->ui32LogType;
 		RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfTraceBufCtl->ui32LogType, FLUSH);
 	}
 
@@ -1924,7 +1894,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 #if defined(SUPPORT_AUTOVZ)
 	/* always allocate trace buffer for AutoVz Host drivers to allow
 	 * deterministic addresses of all SysData structures */
-	if ((PVRSRV_VZ_MODE_IS(HOST)) || (RGXTraceBufferIsInitRequired(psDevInfo)))
+	if ((PVRSRV_VZ_MODE_IS(HOST, DEVINFO, psDevInfo)) || (RGXTraceBufferIsInitRequired(psDevInfo)))
 #else
 	if (RGXTraceBufferIsInitRequired(psDevInfo))
 #endif
@@ -1949,67 +1919,17 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 	/* GPIO validation setup */
 	psFwSysInitScratch->eGPIOValidationMode = RGXFWIF_GPIO_VAL_OFF;
-#if defined(SUPPORT_VALIDATION)
-	{
-		IMG_INT32 ui32GPIOValidationMode;
-
-		/* Check AppHint for GPIO validation mode */
-		ui32AppHintDefault = PVRSRV_APPHINT_GPIOVALIDATIONMODE;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE,
-		                   pvAppHintState,
-		                   GPIOValidationMode,
-		                   &ui32AppHintDefault,
-		                   &ui32GPIOValidationMode);
-
-		if (ui32GPIOValidationMode >= RGXFWIF_GPIO_VAL_LAST)
-		{
-			PVR_DPF((PVR_DBG_ERROR,
-			        "%s: Invalid GPIO validation mode: %d, only valid if smaller than %d. Disabling GPIO validation.",
-			        __func__,
-			        ui32GPIOValidationMode,
-			        RGXFWIF_GPIO_VAL_LAST));
-		}
-		else
-		{
-			psFwSysInitScratch->eGPIOValidationMode = (RGXFWIF_GPIO_VAL_MODE) ui32GPIOValidationMode;
-		}
-
-		psFwSysInitScratch->eGPIOValidationMode = ui32GPIOValidationMode;
-	}
-#endif
 
 #if defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS)
 	eError = RGXFWSetupCounterBuffer(psDevInfo,
 									 &psDevInfo->psCounterBufferMemDesc,
-									 PAGE_SIZE,
-									 &psFwSysInitScratch->sCounterDumpCtl,
-									 "CounterBuffer");
+									 OSGetPageSize(),
+									 &psFwSysInitScratch->sCounterDumpCtl);
 	PVR_LOG_GOTO_IF_ERROR(eError, "Counter Buffer allocation", fail);
-#endif /* defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS) */
 
-#if defined(SUPPORT_VALIDATION)
-	{
-		IMG_UINT32 ui32EnablePollOnChecksumErrorStatus;
-		ui32AppHintDefault = 0;
-
-		/* Check AppHint for polling on GPU Checksum status */
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE,
-		                   pvAppHintState,
-		                   EnablePollOnChecksumErrorStatus,
-		                   &ui32AppHintDefault,
-		                   &ui32EnablePollOnChecksumErrorStatus);
+	PVR_DPF((PVR_DBG_WARNING, "Counter buffer allocated at %p, size %zu Bytes.", psDevInfo->psCounterBufferMemDesc, OSGetPageSize()));
+#endif /* defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS) */
 
-		switch (ui32EnablePollOnChecksumErrorStatus)
-		{
-			case 0: /* no checking */ break;
-			case 3: psDevInfo->ui32ValidationFlags |= RGX_VAL_WGP_SIG_CHECK_NOERR_EN; break;
-			case 4: psDevInfo->ui32ValidationFlags |= RGX_VAL_WGP_SIG_CHECK_ERR_EN; break;
-			default:
-				PVR_DPF((PVR_DBG_WARNING, "Unsupported value in EnablePollOnChecksumErrorStatus (%d)", ui32EnablePollOnChecksumErrorStatus));
-				break;
-		}
-	}
-#endif /* defined(SUPPORT_VALIDATION) */
 
 #if defined(SUPPORT_FIRMWARE_GCOV)
 	eError = RGXFWSetupFirmwareGcovBuffer(psDevInfo,
@@ -2028,12 +1948,27 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		ui32SignatureChecksBufSize = RGXFW_SIG_BUFFER_SIZE_MIN;
 	}
 
-	/* Setup Signature and Checksum Buffers for TDM, GEOM and 3D */
+	/* Setup Signature and Checksum Buffers */
+	psDevInfo->psRGXFWSigTDMChecksMemDesc = NULL;
+	psDevInfo->ui32SigTDMChecksSize = 0;
+
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TDM_PDS_CHECKSUM))
+	{
+		/* Buffer allocated only when feature present because all known TDM
+		 * signature registers are dependent on this feature being present */
+		eError = RGXFWSetupSignatureChecks(psDevInfo,
+		                                   &psDevInfo->psRGXFWSigTDMChecksMemDesc,
+		                                   ui32SignatureChecksBufSize,
+		                                   &psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_TDM]);
+		PVR_LOG_GOTO_IF_ERROR(eError, "TDM Signature check setup", fail);
+		psDevInfo->ui32SigTDMChecksSize = ui32SignatureChecksBufSize;
+	}
+
 	eError = RGXFWSetupSignatureChecks(psDevInfo,
 	                                   &psDevInfo->psRGXFWSigTAChecksMemDesc,
 	                                   ui32SignatureChecksBufSize,
 	                                   &psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_GEOM]);
-	PVR_LOG_GOTO_IF_ERROR(eError, "TA Signature check setup", fail);
+	PVR_LOG_GOTO_IF_ERROR(eError, "GEOM Signature check setup", fail);
 	psDevInfo->ui32SigTAChecksSize = ui32SignatureChecksBufSize;
 
 	eError = RGXFWSetupSignatureChecks(psDevInfo,
@@ -2043,26 +1978,29 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	PVR_LOG_GOTO_IF_ERROR(eError, "3D Signature check setup", fail);
 	psDevInfo->ui32Sig3DChecksSize = ui32SignatureChecksBufSize;
 
-	psDevInfo->psRGXFWSigTDM2DChecksMemDesc = NULL;
-	psDevInfo->ui32SigTDM2DChecksSize = 0;
 
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TDM_PDS_CHECKSUM))
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, RAY_TRACING_ARCH) &&
+		RGX_GET_FEATURE_VALUE(psDevInfo, RAY_TRACING_ARCH) > 1)
 	{
-		/* Buffer allocated only when feature present because, all known TDM
-		 * signature registers are dependent on this feature being present */
 		eError = RGXFWSetupSignatureChecks(psDevInfo,
-		                                   &psDevInfo->psRGXFWSigTDM2DChecksMemDesc,
+		                                   &psDevInfo->psRGXFWSigRDMChecksMemDesc,
 		                                   ui32SignatureChecksBufSize,
-		                                   &psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_TDM]);
-		PVR_LOG_GOTO_IF_ERROR(eError, "TDM Signature check setup", fail);
-		psDevInfo->ui32SigTDM2DChecksSize = ui32SignatureChecksBufSize;
+		                                   &psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_RAY]);
+		PVR_LOG_GOTO_IF_ERROR(eError, "RDM Signature check setup", fail);
+		psDevInfo->ui32SigRDMChecksSize = ui32SignatureChecksBufSize;
 	}
+#endif
 
-	if (!bEnableSignatureChecks)
+	if (!psApphints->bEnableSignatureChecks)
 	{
 		psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_TDM].sBuffer.ui32Addr = 0x0;
 		psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_GEOM].sBuffer.ui32Addr = 0x0;
 		psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_3D].sBuffer.ui32Addr = 0x0;
+		psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_CDM].sBuffer.ui32Addr = 0x0;
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+		psFwSysInitScratch->asSigBufCtl[RGXFWIF_DM_RAY].sBuffer.ui32Addr = 0x0;
+#endif
 	}
 #endif /* defined(PDUMP) */
 
@@ -2070,14 +2008,11 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	                               &psFwSysInitScratch->sAlignChecks);
 	PVR_LOG_GOTO_IF_ERROR(eError, "Alignment checks setup", fail);
 
-	psFwSysInitScratch->ui32FilterFlags = ui32FilterFlags;
+	psFwSysInitScratch->ui32FilterFlags = psApphints->ui32FilterFlags;
 
 	/* Fill the remaining bits of fw the init data */
 	psFwSysInitScratch->sPDSExecBase.uiAddr = RGX_PDSCODEDATA_HEAP_BASE;
 	psFwSysInitScratch->sUSCExecBase.uiAddr = RGX_USCCODE_HEAP_BASE;
-	psFwSysInitScratch->sFBCDCStateTableBase.uiAddr = RGX_FBCDC_HEAP_BASE;
-	psFwSysInitScratch->sFBCDCLargeStateTableBase.uiAddr = RGX_FBCDC_LARGE_HEAP_BASE;
-	psFwSysInitScratch->sTextureHeapBase.uiAddr = RGX_TEXTURE_STATE_HEAP_BASE;
 
 #if defined(FIX_HW_BRN_65273_BIT_MASK)
 	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65273))
@@ -2088,17 +2023,6 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	}
 #endif
 
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		psFwSysInitScratch->ui32JonesDisableMask = ui32JonesDisableMask;
-	}
-#if defined(RGX_FEATURE_SLC_VIVT_BIT_MASK)
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, SLC_VIVT))
-	{
-		eError = _AllocateSLC3Fence(psDevInfo, psFwSysInitScratch);
-		PVR_LOG_GOTO_IF_ERROR(eError, "SLC3Fence memory allocation", fail);
-	}
-#endif
 #if defined(SUPPORT_PDVFS)
 	/* Core clock rate */
 	eError = RGXSetupFwAllocation(psDevInfo,
@@ -2238,11 +2162,11 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 								  (RGX_FWSHAREDMEM_CPU_RO_ALLOCFLAGS |
 								  PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(FIRMWARE_CACHED)) &
 								  RGX_AUTOVZ_KEEP_FW_DATA_MASK(psDeviceNode->bAutoVzFwIsUp),
-								  sizeof(RGXFWIF_GPU_UTIL_FWCB),
+								  sizeof(RGXFWIF_GPU_UTIL_FW),
 								  "FwGPUUtilisationBuffer",
-								  &psDevInfo->psRGXFWIfGpuUtilFWCbCtlMemDesc,
-								  &psFwSysInitScratch->sGpuUtilFWCbCtl,
-								  (void**) &psDevInfo->psRGXFWIfGpuUtilFWCb,
+								  &psDevInfo->psRGXFWIfGpuUtilFWCtlMemDesc,
+								  &psFwSysInitScratch->sGpuUtilFWCtl,
+								  (void**) &psDevInfo->psRGXFWIfGpuUtilFW,
 								  RFW_FWADDR_NOREF_FLAG);
 	PVR_LOG_GOTO_IF_ERROR(eError, "GPU Utilisation Buffer ctl allocation", fail);
 
@@ -2259,7 +2183,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 #if defined(SUPPORT_USER_REGISTER_CONFIGURATION)
 	eError = RGXSetupFwAllocation(psDevInfo,
-								  RGX_FWSHAREDMEM_MAIN_ALLOCFLAGS &
+								  RGX_FWSHAREDMEM_CPU_RO_ALLOCFLAGS &
 								  RGX_AUTOVZ_KEEP_FW_DATA_MASK(psDeviceNode->bAutoVzFwIsUp),
 								  sizeof(RGXFWIF_REG_CFG),
 								  "FwRegisterConfigStructure",
@@ -2283,7 +2207,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	PVR_LOG_GOTO_IF_ERROR(eError, "Firmware scratch buffer allocation", fail);
 #endif
 
-	psDevInfo->ui32RGXFWIfHWPerfBufSize = GetHwPerfBufferSize(ui32HWPerfFWBufSizeKB);
+	psDevInfo->ui32RGXFWIfHWPerfBufSize = GetHwPerfBufferSize(psApphints->ui32HWPerfFWBufSize);
 
 	/* Host L2 HWPERF buffer size in bytes must be bigger than the L1 buffer
 	 * accessed by the FW. The MISR may try to write one packet the size of the L1
@@ -2302,7 +2226,8 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	{
 		psFwSysInitScratch->ui64HWPerfFilter =
 		    RGXHWPerfFwSetEventFilter(psDevInfo, RGX_HWPERF_L2_STREAM_HWPERF,
-		                              ui64HWPerfFilter);
+		                              (IMG_UINT64) psApphints->ui32HWPerfFilter0 |
+		                              ((IMG_UINT64) psApphints->ui32HWPerfFilter1 << 32));
 	}
 	else
 	{
@@ -2341,7 +2266,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	psDevInfo->bPDPEnabled = (ui32ConfigFlags & RGXFWIF_INICFG_DISABLE_PDP_EN)
 							  ? IMG_FALSE : IMG_TRUE;
 
-	psFwSysInitScratch->eFirmwarePerf = eFirmwarePerf;
+	psFwSysInitScratch->eFirmwarePerf = psApphints->eFirmwarePerf;
 
 #if defined(PDUMP)
 	/* default: no filter */
@@ -2349,17 +2274,6 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	psFwSysInitScratch->sPIDFilter.asItems[0].uiPID = 0;
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	{
-		IMG_UINT32 dm;
-
-		/* TPU trilinear rounding mask override */
-		for (dm = 0; dm < RGXFWIF_TPU_DM_LAST; dm++)
-		{
-			psFwSysInitScratch->aui32TPUTrilinearFracMask[dm] = pui32TPUTrilinearFracMask[dm];
-		}
-	}
-#endif
 
 #if defined(SUPPORT_SECURITY_VALIDATION)
 	{
@@ -2370,7 +2284,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		eError = DevmemFwAllocateExportable(psDeviceNode,
 											OSGetPageSize(),
 											OSGetPageSize(),
-											RGX_FWSHAREDMEM_MAIN_ALLOCFLAGS,
+											RGX_FWSHAREDMEM_CPU_RO_ALLOCFLAGS,
 											"FwExNonSecureBuffer",
 											&psDevInfo->psRGXFWIfNonSecureBufMemDesc);
 		PVR_LOG_GOTO_IF_ERROR(eError, "Non-secure buffer allocation", fail);
@@ -2402,7 +2316,7 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		psFwSysInitScratch->ui32TFBCCompressionControl =
 			(ui32ConfigFlagsExt & RGXFWIF_INICFG_EXT_TFBC_CONTROL_MASK) >> RGXFWIF_INICFG_EXT_TFBC_CONTROL_SHIFT;
 	}
-#endif /* SUPPORT_SECURITY_VALIDATION */
+#endif /* RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK */
 
 	/* Initialize FW started flag */
 	psFwSysInitScratch->bFirmwareStarted = IMG_FALSE;
@@ -2418,10 +2332,16 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 		/* Required info by FW to calculate the ActivePM idle timer latency */
 		psFwSysInitScratch->ui32InitialCoreClockSpeed = psRGXData->psRGXTimingInfo->ui32CoreClockSpeed;
+#if defined(SUPPORT_SOC_TIMER)
+		psFwSysInitScratch->ui32InitialSOCClockSpeed = psRGXData->psRGXTimingInfo->ui32SOCClockSpeed;
+#endif
 		psFwSysInitScratch->ui32InitialActivePMLatencyms = psRGXData->psRGXTimingInfo->ui32ActivePMLatencyms;
 
 		/* Initialise variable runtime configuration to the system defaults */
 		psRuntimeCfg->ui32CoreClockSpeed = psFwSysInitScratch->ui32InitialCoreClockSpeed;
+#if defined(SUPPORT_SOC_TIMER)
+		psRuntimeCfg->ui32SOCClockSpeed = psFwSysInitScratch->ui32InitialSOCClockSpeed;
+#endif
 		psRuntimeCfg->ui32ActivePMLatencyms = psFwSysInitScratch->ui32InitialActivePMLatencyms;
 		psRuntimeCfg->bActivePMLatencyPersistant = IMG_TRUE;
 		psRuntimeCfg->ui32HCSDeadlineMS = RGX_HCS_DEFAULT_DEADLINE_MS;
@@ -2438,76 +2358,70 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 			psRuntimeCfg->ui32WdgPeriodUs = RGXFW_SAFETY_WATCHDOG_PERIOD_IN_US;
 		}
 
-		if (PVRSRV_VZ_MODE_IS(NATIVE))
+		if (PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo))
 		{
-			psRuntimeCfg->aui32DriverPriority[RGXFW_HOST_DRIVER_ID] = 0;
+			psRuntimeCfg->ai32DriverPriority[RGXFW_HOST_DRIVER_ID] = 0;
 			psRuntimeCfg->aui32DriverIsolationGroup[RGXFW_HOST_DRIVER_ID] = RGX_DRIVERID_0_DEFAULT_ISOLATION_GROUP;
-			psRuntimeCfg->aui32DriverTimeSlice[RGXFW_HOST_DRIVER_ID] = (IMG_UINT8)RGX_DRIVERID_0_DEFAULT_TIME_SLICE;
+			psRuntimeCfg->aui32TSPercentage[RGXFW_HOST_DRIVER_ID] = (IMG_UINT8)RGX_DRIVERID_0_DEFAULT_TIME_SLICE;
 		}
 		else
 		{
-			FOREACH_SUPPORTED_DRIVER(ui32DriverID)
-			{
-				const IMG_INT32 ai32DefaultPriorities[RGXFW_MAX_NUM_OSIDS] =
-					{RGX_DRIVERID_0_DEFAULT_PRIORITY,
+			const RGX_QOS_DEFAULTS asQosDefaults[RGXFW_MAX_NUM_OSIDS] = {
+					RGX_QOS_DEFAULTS_INIT(0),
 #if (RGXFW_MAX_NUM_OSIDS > 1)
-					 RGX_DRIVERID_1_DEFAULT_PRIORITY,
+					RGX_QOS_DEFAULTS_INIT(1),
 #if (RGXFW_MAX_NUM_OSIDS > 2)
-					 RGX_DRIVERID_2_DEFAULT_PRIORITY,
-					 RGX_DRIVERID_3_DEFAULT_PRIORITY,
-					 RGX_DRIVERID_4_DEFAULT_PRIORITY,
-					 RGX_DRIVERID_5_DEFAULT_PRIORITY,
-					 RGX_DRIVERID_6_DEFAULT_PRIORITY,
-					 RGX_DRIVERID_7_DEFAULT_PRIORITY
+					RGX_QOS_DEFAULTS_INIT(2),
+					RGX_QOS_DEFAULTS_INIT(3),
+					RGX_QOS_DEFAULTS_INIT(4),
+					RGX_QOS_DEFAULTS_INIT(5),
+					RGX_QOS_DEFAULTS_INIT(6),
+					RGX_QOS_DEFAULTS_INIT(7),
 #if (RGXFW_MAX_NUM_OSIDS > 8)
-#error "Support for more than 8 OSIDs not implemented."
-#endif
-#endif
-#endif
-					};
-
-				const IMG_UINT32 aui32DefaultIsolationGroups[RGXFW_MAX_NUM_OSIDS] =
-					{RGX_DRIVERID_0_DEFAULT_ISOLATION_GROUP,
-#if (RGXFW_MAX_NUM_OSIDS > 1)
-					 RGX_DRIVERID_1_DEFAULT_ISOLATION_GROUP,
-#if (RGXFW_MAX_NUM_OSIDS > 2)
-					 RGX_DRIVERID_2_DEFAULT_ISOLATION_GROUP,
-					 RGX_DRIVERID_3_DEFAULT_ISOLATION_GROUP,
-					 RGX_DRIVERID_4_DEFAULT_ISOLATION_GROUP,
-					 RGX_DRIVERID_5_DEFAULT_ISOLATION_GROUP,
-					 RGX_DRIVERID_6_DEFAULT_ISOLATION_GROUP,
-					 RGX_DRIVERID_7_DEFAULT_ISOLATION_GROUP,
+					RGX_QOS_DEFAULTS_INIT(8),
+					RGX_QOS_DEFAULTS_INIT(9),
+					RGX_QOS_DEFAULTS_INIT(10),
+					RGX_QOS_DEFAULTS_INIT(11),
+					RGX_QOS_DEFAULTS_INIT(12),
+					RGX_QOS_DEFAULTS_INIT(13),
+					RGX_QOS_DEFAULTS_INIT(14),
+					RGX_QOS_DEFAULTS_INIT(15),
+					RGX_QOS_DEFAULTS_INIT(16),
+					RGX_QOS_DEFAULTS_INIT(17),
+					RGX_QOS_DEFAULTS_INIT(18),
+					RGX_QOS_DEFAULTS_INIT(19),
+					RGX_QOS_DEFAULTS_INIT(20),
+					RGX_QOS_DEFAULTS_INIT(21),
+					RGX_QOS_DEFAULTS_INIT(22),
+					RGX_QOS_DEFAULTS_INIT(23),
+					RGX_QOS_DEFAULTS_INIT(24),
+					RGX_QOS_DEFAULTS_INIT(25),
+					RGX_QOS_DEFAULTS_INIT(26),
+					RGX_QOS_DEFAULTS_INIT(27),
+					RGX_QOS_DEFAULTS_INIT(28),
+					RGX_QOS_DEFAULTS_INIT(29),
+					RGX_QOS_DEFAULTS_INIT(30),
+					RGX_QOS_DEFAULTS_INIT(31),
+#if (RGXFW_MAX_NUM_OSIDS > 32)
+#error "Support for more than 32 OSIDs not implemented."
 #endif
-#endif
-					};
+#endif /* RGXFW_MAX_NUM_OSIDS > 8 */
+#endif /* RGXFW_MAX_NUM_OSIDS > 2 */
 
-				const IMG_INT32 ai32DefaultTimeSlice[RGXFW_MAX_NUM_OSIDS] =
-					{RGX_DRIVERID_0_DEFAULT_TIME_SLICE,
-#if (RGXFW_MAX_NUM_OSIDS > 1)
-					 RGX_DRIVERID_1_DEFAULT_TIME_SLICE,
-#if (RGXFW_MAX_NUM_OSIDS > 2)
-					 RGX_DRIVERID_2_DEFAULT_TIME_SLICE,
-					 RGX_DRIVERID_3_DEFAULT_TIME_SLICE,
-					 RGX_DRIVERID_4_DEFAULT_TIME_SLICE,
-					 RGX_DRIVERID_5_DEFAULT_TIME_SLICE,
-					 RGX_DRIVERID_6_DEFAULT_TIME_SLICE,
-					 RGX_DRIVERID_7_DEFAULT_TIME_SLICE
-#if (RGXFW_MAX_NUM_OSIDS > 8)
-#error "Support for more than 8 OSIDs not implemented."
-#endif
-#endif
-#endif
-					};
+#endif /* RGXFW_MAX_NUM_OSIDS > 1 */
+			};
 
+			FOREACH_SUPPORTED_DRIVER(ui32DriverID)
+			{
 				/* Set up initial priorities between different OSes */
-				psRuntimeCfg->aui32DriverPriority[ui32DriverID] = (IMG_UINT32)ai32DefaultPriorities[ui32DriverID];
-				psRuntimeCfg->aui32DriverIsolationGroup[ui32DriverID] = aui32DefaultIsolationGroups[ui32DriverID];
-				psRuntimeCfg->aui32DriverTimeSlice[ui32DriverID] = (IMG_UINT32)(ai32DefaultTimeSlice[ui32DriverID] <=
+				psRuntimeCfg->ai32DriverPriority[ui32DriverID] = asQosDefaults[ui32DriverID].i32Priority;
+				psRuntimeCfg->aui32DriverIsolationGroup[ui32DriverID] = asQosDefaults[ui32DriverID].ui32IsolationGroups;
+				psRuntimeCfg->aui32TSPercentage[ui32DriverID] = (asQosDefaults[ui32DriverID].ui32TSPercentage <=
 																				PVRSRV_VZ_TIME_SLICE_MAX) ?
-																				ai32DefaultTimeSlice[ui32DriverID]:(0);
+																				asQosDefaults[ui32DriverID].ui32TSPercentage:(0);
 			}
 		}
-		psRuntimeCfg->ui32DriverTimeSliceInterval = RGX_DRIVER_DEFAULT_TIME_SLICE_INTERVAL;
+		psRuntimeCfg->ui32TSIntervalMs = RGX_DRIVER_DEFAULT_TIME_SLICE_INTERVAL;
 
 #if defined(PVR_ENABLE_PHR) && defined(PDUMP)
 		psRuntimeCfg->ui32PHRMode = RGXFWIF_PHR_MODE_RD_RESET;
@@ -2515,8 +2429,8 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		psRuntimeCfg->ui32PHRMode = 0;
 #endif
 
-		/* Initialize the DefaultDustsNumInit Field to Max Dusts */
-		psRuntimeCfg->ui32DefaultDustsNumInit = psDevInfo->sDevFeatureCfg.ui32MAXDustCount;
+		/* Initialize the PowUnitsState Field to Max Dusts */
+		psRuntimeCfg->ui32PowUnitsState = psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount;
 
 		/* flush write buffers for psDevInfo->psRGXFWIfRuntimeCfg */
 		OSWriteMemoryBarrier(psDevInfo->psRGXFWIfRuntimeCfg);
@@ -2526,14 +2440,6 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		if (psDevInfo->psRGXFWIfCorememDataStoreMemDesc)
 		{
 			psFwSysInitScratch->sCorememDataStore.pbyFWAddr = psDevInfo->sFWCorememDataStoreFWAddr;
-
-			if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_DMA))
-			{
-				RGXSetMetaDMAAddress(&psFwSysInitScratch->sCorememDataStore,
-									 psDevInfo->psRGXFWIfCorememDataStoreMemDesc,
-									 &psFwSysInitScratch->sCorememDataStore.pbyFWAddr,
-									 0);
-			}
 		}
 
 		psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags    = ui32ConfigFlags    & RGXFWIF_INICFG_ALL;
@@ -2543,19 +2449,23 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		{
 			IMG_UINT64 ui64LastWord = RGXFWIF_GPU_UTIL_MAKE_WORD(OSClockns64(), RGXFWIF_GPU_UTIL_STATE_IDLE);
 			RGXFWIF_DM eDM;
+			IMG_UINT64 ui64LastWordTimeShifted =
+			        RGXFWIF_GPU_UTIL_MAKE_WORD(OSClockns64() >> RGXFWIF_DM_OS_TIMESTAMP_SHIFT, RGXFWIF_GPU_UTIL_STATE_IDLE);
+			IMG_UINT32 ui32DriverID;
 
-			psDevInfo->psRGXFWIfGpuUtilFWCb->ui64GpuLastWord = ui64LastWord;
+			psDevInfo->psRGXFWIfGpuUtilFW->ui64GpuLastWord = ui64LastWord;
 
-			for (eDM = 0; eDM < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; eDM++)
+			FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 			{
-				IMG_UINT32 ui32DriverID;
+				RGXFWIF_GPU_STATS *psStats = &psDevInfo->psRGXFWIfGpuUtilFW->sStats[ui32DriverID];
 
-				FOREACH_SUPPORTED_DRIVER(ui32DriverID)
+				for (eDM = 0; eDM < RGXFWIF_GPU_UTIL_DM_MAX; eDM++)
 				{
-					psDevInfo->psRGXFWIfGpuUtilFWCb->aaui64DMOSLastWord[eDM][ui32DriverID] = ui64LastWord;
+					psStats->aui32DMOSLastWord[eDM] = (IMG_UINT32)(ui64LastWordTimeShifted & IMG_UINT32_MAX);
+					psStats->aui32DMOSLastWordWrap[eDM] = (IMG_UINT32)(ui64LastWordTimeShifted >> 32);
 				}
 			}
-			RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFWCb, FLUSH);
+			RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFW, FLUSH);
 		}
 
 		/* init HWPERF data */
@@ -2586,9 +2496,6 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 	OSFreeMem(psFwSysInitScratch);
 
-#if defined(SUPPORT_VALIDATION)
-	OSFreeAppHintState(pvAppHintState);
-#endif
 
 	return PVRSRV_OK;
 
@@ -2601,9 +2508,6 @@ static PVRSRV_ERROR RGXSetupFwSysData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	RGXFreeFwSysData(psDevInfo);
 
 	PVR_ASSERT(eError != PVRSRV_OK);
-#if defined(SUPPORT_VALIDATION)
-	OSFreeAppHintState(pvAppHintState);
-#endif
 	return eError;
 }
 
@@ -2628,7 +2532,7 @@ static PVRSRV_ERROR RGXSetupFwOsData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 	OSCachedMemSet(&sFwOsInitScratch, 0, sizeof(RGXFWIF_OSINIT));
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = RGXSetupFwGuardPage(psDevInfo);
 		PVR_LOG_GOTO_IF_ERROR(eError, "Setting up firmware heap guard pages", fail);
@@ -2748,7 +2652,7 @@ static PVRSRV_ERROR RGXSetupFwOsData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	sFwOsInitScratch.ui32HWRDebugDumpLimit = ui32HWRDebugDumpLimit;
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Set up Workload Estimation firmware CCB */
 		eError = RGXSetupCCB(psDevInfo,
@@ -2767,7 +2671,7 @@ static PVRSRV_ERROR RGXSetupFwOsData(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	}
 #endif /* defined(SUPPORT_WORKLOAD_ESTIMATION) */
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Initialise the compatibility check data */
 		RGXFWIF_COMPCHECKS_BVNC_INIT(sFwOsInitScratch.sRGXCompChecks.sFWBVNC);
@@ -2799,33 +2703,24 @@ static PVRSRV_ERROR RGXSetupFwOsData(PVRSRV_DEVICE_NODE       *psDeviceNode,
  @Return      PVRSRV_ERROR
 ******************************************************************************/
 PVRSRV_ERROR RGXSetupFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
-							  IMG_BOOL                 bEnableSignatureChecks,
-							  IMG_UINT32               ui32SignatureChecksBufSize,
-							  IMG_UINT32               ui32HWPerfFWBufSizeKB,
-							  IMG_UINT64               ui64HWPerfFilter,
+							  RGX_INIT_APPHINTS        *psApphints,
 							  IMG_UINT32               ui32ConfigFlags,
 							  IMG_UINT32               ui32ConfigFlagsExt,
-							  IMG_UINT32               ui32FwOsCfgFlags,
-							  IMG_UINT32               ui32LogType,
-							  IMG_UINT32               ui32FilterFlags,
-							  IMG_UINT32               ui32JonesDisableMask,
-							  IMG_UINT32               ui32HWRDebugDumpLimit,
-							  IMG_UINT32               ui32HWPerfCountersDataSize,
-							  IMG_UINT32               *pui32TPUTrilinearFracMask,
-							  RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandConf,
-							  FW_PERF_CONF             eFirmwarePerf,
-							  IMG_UINT32               ui32KCCBSizeLog2)
+							  IMG_UINT32               ui32FwOsCfgFlags)
 {
 	PVRSRV_ERROR eError;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	IMG_UINT32 ui32HWPerfCountersDataSize;
 
 	eError = RGXSetupFwOsData(psDeviceNode,
-							  ui32KCCBSizeLog2,
-							  ui32HWRDebugDumpLimit,
+							  psApphints->ui32KCCBSizeLog2,
+							  psApphints->ui32HWRDebugDumpLimit,
 							  ui32FwOsCfgFlags);
 	PVR_LOG_GOTO_IF_ERROR(eError, "Setting up firmware os data", fail);
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	ui32HWPerfCountersDataSize = sizeof(RGXFWIF_HWPERF_CTL);
+
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Guest drivers do not configure system-wide firmware data */
 		psDevInfo->psRGXFWIfSysInit = NULL;
@@ -2834,19 +2729,10 @@ PVRSRV_ERROR RGXSetupFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 	{
 		/* Native and Host drivers must initialise the firmware's system data */
 		eError = RGXSetupFwSysData(psDeviceNode,
-								   bEnableSignatureChecks,
-								   ui32SignatureChecksBufSize,
-								   ui32HWPerfFWBufSizeKB,
-								   ui64HWPerfFilter,
+								   psApphints,
 								   ui32ConfigFlags,
 								   ui32ConfigFlagsExt,
-								   ui32LogType,
-								   ui32FilterFlags,
-								   ui32JonesDisableMask,
-								   ui32HWPerfCountersDataSize,
-								   pui32TPUTrilinearFracMask,
-								   eRGXRDPowerIslandConf,
-								   eFirmwarePerf);
+								   ui32HWPerfCountersDataSize);
 		PVR_LOG_GOTO_IF_ERROR(eError, "Setting up firmware system data", fail);
 	}
 
@@ -2854,8 +2740,8 @@ PVRSRV_ERROR RGXSetupFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 #if defined(PDUMP)
 	RGXPDumpLoadFWInitData(psDevInfo,
-	                       ui32HWPerfCountersDataSize,
-	                       bEnableSignatureChecks);
+	                       psApphints,
+	                       ui32HWPerfCountersDataSize);
 #endif /* PDUMP */
 
 fail:
@@ -2881,10 +2767,10 @@ static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo)
 
 #if defined(PDUMP)
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TDM_PDS_CHECKSUM) &&
-	    psDevInfo->psRGXFWSigTDM2DChecksMemDesc)
+	    psDevInfo->psRGXFWSigTDMChecksMemDesc)
 	{
-		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWSigTDM2DChecksMemDesc);
-		psDevInfo->psRGXFWSigTDM2DChecksMemDesc = NULL;
+		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWSigTDMChecksMemDesc);
+		psDevInfo->psRGXFWSigTDMChecksMemDesc = NULL;
 	}
 
 	if (psDevInfo->psRGXFWSigTAChecksMemDesc)
@@ -2898,6 +2784,16 @@ static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo)
 		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWSig3DChecksMemDesc);
 		psDevInfo->psRGXFWSig3DChecksMemDesc = NULL;
 	}
+
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, RAY_TRACING_ARCH) &&
+		RGX_GET_FEATURE_VALUE(psDevInfo, RAY_TRACING_ARCH) > 1 &&
+	   psDevInfo->psRGXFWSigRDMChecksMemDesc)
+	{
+		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWSigRDMChecksMemDesc);
+		psDevInfo->psRGXFWSigRDMChecksMemDesc = NULL;
+	}
+#endif
 #endif
 
 #if defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS)
@@ -2918,15 +2814,15 @@ static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo)
 
 	RGXSetupFaultReadRegisterRollback(psDevInfo);
 
-	if (psDevInfo->psRGXFWIfGpuUtilFWCbCtlMemDesc)
+	if (psDevInfo->psRGXFWIfGpuUtilFWCtlMemDesc)
 	{
-		if (psDevInfo->psRGXFWIfGpuUtilFWCb != NULL)
+		if (psDevInfo->psRGXFWIfGpuUtilFW != NULL)
 		{
-			DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWIfGpuUtilFWCbCtlMemDesc);
-			psDevInfo->psRGXFWIfGpuUtilFWCb = NULL;
+			DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWIfGpuUtilFWCtlMemDesc);
+			psDevInfo->psRGXFWIfGpuUtilFW = NULL;
 		}
-		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWIfGpuUtilFWCbCtlMemDesc);
-		psDevInfo->psRGXFWIfGpuUtilFWCbCtlMemDesc = NULL;
+		DevmemFwUnmapAndFree(psDevInfo, psDevInfo->psRGXFWIfGpuUtilFWCtlMemDesc);
+		psDevInfo->psRGXFWIfGpuUtilFWCtlMemDesc = NULL;
 	}
 
 	if (psDevInfo->psRGXFWIfRuntimeCfgMemDesc)
@@ -2940,9 +2836,12 @@ static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo)
 		psDevInfo->psRGXFWIfRuntimeCfgMemDesc = NULL;
 	}
 
-	if (psDevInfo->psRGXFWIfCorememDataStoreMemDesc)
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META_COREMEM_SIZE))
 	{
-		psDevInfo->psRGXFWIfCorememDataStoreMemDesc = NULL;
+		if (psDevInfo->psRGXFWIfCorememDataStoreMemDesc)
+		{
+			psDevInfo->psRGXFWIfCorememDataStoreMemDesc = NULL;
+		}
 	}
 
 	if (psDevInfo->psRGXFWIfTraceBufCtlMemDesc)
@@ -3005,12 +2904,6 @@ static void RGXFreeFwSysData(PVRSRV_RGXDEV_INFO *psDevInfo)
 	}
 #endif
 
-#if defined(RGX_FEATURE_SLC_VIVT_BIT_MASK)
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, SLC_VIVT))
-	{
-		_FreeSLC3Fence(psDevInfo);
-	}
-#endif
 #if defined(SUPPORT_PDVFS)
 	if (psDevInfo->psRGXFWIFCoreClkRateMemDesc)
 	{
@@ -3063,7 +2956,7 @@ static void RGXFreeFwOsData(PVRSRV_RGXDEV_INFO *psDevInfo)
 	           &psDevInfo->psFirmwareCCBMemDesc);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		RGXFreeCCB(psDevInfo,
 		           &psDevInfo->psWorkEstFirmwareCCBCtl,
@@ -3269,10 +3162,10 @@ static PVRSRV_ERROR RGXAcquireKernelCCBSlot(PVRSRV_RGXDEV_INFO *psDevInfo,
 #if defined(PDUMP)
 	/* Wait for sufficient CCB space to become available */
 	PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode, 0,
-	                      "Wait for kCCB woff=%u", ui32NextWriteOffset);
+	                      "Wait for space to write kCCB woff=%u", psKCCBCtlLocal->ui32WriteOffset);
 	DevmemPDumpCBP(psDevInfo->psKernelCCBCtlMemDesc,
 	               offsetof(RGXFWIF_CCB_CTL, ui32ReadOffset),
-	               ui32NextWriteOffset,
+	               psKCCBCtlLocal->ui32WriteOffset,
 	               1,
 	               (psKCCBCtlLocal->ui32WrapMask + 1));
 #endif
@@ -3313,7 +3206,7 @@ static PVRSRV_ERROR RGXPollKernelCCBSlot(PVRSRV_RGXDEV_INFO *psDevInfo)
 		return PVRSRV_OK;
 	}
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		PVRSRV_ERROR eError = RGXUpdateLocalKCCBRoff(psDevInfo);
 		PVR_LOG_RETURN_IF_ERROR(eError, "RGXUpdateLocalKCCBRoff");
@@ -3333,7 +3226,7 @@ static PVRSRV_ERROR RGXPollKernelCCBSlot(PVRSRV_RGXDEV_INFO *psDevInfo)
 		}
 
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return PVRSRV_ERROR_KERNEL_CCB_FULL;
 }
@@ -3464,22 +3357,19 @@ static IMG_UINT32 RGXGetCmdMemCopySize(RGXFWIF_KCCB_CMD_TYPE eCmdType)
 		case RGXFWIF_KCCB_CMD_WDG_CFG:
 		case RGXFWIF_KCCB_CMD_PHR_CFG:
 		case RGXFWIF_KCCB_CMD_HEALTH_CHECK:
-		case RGXFWIF_KCCB_CMD_LOGTYPE_UPDATE:
 		case RGXFWIF_KCCB_CMD_STATEFLAGS_CTRL:
 		{
 			/* No command specific data */
 			return offsetof(RGXFWIF_KCCB_CMD, uCmdData);
 		}
-#if defined(SUPPORT_VALIDATION)
-		case RGXFWIF_KCCB_CMD_RGXREG:
+		case RGXFWIF_KCCB_CMD_LOGTYPE_UPDATE:
 		{
-			return offsetof(RGXFWIF_KCCB_CMD, uCmdData) + sizeof(RGXFWIF_RGXREG_DATA);
+			return offsetof(RGXFWIF_KCCB_CMD, uCmdData) + sizeof(RGXFWIF_DEV_VIRTADDR);
 		}
-		case RGXFWIF_KCCB_CMD_GPUMAP:
+		case RGXFWIF_KCCB_CMD_CANCEL_WORK:
 		{
-			return offsetof(RGXFWIF_KCCB_CMD, uCmdData) + sizeof(RGXFWIF_GPUMAP_DATA);
+			return offsetof(RGXFWIF_KCCB_CMD, uCmdData) + sizeof(RGXFWIF_CANCEL_WORK_DATA);
 		}
-#endif
 		default:
 		{
 			/* Invalid (OR) Unused (OR) Newly added command type */
@@ -3589,18 +3479,26 @@ static PVRSRV_ERROR RGXSendCommandRaw(PVRSRV_RGXDEV_INFO  *psDevInfo,
 #if defined(SUPPORT_AUTOVZ)
 	KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 	KM_CONNECTION_CACHEOP(Os, INVALIDATE);
-	if (!((KM_FW_CONNECTION_IS(READY, psDevInfo) && KM_OS_CONNECTION_IS(READY, psDevInfo)) ||
-		(KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) && KM_OS_CONNECTION_IS(ACTIVE, psDevInfo))) &&
-		!PVRSRV_VZ_MODE_IS(NATIVE))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: The firmware-driver connection is invalid:"
-								"driver state = %u / firmware state = %u;"
-								"expected READY (%u/%u) or ACTIVE (%u/%u);",
-								__func__, KM_GET_OS_CONNECTION(psDevInfo), KM_GET_FW_CONNECTION(psDevInfo),
-								RGXFW_CONNECTION_OS_READY, RGXFW_CONNECTION_FW_READY,
-								RGXFW_CONNECTION_OS_ACTIVE, RGXFW_CONNECTION_FW_ACTIVE));
-		eError = PVRSRV_ERROR_PVZ_OSID_IS_OFFLINE;
-		goto _RGXSendCommandRaw_Exit;
+	if (!PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode))
+	{
+		if ((likely(KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) &&
+			(KM_OS_CONNECTION_IS(ACTIVE, psDevInfo) || KM_OS_CONNECTION_IS(READY, psDevInfo)))) ||
+			(KM_FW_CONNECTION_IS(READY, psDevInfo) && KM_OS_CONNECTION_IS(READY, psDevInfo)))
+		{
+			RGXUpdateAutoVzWdgToken(psDevInfo);
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: The firmware-driver connection is invalid:"
+									"driver state = %u / firmware state = %u;"
+									"expected READY (%u/%u) or ACTIVE (%u/%u) or in transition (%u/%u);",
+									__func__, KM_GET_OS_CONNECTION(psDevInfo), KM_GET_FW_CONNECTION(psDevInfo),
+									RGXFW_CONNECTION_OS_READY, RGXFW_CONNECTION_FW_READY,
+									RGXFW_CONNECTION_OS_ACTIVE, RGXFW_CONNECTION_FW_ACTIVE,
+									RGXFW_CONNECTION_OS_READY, RGXFW_CONNECTION_FW_ACTIVE));
+			eError = PVRSRV_ERROR_PVZ_OSID_IS_OFFLINE;
+			goto _RGXSendCommandRaw_Exit;
+		}
 	}
 #endif
 
@@ -3624,7 +3522,7 @@ static PVRSRV_ERROR RGXSendCommandRaw(PVRSRV_RGXDEV_INFO  *psDevInfo,
 	PVR_LOG_RETURN_IF_FALSE(ui32CmdMemCopySize !=0, "RGXGetCmdMemCopySize failed", PVRSRV_ERROR_INVALID_CCB_COMMAND);
 
 	/* Copy the command into the CCB */
-	OSCachedMemCopyWMB(&pui8KCCB[ui32OldWriteOffset * sizeof(RGXFWIF_KCCB_CMD)],
+	OSCachedMemCopy(&pui8KCCB[ui32OldWriteOffset * sizeof(RGXFWIF_KCCB_CMD)],
 	                psKCCBCmd, ui32CmdMemCopySize);
 	RGXFwSharedMemCacheOpExec(&pui8KCCB[ui32OldWriteOffset * sizeof(RGXFWIF_KCCB_CMD)], ui32CmdMemCopySize, PVRSRV_CACHE_OP_FLUSH);
 
@@ -3651,9 +3549,14 @@ static PVRSRV_ERROR RGXSendCommandRaw(PVRSRV_RGXDEV_INFO  *psDevInfo,
 		         __func__, psDevInfo, ui32OldWriteOffset, RGXFWIF_KCCB_RTN_SLOT_NO_RESPONSE, psKCCBCmd->eCmdType));
 	}
 
+	/* Memory barrier before KCCB write offset update. */
+	OSWriteMemoryBarrier(NULL);
+
+
 	/* Move past the current command */
 	psKCCBCtlLocal->ui32WriteOffset = ui32NewWriteOffset;
 	psKCCBCtl->ui32WriteOffset = ui32NewWriteOffset;
+	/* Read-back of memory before Kick MTS */
 	OSWriteMemoryBarrier(&psKCCBCtl->ui32WriteOffset);
 	RGXFwSharedMemCacheOpValue(psKCCBCtl->ui32WriteOffset, FLUSH);
 
@@ -3822,7 +3725,7 @@ PVRSRV_ERROR RGXSendCommandsFromDeferredList(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_
 	dllist_replace_head(&psDevInfo->sKCCBDeferredCommandsListHead, &sCommandList);
 	OSSpinLockRelease(psDevInfo->hLockKCCBDeferredCommandsList, uiFlags);
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		if (dllist_is_empty(&sCommandList))
 		{
@@ -3864,7 +3767,7 @@ PVRSRV_ERROR RGXSendCommandsFromDeferredList(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_
 				goto cleanup_;
 			}
 		}
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 cleanup_:
 	/* if the local list is not empty put it back to the deferred list head
@@ -3995,41 +3898,6 @@ void RGXScheduleProcessQueuesKM(PVRSRV_CMDCOMP_HANDLE hCmdCompHandle)
 	OSScheduleMISR(psDevInfo->hProcessQueuesMISR);
 }
 
-#if defined(SUPPORT_VALIDATION)
-PVRSRV_ERROR RGXScheduleRgxRegCommand(PVRSRV_RGXDEV_INFO *psDevInfo,
-									  IMG_UINT64 ui64RegVal,
-									  IMG_UINT64 ui64Size,
-									  IMG_UINT32 ui32Offset,
-									  IMG_BOOL bWriteOp)
-{
-	RGXFWIF_KCCB_CMD sRgxRegsCmd = {0};
-	IMG_UINT32 ui32kCCBCommandSlot;
-	PVRSRV_ERROR eError;
-
-	sRgxRegsCmd.eCmdType = RGXFWIF_KCCB_CMD_RGXREG;
-	sRgxRegsCmd.uCmdData.sFwRgxData.ui64RegVal = ui64RegVal;
-	sRgxRegsCmd.uCmdData.sFwRgxData.ui32RegWidth = ui64Size;
-	sRgxRegsCmd.uCmdData.sFwRgxData.ui32RegAddr = ui32Offset;
-	sRgxRegsCmd.uCmdData.sFwRgxData.bWriteOp = bWriteOp;
-
-	eError =  RGXScheduleCommandAndGetKCCBSlot(psDevInfo,
-											   RGXFWIF_DM_GP,
-											   &sRgxRegsCmd,
-											   PDUMP_FLAGS_CONTINUOUS,
-											   &ui32kCCBCommandSlot);
-	PVR_LOG_RETURN_IF_ERROR(eError, "RGXScheduleCommandAndGetKCCBSlot");
-
-	if (bWriteOp)
-	{
-		eError = RGXWaitForKCCBSlotUpdate(psDevInfo,
-										  ui32kCCBCommandSlot,
-		                                  PDUMP_FLAGS_CONTINUOUS);
-		PVR_LOG_RETURN_IF_ERROR(eError, "RGXWaitForKCCBSlotUpdate");
-	}
-
-	return eError;
-}
-#endif
 
 /*!
 *******************************************************************************
@@ -4044,7 +3912,7 @@ static void RGX_MISRHandler_ScheduleProcessQueues(void *pvData)
 	PVRSRV_DEVICE_NODE     *psDeviceNode = pvData;
 	PVRSRV_RGXDEV_INFO     *psDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_ERROR           eError;
-	PVRSRV_DEV_POWER_STATE ePowerState;
+	PVRSRV_DEV_POWER_STATE ePowerState = PVRSRV_DEV_POWER_STATE_OFF;
 
 	eError = PVRSRVPowerLock(psDeviceNode);
 	if (eError != PVRSRV_OK)
@@ -4057,41 +3925,55 @@ static void RGX_MISRHandler_ScheduleProcessQueues(void *pvData)
 	/* Check whether it's worth waking up the GPU */
 	eError = PVRSRVGetDevicePowerState(psDeviceNode, &ePowerState);
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST) &&
-		(eError == PVRSRV_OK) && (ePowerState == PVRSRV_DEV_POWER_STATE_OFF))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
-		/* For now, guest drivers will always wake-up the GPU */
-		RGXFWIF_GPU_UTIL_FWCB  *psUtilFWCb = psDevInfo->psRGXFWIfGpuUtilFWCb;
-		IMG_BOOL               bGPUHasWorkWaiting;
-
-		RGXFwSharedMemCacheOpValue(psUtilFWCb->ui64GpuLastWord, INVALIDATE);
-		bGPUHasWorkWaiting =
-		    (RGXFWIF_GPU_UTIL_GET_STATE(psUtilFWCb->ui64GpuLastWord) == RGXFWIF_GPU_UTIL_STATE_BLOCKED);
-
-		if (!bGPUHasWorkWaiting)
+		/* Guests are not permitted to change the device power state */
+		if ((eError != PVRSRV_OK) || (ePowerState == PVRSRV_DEV_POWER_STATE_OFF))
 		{
-			/* all queues are empty, don't wake up the GPU */
 			PVRSRVPowerUnlock(psDeviceNode);
 			return;
 		}
 	}
+	else
+	{
+		if ((eError == PVRSRV_OK) && (ePowerState == PVRSRV_DEV_POWER_STATE_OFF))
+		{
+			RGXFWIF_GPU_UTIL_FW    *psUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
+			IMG_BOOL               bGPUHasWorkWaiting;
 
-	PDUMPPOWCMDSTART(psDeviceNode);
-	/* wake up the GPU */
-	eError = PVRSRVSetDevicePowerStateKM(psDeviceNode,
-										 PVRSRV_DEV_POWER_STATE_ON,
-										 PVRSRV_POWER_FLAGS_NONE);
-	PDUMPPOWCMDEND(psDeviceNode);
+			/* Check whether it's worth waking up the GPU */
+			RGXFwSharedMemCacheOpValue(psUtilFW->ui64GpuLastWord, INVALIDATE);
+			bGPUHasWorkWaiting =
+			    (RGXFWIF_GPU_UTIL_GET_STATE(psUtilFW->ui64GpuLastWord) == RGXFWIF_GPU_UTIL_STATE_BLOCKED);
 
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s: failed to transition Rogue to ON (%s)",
-				__func__, PVRSRVGetErrorString(eError)));
+			if (!bGPUHasWorkWaiting)
+			{
+				/* all queues are empty, don't wake up the GPU */
+				PVRSRVPowerUnlock(psDeviceNode);
+				return;
+			}
+		}
 
-		PVRSRVPowerUnlock(psDeviceNode);
-		return;
+		PDUMPPOWCMDSTART(psDeviceNode);
+		/* wake up the GPU */
+		eError = PVRSRVSetDevicePowerStateKM(psDeviceNode,
+											 PVRSRV_DEV_POWER_STATE_ON,
+											 PVRSRV_POWER_FLAGS_NONE);
+		PDUMPPOWCMDEND(psDeviceNode);
+
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "%s: failed to transition device to ON (%s)",
+					__func__, PVRSRVGetErrorString(eError)));
+
+			PVRSRVPowerUnlock(psDeviceNode);
+			return;
+		}
 	}
 
+	/* Memory barrier before Kick MTS */
+	OSWriteMemoryBarrier(NULL);
+
 	/* uncounted kick to the FW */
 	HTBLOGK(HTB_SF_MAIN_KICK_UNCOUNTED);
 	__MTSScheduleWrite(psDevInfo, (RGXFWIF_DM_GP & ~RGX_CR_MTS_SCHEDULE_DM_CLRMSK) | RGX_CR_MTS_SCHEDULE_TASK_NON_COUNTED);
@@ -4120,7 +4002,6 @@ PVRSRV_ERROR _RGXScheduleCommandAndGetKCCBSlot(PVRSRV_RGXDEV_INFO  *psDevInfo,
 	/* Don't send the command/power up request if device not available. */
 	if (unlikely((psDevInfo == NULL) ||
 	             (psDevInfo->psDeviceNode == NULL) ||
-	             (psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF) ||
 				 (psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_PCI_ERROR)))
 	{
 		return PVRSRV_ERROR_INVALID_DEVICE;
@@ -4131,81 +4012,13 @@ PVRSRV_ERROR _RGXScheduleCommandAndGetKCCBSlot(PVRSRV_RGXDEV_INFO  *psDevInfo,
 	 * sequence below is accessing the HW registers.
 	 * Not yet safe to free resources. Caller should retry later.
 	 */
-	if (psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT)
+	if (psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
+	    psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)
 	{
 		return PVRSRV_ERROR_RETRY;
 	}
 
-#if defined(SUPPORT_VALIDATION)
-	/* For validation, force the core to different dust count states with each kick */
-	if ((eKCCBType == RGXFWIF_DM_GEOM) || (eKCCBType == RGXFWIF_DM_CDM))
-	{
-		if (psDevInfo->ui32DeviceFlags & RGXKM_DEVICE_STATE_GPU_UNITS_POWER_CHANGE_EN)
-		{
-			IMG_UINT32 ui32NumDusts = RGXGetNextDustCount(&psDevInfo->sDustReqState, psDevInfo->sDevFeatureCfg.ui32MAXDustCount);
-			PVRSRVDeviceGPUUnitsPowerChange(psDevInfo->psDeviceNode, ui32NumDusts);
-		}
-	}
-
-	if (psDevInfo->ui32ECCRAMErrInjModule != RGXKM_ECC_ERR_INJ_DISABLE)
-	{
-		if (psDevInfo->ui32ECCRAMErrInjInterval > 0U)
-		{
-			--psDevInfo->ui32ECCRAMErrInjInterval;
-		}
-		else
-		{
-			IMG_UINT64 ui64ECCRegVal = 0U;
-
-			psDevInfo->ui32ECCRAMErrInjInterval = RGXKM_ECC_ERR_INJ_INTERVAL;
-
-			if (psDevInfo->ui32ECCRAMErrInjModule == RGXKM_ECC_ERR_INJ_SLC)
-			{
-				PVR_LOG(("ECC RAM Error Inject SLC"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_SLC_SIDEKICK_EN;
-			}
-			else if (psDevInfo->ui32ECCRAMErrInjModule == RGXKM_ECC_ERR_INJ_USC)
-			{
-				PVR_LOG(("ECC RAM Error Inject USC"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_USC_EN;
-			}
-			else if (psDevInfo->ui32ECCRAMErrInjModule == RGXKM_ECC_ERR_INJ_TPU)
-			{
-#if defined(RGX_FEATURE_MAX_TPU_PER_SPU)
-				PVR_LOG(("ECC RAM Error Inject Swift TPU"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_SWIFT_EN;
-#else
-				PVR_LOG(("ECC RAM Error Inject TPU MCU L0"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_TPU_MCU_L0_EN;
-#endif
-			}
-			else if (psDevInfo->ui32ECCRAMErrInjModule == RGXKM_ECC_ERR_INJ_RASCAL)
-			{
-#if defined(RGX_CR_ECC_RAM_ERR_INJ_RASCAL_EN)
-				PVR_LOG(("ECC RAM Error Inject RASCAL"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_RASCAL_EN;
-#else
-				PVR_LOG(("ECC RAM Error Inject USC"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_USC_EN;
-#endif
-			}
-			else if (psDevInfo->ui32ECCRAMErrInjModule == RGXKM_ECC_ERR_INJ_MARS)
-			{
-				PVR_LOG(("ECC RAM Error Inject MARS"));
-				ui64ECCRegVal = RGX_CR_ECC_RAM_ERR_INJ_MARS_EN;
-			}
-			else
-			{
-			}
 
-			OSWriteMemoryBarrier(NULL);
-			OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_ECC_RAM_ERR_INJ, ui64ECCRegVal);
-			PDUMPCOMMENT(psDevInfo->psDeviceNode, "Write reg ECC_RAM_ERR_INJ");
-			PDUMPREG64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME, RGX_CR_ECC_RAM_ERR_INJ, ui64ECCRegVal, PDUMP_FLAGS_CONTINUOUS);
-			OSWriteMemoryBarrier(NULL);
-		}
-	}
-#endif
 
 	if (!bCallerHasPwrLock)
 	{
@@ -4227,7 +4040,8 @@ PVRSRV_ERROR _RGXScheduleCommandAndGetKCCBSlot(PVRSRV_RGXDEV_INFO  *psDevInfo,
 		}
 	}
 
-	if (unlikely(psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT))
+	if (unlikely(psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
+	             psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING))
 	{
 		/* If we have the power lock the device is valid but the deinit
 		 * thread could be waiting for the lock. */
@@ -4277,9 +4091,9 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
 	KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 	KM_CONNECTION_CACHEOP(Os, INVALIDATE);
-	PVR_LOG_RETURN_VOID_IF_FALSE(PVRSRV_VZ_MODE_IS(NATIVE) ||
+	PVR_LOG_RETURN_VOID_IF_FALSE(PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo) ||
 								 (KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) &&
-								  KM_OS_CONNECTION_IS(ACTIVE, psDevInfo)),
+								  (KM_OS_CONNECTION_IS(ACTIVE, psDevInfo) || KM_OS_CONNECTION_IS(READY, psDevInfo))),
 								 "FW-KM connection is down");
 #endif
 
@@ -4340,7 +4154,7 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 					PDUMP_PANIC(psDevInfo->psDeviceNode, FREELISTS_RECONSTRUCTION, "Request to reconstruct free lists");
 				}
 
-				if (PVRSRV_VZ_MODE_IS(GUEST))
+				if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 				{
 					PVR_DPF((PVR_DBG_MESSAGE, "%s: Freelist reconstruction request (%d) for %d freelists",
 							__func__,
@@ -4519,14 +4333,21 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 						PVRSRVStatsUpdateRenderContextStats(psDevInfo->psDeviceNode,0,0,0,0,0,i32AdjustmentValue,0,pidTmp);
 						break;
 					}
+#if defined(RGX_FEATURE_RAY_TRACING_ARCH_MAX_VALUE_IDX)
+					case RGXFWIF_FWCCB_CMD_UPDATE_NUM_RAY_STORES:
+					{
+						PVRSRVStatsUpdateRenderContextStats(psDevInfo->psDeviceNode,0,0,0,0,0,0,i32AdjustmentValue,pidTmp);
+						break;
+					}
+#endif
 				}
 #endif
 				break;
 			}
-#if defined(SUPPORT_PDVFS)
+#if defined(SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY)
 			case RGXFWIF_FWCCB_CMD_CORE_CLK_RATE_CHANGE:
 			{
-				PDVFS_PROCESS_CORE_CLK_RATE_CHANGE(psDevInfo,
+				RGX_PROCESS_CORE_CLK_RATE_CHANGE(psDevInfo,
 											  psFwCCBCmd->uCmdData.sCmdCoreClkRateChange.ui32CoreClkRate);
 				break;
 			}
@@ -4559,7 +4380,7 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 						/* Send a dummy KCCB command to ensure the FW wakes up and checks the queues... */
 						if (eError == PVRSRV_OK)
 						{
-							LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+							LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 							{
 								eError = RGXFWHealthCheckCmd(psDevInfo);
 								if (eError != PVRSRV_ERROR_RETRY)
@@ -4567,7 +4388,7 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 									break;
 								}
 								OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-							} END_LOOP_UNTIL_TIMEOUT();
+							} END_LOOP_UNTIL_TIMEOUT_US();
 						}
 					}
 
@@ -4599,38 +4420,6 @@ void RGXCheckFirmwareCCB(PVRSRV_RGXDEV_INFO *psDevInfo)
 				}
 				break;
 			}
-#if defined(SUPPORT_VALIDATION)
-		case RGXFWIF_FWCCB_CMD_REG_READ:
-		{
-			psDevInfo->sFwRegs.ui64RegVal = psFwCCBCmd->uCmdData.sCmdRgxRegReadData.ui64RegValue;
-			complete(&psDevInfo->sFwRegs.sRegComp);
-			break;
-		}
-#if defined(SUPPORT_SOC_TIMER)
-			case RGXFWIF_FWCCB_CMD_SAMPLE_TIMERS:
-			{
-				RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags,
-				                           INVALIDATE);
-				if (psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags & RGXFWIF_INICFG_VALIDATE_SOCUSC_TIMER)
-				{
-					PVRSRV_ERROR eSOCtimerErr = RGXValidateSOCUSCTimer(psDevInfo,
-											      PDUMP_NONE,
-											      psFwCCBCmd->uCmdData.sCmdTimers.ui64timerGray,
-											      psFwCCBCmd->uCmdData.sCmdTimers.ui64timerBinary,
-											      psFwCCBCmd->uCmdData.sCmdTimers.aui64uscTimers);
-					if (PVRSRV_OK == eSOCtimerErr)
-					{
-						PVR_DPF((PVR_DBG_WARNING, "SoC or USC Timers have increased over time"));
-					}
-					else
-					{
-						PVR_DPF((PVR_DBG_WARNING, "SoC or USC Timers have NOT increased over time"));
-					}
-				}
-				break;
-			}
-#endif
-#endif
 			default:
 			{
 				/* unknown command */
@@ -4792,14 +4581,14 @@ PVRSRV_ERROR RGXStateFlagCtrl(PVRSRV_RGXDEV_INFO *psDevInfo,
 	IMG_UINT32 ui32kCCBCommandSlot;
 	IMG_BOOL bWaitForFwUpdate = IMG_FALSE;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
-
 	if (!psDevInfo)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 	psDeviceNode = psDevInfo->psDeviceNode;
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
+
 	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfFwSysData, INVALIDATE);
 	psFwSysData = psDevInfo->psRGXFWIfFwSysData;
 
@@ -4877,6 +4666,14 @@ PVRSRV_ERROR RGXScheduleCleanupCommand(PVRSRV_RGXDEV_INFO	*psDevInfo,
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT32 ui32kCCBCommandSlot;
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+	PVRSRV_DEVICE_HEALTH_STATUS eHealthStatus = OSAtomicRead(&psDevInfo->psDeviceNode->eHealthStatus);
+
+	PVR_LOG_RETURN_IF_FALSE((eHealthStatus != PVRSRV_DEVICE_HEALTH_STATUS_DEAD) &&
+							(eHealthStatus != PVRSRV_DEVICE_HEALTH_STATUS_FAULT),
+							"Cleanup aborted: Device in bad state", PVRSRV_OK);
+#endif
+
 
 	/* Clean-up commands sent during frame capture intervals must be dumped even when not in capture range... */
 	ui32PDumpFlags |= PDUMP_FLAGS_INTERVAL;
@@ -5140,7 +4937,7 @@ PVRSRV_ERROR RGXFWRequestZSBufferCleanUp(PVRSRV_RGXDEV_INFO *psDevInfo,
 PVRSRV_ERROR RGXFWSetHCSDeadline(PVRSRV_RGXDEV_INFO *psDevInfo,
 								IMG_UINT32 ui32HCSDeadlineMs)
 {
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	psDevInfo->psRGXFWIfRuntimeCfg->ui32HCSDeadlineMS = ui32HCSDeadlineMs;
 	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->ui32HCSDeadlineMS);
@@ -5186,7 +4983,7 @@ PVRSRV_ERROR RGXFWInjectFault(PVRSRV_RGXDEV_INFO *psDevInfo)
 	IMG_UINT32 ui32CBaseMapCtxReg;
 #endif
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_ERROR_NOT_SUPPORTED);
 
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
@@ -5263,7 +5060,7 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 		PVR_UNREFERENCED_PARAMETER(psFwSysData);
 		sOSOnlineStateCmd.uCmdData.sCmdOSOnlineStateData.eNewOSState = RGXFWIF_OS_OFFLINE;
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			/* Send the offline command regardless if power lock is held or not.
 			 * Under AutoVz this is done during regular driver deinit, store-to-ram suspend
@@ -5282,14 +5079,14 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 			}
 
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		/* Guests and Host going offline should wait for confirmation
 		 * from the Firmware of the state change. If this fails, break
 		 * the connection on the OS Driver's end as backup. */
-		if (PVRSRV_VZ_MODE_IS(GUEST) || (ui32DriverID == RGXFW_HOST_DRIVER_ID))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo) || (ui32DriverID == RGXFW_HOST_DRIVER_ID))
 		{
-			LOOP_UNTIL_TIMEOUT(SECONDS_TO_MICROSECONDS/2)
+			LOOP_UNTIL_TIMEOUT_US(SECONDS_TO_MICROSECONDS/2)
 			{
 				KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 				if (KM_FW_CONNECTION_IS(READY, psDevInfo))
@@ -5297,7 +5094,7 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 					bConnectionDown = IMG_TRUE;
 					break;
 				}
-			} END_LOOP_UNTIL_TIMEOUT();
+			} END_LOOP_UNTIL_TIMEOUT_US();
 
 			if (!bConnectionDown)
 			{
@@ -5307,32 +5104,21 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 		}
 	}
 #else
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		/* no reason for Guests to update their state or any other VM's.
 		 * This is the Hypervisor and Host driver's responsibility. */
 		return PVRSRV_OK;
 	}
-	else if (eOSOnlineState == RGXFWIF_OS_ONLINE)
+	else
 	{
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
-		{
-			eError = RGXScheduleCommand(psDevInfo,
-			                            RGXFWIF_DM_GP,
-			                            &sOSOnlineStateCmd,
-			                            PDUMP_FLAGS_CONTINUOUS);
-			if (eError != PVRSRV_ERROR_RETRY) break;
+		const volatile RGXFWIF_OS_RUNTIME_FLAGS *psFwRunFlags;
 
-			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
-	}
-	else if (psFwSysData)
-	{
-		const volatile RGXFWIF_OS_RUNTIME_FLAGS *psFwRunFlags =
-		         (const volatile RGXFWIF_OS_RUNTIME_FLAGS*) &psFwSysData->asOsRuntimeFlagsMirror[ui32DriverID];
+		PVR_ASSERT(psFwSysData != NULL);
 
+		psFwRunFlags = (const volatile RGXFWIF_OS_RUNTIME_FLAGS*) &psFwSysData->asOsRuntimeFlagsMirror[ui32DriverID];
 		/* Attempt several times until the FW manages to offload the OS */
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			IMG_UINT32 ui32kCCBCommandSlot;
 
@@ -5352,7 +5138,8 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 			/* read the OS state */
 			OSMemoryBarrier(NULL);
 			/* check if FW finished offloading the driver and is stopped */
-			if (psFwRunFlags->bfOsState == RGXFW_CONNECTION_FW_OFFLINE)
+			if ((eOSOnlineState == RGXFWIF_OS_ONLINE && (psFwRunFlags->bfOsState == RGXFW_CONNECTION_FW_READY || psFwRunFlags->bfOsState == RGXFW_CONNECTION_FW_ACTIVE)) ||
+			    (eOSOnlineState == RGXFWIF_OS_OFFLINE && psFwRunFlags->bfOsState == RGXFW_CONNECTION_FW_OFFLINE))
 			{
 				eError = PVRSRV_OK;
 				break;
@@ -5363,11 +5150,7 @@ PVRSRV_ERROR RGXFWSetFwOsState(PVRSRV_RGXDEV_INFO *psDevInfo,
 			}
 
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
-	}
-	else
-	{
-		eError = PVRSRV_ERROR_NOT_INITIALISED;
+		} END_LOOP_UNTIL_TIMEOUT_US();
 	}
 
 return_ :
@@ -5381,7 +5164,11 @@ PVRSRV_ERROR RGXFWConfigPHR(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PVRSRV_ERROR eError;
 	RGXFWIF_KCCB_CMD sCfgPHRCmd = { 0 };
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_ERROR_NOT_SUPPORTED);
+
+	PVR_LOG_RETURN_IF_FALSE((ui32PHRMode == RGXFWIF_PHR_MODE_OFF) ||
+							(ui32PHRMode == RGXFWIF_PHR_MODE_RD_RESET),
+							"Invalid PHR Mode.", PVRSRV_ERROR_INVALID_PARAMS);
 
 	sCfgPHRCmd.eCmdType = RGXFWIF_KCCB_CMD_PHR_CFG;
 	psDevInfo->psRGXFWIfRuntimeCfg->ui32PHRMode = ui32PHRMode;
@@ -5397,7 +5184,7 @@ PVRSRV_ERROR RGXFWConfigPHR(PVRSRV_RGXDEV_INFO *psDevInfo,
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 		                            RGXFWIF_DM_GP,
@@ -5408,7 +5195,7 @@ PVRSRV_ERROR RGXFWConfigPHR(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -5419,7 +5206,7 @@ PVRSRV_ERROR RGXFWConfigWdg(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PVRSRV_ERROR eError;
 	RGXFWIF_KCCB_CMD sCfgWdgCmd = { 0 };
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	sCfgWdgCmd.eCmdType = RGXFWIF_KCCB_CMD_WDG_CFG;
 	psDevInfo->psRGXFWIfRuntimeCfg->ui32WdgPeriodUs = ui32WdgPeriodUs;
@@ -5435,7 +5222,7 @@ PVRSRV_ERROR RGXFWConfigWdg(PVRSRV_RGXDEV_INFO *psDevInfo,
 							  PDUMP_FLAGS_CONTINUOUS);
 #endif
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 									RGXFWIF_DM_GP,
@@ -5446,7 +5233,7 @@ PVRSRV_ERROR RGXFWConfigWdg(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	return eError;
 }
@@ -5471,16 +5258,13 @@ void RGXCheckForStalledClientContexts(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_BOOL bI
 	ui32StalledClientMask |= CheckForStalledClientTransferCtxt(psDevInfo);
 
 	ui32StalledClientMask |= CheckForStalledClientRenderCtxt(psDevInfo);
+
+	ui32StalledClientMask |= CheckForStalledClientComputeCtxt(psDevInfo);
 #if defined(SUPPORT_RGXKICKSYNC_BRIDGE)
 	ui32StalledClientMask |= CheckForStalledClientKickSyncCtxt(psDevInfo);
 #endif
-	if (psDevInfo->sDevFeatureCfg.ui64Features & RGX_FEATURE_COMPUTE_BIT_MASK)
-	{
-		ui32StalledClientMask |= CheckForStalledClientComputeCtxt(psDevInfo);
-	}
-
 	/* If at least one DM stalled bit is different than before */
-	if (bIgnorePrevious || (psDevInfo->ui32StalledClientMask != ui32StalledClientMask))//(psDevInfo->ui32StalledClientMask ^ ui32StalledClientMask))
+	if (bIgnorePrevious || (psDevInfo->ui32StalledClientMask != ui32StalledClientMask))
 	{
 		if (ui32StalledClientMask > 0)
 		{
@@ -5541,19 +5325,24 @@ PVRSRV_ERROR RGXUpdateHealthStatus(PVRSRV_DEVICE_NODE* psDevNode,
 	PVR_ASSERT(psDevNode != NULL);
 	psDevInfo = psDevNode->pvDevice;
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevNode, PVRSRV_OK);
+
 	/* If the firmware is not yet initialised or has already deinitialised, stop here */
 	if (psDevInfo  == NULL || !psDevInfo->bFirmwareInitialised || psDevInfo->pvRegsBaseKM == NULL ||
 		psDevInfo->psDeviceNode == NULL || psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
-		psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF)
+		psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)
 	{
 		return PVRSRV_OK;
 	}
 
 	psRGXFWIfTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
 
-	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfFwSysData,
-	                         INVALIDATE);
-	psFwSysData = psDevInfo->psRGXFWIfFwSysData;
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
+	{
+		RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfFwSysData,
+								 INVALIDATE);
+		psFwSysData = psDevInfo->psRGXFWIfFwSysData;
+	}
 
 	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfFwOsData,
 	                         INVALIDATE);
@@ -5572,19 +5361,38 @@ PVRSRV_ERROR RGXUpdateHealthStatus(PVRSRV_DEVICE_NODE* psDevNode,
 		psDevInfo->ui32SLRHoldoffCounter--;
 	}
 
-	eError = PVRSRVPowerLock(psDevNode);
-	PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVPowerLock");
+	/* Take power lock, retry if it's in use in another task. */
+	eError = PVRSRVPowerTryLockWaitForTimeout(psDevNode);
+	if (eError == PVRSRV_ERROR_TIMEOUT)
+	{
+		/* Skip health status update if timeout */
+		PVR_DPF((PVR_DBG_WARNING, "%s: Power lock timeout, increase OS_POWERLOCK_TIMEOUT_US.", __func__));
+		goto _RGXUpdateHealthStatus_Exit;
+	}
+	PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVPowerTryLockWaitForTimeout");
 
-	/* On a PCI error all reads from the PCI bar may return 0xFFFFFFFF.
-	   This value is not valid for a core ID. */
-	if (psFwSysData->ui32MemFaultCheck == RGX_PCI_ERROR_VALUE_DWORD)
+	/* If the firmware is not yet initialised or has already deinitialised, stop here */
+	if (psDevInfo  == NULL || !psDevInfo->bFirmwareInitialised || psDevInfo->pvRegsBaseKM == NULL ||
+		psDevInfo->psDeviceNode == NULL || psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
+		psDevInfo->psDeviceNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)
 	{
-		PVR_DPF((PVR_DBG_WARNING, "%s: PCI error", __func__));
-		eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_DEAD;
-		eNewReason = PVRSRV_DEVICE_HEALTH_REASON_PCI_ERROR;
-		PVRSRVDeviceSetState(psDevNode, PVRSRV_DEVICE_STATE_PCI_ERROR);
 		PVRSRVPowerUnlock(psDevNode);
-		goto _RGXUpdateHealthStatus_Exit;
+		return PVRSRV_OK;
+	}
+
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
+	{
+		/* On a PCI error all reads from the PCI bar may return 0xFFFFFFFF.
+		   This value is not valid for a core ID. */
+		if (psFwSysData->ui32MemFaultCheck == RGX_PCI_ERROR_VALUE_DWORD)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "%s: PCI error", __func__));
+			eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_DEAD;
+			eNewReason = PVRSRV_DEVICE_HEALTH_REASON_PCI_ERROR;
+			PVRSRVDeviceSetState(psDevNode, PVRSRV_DEVICE_STATE_PCI_ERROR);
+			PVRSRVPowerUnlock(psDevNode);
+			goto _RGXUpdateHealthStatus_Exit;
+		}
 	}
 
 	/* If Rogue is not powered on, just skip ahead and check for stalled client CCBs */
@@ -5618,47 +5426,53 @@ PVRSRV_ERROR RGXUpdateHealthStatus(PVRSRV_DEVICE_NODE* psDevNode,
 					goto _RGXUpdateHealthStatus_Exit;
 				}
 
-				/*
-				   Check the threads to see if they are in the same poll locations as last time...
-				*/
-				if (bCheckAfterTimePassed)
+				if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 				{
-					if (psFwSysData->aui32CrPollAddr[ui32ThreadCount] != 0  &&
-						psFwSysData->aui32CrPollCount[ui32ThreadCount] == psDevInfo->aui32CrLastPollCount[ui32ThreadCount])
+					/*
+					   Check the threads to see if they are in the same poll locations as last time...
+					*/
+					if (bCheckAfterTimePassed)
 					{
-						PVR_DPF((PVR_DBG_WARNING, "%s: Firmware stuck on CR poll: T%u polling %s (reg:0x%08X mask:0x%08X)",
-								__func__, ui32ThreadCount,
-								((psFwSysData->aui32CrPollAddr[ui32ThreadCount] & RGXFW_POLL_TYPE_SET)?("set"):("unset")),
-								psFwSysData->aui32CrPollAddr[ui32ThreadCount] & ~RGXFW_POLL_TYPE_SET,
-								psFwSysData->aui32CrPollMask[ui32ThreadCount]));
-						eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_NOT_RESPONDING;
-						eNewReason = PVRSRV_DEVICE_HEALTH_REASON_POLL_FAILING;
-						PVRSRVPowerUnlock(psDevNode);
-						goto _RGXUpdateHealthStatus_Exit;
+						if (psFwSysData->aui32CrPollAddr[ui32ThreadCount] != 0  &&
+							psFwSysData->aui32CrPollCount[ui32ThreadCount] == psDevInfo->aui32CrLastPollCount[ui32ThreadCount])
+						{
+							PVR_DPF((PVR_DBG_WARNING, "%s: Firmware stuck on CR poll: T%u polling %s (reg:0x%08X mask:0x%08X)",
+									__func__, ui32ThreadCount,
+									((psFwSysData->aui32CrPollAddr[ui32ThreadCount] & RGXFW_POLL_TYPE_SET)?("set"):("unset")),
+									psFwSysData->aui32CrPollAddr[ui32ThreadCount] & ~RGXFW_POLL_TYPE_SET,
+									psFwSysData->aui32CrPollMask[ui32ThreadCount]));
+							eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_NOT_RESPONDING;
+							eNewReason = PVRSRV_DEVICE_HEALTH_REASON_POLL_FAILING;
+							PVRSRVPowerUnlock(psDevNode);
+							goto _RGXUpdateHealthStatus_Exit;
+						}
+						psDevInfo->aui32CrLastPollCount[ui32ThreadCount] = psFwSysData->aui32CrPollCount[ui32ThreadCount];
 					}
-					psDevInfo->aui32CrLastPollCount[ui32ThreadCount] = psFwSysData->aui32CrPollCount[ui32ThreadCount];
 				}
 			}
 
-			/*
-			Check if the FW has faulted...
-			*/
-			if (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_FW_FAULT)
+			if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevNode))
 			{
-				PVR_DPF((PVR_DBG_WARNING,
-						"%s: Firmware has faulted and needs to restart",
-						__func__));
-				eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_FAULT;
-				if (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_RESTART_REQUESTED)
-				{
-					eNewReason = PVRSRV_DEVICE_HEALTH_REASON_RESTARTING;
-				}
-				else
+				/*
+				Check if the FW has faulted...
+				*/
+				if (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_FW_FAULT)
 				{
-					eNewReason = PVRSRV_DEVICE_HEALTH_REASON_IDLING;
+					PVR_DPF((PVR_DBG_WARNING,
+							"%s: Firmware has faulted and needs to restart",
+							__func__));
+					eNewStatus = PVRSRV_DEVICE_HEALTH_STATUS_FAULT;
+					if (psFwSysData->ui32HWRStateFlags & RGXFWIF_HWR_RESTART_REQUESTED)
+					{
+						eNewReason = PVRSRV_DEVICE_HEALTH_REASON_RESTARTING;
+					}
+					else
+					{
+						eNewReason = PVRSRV_DEVICE_HEALTH_REASON_IDLING;
+					}
+					PVRSRVPowerUnlock(psDevNode);
+					goto _RGXUpdateHealthStatus_Exit;
 				}
-				PVRSRVPowerUnlock(psDevNode);
-				goto _RGXUpdateHealthStatus_Exit;
 			}
 		}
 
@@ -5684,6 +5498,7 @@ PVRSRV_ERROR RGXUpdateHealthStatus(PVRSRV_DEVICE_NODE* psDevNode,
 		*/
 		bKCCBCmdsWaiting = IMG_FALSE;
 
+		RGXFwSharedMemCacheOpPtr(psDevInfo->psKernelCCBCtl, INVALIDATE);
 		psKCCBCtl = psDevInfo->psKernelCCBCtl;
 		psKCCBCtlLocal = psDevInfo->psKernelCCBCtlLocal;
 
@@ -5729,7 +5544,9 @@ PVRSRV_ERROR RGXUpdateHealthStatus(PVRSRV_DEVICE_NODE* psDevNode,
 				   If no commands are currently pending and nothing happened since the last poll, then
 				   schedule a dummy command to ping the firmware so we know it is alive and processing.
 				*/
-				if (!bKCCBCmdsWaiting)
+				if ((!bKCCBCmdsWaiting) &&
+					(eNewStatus != PVRSRV_DEVICE_HEALTH_STATUS_DEAD) &&
+					(eNewStatus != PVRSRV_DEVICE_HEALTH_STATUS_FAULT))
 				{
 					/* Protect the PDumpLoadMem. RGXScheduleCommand() cannot take the
 					 * PMR lock itself, because some bridge functions will take the PMR lock
@@ -5874,7 +5691,8 @@ void RGXUpdateAutoVzWdgToken(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 	KM_CONNECTION_CACHEOP(Os, INVALIDATE);
-	if (likely(KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) && KM_OS_CONNECTION_IS(ACTIVE, psDevInfo)))
+	if (likely(KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) &&
+		(KM_OS_CONNECTION_IS(ACTIVE, psDevInfo) || KM_OS_CONNECTION_IS(READY, psDevInfo))))
 	{
 		/* read and write back the alive token value to confirm to the
 		 * virtualisation watchdog that this connection is healthy */
@@ -5894,7 +5712,7 @@ void RGXUpdateAutoVzWatchdog(PVRSRV_DEVICE_NODE* psDevNode)
 
 		if (unlikely((psDevInfo  == NULL || !psDevInfo->bFirmwareInitialised || !psDevInfo->bRGXPowered ||
 					  psDevInfo->pvRegsBaseKM == NULL || psDevNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT ||
-					  psDevNode->eDevState == PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF)))
+					  psDevNode->eDevState == PVRSRV_DEVICE_STATE_DESTRUCTING)))
 		{
 			/* If the firmware is not initialised, stop here */
 			return;
@@ -6091,6 +5909,7 @@ PVRSRV_ERROR RGXGetPhyAddr(PMR *psPMR,
 PVRSRV_ERROR RGXPdumpDrainKCCB(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32WriteOffset)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_OK);
 
 	if (psDevInfo->bDumpedKCCBCtlAlready)
 	{
@@ -6145,7 +5964,7 @@ PVRSRV_ERROR RGXClientConnectCompatCheck_ClientAgainstFW(PVRSRV_DEVICE_NODE *psD
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	RGX_FW_INFO_HEADER *psFWInfoHeader;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	if (psDevInfo == NULL || psDevInfo->psRGXFWIfOsInitMemDesc == NULL)
 	{
@@ -6158,9 +5977,9 @@ PVRSRV_ERROR RGXClientConnectCompatCheck_ClientAgainstFW(PVRSRV_DEVICE_NODE *psD
 	psFWInfoHeader = &psDevInfo->sFWInfoHeader;
 
 #if !defined(NO_HARDWARE)
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.bUpdated,
 		                               INVALIDATE);
@@ -6170,7 +5989,7 @@ PVRSRV_ERROR RGXClientConnectCompatCheck_ClientAgainstFW(PVRSRV_DEVICE_NODE *psD
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 	}
 #endif
 
@@ -6232,7 +6051,7 @@ PVRSRV_ERROR RGXFwRawHeapAllocMap(PVRSRV_DEVICE_NODE *psDeviceNode,
 																PHYS_HEAP_USAGE_FW_SHARED);
 	PHYS_HEAP_CONFIG sFwHeapConfig;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	if (psFwHeapConfig == NULL)
 	{
@@ -6252,14 +6071,14 @@ PVRSRV_ERROR RGXFwRawHeapAllocMap(PVRSRV_DEVICE_NODE *psDeviceNode,
 	}
 
 	sFwHeapConfig = *psFwHeapConfig;
-	sFwHeapConfig.sStartAddr.uiAddr = 0;
-	sFwHeapConfig.sCardBase.uiAddr = sDevPAddr.uiAddr;
-	sFwHeapConfig.uiSize = RGX_FIRMWARE_RAW_HEAP_SIZE;
 	sFwHeapConfig.eType = PHYS_HEAP_TYPE_LMA;
 	sFwHeapConfig.ui32UsageFlags = PHYS_HEAP_USAGE_FW_PREMAP;
+	sFwHeapConfig.uConfig.sLMA.sStartAddr.uiAddr = 0;
+	sFwHeapConfig.uConfig.sLMA.sCardBase.uiAddr = sDevPAddr.uiAddr;
+	sFwHeapConfig.uConfig.sLMA.uiSize = RGX_FIRMWARE_RAW_HEAP_SIZE;
 
 	eError = PhysmemCreateHeapLMA(psDeviceNode,
-	                              RGXPhysHeapGetLMAPolicy(sFwHeapConfig.ui32UsageFlags),
+	                              RGXPhysHeapGetLMAPolicy(sFwHeapConfig.ui32UsageFlags, psDeviceNode),
 	                              &sFwHeapConfig,
 	                              szRegionRAName,
 	                              &psDeviceNode->apsFWPremapPhysHeap[ui32DriverID]);
@@ -6284,12 +6103,16 @@ PVRSRV_ERROR RGXFwRawHeapAllocMap(PVRSRV_DEVICE_NODE *psDeviceNode,
 		DevmemHeapSetPremapStatus(psDevInfo->psPremappedFwRawHeap[ui32DriverID], IMG_TRUE);
 	}
 
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	PVR_DPF((PVR_DBG_MESSAGE, "%s: Allocation and mapping for Firmware heaps done by TEE.", __func__));
+#else
 	eError = DevmemFwAllocate(psDevInfo,
 							  RGX_FIRMWARE_RAW_HEAP_SIZE,
 							  uiRawFwHeapAllocFlags,
 							  psDevInfo->psPremappedFwRawHeap[ui32DriverID]->pszName,
 							  &psDevInfo->psPremappedFwRawMemDesc[ui32DriverID]);
 	PVR_LOG_RETURN_IF_ERROR(eError, "DevmemFwAllocate");
+#endif
 
 	/* Mark this devmem heap as premapped so allocations will not require device mapping. */
 	DevmemHeapSetPremapStatus(psDevInfo->psPremappedFwRawHeap[ui32DriverID], IMG_TRUE);
@@ -6575,186 +6398,6 @@ PVRSRV_ERROR RGXWriteFWModuleAddr(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
-/*
-	RGXWriteMetaRegThroughSP
-*/
-PVRSRV_ERROR RGXWriteMetaRegThroughSP(const void *hPrivate,
-                                      IMG_UINT32 ui32RegAddr,
-                                      IMG_UINT32 ui32RegValue)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	/* Wait for Slave Port to be Ready */
-	PVRSRV_RGXDEV_INFO *psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES))
-	{
-		if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
-		{
-			eError = RGXPollReg32(hPrivate,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN);
-			if (eError == PVRSRV_OK)
-			{
-				/* Issue a Write */
-				CHECK_HWBRN_68777(ui32RegAddr);
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA, ui32RegAddr);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA); /* Fence write */
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVDATAT__HOST_SECURITY_GT1_AND_MRUA, ui32RegValue);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVDATAT__HOST_SECURITY_GT1_AND_MRUA); /* Fence write */
-			}
-		}
-		else
-		{
-			eError = RGXPollReg32(hPrivate,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN);
-			if (eError == PVRSRV_OK)
-			{
-				/* Issue a Write */
-				CHECK_HWBRN_68777(ui32RegAddr);
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA, ui32RegAddr);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA); /* Fence write */
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA, ui32RegValue);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA); /* Fence write */
-			}
-		}
-	}
-	else
-#endif
-	{
-		eError = RGXPollReg32(hPrivate,
-							  RGX_CR_META_SP_MSLVCTRL1,
-							  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN,
-							  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN);
-		if (eError == PVRSRV_OK)
-		{
-			/* Issue a Write */
-			RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0, ui32RegAddr);
-			(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0); /* Fence write */
-			RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVDATAT, ui32RegValue);
-			(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVDATAT); /* Fence write */
-		}
-	}
-
-	return eError;
-}
-
-/*
-	RGXReadMetaRegThroughSP
-*/
-PVRSRV_ERROR RGXReadMetaRegThroughSP(const void *hPrivate,
-                                     IMG_UINT32 ui32RegAddr,
-                                     IMG_UINT32* ui32RegValue)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	/* Wait for Slave Port to be Ready */
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	PVRSRV_RGXDEV_INFO *psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES))
-	{
-		if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
-		{
-			eError = RGXPollReg32(hPrivate,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN);
-			if (eError == PVRSRV_OK)
-			{
-				/* Issue a Read */
-				CHECK_HWBRN_68777(ui32RegAddr);
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA,
-										ui32RegAddr | RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA__RD_EN);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA); /* Fence write */
-
-				/* Wait for Slave Port to be Ready */
-				eError = RGXPollReg32(hPrivate,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-									  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN
-									  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN);
-				if (eError != PVRSRV_OK) return eError;
-			}
-		}
-		else
-		{
-			eError = RGXPollReg32(hPrivate,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN,
-								  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-								  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN);
-			if (eError == PVRSRV_OK)
-			{
-				/* Issue a Read */
-				CHECK_HWBRN_68777(ui32RegAddr);
-				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA,
-										ui32RegAddr | RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA__RD_EN);
-				(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA); /* Fence write */
-
-				/* Wait for Slave Port to be Ready */
-				eError = RGXPollReg32(hPrivate,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-									  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN,
-									  RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN
-									  | RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN);
-				if (eError != PVRSRV_OK) return eError;
-			}
-		}
-#if !defined(NO_HARDWARE)
-		if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
-		{
-			*ui32RegValue = RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_GT1_AND_MRUA);
-		}
-		else
-		{
-			*ui32RegValue = RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_EQ1_AND_MRUA);
-		}
-#else
-		*ui32RegValue = 0xFFFFFFFF;
-#endif
-	}
-	else
-#endif
-	{
-		eError = RGXPollReg32(hPrivate,
-							  RGX_CR_META_SP_MSLVCTRL1,
-							  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN,
-							  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN);
-		if (eError == PVRSRV_OK)
-		{
-			/* Issue a Read */
-			RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0, ui32RegAddr | RGX_CR_META_SP_MSLVCTRL0_RD_EN);
-			(void) RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVCTRL0); /* Fence write */
-
-			/* Wait for Slave Port to be Ready */
-			eError = RGXPollReg32(hPrivate,
-								  RGX_CR_META_SP_MSLVCTRL1,
-								  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN,
-								  RGX_CR_META_SP_MSLVCTRL1_READY_EN|RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN);
-			if (eError != PVRSRV_OK) return eError;
-		}
-#if !defined(NO_HARDWARE)
-		*ui32RegValue = RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVDATAX);
-#else
-		*ui32RegValue = 0xFFFFFFFF;
-#endif
-	}
-
-	return eError;
-}
-
 PVRSRV_ERROR RGXGetFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
                              IMG_UINT32 ui32FwVA,
                              IMG_CPU_PHYADDR *psCpuPA,
@@ -6820,7 +6463,7 @@ PVRSRV_ERROR RGXGetFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
 #if !defined(EMULATOR)
 		else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
 		{
-			ui64FwDataBaseMask = ~(RGXRISCVFW_GET_REGION_BASE(0xF));
+			ui64FwDataBaseMask = ~RGXRISCVFW_REGION_MASK;
 		}
 #endif
 		else
@@ -6892,39 +6535,11 @@ PVRSRV_ERROR RGXGetFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
 	return eError;
 }
 
-#if defined(SUPPORT_WORKLOAD_ESTIMATION)
-/*!
-*******************************************************************************
-@Function       RGXIsValidWorkloadEstCCBCommand
-
-@Description    Checks if command type can be used for workload estimation
-
-@Input          eType       Command type to check
-
-
-@Return        IMG_BOOL
-******************************************************************************/
-INLINE IMG_BOOL RGXIsValidWorkloadEstCCBCommand(RGXFWIF_CCB_CMD_TYPE eType)
-{
-	switch (eType)
-	{
-			case RGXFWIF_CCB_CMD_TYPE_GEOM:
-			case RGXFWIF_CCB_CMD_TYPE_3D:
-			case RGXFWIF_CCB_CMD_TYPE_CDM:
-			case RGXFWIF_CCB_CMD_TYPE_TQ_TDM:
-				return IMG_TRUE;
-			default:
-				PVR_ASSERT(IMG_FALSE);
-				return IMG_FALSE;
-	}
-}
-#endif
-
 PVRSRV_ERROR
 RGXFWSetVzConnectionCooldownPeriod(PVRSRV_RGXDEV_INFO *psDevInfo,
 				   IMG_UINT32 ui32VzConnectionCooldownPeriodInSec)
 {
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psDevInfo, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	psDevInfo->psRGXFWIfRuntimeCfg->ui32VzConnectionCooldownPeriodInSec = ui32VzConnectionCooldownPeriodInSec;
 	OSWriteMemoryBarrier(&psDevInfo->psRGXFWIfRuntimeCfg->ui32VzConnectionCooldownPeriodInSec);
diff --git a/drivers/gpu/drm/img-rogue/rgxfwutils.h b/drivers/gpu/drm/img-rogue/rgxfwutils.h
index 28fc64905243..6752bc95fa18 100644
--- a/drivers/gpu/drm/img-rogue/rgxfwutils.h
+++ b/drivers/gpu/drm/img-rogue/rgxfwutils.h
@@ -57,6 +57,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "devicemem_utils.h"
 #include "rgxmem.h"
 #include "rgxfwmemctx.h"
+#include "rgxinit_apphints.h"
 
 #define RGX_FIRMWARE_GUEST_RAW_HEAP_IDENT   "FwRawDriverID%d" /*!< RGX Raw Firmware Heap identifier */
 
@@ -330,6 +331,8 @@ static INLINE void DevmemFwUnmapAndFree(PVRSRV_RGXDEV_INFO *psDevInfo,
 {
 	PVR_DPF_ENTERED1(psMemDesc);
 
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+
 	DevmemReleaseDevVirtAddr(psMemDesc);
 	DevmemFree(psMemDesc);
 
@@ -375,6 +378,7 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                       PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC | \
                                       PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE | \
                                       PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                      PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC | \
                                       PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN))
 
 #define RGX_FWCODEDATA_ALLOCFLAGS    (PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) | \
@@ -384,6 +388,7 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                       PVRSRV_MEMALLOCFLAG_CPU_READABLE | \
                                       PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE | \
                                       PVRSRV_MEMALLOCFLAG_GPU_CACHE_INCOHERENT | \
+                                      PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC | \
                                       PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE)
 
 #define RGX_FWSHAREDMEM_MAIN_ALLOCFLAGS (PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) | \
@@ -395,6 +400,7 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                          PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC | \
                                          PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE | \
                                          PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                         PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC | \
                                          PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN))
 
 #define RGX_FWSHAREDMEM_CONFIG_ALLOCFLAGS (PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) | \
@@ -406,6 +412,7 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                            PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC | \
                                            PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE | \
                                            PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                           PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC | \
                                            PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_CONFIG))
 
 #define RGX_FWSHAREDMEM_GPU_RO_ALLOCFLAGS (PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) | \
@@ -416,6 +423,7 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                            PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC | \
                                            PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE | \
                                            PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                           PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC | \
                                            PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN))
 
 /* Firmware memory that is not accessible by the CPU. */
@@ -423,7 +431,8 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                              PVRSRV_MEMALLOCFLAG_GPU_READABLE | \
                                              PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE | \
                                              PVRSRV_MEMALLOCFLAG_GPU_UNCACHED | \
-                                             PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC)
+                                             PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                             PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC)
 
 /* Firmware shared memory that is supposed to be read-only to the CPU.
  * In reality it isn't due to ZERO_ON_ALLOC which enforces CPU_WRITEABLE
@@ -436,7 +445,8 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
                                            PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE | \
                                            PVRSRV_MEMALLOCFLAG_GPU_UNCACHED | \
                                            PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC | \
-                                           PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC)
+                                           PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC | \
+                                           PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC)
 
 /* data content being kept from previous boot cycles from physical memory must not be cleared during allocation */
 #define RGX_AUTOVZ_KEEP_FW_DATA_MASK(bKeepMem) ((bKeepMem) ? (~PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC) : (~0ULL))
@@ -448,43 +458,82 @@ static INLINE IMG_UINT64 RGXReadHWTimerReg(PVRSRV_RGXDEV_INFO *psDevInfo)
 #define RFW_FWADDR_NOREF_FLAG		(1U << 0)	/*!< It is safe to immediately release the reference to the pointer,
 												  otherwise RGXUnsetFirmwareAddress() must be call when finished. */
 
-IMG_BOOL RGXTraceBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo);
+/*************************************************************************/ /*!
+@Function       RGXTraceBufferIsInitRequired
+
+@Description    Returns true if the firmware trace buffer is not allocated and
+                might be required by the firmware soon. Trace buffer allocated
+                on-demand to reduce RAM footprint on systems not needing
+                firmware trace.
+
+@Input          psDevInfo RGX device info
+
+@Return         IMG_BOOL  Whether on-demand allocation(s) is/are needed or not
+*/ /**************************************************************************/
+FORCE_INLINE IMG_BOOL RGXTraceBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	RGXFWIF_TRACEBUF*  psTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
+
+	RGXFwSharedMemCacheOpValue(psTraceBufCtl->ui32LogType, INVALIDATE);
+
+	/* The firmware expects a trace buffer only when:
+	 *	- Logtype is "trace" AND
+	 *	- at least one LogGroup is configured
+	 *	- the Driver Mode is not Guest
+	 */
+	if ((psDevInfo->psRGXFWIfTraceBufferMemDesc[0] == NULL)
+		&& (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_TRACE)
+		&& (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_GROUP_MASK)
+		&& !PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
+	{
+		return IMG_TRUE;
+	}
+
+	return IMG_FALSE;
+}
+
 PVRSRV_ERROR RGXTraceBufferInitOnDemandResources(PVRSRV_RGXDEV_INFO* psDevInfo, PVRSRV_MEMALLOCFLAGS_T uiAllocFlags);
 
 #if defined(SUPPORT_TBI_INTERFACE)
-IMG_BOOL RGXTBIBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo);
+/*************************************************************************/ /*!
+@Function       RGXTBIBufferIsInitRequired
+
+@Description    Returns true if the firmware tbi buffer is not allocated and
+                might be required by the firmware soon. TBI buffer allocated
+                on-demand to reduce RAM footprint on systems not needing
+                tbi.
+
+@Input          psDevInfo RGX device info
+
+@Return         IMG_BOOL  Whether on-demand allocation(s) is/are needed or not
+*/ /**************************************************************************/
+FORCE_INLINE IMG_BOOL RGXTBIBufferIsInitRequired(PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	RGXFWIF_TRACEBUF*  psTraceBufCtl = psDevInfo->psRGXFWIfTraceBufCtl;
+
+	RGXFwSharedMemCacheOpValue(psTraceBufCtl->ui32LogType, INVALIDATE);
+
+	/* The firmware expects a tbi buffer only when:
+	 *	- Logtype is "tbi"
+	 */
+	if ((psDevInfo->psRGXFWIfTBIBufferMemDesc == NULL)
+		 && (psTraceBufCtl->ui32LogType & ~RGXFWIF_LOG_TYPE_TRACE)
+		 && (psTraceBufCtl->ui32LogType & RGXFWIF_LOG_TYPE_GROUP_MASK))
+	{
+		return IMG_TRUE;
+	}
+
+	return IMG_FALSE;
+}
+
 PVRSRV_ERROR RGXTBIBufferInitOnDemandResources(PVRSRV_RGXDEV_INFO *psDevInfo);
 #endif
 
 PVRSRV_ERROR RGXSetupFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
-                              IMG_BOOL                 bEnableSignatureChecks,
-                              IMG_UINT32               ui32SignatureChecksBufSize,
-                              IMG_UINT32               ui32HWPerfFWBufSizeKB,
-                              IMG_UINT64               ui64HWPerfFilter,
+                              RGX_INIT_APPHINTS        *psApphints,
                               IMG_UINT32               ui32ConfigFlags,
                               IMG_UINT32               ui32ConfigFlagsExt,
-                              IMG_UINT32               ui32FwOsCfgFlags,
-                              IMG_UINT32               ui32LogType,
-                              IMG_UINT32               ui32FilterFlags,
-                              IMG_UINT32               ui32JonesDisableMask,
-                              IMG_UINT32               ui32HWRDebugDumpLimit,
-                              IMG_UINT32               ui32HWPerfCountersDataSize,
-#if defined(PVR_ARCH_VOLCANIC)
-                              IMG_UINT32               ui32RenderKillingCtl,
-                              IMG_UINT32               ui32CDMTDMKillingCtl,
-                              IMG_UINT32               *pui32USRMNumRegions,
-                              IMG_UINT64               *pui64UVBRMNumRegions,
-                              IMG_UINT64               ui64ClkCtrl0,
-                              IMG_UINT64               ui64ClkCtrl1,
-                              IMG_UINT32               ui32ClkCtrl2,
-                              IMG_BOOL                 bSPUClockGating,
-                              IMG_UINT32               ui32AvailablePowUnitsMask,
-                              IMG_UINT32               ui32AvailableRACMask,
-#endif
-                              IMG_UINT32               *pui32TPUTrilinearFracMask,
-                              RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandConf,
-                              FW_PERF_CONF             eFirmwarePerf,
-                              IMG_UINT32               ui32KCCBSizeLog2);
+                              IMG_UINT32               ui32FwOsCfgFlags);
 
 
 void RGXFreeFirmware(PVRSRV_RGXDEV_INFO *psDevInfo);
@@ -573,26 +622,6 @@ void RGXUnsetFirmwareAddress(DEVMEM_MEMDESC *psSrc);
 ******************************************************************************/
 void RGXScheduleProcessQueuesKM(PVRSRV_CMDCOMP_HANDLE hCmdCompHandle);
 
-#if defined(SUPPORT_VALIDATION)
-/*!
-*******************************************************************************
-@Function       RGXScheduleRgxRegCommand
-
-@Input          psDevInfo       Device Info struct
-@Input          ui64RegVal      Value to write into FW register
-@Input          ui64Size        Register size
-@Input          ui32Offset      Register Offset
-@Input          bWriteOp        Register Write or Read toggle
-
-@Return         PVRSRV_ERROR
-******************************************************************************/
-PVRSRV_ERROR RGXScheduleRgxRegCommand(PVRSRV_RGXDEV_INFO *psDevInfo,
-									  IMG_UINT64 ui64RegVal,
-									  IMG_UINT64 ui64Size,
-									  IMG_UINT32 ui32Offset,
-									  IMG_BOOL bWriteOp);
-
-#endif
 
 /*!
 *******************************************************************************
@@ -1156,14 +1185,6 @@ PVRSRV_ERROR RGXWriteFWModuleAddr(PVRSRV_RGXDEV_INFO *psDevInfo,
                                   IMG_UINT32 ui32MemAddr,
                                   IMG_UINT32 ui32Value);
 
-PVRSRV_ERROR RGXWriteMetaRegThroughSP(const void *hPrivate,
-                                      IMG_UINT32 ui32RegAddr,
-                                      IMG_UINT32 ui32RegValue);
-
-PVRSRV_ERROR RGXReadMetaRegThroughSP(const void *hPrivate,
-                                     IMG_UINT32 ui32RegAddr,
-                                     IMG_UINT32* ui32RegValue);
-
 /*!
 *******************************************************************************
 @Function       RGXGetFwMapping
@@ -1186,21 +1207,6 @@ PVRSRV_ERROR RGXGetFwMapping(PVRSRV_RGXDEV_INFO *psDevInfo,
                                     IMG_DEV_PHYADDR *psDevPA,
                                     IMG_UINT64 *pui64RawPTE);
 
-#if defined(SUPPORT_WORKLOAD_ESTIMATION)
-/*!
-*******************************************************************************
-@Function       RGXIsValidWorkloadEstCCBCommand
-
-@Description    Checks if command type can be used for workload estimation
-
-@Input          eType       Command type to check
-
-@Return        IMG_BOOL
-******************************************************************************/
-IMG_BOOL RGXIsValidWorkloadEstCCBCommand(RGXFWIF_CCB_CMD_TYPE eType);
-
-#endif
-
 /*!
 *******************************************************************************
 @Function       RGXFWInjectFault
@@ -1257,8 +1263,8 @@ RGXFWSetVzConnectionCooldownPeriod(PVRSRV_RGXDEV_INFO *psDevInfo,
 													                           CacheOp);
 #endif /* defined(SUPPORT_AUTOVZ) */
 
-#if !defined(NO_HARDWARE) && (defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) || (!defined(RGX_NUM_DRIVERS_SUPPORTED) || (RGX_NUM_DRIVERS_SUPPORTED == 1)))
-/* native, static-vz and AutoVz using shared memory */
+#if !defined(NO_HARDWARE) && defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+/* static, dynamic and AutoVz DDKs using shared memory */
 #define KM_GET_FW_CONNECTION(psDevInfo)			(psDevInfo->psRGXFWIfConnectionCtl->eConnectionFwState)
 #define KM_GET_OS_CONNECTION(psDevInfo)			(psDevInfo->psRGXFWIfConnectionCtl->eConnectionOsState)
 #define KM_SET_OS_CONNECTION(val, psDevInfo)	do { \
@@ -1269,7 +1275,7 @@ RGXFWSetVzConnectionCooldownPeriod(PVRSRV_RGXDEV_INFO *psDevInfo,
 #define KM_CONNECTION_CACHEOP(Target, CacheOp)  RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfConnectionCtl->eConnection##Target##State, \
 												                           CacheOp);
 #else
-/* dynamic-vz & nohw */
+/* nohw & native */
 #define KM_GET_FW_CONNECTION(psDevInfo)			(RGXFW_CONNECTION_FW_ACTIVE)
 #define KM_GET_OS_CONNECTION(psDevInfo)			(RGXFW_CONNECTION_OS_ACTIVE)
 #define KM_SET_OS_CONNECTION(val, psDevInfo)
diff --git a/drivers/gpu/drm/img-rogue/rgxheapconfig.h b/drivers/gpu/drm/img-rogue/rgxheapconfig.h
index 92da55c35664..6825da5caa3b 100644
--- a/drivers/gpu/drm/img-rogue/rgxheapconfig.h
+++ b/drivers/gpu/drm/img-rogue/rgxheapconfig.h
@@ -46,12 +46,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "rgxdefs_km.h"
 
-
-#define RGX_HEAP_SIZE_4KiB       IMG_UINT64_C(0x0000001000)
-#define RGX_HEAP_SIZE_64KiB      IMG_UINT64_C(0x0000010000)
-#define RGX_HEAP_SIZE_256KiB     IMG_UINT64_C(0x0000040000)
-
-#define RGX_HEAP_SIZE_1MiB       IMG_UINT64_C(0x0000100000)
+#define RGX_HEAP_SIZE_32KiB      IMG_UINT64_C(0x0000008000)
 #define RGX_HEAP_SIZE_2MiB       IMG_UINT64_C(0x0000200000)
 #define RGX_HEAP_SIZE_4MiB       IMG_UINT64_C(0x0000400000)
 #define RGX_HEAP_SIZE_16MiB      IMG_UINT64_C(0x0001000000)
@@ -101,7 +96,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 	heaps should be added to this file, like BRN_63142 below.
 	NOTE: All regular heaps below greater than 1GB require a BRN_65273 WA heap.
 
-	Base addresses have to be a multiple of 4MiB
 	Heaps must not start at 0x0000000000, as this is reserved for internal
 	use within device memory layer.
 	Range comments, those starting in column 0 below are a section heading of
@@ -118,16 +112,20 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /* 0x00_0000_0000 ************************************************************/
 
 /* 0x00_0000_0000 - 0x00_0020_0000 **/
-	/* 0 MiB to 2 MiB, size of 2 MiB : RESERVED **/
+	/* 0 MiB to 2 MiB, size of 2 MiB : RESERVED (only when General SVM
+	 *                                           doesn't exist) **/
 
 	/* BRN_65273 TQ3DPARAMETERS base 0x0000010000 */
 	/* BRN_65273 GENERAL base        0x65C0000000 */
 	/* BRN_65273 GENERAL_NON4K base  0x73C0000000 */
 
-/* 0x00_0020_0000 - 0x7F_FFC0_0000 **/
-	/* 2 MiB to 512 GiB, size of 512 GiB less 2 MiB : GENERAL_SVM_HEAP **/
-	#define RGX_GENERAL_SVM_HEAP_BASE           IMG_UINT64_C(0x0000200000)
-	#define RGX_GENERAL_SVM_HEAP_SIZE           (RGX_HEAP_SIZE_512GiB - RGX_HEAP_SIZE_2MiB)
+/* 0x00_0000_8000 - 0x7F_FFFF_8000 **/
+	/* MAX(32 KiB, PAGE_SIZE) to 512 GiB, size of 512 GiB less MAX(32 KiB, PAGE_SIZE) : GENERAL_SVM_HEAP **/
+
+	/* The MAX is determined at runtime (PAGE_SIZE isn't available on all platforms)
+	 * so the #define's must NOT be used directly. Use the heap config after initialisation. */
+	#define RGX_GENERAL_SVM_HEAP_BASE           IMG_UINT64_C(0x0000008000)
+	#define RGX_GENERAL_SVM_HEAP_SIZE           (RGX_HEAP_SIZE_512GiB - RGX_HEAP_SIZE_32KiB)
 
 
 /* 0x80_0000_0000 ************************************************************/
@@ -217,12 +215,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /* 0xE9_4000_0000 - 0xE9_FFFF_FFFF **/
 	/* 933 GiB to 936 GiB, size of 3 GiB : FREE **/
 
-/* 0xEA_0000_0000 - 0xEA_0000_0FFF **/
-	/* 936 GiB to 937 GiB, size of min heap size : SIGNALS_HEAP **/
-	/* CDM Signals heap (31 signals less one reserved for Services).
-	 * Size 960B rounded up to minimum heap size */
-	#define RGX_SIGNALS_HEAP_BASE               IMG_UINT64_C(0xEA00000000)
-	#define RGX_SIGNALS_HEAP_SIZE               DEVMEM_HEAP_MINIMUM_SIZE
+/* 0xEA_0000_0000 - 0xEA_001F_FFFF **/
+	/* 936 GiB to 937 GiB, size of 1 GiB : FREE **/
 
 /* 0xEA_4000_0000 - 0xEA_FFFF_FFFF **/
 	/* 937 GiB to 940 GiB, size of 3 GiB : FREE **/
diff --git a/drivers/gpu/drm/img-rogue/rgxheapconfig_65273.h b/drivers/gpu/drm/img-rogue/rgxheapconfig_65273.h
index 13b4a96f7f6f..66f44dc8c18b 100644
--- a/drivers/gpu/drm/img-rogue/rgxheapconfig_65273.h
+++ b/drivers/gpu/drm/img-rogue/rgxheapconfig_65273.h
@@ -44,17 +44,22 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef RGXHEAPCONFIG_65273_H
 #define RGXHEAPCONFIG_65273_H
 
+#define RGX_HEAP_SIZE_64KiB      IMG_UINT64_C(0x0000010000)
+
 /*
 	RGX Device Virtual Address Space Definitions
 
 	This file defines the RGX virtual address replacement heaps that are used
-	in application memory contexts for BRN_65273.
+	in application memory contexts when BRN_65273 is present. The addresses
+	used are specifically crafted to avoid the BRN - under no circumstances
+	can they be moved, altered in size or additional heaps added.
 
 	The heaps defined for BRN_65273 _replace_ the non-BRN equivalents when this
 	BRN WA is active on affected cores. This is different to most other BRNs
 	and hence has been given its own header file for clarity. The SVM_HEAP is
 	also disabled and unavailable when the WA is active. This is reflected
 	in the device connection capability bits returned to user space.
+
 	NOTE: All regular heaps in rgxheapconfig.h greater than 1GB require
 	      a BRN_65273 WA heap.
 
diff --git a/drivers/gpu/drm/img-rogue/rgxhwperf.c b/drivers/gpu/drm/img-rogue/rgxhwperf.c
index 1bb4e429ead4..e43fc499d9db 100644
--- a/drivers/gpu/drm/img-rogue/rgxhwperf.c
+++ b/drivers/gpu/drm/img-rogue/rgxhwperf.c
@@ -135,7 +135,7 @@ PVRSRV_ERROR RGXServerFeatureFlagsToHWPerfFlags(PVRSRV_RGXDEV_INFO *psDevInfo, R
 	if ((pszBVNC = RGXDevBVNCString(psDevInfo)))
 	{
 		size_t uiStringLength = OSStringNLength(pszBVNC, RGX_HWPERF_MAX_BVNC_LEN - 1);
-		OSStringLCopy(psBVNC->aszBvncString, pszBVNC, uiStringLength + 1);
+		OSStringSafeCopy(psBVNC->aszBvncString, pszBVNC, uiStringLength + 1);
 		memset(&psBVNC->aszBvncString[uiStringLength], 0, RGX_HWPERF_MAX_BVNC_LEN - uiStringLength);
 	}
 	else
@@ -149,10 +149,6 @@ PVRSRV_ERROR RGXServerFeatureFlagsToHWPerfFlags(PVRSRV_RGXDEV_INFO *psDevInfo, R
 	{
 		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_PERFBUS_FLAG;
 	}
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_S7_TOP_INFRASTRUCTURE_FLAG;
-	}
 #if defined(RGX_FEATURE_XT_TOP_INFRASTRUCTURE_BIT_MASK)
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, XT_TOP_INFRASTRUCTURE))
 	{
@@ -167,10 +163,6 @@ PVRSRV_ERROR RGXServerFeatureFlagsToHWPerfFlags(PVRSRV_RGXDEV_INFO *psDevInfo, R
 	{
 		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_ROGUEXE_FLAG;
 	}
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, DUST_POWER_ISLAND_S7))
-	{
-		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_DUST_POWER_ISLAND_S7_FLAG;
-	}
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, PBE2_IN_XE))
 	{
 		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_PBE2_IN_XE_FLAG;
@@ -181,7 +173,7 @@ PVRSRV_ERROR RGXServerFeatureFlagsToHWPerfFlags(PVRSRV_RGXDEV_INFO *psDevInfo, R
 	}
 
 #ifdef SUPPORT_WORKLOAD_ESTIMATION
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		/* Not a part of BVNC feature line and so doesn't need the feature supported check */
 		psBVNC->ui32BvncKmFeatureFlags |= RGX_HWPERF_FEATURE_WORKLOAD_ESTIMATION;
@@ -249,7 +241,7 @@ PVRSRV_ERROR PVRSRVRGXConfigMuxHWPerfCountersKM(
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	PVR_LOG_RETURN_IF_FALSE(ui32ArrayLen > 0, "ui32ArrayLen is 0",
 	                  PVRSRV_ERROR_INVALID_PARAMS);
@@ -316,7 +308,7 @@ PVRSRV_ERROR PVRSRVRGXConfigMuxHWPerfCountersKM(
 
 	/*PVR_DPF((PVR_DBG_VERBOSE, "PVRSRVRGXConfigMuxHWPerfCountersKM firmware completed"));*/
 
-	PVR_DPF((PVR_DBG_WARNING, "HWPerf %d counter blocks configured and ENABLED", ui32ArrayLen));
+	PVR_DPF((PVR_DBG_MESSAGE, "HWPerf %d counter blocks configured and ENABLED", ui32ArrayLen));
 
 	PVR_DPF_RETURN_OK;
 
@@ -350,7 +342,7 @@ PVRSRV_ERROR PVRSRVRGXConfigCustomCountersKM(
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	PVR_DPF_ENTERED;
 
@@ -467,7 +459,7 @@ PVRSRV_ERROR PVRSRVRGXConfigureHWPerfBlocksKM(
 
 	PVR_UNREFERENCED_PARAMETER(ui32CtrlWord);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	PVR_LOG_RETURN_IF_FALSE(ui32ArrayLen > 0, "ui32ArrayLen is 0",
 	                        PVRSRV_ERROR_INVALID_PARAMS);
@@ -525,7 +517,7 @@ PVRSRV_ERROR PVRSRVRGXConfigureHWPerfBlocksKM(
 	DevmemReleaseCpuVirtAddr(psFwBlkConfigsMemDesc);
 	DevmemFwUnmapAndFree(psDevice, psFwBlkConfigsMemDesc);
 
-	PVR_DPF((PVR_DBG_WARNING, "HWPerf %d counter blocks configured and ENABLED",
+	PVR_DPF((PVR_DBG_MESSAGE, "HWPerf %d counter blocks configured and ENABLED",
 	         ui32ArrayLen));
 
 	PVR_DPF_RETURN_OK;
@@ -579,7 +571,6 @@ PVRSRV_ERROR RGXHWPerfConfigMuxCounters(
 	RGX_KM_HWPERF_DEVDATA* psDevData;
 	RGX_HWPERF_DEVICE *psHWPerfDev;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	/* Validate input argument values supplied by the caller */
 	if (!psHWPerfConnection || ui32NumBlocks==0 || !asBlockConfigs)
@@ -598,6 +589,8 @@ PVRSRV_ERROR RGXHWPerfConfigMuxCounters(
 	{
 		psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
 
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		/* Call the internal server API */
 		eError = PVRSRVRGXConfigMuxHWPerfCountersKM(NULL,
 		                                            psDevData->psRgxDevNode,
@@ -621,8 +614,6 @@ PVRSRV_ERROR RGXHWPerfConfigureAndEnableCustomCounters(
 	PVRSRV_ERROR            eError;
 	RGX_HWPERF_DEVICE       *psHWPerfDev;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Validate input arguments supplied by the caller */
 	PVR_LOG_RETURN_IF_FALSE((NULL != psHWPerfConnection), "psHWPerfConnection invalid",
 	                   PVRSRV_ERROR_INVALID_PARAMS);
@@ -645,6 +636,8 @@ PVRSRV_ERROR RGXHWPerfConfigureAndEnableCustomCounters(
 	{
 		RGX_KM_HWPERF_DEVDATA *psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
 
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		eError = PVRSRVRGXConfigCustomCountersKM(NULL,
 				                                 psDevData->psRgxDevNode,
 												 ui16CustomBlockID, ui16NumCustomCounters, pui32CustomCounterIDs);
diff --git a/drivers/gpu/drm/img-rogue/rgxhwperf.h b/drivers/gpu/drm/img-rogue/rgxhwperf.h
index 16a959c7594a..5191f18f1307 100644
--- a/drivers/gpu/drm/img-rogue/rgxhwperf.h
+++ b/drivers/gpu/drm/img-rogue/rgxhwperf.h
@@ -44,13 +44,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef RGXHWPERF_H_
 #define RGXHWPERF_H_
 
-#include "rgx_fwif_hwperf.h"
 #include "rgxhwperf_common.h"
 
 /******************************************************************************
- * RGX HW Performance Profiling API(s) Rogue specific
+ * RGX HW Performance Profiling API(s)
  *****************************************************************************/
 
+#if defined(RGX_FEATURE_HWPERF_ROGUE)
 PVRSRV_ERROR PVRSRVRGXConfigMuxHWPerfCountersKM(
 	CONNECTION_DATA               *psConnection,
 	PVRSRV_DEVICE_NODE            *psDeviceNode,
@@ -64,6 +64,7 @@ PVRSRV_ERROR PVRSRVRGXConfigCustomCountersKM(
 	IMG_UINT16           ui16CustomBlockID,
 	IMG_UINT16           ui16NumCustomCounters,
 	IMG_UINT32         * pui32CustomCounterIDs);
+#endif
 
 PVRSRV_ERROR PVRSRVRGXConfigureHWPerfBlocksKM(
 	CONNECTION_DATA       * psConnection,
@@ -72,6 +73,7 @@ PVRSRV_ERROR PVRSRVRGXConfigureHWPerfBlocksKM(
 	IMG_UINT32            ui32ArrayLen,
 	RGX_HWPERF_CONFIG_CNTBLK * psBlockConfigs);
 
+#if defined(RGX_FEATURE_HWPERF_ROGUE)
 PVRSRV_ERROR PVRSRVRGXGetConfiguredHWPerfMuxCountersKM(CONNECTION_DATA *psConnection,
                                                        PVRSRV_DEVICE_NODE *psDeviceNode,
                                                        const IMG_UINT32 ui32BlockID,
@@ -81,6 +83,7 @@ PVRSRV_ERROR PVRSRVRGXGetConfiguredHWPerfMuxCounters(PVRSRV_DEVICE_NODE *psDevNo
                                                      RGXFWIF_HWPERF_CTL *psHWPerfCtl,
                                                      IMG_UINT32 ui32BlockID,
                                                      RGX_HWPERF_CONFIG_MUX_CNTBLK *psConfiguredMuxCounters);
+#endif
 
 PVRSRV_ERROR PVRSRVRGXGetConfiguredHWPerfCounters(PVRSRV_DEVICE_NODE *psDevNode,
                                                   RGXFWIF_HWPERF_CTL *psHWPerfCtl,
diff --git a/drivers/gpu/drm/img-rogue/rgxhwperf_common.c b/drivers/gpu/drm/img-rogue/rgxhwperf_common.c
index cf2b4fcf77d5..4a2452651077 100644
--- a/drivers/gpu/drm/img-rogue/rgxhwperf_common.c
+++ b/drivers/gpu/drm/img-rogue/rgxhwperf_common.c
@@ -222,30 +222,115 @@ static IMG_UINT32 RGXHWPerfCopyData(PVRSRV_RGXDEV_INFO *psDeviceInfo,
 	PVR_DPF_RETURN_VAL(uiBytesCopied);
 }
 
+/*
+  RGXHWPerfGetMaxTransfer
+ */
+static IMG_UINT32 RGXHWPerfGetMaxTransfer(PVRSRV_RGXDEV_INFO *psDeviceInfo,
+                                          IMG_UINT32 ui32BytesExp,
+                                          IMG_UINT32 uiL2StreamCopyMask)
+{
+	IMG_UINT32 uiMaxXfer = ui32BytesExp;
+	IMG_UINT32 eL2StreamId;
+
+	for (eL2StreamId = 0; eL2StreamId < RGX_HWPERF_L2_STREAM_LAST; eL2StreamId++)
+	{
+		if (BIT_ISSET(uiL2StreamCopyMask, eL2StreamId))
+		{
+			IMG_UINT32 uiMaxXferSize = TLStreamGetMaxTransfer(
+			                             ui32BytesExp,
+			                             psDeviceInfo->hHWPerfStream[eL2StreamId]);
+
+			if (uiMaxXferSize < uiMaxXfer)
+			{
+				/* New minimum size found, save it for later */
+#if defined(DEBUG)
+				PVR_DPF((PVR_DBG_MESSAGE,
+				         "%s(dev %u, len %u, mask %u) New/Old = [0x%x/0x%x]",
+				         __func__, eL2StreamId, ui32BytesExp,
+				         uiL2StreamCopyMask, uiMaxXferSize, uiMaxXfer));
+#endif
+
+				uiMaxXfer = uiMaxXferSize;
+			}
+#if defined(DEBUG)
+			else
+			{
+				PVR_DPF((PVR_DBG_VERBOSE,
+				         "%s(dev %u, len %u, mask %u) New/Old = [0x%x/0x%x]",
+				         __func__, eL2StreamId, ui32BytesExp,
+				         uiL2StreamCopyMask, uiMaxXferSize, uiMaxXfer));
+			}
+#endif
+		}
+	}
+
+	return uiMaxXfer;
+}
+
 /*
 	RGXHWPerfCopyDataL1toL2
  */
 static IMG_UINT32 RGXHWPerfCopyDataL1toL2(PVRSRV_RGXDEV_INFO* psDeviceInfo,
                                           IMG_BYTE   *pbFwBuffer,
-                                          IMG_UINT32 ui32BytesExp)
+                                          IMG_UINT32 ui32BytesExp,
+                                          IMG_UINT32 uiL2StreamCopyMask)
 {
 	IMG_UINT32 eL2StreamId, uiHWPerfBytesCopied = 0;
 
-	/* Invalidate initial packet header, type/size cast via RGX_HWPEF_GET_PACKET */
-	RGXFwSharedMemCacheOpPtr(RGX_HWPERF_GET_PACKET(pbFwBuffer), INVALIDATE);
-
 	/* HWPERF_MISR_FUNC_DEBUG enables debug code for investigating HWPerf issues */
 #ifdef HWPERF_MISR_FUNC_DEBUG
 	static IMG_UINT32 gui32Ordinal = IMG_UINT32_MAX;
 #endif
 
+	/* Invalidate initial packet header, type/size cast via RGX_HWPEF_GET_PACKET */
+	RGXFwSharedMemCacheOpPtr(RGX_HWPERF_GET_PACKET(pbFwBuffer), INVALIDATE);
+
 	PVR_DPF_ENTERED;
 
 #ifdef HWPERF_MISR_FUNC_DEBUG
-	PVR_DPF((PVR_DBG_VERBOSE, "EVENTS to copy from 0x%p length:%05d",
-			pbFwBuffer, ui32BytesExp));
+	PVR_DPF((PVR_DBG_VERBOSE, "EVENTS to copy from 0x%p length:%05d mask:0x%2x",
+			pbFwBuffer, ui32BytesExp, uiL2StreamCopyMask));
 #endif
 
+	/* Determine the maximum space available in all consumer (L2) streams.
+	 * This limits the amount of data that will be copied if we have multiple
+	 * L2 consumers registered. In this case we only transfer the amount of
+	 * data that can fit into all available L2 consumer streams and so we will
+	 * exert back-pressure onto the L1 buffer whenever one of the L2 consumer
+	 * streams gets filled.
+	 * This effectively lock-steps the L2 consumer streams together.
+	 */
+	ui32BytesExp = RGXHWPerfGetMaxTransfer(psDeviceInfo, ui32BytesExp, uiL2StreamCopyMask);
+
+	for (eL2StreamId = 0; eL2StreamId < RGX_HWPERF_L2_STREAM_LAST; eL2StreamId++)
+	{
+		if (BIT_ISSET(uiL2StreamCopyMask, eL2StreamId))
+		{
+			IMG_UINT32 uiBytesCopied, uiPacketDataSize = ui32BytesExp;
+			IMG_UINT32 uiMaxPacketSize = psDeviceInfo->ui32L2BufMaxPacketSize[eL2StreamId];
+
+			if (ui32BytesExp > uiMaxPacketSize)
+			{
+				uiPacketDataSize = RGXHWPerfGetPackets(ui32BytesExp, uiMaxPacketSize,
+				                                       RGX_HWPERF_GET_PACKET(pbFwBuffer));
+
+				if (uiPacketDataSize == 0)
+				{
+					PVR_DPF((PVR_DBG_ERROR, "Failed to write data into host buffer "
+					        "(%u) as packet is too big and hence it breaches TL "
+					        "packet size limit (TLBufferSize / 2.5)", eL2StreamId));
+
+					continue;
+				}
+			}
+
+			uiBytesCopied = RGXHWPerfCopyData(psDeviceInfo, pbFwBuffer, eL2StreamId,
+			                                  uiPacketDataSize);
+
+			uiHWPerfBytesCopied = MAX(uiBytesCopied, uiHWPerfBytesCopied);
+		}
+	}
+
 #ifdef HWPERF_MISR_FUNC_DEBUG
 	{
 		/* Check the incoming buffer of data has not lost any packets */
@@ -285,39 +370,10 @@ static IMG_UINT32 RGXHWPerfCopyDataL1toL2(PVRSRV_RGXDEV_INFO* psDeviceInfo,
 			}
 			gui32Ordinal = asCurPos->ui32Ordinal;
 			pbFwBufferIter += RGX_HWPERF_GET_SIZE(asCurPos);
-		} while (pbFwBufferIter < pbFwBufferEnd);
+		} while (pbFwBufferIter < pbFwBufferEnd && pbFwBufferIter < (pbFwBuffer + uiHWPerfBytesCopied));
 	}
 #endif
 
-	for (eL2StreamId = 0; eL2StreamId < RGX_HWPERF_L2_STREAM_LAST; eL2StreamId++)
-	{
-		if (!psDeviceInfo->bSuspendHWPerfL2DataCopy[eL2StreamId])
-		{
-			IMG_UINT32 uiBytesCopied, uiPacketDataSize = ui32BytesExp;
-			IMG_UINT32 uiMaxPacketSize = psDeviceInfo->ui32L2BufMaxPacketSize[eL2StreamId];
-
-			if (ui32BytesExp > uiMaxPacketSize)
-			{
-				uiPacketDataSize = RGXHWPerfGetPackets(ui32BytesExp, uiMaxPacketSize,
-				                                       RGX_HWPERF_GET_PACKET(pbFwBuffer));
-
-				if (uiPacketDataSize == 0)
-				{
-					PVR_DPF((PVR_DBG_ERROR, "Failed to write data into host buffer "
-					        "(%u) as packet is too big and hence it breaches TL "
-					        "packet size limit (TLBufferSize / 2.5)", eL2StreamId));
-
-					continue;
-				}
-			}
-
-			uiBytesCopied = RGXHWPerfCopyData(psDeviceInfo, pbFwBuffer, eL2StreamId,
-			                                  uiPacketDataSize);
-
-			uiHWPerfBytesCopied = MAX(uiBytesCopied, uiHWPerfBytesCopied);
-		}
-	}
-
 	/* Return the remaining packets left to be transported. */
 	PVR_DPF_RETURN_VAL(uiHWPerfBytesCopied);
 }
@@ -339,6 +395,10 @@ static INLINE IMG_UINT32 RGXHWPerfAdvanceRIdx(
 	The number of copied data is always the maximum read number of packets.
 	In case where one of the stream is not able to accept the same amount of
 	data as other streams it will suffer from gaps in the data.
+
+	To avoid these gaps, we will exert back-pressure on the L1 buffer by
+	pre-calculating the maximum amount of data that can be copied to all
+	L2 streams (currently a maximum of 2).
  */
 static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 {
@@ -346,29 +406,35 @@ static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 	IMG_BYTE*				psHwPerfInfo = psDevInfo->psRGXFWIfHWPerfBuf;
 	IMG_UINT32				ui32SrcRIdx, ui32SrcWIdx, ui32SrcWrapCount;
 	IMG_UINT32				ui32BytesExp = 0, ui32BytesCopied = 0, ui32BytesCopiedSum = 0;
+	IMG_UINT32				uiStreamCopyMask = 0;
 #ifdef HWPERF_MISR_FUNC_DEBUG
 	IMG_UINT32				ui32BytesExpSum = 0;
 #endif
 
+	/* It's unlikely that we're ever going to have more than 32 consumers
+	 * for the Firmware L1 buffer but check just to be safe. */
+	static_assert(RGX_HWPERF_L2_STREAM_LAST <= sizeof(uiStreamCopyMask) * 8,
+	              "RGX_HWPERF_L2_STREAM_LAST cannot be greater than 32.")
+
 	PVR_DPF_ENTERED;
 
 	/* Caller should check this member is valid before calling */
 	{
-		IMG_UINT32 i, uiSuspendedCount = 0;
+		RGX_HWPERF_L2_STREAM_ID eL2StreamId;
 #if defined(PVRSRV_NEED_PVR_ASSERT)
 		IMG_UINT32 uiNotNullCount = 0;
 #endif
-		for (i = 0; i < RGX_HWPERF_L2_STREAM_LAST; i++)
+		for (eL2StreamId = 0; eL2StreamId < RGX_HWPERF_L2_STREAM_LAST; eL2StreamId++)
 		{
 #if defined(PVRSRV_NEED_PVR_ASSERT)
-			if (psDevInfo->hHWPerfStream[i] != NULL)
+			if (psDevInfo->hHWPerfStream[eL2StreamId] != NULL)
 			{
 				uiNotNullCount++;
 			}
 #endif
-			if (psDevInfo->bSuspendHWPerfL2DataCopy[i])
+			if (!psDevInfo->bSuspendHWPerfL2DataCopy[eL2StreamId])
 			{
-				uiSuspendedCount++;
+				BIT_SET(uiStreamCopyMask, eL2StreamId);
 			}
 		}
 
@@ -377,8 +443,11 @@ static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 		PVR_ASSERT(uiNotNullCount > 0);
 #endif
 
-		/* Only proceed if any of the streams are not suspended. */
-		if (uiSuspendedCount == RGX_HWPERF_L2_STREAM_LAST)
+		/* Only proceed if any of the streams are not suspended.
+		 * Build bit field representing each L2 stream's suspend status. This
+		 * will be passed down the stack for copy function to determine if the
+		 * data should or should not be copied. */
+		if (uiStreamCopyMask == 0)
 		{
 			PVR_DPF((PVR_DBG_MESSAGE, "%s : Copying data to all L2 host buffers for FW events is "
 			        "suspended. Start at least one of the HWPerf consumers or restart the driver "
@@ -431,7 +500,8 @@ static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 #endif
 			ui32BytesCopied = RGXHWPerfCopyDataL1toL2(psDevInfo,
 			                                          psHwPerfInfo + ui32SrcRIdx,
-			                                          ui32BytesExp);
+			                                          ui32BytesExp,
+			                                          uiStreamCopyMask);
 
 			/* Advance the read index and the free bytes counter by the number
 			 * of bytes transported. Items will be left in buffer if not all data
@@ -456,10 +526,10 @@ static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 #ifdef HWPERF_MISR_FUNC_DEBUG
 			ui32BytesExpSum += ui32BytesExp;
 #endif
-			/* Attempt to transfer the packets to the TL stream buffer */
 			ui32BytesCopied = RGXHWPerfCopyDataL1toL2(psDevInfo,
 			                                          psHwPerfInfo + ui32SrcRIdx,
-			                                          ui32BytesExp);
+			                                          ui32BytesExp,
+			                                          uiStreamCopyMask);
 
 			/* Advance read index as before and Update the local copy of the
 			 * read index as it might be used in the last if branch*/
@@ -492,7 +562,8 @@ static IMG_UINT32 RGXHWPerfDataStore(PVRSRV_RGXDEV_INFO	*psDevInfo)
 #endif
 				ui32BytesCopied = RGXHWPerfCopyDataL1toL2(psDevInfo,
 				                                          psHwPerfInfo,
-				                                          ui32BytesExp);
+				                                          ui32BytesExp,
+				                                          uiStreamCopyMask);
 				/* Advance the FW buffer read position. */
 				psFwSysData->sHWPerfCtrl.ui32HWPerfRIdx = RGXHWPerfAdvanceRIdx(
 						psDevInfo->ui32RGXFWIfHWPerfBufSize, ui32SrcRIdx,
@@ -527,11 +598,11 @@ PVRSRV_ERROR RGXHWPerfDataStoreCB(PVRSRV_DEVICE_NODE *psDevInfo)
 	PVRSRV_RGXDEV_INFO* psRgxDevInfo;
 	IMG_UINT32          ui32BytesCopied;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVR_ASSERT(psDevInfo);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevInfo, PVRSRV_OK);
 
 	PVR_DPF_ENTERED;
 
-	PVR_ASSERT(psDevInfo);
 	psRgxDevInfo = psDevInfo->pvDevice;
 
 	/* Store FW event data if the destination buffer exists.*/
@@ -650,13 +721,13 @@ PVRSRV_ERROR RGXHWPerfInit(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
-
 	PVR_DPF_ENTERED;
 
 	/* expecting a valid device info */
 	PVR_RETURN_IF_INVALID_PARAM(psRgxDevInfo != NULL);
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_OK);
+
 	/* Create a lock for HWPerf server module used for serializing, L1 to L2
 	 * copy calls (e.g. in case of TL producer callback) and L1, L2 resource
 	 * allocation */
@@ -714,13 +785,13 @@ static void _HWPerfFWOnReaderOpenCB(void *pvArg)
 	RGXFWIF_KCCB_CMD sKccbCmd;
 	IMG_UINT32 ui32kCCBCommandSlot;
 
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVNODE, psDevNode);
 
 	/* Clear any previously suspended state for bSuspendHWPerfL2DataCopy as we
 	 * now have a reader attached so the data will be delivered upstream. */
 	if (psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_HWPERF])
 	{
-		PVR_DPF((PVR_DBG_WARNING, "%s: Resuming HWPerf FW event collection.",
+		PVR_DPF((PVR_DBG_MESSAGE, "%s: Resuming HWPerf FW event collection.",
 		        __func__));
 		psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_HWPERF] = IMG_FALSE;
 	}
@@ -744,6 +815,13 @@ static void _HWPerfFWOnReaderOpenCB(void *pvArg)
 	eError = RGXWaitForKCCBSlotUpdate(psRgxDevInfo, ui32kCCBCommandSlot, PDUMP_FLAGS_CONTINUOUS);
 	PVR_LOG_RETURN_VOID_IF_ERROR(eError, "RGXWaitForKCCBSlotUpdate");
 }
+
+static void _HWPerfFWOnReaderCloseCB(void *pvArg)
+{
+	PVRSRV_RGXDEV_INFO* psRgxDevInfo = (PVRSRV_RGXDEV_INFO*) pvArg;
+
+	psRgxDevInfo->bSuspendHWPerfL2DataCopy[RGX_HWPERF_L2_STREAM_HWPERF] = IMG_TRUE;
+}
 #endif
 
 /*************************************************************************/ /*!
@@ -765,7 +843,7 @@ PVRSRV_ERROR RGXHWPerfInitOnDemandL1Buffer(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 	PVRSRV_MEMALLOCFLAGS_T uiMemAllocFlags;
 	PVRSRV_ERROR eError;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	PVR_DPF_ENTERED;
 
@@ -790,6 +868,7 @@ PVRSRV_ERROR RGXHWPerfInitOnDemandL1Buffer(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 #else /* Helps show corruption issues in driver-live */
 						| PVRSRV_MEMALLOCFLAG_POISON_ON_ALLOC
 #endif
+						| PVRSRV_MEMALLOCFLAG_RI_FWKMD_ALLOC
 						| PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN);
 
 	/* Allocate HWPerf FW L1 buffer */
@@ -874,7 +953,7 @@ PVRSRV_ERROR RGXHWPerfInitOnDemandL2Stream(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 	TL_STREAM_INFO sTLStreamInfo;
 #endif
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	PVR_ASSERT(eL2StreamId < RGX_HWPERF_L2_STREAM_LAST);
 
@@ -905,6 +984,7 @@ PVRSRV_ERROR RGXHWPerfInitOnDemandL2Stream(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 								psRgxDevInfo->ui32RGXL2HWPerfBufSize,
 								TL_OPMODE_DROP_NEWER | TL_FLAG_NO_SIGNAL_ON_COMMIT,
 								_HWPerfFWOnReaderOpenCB, psRgxDevInfo,
+								_HWPerfFWOnReaderCloseCB, psRgxDevInfo,
 #if !defined(SUPPORT_TL_PRODUCER_CALLBACK)
 								NULL, NULL
 #else
@@ -964,12 +1044,12 @@ void RGXHWPerfDeinitL2Stream(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 {
 	IMG_HANDLE hStream;
 
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
-
 	PVR_DPF_ENTERED;
 
 	PVR_ASSERT(psRgxDevInfo);
 
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVINFO, psRgxDevInfo);
+
 	hStream = psRgxDevInfo->hHWPerfStream[eL2StreamId];
 
 	/* Clean up the L2 buffer stream object if allocated */
@@ -1018,8 +1098,9 @@ static PVRSRV_ERROR RGXHWPerfCtrlFwBuffer(const PVRSRV_DEVICE_NODE *psDeviceNode
 	RGXFWIF_KCCB_CMD sKccbCmd;
 	IMG_UINT32 ui32kCCBCommandSlot;
 	IMG_UINT64 ui64MaskValue = ui64Mask;
+	IMG_UINT64 ui64OldMaskValue;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	PVR_ASSERT(eL2StreamId < RGX_HWPERF_L2_STREAM_LAST);
 
@@ -1077,6 +1158,11 @@ static PVRSRV_ERROR RGXHWPerfCtrlFwBuffer(const PVRSRV_DEVICE_NODE *psDeviceNode
 		goto done_;
 	}
 
+	ui64OldMaskValue = psDevice->ui64HWPerfFilter[eL2StreamId];
+	ui64MaskValue = RGXHWPerfFwSetEventFilter(psDevice, eL2StreamId, bToggle
+	                                          ? psDevice->ui64HWPerfFilter[eL2StreamId] ^ ui64MaskValue
+	                                          : ui64MaskValue);
+
 	/* Prepare command parameters ... */
 	sKccbCmd.eCmdType = RGXFWIF_KCCB_CMD_HWPERF_UPDATE_CONFIG;
 	sKccbCmd.uCmdData.sHWPerfCtrl.eOpCode = bToggle ? RGXFWIF_HWPERF_CTRL_TOGGLE : RGXFWIF_HWPERF_CTRL_SET;
@@ -1092,16 +1178,12 @@ static PVRSRV_ERROR RGXHWPerfCtrlFwBuffer(const PVRSRV_DEVICE_NODE *psDeviceNode
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to set new HWPerfFW filter in "
 				"firmware (error = %d)", __func__, eError));
-		goto return_;
+		goto restore_mask_;
 	}
 
-	(void) RGXHWPerfFwSetEventFilter(psDevice, eL2StreamId, bToggle
-	                                 ? psDevice->ui64HWPerfFilter[eL2StreamId] ^ ui64Mask
-	                                 : ui64MaskValue);
-
 	/* Wait for FW to complete */
 	eError = RGXWaitForKCCBSlotUpdate(psDevice, ui32kCCBCommandSlot, PDUMP_FLAGS_CONTINUOUS);
-	PVR_LOG_GOTO_IF_ERROR(eError, "RGXWaitForKCCBSlotUpdate", return_);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXWaitForKCCBSlotUpdate", restore_mask_);
 
 done_:
 	return PVRSRV_OK;
@@ -1109,7 +1191,11 @@ static PVRSRV_ERROR RGXHWPerfCtrlFwBuffer(const PVRSRV_DEVICE_NODE *psDeviceNode
 unlock_and_return:
 	OSLockRelease(psDevice->hHWPerfLock);
 
-return_:
+	return eError;
+
+restore_mask_:
+	(void) RGXHWPerfFwSetEventFilter(psDevice, eL2StreamId, ui64OldMaskValue);
+
 	return eError;
 }
 
@@ -1125,7 +1211,6 @@ static PVRSRV_ERROR RGXHWPerfCtrlHostBuffer(const PVRSRV_DEVICE_NODE *psDeviceNo
 	IMG_UINT32 ui32OldFilter = psDevice->ui32HWPerfHostFilter;
 #endif
 
-	OSLockAcquire(psDevice->hLockHWPerfHostStream);
 	if (psDevice->hHWPerfHostStream == NULL)
 	{
 		eError = RGXHWPerfHostInitOnDemandResources(psDevice);
@@ -1134,11 +1219,11 @@ static PVRSRV_ERROR RGXHWPerfCtrlHostBuffer(const PVRSRV_DEVICE_NODE *psDeviceNo
 			PVR_DPF((PVR_DBG_ERROR,
 					 "%s: Initialisation of on-demand HWPerfHost resources failed",
 					 __func__));
-			OSLockRelease(psDevice->hLockHWPerfHostStream);
 			return eError;
 		}
 	}
 
+	OSLockAcquire(psDevice->hLockHWPerfHostStream);
 	psDevice->ui32HWPerfHostFilter = bToggle ?
 			psDevice->ui32HWPerfHostFilter ^ ui32Mask : ui32Mask;
 
@@ -1170,18 +1255,16 @@ static PVRSRV_ERROR RGXHWPerfCtrlHostBuffer(const PVRSRV_DEVICE_NODE *psDeviceNo
 
 	OSLockRelease(psDevice->hLockHWPerfHostStream);
 
-#if defined(DEBUG)
 	if (bToggle)
 	{
-		PVR_DPF((PVR_DBG_WARNING, "HWPerfHost events (%x) have been TOGGLED",
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerfHost events (%x) have been TOGGLED",
 				ui32Mask));
 	}
 	else
 	{
-		PVR_DPF((PVR_DBG_WARNING, "HWPerfHost mask has been SET to (%x)",
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerfHost mask has been SET to (%x)",
 				ui32Mask));
 	}
-#endif
 
 	return PVRSRV_OK;
 }
@@ -1201,18 +1284,16 @@ static PVRSRV_ERROR RGXHWPerfCtrlClientBuffer(IMG_BOOL bToggle,
 			psData->pui32InfoPage[ui32InfoPageIdx] ^ ui32Mask : ui32Mask;
 	OSLockRelease(psData->hInfoPageLock);
 
-#if defined(DEBUG)
 	if (bToggle)
 	{
-		PVR_DPF((PVR_DBG_WARNING, "HWPerfClient (%u) events (%x) have been TOGGLED",
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerfClient (%u) events (%x) have been TOGGLED",
 				ui32InfoPageIdx, ui32Mask));
 	}
 	else
 	{
-		PVR_DPF((PVR_DBG_WARNING, "HWPerfClient (%u) mask has been SET to (%x)",
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerfClient (%u) mask has been SET to (%x)",
 				ui32InfoPageIdx, ui32Mask));
 	}
-#endif
 
 	return PVRSRV_OK;
 }
@@ -1224,6 +1305,8 @@ PVRSRV_ERROR PVRSRVRGXGetHWPerfBvncFeatureFlagsKM(CONNECTION_DATA    *psConnecti
 	PVRSRV_RGXDEV_INFO *psDevInfo;
 	PVRSRV_ERROR        eError;
 
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	PVR_LOG_RETURN_IF_FALSE((NULL != psDeviceNode), "psDeviceNode invalid", PVRSRV_ERROR_INVALID_PARAMS);
 
 	psDevInfo = psDeviceNode->pvDevice;
@@ -1534,10 +1617,10 @@ PVRSRV_ERROR RGXHWPerfHostInit(PVRSRV_RGXDEV_INFO *psRgxDevInfo, IMG_UINT32 ui32
 {
 	PVRSRV_ERROR eError;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
-
 	PVR_RETURN_IF_INVALID_PARAM(psRgxDevInfo != NULL);
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_OK);
+
 	eError = OSLockCreate(&psRgxDevInfo->hLockHWPerfHostStream);
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate", error);
 
@@ -1687,7 +1770,7 @@ PVRSRV_ERROR RGXHWPerfHostInitOnDemandResources(PVRSRV_RGXDEV_INFO *psRgxDevInfo
 	/* 4 makes space up to "hwperf_host_999" streams */
 	IMG_CHAR pszHWPerfHostStreamName[sizeof(PVRSRV_TL_HWPERF_HOST_SERVER_STREAM) + 4];
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	if (psRgxDevInfo->hHWPerfHostStream != NULL)
 	{
@@ -1711,7 +1794,7 @@ PVRSRV_ERROR RGXHWPerfHostInitOnDemandResources(PVRSRV_RGXDEV_INFO *psRgxDevInfo
 	                        pszHWPerfHostStreamName, psRgxDevInfo->ui32HWPerfHostBufSize,
 	                        TL_OPMODE_DROP_NEWER,
 	                        _HWPerfHostOnConnectCB, psRgxDevInfo,
-	                        NULL, NULL);
+	                        NULL, NULL, NULL, NULL);
 	PVR_LOG_RETURN_IF_ERROR(eError, "TLStreamCreate");
 
 	eError = TLStreamSetNotifStream(psRgxDevInfo->hHWPerfHostStream,
@@ -1775,10 +1858,10 @@ PVRSRV_ERROR RGXHWPerfHostInitOnDemandResources(PVRSRV_RGXDEV_INFO *psRgxDevInfo
 
 void RGXHWPerfHostDeInit(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 {
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
-
 	PVR_ASSERT (psRgxDevInfo);
 
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVINFO, psRgxDevInfo);
+
 	if (psRgxDevInfo->pui8DeferredEvents)
 	{
 		OSFreeMem(psRgxDevInfo->pui8DeferredEvents);
@@ -1835,7 +1918,7 @@ static IMG_UINT64 RGXHWPerfFwSetEventFilterNoLock(PVRSRV_RGXDEV_INFO *psRgxDevIn
 	psRgxDevInfo->ui64HWPerfFwFilter = uiTmpFilter;
 
 #if !defined(NO_HARDWARE)
-	PVR_DPF((PVR_DBG_WARNING, "HWPerfFW mask has been SET to 0x%" IMG_UINT64_FMTSPECx
+	PVR_DPF((PVR_DBG_MESSAGE, "HWPerfFW mask has been SET to 0x%" IMG_UINT64_FMTSPECx
 	         " (stream %u value SET to 0x%" IMG_UINT64_FMTSPECx ")",
 	         psRgxDevInfo->ui64HWPerfFwFilter, eL2StreamId,
 	         psRgxDevInfo->ui64HWPerfFilter[eL2StreamId]));
@@ -1859,7 +1942,7 @@ IMG_UINT64 RGXHWPerfFwSetEventFilter(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 
 inline void RGXHWPerfHostSetEventFilter(PVRSRV_RGXDEV_INFO *psRgxDevInfo, IMG_UINT32 ui32Filter)
 {
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVINFO, psRgxDevInfo);
 	psRgxDevInfo->ui32HWPerfHostFilter = ui32Filter;
 }
 
@@ -2165,8 +2248,7 @@ static void _GetHWPerfHostPacketSpecifics(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 	OSSpinLockRelease(psRgxDevInfo->hHWPerfHostSpinLock, uiFlags);
 }
 
-static inline void _SetupHostPacketHeader(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
-                                          IMG_UINT8 *pui8Dest,
+static inline void _SetupHostPacketHeader(IMG_UINT8 *pui8Dest,
                                           RGX_HWPERF_HOST_EVENT_TYPE eEvType,
                                           IMG_UINT32 ui32Size,
                                           IMG_UINT32 ui32Ordinal,
@@ -2237,7 +2319,7 @@ void RGXHWPerfHostPostRaw(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, eEvType, ui32PktSize, ui32Ordinal, ui64Timestamp);
+	_SetupHostPacketHeader(pui8Dest, eEvType, ui32PktSize, ui32Ordinal, ui64Timestamp);
 	OSDeviceMemCopy((IMG_UINT8*)IMG_OFFSET_ADDR(pui8Dest, sizeof(RGX_HWPERF_V2_PACKET_HDR)), pbPayload, ui32PayloadSize);
 	_CommitHWPerfStream(psRgxDevInfo, ui32PktSize);
 
@@ -2274,7 +2356,7 @@ void RGXHWPerfHostPostEnqEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_ENQ, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_ENQ, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 	_SetupHostEnqPacketData(pui8Dest,
 	                        eEnqType,
@@ -2410,7 +2492,7 @@ void RGXHWPerfHostPostUfoEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		pui8Dest = GET_DE_EVENT_DATA(pui8Dest);
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_UFO, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_UFO, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 	_SetupHostUfoPacketData(pui8Dest, eUfoType, psUFOData);
 
@@ -2446,8 +2528,10 @@ static inline IMG_UINT32 _FixNameAndCalculateHostAllocPacketSize(
 	if (*ppsName != NULL && *ui32NameSize > 0)
 	{
 		/* if string longer than maximum cut it (leave space for '\0') */
-		if (*ui32NameSize >= PVRSRV_SYNC_NAME_LENGTH)
+		if ((*ui32NameSize +1U) >= PVRSRV_SYNC_NAME_LENGTH)
 			*ui32NameSize = PVRSRV_SYNC_NAME_LENGTH;
+		else
+			*ui32NameSize += 1U;
 	}
 	else
 	{
@@ -2502,19 +2586,27 @@ static inline void _SetupHostAllocPacketData(IMG_UINT8 *pui8Dest,
 	switch (eAllocType)
 	{
 		case RGX_HWPERF_HOST_RESOURCE_TYPE_SYNC:
-			psData->uAllocDetail.sSyncAlloc = puAllocDetail->sSyncAlloc;
+			psData->uAllocDetail.sSyncAlloc.ui32FWAddr = puAllocDetail->sSyncAlloc.ui32FWAddr;
 			acName = psData->uAllocDetail.sSyncAlloc.acName;
 			break;
 		case RGX_HWPERF_HOST_RESOURCE_TYPE_FENCE_PVR:
-			psData->uAllocDetail.sFenceAlloc = puAllocDetail->sFenceAlloc;
+			psData->uAllocDetail.sFenceAlloc.uiPID = puAllocDetail->sFenceAlloc.uiPID;
+			psData->uAllocDetail.sFenceAlloc.hFence = puAllocDetail->sFenceAlloc.hFence;
+			psData->uAllocDetail.sFenceAlloc.ui32CheckPt_FWAddr = puAllocDetail->sFenceAlloc.ui32CheckPt_FWAddr;
 			acName = psData->uAllocDetail.sFenceAlloc.acName;
 			break;
 		case RGX_HWPERF_HOST_RESOURCE_TYPE_FENCE_SW:
-			psData->uAllocDetail.sSWFenceAlloc = puAllocDetail->sSWFenceAlloc;
+			psData->uAllocDetail.sSWFenceAlloc.uiPID = puAllocDetail->sSWFenceAlloc.uiPID;
+			psData->uAllocDetail.sSWFenceAlloc.hSWFence = puAllocDetail->sSWFenceAlloc.hSWFence;
+			psData->uAllocDetail.sSWFenceAlloc.hSWTimeline = puAllocDetail->sSWFenceAlloc.hSWTimeline;
+			psData->uAllocDetail.sSWFenceAlloc.ui64SyncPtIndex = puAllocDetail->sSWFenceAlloc.ui64SyncPtIndex;
 			acName = psData->uAllocDetail.sSWFenceAlloc.acName;
 			break;
 		case RGX_HWPERF_HOST_RESOURCE_TYPE_SYNC_CP:
-			psData->uAllocDetail.sSyncCheckPointAlloc = puAllocDetail->sSyncCheckPointAlloc;
+			psData->uAllocDetail.sSyncCheckPointAlloc.ui32CheckPt_FWAddr = puAllocDetail->sSyncCheckPointAlloc.ui32CheckPt_FWAddr;
+			psData->uAllocDetail.sSyncCheckPointAlloc.hTimeline = puAllocDetail->sSyncCheckPointAlloc.hTimeline;
+			psData->uAllocDetail.sSyncCheckPointAlloc.uiPID = puAllocDetail->sSyncCheckPointAlloc.uiPID;
+			psData->uAllocDetail.sSyncCheckPointAlloc.hFence = puAllocDetail->sSyncCheckPointAlloc.hFence;
 			acName = psData->uAllocDetail.sSyncCheckPointAlloc.acName;
 			break;
 		default:
@@ -2529,7 +2621,7 @@ static inline void _SetupHostAllocPacketData(IMG_UINT8 *pui8Dest,
 	{
 		if (ui32NameSize)
 		{
-			OSStringLCopy(acName, psName, ui32NameSize);
+			OSStringSafeCopy(acName, psName, ui32NameSize);
 		}
 		else
 		{
@@ -2563,7 +2655,7 @@ void RGXHWPerfHostPostAllocEvent(PVRSRV_RGXDEV_INFO* psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_ALLOC, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_ALLOC, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 
 	_SetupHostAllocPacketData(pui8Dest,
@@ -2581,7 +2673,6 @@ void RGXHWPerfHostPostAllocEvent(PVRSRV_RGXDEV_INFO* psRgxDevInfo,
 static inline void _SetupHostFreePacketData(IMG_UINT8 *pui8Dest,
                                             RGX_HWPERF_HOST_RESOURCE_TYPE eFreeType,
                                             IMG_UINT64 ui64UID,
-                                            IMG_UINT32 ui32PID,
                                             IMG_UINT32 ui32FWAddr)
 {
 	RGX_HWPERF_HOST_FREE_DATA *psData = (RGX_HWPERF_HOST_FREE_DATA *)
@@ -2619,6 +2710,8 @@ void RGXHWPerfHostPostFreeEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 	IMG_UINT32 ui32Ordinal;
 	IMG_UINT64 ui64Timestamp;
 
+	PVR_UNREFERENCED_PARAMETER(ui32PID);
+
 	_GetHWPerfHostPacketSpecifics(psRgxDevInfo, &ui32Ordinal, &ui64Timestamp,
 	                              NULL, IMG_TRUE);
 	_PostFunctionPrologue(psRgxDevInfo, ui32Ordinal);
@@ -2628,12 +2721,11 @@ void RGXHWPerfHostPostFreeEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_FREE, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_FREE, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 	_SetupHostFreePacketData(pui8Dest,
 	                         eFreeType,
 	                         ui64UID,
-	                         ui32PID,
 	                         ui32FWAddr);
 
 	_CommitHWPerfStream(psRgxDevInfo, ui32Size);
@@ -2718,7 +2810,7 @@ static inline void _SetupHostModifyPacketData(IMG_UINT8 *pui8Dest,
 	{
 		if (ui32NameSize)
 		{
-			OSStringLCopy(acName, psName, ui32NameSize);
+			OSStringSafeCopy(acName, psName, ui32NameSize);
 		}
 		else
 		{
@@ -2753,7 +2845,7 @@ void RGXHWPerfHostPostModifyEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_MODIFY, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_MODIFY, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 	_SetupHostModifyPacketData(pui8Dest,
 	                           eModifyType,
@@ -2773,15 +2865,15 @@ static inline void _SetupHostClkSyncPacketData(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 {
 	RGX_HWPERF_HOST_CLK_SYNC_DATA *psData = (RGX_HWPERF_HOST_CLK_SYNC_DATA *)
 					IMG_OFFSET_ADDR(pui8Dest, sizeof(RGX_HWPERF_V2_PACKET_HDR));
-	RGXFWIF_GPU_UTIL_FWCB *psGpuUtilFWCB = psRgxDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psRgxDevInfo->psRGXFWIfGpuUtilFW;
 	IMG_UINT32 ui32CurrIdx;
 	RGXFWIF_TIME_CORR *psTimeCorr;
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->ui32TimeCorrSeqCount, INVALIDATE);
-	ui32CurrIdx = RGXFWIF_TIME_CORR_CURR_INDEX(psGpuUtilFWCB->ui32TimeCorrSeqCount);
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->ui32TimeCorrSeqCount, INVALIDATE);
+	ui32CurrIdx = RGXFWIF_TIME_CORR_CURR_INDEX(psGpuUtilFW->ui32TimeCorrSeqCount);
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->sTimeCorr[ui32CurrIdx], INVALIDATE);
-	psTimeCorr = &psGpuUtilFWCB->sTimeCorr[ui32CurrIdx];
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->sTimeCorr[ui32CurrIdx], INVALIDATE);
+	psTimeCorr = &psGpuUtilFW->sTimeCorr[ui32CurrIdx];
 
 	psData->ui64CRTimestamp = psTimeCorr->ui64CRTimeStamp;
 	psData->ui64OSTimestamp = psTimeCorr->ui64OSTimeStamp;
@@ -2798,7 +2890,7 @@ void RGXHWPerfHostPostClkSyncEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 
 	/* if the buffer for time correlation data is not yet available (possibly
 	 * device not initialised yet) skip this event */
-	if (psRgxDevInfo->psRGXFWIfGpuUtilFWCb == NULL)
+	if (psRgxDevInfo->psRGXFWIfGpuUtilFW == NULL)
 	{
 		return;
 	}
@@ -2812,7 +2904,7 @@ void RGXHWPerfHostPostClkSyncEvent(PVRSRV_RGXDEV_INFO *psRgxDevInfo)
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_CLK_SYNC, ui32Size,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_CLK_SYNC, ui32Size,
 	                       ui32Ordinal, ui64Timestamp);
 	_SetupHostClkSyncPacketData(psRgxDevInfo, pui8Dest);
 
@@ -2909,7 +3001,7 @@ void RGXHWPerfHostPostDeviceInfo(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 
 		if ((pui8Dest = _ReserveHWPerfStream(psRgxDevInfo, ui32Size)) != NULL)
 		{
-			_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_DEV_INFO, ui32Size, ui32Ordinal, ui64Timestamp);
+			_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_DEV_INFO, ui32Size, ui32Ordinal, ui64Timestamp);
 			_SetupHostDeviceInfoPacketData(psRgxDevInfo, eEvType, puData, pui8Dest);
 			_CommitHWPerfStream(psRgxDevInfo, ui32Size);
 		}
@@ -2967,7 +3059,7 @@ static inline IMG_UINT32 _CalculateHostInfoPacketSize(RGX_HWPERF_INFO_EV eEvType
 			if (PVRSRVGetProcessMemUsage(pui64TotalMemoryUsage, pui32LivePids, ppsPerProcessMemUsage) == PVRSRV_OK)
 			{
 				ui32Size += offsetof(RGX_HWPERF_HOST_INFO_DETAIL, sMemUsageStats.sPerProcessUsage)
-					+ ((*pui32LivePids) * sizeof(((RGX_HWPERF_HOST_INFO_DETAIL*)0)->sMemUsageStats.sPerProcessUsage));
+					+ ((*pui32LivePids) * sizeof(struct _RGX_HWPERF_HOST_INFO_PER_PROC_USAGE_));
 			}
 #else
 			PVR_DPF((PVR_DBG_ERROR, "This functionality is not yet implemented for this platform"));
@@ -3004,7 +3096,7 @@ void RGXHWPerfHostPostInfo(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 
 		if ((pui8Dest = _ReserveHWPerfStream(psRgxDevInfo, ui32Size)) != NULL)
 		{
-			_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_INFO, ui32Size, ui32Ordinal, ui64Timestamp);
+			_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_INFO, ui32Size, ui32Ordinal, ui64Timestamp);
 			_SetupHostInfoPacketData(eEvType, ui64TotalMemoryUsage, ui32LivePids, psPerProcessMemUsage, pui8Dest);
 			_CommitHWPerfStream(psRgxDevInfo, ui32Size);
 		}
@@ -3095,7 +3187,7 @@ void RGXHWPerfHostPostFenceWait(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_SYNC_FENCE_WAIT,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_SYNC_FENCE_WAIT,
 	                       ui32Size, ui32Ordinal, ui64Timestamp);
 	_SetupHostFenceWaitPacketData(pui8Dest, eType, uiPID, hFence, ui32Data);
 
@@ -3147,7 +3239,7 @@ void RGXHWPerfHostPostSWTimelineAdv(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_SYNC_SW_TL_ADVANCE,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_SYNC_SW_TL_ADVANCE,
 	                       ui32Size, ui32Ordinal, ui64Timestamp);
 	_SetupHostSWTimelineAdvPacketData(pui8Dest, uiPID, hSWTimeline, ui64SyncPtIndex);
 
@@ -3181,7 +3273,7 @@ void RGXHWPerfHostPostClientInfoProcName(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 		goto cleanup;
 	}
 
-	_SetupHostPacketHeader(psRgxDevInfo, pui8Dest, RGX_HWPERF_HOST_CLIENT_INFO,
+	_SetupHostPacketHeader(pui8Dest, RGX_HWPERF_HOST_CLIENT_INFO,
 	                       ui32Size, ui32Ordinal, ui64Timestamp);
 
 	psPkt = (RGX_HWPERF_HOST_CLIENT_INFO_DATA*)IMG_OFFSET_ADDR(pui8Dest, sizeof(RGX_HWPERF_V2_PACKET_HDR));
@@ -3236,8 +3328,6 @@ PVRSRV_ERROR RGXHWPerfLazyConnect(RGX_HWPERF_CONNECTION** ppsHWPerfConnection)
 	RGX_HWPERF_CONNECTION* psHWPerfConnection;
 	IMG_BOOL bFWActive = IMG_FALSE;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* avoid uninitialised data */
 	PVR_ASSERT(*ppsHWPerfConnection == NULL);
 	PVR_ASSERT(psPVRSRVData);
@@ -3256,6 +3346,12 @@ PVRSRV_ERROR RGXHWPerfLazyConnect(RGX_HWPERF_CONNECTION** ppsHWPerfConnection)
 
 	while (psDeviceNode)
 	{
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+		{
+			OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
+			return PVRSRV_ERROR_NOT_IMPLEMENTED;
+		}
+
 		if (psDeviceNode->eDevState != PVRSRV_DEVICE_STATE_ACTIVE)
 		{
 			PVR_DPF((PVR_DBG_WARNING,
@@ -3328,8 +3424,6 @@ PVRSRV_ERROR RGXHWPerfOpen(RGX_HWPERF_CONNECTION *psHWPerfConnection)
 	IMG_UINT32 ui32StreamFlags = PVRSRV_STREAM_FLAG_ACQUIRE_NONBLOCKING |
 			PVRSRV_STREAM_FLAG_DISABLE_PRODUCER_CALLBACK;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Validate input argument values supplied by the caller */
 	if (!psHWPerfConnection)
 	{
@@ -3342,6 +3436,8 @@ PVRSRV_ERROR RGXHWPerfOpen(RGX_HWPERF_CONNECTION *psHWPerfConnection)
 		psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
 		psRgxDevInfo = psDevData->psRgxDevInfo;
 
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		/* In the case where the AppHint has not been set we need to
 		 * initialise the HWPerf resources here. Allocated on-demand
 		 * to reduce RAM foot print on systems not needing HWPerf.
@@ -3458,8 +3554,6 @@ PVRSRV_ERROR RGXHWPerfConnect(RGX_HWPERF_CONNECTION** ppsHWPerfConnection)
 {
 	PVRSRV_ERROR eError;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	eError = RGXHWPerfLazyConnect(ppsHWPerfConnection);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXHWPerfLazyConnect", e0);
 
@@ -3493,14 +3587,14 @@ PVRSRV_ERROR PVRSRVRGXControlHWPerfBlocksKM(
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVR_ASSERT(psDeviceNode);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	PVR_DPF_ENTERED;
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psBlockIDs != NULL, "psBlockIDs");
 	PVR_LOG_RETURN_IF_INVALID_PARAM((ui32ArrayLen>0) && (ui32ArrayLen <= RGXFWIF_HWPERF_CTRL_BLKS_MAX), "ui32ArrayLen");
 
-	PVR_ASSERT(psDeviceNode);
 	psDevice = psDeviceNode->pvDevice;
 
 	/* Fill in the command structure with the parameters needed
@@ -3525,13 +3619,14 @@ PVRSRV_ERROR PVRSRVRGXControlHWPerfBlocksKM(
 	eError = RGXWaitForKCCBSlotUpdate(psDevice, ui32kCCBCommandSlot, PDUMP_FLAGS_CONTINUOUS);
 	PVR_LOG_RETURN_IF_ERROR(eError, "RGXWaitForKCCBSlotUpdate");
 
-
-#if defined(DEBUG)
 	if (bEnable)
-		PVR_DPF((PVR_DBG_WARNING, "HWPerf %d counter blocks have been ENABLED", ui32ArrayLen));
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerf %d counter blocks have been ENABLED", ui32ArrayLen));
+	}
 	else
-		PVR_DPF((PVR_DBG_WARNING, "HWPerf %d counter blocks have been DISABLED", ui32ArrayLen));
-#endif
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "HWPerf %d counter blocks have been DISABLED", ui32ArrayLen));
+	}
 
 	PVR_DPF_RETURN_OK;
 }
@@ -3548,10 +3643,10 @@ PVRSRV_ERROR PVRSRVRGXCtrlHWPerfKM(
 {
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
+	PVR_ASSERT(psDeviceNode);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
 
 	PVR_DPF_ENTERED;
-	PVR_ASSERT(psDeviceNode);
 
 	if (eStreamId == RGX_HWPERF_STREAM_ID0_FW)
 	{
@@ -3635,8 +3730,6 @@ PVRSRV_ERROR RGXHWPerfControl(
 	RGX_KM_HWPERF_DEVDATA* psDevData;
 	RGX_HWPERF_DEVICE* psHWPerfDev;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Validate input argument values supplied by the caller */
 	if (!psHWPerfConnection)
 	{
@@ -3649,6 +3742,8 @@ PVRSRV_ERROR RGXHWPerfControl(
 	{
 		psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
 
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		/* Call the internal server API */
 		eError = PVRSRVRGXCtrlHWPerfKM(NULL, psDevData->psRgxDevNode, eStreamId, bToggle, ui64Mask);
 		PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVRGXCtrlHWPerfKM");
@@ -3678,8 +3773,6 @@ IMG_INTERNAL PVRSRV_ERROR RGXHWPerfToggleCounters(
 	RGX_KM_HWPERF_DEVDATA* psDevData;
 	RGX_HWPERF_DEVICE*     psHWPerfDev;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	if (!psHWPerfConnection || ui32NumBlocks==0 || !aeBlockIDs)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -3696,6 +3789,8 @@ IMG_INTERNAL PVRSRV_ERROR RGXHWPerfToggleCounters(
 	{
 		psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
 
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		/* Call the internal server API */
 		eError = PVRSRVRGXControlHWPerfBlocksKM(NULL,
 		                                        psDevData->psRgxDevNode,
@@ -3750,8 +3845,6 @@ PVRSRV_ERROR RGXHWPerfAcquireEvents(
 	PVRSRVTL_PPACKETHDR psHDRptr;
 	PVRSRVTL_PACKETTYPE ui16TlType;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Reset the output arguments in case we discover an error */
 	*ppBuf = NULL;
 	*pui32BufLen = 0;
@@ -3762,6 +3855,8 @@ PVRSRV_ERROR RGXHWPerfAcquireEvents(
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 	if (psDevData->pTlBuf[eStreamId] == NULL)
 	{
 		/* Acquire some data to read from the HWPerf TL stream */
@@ -3849,14 +3944,14 @@ PVRSRV_ERROR RGXHWPerfReleaseEvents(
 	PVRSRV_ERROR			eError = PVRSRV_OK;
 	RGX_KM_HWPERF_DEVDATA*	psDevData = (RGX_KM_HWPERF_DEVDATA*)hDevData;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Valid input argument values supplied by the caller */
 	if (!psDevData || eStreamId >= RGX_HWPERF_MAX_STREAM_ID)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 	if (psDevData->bRelease[eStreamId])
 	{
 		/* Inform the TL that we are done with reading the data. */
@@ -3880,8 +3975,6 @@ PVRSRV_ERROR RGXHWPerfGetFilter(
 	PVRSRV_RGXDEV_INFO* psRgxDevInfo =
 			hDevData ? ((RGX_KM_HWPERF_DEVDATA*) hDevData)->psRgxDevInfo : NULL;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	/* Valid input argument values supplied by the caller */
 	if (!psRgxDevInfo)
 	{
@@ -3890,6 +3983,8 @@ PVRSRV_ERROR RGXHWPerfGetFilter(
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVINFO, psRgxDevInfo, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 	/* No need to take hHWPerfLock here since we are only reading data
 	 * from always existing integers to return to debugfs which is an
 	 * atomic operation.
@@ -3922,8 +4017,6 @@ PVRSRV_ERROR RGXHWPerfFreeConnection(RGX_HWPERF_CONNECTION** ppsHWPerfConnection
 		return PVRSRV_OK;
 	}
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	psHWPerfNextDev = psHWPerfConnection->psHWPerfDevList;
 	while (psHWPerfNextDev)
 	{
@@ -3955,12 +4048,13 @@ PVRSRV_ERROR RGXHWPerfClose(RGX_HWPERF_CONNECTION *psHWPerfConnection)
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	psHWPerfDev = psHWPerfConnection->psHWPerfDevList;
 	while (psHWPerfDev)
 	{
 		psDevData = (RGX_KM_HWPERF_DEVDATA *) psHWPerfDev->hDevData;
+
+		PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevData->psRgxDevNode, PVRSRV_ERROR_NOT_IMPLEMENTED);
+
 		for (uiStreamId = 0; uiStreamId < RGX_HWPERF_MAX_STREAM_ID; uiStreamId++)
 		{
 			/* If the TL buffer exists they have not called ReleaseData
@@ -4008,8 +4102,6 @@ PVRSRV_ERROR RGXHWPerfDisconnect(RGX_HWPERF_CONNECTION** ppsHWPerfConnection)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_IMPLEMENTED);
-
 	eError = RGXHWPerfClose(*ppsHWPerfConnection);
 	PVR_LOG_IF_ERROR(eError, "RGXHWPerfClose");
 
diff --git a/drivers/gpu/drm/img-rogue/rgxhwperf_common.h b/drivers/gpu/drm/img-rogue/rgxhwperf_common.h
index 6544e524a4a4..9b14d15cb64f 100644
--- a/drivers/gpu/drm/img-rogue/rgxhwperf_common.h
+++ b/drivers/gpu/drm/img-rogue/rgxhwperf_common.h
@@ -53,6 +53,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxdevice.h"
 #include "rgx_hwperf.h"
 #include "rgx_fwif_hwperf.h"
+#if defined(PVR_ARCH_VOLCANIC)
+#include "rgx_hwperf_table.h"
+#endif
 #include "cache_ops.h"
 #include "rgxfwmemctx.h"
 
@@ -286,6 +289,25 @@ void RGXHWPerfHostPostClientInfoProcName(PVRSRV_RGXDEV_INFO *psRgxDevInfo,
 
 IMG_BOOL RGXHWPerfHostIsEventEnabled(PVRSRV_RGXDEV_INFO *psRgxDevInfo, RGX_HWPERF_HOST_EVENT_TYPE eEvent);
 
+#if defined(PVR_ARCH_VOLCANIC)
+IMG_INTERNAL /*static inline*/ IMG_UINT32
+RGXGetHWPerfBlockConfig(const RGXFW_HWPERF_CNTBLK_TYPE_MODEL **ppsModel);
+
+/*!
+*******************************************************************************
+ @Function    RGXHWPerfMaxDefinedBlks
+
+ @Description Return the number of valid block-IDs for the given device node
+
+ @Input       (PVRSRV_RGXDEV_INFO *)   pvDevice    device-node to query
+
+ @Returns     (IMG_UINT32)             Number of block-IDs (RGX_CNTBLK_ID)
+                                       valid for this device.
+******************************************************************************/
+IMG_INTERNAL IMG_UINT32
+RGXHWPerfMaxDefinedBlks(PVRSRV_RGXDEV_INFO *psDevInfo);
+#endif
+
 #define _RGX_HWPERF_HOST_FILTER(CTX, EV) \
 		(((PVRSRV_RGXDEV_INFO *)CTX->psDeviceNode->pvDevice)->ui32HWPerfHostFilter \
 		& RGX_HWPERF_EVENT_MASK_VALUE(EV))
diff --git a/drivers/gpu/drm/img-rogue/rgxinit.c b/drivers/gpu/drm/img-rogue/rgxinit.c
index cbfd04c8d9b4..88f243d899f7 100644
--- a/drivers/gpu/drm/img-rogue/rgxinit.c
+++ b/drivers/gpu/drm/img-rogue/rgxinit.c
@@ -53,12 +53,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_bridge_init.h"
 #include "rgx_bridge_init.h"
 #include "syscommon.h"
-#include "rgx_heaps.h"
+#include "rgx_heaps_server.h"
 #include "rgxheapconfig.h"
 #include "rgxpower.h"
 #include "tlstream.h"
 #include "pvrsrv_tlstreams.h"
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 #include "pvr_ricommon.h"
+#endif
 
 #include "rgxinit.h"
 #include "rgxbvnc.h"
@@ -76,7 +78,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxfwdbg.h"
 #include "info_page.h"
 
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 #include "rgxfwimageutils.h"
+#endif
 #include "rgxutils.h"
 #include "rgxfwutils.h"
 #include "rgx_fwif_km.h"
@@ -84,8 +88,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxmmuinit.h"
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 #include "rgxmipsmmuinit.h"
-#endif
 #include "physmem.h"
+#endif
 #include "devicemem_utils.h"
 #include "devicemem_server.h"
 #include "physmem_osmem.h"
@@ -100,13 +104,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "rgx_compat_bvnc.h"
 
-#include "rgx_heaps.h"
-
 #include "rgxta3d.h"
 #include "rgxtimecorr.h"
 #include "rgxshader.h"
 
-#include "rgx_bvnc_defs_km.h"
 #if defined(PDUMP)
 #include "rgxstartstop.h"
 #endif
@@ -122,9 +123,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxpdvfs.h"
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER)
-#include "rgxsoctimer.h"
-#endif
 
 #if defined(PDUMP) && defined(SUPPORT_SECURITY_VALIDATION)
 #include "pdump_physmem.h"
@@ -157,7 +155,7 @@ static void RGXDeInitFwRawHeap(DEVMEM_HEAP_BLUEPRINT *psDevMemHeap);
 
 #define VAR(x) #x
 
-static void RGXDeInitHeaps(DEVICE_MEMORY_INFO *psDevMemoryInfo);
+static void RGXDeInitHeaps(DEVICE_MEMORY_INFO *psDevMemoryInfo, PVRSRV_DEVICE_NODE *psDeviceNode);
 
 #if !defined(NO_HARDWARE)
 /*************************************************************************/ /*!
@@ -175,7 +173,7 @@ static INLINE IMG_BOOL SampleIRQCount(PVRSRV_RGXDEV_INFO *psDevInfo)
 	IMG_UINT32 ui32IrqCnt;
 
 #if defined(RGX_FW_IRQ_OS_COUNTERS)
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		bReturnVal = IMG_TRUE;
 	}
@@ -217,7 +215,7 @@ static INLINE IMG_BOOL SampleIRQCount(PVRSRV_RGXDEV_INFO *psDevInfo)
  */ /**************************************************************************/
 static INLINE IMG_UINT32 RGXHostSafetyEvents(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
-	if (PVRSRV_VZ_MODE_IS(GUEST) || (psDevInfo->ui32HostSafetyEventMask == 0))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo) || (psDevInfo->ui32HostSafetyEventMask == 0))
 	{
 		return 0;
 	}
@@ -263,89 +261,106 @@ static INLINE IMG_BOOL RGXSafetyEventCheck(PVRSRV_RGXDEV_INFO *psDevInfo)
  */ /**************************************************************************/
 static void RGXSafetyEventHandler(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
-	IMG_UINT32 ui32HostSafetyStatus = RGXHostSafetyEvents(psDevInfo);
-	RGX_CONTEXT_RESET_REASON eResetReason = RGX_CONTEXT_RESET_REASON_NONE;
+	PVRSRV_DEVICE_NODE *psDeviceNode = psDevInfo->psDeviceNode;
+	PVRSRV_ERROR eError;
 
-	if (ui32HostSafetyStatus != 0)
+	eError = PVRSRVPowerLock(psDeviceNode);
+	if (eError != PVRSRV_OK)
 	{
-		/* clear the safety bus events handled by the Host */
-		OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_SAFETY_EVENT_CLEAR__ROGUEXE, ui32HostSafetyStatus);
+		PVR_DPF((PVR_DBG_ERROR,
+				 "%s: Failed to acquire PowerLock (device: %p, error: %s)",
+				 __func__, psDeviceNode, PVRSRVGetErrorString(eError)));
+		return;
+	}
 
-		if (BIT_ISSET(ui32HostSafetyStatus, RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__FAULT_FW_SHIFT))
-		{
-			IMG_UINT32 ui32FaultFlag;
-			IMG_UINT32 ui32FaultFW = OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_FAULT_FW_STATUS);
-			IMG_UINT32 ui32CorrectedBitOffset = RGX_CR_FAULT_FW_STATUS_CPU_CORRECT_SHIFT -
-												RGX_CR_FAULT_FW_STATUS_CPU_DETECT_SHIFT;
+	if (psDevInfo->bRGXPowered)
+	{
+		RGX_CONTEXT_RESET_REASON eResetReason = RGX_CONTEXT_RESET_REASON_NONE;
+		IMG_UINT32 ui32HostSafetyStatus = RGXHostSafetyEvents(psDevInfo);
 
-			PVR_DPF((PVR_DBG_ERROR, "%s: Firmware safety fault status: 0x%X", __func__, ui32FaultFW));
+		if (ui32HostSafetyStatus != 0)
+		{
+			/* clear the safety bus events handled by the Host */
+			OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_SAFETY_EVENT_CLEAR__ROGUEXE, ui32HostSafetyStatus);
 
-			for (ui32FaultFlag = 0; ui32FaultFlag < ui32CorrectedBitOffset; ui32FaultFlag++)
+			if (BIT_ISSET(ui32HostSafetyStatus, RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__FAULT_FW_SHIFT))
 			{
-				if (BIT_ISSET(ui32FaultFW, ui32FaultFlag))
-				{
-					PVR_DPF((PVR_DBG_ERROR, "%s: Firmware safety hardware fault detected (0x%lX).",
-						 __func__, BIT(ui32FaultFlag)));
-					eResetReason = RGX_CONTEXT_RESET_REASON_FW_ECC_ERR;
-				}
-				else if BIT_ISSET(ui32FaultFW, ui32FaultFlag + ui32CorrectedBitOffset)
-				{
-					PVR_DPF((PVR_DBG_WARNING, "%s: Firmware safety hardware fault corrected.(0x%lX).",
-						 __func__, BIT(ui32FaultFlag)));
+				IMG_UINT32 ui32FaultFlag;
+				IMG_UINT32 ui32FaultFW = OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_FAULT_FW_STATUS);
+				IMG_UINT32 ui32CorrectedBitOffset = RGX_CR_FAULT_FW_STATUS_CPU_CORRECT_SHIFT -
+													RGX_CR_FAULT_FW_STATUS_CPU_DETECT_SHIFT;
 
-					/* Only report this if we haven't detected a more serious error */
-					if (eResetReason != RGX_CONTEXT_RESET_REASON_FW_ECC_ERR)
+				PVR_DPF((PVR_DBG_ERROR, "%s: Firmware safety fault status: 0x%X", __func__, ui32FaultFW));
+
+				for (ui32FaultFlag = 0; ui32FaultFlag < ui32CorrectedBitOffset; ui32FaultFlag++)
+				{
+					if (BIT_ISSET(ui32FaultFW, ui32FaultFlag))
 					{
-						eResetReason = RGX_CONTEXT_RESET_REASON_FW_ECC_OK;
+						PVR_DPF((PVR_DBG_ERROR, "%s: Firmware safety hardware fault detected (0x%lX).",
+							 __func__, BIT(ui32FaultFlag)));
+						eResetReason = RGX_CONTEXT_RESET_REASON_FW_ECC_ERR;
+					}
+					else if BIT_ISSET(ui32FaultFW, ui32FaultFlag + ui32CorrectedBitOffset)
+					{
+						PVR_DPF((PVR_DBG_WARNING, "%s: Firmware safety hardware fault corrected.(0x%lX).",
+							 __func__, BIT(ui32FaultFlag)));
+
+						/* Only report this if we haven't detected a more serious error */
+						if (eResetReason != RGX_CONTEXT_RESET_REASON_FW_ECC_ERR)
+						{
+							eResetReason = RGX_CONTEXT_RESET_REASON_FW_ECC_OK;
+						}
 					}
 				}
-			}
-
-			OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_FAULT_FW_CLEAR, ui32FaultFW);
-		}
 
-		if (BIT_ISSET(ui32HostSafetyStatus, RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__WATCHDOG_TIMEOUT_SHIFT))
-		{
-			volatile RGXFWIF_POW_STATE ePowState;
-
-			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfFwSysData->ePowState,
-			                           INVALIDATE);
-			ePowState = psDevInfo->psRGXFWIfFwSysData->ePowState;
+				OSWriteHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_FAULT_FW_CLEAR, ui32FaultFW);
+			}
 
-			if (ePowState != RGXFWIF_POW_OFF)
+			if (BIT_ISSET(ui32HostSafetyStatus, RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__WATCHDOG_TIMEOUT_SHIFT))
 			{
-				PVR_DPF((PVR_DBG_ERROR, "%s: Safety Watchdog Trigger !", __func__));
+				volatile RGXFWIF_POW_STATE ePowState;
 
-				/* Only report this if we haven't detected a more serious error */
-				if (eResetReason != RGX_CONTEXT_RESET_REASON_FW_ECC_ERR)
+				RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfFwSysData->ePowState,
+										   INVALIDATE);
+				ePowState = psDevInfo->psRGXFWIfFwSysData->ePowState;
+
+				if (ePowState != RGXFWIF_POW_OFF)
 				{
-					eResetReason = RGX_CONTEXT_RESET_REASON_FW_WATCHDOG;
+					PVR_DPF((PVR_DBG_ERROR, "%s: Safety Watchdog Trigger !", __func__));
+
+					/* Only report this if we haven't detected a more serious error */
+					if (eResetReason != RGX_CONTEXT_RESET_REASON_FW_ECC_ERR)
+					{
+						eResetReason = RGX_CONTEXT_RESET_REASON_FW_WATCHDOG;
+					}
 				}
 			}
-		}
 
-		/* Notify client and system layer of any error */
-		if (eResetReason != RGX_CONTEXT_RESET_REASON_NONE)
-		{
-			PVRSRV_DEVICE_NODE *psDevNode = psDevInfo->psDeviceNode;
-			PVRSRV_DEVICE_CONFIG *psDevConfig = psDevNode->psDevConfig;
+			/* Notify client and system layer of any error */
+			if (eResetReason != RGX_CONTEXT_RESET_REASON_NONE)
+			{
+				PVRSRV_DEVICE_NODE *psDevNode = psDevInfo->psDeviceNode;
+				PVRSRV_DEVICE_CONFIG *psDevConfig = psDevNode->psDevConfig;
 
-			/* Client notification of device error will be achieved by
-			 * clients calling UM function RGXGetLastDeviceError() */
-			psDevInfo->eLastDeviceError = eResetReason;
+				/* Client notification of device error will be achieved by
+				 * clients calling UM function RGXGetLastDeviceError() */
+				psDevInfo->eLastDeviceError = eResetReason;
 
-			/* Notify system layer of any error */
-			if (psDevConfig->pfnSysDevErrorNotify)
-			{
-				PVRSRV_ROBUSTNESS_NOTIFY_DATA sErrorData = {0};
+				/* Notify system layer of any error */
+				if (psDevConfig->pfnSysDevErrorNotify)
+				{
+					PVRSRV_ROBUSTNESS_NOTIFY_DATA sErrorData = {0};
 
-				sErrorData.eResetReason = eResetReason;
+					sErrorData.eResetReason = eResetReason;
 
-				psDevConfig->pfnSysDevErrorNotify(psDevConfig,
-				                                  &sErrorData);
+					psDevConfig->pfnSysDevErrorNotify(psDevConfig,
+													  &sErrorData);
+				}
 			}
 		}
 	}
+
+	PVRSRVPowerUnlock(psDeviceNode);
 }
 
 static IMG_BOOL _WaitForInterruptsTimeoutCheck(PVRSRV_RGXDEV_INFO *psDevInfo)
@@ -381,7 +396,7 @@ void RGX_WaitForInterruptsTimeout(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	IMG_BOOL bScheduleMISR;
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		bScheduleMISR = IMG_TRUE;
 	}
@@ -409,6 +424,9 @@ static inline IMG_BOOL RGXAckHwIrq(PVRSRV_RGXDEV_INFO *psDevInfo,
 {
 	IMG_UINT32 ui32IRQStatus = OSReadHWReg32(psDevInfo->pvRegsBaseKM, ui32IRQStatusReg);
 
+	/* clear only the pending bit of the thread that triggered this interrupt */
+	ui32IRQClearMask &= ui32IRQStatus;
+
 	if (ui32IRQStatus & ui32IRQStatusEventMsk)
 	{
 		/* acknowledge and clear the interrupt */
@@ -422,7 +440,7 @@ static inline IMG_BOOL RGXAckHwIrq(PVRSRV_RGXDEV_INFO *psDevInfo,
 	}
 }
 
-static IMG_BOOL RGXAckIrqMETA(PVRSRV_RGXDEV_INFO *psDevInfo)
+static __maybe_unused IMG_BOOL RGXAckIrqMETA(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	return RGXAckHwIrq(psDevInfo,
 					   RGX_CR_META_SP_MSLVIRQSTATUS,
@@ -431,6 +449,7 @@ static IMG_BOOL RGXAckIrqMETA(PVRSRV_RGXDEV_INFO *psDevInfo)
 					   RGX_CR_META_SP_MSLVIRQSTATUS_TRIGVECT2_CLRMSK);
 }
 
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 static IMG_BOOL RGXAckIrqMIPS(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
 	return RGXAckHwIrq(psDevInfo,
@@ -439,6 +458,7 @@ static IMG_BOOL RGXAckIrqMIPS(PVRSRV_RGXDEV_INFO *psDevInfo)
 					   RGX_CR_MIPS_WRAPPER_IRQ_CLEAR,
 					   RGX_CR_MIPS_WRAPPER_IRQ_CLEAR_EVENT_EN);
 }
+#endif
 
 static IMG_BOOL RGXAckIrqDedicated(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
@@ -448,9 +468,51 @@ static IMG_BOOL RGXAckIrqDedicated(PVRSRV_RGXDEV_INFO *psDevInfo)
 		 * register bank 0 */
 	return RGXAckHwIrq(psDevInfo,
 					   RGX_CR_IRQ_OS0_EVENT_STATUS,
-					   RGX_CR_IRQ_OS0_EVENT_STATUS_SOURCE_EN,
+					   ~RGX_CR_IRQ_OS0_EVENT_STATUS_SOURCE_CLRMSK,
 					   RGX_CR_IRQ_OS0_EVENT_CLEAR,
-					   RGX_CR_IRQ_OS0_EVENT_CLEAR_SOURCE_EN);
+					   ~RGX_CR_IRQ_OS0_EVENT_CLEAR_SOURCE_CLRMSK);
+}
+
+static PVRSRV_ERROR RGXSetAckIrq(PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	if ((RGX_IS_FEATURE_SUPPORTED(psDevInfo, IRQ_PER_OS)) && (!PVRSRV_VZ_MODE_IS(NATIVE, DEVINFO, psDevInfo)))
+	{
+		psDevInfo->pfnRGXAckIrq = RGXAckIrqDedicated;
+	}
+	else if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
+	{
+		psDevInfo->pfnRGXAckIrq = NULL;
+	}
+	else
+	{
+		/* native and host drivers must clear the unique GPU physical interrupt */
+		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
+		{
+			psDevInfo->pfnRGXAckIrq = RGXAckIrqMIPS;
+		}
+		else if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META))
+		{
+			psDevInfo->pfnRGXAckIrq = RGXAckIrqMETA;
+		}
+		else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
+		{
+			psDevInfo->pfnRGXAckIrq = RGXAckIrqDedicated;
+		}
+		else
+		{
+			PVR_DPF((PVR_DBG_ERROR, "%s: GPU IRQ clearing mechanism not implemented "
+									"for this architecture.", __func__));
+			return PVRSRV_ERROR_NOT_IMPLEMENTED;
+		}
+	}
+
+#if defined(RGX_IRQ_HYPERV_HANDLER)
+	/* The hypervisor receives and acknowledges the GPU irq, then it injects an
+	 * irq only in the recipient OS. The KM driver doesn't handle the GPU irq line */
+	psDevInfo->pfnRGXAckIrq = NULL;
+#endif
+
+	return PVRSRV_OK;
 }
 
 static IMG_BOOL RGX_LISRHandler(void *pvData)
@@ -509,11 +571,16 @@ static IMG_BOOL RGX_LISRHandler(void *pvData)
 	}
 	else
 	{
+#if defined(SUPPORT_AUTOVZ)
 		/* AutoVz drivers rebooting while the firmware is active must acknowledge
 		 * and clear the hw IRQ line before the RGXInit() has finished. */
-		if (!(psDevInfo->psDeviceNode->bAutoVzFwIsUp &&
-			  (psDevInfo->pfnRGXAckIrq != NULL) &&
-			  psDevInfo->pfnRGXAckIrq(psDevInfo)))
+		if ((psDevInfo->pfnRGXAckIrq != NULL) &&
+			 psDevInfo->pfnRGXAckIrq(psDevInfo))
+		{
+			bIrqAcknowledged = IMG_TRUE;
+		}
+		else
+#endif
 		{
 			UPDATE_LISR_DBG_STATUS(RGX_LISR_DEVICE_NOT_POWERED);
 		}
@@ -605,40 +672,34 @@ static void RGX_MISRHandler_CheckFWActivePowerState(void *psDevice)
 #define GPU_IDLE       RGXFWIF_GPU_UTIL_STATE_IDLE
 #define GPU_ACTIVE     RGXFWIF_GPU_UTIL_STATE_ACTIVE
 #define GPU_BLOCKED    RGXFWIF_GPU_UTIL_STATE_BLOCKED
+#define GPU_INACTIVE   RGXFWIF_GPU_UTIL_STATE_INACTIVE
 #define MAX_ITERATIONS 64
+#define MAX_DIFF_TIME_NS (300000ULL)
+#define MAX_DIFF_DM_TIME_NS (MAX_DIFF_TIME_NS >> RGXFWIF_DM_OS_TIMESTAMP_SHIFT)
 
 static PVRSRV_ERROR RGXGetGpuUtilStats(PVRSRV_DEVICE_NODE *psDeviceNode,
                                        IMG_HANDLE hGpuUtilUser,
                                        RGXFWIF_GPU_UTIL_STATS *psReturnStats)
 {
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	const volatile RGXFWIF_GPU_UTIL_FWCB *psUtilFWCb = psDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_STATS sStats;
 	RGXFWIF_GPU_UTIL_STATS *psAggregateStats;
-	IMG_UINT64 (*paaui64DMOSTmpCounters)[RGX_NUM_DRIVERS_SUPPORTED][RGXFWIF_GPU_UTIL_STATE_NUM];
+	IMG_UINT64 (*paaui64DMOSTmpCounters)[RGX_NUM_DRIVERS_SUPPORTED][RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM];
 	IMG_UINT64 (*paui64DMOSTmpLastWord)[RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 (*paui64DMOSTmpLastState)[RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 (*paui64DMOSTmpLastPeriod)[RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 (*paui64DMOSTmpLastTime)[RGX_NUM_DRIVERS_SUPPORTED];
 	IMG_UINT64 ui64TimeNow;
+	IMG_UINT64 ui64TimeNowShifted;
 	IMG_UINT32 ui32Attempts;
 	IMG_UINT32 ui32Remainder;
 	IMG_UINT32 ui32DriverID;
 	IMG_UINT32 ui32MaxDMCount;
 	RGXFWIF_DM eDM;
 
-
 	/***** (1) Initialise return stats *****/
 
 	psReturnStats->bValid = IMG_FALSE;
-	psReturnStats->ui64GpuStatIdle       = 0;
-	psReturnStats->ui64GpuStatActive     = 0;
-	psReturnStats->ui64GpuStatBlocked    = 0;
-	psReturnStats->ui64GpuStatCumulative = 0;
-
-	memset(psReturnStats->aaui64DMOSStatIdle, 0, sizeof(psReturnStats->aaui64DMOSStatIdle));
-	memset(psReturnStats->aaui64DMOSStatActive, 0, sizeof(psReturnStats->aaui64DMOSStatActive));
-	memset(psReturnStats->aaui64DMOSStatBlocked, 0, sizeof(psReturnStats->aaui64DMOSStatBlocked));
-	memset(psReturnStats->aaui64DMOSStatCumulative, 0, sizeof(psReturnStats->aaui64DMOSStatCumulative));
 
 	if (hGpuUtilUser == NULL)
 	{
@@ -646,73 +707,152 @@ static PVRSRV_ERROR RGXGetGpuUtilStats(PVRSRV_DEVICE_NODE *psDeviceNode,
 	}
 	psAggregateStats = hGpuUtilUser;
 
-	ui32MaxDMCount = psDevInfo->sDevFeatureCfg.ui32MAXDMCount;
+	/* decrease by 1 to account for excluding GP DM from the statics */;
+	ui32MaxDMCount =  psDevInfo->sDevFeatureCfg.ui32MAXDMCount-1;
 
 	/* Reset temporary counters used in the attempts loop */
-	memset(&psReturnStats->sTempGpuStats, 0, sizeof(psReturnStats->sTempGpuStats));
 	paaui64DMOSTmpCounters  = &psAggregateStats->sTempGpuStats.aaaui64DMOSTmpCounters[0];
 	paui64DMOSTmpLastWord   = &psAggregateStats->sTempGpuStats.aaui64DMOSTmpLastWord[0];
 	paui64DMOSTmpLastState  = &psAggregateStats->sTempGpuStats.aaui64DMOSTmpLastState[0];
 	paui64DMOSTmpLastPeriod = &psAggregateStats->sTempGpuStats.aaui64DMOSTmpLastPeriod[0];
 	paui64DMOSTmpLastTime   = &psAggregateStats->sTempGpuStats.aaui64DMOSTmpLastTime[0];
 
-	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFWCb, INVALIDATE);
+	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFW, INVALIDATE);
 
 	/* Try to acquire GPU utilisation counters and repeat if the FW is in the middle of an update */
 	for (ui32Attempts = 0; ui32Attempts < 4; ui32Attempts++)
 	{
-		const volatile IMG_UINT64 *pui64GpuStatsCounters = &psUtilFWCb->aui64GpuStatsCounters[0];
-		const volatile IMG_UINT64 (*paui64DMOSLastWord)[RGXFW_MAX_NUM_OSIDS] = &psUtilFWCb->aaui64DMOSLastWord[0];
-		const volatile IMG_UINT64 (*paaui64DMOSStatsCounters)[RGXFW_MAX_NUM_OSIDS][RGXFWIF_GPU_UTIL_STATE_NUM] = &psUtilFWCb->aaaui64DMOSStatsCounters[0];
-
 		IMG_UINT64 aui64GpuTmpCounters[RGXFWIF_GPU_UTIL_STATE_NUM] = {0};
 		IMG_UINT64 ui64GpuLastPeriod = 0, ui64GpuLastWord = 0, ui64GpuLastState = 0, ui64GpuLastTime = 0;
-		IMG_UINT32 i = 0;
-
 
 		/***** (2) Get latest data from shared area *****/
 
-		OSLockAcquire(psDevInfo->hGPUUtilLock);
-
-		/*
-		 * First attempt at detecting if the FW is in the middle of an update.
-		 * This should also help if the FW is in the middle of a 64 bit variable update.
-		 */
-		while (((ui64GpuLastWord != psUtilFWCb->ui64GpuLastWord) ||
-				(aui64GpuTmpCounters[ui64GpuLastState] !=
-				 pui64GpuStatsCounters[ui64GpuLastState])) &&
-			   (i < MAX_ITERATIONS))
+		FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 		{
-			ui64GpuLastWord  = psUtilFWCb->ui64GpuLastWord;
-			ui64GpuLastState = RGXFWIF_GPU_UTIL_GET_STATE(ui64GpuLastWord);
-			aui64GpuTmpCounters[GPU_IDLE]    = pui64GpuStatsCounters[GPU_IDLE];
-			aui64GpuTmpCounters[GPU_ACTIVE]  = pui64GpuStatsCounters[GPU_ACTIVE];
-			aui64GpuTmpCounters[GPU_BLOCKED] = pui64GpuStatsCounters[GPU_BLOCKED];
+			IMG_UINT64 aui64StatsCountersNew[RGXFWIF_GPU_UTIL_STATE_NUM];
+			IMG_UINT64 ui64GpuLastWordNew;
+			RGXFWIF_GPU_STATS sStatsNew;
+			IMG_UINT32 i = 0;
 
-			for (eDM = 0; eDM < ui32MaxDMCount; eDM++)
+			ui64GpuLastWord = 0;
+			ui64GpuLastState = 0;
+
+			OSLockAcquire(psDevInfo->hGPUUtilLock);
+
+			/* Copy data from device memory */
+			memcpy(&sStatsNew, &psDevInfo->psRGXFWIfGpuUtilFW->sStats[ui32DriverID], sizeof(sStats));
+			memcpy(&ui64GpuLastWordNew, &psDevInfo->psRGXFWIfGpuUtilFW->ui64GpuLastWord, sizeof(ui64GpuLastWord));
+			memcpy(aui64StatsCountersNew, psDevInfo->psRGXFWIfGpuUtilFW->aui64GpuStatsCounters, sizeof(aui64StatsCountersNew));
+
+			/*
+			 * First attempt at detecting if the FW is in the middle of an update.
+			 * This should also help if the FW is in the middle of a 64 bit variable update.
+			 * This loop must be fast. Faster than FW updates the stats.
+			 */
+			for (i = 0; i < MAX_ITERATIONS; i++)
 			{
-				FOREACH_SUPPORTED_DRIVER(ui32DriverID)
+				IMG_UINT32 j,k;
+				IMG_BOOL bRetry = IMG_FALSE;
+
+				if (i > 0)
+				{
+					/* On retry keep previous data */
+					ui64GpuLastWordNew = ui64GpuLastWord;
+					memcpy(aui64StatsCountersNew, aui64GpuTmpCounters, sizeof(aui64StatsCountersNew));
+					memcpy(&sStatsNew, &sStats, sizeof(sStatsNew));
+				}
+
+				/* Copy data from device memory */
+				memcpy(&sStats, &psDevInfo->psRGXFWIfGpuUtilFW->sStats[ui32DriverID], sizeof(sStats));
+				memcpy(&ui64GpuLastWord, &psDevInfo->psRGXFWIfGpuUtilFW->ui64GpuLastWord, sizeof(ui64GpuLastWord));
+				memcpy(aui64GpuTmpCounters, psDevInfo->psRGXFWIfGpuUtilFW->aui64GpuStatsCounters, sizeof(aui64GpuTmpCounters));
+
+				/* Check for abnormal time difference between reads */
+				if (RGXFWIF_GPU_UTIL_GET_TIME(ui64GpuLastWord) - RGXFWIF_GPU_UTIL_GET_TIME(ui64GpuLastWordNew) > MAX_DIFF_TIME_NS)
 				{
-					paui64DMOSTmpLastWord[eDM][ui32DriverID]  = paui64DMOSLastWord[eDM][ui32DriverID];
-					paui64DMOSTmpLastState[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_STATE(paui64DMOSTmpLastWord[eDM][ui32DriverID]);
-					paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_IDLE]    = paaui64DMOSStatsCounters[eDM][ui32DriverID][GPU_IDLE];
-					paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_ACTIVE]  = paaui64DMOSStatsCounters[eDM][ui32DriverID][GPU_ACTIVE];
-					paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_BLOCKED] = paaui64DMOSStatsCounters[eDM][ui32DriverID][GPU_BLOCKED];
+					bRetry = IMG_TRUE;
+					continue;
+				}
+
+				for (j = 0; j < RGXFWIF_GPU_UTIL_STATE_NUM; j++)
+				{
+					/* Check for abnormal time difference between reads */
+					if (aui64GpuTmpCounters[j] - aui64StatsCountersNew[j] > MAX_DIFF_TIME_NS)
+					{
+						bRetry = IMG_TRUE;
+						break;
+					}
+				}
+
+				if (bRetry)
+				{
+					continue;
+				}
+
+				/* Check for DM counters wrapped or
+				   abnormal time difference between reads.
+				   The DM time is shifted by RGXFWIF_DM_OS_TIMESTAMP_SHIFT */
+				for (j = 0; j < RGXFWIF_GPU_UTIL_DM_MAX; j++)
+				{
+					if (sStats.aui32DMOSLastWordWrap[j] != sStatsNew.aui32DMOSLastWordWrap[j] ||
+						RGXFWIF_GPU_UTIL_GET_TIME32(sStats.aui32DMOSLastWord[j]) - RGXFWIF_GPU_UTIL_GET_TIME32(sStatsNew.aui32DMOSLastWord[j]) > MAX_DIFF_DM_TIME_NS)
+					{
+						bRetry = IMG_TRUE;
+						break;
+					}
+
+					for (k = 0; k < RGXFWIF_GPU_UTIL_REDUCED_STATES_NUM; k++)
+					{
+						if (sStats.aaui32DMOSCountersWrap[j][k] != sStatsNew.aaui32DMOSCountersWrap[j][k] ||
+							sStats.aaui32DMOSStatsCounters[j][k] - sStatsNew.aaui32DMOSStatsCounters[j][k] > MAX_DIFF_DM_TIME_NS)
+						{
+							bRetry = IMG_TRUE;
+							break;
+						}
+
+					}
+
+					if (bRetry)
+					{
+						break;
+					}
+				}
+
+				if (!bRetry)
+				{
+					/* Stats are good*/
+					break;
 				}
 			}
 
-			i++;
-		}
+			OSLockRelease(psDevInfo->hGPUUtilLock);
 
-		OSLockRelease(psDevInfo->hGPUUtilLock);
+			ui64GpuLastState = RGXFWIF_GPU_UTIL_GET_STATE(ui64GpuLastWord);
 
-		if (i == MAX_ITERATIONS)
-		{
-			PVR_DPF((PVR_DBG_WARNING,
-			         "RGXGetGpuUtilStats could not get reliable data after trying %u times", i));
+			if (i == MAX_ITERATIONS)
+			{
+				PVR_DPF((PVR_DBG_WARNING,
+						 "RGXGetGpuUtilStats could not get reliable data after trying %u times", i));
 
-			return PVRSRV_ERROR_TIMEOUT;
-		}
+				return PVRSRV_ERROR_TIMEOUT;
+			}
+
+			for (eDM = 0; eDM < ui32MaxDMCount; eDM++)
+			{
+				paui64DMOSTmpLastWord[eDM][ui32DriverID]  =
+					((IMG_UINT64)sStats.aui32DMOSLastWordWrap[eDM] << 32) + sStats.aui32DMOSLastWord[eDM];
+				paui64DMOSTmpLastState[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_STATE(paui64DMOSTmpLastWord[eDM][ui32DriverID]);
+				if (paui64DMOSTmpLastState[eDM][ui32DriverID] != GPU_ACTIVE)
+				{
+					paui64DMOSTmpLastState[eDM][ui32DriverID] = GPU_INACTIVE;
+				}
+				paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_INACTIVE] = (IMG_UINT64)sStats.aaui32DMOSStatsCounters[eDM][GPU_INACTIVE] +
+					((IMG_UINT64)sStats.aaui32DMOSCountersWrap[eDM][GPU_INACTIVE] << 32);
+				paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_ACTIVE]  = (IMG_UINT64)sStats.aaui32DMOSStatsCounters[eDM][GPU_ACTIVE] +
+					((IMG_UINT64)sStats.aaui32DMOSCountersWrap[eDM][GPU_ACTIVE] << 32);
+			}
+
+		} /* FOREACH_SUPPORTED_DRIVER(ui32DriverID) */
 
 
 		/***** (3) Compute return stats *****/
@@ -736,24 +876,22 @@ static PVRSRV_ERROR RGXGetGpuUtilStats(PVRSRV_DEVICE_NODE *psDeviceNode,
 		                                       psReturnStats->ui64GpuStatActive +
 		                                       psReturnStats->ui64GpuStatBlocked;
 
+		/* convert time into the same units as used by fw */
+		ui64TimeNowShifted  = ui64TimeNow >> RGXFWIF_DM_OS_TIMESTAMP_SHIFT;
 		for (eDM = 0; eDM < ui32MaxDMCount; eDM++)
 		{
 			FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 			{
 				paui64DMOSTmpLastTime[eDM][ui32DriverID]   = RGXFWIF_GPU_UTIL_GET_TIME(paui64DMOSTmpLastWord[eDM][ui32DriverID]);
-				paui64DMOSTmpLastPeriod[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(ui64TimeNow, paui64DMOSTmpLastTime[eDM][ui32DriverID]);
+				paui64DMOSTmpLastPeriod[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(ui64TimeNowShifted , paui64DMOSTmpLastTime[eDM][ui32DriverID]);
 				paaui64DMOSTmpCounters[eDM][ui32DriverID][paui64DMOSTmpLastState[eDM][ui32DriverID]] += paui64DMOSTmpLastPeriod[eDM][ui32DriverID];
-
 				/* Get statistics for a user since its last request */
-				psReturnStats->aaui64DMOSStatIdle[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_IDLE],
-				                                                             psAggregateStats->aaui64DMOSStatIdle[eDM][ui32DriverID]);
+				psReturnStats->aaui64DMOSStatInactive[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_INACTIVE],
+				                                                             psAggregateStats->aaui64DMOSStatInactive[eDM][ui32DriverID]);
 				psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_ACTIVE],
 				                                                               psAggregateStats->aaui64DMOSStatActive[eDM][ui32DriverID]);
-				psReturnStats->aaui64DMOSStatBlocked[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_GET_PERIOD(paaui64DMOSTmpCounters[eDM][ui32DriverID][GPU_BLOCKED],
-				                                                                psAggregateStats->aaui64DMOSStatBlocked[eDM][ui32DriverID]);
-				psReturnStats->aaui64DMOSStatCumulative[eDM][ui32DriverID] = psReturnStats->aaui64DMOSStatIdle[eDM][ui32DriverID] +
-				                                       psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID] +
-				                                       psReturnStats->aaui64DMOSStatBlocked[eDM][ui32DriverID];
+				psReturnStats->aaui64DMOSStatCumulative[eDM][ui32DriverID] = psReturnStats->aaui64DMOSStatInactive[eDM][ui32DriverID] +
+				                                       psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID];
 			}
 		}
 
@@ -794,9 +932,8 @@ static PVRSRV_ERROR RGXGetGpuUtilStats(PVRSRV_DEVICE_NODE *psDeviceNode,
 	{
 		FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 		{
-			psAggregateStats->aaui64DMOSStatIdle[eDM][ui32DriverID]    += psReturnStats->aaui64DMOSStatIdle[eDM][ui32DriverID];
+			psAggregateStats->aaui64DMOSStatInactive[eDM][ui32DriverID]    += psReturnStats->aaui64DMOSStatInactive[eDM][ui32DriverID];
 			psAggregateStats->aaui64DMOSStatActive[eDM][ui32DriverID]  += psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID];
-			psAggregateStats->aaui64DMOSStatBlocked[eDM][ui32DriverID] += psReturnStats->aaui64DMOSStatBlocked[eDM][ui32DriverID];
 		}
 	}
 
@@ -807,17 +944,6 @@ static PVRSRV_ERROR RGXGetGpuUtilStats(PVRSRV_DEVICE_NODE *psDeviceNode,
 	psReturnStats->ui64GpuStatBlocked    = OSDivide64(psReturnStats->ui64GpuStatBlocked, 1000, &ui32Remainder);
 	psReturnStats->ui64GpuStatCumulative = OSDivide64(psReturnStats->ui64GpuStatCumulative, 1000, &ui32Remainder);
 
-	for (eDM = 0; eDM < ui32MaxDMCount; eDM++)
-	{
-		FOREACH_SUPPORTED_DRIVER(ui32DriverID)
-		{
-			psReturnStats->aaui64DMOSStatIdle[eDM][ui32DriverID]       = OSDivide64(psReturnStats->aaui64DMOSStatIdle[eDM][ui32DriverID], 1000, &ui32Remainder);
-			psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID]     = OSDivide64(psReturnStats->aaui64DMOSStatActive[eDM][ui32DriverID], 1000, &ui32Remainder);
-			psReturnStats->aaui64DMOSStatBlocked[eDM][ui32DriverID]    = OSDivide64(psReturnStats->aaui64DMOSStatBlocked[eDM][ui32DriverID], 1000, &ui32Remainder);
-			psReturnStats->aaui64DMOSStatCumulative[eDM][ui32DriverID] = OSDivide64(psReturnStats->aaui64DMOSStatCumulative[eDM][ui32DriverID], 1000, &ui32Remainder);
-		}
-	}
-
 	/* Check that the return stats make sense */
 	if (psReturnStats->ui64GpuStatCumulative == 0)
 	{
@@ -908,8 +1034,13 @@ static void RGX_MISRHandler_Main (void *pvData)
 	RGXPDVFSCheckCoreClkRateChange(psDeviceNode->pvDevice);
 #endif
 
-	/* Handle Safety events if necessary */
-	RGXSafetyEventHandler(psDeviceNode->pvDevice);
+	/* Only execute SafetyEventHandler if RGX_FEATURE_SAFETY_EVENT is on */
+	if (PVRSRV_GET_DEVICE_FEATURE_VALUE(psDeviceNode, ECC_RAMS) > 0 ||
+		PVRSRV_IS_FEATURE_SUPPORTED(psDeviceNode, WATCHDOG_TIMER))
+	{
+		/* Handle Safety events if necessary */
+		RGXSafetyEventHandler(psDeviceNode->pvDevice);
+	}
 
 	/* Signal the global event object */
 	PVRSRVSignalDriverWideEO();
@@ -921,7 +1052,7 @@ static void RGX_MISRHandler_Main (void *pvData)
 	RGXTimeCorrRestartPeriodic(psDeviceNode);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Process Workload Estimation Specific commands from the FW */
 		WorkEstCheckFirmwareCCB(psDeviceNode->pvDevice);
@@ -945,7 +1076,7 @@ static PVRSRV_ERROR RGXPDumpBootldrData(PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_DEV_PHYADDR sTmpAddr;
 	IMG_UINT32 ui32BootConfOffset, ui32ParamOffset, i;
 	PVRSRV_ERROR eError;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	psFWDataPMR = (PMR *)(psDevInfo->psRGXFWDataMemDesc->psImport->hPMR);
 	ui32BootConfOffset = RGXGetFWImageSectionOffset(NULL, MIPS_BOOT_DATA);
@@ -1037,50 +1168,55 @@ static PVRSRV_ERROR RGXSetPowerParams(PVRSRV_RGXDEV_INFO   *psDevInfo,
                                       PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_DEV_PHYADDR sKernelMMUCtxPCAddr;
+	IMG_BOOL bPremappedFw;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVCFG, psDevConfig, PVRSRV_OK);
 
 	/* Save information used on power transitions for later
 	 * (when RGXStart and RGXStop are executed)
 	 */
-	psDevInfo->sLayerParams.psDevInfo = psDevInfo;
-	psDevInfo->sLayerParams.psDevConfig = psDevConfig;
 #if defined(PDUMP)
 	psDevInfo->sLayerParams.ui32PdumpFlags = PDUMP_FLAGS_CONTINUOUS;
 #endif
-	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META) ||
-	    RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
+
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_PREMAP_FW_HEAPS)
+	/* Rogue drivers with security support and premapped fw heaps
+	 * always have their fw heap premapped by the TEE */
+	bPremappedFw = IMG_TRUE;
+#else
+	/* If AutoVz firmware is up at this stage, the driver initialised it
+	 * during a previous life-cycle. The firmware's memory is already pre-mapped
+	 * and the MMU page tables reside in the predetermined memory carveout.
+	 * The Kernel MMU Context created in this life-cycle is a dummy structure
+	 * that is not used for mapping.
+	 * To program the Device's BIF with the correct PC address, use the base
+	 * address of the carveout reserved for MMU mappings as Kernel MMU PC Address */
+	bPremappedFw = psDevInfo->psDeviceNode->bAutoVzFwIsUp;
+#endif
+
+	if (bPremappedFw)
 	{
-		IMG_DEV_PHYADDR sKernelMMUCtxPCAddr;
+		IMG_DEV_PHYADDR sDevPAddr;
+		PHYS_HEAP *psFwPageTableHeap = psDevInfo->psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_PREMAP_PT];
 
-		if (psDevInfo->psDeviceNode->bAutoVzFwIsUp)
-		{
-			/* If AutoVz firmware is up at this stage, the driver initialised it
-			 * during a previous life-cycle. The firmware's memory is already pre-mapped
-			 * and the MMU page tables reside in the predetermined memory carveout.
-			 * The Kernel MMU Context created in this life-cycle is a dummy structure
-			 * that is not used for mapping.
-			 * To program the Device's BIF with the correct PC address, use the base
-			 * address of the carveout reserved for MMU mappings as Kernel MMU PC Address */
-			IMG_DEV_PHYADDR sDevPAddr;
-			PHYS_HEAP *psFwPageTableHeap = psDevInfo->psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_PREMAP_PT];
-
-			PVR_LOG_RETURN_IF_FALSE((NULL != psFwPageTableHeap),
-									"Firmware Page Table heap not defined.",
-									PVRSRV_ERROR_INVALID_HEAP);
-
-			PhysHeapGetDevPAddr(psFwPageTableHeap, &sDevPAddr);
-			sKernelMMUCtxPCAddr.uiAddr = sDevPAddr.uiAddr;
-		}
-		else
+		PVR_LOG_RETURN_IF_FALSE((NULL != psFwPageTableHeap),
+								"Firmware Page Table heap not defined.",
+								PVRSRV_ERROR_INVALID_HEAP);
+
+		PhysHeapGetDevPAddr(psFwPageTableHeap, &sDevPAddr);
+		sKernelMMUCtxPCAddr.uiAddr = sDevPAddr.uiAddr;
+		psDevInfo->sLayerParams.sPCAddr = sKernelMMUCtxPCAddr;
+	}
+	else if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META) ||
+	    RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
+	{
+		eError = MMU_AcquireBaseAddr(psDevInfo->psKernelMMUCtx,
+		                             &sKernelMMUCtxPCAddr);
+		if (eError != PVRSRV_OK)
 		{
-			eError = MMU_AcquireBaseAddr(psDevInfo->psKernelMMUCtx,
-			                             &sKernelMMUCtxPCAddr);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR, "RGXSetPowerParams: Failed to acquire Kernel MMU Ctx page catalog"));
-				return eError;
-			}
+			PVR_DPF((PVR_DBG_ERROR, "RGXSetPowerParams: Failed to acquire Kernel MMU Ctx page catalog"));
+			return eError;
 		}
 
 		psDevInfo->sLayerParams.sPCAddr = sKernelMMUCtxPCAddr;
@@ -1200,40 +1336,173 @@ static PVRSRV_ERROR RGXSetPowerParams(PVRSRV_RGXDEV_INFO   *psDevInfo,
 	return eError;
 }
 
+#if defined(RGX_FEATURE_AXI_ACE_BIT_MASK)
 /*
-	RGXSystemHasFBCDCVersion31
+	RGXSystemGetFabricCoherency
 */
-static IMG_BOOL RGXSystemHasFBCDCVersion31(PVRSRV_DEVICE_NODE *psDeviceNode)
+PVRSRV_ERROR RGXSystemGetFabricCoherency(PVRSRV_DEVICE_CONFIG *psDevConfig,
+										 IMG_CPU_PHYADDR sRegsCpuPBase,
+										 IMG_UINT32 ui32RegsSize,
+										 PVRSRV_DEVICE_FABRIC_TYPE *peDevFabricType,
+										 PVRSRV_DEVICE_SNOOP_MODE *peCacheSnoopingMode)
 {
-#if defined(SUPPORT_VALIDATION)
-	IMG_UINT32 ui32FBCDCVersionOverride = 0;
+	IMG_CHAR *aszLabels[] = {"none", "acelite", "fullace", "unknown"};
+	PVRSRV_DEVICE_SNOOP_MODE eAppHintCacheSnoopingMode;
+	PVRSRV_DEVICE_SNOOP_MODE eDeviceCacheSnoopingMode;
+	IMG_UINT32 ui32AppHintFabricCoherency;
+	IMG_UINT32 ui32DeviceFabricCoherency;
+	void *pvAppHintState = NULL;
+	IMG_UINT32 ui32AppHintDefault;
+#if !defined(NO_HARDWARE)
+	void *pvRegsBaseKM;
+	IMG_BOOL bPowerDown = IMG_TRUE;
+	PVRSRV_ERROR eError;
 #endif
 
-#if defined(FIX_HW_ERN_66622_BIT_MASK)
-	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	if (!sRegsCpuPBase.uiAddr || !ui32RegsSize)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "RGXSystemGetFabricCoherency: Invalid RGX register base/size parameters"));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
 
-	if (RGX_IS_ERN_SUPPORTED(psDevInfo, 66622))
+#if !defined(NO_HARDWARE)
+	pvRegsBaseKM = OSMapPhysToLin(sRegsCpuPBase, ui32RegsSize, PVRSRV_MEMALLOCFLAG_CPU_UNCACHED);
+	if (!pvRegsBaseKM)
 	{
-#if defined(SUPPORT_VALIDATION)
-		void *pvAppHintState = NULL;
+		PVR_DPF((PVR_DBG_ERROR,
+		         "RGXSystemGetFabricCoherency: Failed to create RGX register mapping"));
+		return PVRSRV_ERROR_BAD_MAPPING;
+	}
 
-		IMG_UINT32 ui32AppHintDefault;
+	bPowerDown = ! PVRSRVIsSystemPowered(psDevConfig->psDevNode);
 
-		OSCreateAppHintState(&pvAppHintState);
-		ui32AppHintDefault = PVRSRV_APPHINT_FBCDCVERSIONOVERRIDE;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, FBCDCVersionOverride,
-		                     &ui32AppHintDefault, &ui32FBCDCVersionOverride);
-		OSFreeAppHintState(pvAppHintState);
+	/* Power-up the device as required to read the registers */
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVCFG, psDevConfig) && bPowerDown)
+	{
+		eError = PVRSRVSetSystemPowerState(psDevConfig, PVRSRV_SYS_POWER_STATE_ON);
+		PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState ON");
+	}
 
-		if (ui32FBCDCVersionOverride > 0)
-		{
-			if (ui32FBCDCVersionOverride == 2)
-			{
-				return IMG_TRUE;
-			}
-		}
-		else
+	/* AXI support within the SoC, bitfield COHERENCY_SUPPORT [1 .. 0]
+		value NO_COHERENCY        0x0 {SoC does not support any form of Coherency}
+		value ACE_LITE_COHERENCY  0x1 {SoC supports ACE-Lite or I/O Coherency}
+		value FULL_ACE_COHERENCY  0x2 {SoC supports full ACE or 2-Way Coherency} */
+	ui32DeviceFabricCoherency = OSReadHWReg32((void __iomem *)pvRegsBaseKM, RGX_CR_SOC_AXI);
+	PVR_LOG(("AXI fabric coherency (RGX_CR_SOC_AXI): 0x%x", ui32DeviceFabricCoherency));
+#if defined(DEBUG)
+	if (ui32DeviceFabricCoherency & ~((IMG_UINT32)RGX_CR_SOC_AXI_MASKFULL))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Invalid RGX_CR_SOC_AXI value.", __func__));
+		return PVRSRV_ERROR_INVALID_DEVICE;
+	}
+#endif
+	ui32DeviceFabricCoherency &= ~((IMG_UINT32)RGX_CR_SOC_AXI_COHERENCY_SUPPORT_CLRMSK);
+	ui32DeviceFabricCoherency >>= RGX_CR_SOC_AXI_COHERENCY_SUPPORT_SHIFT;
+
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVCFG, psDevConfig) && bPowerDown)
+	{
+		eError = PVRSRVSetSystemPowerState(psDevConfig, PVRSRV_SYS_POWER_STATE_OFF);
+		PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState OFF");
+	}
+
+	/* UnMap Regs */
+	OSUnMapPhysToLin(pvRegsBaseKM, ui32RegsSize);
+
+	switch (ui32DeviceFabricCoherency)
+	{
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_FULL_ACE_COHERENCY:
+		eDeviceCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CROSS;
+		*peDevFabricType = PVRSRV_DEVICE_FABRIC_FULLACE;
+		break;
+
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_ACE_LITE_COHERENCY:
+		eDeviceCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CPU_ONLY;
+		*peDevFabricType = PVRSRV_DEVICE_FABRIC_ACELITE;
+		break;
+
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_NO_COHERENCY:
+	default:
+		eDeviceCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_NONE;
+		*peDevFabricType = PVRSRV_DEVICE_FABRIC_NONE;
+		break;
+	}
+#else /* !defined(NO_HARDWARE) */
+    *peDevFabricType = PVRSRV_DEVICE_FABRIC_ACELITE;
+    eDeviceCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CPU_ONLY;
+    ui32DeviceFabricCoherency = RGX_CR_SOC_AXI_COHERENCY_SUPPORT_ACE_LITE_COHERENCY;
+#endif /* !defined(NO_HARDWARE) */
+
+	OSCreateAppHintState(&pvAppHintState);
+	ui32AppHintDefault = RGX_CR_SOC_AXI_COHERENCY_SUPPORT_FULL_ACE_COHERENCY;
+	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, FabricCoherencyOverride,
+						 &ui32AppHintDefault, &ui32AppHintFabricCoherency);
+	OSFreeAppHintState(pvAppHintState);
+
+#if defined(SUPPORT_SECURITY_VALIDATION)
+	/* Temporarily disable coherency */
+	ui32AppHintFabricCoherency = RGX_CR_SOC_AXI_COHERENCY_SUPPORT_NO_COHERENCY;
 #endif
+
+	/* Suppress invalid AppHint value */
+	switch (ui32AppHintFabricCoherency)
+	{
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_NO_COHERENCY:
+		eAppHintCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_NONE;
+		break;
+
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_ACE_LITE_COHERENCY:
+		eAppHintCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CPU_ONLY;
+		break;
+
+	case RGX_CR_SOC_AXI_COHERENCY_SUPPORT_FULL_ACE_COHERENCY:
+		eAppHintCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CROSS;
+		break;
+
+	default:
+		PVR_DPF((PVR_DBG_ERROR,
+				"Invalid FabricCoherencyOverride AppHint %d, ignoring",
+				ui32AppHintFabricCoherency));
+		eAppHintCacheSnoopingMode = PVRSRV_DEVICE_SNOOP_CROSS;
+		ui32AppHintFabricCoherency = RGX_CR_SOC_AXI_COHERENCY_SUPPORT_FULL_ACE_COHERENCY;
+		break;
+	}
+
+	if (ui32AppHintFabricCoherency < ui32DeviceFabricCoherency)
+	{
+		PVR_LOG(("Downgrading device fabric coherency from %s to %s",
+				aszLabels[ui32DeviceFabricCoherency],
+				aszLabels[ui32AppHintFabricCoherency]));
+		eDeviceCacheSnoopingMode = eAppHintCacheSnoopingMode;
+	}
+	else if (ui32AppHintFabricCoherency > ui32DeviceFabricCoherency)
+	{
+		PVR_DPF((PVR_DBG_WARNING,
+				"Cannot upgrade device fabric coherency from %s to %s, not supported by device!",
+				aszLabels[ui32DeviceFabricCoherency],
+				aszLabels[ui32AppHintFabricCoherency]));
+
+		/* Override requested-for app-hint with actual app-hint value being used */
+		ui32AppHintFabricCoherency = ui32DeviceFabricCoherency;
+	}
+
+	*peCacheSnoopingMode = eDeviceCacheSnoopingMode;
+	return PVRSRV_OK;
+}
+#endif
+
+/*
+	RGXSystemHasFBCDCVersion31
+*/
+static IMG_BOOL RGXSystemHasFBCDCVersion31(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+
+#if defined(HW_ERN_66622_BIT_MASK)
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+
+	if (RGX_IS_ERN_SUPPORTED(psDevInfo, 66622))
+#endif
+	{
 		{
 			if (psDeviceNode->psDevConfig->bHasFBCDCVersion31)
 			{
@@ -1241,19 +1510,10 @@ static IMG_BOOL RGXSystemHasFBCDCVersion31(PVRSRV_DEVICE_NODE *psDeviceNode)
 			}
 		}
 	}
+#if defined(HW_ERN_66622_BIT_MASK)
 	else
-#endif
 	{
 
-#if defined(SUPPORT_VALIDATION)
-		if (ui32FBCDCVersionOverride == 2)
-		{
-			PVR_DPF((PVR_DBG_WARNING,
-			         "%s: FBCDCVersionOverride forces FBC3.1 but this core doesn't support it!",
-			         __func__));
-		}
-#endif
-
 #if !defined(NO_HARDWARE)
 		if (psDeviceNode->psDevConfig->bHasFBCDCVersion31)
 		{
@@ -1263,6 +1523,7 @@ static IMG_BOOL RGXSystemHasFBCDCVersion31(PVRSRV_DEVICE_NODE *psDeviceNode)
 		}
 #endif
 	}
+#endif /* defined(HW_ERN_66622_BIT_MASK) */
 
 	return IMG_FALSE;
 }
@@ -1272,11 +1533,11 @@ static IMG_BOOL RGXSystemHasFBCDCVersion31(PVRSRV_DEVICE_NODE *psDeviceNode)
 */
 static IMG_UINT32 RGXGetTFBCLossyGroup(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-
 #if defined(RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK)
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	return psDevInfo->ui32TFBCLossyGroup;
 #else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 	return 0;
 #endif
 }
@@ -1309,22 +1570,40 @@ static MMU_DEVICEATTRIBS *RGXDevMMUAttributes(PVRSRV_DEVICE_NODE *psDeviceNode,
 	return psMMUDevAttrs;
 }
 
+/*
+	RGXDevSnoopMode
+*/
+static PVRSRV_DEVICE_SNOOP_MODE RGXDevSnoopMode(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(psDeviceNode != NULL);
+	PVR_ASSERT(psDeviceNode->pvDevice != NULL);
+
+	psDevInfo = (PVRSRV_RGXDEV_INFO *) psDeviceNode->pvDevice;
+
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, AXI_ACELITE))
+	{
+		return PVRSRV_DEVICE_SNOOP_CPU_ONLY;
+	}
+
+	return PVRSRV_DEVICE_SNOOP_NONE;
+}
+
 /*
  * RGXInitDevPart2
  */
 PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
-                             IMG_UINT32			ui32DeviceFlags,
-                             IMG_UINT32			ui32HWPerfHostFilter,
-                             RGX_ACTIVEPM_CONF		eActivePMConf,
-                             RGX_FWT_LOGTYPE		eDebugDumpFWTLogType)
+                             RGX_INIT_APPHINTS	*psApphints)
 {
 	PVRSRV_ERROR			eError;
 	PVRSRV_RGXDEV_INFO		*psDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_DEV_POWER_STATE	eDefaultPowerState = PVRSRV_DEV_POWER_STATE_ON;
 	PVRSRV_DEVICE_CONFIG	*psDevConfig = psDeviceNode->psDevConfig;
-
-	/* Assume system layer has turned power on by this point, required before powering device */
-	psDeviceNode->eCurrentSysPowerState = PVRSRV_SYS_POWER_STATE_ON;
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	IMG_UINT32			ui32AllPowUnitsMask = (1 << psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount) - 1;
+	IMG_UINT32			ui32AllRACMask = (1 << psDevInfo->sDevFeatureCfg.ui32MAXRACCount) - 1;
+#endif
 
 	PDUMPCOMMENT(psDeviceNode, "RGX Initialisation Part 2");
 
@@ -1340,7 +1619,7 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 
 	/* Initialise Device Flags */
 	psDevInfo->ui32DeviceFlags = 0;
-	RGXSetDeviceFlags(psDevInfo, ui32DeviceFlags, IMG_TRUE);
+	RGXSetDeviceFlags(psDevInfo, psApphints->ui32DeviceFlags, IMG_TRUE);
 
 	/* Allocate DVFS Table (needs to be allocated before GPU trace events
 	 *  component is initialised because there is a dependency between them) */
@@ -1349,7 +1628,7 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 
 	if (psDevInfo->ui32HWPerfHostFilter == 0)
 	{
-		RGXHWPerfHostSetEventFilter(psDevInfo, ui32HWPerfHostFilter);
+		RGXHWPerfHostSetEventFilter(psDevInfo, psApphints->ui32HWPerfHostFilter);
 	}
 
 	/* If HWPerf enabled allocate all resources for the host side buffer. */
@@ -1363,7 +1642,7 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Initialise work estimation lock */
 		eError = OSLockCreate(&psDevInfo->hWorkEstLock);
@@ -1408,19 +1687,36 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 #endif
 
 	eDefaultPowerState = PVRSRV_DEV_POWER_STATE_ON;
-	psDevInfo->eActivePMConf = eActivePMConf;
+	psDevInfo->eActivePMConf = psApphints->eRGXActivePMConf;
+
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	/* Validate the SPU mask and initialize to number of SPUs to power up */
+	if ((psApphints->ui32AvailablePowUnitsMask & ui32AllPowUnitsMask) == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s:Invalid SPU mask (All=0x%X, Non Fused=0x%X). At-least one SPU must to be powered up.",
+		         __func__,
+		         ui32AllPowUnitsMask,
+		         psApphints->ui32AvailablePowUnitsMask));
+		PVR_LOG_GOTO_WITH_ERROR("ui32AvailablePowUnitsMask", eError, PVRSRV_ERROR_INVALID_SPU_MASK, ErrorExit);
+	}
+
+	psDevInfo->ui32AvailablePowUnitsMask = psApphints->ui32AvailablePowUnitsMask & ui32AllPowUnitsMask;
+
+	psDevInfo->ui32AvailableRACMask = psApphints->ui32AvailableRACMask & ui32AllRACMask;
+#endif
 
 #if !defined(NO_HARDWARE)
 	/* set-up the Active Power Mgmt callback */
 	{
 		RGX_DATA *psRGXData = (RGX_DATA*) psDeviceNode->psDevConfig->hDevData;
 		IMG_BOOL bSysEnableAPM = psRGXData->psRGXTimingInfo->bEnableActivePM;
-		IMG_BOOL bEnableAPM = ((eActivePMConf == RGX_ACTIVEPM_DEFAULT) && bSysEnableAPM) ||
-							   (eActivePMConf == RGX_ACTIVEPM_FORCE_ON);
+		IMG_BOOL bEnableAPM = ((psApphints->eRGXActivePMConf == RGX_ACTIVEPM_DEFAULT) && bSysEnableAPM) ||
+							   (psApphints->eRGXActivePMConf == RGX_ACTIVEPM_FORCE_ON);
 
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1) && defined(SUPPORT_AUTOVZ)
 		/* The AutoVz driver enables a virtualisation watchdog not compatible with APM */
-		if (bEnableAPM && (!PVRSRV_VZ_MODE_IS(NATIVE)))
+		if (bEnableAPM && (!PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode)))
 		{
 			PVR_DPF((PVR_DBG_WARNING, "%s: Active Power Management disabled in AutoVz mode", __func__));
 			bEnableAPM = IMG_FALSE;
@@ -1443,7 +1739,7 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 	}
 #endif
 
-	psDevInfo->eDebugDumpFWTLogType = eDebugDumpFWTLogType;
+	psDevInfo->eDebugDumpFWTLogType = psApphints->eDebugDumpFWTLogType;
 
 	PVRSRVAppHintRegisterHandlersUINT32(APPHINT_ID_EnableAPM,
 	                                    RGXQueryAPMState,
@@ -1455,56 +1751,20 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 
 	/* Register the device with the power manager */
 	eError = PVRSRVRegisterPowerDevice(psDeviceNode,
-			(PVRSRV_VZ_MODE_IS(NATIVE)) ? &RGXPrePowerState : &RGXVzPrePowerState,
-			(PVRSRV_VZ_MODE_IS(NATIVE)) ? &RGXPostPowerState : &RGXVzPostPowerState,
-			psDevConfig->pfnPrePowerState, psDevConfig->pfnPostPowerState,
-			&RGXPreClockSpeedChange, &RGXPostClockSpeedChange,
-			&RGXForcedIdleRequest, &RGXCancelForcedIdleRequest,
-			&RGXDustCountChange,
-			(IMG_HANDLE)psDeviceNode,
-			PVRSRV_DEV_POWER_STATE_OFF,
-			eDefaultPowerState);
+	                                   (PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode)) ? &RGXPrePowerState : &RGXVzPrePowerState,
+	                                   (PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode)) ? &RGXPostPowerState : &RGXVzPostPowerState,
+	                                   psDevConfig->pfnPrePowerState, psDevConfig->pfnPostPowerState,
+	                                   &RGXPreClockSpeedChange, &RGXPostClockSpeedChange,
+	                                   &RGXForcedIdleRequest, &RGXCancelForcedIdleRequest,
+	                                   &RGXPowUnitsChange,
+	                                   (IMG_HANDLE)psDeviceNode,
+	                                   PVRSRV_DEV_POWER_STATE_OFF,
+	                                   eDefaultPowerState);
 	PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVRegisterPowerDevice", ErrorExit);
 
 	eError = RGXSetPowerParams(psDevInfo, psDevConfig);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXSetPowerParams", ErrorExit);
 
-#if defined(SUPPORT_VALIDATION)
-	{
-		void *pvAppHintState = NULL;
-
-		IMG_UINT32 ui32AppHintDefault;
-
-		OSCreateAppHintState(&pvAppHintState);
-		ui32AppHintDefault = PVRSRV_APPHINT_TESTSLRINTERVAL;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, TestSLRInterval,
-		                     &ui32AppHintDefault, &psDevInfo->ui32TestSLRInterval);
-		PVR_LOG(("OSGetAppHintUINT32(TestSLRInterval) ui32AppHintDefault=%d, psDevInfo->ui32TestSLRInterval=%d",
-		        ui32AppHintDefault, psDevInfo->ui32TestSLRInterval));
-		OSFreeAppHintState(pvAppHintState);
-		psDevInfo->ui32TestSLRCount = psDevInfo->ui32TestSLRInterval;
-		psDevInfo->ui32SLRSkipFWAddr = 0;
-
-		ui32AppHintDefault = 0;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, ECCRAMErrInj, &ui32AppHintDefault, &psDevInfo->ui32ECCRAMErrInjModule);
-		psDevInfo->ui32ECCRAMErrInjInterval = RGXKM_ECC_ERR_INJ_INTERVAL;
-
-#if defined(PDUMP) && defined(SUPPORT_VALIDATION)
-		/* POL on ECC RAM GPU fault events, MARS is FW fault */
-		if (psDevInfo->ui32ECCRAMErrInjModule != RGXKM_ECC_ERR_INJ_DISABLE &&
-			psDevInfo->ui32ECCRAMErrInjModule != RGXKM_ECC_ERR_INJ_MARS)
-		{
-			PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_DEINIT, "Verify ECC fault event");
-			eError = PDUMPREGPOL(psDeviceNode, RGX_PDUMPREG_NAME,
-								 RGX_CR_SCRATCH11,
-								 1U,
-								 0xFFFFFFFF,
-								 PDUMP_FLAGS_DEINIT,
-								 PDUMP_POLL_OPERATOR_EQUAL);
-		}
-#endif
-	}
-#endif
 
 #if defined(PDUMP)
 #if defined(NO_HARDWARE)
@@ -1531,7 +1791,7 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 
 	psDevInfo->sLayerParams.ui32PdumpFlags |= PDUMP_FLAGS_DEINIT | PDUMP_FLAGS_NOHW;
 
-	if (! PVRSRV_VZ_MODE_IS(GUEST))
+	if (! PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = RGXStop(&psDevInfo->sLayerParams);
 		PVR_LOG_GOTO_IF_ERROR(eError, "RGXStop", ErrorExit);
@@ -1555,42 +1815,8 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSInstallMISR(MISR)", ErrorExit);
 
 	/* Register appropriate mechanism for clearing hw interrupts */
-	if ((RGX_IS_FEATURE_SUPPORTED(psDevInfo, IRQ_PER_OS)) && (!PVRSRV_VZ_MODE_IS(NATIVE)))
-	{
-		psDevInfo->pfnRGXAckIrq = RGXAckIrqDedicated;
-	}
-	else if (PVRSRV_VZ_MODE_IS(GUEST))
-	{
-		psDevInfo->pfnRGXAckIrq = NULL;
-	}
-	else
-	{
-		/* native and host drivers must clear the unique GPU physical interrupt */
-		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
-		{
-			psDevInfo->pfnRGXAckIrq = RGXAckIrqMIPS;
-		}
-		else if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META))
-		{
-			psDevInfo->pfnRGXAckIrq = RGXAckIrqMETA;
-		}
-		else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR))
-		{
-			psDevInfo->pfnRGXAckIrq = RGXAckIrqDedicated;
-		}
-		else
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: GPU IRQ clearing mechanism not implemented "
-									"for the this architecture.", __func__));
-			PVR_LOG_GOTO_WITH_ERROR("pfnRGXAckIrq", eError, PVRSRV_ERROR_NOT_IMPLEMENTED, ErrorExit);
-		}
-	}
-
-#if defined(RGX_IRQ_HYPERV_HANDLER)
-		/* The hypervisor receives and acknowledges the GPU irq, then it injects an
-		 * irq only in the recipient OS. The KM driver doesn't handle the GPU irq line */
-		psDevInfo->pfnRGXAckIrq = NULL;
-#endif
+	eError = RGXSetAckIrq(psDevInfo);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXSetAckIrq", ErrorExit);
 
 	eError = SysInstallDeviceLISR(psDevConfig->hSysData,
 								  psDevConfig->ui32IRQ,
@@ -1602,28 +1828,16 @@ PVRSRV_ERROR RGXInitDevPart2(PVRSRV_DEVICE_NODE	*psDeviceNode,
 #endif /* !defined(NO_HARDWARE) */
 
 #if defined(PDUMP)
-	if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_CACHE_HIERARCHY)))
-	{
-		if (!PVRSRVSystemSnoopingOfCPUCache(psDevConfig) &&
-				!PVRSRVSystemSnoopingOfDeviceCache(psDevConfig))
-		{
-			PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
-			                      "System has NO cache snooping");
-		}
-		else
-		{
-			if (PVRSRVSystemSnoopingOfCPUCache(psDevConfig))
-			{
-				PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
-				                      "System has CPU cache snooping");
-			}
-			if (PVRSRVSystemSnoopingOfDeviceCache(psDevConfig))
-			{
-				PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
-				                      "System has DEVICE cache snooping");
-			}
-		}
-	}
+    if (PVRSRVSystemSnoopingOfCPUCache(psDevConfig))
+    {
+        PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
+                              "System has CPU cache snooping");
+    }
+    else
+    {
+        PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
+                              "System has NO cache snooping");
+    }
 #endif
 
 #if defined(RGX_FEATURE_COMPUTE_ONLY_BIT_MASK)
@@ -1665,7 +1879,7 @@ static void _GetFWFileName(PVRSRV_DEVICE_NODE *psDeviceNode,
 {
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	const IMG_CHAR * const pszFWFilenameSuffix =
-			PVRSRV_VZ_MODE_IS(NATIVE) ? "" : VZ_RGX_FW_FILENAME_SUFFIX;
+			PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode) ? "" : VZ_RGX_FW_FILENAME_SUFFIX;
 
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	const IMG_CHAR * const pszFWFilenameSuffix2 =
@@ -1677,23 +1891,20 @@ static void _GetFWFileName(PVRSRV_DEVICE_NODE *psDeviceNode,
 #endif
 
 	OSSNPrintf(pszFWFilenameStr, RGX_FW_FILENAME_MAX_SIZE,
-			"%s." RGX_BVNC_STR_FMTSPEC "%s%s",
-			RGX_FW_FILENAME,
+			RGX_FW_FILENAME "." RGX_BVNC_STR_FMTSPEC "%s%s",
 			psDevInfo->sDevFeatureCfg.ui32B, psDevInfo->sDevFeatureCfg.ui32V,
 			psDevInfo->sDevFeatureCfg.ui32N, psDevInfo->sDevFeatureCfg.ui32C,
 			pszFWFilenameSuffix, pszFWFilenameSuffix2);
 
 	OSSNPrintf(pszFWpFilenameStr, RGX_FW_FILENAME_MAX_SIZE,
-			"%s." RGX_BVNC_STRP_FMTSPEC "%s%s",
-			RGX_FW_FILENAME,
+			RGX_FW_FILENAME "." RGX_BVNC_STRP_FMTSPEC "%s%s",
 			psDevInfo->sDevFeatureCfg.ui32B, psDevInfo->sDevFeatureCfg.ui32V,
 			psDevInfo->sDevFeatureCfg.ui32N, psDevInfo->sDevFeatureCfg.ui32C,
 			pszFWFilenameSuffix, pszFWFilenameSuffix2);
 }
 
 PVRSRV_ERROR RGXLoadAndGetFWData(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                 OS_FW_IMAGE **ppsRGXFW,
-                                 const IMG_BYTE **ppbFWData)
+                                 OS_FW_IMAGE **ppsRGXFW)
 {
 	IMG_CHAR aszFWFilenameStr[RGX_FW_FILENAME_MAX_SIZE];
 	IMG_CHAR aszFWpFilenameStr[RGX_FW_FILENAME_MAX_SIZE];
@@ -1725,15 +1936,9 @@ PVRSRV_ERROR RGXLoadAndGetFWData(PVRSRV_DEVICE_NODE *psDeviceNode,
 	if (eErr == PVRSRV_OK)
 	{
 		PVR_LOG(("RGX Firmware image '%s' loaded", pszLoadedFwStr));
-		*ppbFWData = (const IMG_BYTE*)OSFirmwareData(*ppsRGXFW);
-	}
-	else
-	{
-		*ppbFWData = NULL;
 	}
 
 	return eErr;
-
 }
 
 #if defined(PDUMP)
@@ -1746,17 +1951,19 @@ PVRSRV_ERROR RGXInitHWPerfCounters(PVRSRV_DEVICE_NODE *psDeviceNode)
 PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	/* set up fw memory contexts */
-	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_ERROR       eError;
+	PVRSRV_RGXDEV_INFO   *psDevInfo = psDeviceNode->pvDevice;
+	__maybe_unused PVRSRV_DEVICE_CONFIG *psDevConfig = psDeviceNode->psDevConfig;
+	PVRSRV_ERROR eError;
 
 #if defined(RGX_PREMAP_FW_HEAPS) || defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
-	IMG_BOOL  bNativeFwUMAHeap = PVRSRV_VZ_MODE_IS(NATIVE) &&
+	IMG_BOOL  bNativeFwUMAHeap = PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDeviceNode) &&
 	                             (PhysHeapGetType(psDeviceNode->apsPhysHeap[FIRST_PHYSHEAP_MAPPED_TO_FW_MAIN_DEVMEM]) == PHYS_HEAP_TYPE_UMA);
 #endif
 
 #if defined(RGX_PREMAP_FW_HEAPS)
 	PHYS_HEAP *psDefaultPhysHeap = psDeviceNode->psMMUPhysHeap;
-	if ((!PVRSRV_VZ_MODE_IS(GUEST)) && (!psDeviceNode->bAutoVzFwIsUp) && (!bNativeFwUMAHeap))
+
+	if ((!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)) && (!psDeviceNode->bAutoVzFwIsUp) && (!bNativeFwUMAHeap))
 	{
 		PHYS_HEAP *psFwPageTableHeap =
 				psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_PREMAP_PT];
@@ -1772,11 +1979,28 @@ PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode
 	}
 #endif
 
+#if defined(RGX_FEATURE_AXI_ACE_BIT_MASK)
+	/* Set the device fabric coherency before FW context creation */
+	eError = RGXSystemGetFabricCoherency(psDevConfig,
+										 psDevConfig->sRegsCpuPBase,
+										 psDevConfig->ui32RegsSize,
+										 &psDeviceNode->eDevFabricType,
+										 &psDevConfig->eCacheSnoopingMode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Failed RGXSystemGetFabricCoherency (%u)",
+		         __func__,
+		         eError));
+		goto failed_to_create_ctx;
+	}
+#endif
+
 	/* Register callbacks for creation of device memory contexts */
 	psDeviceNode->pfnRegisterMemoryContext = RGXRegisterMemoryContext;
 	psDeviceNode->pfnUnregisterMemoryContext = RGXUnregisterMemoryContext;
 
-	RGXFwSharedMemCheckSnoopMode(psDevInfo->psDeviceNode->psDevConfig);
+	RGXFwSharedMemCheckSnoopMode(psDevConfig);
 
 	/* Create the memory context for the firmware. */
 	eError = DevmemCreateContext(psDeviceNode, DEVMEM_HEAPCFG_FORFW,
@@ -1813,11 +2037,11 @@ PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode
 	}
 
 #if (defined(RGX_PREMAP_FW_HEAPS)) || (defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1))
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		IMG_UINT32 ui32DriverID;
 
-		FOREACH_DRIVER_RAW_HEAP(ui32DriverID)
+		FOREACH_DRIVER_RAW_HEAP(ui32DriverID, DEVNODE, psDeviceNode)
 		{
 			IMG_CHAR szHeapName[RA_MAX_NAME_LENGTH];
 
@@ -1830,17 +2054,30 @@ PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode
 #endif
 
 #if defined(RGX_PREMAP_FW_HEAPS) || defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
-	if (!PVRSRV_VZ_MODE_IS(GUEST) && !bNativeFwUMAHeap)
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) && !bNativeFwUMAHeap)
 	{
 		IMG_DEV_PHYADDR sPhysHeapBase;
 		IMG_UINT32 ui32DriverID;
+		void *pvAppHintState = NULL;
+		IMG_UINT64 ui64DefaultHeapStride;
+		IMG_UINT64 ui64GuestHeapDevBaseStride;
+
+		OSCreateAppHintState(&pvAppHintState);
+		ui64DefaultHeapStride = PVRSRV_APPHINT_GUESTFWHEAPSTRIDE;
+		OSGetAppHintUINT64(APPHINT_NO_DEVICE,
+							pvAppHintState,
+							GuestFWHeapStride,
+							&ui64DefaultHeapStride,
+							&ui64GuestHeapDevBaseStride);
+		OSFreeAppHintState(pvAppHintState);
+		pvAppHintState = NULL;
 
 		eError = PhysHeapGetDevPAddr(psDeviceNode->apsPhysHeap[FIRST_PHYSHEAP_MAPPED_TO_FW_MAIN_DEVMEM], &sPhysHeapBase);
 		PVR_LOG_GOTO_IF_ERROR(eError, "PhysHeapGetDevPAddr", failed_to_find_heap);
 
-		FOREACH_DRIVER_RAW_HEAP(ui32DriverID)
+		FOREACH_DRIVER_RAW_HEAP(ui32DriverID, DEVNODE, psDeviceNode)
 		{
-			IMG_DEV_PHYADDR sRawFwHeapBase = {sPhysHeapBase.uiAddr + (ui32DriverID * RGX_FIRMWARE_RAW_HEAP_SIZE)};
+			IMG_DEV_PHYADDR sRawFwHeapBase = {sPhysHeapBase.uiAddr + (ui32DriverID * ui64GuestHeapDevBaseStride)};
 
 			eError = RGXFwRawHeapAllocMap(psDeviceNode,
 										  ui32DriverID,
@@ -1866,14 +2103,14 @@ PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode
 #if !defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
 	/* On setups with dynamically mapped Guest heaps, the Guest makes
 	 * a PVZ call to the Host to request the mapping during init. */
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
-		eError = PvzClientMapDevPhysHeap(psDeviceNode->psDevConfig);
+		eError = PvzClientMapDevPhysHeap(psDevConfig);
 		PVR_LOG_GOTO_IF_ERROR(eError, "PvzClientMapDevPhysHeap", failed_to_find_heap);
 	}
 #endif /* !defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) */
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		DevmemHeapSetPremapStatus(psDevInfo->psFirmwareMainHeap, IMG_TRUE);
 		DevmemHeapSetPremapStatus(psDevInfo->psFirmwareConfigHeap, IMG_TRUE);
@@ -1903,7 +2140,7 @@ void RGXDeInitDestroyFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode)
 #endif
 
 #if defined(RGX_PREMAP_FW_HEAPS) || defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 #if defined(RGX_PREMAP_FW_HEAPS)
 		psDeviceNode->psMMUPhysHeap =
@@ -1914,7 +2151,7 @@ void RGXDeInitDestroyFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode)
 		{
 			IMG_UINT32 ui32DriverID;
 
-			FOREACH_DRIVER_RAW_HEAP(ui32DriverID)
+			FOREACH_DRIVER_RAW_HEAP(ui32DriverID, DEVNODE, psDeviceNode)
 			{
 				RGXFwRawHeapUnmapFree(psDeviceNode, ui32DriverID);
 			}
@@ -1923,7 +2160,7 @@ void RGXDeInitDestroyFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode)
 #endif /* defined(RGX_PREMAP_FW_HEAPS) || defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) */
 
 #if !defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		(void) PvzClientUnmapDevPhysHeap(psDeviceNode->psDevConfig);
 
@@ -1968,7 +2205,7 @@ static PVRSRV_ERROR RGXAlignmentCheck(PVRSRV_DEVICE_NODE *psDevNode,
 
 	/* Skip the alignment check if the driver is guest
 	   since there is no firmware to check against */
-	PVRSRV_VZ_RET_IF_MODE(GUEST, eError);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDevNode, eError);
 
 	if (psDevInfo->psRGXFWAlignChecksMemDesc == NULL)
 	{
@@ -2099,24 +2336,45 @@ static PVRSRV_ERROR RGXDevInitCompatCheck_KMBuildOptions_FWAgainstDriver(PVRSRV_
 	IMG_UINT32			ui32BuildOptions, ui32BuildOptionsFWKMPart, ui32BuildOptionsMismatch;
 	RGX_FW_INFO_HEADER	*psFWInfoHeader = NULL;
 	RGXFWIF_OSINIT		*psFwOsInit = NULL;
+	IMG_UINT8               ui8FwOsCount;
 
 	if (psDevInfo == NULL)
 		return PVRSRV_ERROR_INVALID_PARAMS;
 
 	ui32BuildOptions = (RGX_BUILD_OPTIONS_KM & RGX_BUILD_OPTIONS_MASK_FW);
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		psFwOsInit = psDevInfo->psRGXFWIfOsInit;
 		if (psFwOsInit == NULL)
 			return PVRSRV_ERROR_INVALID_PARAMS;
 
 		ui32BuildOptionsFWKMPart = psFwOsInit->sRGXCompChecks.ui32BuildOptions & RGX_BUILD_OPTIONS_MASK_FW;
+
+		ui8FwOsCount = psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.sInitOptions.ui8OsCountSupport;
+		if (ui8FwOsCount != RGX_NUM_DRIVERS_SUPPORTED)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "%s: Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
+					__func__, RGX_NUM_DRIVERS_SUPPORTED, ui8FwOsCount));
+			return PVRSRV_ERROR_BUILD_OPTIONS_MISMATCH;
+		}
 	}
 	else
 	{
 		psFWInfoHeader = &psDevInfo->sFWInfoHeader;
 		ui32BuildOptionsFWKMPart = psFWInfoHeader->ui32Flags & RGX_BUILD_OPTIONS_MASK_FW;
+
+		if (PVRSRV_VZ_MODE_IS(HOST, DEVINFO, psDevInfo) && BITMASK_HAS(psFWInfoHeader->ui32Flags, OPTIONS_NUM_DRIVERS_SUPPORTED_CHECK_EN))
+		{
+			ui8FwOsCount = (psFWInfoHeader->ui32Flags & OPTIONS_NUM_DRIVERS_SUPPORTED_MASK) >> OPTIONS_NUM_DRIVERS_SUPPORTED_SHIFT;
+			ui8FwOsCount++;
+			if (ui8FwOsCount != RGX_NUM_DRIVERS_SUPPORTED)
+			{
+				PVR_DPF((PVR_DBG_WARNING, "%s: Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
+					__func__, RGX_NUM_DRIVERS_SUPPORTED, ui8FwOsCount));
+				return PVRSRV_ERROR_BUILD_OPTIONS_MISMATCH;
+			}
+		}
 	}
 
 	/* Check if the FW is missing support for any features required by the driver */
@@ -2179,7 +2437,7 @@ static PVRSRV_ERROR RGXDevInitCompatCheck_DDKVersion_FWAgainstDriver(PVRSRV_RGXD
 
 	ui32KMDDKVersion = PVRVERSION_PACK(PVRVERSION_MAJ, PVRVERSION_MIN);
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		psFwOsInit = psDevInfo->psRGXFWIfOsInit;
 		if (psFwOsInit == NULL)
@@ -2241,7 +2499,7 @@ static PVRSRV_ERROR RGXDevInitCompatCheck_DDKBuild_FWAgainstDriver(PVRSRV_RGXDEV
 	if (psDevInfo == NULL)
 		return PVRSRV_ERROR_INVALID_PARAMS;
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		psFwOsInit = psDevInfo->psRGXFWIfOsInit;
 		if (psFwOsInit == NULL)
@@ -2356,11 +2614,11 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_ERROR		eError;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 #if !defined(NO_HARDWARE)
-	IMG_UINT32			ui32FwTimeout = MAX_HW_TIME_US;
-
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
-		LOOP_UNTIL_TIMEOUT(ui32FwTimeout)
+		IMG_UINT32			ui32FwTimeout = MAX_HW_TIME_US;
+
+		LOOP_UNTIL_TIMEOUT_US(ui32FwTimeout)
 		{
 			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.bUpdated,
 		                               INVALIDATE);
@@ -2370,12 +2628,8 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 				break;
 			}
 			OSWaitus(ui32FwTimeout/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
-	}
-
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
-	{
 		/* Flush covers this instance and the reads in the functions below */
 		RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfOsInit->sRGXCompChecks,
 	                               INVALIDATE);
@@ -2390,12 +2644,6 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 			goto chk_exit;
 		}
 	}
-
-	if (PVRSRV_VZ_MODE_IS(NATIVE) && (RGX_NUM_DRIVERS_SUPPORTED > 1))
-	{
-		PVR_DPF((PVR_DBG_WARNING, "%s: Mismatch between the number of Operating Systems supported by KM driver (%d) and FW (%d)",
-				__func__, 1, RGX_NUM_DRIVERS_SUPPORTED));
-	}
 #endif /* defined(NO_HARDWARE) */
 
 	eError = RGXDevInitCompatCheck_KMBuildOptions_FWAgainstDriver(psDevInfo);
@@ -2416,7 +2664,7 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 		goto chk_exit;
 	}
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = RGXDevInitCompatCheck_BVNC_FWAgainstDriver(psDevInfo);
 		if (eError != PVRSRV_OK)
@@ -2431,6 +2679,16 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
 	return eError;
 }
 
+static void _RGXSoftResetToggle(PVRSRV_RGXDEV_INFO *psDevInfo,
+                                IMG_UINT64  ui64ResetValue1,
+                                IMG_UINT64  ui64ResetValue2)
+{
+	OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET, ui64ResetValue1);
+
+	/* Read soft-reset to fence previous write in order to clear the SOCIF pipeline */
+	(void) OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET);
+}
+
 /**************************************************************************/ /*!
 @Function       RGXSoftReset
 @Description    Resets some modules of the RGX device
@@ -2442,10 +2700,10 @@ static PVRSRV_ERROR RGXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode)
                                 to a module to reset (via the SOFT_RESET2
                                 register).
 @Return         PVRSRV_ERROR
- */ /***************************************************************************/
+*/ /***************************************************************************/
 static PVRSRV_ERROR RGXSoftReset(PVRSRV_DEVICE_NODE *psDeviceNode,
-		IMG_UINT64  ui64ResetValue1,
-		IMG_UINT64  ui64ResetValue2)
+                                 IMG_UINT64  ui64ResetValue1,
+                                 IMG_UINT64  ui64ResetValue2)
 {
 	PVRSRV_RGXDEV_INFO        *psDevInfo;
 	IMG_BOOL	bSoftReset = IMG_FALSE;
@@ -2453,61 +2711,31 @@ static PVRSRV_ERROR RGXSoftReset(PVRSRV_DEVICE_NODE *psDeviceNode,
 
 	PVR_ASSERT(psDeviceNode != NULL);
 	PVR_ASSERT(psDeviceNode->pvDevice != NULL);
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
-	/* the device info */
 	psDevInfo = psDeviceNode->pvDevice;
+
 #if defined(RGX_CR_SOFT_RESET__PBE2_XE__MASKFULL)
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, PBE2_IN_XE))
 	{
 		ui64SoftResetMask = RGX_CR_SOFT_RESET__PBE2_XE__MASKFULL;
-	}else
+	}
+	else
 #endif
 	{
 		ui64SoftResetMask = RGX_CR_SOFT_RESET_MASKFULL;
 	}
 
-#if defined(RGX_CR_SOFT_RESET2_MASKFULL)
-	if ((RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE)) &&
-			((ui64ResetValue2 & RGX_CR_SOFT_RESET2_MASKFULL) != ui64ResetValue2))
-	{
-		bSoftReset = IMG_TRUE;
-	}
-#endif
-
 	if (((ui64ResetValue1 & ui64SoftResetMask) != ui64ResetValue1) || bSoftReset)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	/* Set in soft-reset */
-	OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET, ui64ResetValue1);
-
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET2, ui64ResetValue2);
-	}
-
-	/* Read soft-reset to fence previous write in order to clear the SOCIF pipeline */
-	(void) OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET);
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		(void) OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET2);
-	}
+	_RGXSoftResetToggle(psDevInfo, ui64ResetValue1, ui64ResetValue2);
 
 	/* Take the modules out of reset... */
-	OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET, 0);
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		OSWriteHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET2, 0);
-	}
-
-	/* ...and fence again */
-	(void) OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET);
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		(void) OSReadHWReg64(psDevInfo->pvRegsBaseKM, RGX_CR_SOFT_RESET2);
-	}
+	_RGXSoftResetToggle(psDevInfo, 0, 0);
 
 	return PVRSRV_OK;
 }
@@ -2682,7 +2910,7 @@ PVRSRV_ERROR RGXInitAllocFWImgMem(PVRSRV_DEVICE_NODE   *psDeviceNode,
 	}
 
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
-	if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) || (PVRSRV_VZ_MODE_IS(GUEST))))
+	if (!(RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) || (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))))
 #endif
 	{
 		/*
@@ -3018,20 +3246,8 @@ PVRSRV_ERROR RGXSetFWPoisonOnFree(const PVRSRV_DEVICE_NODE *psDeviceNode,
  */
 PVRSRV_ERROR
 RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
-                IMG_BOOL                 bEnableSignatureChecks,
-                IMG_UINT32               ui32SignatureChecksBufSize,
-                IMG_UINT32               ui32HWPerfFWBufSizeKB,
-                IMG_UINT64               ui64HWPerfFilter,
+                RGX_INIT_APPHINTS        *psApphints,
                 IMG_UINT32               ui32ConfigFlags,
-                IMG_UINT32               ui32LogType,
-                IMG_UINT32               ui32FilterFlags,
-                IMG_UINT32               ui32JonesDisableMask,
-                IMG_UINT32               ui32HWRDebugDumpLimit,
-                IMG_UINT32               ui32HWPerfCountersDataSize,
-                IMG_UINT32               *pui32TPUTrilinearFracMask,
-                RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandingConf,
-                FW_PERF_CONF             eFirmwarePerf,
-                IMG_UINT32               ui32KCCBSizeLog2,
                 IMG_UINT32               ui32ConfigFlagsExt,
                 IMG_UINT32               ui32FwOsCfgFlags)
 {
@@ -3044,22 +3260,10 @@ RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 #endif
 
 	eError = RGXSetupFirmware(psDeviceNode,
-	                          bEnableSignatureChecks,
-	                          ui32SignatureChecksBufSize,
-	                          ui32HWPerfFWBufSizeKB,
-	                          ui64HWPerfFilter,
+	                          psApphints,
 	                          ui32ConfigFlags,
 	                          ui32ConfigFlagsExt,
-	                          ui32FwOsCfgFlags,
-	                          ui32LogType,
-	                          ui32FilterFlags,
-	                          ui32JonesDisableMask,
-	                          ui32HWRDebugDumpLimit,
-	                          ui32HWPerfCountersDataSize,
-	                          pui32TPUTrilinearFracMask,
-	                          eRGXRDPowerIslandingConf,
-	                          eFirmwarePerf,
-	                          ui32KCCBSizeLog2);
+	                          ui32FwOsCfgFlags);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
@@ -3068,7 +3272,7 @@ RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 		goto failed_init_firmware;
 	}
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		PVRSRVAppHintRegisterHandlersUINT32(APPHINT_ID_EnableLogGroup,
 		                                    RGXFWTraceQueryFilter,
@@ -3119,6 +3323,7 @@ RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 /* See device.h for function declaration */
 static PVRSRV_ERROR RGXAllocUFOBlock(PVRSRV_DEVICE_NODE *psDeviceNode,
+									 IMG_UINT32 ui32RequestedSize,
 									 DEVMEM_MEMDESC **psMemDesc,
 									 IMG_UINT32 *puiSyncPrimVAddr,
 									 IMG_UINT32 *puiSyncPrimBlockSize)
@@ -3126,35 +3331,24 @@ static PVRSRV_ERROR RGXAllocUFOBlock(PVRSRV_DEVICE_NODE *psDeviceNode,
 	PVRSRV_RGXDEV_INFO *psDevInfo;
 	PVRSRV_ERROR eError;
 	RGXFWIF_DEV_VIRTADDR pFirmwareAddr;
-	IMG_DEVMEM_SIZE_T uiUFOBlockSize = sizeof(IMG_UINT32);
-	IMG_DEVMEM_ALIGN_T ui32UFOBlockAlign = sizeof(IMG_UINT32);
-	IMG_UINT32 ui32CoherencyFlag = 0;
+	IMG_DEVMEM_ALIGN_T uiUFOBlockAlign = MAX(sizeof(IMG_UINT32), sizeof(SYNC_CHECKPOINT_FW_OBJ));
+	IMG_DEVMEM_SIZE_T uiUFOBlockSize = PVR_ALIGN(ui32RequestedSize, uiUFOBlockAlign);
 
 	psDevInfo = psDeviceNode->pvDevice;
 
 	/* Size and align are 'expanded' because we request an Exportalign allocation */
 	eError = DevmemExportalignAdjustSizeAndAlign(DevmemGetHeapLog2PageSize(psDevInfo->psFirmwareMainHeap),
 	                                             &uiUFOBlockSize,
-	                                             &ui32UFOBlockAlign);
+	                                             &uiUFOBlockAlign);
 
 	if (eError != PVRSRV_OK)
 	{
 		goto e0;
 	}
 
-	if (PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig) &&
-		PVRSRVSystemSnoopingOfCPUCache(psDeviceNode->psDevConfig))
-	{
-		ui32CoherencyFlag = PVRSRV_MEMALLOCFLAG_CACHE_COHERENT;
-	}
-	else
-	{
-		ui32CoherencyFlag = PVRSRV_MEMALLOCFLAG_UNCACHED;
-	}
-
 	eError = DevmemFwAllocateExportable(psDeviceNode,
 										uiUFOBlockSize,
-										ui32UFOBlockAlign,
+										uiUFOBlockAlign,
 										PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN) |
 										PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) |
 										PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE |
@@ -3163,7 +3357,7 @@ static PVRSRV_ERROR RGXAllocUFOBlock(PVRSRV_DEVICE_NODE *psDeviceNode,
 										PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
 										PVRSRV_MEMALLOCFLAG_CPU_READABLE |
 										PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE |
-										ui32CoherencyFlag,
+										PVRSRV_MEMALLOCFLAG_UNCACHED,
 										"FwExUFOBlock",
 										psMemDesc);
 	if (eError != PVRSRV_OK)
@@ -3191,63 +3385,6 @@ static void RGXFreeUFOBlock(PVRSRV_DEVICE_NODE *psDeviceNode,
 {
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
-	/*
-		If the system has snooping of the device cache then the UFO block
-		might be in the cache so we need to flush it out before freeing
-		the memory
-
-		When the device is being shutdown/destroyed we don't care anymore.
-		Several necessary data structures to issue a flush were destroyed
-		already.
-	 */
-	if (PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig) &&
-		psDeviceNode->eDevState != PVRSRV_DEVICE_STATE_DEINIT &&
-		psDeviceNode->eDevState != PVRSRV_DEVICE_STATE_DEINIT_POWERED_OFF)
-	{
-		RGXFWIF_KCCB_CMD sFlushInvalCmd;
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32kCCBCommandSlot;
-
-		/* Schedule the SLC flush command ... */
-#if defined(PDUMP)
-		PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
-		                      "Submit SLC flush and invalidate");
-#endif
-		sFlushInvalCmd.eCmdType = RGXFWIF_KCCB_CMD_SLCFLUSHINVAL;
-		sFlushInvalCmd.uCmdData.sSLCFlushInvalData.bInval = IMG_TRUE;
-		sFlushInvalCmd.uCmdData.sSLCFlushInvalData.bDMContext = IMG_FALSE;
-		sFlushInvalCmd.uCmdData.sSLCFlushInvalData.psContext.ui32Addr = 0;
-
-		eError = RGXSendCommandWithPowLockAndGetKCCBSlot(psDevInfo,
-														 &sFlushInvalCmd,
-														 PDUMP_FLAGS_CONTINUOUS,
-														 &ui32kCCBCommandSlot);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,
-			         "%s: Failed to schedule SLC flush command with error (%u)",
-			         __func__,
-			         eError));
-		}
-		else
-		{
-			/* Wait for the SLC flush to complete */
-			eError = RGXWaitForKCCBSlotUpdate(psDevInfo, ui32kCCBCommandSlot, PDUMP_FLAGS_CONTINUOUS);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-				         "%s: SLC flush and invalidate aborted with error (%u)",
-				         __func__,
-				         eError));
-			}
-			else if (unlikely(psDevInfo->pui32KernelCCBRtnSlots[ui32kCCBCommandSlot] &
-							  RGXFWIF_KCCB_RTN_SLOT_POLL_FAILURE))
-			{
-				PVR_DPF((PVR_DBG_WARNING, "%s: FW poll on a HW operation failed", __func__));
-			}
-		}
-	}
-
 	RGXUnsetFirmwareAddress(psMemDesc);
 	DevmemFwUnmapAndFree(psDevInfo, psMemDesc);
 }
@@ -3341,7 +3478,7 @@ static void DevPart2DeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* De-init work estimation lock */
 		if (psDevInfo->hWorkEstLock != NULL)
@@ -3381,14 +3518,12 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 		KM_CONNECTION_CACHEOP(Os, FLUSH);
 	}
 
-	DeviceDepBridgeDeInit(psDevInfo);
+	RGXUnregisterBridges(psDevInfo);
 
 #if defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS)
 	OSLockDestroy(psDevInfo->hCounterDumpingLock);
 #endif
 
-	RGXDeInitMultiCoreInfo(psDeviceNode);
-
 	/* Unregister debug request notifiers first as they could depend on anything. */
 
 	RGXDebugDeinit(psDevInfo);
@@ -3464,7 +3599,7 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
 
-	RGXDeInitHeaps(psDevMemoryInfo);
+	RGXDeInitHeaps(psDevMemoryInfo, psDeviceNode);
 
 	if (psDevInfo->psRGXFWCodeMemDesc)
 	{
@@ -3475,7 +3610,7 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 		psDevInfo->psRGXFWCodeMemDesc = NULL;
 	}
 #if !defined(NO_HARDWARE)
-	else if (!PVRSRV_VZ_MODE_IS(GUEST))
+	else if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		PVR_DPF((PVR_DBG_WARNING, "No firmware code memory to free"));
 	}
@@ -3503,7 +3638,7 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 		psDevInfo->psRGXFWDataMemDesc = NULL;
 	}
 #if !defined(NO_HARDWARE)
-	else if (!PVRSRV_VZ_MODE_IS(GUEST))
+	else if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		PVR_DPF((PVR_DBG_WARNING, "No firmware data memory to free"));
 	}
@@ -3532,6 +3667,9 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 	 */
 	RGXFreeFirmware(psDevInfo);
 
+
+	RGXDeInitMultiCoreInfo(psDeviceNode);
+
 	/* De-initialise non-device specific (TL) users of RGX device memory */
 	{
 		IMG_UINT32 i;
@@ -3543,18 +3681,20 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 		RGXHWPerfDeinit(psDevInfo);
 	}
 
+	RGXDeInitDestroyFWKernelMemoryContext(psDeviceNode);
+
 	RGXHWPerfHostDeInit(psDevInfo);
 	eError = HTBDeInit();
 	PVR_LOG_IF_ERROR(eError, "HTBDeInit");
 
-	RGXDeInitDestroyFWKernelMemoryContext(psDeviceNode);
+	OSLockDestroy(psDevInfo->hGpuUtilStatsLock);
 
 	/* destroy the stalled CCB locks */
 	OSLockDestroy(psDevInfo->hCCBRecoveryLock);
 	OSLockDestroy(psDevInfo->hCCBStallCheckLock);
 
 	/* destroy the context list locks */
-	OSLockDestroy(psDevInfo->sRegCongfig.hLock);
+	OSLockDestroy(psDevInfo->sRegConfig.hLock);
 	OSLockDestroy(psDevInfo->hBPLock);
 	OSLockDestroy(psDevInfo->hRGXFWIfBufInitLock);
 	OSWRLockDestroy(psDevInfo->hRenderCtxListLock);
@@ -3572,6 +3712,7 @@ PVRSRV_ERROR DevDeInitRGX(PVRSRV_DEVICE_NODE *psDeviceNode)
 		OSFreeMem(psDevInfo->sDevFeatureCfg.pszBVNCString);
 	}
 
+
 	/* DeAllocate devinfo */
 	OSFreeMem(psDevInfo);
 
@@ -3594,9 +3735,10 @@ PVRSRV_ERROR RGXResetPDump(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 /* Takes a log2 page size parameter and calculates a suitable page size
  * for the RGX heaps. Returns 0 if parameter is wrong.*/
-static INLINE IMG_UINT32 RGXHeapDerivePageSize(IMG_UINT32 uiLog2PageSize)
+IMG_UINT32 RGXHeapDerivePageSize(IMG_UINT32 uiLog2PageSize)
 {
 	IMG_BOOL bFound = IMG_FALSE;
+	IMG_UINT32 ui32PageSizeMask = RGXGetValidHeapPageSizeMask();
 
 	/* OS page shift must be at least RGX_HEAP_4KB_PAGE_SHIFT,
 	 * max RGX_HEAP_2MB_PAGE_SHIFT, non-zero and a power of two*/
@@ -3614,24 +3756,18 @@ static INLINE IMG_UINT32 RGXHeapDerivePageSize(IMG_UINT32 uiLog2PageSize)
 
 	do
 	{
-		switch (uiLog2PageSize)
+		if ((IMG_PAGE2BYTES32(uiLog2PageSize) & ui32PageSizeMask) == 0)
 		{
-			case RGX_HEAP_4KB_PAGE_SHIFT:
-			case RGX_HEAP_16KB_PAGE_SHIFT:
-			case RGX_HEAP_64KB_PAGE_SHIFT:
-			case RGX_HEAP_256KB_PAGE_SHIFT:
-			case RGX_HEAP_1MB_PAGE_SHIFT:
-			case RGX_HEAP_2MB_PAGE_SHIFT:
-				/* All good, RGX page size equals given page size
-				 * => use it as default for heaps */
-				bFound = IMG_TRUE;
-				break;
-			default:
-				/* We have to fall back to a smaller device
-				 * page size than given page size because there
-				 * is no exact match for any supported size. */
-				uiLog2PageSize -= 1U;
-				break;
+			/* We have to fall back to a smaller device
+			 * page size than given page size because there
+			 * is no exact match for any supported size. */
+			uiLog2PageSize -= 1U;
+		}
+		else
+		{
+			/* All good, RGX page size equals given page size
+			 * => use it as default for heaps */
+			bFound = IMG_TRUE;
 		}
 	} while (!bFound);
 
@@ -3654,6 +3790,7 @@ static INLINE IMG_UINT32 RGXHeapDerivePageSize(IMG_UINT32 uiLog2PageSize)
 
 typedef struct RGX_HEAP_INFO_TAG RGX_HEAP_INFO; // Forward declaration
 typedef IMG_BOOL (*PFN_IS_PRESENT)(PVRSRV_RGXDEV_INFO*, const RGX_HEAP_INFO*);
+typedef void (*PFN_HEAP_DYNAMIC)(PVRSRV_DEVICE_NODE*, RGX_HEAP_INFO*);
 
 struct RGX_HEAP_INFO_TAG
 {
@@ -3663,55 +3800,54 @@ struct RGX_HEAP_INFO_TAG
 	IMG_DEVMEM_SIZE_T  uiHeapReservedRegionLength;
 	IMG_UINT32         ui32Log2ImportAlignment;
 	PFN_IS_PRESENT     pfnIsHeapPresent;
+	PFN_HEAP_DYNAMIC   pfnDynamicBaseSize; /* May modify the psHeapInfo's base & length. May be NULL.
+	                                          Only called once if the heap is present otherwise never. */
 	PFN_HEAP_INIT      pfnInit;
 	PFN_HEAP_DEINIT    pfnDeInit;
 	IMG_UINT32         ui32HeapInstanceFlags;
 };
-
 /* RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES is the total amount of reserved space, to be specified in gasRGXHeapLayoutApp[] */
 #define RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES	(RGX_HEAP_UM_GENERAL_RESERVED_SIZE + RGXFWIF_KM_GENERAL_HEAP_RESERVED_SIZE)
 
-#if defined(SUPPORT_SECURE_ALLOC_KM)
-/* Private data struct for general heap. */
-typedef struct RGX_GENERAL_HEAP_DATA_TAG
+/* Private heap data struct. */
+typedef struct RGX_HEAP_DATA_TAG
 {
-	DEVMEMINT_RESERVATION  *psSecMemReservation;
-	DEVMEMINT_MAPPING      *psSecMemMapping;
-} RGX_GENERAL_HEAP_DATA;
-
-/* Init callback function for general heap. */
-static PVRSRV_ERROR GeneralHeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                    DEVMEMINT_HEAP *psDevmemHeap,
-                                    IMG_HANDLE *phPrivData)
+	DEVMEMINT_RESERVATION  *psMemReservation;
+} RGX_HEAP_DATA;
+
+static PVRSRV_ERROR HeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
+							 DEVMEMINT_HEAP *psDevmemHeap,
+							 PMR *psPMR,
+							 IMG_DEVMEM_SIZE_T uiSize,
+							 IMG_UINT64 ui64Offset,
+							 IMG_BOOL bWriteAble,
+							 IMG_HANDLE *phPrivData)
 {
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	RGX_GENERAL_HEAP_DATA *psHeapData;
+	RGX_HEAP_DATA *psHeapData;
 	IMG_DEV_VIRTADDR sCarveOutAddr;
 	PVRSRV_ERROR eError;
 
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psDeviceNode, "psDeviceNode");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(psDevmemHeap, "psDevmemHeap");
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psPMR, "psPMR");
 	PVR_LOG_RETURN_IF_INVALID_PARAM(phPrivData, "phPrivData");
 
-	psDevInfo = psDeviceNode->pvDevice;
-
 	psHeapData = OSAllocMem(sizeof(*psHeapData));
 	PVR_LOG_RETURN_IF_NOMEM(psHeapData, "psHeapData");
 
 	/* Map the per device secure mem PMR allocation to the general devmem heap carveout. */
 	sCarveOutAddr = DevmemIntHeapGetBaseAddr(psDevmemHeap);
-	sCarveOutAddr.uiAddr += RGX_HEAP_KM_GENERAL_RESERVED_REGION_OFFSET;
+	sCarveOutAddr.uiAddr += ui64Offset;
 
 	eError = DevmemIntReserveRange(psDevmemHeap,
-								   sCarveOutAddr,
-								   RGXFWIF_KM_GENERAL_HEAP_RESERVED_SIZE,
-								   &psHeapData->psSecMemReservation);
+									sCarveOutAddr,
+									uiSize,
+									PVRSRV_MEMALLOCFLAG_GPU_READABLE |
+									(bWriteAble ? PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE : 0),
+									&psHeapData->psMemReservation);
 	PVR_GOTO_IF_ERROR(eError, ErrorFreeHeapData);
 
-	eError = DevmemIntMapPMR(psDevmemHeap, psHeapData->psSecMemReservation, psDevInfo->psGenHeapSecMem,
-					PVRSRV_MEMALLOCFLAG_GPU_READABLE
-					| PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE,
-					&psHeapData->psSecMemMapping);
+	eError = DevmemIntMapPMR(psHeapData->psMemReservation, psPMR);
 	PVR_GOTO_IF_ERROR(eError, ErrorUnreserve);
 
 	*phPrivData = (IMG_HANDLE)psHeapData;
@@ -3719,7 +3855,7 @@ static PVRSRV_ERROR GeneralHeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
 	return PVRSRV_OK;
 
 ErrorUnreserve:
-	DevmemIntUnreserveRange(psHeapData->psSecMemReservation);
+	DevmemIntUnreserveRange(psHeapData->psMemReservation);
 ErrorFreeHeapData:
 	OSFreeMem(psHeapData);
 
@@ -3727,28 +3863,121 @@ static PVRSRV_ERROR GeneralHeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
 }
 
 /* Deinit callback function for general heap. */
-static void GeneralHeapDeInit(IMG_HANDLE hPrivData)
+static void HeapDeInit(IMG_HANDLE hPrivData)
 {
-	RGX_GENERAL_HEAP_DATA *psHeapData = (RGX_GENERAL_HEAP_DATA*)hPrivData;
+	RGX_HEAP_DATA *psHeapData = (RGX_HEAP_DATA*)hPrivData;
 
 	PVR_ASSERT(hPrivData);
 
-	DevmemIntUnmapPMR(psHeapData->psSecMemMapping);
-	DevmemIntUnreserveRange(psHeapData->psSecMemReservation);
+	DevmemIntUnmapPMR(psHeapData->psMemReservation);
+	DevmemIntUnreserveRange(psHeapData->psMemReservation);
 
 	OSFreeMem(psHeapData);
 }
+
+/* Init callback function for general heap. */
+static PVRSRV_ERROR USCHeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
+                                    DEVMEMINT_HEAP *psDevmemHeap,
+                                    IMG_HANDLE *phPrivData)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_BOOL bWriteAble = IMG_FALSE;
+	IMG_DEVMEM_SIZE_T uiSize;
+	PVRSRV_ERROR eError;
+
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psDeviceNode, "psDeviceNode");
+
+	psDevInfo = psDeviceNode->pvDevice;
+
+	uiSize = PMR_PhysicalSize(psDevInfo->hTQUSCSharedMem);
+
+	eError = HeapInit(psDeviceNode,
+					  psDevmemHeap,
+					  psDevInfo->hTQUSCSharedMem,
+					  uiSize,
+					  RGX_HEAP_KM_USC_RESERVED_REGION_OFFSET,
+					  bWriteAble,
+					  phPrivData);
+
+	return eError;
+}
+
+#if defined(SUPPORT_SECURE_ALLOC_KM)
+/* Init callback function for general heap. */
+static PVRSRV_ERROR GeneralHeapInit(PVRSRV_DEVICE_NODE *psDeviceNode,
+                                    DEVMEMINT_HEAP *psDevmemHeap,
+                                    IMG_HANDLE *phPrivData)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_BOOL bWriteAble = IMG_TRUE;
+	PVRSRV_ERROR eError;
+
+	psDevInfo = psDeviceNode->pvDevice;
+
+	eError = HeapInit(psDeviceNode,
+					  psDevmemHeap,
+					  psDevInfo->psGenHeapSecMem,
+					  RGXFWIF_KM_GENERAL_HEAP_RESERVED_SIZE,
+					  RGX_HEAP_KM_GENERAL_RESERVED_REGION_OFFSET,
+					  bWriteAble,
+					  phPrivData);
+
+	return eError;
+}
+
+#define GeneralHeapDeInit HeapDeInit
 #else
 /* Callbacks not used */
 #define GeneralHeapInit NULL
 #define GeneralHeapDeInit NULL
 #endif
 
+static void SVMHeapDynamic(PVRSRV_DEVICE_NODE *psDeviceNode,
+                           RGX_HEAP_INFO *psHeapInfo)
+{
+	IMG_UINT64 ui64OSPageSize = OSGetPageSize();
+#if defined(FIX_HW_BRN_65273_BIT_MASK)
+	PVRSRV_RGXDEV_INFO* psDevInfo = psDeviceNode->pvDevice;
+#endif /* defined(FIX_HW_BRN_65273_BIT_MASK) */
+
+	/* Ensures the SVM heap has the correct alignment & size for any OS page size.
+	 *
+	 * The SVM heap's base must be the smallest possible address mappable by UM.
+	 * This is 32KB unless the page size is larger than 32KB. [1]
+	 * If the page size > 32KB, raise the SVM heap base to the next page boundary.
+	 * Also reduce the length to ensure it's still page aligned and doesn't go
+	 * into another heap.
+	 *
+	 * [1]: https://chromium.googlesource.com/chromium/src/+/fe24932ee14aa93e1fe4d3e7003b9362591a54d4/docs/security/faq.md#why-aren_t-null-pointer-dereferences-considered-security-bugs
+	 */
+	IMG_UINT64 ui64Base = PVR_ALIGN(psHeapInfo->ui64HeapBase, ui64OSPageSize);
+	IMG_UINT64 ui64BaseDiff = ui64Base - psHeapInfo->ui64HeapBase;
+	psHeapInfo->ui64HeapBase = ui64Base;
+	if (psHeapInfo->uiHeapLength >= ui64BaseDiff)
+	    psHeapInfo->uiHeapLength -= ui64BaseDiff;
+	if (psHeapInfo->uiHeapReservedRegionLength >= ui64BaseDiff)
+	    psHeapInfo->uiHeapReservedRegionLength -= ui64BaseDiff;
+
+	/* The device shared-virtual-memory heap address-space size is stored on the device for
+	   faster look-up without having to walk the device heap configuration structures during
+	   client device connection  (i.e. this size is relative to a zero-based offset) */
+#if defined(FIX_HW_BRN_65273_BIT_MASK)
+	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65273))
+	{
+		psDeviceNode->ui64GeneralSVMHeapTopVA = 0;
+	}
+	else
+#endif /* defined(FIX_HW_BRN_65273_BIT_MASK) */
+	{
+		psDeviceNode->ui64GeneralSVMHeapTopVA = psHeapInfo->ui64HeapBase + psHeapInfo->uiHeapLength;
+	}
+}
+
 /* Feature Present function prototypes */
 
+#if defined(FIX_HW_BRN_65273_BIT_MASK)
 static IMG_BOOL BRN65273IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_INFO *pksHeapInfo)
 {
-#if defined(FIX_HW_BRN_65273_BIT_MASK)
 	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65273))
 	{
 		return (((pksHeapInfo->ui32HeapInstanceFlags & HEAP_INST_VALUE_MASK) == HEAP_INST_BRN_ALT_VALUE) ||
@@ -3756,19 +3985,17 @@ static IMG_BOOL BRN65273IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_
 		        IMG_TRUE : IMG_FALSE;
 	}
 	else
-#else
-	PVR_UNREFERENCED_PARAMETER(psDevInfo);
-#endif
 	{
 		return ((pksHeapInfo->ui32HeapInstanceFlags & HEAP_INST_VALUE_MASK) == HEAP_INST_DEFAULT_VALUE) ? IMG_TRUE : IMG_FALSE;
 	}
 }
+#endif
 
+#if defined(FIX_HW_BRN_63142_BIT_MASK)
 static IMG_BOOL BRN63142IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_INFO *pksHeapInfo)
 {
 	PVR_UNREFERENCED_PARAMETER(pksHeapInfo);
 
-#if defined(FIX_HW_BRN_63142_BIT_MASK)
 	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 63142))
 	{
 		PVR_ASSERT((pksHeapInfo->ui64HeapBase & IMG_UINT64_C(0x3FFFFFFFF)) +
@@ -3776,12 +4003,10 @@ static IMG_BOOL BRN63142IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_
 
 		return IMG_TRUE;
 	}
-#else
-	PVR_UNREFERENCED_PARAMETER(psDevInfo);
-#endif
 
 	return IMG_FALSE;
 }
+#endif
 
 static IMG_BOOL FBCDescriptorIsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_INFO *pksHeapInfo)
 {
@@ -3821,18 +4046,9 @@ static IMG_BOOL TextureStateIsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_H
 	return IMG_FALSE;
 }
 
-static IMG_BOOL SignalSnoopingIsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_INFO *pksHeapInfo)
-{
-	PVR_UNREFERENCED_PARAMETER(pksHeapInfo);
-
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, SIGNAL_SNOOPING))
-	{
-		return IMG_TRUE;
-	}
-
-	return IMG_FALSE;
-}
+/* FW Feature Present function prototypes */
 
+#if defined(FIX_HW_BRN_65101_BIT_MASK)
 static IMG_BOOL FWBRN65101IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEAP_INFO *pksHeapInfo)
 {
 	/* Used to determine the correct table row to instantiate as a heap by checking
@@ -3841,15 +4057,13 @@ static IMG_BOOL FWBRN65101IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEA
 	IMG_UINT64 ui64MainSubHeapSize;
 
 	/* MIPS Firmware must reserve some space in its Host/Native heap for GPU memory mappings */
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) && (!PVRSRV_VZ_MODE_IS(GUEST)))
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) && (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo)))
 	{
-#if defined(FIX_HW_BRN_65101_BIT_MASK)
 		if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65101))
 		{
 			ui64MainSubHeapSize = RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_BRN65101;
 		}
 		else
-#endif
 		{
 			ui64MainSubHeapSize = RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_NORMAL;
 		}
@@ -3864,6 +4078,7 @@ static IMG_BOOL FWBRN65101IsPresent(PVRSRV_RGXDEV_INFO *psDevInfo, const RGX_HEA
 	        pksHeapInfo->ui64HeapBase == RGX_FIRMWARE_MAIN_HEAP_BASE) ?
 	        IMG_TRUE : IMG_FALSE;
 }
+#endif
 
 static IMG_BOOL FWVZConfigPresent(PVRSRV_RGXDEV_INFO* psDevInfo, const RGX_HEAP_INFO* pksHeapInfo)
 {
@@ -3877,43 +4092,110 @@ static IMG_BOOL FWVZConfigPresent(PVRSRV_RGXDEV_INFO* psDevInfo, const RGX_HEAP_
 
 /* Blueprint array. note: not all heaps are available to clients*/
 
-static const RGX_HEAP_INFO gasRGXHeapLayoutApp[] =
+static RGX_HEAP_INFO gasRGXHeapLayoutApp[] =
 {
-	/* Name                             HeapBase                                 HeapLength                               HeapReservedRegionLength                     Log2ImportAlignment pfnPresent                   pfnInit           pfnDeInit          HeapInstanceFlags   */
-	{RGX_GENERAL_SVM_HEAP_IDENT,        RGX_GENERAL_SVM_HEAP_BASE,               RGX_GENERAL_SVM_HEAP_SIZE,               0,                                           0,                  NULL,                        NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_GENERAL_HEAP_IDENT,            RGX_GENERAL_HEAP_BASE,                   RGX_GENERAL_HEAP_SIZE,                   RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES,       0,                  BRN65273IsPresent,           GeneralHeapInit,  GeneralHeapDeInit, HEAP_INST_DEFAULT_VALUE },
-	{RGX_GENERAL_HEAP_IDENT,            RGX_GENERAL_BRN_65273_HEAP_BASE,         RGX_GENERAL_BRN_65273_HEAP_SIZE,         RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES,       0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
-	{RGX_GENERAL_NON4K_HEAP_IDENT,      RGX_GENERAL_NON4K_HEAP_BASE,             RGX_GENERAL_NON4K_HEAP_SIZE,             0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_DEFAULT_VALUE | HEAP_INST_NON4K_FLAG },
-	{RGX_GENERAL_NON4K_HEAP_IDENT,      RGX_GENERAL_NON4K_BRN_65273_HEAP_BASE,   RGX_GENERAL_NON4K_BRN_65273_HEAP_SIZE,   0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE | HEAP_INST_NON4K_FLAG },
-	{RGX_PDSCODEDATA_HEAP_IDENT,        RGX_PDSCODEDATA_HEAP_BASE,               RGX_PDSCODEDATA_HEAP_SIZE,               RGX_HEAP_PDS_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_PDSCODEDATA_HEAP_IDENT,        RGX_PDSCODEDATA_BRN_65273_HEAP_BASE,     RGX_PDSCODEDATA_BRN_65273_HEAP_SIZE,     RGX_HEAP_PDS_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
-	{RGX_RGNHDR_BRN_63142_HEAP_IDENT,   RGX_RGNHDR_BRN_63142_HEAP_BASE,          RGX_RGNHDR_BRN_63142_HEAP_SIZE,          0,                                           0,                  BRN63142IsPresent,           NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE },
-	{RGX_USCCODE_HEAP_IDENT,            RGX_USCCODE_HEAP_BASE,                   RGX_USCCODE_HEAP_SIZE,                   RGX_HEAP_USC_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_USCCODE_HEAP_IDENT,            RGX_USCCODE_BRN_65273_HEAP_BASE,         RGX_USCCODE_BRN_65273_HEAP_SIZE,         RGX_HEAP_USC_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
-	{RGX_TQ3DPARAMETERS_HEAP_IDENT,     RGX_TQ3DPARAMETERS_HEAP_BASE,            RGX_TQ3DPARAMETERS_HEAP_SIZE,            0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_TQ3DPARAMETERS_HEAP_IDENT,     RGX_TQ3DPARAMETERS_BRN_65273_HEAP_BASE,  RGX_TQ3DPARAMETERS_BRN_65273_HEAP_SIZE,  0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
-	{RGX_VK_CAPT_REPLAY_HEAP_IDENT,     RGX_VK_CAPT_REPLAY_HEAP_BASE,            RGX_VK_CAPT_REPLAY_HEAP_SIZE,            0,                                           0,                  NULL,                        NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_SIGNALS_HEAP_IDENT,            RGX_SIGNALS_HEAP_BASE,                   RGX_SIGNALS_HEAP_SIZE,                   0,                                           0,                  SignalSnoopingIsPresent,     NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
-	{RGX_FBCDC_HEAP_IDENT,              RGX_FBCDC_HEAP_BASE,                     RGX_FBCDC_HEAP_SIZE,                     0,                                           0,                  FBCDescriptorIsPresent,      NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
-	{RGX_FBCDC_LARGE_HEAP_IDENT,        RGX_FBCDC_LARGE_HEAP_BASE,               RGX_FBCDC_LARGE_HEAP_SIZE,               0,                                           0,                  FBCLargeDescriptorIsPresent, NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
-	{RGX_CMP_MISSION_RMW_HEAP_IDENT,    RGX_CMP_MISSION_RMW_HEAP_BASE,           RGX_CMP_MISSION_RMW_HEAP_SIZE,           0,                                           0,                  NULL,                        NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_CMP_SAFETY_RMW_HEAP_IDENT,     RGX_CMP_SAFETY_RMW_HEAP_BASE,            RGX_CMP_SAFETY_RMW_HEAP_SIZE,            0,                                           0,                  NULL,                        NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_TEXTURE_STATE_HEAP_IDENT,      RGX_TEXTURE_STATE_HEAP_BASE,             RGX_TEXTURE_STATE_HEAP_SIZE,             0,                                           0,                  TextureStateIsPresent,       NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
-	{RGX_VISIBILITY_TEST_HEAP_IDENT,    RGX_VISIBILITY_TEST_HEAP_BASE,           RGX_VISIBILITY_TEST_HEAP_SIZE,           0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
-	{RGX_VISIBILITY_TEST_HEAP_IDENT,    RGX_VISIBILITY_TEST_BRN_65273_HEAP_BASE, RGX_VISIBILITY_TEST_BRN_65273_HEAP_SIZE, 0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
-	{RGX_MMU_INIA_BRN_65273_HEAP_IDENT, RGX_MMU_INIA_BRN_65273_HEAP_BASE,        RGX_MMU_INIA_BRN_65273_HEAP_SIZE,        0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE },
-	{RGX_MMU_INIB_BRN_65273_HEAP_IDENT, RGX_MMU_INIB_BRN_65273_HEAP_BASE,        RGX_MMU_INIB_BRN_65273_HEAP_SIZE,        0,                                           0,                  BRN65273IsPresent,           NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE }
+	/* Name                             HeapBase                                 HeapLength                               HeapReservedRegionLength                     Log2ImportAlignment pfnIsHeapPresent             pfnDynamicBaseSize pfnInit           pfnDeInit          HeapInstanceFlags   */
+	{RGX_GENERAL_SVM_HEAP_IDENT,        RGX_GENERAL_SVM_HEAP_BASE,               RGX_GENERAL_SVM_HEAP_SIZE,               0,                                           0,                  NULL,                        SVMHeapDynamic,    NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_GENERAL_HEAP_IDENT,            RGX_GENERAL_HEAP_BASE,                   RGX_GENERAL_HEAP_SIZE,                   RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES,       0,                  BRN65273IsPresent,           NULL,              GeneralHeapInit,  GeneralHeapDeInit, HEAP_INST_DEFAULT_VALUE },
+	{RGX_GENERAL_HEAP_IDENT,            RGX_GENERAL_BRN_65273_HEAP_BASE,         RGX_GENERAL_BRN_65273_HEAP_SIZE,         RGX_GENERAL_HEAP_RESERVED_TOTAL_BYTES,       0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
+	{RGX_GENERAL_NON4K_HEAP_IDENT,      RGX_GENERAL_NON4K_HEAP_BASE,             RGX_GENERAL_NON4K_HEAP_SIZE,             0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE | HEAP_INST_NON4K_FLAG },
+	{RGX_GENERAL_NON4K_HEAP_IDENT,      RGX_GENERAL_NON4K_BRN_65273_HEAP_BASE,   RGX_GENERAL_NON4K_BRN_65273_HEAP_SIZE,   0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE | HEAP_INST_NON4K_FLAG },
+	{RGX_PDSCODEDATA_HEAP_IDENT,        RGX_PDSCODEDATA_HEAP_BASE,               RGX_PDSCODEDATA_HEAP_SIZE,               RGX_HEAP_PDS_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_PDSCODEDATA_HEAP_IDENT,        RGX_PDSCODEDATA_BRN_65273_HEAP_BASE,     RGX_PDSCODEDATA_BRN_65273_HEAP_SIZE,     RGX_HEAP_PDS_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
+	{RGX_RGNHDR_BRN_63142_HEAP_IDENT,   RGX_RGNHDR_BRN_63142_HEAP_BASE,          RGX_RGNHDR_BRN_63142_HEAP_SIZE,          0,                                           0,                  BRN63142IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE },
+	{RGX_USCCODE_HEAP_IDENT,            RGX_USCCODE_HEAP_BASE,                   RGX_USCCODE_HEAP_SIZE,                   RGX_HEAP_USC_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,              USCHeapInit,      HeapDeInit,        HEAP_INST_DEFAULT_VALUE },
+	{RGX_USCCODE_HEAP_IDENT,            RGX_USCCODE_BRN_65273_HEAP_BASE,         RGX_USCCODE_BRN_65273_HEAP_SIZE,         RGX_HEAP_USC_RESERVED_TOTAL_SIZE,            0,                  BRN65273IsPresent,           NULL,              USCHeapInit,      HeapDeInit,        HEAP_INST_BRN_ALT_VALUE },
+	{RGX_TQ3DPARAMETERS_HEAP_IDENT,     RGX_TQ3DPARAMETERS_HEAP_BASE,            RGX_TQ3DPARAMETERS_HEAP_SIZE,            0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_TQ3DPARAMETERS_HEAP_IDENT,     RGX_TQ3DPARAMETERS_BRN_65273_HEAP_BASE,  RGX_TQ3DPARAMETERS_BRN_65273_HEAP_SIZE,  0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
+	{RGX_VK_CAPT_REPLAY_HEAP_IDENT,     RGX_VK_CAPT_REPLAY_HEAP_BASE,            RGX_VK_CAPT_REPLAY_HEAP_SIZE,            0,                                           0,                  NULL,                        NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_FBCDC_HEAP_IDENT,              RGX_FBCDC_HEAP_BASE,                     RGX_FBCDC_HEAP_SIZE,                     0,                                           0,                  FBCDescriptorIsPresent,      NULL,              NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
+	{RGX_FBCDC_LARGE_HEAP_IDENT,        RGX_FBCDC_LARGE_HEAP_BASE,               RGX_FBCDC_LARGE_HEAP_SIZE,               0,                                           0,                  FBCLargeDescriptorIsPresent, NULL,              NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
+	{RGX_CMP_MISSION_RMW_HEAP_IDENT,    RGX_CMP_MISSION_RMW_HEAP_BASE,           RGX_CMP_MISSION_RMW_HEAP_SIZE,           0,                                           0,                  NULL,                        NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_CMP_SAFETY_RMW_HEAP_IDENT,     RGX_CMP_SAFETY_RMW_HEAP_BASE,            RGX_CMP_SAFETY_RMW_HEAP_SIZE,            0,                                           0,                  NULL,                        NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_TEXTURE_STATE_HEAP_IDENT,      RGX_TEXTURE_STATE_HEAP_BASE,             RGX_TEXTURE_STATE_HEAP_SIZE,             0,                                           0,                  TextureStateIsPresent,       NULL,              NULL,             NULL,              HEAP_INST_FEAT_DEP_VALUE},
+	{RGX_VISIBILITY_TEST_HEAP_IDENT,    RGX_VISIBILITY_TEST_HEAP_BASE,           RGX_VISIBILITY_TEST_HEAP_SIZE,           0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_DEFAULT_VALUE },
+	{RGX_VISIBILITY_TEST_HEAP_IDENT,    RGX_VISIBILITY_TEST_BRN_65273_HEAP_BASE, RGX_VISIBILITY_TEST_BRN_65273_HEAP_SIZE, 0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_ALT_VALUE },
+	{RGX_MMU_INIA_BRN_65273_HEAP_IDENT, RGX_MMU_INIA_BRN_65273_HEAP_BASE,        RGX_MMU_INIA_BRN_65273_HEAP_SIZE,        0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE },
+	{RGX_MMU_INIB_BRN_65273_HEAP_IDENT, RGX_MMU_INIB_BRN_65273_HEAP_BASE,        RGX_MMU_INIB_BRN_65273_HEAP_SIZE,        0,                                           0,                  BRN65273IsPresent,           NULL,              NULL,             NULL,              HEAP_INST_BRN_DEP_VALUE },
 };
 
-static const RGX_HEAP_INFO gasRGXHeapLayoutFW[] =
+static RGX_HEAP_INFO gasRGXHeapLayoutFW[] =
 {
-	/* Name                          HeapBase                             HeapLength                                 HeapReservedRegionLength Log2ImportAlignment pfnIsHeapPresent     pfnInit pfnDeInit HeapInstanceFlags*/
-	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_DEFAULT_MAIN_HEAP_SIZE,            0,                       0,                  FWBRN65101IsPresent, NULL,   NULL,     HEAP_INST_DEFAULT_VALUE},
-	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_NORMAL,   0,                       0,                  FWBRN65101IsPresent, NULL,   NULL,     HEAP_INST_DEFAULT_VALUE},
-	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_BRN65101, 0,                       0,                  FWBRN65101IsPresent, NULL,   NULL,     HEAP_INST_BRN_ALT_VALUE},
-	{RGX_FIRMWARE_CONFIG_HEAP_IDENT, RGX_FIRMWARE_CONFIG_HEAP_BASE,  RGX_FIRMWARE_CONFIG_HEAP_SIZE,                  0,                       0,                  FWVZConfigPresent,   NULL,   NULL,     HEAP_INST_DEFAULT_VALUE},
+	/* Name                          HeapBase                        HeapLength                                      HeapReservedRegionLength Log2ImportAlignment pfnIsHeapPresent     pfnDynamicBaseSize pfnInit pfnDeInit HeapInstanceFlags*/
+	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_DEFAULT_MAIN_HEAP_SIZE,            0,                       0,                  FWBRN65101IsPresent, NULL,              NULL,   NULL,      HEAP_INST_DEFAULT_VALUE},
+	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_NORMAL,   0,                       0,                  FWBRN65101IsPresent, NULL,              NULL,   NULL,      HEAP_INST_DEFAULT_VALUE},
+	{RGX_FIRMWARE_MAIN_HEAP_IDENT,   RGX_FIRMWARE_MAIN_HEAP_BASE,    RGX_FIRMWARE_HOST_MIPS_MAIN_HEAP_SIZE_BRN65101, 0,                       0,                  FWBRN65101IsPresent, NULL,              NULL,   NULL,      HEAP_INST_BRN_ALT_VALUE},
+	{RGX_FIRMWARE_CONFIG_HEAP_IDENT, RGX_FIRMWARE_CONFIG_HEAP_BASE,  RGX_FIRMWARE_CONFIG_HEAP_SIZE,                  0,                       0,                  FWVZConfigPresent,   NULL,              NULL,   NULL,      HEAP_INST_DEFAULT_VALUE},
 };
 
+static INLINE IMG_BOOL IsFwHeapLayout(const RGX_HEAP_INFO *psHeapInfo)
+{
+	return psHeapInfo->pszName[0] == 'F' &&
+	       psHeapInfo->pszName[1] == 'w' ? IMG_TRUE : IMG_FALSE;
+}
+
+static INLINE void CheckHeapAlignment(const RGX_HEAP_INFO *psHeapInfo,
+                                      const PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	IMG_UINT64 uiAlignment = RGX_HEAP_BASE_SIZE_ALIGN - 1;
+
+	if (IsFwHeapLayout(psHeapInfo) ||
+	    RGX_IS_BRN_SUPPORTED(psDevInfo, 65273))
+	{
+		/*
+		 * 1) Main heap starts at 2MB offset 0xEC10000000UL
+		 * 2) Config Sub heap is created at the end of the main heap making the entire unit start and end at 2MB offset aligned,
+		 *    these 2 heaps will always have the same page size
+		 *    There are no other heaps in between these two heaps, there is no risk for another devmem heap be created between them.
+		 */
+		return;
+	}
+
+	/* General SVM Heap must be placed below 2MiB boundary so we need to adjust
+	 * the validity condition. This is because an OS might return virtual
+	 * addresses below 2MiB threshold. By default (based on testing on Linux)
+	 * this is around 32KiB. */
+	if (OSStringNCompare(psHeapInfo->pszName, RGX_GENERAL_SVM_HEAP_IDENT,
+	                     sizeof(RGX_GENERAL_SVM_HEAP_IDENT)) == 0)
+	{
+		uiAlignment = RGX_GENERAL_SVM_BASE_SIZE_ALIGNMENT - 1;
+	}
+
+	/* All UM accessible heap bases should be aligned to 2MB */
+	if (psHeapInfo->ui64HeapBase & uiAlignment)
+	{
+		PVR_ASSERT(!"Heap Base not aligned to RGX_HEAP_BASE_SIZE_ALIGN");
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Invalid Heap \"%s\" Base: "
+		         "%"IMG_UINT64_FMTSPEC")",
+		         __func__,
+		         psHeapInfo->pszName,
+		         psHeapInfo->ui64HeapBase));
+		PVR_DPF((PVR_DBG_ERROR,
+		         "Heap Base (0x%"IMG_UINT64_FMTSPECX") should always be aligned to "
+		         "RGX_HEAP_BASE_ALIGN (0x%" IMG_UINT64_FMTSPECX ")",
+		         psHeapInfo->ui64HeapBase,
+		         uiAlignment + 1));
+	}
+
+	/* All UM accessible heaps should also be size aligned to 2MB */
+	if (psHeapInfo->uiHeapLength & uiAlignment)
+	{
+		PVR_ASSERT(!"Heap Size not aligned to RGX_HEAP_BASE_SIZE_ALIGN");
+		PVR_DPF((PVR_DBG_ERROR,
+		         "%s: Invalid Heap \"%s\" Size: "
+		         "%"IMG_UINT64_FMTSPEC")",
+		         __func__,
+		         psHeapInfo->pszName,
+		         psHeapInfo->uiHeapLength));
+		PVR_DPF((PVR_DBG_ERROR,
+		         "Heap Size (0x%"IMG_UINT64_FMTSPECX") should always be aligned to "
+		         "RGX_HEAP_BASE_SIZE_ALIGN (0x%" IMG_UINT64_FMTSPECX ")",
+		         psHeapInfo->uiHeapLength,
+		         uiAlignment + 1));
+	}
+}
+
 /* Generic counting method. */
 static void _CountRequiredHeaps(PVRSRV_RGXDEV_INFO  *psDevInfo,
 	                            const RGX_HEAP_INFO  pksHeapInfo[],
@@ -3943,19 +4225,60 @@ static void _CountRequiredHeaps(PVRSRV_RGXDEV_INFO  *psDevInfo,
 }
 /* Generic heap instantiator */
 static void _InstantiateRequiredHeaps(PVRSRV_RGXDEV_INFO     *psDevInfo,
-                                      const RGX_HEAP_INFO     pksHeapInfo[],
+                                      RGX_HEAP_INFO           psHeapInfos[],
                                       IMG_UINT32              ui32HeapListSize,
                                       const IMG_UINT32        ui32Log2RgxDefaultPageShift,
                                       DEVMEM_HEAP_BLUEPRINT **psDeviceMemoryHeapCursor)
 {
 	IMG_UINT32 i;
+
+#if defined DEBUG
+	IMG_UINT32 ui32heapListCnt;
+	bool bHeapPageSizeMisMatch = false;
+
+	/*
+	 * To ensure all heaps within a 2MB region have the same page sizes
+	 */
+	for (ui32heapListCnt = 0; ui32heapListCnt < (ui32HeapListSize-1); ui32heapListCnt++)
+	{
+		const RGX_HEAP_INFO *psHeapInfo1 = &psHeapInfos[ui32heapListCnt];
+		const RGX_HEAP_INFO *psHeapInfo2 = &psHeapInfos[ui32heapListCnt+1];
+
+		if (((psHeapInfo1->uiHeapLength) & (RGX_HEAP_BASE_SIZE_ALIGN - 1)) &&
+			((psHeapInfo1->ui64HeapBase + psHeapInfo1->uiHeapLength) & (RGX_HEAP_BASE_SIZE_ALIGN - 1)) ==
+			((psHeapInfo2->ui64HeapBase) & (RGX_HEAP_BASE_SIZE_ALIGN - 1)))
+		{
+			if (psHeapInfo1->ui32HeapInstanceFlags & HEAP_INST_NON4K_FLAG)
+			{
+				if (!(psHeapInfo2->ui32HeapInstanceFlags & HEAP_INST_NON4K_FLAG))
+				{
+					bHeapPageSizeMisMatch = true;
+				}
+			}
+			else if (psHeapInfo2->ui32HeapInstanceFlags & HEAP_INST_NON4K_FLAG)
+			{
+				bHeapPageSizeMisMatch = true;
+			}
+		}
+		if (bHeapPageSizeMisMatch)
+		{
+			PVR_ASSERT(!"Two Heap with Different Page Size allocated in the same PD space(2MB)");
+			PVR_DPF((PVR_DBG_ERROR,
+					"%s: Invalid Heaps 1) \"%s\" and 2) \"%s\"",
+					__func__,
+					psHeapInfo1->pszName,
+					psHeapInfo2->pszName));
+		}
+	}
+#endif
+
 	/* We now have a list of the heaps to include and so we should loop over this
 	 * list and instantiate.
 	 */
 	for (i = 0; i < ui32HeapListSize; i++)
 	{
 		IMG_UINT32 ui32Log2DataPageSize = 0;
-		const RGX_HEAP_INFO *psHeapInfo = &pksHeapInfo[i];
+		RGX_HEAP_INFO *psHeapInfo = &psHeapInfos[i];
 
 		if (psHeapInfo->pfnIsHeapPresent)
 		{
@@ -3966,6 +4289,11 @@ static void _InstantiateRequiredHeaps(PVRSRV_RGXDEV_INFO     *psDevInfo,
 			}
 		}
 
+		if (psHeapInfo->pfnDynamicBaseSize != NULL)
+		{
+			psHeapInfo->pfnDynamicBaseSize(psDevInfo->psDeviceNode, psHeapInfo);
+		}
+
 		if (psHeapInfo->ui32HeapInstanceFlags & HEAP_INST_NON4K_FLAG)
 		{
 			ui32Log2DataPageSize = psDevInfo->psDeviceNode->ui32Non4KPageSizeLog2;
@@ -3975,6 +4303,8 @@ static void _InstantiateRequiredHeaps(PVRSRV_RGXDEV_INFO     *psDevInfo,
 			ui32Log2DataPageSize = ui32Log2RgxDefaultPageShift;
 		}
 
+		CheckHeapAlignment(psHeapInfo, psDevInfo);
+
 		HeapCfgBlueprintInit(psHeapInfo->pszName,
 		                     psHeapInfo->ui64HeapBase,
 		                     psHeapInfo->uiHeapLength,
@@ -4088,13 +4418,52 @@ static PVRSRV_ERROR RGXInitHeaps(PVRSRV_RGXDEV_INFO *psDevInfo,
 	psNewMemoryInfo->psDeviceMemoryHeapConfigArray[1].uiNumHeaps = RGX_FIRMWARE_NUMBER_OF_FW_HEAPS;
 	psNewMemoryInfo->psDeviceMemoryHeapConfigArray[1].psHeapBlueprintArray = psDeviceMemoryHeapCursor - RGX_FIRMWARE_NUMBER_OF_FW_HEAPS;
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	if (RGX_GET_FEATURE_VALUE(psDevInfo, MMU_VERSION) >= 4)
+	{
+		IMG_UINT32 i;
+		const IMG_UINT32 ui32GeneralNon4KHeapPageSize = (1 << psDevInfo->psDeviceNode->ui32Non4KPageSizeLog2);
+		const IMG_UINT32 ui32RgxDefaultPageSize = (1 << RGXHeapDerivePageSize(OSGetPageShift()));
+
+		/*
+		 * Initialise all MMU Page Size Range Config register to the default page size
+		 * used by the OS, leaving the address range 0;
+		 */
+		for (i = 0; i < ARRAY_SIZE(psDevInfo->aui64MMUPageSizeRangeValue); ++i)
+		{
+			psDevInfo->aui64MMUPageSizeRangeValue[i] =
+					RGXMMUInit_GetConfigRangeValue(ui32RgxDefaultPageSize,
+												   0,
+												   (1 << RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_END_ADDR_ALIGNSHIFT));
+		}
+
+
+		/* set the last MMU config range covering the entire virtual memory to the OS's page size */
+		psDevInfo->aui64MMUPageSizeRangeValue[RGX_MAX_NUM_MMU_PAGE_SIZE_RANGES - 1] =
+				RGXMMUInit_GetConfigRangeValue(ui32RgxDefaultPageSize, 0, (1ULL << 40));
+
+		/*
+		 * If the Non4K heap has a different page size than the OS's page size
+		 * (used as default for all other heaps), configure one MMU config range
+		 * for the Non4K heap
+		 */
+		if (ui32GeneralNon4KHeapPageSize != ui32RgxDefaultPageSize)
+		{
+			psDevInfo->aui64MMUPageSizeRangeValue[0] =
+					RGXMMUInit_GetConfigRangeValue(ui32GeneralNon4KHeapPageSize,
+												   RGX_GENERAL_NON4K_HEAP_BASE,
+												   RGX_GENERAL_NON4K_HEAP_SIZE);
+		}
+	}
+#endif
+
 #if defined(RGX_PREMAP_FW_HEAPS) || (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		IMG_UINT32 ui32DriverID;
 
 		/* Create additional raw firmware heaps */
-		FOREACH_DRIVER_RAW_HEAP(ui32DriverID)
+		FOREACH_DRIVER_RAW_HEAP(ui32DriverID, DEVINFO, psDevInfo)
 		{
 			eError = RGXInitFwRawHeap(psDevInfo, psDeviceMemoryHeapCursor, ui32DriverID);
 			if (eError != PVRSRV_OK)
@@ -4124,21 +4493,23 @@ static PVRSRV_ERROR RGXInitHeaps(PVRSRV_RGXDEV_INFO *psDevInfo,
 	return eError;
 }
 
-static void RGXDeInitHeaps(DEVICE_MEMORY_INFO *psDevMemoryInfo)
+static void RGXDeInitHeaps(DEVICE_MEMORY_INFO *psDevMemoryInfo, PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 #if defined(RGX_PREMAP_FW_HEAPS) || (RGX_NUM_DRIVERS_SUPPORTED > 1)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		IMG_UINT32 ui32DriverID;
 		DEVMEM_HEAP_BLUEPRINT *psDeviceMemoryHeapCursor = psDevMemoryInfo->psDeviceMemoryHeap;
 
 		/* Delete all guest firmware heaps */
-		FOREACH_DRIVER_RAW_HEAP(ui32DriverID)
+		FOREACH_DRIVER_RAW_HEAP(ui32DriverID, DEVNODE, psDeviceNode)
 		{
 			RGXDeInitFwRawHeap(psDeviceMemoryHeapCursor);
 			psDeviceMemoryHeapCursor++;
 		}
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 #endif /* defined(RGX_PREMAP_FW_HEAPS) || (RGX_NUM_DRIVERS_SUPPORTED > 1) */
 
 	OSFreeMem(psDevMemoryInfo->psDeviceMemoryHeapConfigArray);
@@ -4148,13 +4519,12 @@ static void RGXDeInitHeaps(DEVICE_MEMORY_INFO *psDevMemoryInfo)
 static PVRSRV_ERROR RGXInitSharedFwPhysHeaps(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO *)psDeviceNode->pvDevice;
 	PHYS_HEAP_CONFIG *psSysHeapCfg = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig,
 																PHYS_HEAP_USAGE_FW_SHARED);
 
 #if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
 	/* VZ heap validation */
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		PVR_LOG_RETURN_IF_FALSE(psSysHeapCfg != NULL,
 								"FW Main heap is required for VZ Guest.",
@@ -4197,42 +4567,51 @@ static PVRSRV_ERROR RGXInitSharedFwPhysHeaps(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 		/* Subheap layout: Main + (optional MIPS reserved range) + Config */
 		sFwMainHeapCfg = *psSysHeapCfg;
+		PVR_ASSERT(sFwMainHeapCfg.eType == PHYS_HEAP_TYPE_LMA ||
+		           sFwMainHeapCfg.eType == PHYS_HEAP_TYPE_DMA);
 
 		/* Reserve space for the Config heap */
-		sFwMainHeapCfg.uiSize -= RGX_FIRMWARE_CONFIG_HEAP_SIZE;
+		sFwMainHeapCfg.uConfig.sLMA.uiSize -= RGX_FIRMWARE_CONFIG_HEAP_SIZE;
 
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
-		/* MIPS Firmware must reserve some space in its Host/Native heap for GPU memory mappings */
-		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) && (!PVRSRV_VZ_MODE_IS(GUEST)))
 		{
-#if defined(FIX_HW_BRN_65101_BIT_MASK)
-			if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65101))
+			PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO *)psDeviceNode->pvDevice;
+
+			/* MIPS Firmware must reserve some space in its Host/Native heap for GPU memory mappings */
+			if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) && (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)))
 			{
-				sFwMainHeapCfg.uiSize -= RGX_FIRMWARE_MIPS_GPU_MAP_RESERVED_SIZE_BRN65101;
-			}
-			else
+#if defined(FIX_HW_BRN_65101_BIT_MASK)
+				if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65101))
+				{
+					sFwMainHeapCfg.uConfig.sLMA.uiSize -= RGX_FIRMWARE_MIPS_GPU_MAP_RESERVED_SIZE_BRN65101;
+				}
+				else
 #endif
-			{
-				sFwMainHeapCfg.uiSize -= RGX_FIRMWARE_MIPS_GPU_MAP_RESERVED_SIZE_NORMAL;
+				{
+					sFwMainHeapCfg.uConfig.sLMA.uiSize -= RGX_FIRMWARE_MIPS_GPU_MAP_RESERVED_SIZE_NORMAL;
+				}
 			}
 		}
 #endif
 
 		eError = PhysmemCreateHeapLMA(psDeviceNode,
-		                              RGXPhysHeapGetLMAPolicy(sFwMainHeapCfg.ui32UsageFlags),
+		                              RGXPhysHeapGetLMAPolicy(sFwMainHeapCfg.ui32UsageFlags, psDeviceNode),
 		                              &sFwMainHeapCfg,
 		                              "Fw Main subheap",
 		                              &psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_MAIN]);
 		PVR_LOG_GOTO_IF_ERROR(eError, "PhysmemCreateHeapLMA:MAIN", ErrorDeinit);
 
 		sFwCfgHeapCfg = *psSysHeapCfg;
-		sFwCfgHeapCfg.sStartAddr.uiAddr += psSysHeapCfg->uiSize - RGX_FIRMWARE_CONFIG_HEAP_SIZE;
-		sFwCfgHeapCfg.sCardBase.uiAddr += psSysHeapCfg->uiSize - RGX_FIRMWARE_CONFIG_HEAP_SIZE;
+		PVR_ASSERT(sFwCfgHeapCfg.eType == PHYS_HEAP_TYPE_LMA ||
+		           sFwCfgHeapCfg.eType == PHYS_HEAP_TYPE_DMA);
+
+		sFwCfgHeapCfg.uConfig.sLMA.sStartAddr.uiAddr += psSysHeapCfg->uConfig.sLMA.uiSize - RGX_FIRMWARE_CONFIG_HEAP_SIZE;
+		sFwCfgHeapCfg.uConfig.sLMA.sCardBase.uiAddr += psSysHeapCfg->uConfig.sLMA.uiSize - RGX_FIRMWARE_CONFIG_HEAP_SIZE;
 
-		sFwCfgHeapCfg.uiSize = RGX_FIRMWARE_CONFIG_HEAP_SIZE;
+		sFwCfgHeapCfg.uConfig.sLMA.uiSize = RGX_FIRMWARE_CONFIG_HEAP_SIZE;
 
 		eError = PhysmemCreateHeapLMA(psDeviceNode,
-		                              RGXPhysHeapGetLMAPolicy(sFwCfgHeapCfg.ui32UsageFlags),
+		                              RGXPhysHeapGetLMAPolicy(sFwCfgHeapCfg.ui32UsageFlags, psDeviceNode),
 		                              &sFwCfgHeapCfg,
 		                              "Fw Cfg subheap",
 		                              &psDeviceNode->apsPhysHeap[PVRSRV_PHYS_HEAP_FW_CONFIG]);
@@ -4346,34 +4725,38 @@ static PVRSRV_ERROR RGXInitPrivateFwPhysHeaps(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 #if defined(RGX_PREMAP_FW_HEAPS) && defined(SUPPORT_TRUSTED_DEVICE)
-		/* When premapping distinct private and shared Firmware phys heaps
-		 * inside the same virtual devmem heap, their sizes must add up to
-		 * the fixed RGX_FIRMWARE_RAW_HEAP_SIZE for the premapping to work */
-		{
-			PHYS_HEAP_CONFIG *psFwSharedHeapCfg = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig,
-																			PHYS_HEAP_USAGE_FW_SHARED);
-			IMG_UINT64 ui64FwPrivateHeapSize;
-
-			PVR_LOG_GOTO_IF_FALSE((psFwCodeHeapCfg != NULL) && (psFwDataHeapCfg != NULL),
-								  "Security support requires Fw code and data memory be"
-								  " separate from the heap shared with the kernel driver.", ErrorDeinit);
-
-			if (psFwCodeHeapCfg != psFwDataHeapCfg)
-			{
-				/* Private Firmware allocations come from 2 different heaps */
-				ui64FwPrivateHeapSize = psFwCodeHeapCfg->uiSize + psFwDataHeapCfg->uiSize;
-			}
-			else
-			{
-				/* Private Firmware allocations come from a single heap */
-				ui64FwPrivateHeapSize = psFwCodeHeapCfg->uiSize;
-			}
+	/* When premapping distinct private and shared Firmware phys heaps
+	 * inside the same virtual devmem heap, their sizes must add up to
+	 * the fixed RGX_FIRMWARE_RAW_HEAP_SIZE for the premapping to work */
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+	{
+		PHYS_HEAP_CONFIG *psFwSharedHeapCfg = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig,
+																		PHYS_HEAP_USAGE_FW_SHARED);
+		IMG_UINT64 ui64FwCodeHeapSize = PhysHeapConfigGetSize(psFwCodeHeapCfg);
+		IMG_UINT64 ui64FwDataHeapSize = PhysHeapConfigGetSize(psFwDataHeapCfg);
+		IMG_UINT64 ui64FwSharedHeapSize = PhysHeapConfigGetSize(psFwSharedHeapCfg);
+		IMG_UINT64 ui64FwPrivateHeapSize;
+
+		PVR_LOG_GOTO_IF_FALSE((psFwCodeHeapCfg != NULL) && (psFwDataHeapCfg != NULL),
+							  "Security support requires Fw code and data memory be"
+							  " separate from the heap shared with the kernel driver.", FailDeinit);
 
-			PVR_LOG_GOTO_IF_FALSE((psFwSharedHeapCfg->uiSize +
-								   ui64FwPrivateHeapSize) ==
-								  RGX_FIRMWARE_RAW_HEAP_SIZE,
-								  "Invalid firmware physical heap size.", ErrorDeinit);
+		if (psFwCodeHeapCfg != psFwDataHeapCfg)
+		{
+			/* Private Firmware allocations come from 2 different heaps */
+			ui64FwPrivateHeapSize = ui64FwCodeHeapSize + ui64FwDataHeapSize;
+		}
+		else
+		{
+			/* Private Firmware allocations come from a single heap */
+			ui64FwPrivateHeapSize = ui64FwCodeHeapSize;
 		}
+
+				PVR_LOG_GOTO_IF_FALSE((ui64FwSharedHeapSize +
+									   ui64FwPrivateHeapSize) ==
+									   RGX_FIRMWARE_RAW_HEAP_SIZE,
+									   "Invalid firmware physical heap size.", FailDeinit);
+	}
 #endif
 
 	eError = PhysHeapAcquireByID(PVRSRV_PHYS_HEAP_FW_CODE, psDeviceNode,
@@ -4386,6 +4769,10 @@ static PVRSRV_ERROR RGXInitPrivateFwPhysHeaps(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	return eError;
 
+#if defined(RGX_PREMAP_FW_HEAPS) && defined(SUPPORT_TRUSTED_DEVICE)
+FailDeinit:
+    eError = PVRSRV_ERROR_INVALID_PARAMS;
+#endif
 ErrorDeinit:
 	PVR_ASSERT(IMG_FALSE);
 
@@ -4397,7 +4784,7 @@ static PVRSRV_ERROR RGXInitFwPageTableHeap(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_ERROR eError = PVRSRV_OK;
 
 #if defined(RGX_PREMAP_FW_HEAPS)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		PHYS_HEAP_CONFIG *psFwPageTableHeapCfg = PVRSRVFindPhysHeapConfig(psDeviceNode->psDevConfig,
 																		  PHYS_HEAP_USAGE_FW_PREMAP_PT);
@@ -4416,7 +4803,7 @@ static PVRSRV_ERROR RGXInitFwPageTableHeap(PVRSRV_DEVICE_NODE *psDeviceNode)
 								"The Firmware Page Table heap must be LMA or DMA memory.",
 								PVRSRV_ERROR_PHYSHEAP_CONFIG);
 
-		PVR_LOG_RETURN_IF_FALSE((psFwPageTableHeapCfg->uiSize >= RGX_FIRMWARE_MAX_PAGETABLE_SIZE),
+		PVR_LOG_RETURN_IF_FALSE((psFwPageTableHeapCfg->uConfig.sLMA.uiSize >= RGX_FIRMWARE_MAX_PAGETABLE_SIZE),
 								"The Firmware Page Table heap must be able to hold the maximum "
 								"number of pagetables needed to cover the Firmware's VA space.",
 								PVRSRV_ERROR_PHYSHEAP_CONFIG);
@@ -4497,42 +4884,78 @@ static PVRSRV_ERROR RGXDeviceFWMainHeapMemCheck(PVRSRV_DEVICE_NODE *psDeviceNode
 	return eError;
 }
 
-static PVRSRV_ERROR _ReadNon4KHeapPageSize(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 *pui32Log2Non4KPgSize)
+PVRSRV_ERROR RGXGetNon4KHeapPageShift(const void *hPrivate, IMG_UINT32 *pui32Log2Non4KPgShift)
 {
-	void *pvAppHintState = NULL;
-	IMG_UINT32 ui32AppHintDefault = PVRSRV_APPHINT_GENERALNON4KHEAPPAGESIZE;
 	IMG_UINT32 ui32GeneralNon4KHeapPageSize;
-	IMG_UINT32 uiLog2OSPageSize = OSGetPageShift();
+	IMG_UINT32 uiLog2OSPageShift = OSGetPageShift();
 
-	/* Get the page size for the dummy page from the NON4K heap apphint */
-	OSCreateAppHintState(&pvAppHintState);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState,
-	                     GeneralNon4KHeapPageSize, &ui32AppHintDefault,
-	                     &ui32GeneralNon4KHeapPageSize);
-	*pui32Log2Non4KPgSize = ExactLog2(ui32GeneralNon4KHeapPageSize);
-	OSFreeAppHintState(pvAppHintState);
+	/* We support Non4K pages only on platforms with 4KB pages. On all platforms
+	 * where OS pages are larger than 4KB we must ensure the non4K device memory
+	 * heap matches the page size used in all other device memory heaps, which
+	 * is the OS page size, see RGXHeapDerivePageSize. */
+	if (uiLog2OSPageShift > RGX_HEAP_4KB_PAGE_SHIFT)
+	{
+		*pui32Log2Non4KPgShift = RGXHeapDerivePageSize(uiLog2OSPageShift);
+	}
+	else
+	{
+		void *pvAppHintState = NULL;
+		IMG_UINT32 ui32AppHintDefault = PVRSRV_APPHINT_GENERALNON4KHEAPPAGESIZE;
+		IMG_UINT32 ui32Log2Non4KPgShift;
+
+		/* Get the page size for the dummy page from the NON4K heap apphint */
+		OSCreateAppHintState(&pvAppHintState);
+		OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState,
+		                   GeneralNon4KHeapPageSize, &ui32AppHintDefault,
+		                   &ui32GeneralNon4KHeapPageSize);
+		OSFreeAppHintState(pvAppHintState);
+
+		/* Validate the specified parameter to be one of the supported values */
+		ui32Log2Non4KPgShift = RGXHeapDerivePageSize(ExactLog2(ui32GeneralNon4KHeapPageSize));
+		if (ui32AppHintDefault != ui32GeneralNon4KHeapPageSize)
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Invalid Non4K Page-size, default=%u, requested=%u,"
+			         " actual=%u, pageshift 0x%x",
+			         __func__, ui32AppHintDefault, ui32GeneralNon4KHeapPageSize,
+			         (1U << ui32Log2Non4KPgShift), ui32Log2Non4KPgShift));
+		}
+
+		if (ui32Log2Non4KPgShift == 0U)
+		{
+			return PVRSRV_ERROR_INVALID_NON4K_HEAP_PAGESIZE;
+		}
+
+		*pui32Log2Non4KPgShift = ui32Log2Non4KPgShift;
+	}
 
 #if defined(FIX_HW_BRN_71317_BIT_MASK)
-	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 71317))
+	if (RGX_DEVICE_HAS_BRN(hPrivate, 71317))
 	{
-		if (*pui32Log2Non4KPgSize == RGX_HEAP_2MB_PAGE_SHIFT
-		   || *pui32Log2Non4KPgSize == RGX_HEAP_1MB_PAGE_SHIFT)
+		if (*pui32Log2Non4KPgShift == RGX_HEAP_2MB_PAGE_SHIFT
+		   || *pui32Log2Non4KPgShift == RGX_HEAP_1MB_PAGE_SHIFT)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
 			         "Page sizes of 2MB or 1MB cause page faults."));
 			return PVRSRV_ERROR_INVALID_NON4K_HEAP_PAGESIZE;
 		}
 	}
+#else
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
 #endif
 
 	/* Check the Non4k page size is at least the size of the OS page size
 	 * or larger. The Non4k page size also has to be a multiple of the OS page
 	 * size but since we have the log2 value from the apphint we know powers of 2
-	 * will always be multiples.
+	 * will always be multiples. If the Non4k page size is less than OS page size
+	 * we notify and upgrade the size.
 	 */
-	PVR_LOG_RETURN_IF_FALSE(*pui32Log2Non4KPgSize >= uiLog2OSPageSize,
-	                        "Non4K page size smaller than OS page size",
-	                        PVRSRV_ERROR_INVALID_NON4K_HEAP_PAGESIZE);
+	if (*pui32Log2Non4KPgShift < uiLog2OSPageShift)
+	{
+		PVR_DPF((PVR_DBG_MESSAGE, "Non4K page size smaller than OS page size, upgrading to "
+		                          "match OS page size."));
+		*pui32Log2Non4KPgShift = uiLog2OSPageShift;
+	}
 
 	return PVRSRV_OK;
 }
@@ -4551,7 +4974,6 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	void *pvAppHintState = NULL;
 	IMG_UINT32 ui32AppHintDefault = HWPERF_HOST_TL_STREAM_SIZE_DEFAULT, ui32HWPerfHostBufSizeKB;
 
-	ui32AppHintDefault = PVRSRV_APPHINT_DRIVERMODE;
 	OSCreateAppHintState(&pvAppHintState);
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, HWPerfHostBufSizeInKB,
 	                     &ui32AppHintDefault, &ui32HWPerfHostBufSizeKB);
@@ -4580,10 +5002,16 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 	/* Callback for getting the MMU device attributes */
 	psDeviceNode->pfnGetMMUDeviceAttributes = RGXDevMMUAttributes;
+	psDeviceNode->pfnGetDeviceSnoopMode = RGXDevSnoopMode;
 	psDeviceNode->pfnMMUCacheInvalidate = RGXMMUCacheInvalidate;
 	psDeviceNode->pfnMMUCacheInvalidateKick = RGXMMUCacheInvalidateKick;
+#if defined(RGX_BRN71422_TARGET_HARDWARE_PHYSICAL_ADDR)
+	psDeviceNode->pfnMMUTopLevelPxWorkarounds = RGXMapBRN71422TargetPhysicalAddress;
+#else
 	psDeviceNode->pfnMMUTopLevelPxWorkarounds = NULL;
-/*  psDeviceNode->pfnMMUTweakProtFlags is set later on once BNVC features setup */
+#endif
+	/* pfnMMUTweakProtFlags is set later on once BVNC features are setup */
+	psDeviceNode->pfnMMUTweakProtFlags = NULL;
 
 	psDeviceNode->pfnInitDeviceCompatCheck	= &RGXDevInitCompatCheck;
 
@@ -4596,7 +5024,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	psDeviceNode->pfnFreeUFOBlock = RGXFreeUFOBlock;
 
 	/* Register callback for checking the device's health */
-	psDeviceNode->pfnUpdateHealthStatus = PVRSRV_VZ_MODE_IS(GUEST) ? NULL : RGXUpdateHealthStatus;
+	psDeviceNode->pfnUpdateHealthStatus = PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) ? NULL : RGXUpdateHealthStatus;
 
 #if defined(SUPPORT_AUTOVZ)
 	/* Register callback for updating the virtualization watchdog */
@@ -4656,6 +5084,10 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
+	/* initialise the layer parameters needed for early hw feature checks */
+	psDevInfo->sLayerParams.psDevInfo = psDevInfo;
+	psDevInfo->sLayerParams.psDevConfig = psDeviceNode->psDevConfig;
+
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	/* Default psTrampoline to point to null struct */
 	psDevInfo->psTrampoline = (RGX_MIPS_ADDRESS_TRAMPOLINE *)&sNullTrampoline;
@@ -4734,7 +5166,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		goto e7;
 	}
 
-	eError = OSLockCreate(&psDevInfo->sRegCongfig.hLock);
+	eError = OSLockCreate(&psDevInfo->sRegConfig.hLock);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to create register configuration lock", __func__));
@@ -4768,6 +5200,13 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		goto e12;
 	}
 
+	eError = OSLockCreate(&psDevInfo->hGpuUtilStatsLock);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to create GPU stats lock", __func__));
+		goto e13;
+	}
+
 	dllist_init(&psDevInfo->sMemoryContextList);
 
 	/* initialise ui32SLRHoldoffCounter */
@@ -4803,7 +5242,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		         "%s: Failed to create RGX register mapping",
 		         __func__));
 		eError = PVRSRV_ERROR_BAD_MAPPING;
-		goto e13;
+		goto e14;
 	}
 #endif /* !NO_HARDWARE */
 
@@ -4815,7 +5254,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 		PVR_DPF((PVR_DBG_ERROR,
 		         "%s: Unsupported HW device detected by driver",
 		         __func__));
-		goto e14;
+		goto e15;
 	}
 
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
@@ -4839,7 +5278,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 			PVR_DPF((PVR_DBG_ERROR,
 			         "PVRSRVRGXInitDevPart2KM: Failed to create RGX secure register mapping"));
 			eError = PVRSRV_ERROR_BAD_MAPPING;
-			goto e14;
+			goto e15;
 		}
 
 		/*
@@ -4863,50 +5302,26 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 			RGXMMUTweakProtFlags : NULL;
 #endif
 
-	eError = _ReadNon4KHeapPageSize(psDevInfo,
+	eError = RGXGetNon4KHeapPageShift(&psDevInfo->sLayerParams,
 	                                &psDeviceNode->ui32Non4KPageSizeLog2);
-	PVR_LOG_GOTO_IF_ERROR(eError, "_ReadNon4KHeapPageSize", e15);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXGetNon4KHeapPageSize", e16);
 
 	eError = RGXInitHeaps(psDevInfo, psDevMemoryInfo);
 	if (eError != PVRSRV_OK)
 	{
-		goto e15;
+		goto e16;
 	}
 
 	eError = RGXHWPerfInit(psDevInfo);
-	PVR_LOG_GOTO_IF_ERROR(eError, "RGXHWPerfInit", e15);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXHWPerfInit", e16);
 
 	eError = RGXHWPerfHostInit(psDeviceNode->pvDevice, ui32HWPerfHostBufSizeKB);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXHWPerfHostInit", ErrorDeInitHWPerfFw);
 
-#if defined(SUPPORT_VALIDATION)
-	/* This completion will be signaled by the ISR when processing
-	 * the answer CCB command carrying an RGX Register read value */
-	init_completion(&psDevInfo->sFwRegs.sRegComp);
-	psDevInfo->sFwRegs.ui64RegVal = 0;
-
-#if defined(SUPPORT_SOC_TIMER)
-	{
-		IMG_BOOL bAppHintDefault = IMG_FALSE;
-		IMG_BOOL bInitSocTimer;
-		void *pvAppHintState = NULL;
-
-		OSCreateAppHintState(&pvAppHintState);
-		OSGetAppHintBOOL(APPHINT_NO_DEVICE, pvAppHintState, ValidateSOCUSCTimer, &bAppHintDefault, &bInitSocTimer);
-		OSFreeAppHintState(pvAppHintState);
-
-		if (bInitSocTimer)
-		{
-			eError = RGXInitSOCUSCTimer(psDeviceNode);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXInitSOCUSCTimer", ErrorDeInitHWPerfHost);
-		}
-	}
-#endif
-#endif
 
 	/* Register callback for dumping debug info */
 	eError = RGXDebugInit(psDevInfo);
-	PVR_LOG_GOTO_IF_ERROR(eError, "RGXDebugInit", ErrorDeInitHWPerfHost);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXDebugInit", e17);
 
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	/* Register callback for fw mmu init */
@@ -4916,30 +5331,15 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 #endif
 
-	/* The device shared-virtual-memory heap address-space size is stored here for faster
-	   look-up without having to walk the device heap configuration structures during
-	   client device connection  (i.e. this size is relative to a zero-based offset) */
-#if defined(FIX_HW_BRN_65273_BIT_MASK)
-	if (RGX_IS_BRN_SUPPORTED(psDevInfo, 65273))
-	{
-		psDeviceNode->ui64GeneralSVMHeapTopVA = 0;
-	}else
-#endif
-	{
-		psDeviceNode->ui64GeneralSVMHeapTopVA = RGX_GENERAL_SVM_HEAP_BASE + RGX_GENERAL_SVM_HEAP_SIZE;
-	}
-
 	if (NULL != psDeviceNode->psDevConfig->pfnSysDevFeatureDepInit)
 	{
 		psDeviceNode->psDevConfig->pfnSysDevFeatureDepInit(psDeviceNode->psDevConfig,
 				psDevInfo->sDevFeatureCfg.ui64Features);
 	}
 
-	psDeviceNode->bHasSystemDMA = psDeviceNode->psDevConfig->bHasDma;
-
 	/* Initialise the device dependent bridges */
-	eError = DeviceDepBridgeInit(psDevInfo);
-	PVR_LOG_IF_ERROR(eError, "DeviceDepBridgeInit");
+	eError = RGXRegisterBridges(psDevInfo);
+	PVR_LOG_IF_ERROR(eError, "RGXRegisterBridges");
 
 #if defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS)
 	eError = OSLockCreate(&psDevInfo->hCounterDumpingLock);
@@ -4957,14 +5357,14 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 #if defined(SUPPORT_POWER_SAMPLING_VIA_DEBUGFS)
 ErrorDeInitDeviceDepBridge:
-	DeviceDepBridgeDeInit(psDevInfo);
+	RGXUnregisterBridges(psDevInfo);
 #endif
 
-ErrorDeInitHWPerfHost:
+e17:
 	RGXHWPerfHostDeInit(psDevInfo);
 ErrorDeInitHWPerfFw:
 	RGXHWPerfDeinit(psDevInfo);
-e15:
+e16:
 #if !defined(NO_HARDWARE)
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 	if (psDevInfo->pvSecureRegsBaseKM != NULL)
@@ -4981,15 +5381,17 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 #endif
 #endif /* !NO_HARDWARE */
-e14:
+e15:
 #if !defined(NO_HARDWARE)
 	if (psDevInfo->pvRegsBaseKM != NULL)
 	{
 		OSUnMapPhysToLin((void __force *) psDevInfo->pvRegsBaseKM,
 		                 psDevInfo->ui32RegSize);
 	}
-e13:
+e14:
 #endif /* !NO_HARDWARE */
+	OSLockDestroy(psDevInfo->hGpuUtilStatsLock);
+e13:
 	OSLockDestroy(psDevInfo->hCCBRecoveryLock);
 e12:
 	OSLockDestroy(psDevInfo->hCCBStallCheckLock);
@@ -4998,7 +5400,7 @@ PVRSRV_ERROR RGXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode)
 e10:
 	OSLockDestroy(psDevInfo->hBPLock);
 e9:
-	OSLockDestroy(psDevInfo->sRegCongfig.hLock);
+	OSLockDestroy(psDevInfo->sRegConfig.hLock);
 e8:
 	OSWRLockDestroy(psDevInfo->hCommonCtxtListLock);
 e7:
diff --git a/drivers/gpu/drm/img-rogue/rgxinit.h b/drivers/gpu/drm/img-rogue/rgxinit.h
index 6878aee7f075..807f6a0b6fce 100644
--- a/drivers/gpu/drm/img-rogue/rgxinit.h
+++ b/drivers/gpu/drm/img-rogue/rgxinit.h
@@ -51,6 +51,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxdevice.h"
 #include "rgx_bridge.h"
 #include "fwload.h"
+#include "rgxinit_apphints.h"
 
 #if defined(__linux__)
 #define OS_FW_VERIFY_FUNCTION OSVerifyFirmware
@@ -73,10 +74,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 ******************************************************************************/
 PVRSRV_ERROR RGXInitDevPart2 (PVRSRV_DEVICE_NODE	*psDeviceNode,
-							  IMG_UINT32			ui32DeviceFlags,
-							  IMG_UINT32			ui32HWPerfHostFilter,
-							  RGX_ACTIVEPM_CONF		eActivePMConf,
-							  RGX_FWT_LOGTYPE		eDebugDumpFWTLogType);
+							  RGX_INIT_APPHINTS		*psApphints);
 
 PVRSRV_ERROR RGXInitAllocFWImgMem(PVRSRV_DEVICE_NODE   *psDeviceNode,
                                   IMG_DEVMEM_SIZE_T    ui32FWCodeLen,
@@ -101,20 +99,8 @@ PVRSRV_ERROR RGXInitAllocFWImgMem(PVRSRV_DEVICE_NODE   *psDeviceNode,
 ******************************************************************************/
 PVRSRV_ERROR
 RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
-                IMG_BOOL                 bEnableSignatureChecks,
-                IMG_UINT32               ui32SignatureChecksBufSize,
-                IMG_UINT32               ui32HWPerfFWBufSizeKB,
-                IMG_UINT64               ui64HWPerfFilter,
+                RGX_INIT_APPHINTS        *psApphints,
                 IMG_UINT32               ui32ConfigFlags,
-                IMG_UINT32               ui32LogType,
-                IMG_UINT32               ui32FilterFlags,
-                IMG_UINT32               ui32JonesDisableMask,
-                IMG_UINT32               ui32HWRDebugDumpLimit,
-                IMG_UINT32               ui32HWPerfCountersDataSize,
-                IMG_UINT32               *pui32TPUTrilinearFracMask,
-                RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandingConf,
-                FW_PERF_CONF             eFirmwarePerf,
-                IMG_UINT32               ui32KCCBSizeLog2,
                 IMG_UINT32               ui32ConfigFlagsExt,
                 IMG_UINT32               ui32FwOsCfgFlags);
 
@@ -132,8 +118,6 @@ RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
  @Input ppsRGXFW - fw pointer
 
- @Output ppbFWData - pointer to FW data (NULL if an error occurred)
-
  @Return PVRSRV_ERROR - PVRSRV_OK on success
                         PVRSRV_ERROR_NOT_READY if filesystem is not ready
                         PVRSRV_ERROR_NOT_FOUND if no suitable FW image found
@@ -142,8 +126,7 @@ RGXInitFirmware(PVRSRV_DEVICE_NODE       *psDeviceNode,
 
 ******************************************************************************/
 PVRSRV_ERROR RGXLoadAndGetFWData(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                 OS_FW_IMAGE **ppsRGXFW,
-                                 const IMG_BYTE **ppbFWData);
+                                 OS_FW_IMAGE **ppsRGXFW);
 
 #if defined(PDUMP)
 /*!
@@ -255,6 +238,28 @@ PVRSRV_ERROR SORgxGpuUtilStatsRegister(IMG_HANDLE *phGpuUtilUser);
 PVRSRV_ERROR SORgxGpuUtilStatsUnregister(IMG_HANDLE hGpuUtilUser);
 #endif /* !defined(NO_HARDWARE) */
 
+#if defined(RGX_FEATURE_AXI_ACE_BIT_MASK)
+/*!
+************************************************************************************
+ @Function		RGXSystemGetFabricCoherency
+
+ @Description	Get the system fabric coherency for the device by reading default
+				configuration from device register, subject to AppHint overrides.
+
+ @Input			sRegsCpuPBase		: Device register CPU physical address base
+				ui32RegsSize		: Device register size
+				peDevFabricType		: Device memory bus fabric type
+				peCacheSnoopingMode : Fabric coherency override
+
+ @Return		PVRSRV_ERROR
+************************************************************************************/
+PVRSRV_ERROR RGXSystemGetFabricCoherency(PVRSRV_DEVICE_CONFIG *psDeviceConfig,
+										 IMG_CPU_PHYADDR sRegsCpuPBase,
+										 IMG_UINT32 ui32RegsSize,
+										 PVRSRV_DEVICE_FABRIC_TYPE *peDevFabricType,
+										 PVRSRV_DEVICE_SNOOP_MODE *peCacheSnoopingMode);
+#endif
+
 /*!
  *******************************************************************************
 
@@ -279,4 +284,30 @@ PVRSRV_ERROR RGXInitCreateFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode
  ******************************************************************************/
 void RGXDeInitDestroyFWKernelMemoryContext(PVRSRV_DEVICE_NODE *psDeviceNode);
 
+/*!
+ *******************************************************************************
+
+ @Function      RGXHeapDerivePageSize
+
+ @Description   Ensure the desire page size is suitable for the RGX hardware
+
+ @Input         uiLog2PageSize target page log2 size
+
+ @Return        IMG_UINT32 valid page log2 size
+ ******************************************************************************/
+IMG_UINT32 RGXHeapDerivePageSize(IMG_UINT32 uiLog2PageSize);
+
+/*!
+ *******************************************************************************
+
+ @Function      RGXGetNon4KHeapPageShift
+
+ @Description   Retrieves the log2 page size of the General non 4k heap
+
+ @Output        pui32Log2Non4KPgShift page shift
+ ******************************************************************************/
+PVRSRV_ERROR RGXGetNon4KHeapPageShift(const void *hPrivate,
+                                     IMG_UINT32 *pui32Log2Non4KPgShift);
+
+
 #endif /* RGXINIT_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxinit_apphints.h b/drivers/gpu/drm/img-rogue/rgxinit_apphints.h
new file mode 100644
index 000000000000..99cecc630b5c
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/rgxinit_apphints.h
@@ -0,0 +1,120 @@
+/*************************************************************************/ /*!
+@File
+@Title          Services device initialisation settings
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Device initialisation settings
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#if !defined(RGXINIT_APPHINTS_H)
+#define RGXINIT_APPHINTS_H
+
+#include "img_defs.h"
+
+#include "rgx_fwif_km.h"
+#include "rgxdefs_km.h"
+#include "rgxdevice.h"
+
+/*
+ * Container for all the apphints used by this module
+ */
+typedef struct _RGX_INIT_APPHINTS_
+{
+	IMG_BOOL   bEnableSignatureChecks;
+	IMG_UINT32 ui32SignatureChecksBufSize;
+
+	IMG_BOOL   bAssertOnOutOfMem;
+	IMG_BOOL   bAssertOnHWRTrigger;
+#if defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX)
+	IMG_UINT32 ui32TFBCVersion;
+	IMG_UINT32 ui32TFBCCompressionControlGroup;
+	IMG_UINT32 ui32TFBCCompressionControlScheme;
+	IMG_BOOL   bTFBCCompressionControlYUVFormat;
+	IMG_BOOL   bTFBCCompressionControlLossyMinChannel;
+#endif
+	IMG_BOOL   bCheckMlist;
+	IMG_BOOL   bDisableClockGating;
+	IMG_BOOL   bDisableDMOverlap;
+	IMG_BOOL   bDisablePDP;
+	IMG_BOOL   bEnableDMKillRand;
+	IMG_BOOL   bEnableRandomCsw;
+	IMG_BOOL   bEnableSoftResetCsw;
+	IMG_BOOL   bHWPerfDisableCounterFilter;
+	IMG_UINT32 ui32DeviceFlags;
+	IMG_UINT32 ui32FilterFlags;
+	IMG_UINT32 ui32EnableFWContextSwitch;
+	IMG_UINT32 ui32FWContextSwitchProfile;
+	IMG_UINT32 ui32HWPerfFWBufSize;
+	IMG_UINT32 ui32HWPerfHostBufSize;
+	IMG_UINT32 ui32HWPerfFilter0;
+	IMG_UINT32 ui32HWPerfFilter1;
+	IMG_UINT32 ui32HWPerfHostFilter;
+	IMG_UINT32 ui32TimeCorrClock;
+	IMG_UINT32 ui32HWRDebugDumpLimit;
+	IMG_UINT32 ui32LogType;
+	IMG_UINT32 ui32KCCBSizeLog2;
+#if defined(PVR_ARCH_VOLCANIC)
+	IMG_UINT32 ui32ISPSchedulingLatencyMode;
+#endif
+	FW_PERF_CONF eFirmwarePerf;
+	RGX_ACTIVEPM_CONF eRGXActivePMConf;
+	RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandConf;
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	IMG_UINT32 ui32AvailablePowUnitsMask;
+	IMG_UINT32 ui32AvailableRACMask;
+	IMG_BOOL bSPUClockGating;
+#endif
+	IMG_BOOL   bEnableTrustedDeviceAceConfig;
+	IMG_UINT32 ui32FWContextSwitchCrossDM;
+#if defined(SUPPORT_PHYSMEM_TEST) && !defined(INTEGRITY_OS) && !defined(__QNXNTO__)
+	IMG_UINT32 ui32PhysMemTestPasses;
+#endif
+	RGX_FWT_LOGTYPE eDebugDumpFWTLogType;
+#if defined(SUPPORT_ICS)
+	IMG_UINT32 ui32EnableIdleCycleStealing;
+	IMG_UINT32 ui32FDTI;
+	IMG_UINT32 ui32ICSThreshold;
+	IMG_BOOL   bTestModeOn;
+#endif
+} RGX_INIT_APPHINTS;
+
+#endif /* RGXINIT_APPHINTS_H */
+
+/******************************************************************************
+ End of file (rgxinit_apphints.h)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/rgxkicksync.c b/drivers/gpu/drm/img-rogue/rgxkicksync.c
index 2028c5463a3d..6ab8942d84a8 100644
--- a/drivers/gpu/drm/img-rogue/rgxkicksync.c
+++ b/drivers/gpu/drm/img-rogue/rgxkicksync.c
@@ -167,16 +167,9 @@ PVRSRV_ERROR PVRSRVRGXDestroyKickSyncContextKM(RGX_SERVER_KICKSYNC_CONTEXT * psK
 	                                          RGXFWIF_DM_GP,
 	                                          PDUMP_FLAGS_NONE);
 
-	if (RGXIsErrorAndDeviceRecoverable(psKickSyncContext->psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psKickSyncContext->psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 	/* ... it has so we can free its resources */
 
@@ -336,7 +329,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 		pauiClientUpdateUFOAddress = psKickSyncContext->sSyncAddrListUpdate.pasFWAddrs;
 	}
 	/* Ensure the string is null-terminated (Required for safety) */
-	szUpdateFenceName[31] = '\0';
+	szUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH-1] = '\0';
 
 	/* This will never be true if called from the bridge since piUpdateFence will always be valid */
 	if (iUpdateTimeline >= 0 && !piUpdateFence)
@@ -621,7 +614,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 	eError = RGXCmdHelperAcquireCmdCCB(ARRAY_SIZE(asCmdHelperData), asCmdHelperData);
 	if (eError != PVRSRV_OK)
 	{
-		goto fail_cmdaquire;
+		goto fail_cmdacquire;
 	}
 
 	/*
@@ -682,7 +675,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 	                  NO_DEADLINE,
 	                  NO_CYCEST);
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError2 = RGXScheduleCommandWithoutPowerLock(psKickSyncContext->psDeviceNode->pvDevice,
 		                             RGXFWIF_DM_GP,
@@ -693,7 +686,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
 
@@ -716,7 +709,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 	 */
 	if (eError != PVRSRV_OK )
 	{
-		goto fail_cmdaquire;
+		goto fail_cmdacquire;
 	}
 
 #if defined(NO_HARDWARE)
@@ -768,7 +761,7 @@ PVRSRV_ERROR PVRSRVRGXKickSyncKM(RGX_SERVER_KICKSYNC_CONTEXT * psKickSyncContext
 	return PVRSRV_OK;
 
 fail_acquirepowerlock:
-fail_cmdaquire:
+fail_cmdacquire:
 	SyncAddrListRollbackCheckpoints(psKickSyncContext->psDeviceNode, &psKickSyncContext->sSyncAddrListFence);
 	SyncAddrListRollbackCheckpoints(psKickSyncContext->psDeviceNode, &psKickSyncContext->sSyncAddrListUpdate);
 	if (iUpdateFence != PVRSRV_NO_FENCE)
diff --git a/drivers/gpu/drm/img-rogue/rgxlayer.h b/drivers/gpu/drm/img-rogue/rgxlayer.h
index 6b4667e43b44..3141db5c4488 100644
--- a/drivers/gpu/drm/img-rogue/rgxlayer.h
+++ b/drivers/gpu/drm/img-rogue/rgxlayer.h
@@ -64,10 +64,10 @@ extern "C" {
 #include "img_types.h"
 #include "img_elf.h"
 #include "pvrsrv_error.h" /* includes pvrsrv_errors.h */
-#include "pvrsrv_firmware_boot.h"
+#include "rgx_firmware_boot.h"
 #include "rgx_bvnc_defs_km.h"
 #include "rgx_fw_info.h"
-#include "rgx_fwif_shared.h" /* includes rgx_common.h and mem_types.h */
+#include "rgx_common.h"
 #include "rgx_meta.h"
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
 #include "rgx_mips.h"
@@ -81,6 +81,14 @@ extern "C" {
  * RGX_BNC_CONFIG_KM_HEADER (rgxconfig_km_B.V.N.C.h)
  */
 
+/*
+ * Specific fields for RGX_CR_IDLE must not be polled in pdumps
+ * (technical reasons)
+ */
+#define CR_IDLE_UNSELECTED_MASK ((~RGX_CR_SLC_IDLE_ACE_CONVERTERS_CLRMSK) |	\
+								 (~RGX_CR_SLC_IDLE_OWDB_CLRMSK) |			\
+								 (RGX_CR_SLC_IDLE_FBCDC_ARB_EN))
+
 
 /*!
 *******************************************************************************
@@ -160,6 +168,7 @@ void RGXErrorLog(const void *hPrivate,
                  const IMG_CHAR *pszString,
                  ...);
 
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 /*!
 *******************************************************************************
 
@@ -174,8 +183,9 @@ void RGXErrorLog(const void *hPrivate,
 ******************************************************************************/
 
 IMG_UINT32 RGXGetOSPageSize(const void *hPrivate);
+#endif
 
-/* This is used to get the value of a specific feature from hprivate.
+/* This is used to check if a specific feature is enabled.
  * Should be used instead of calling RGXDeviceHasFeature.  */
 #define RGX_DEVICE_HAS_FEATURE(hPrivate, Feature) \
 			RGXDeviceHasFeature(hPrivate, RGX_FEATURE_##Feature##_BIT_MASK)
@@ -201,6 +211,8 @@ IMG_UINT32 RGXGetOSPageSize(const void *hPrivate);
 #define RGX_DEVICE_HAS_BRN(hPrivate, BRN) \
 			RGXDeviceHasErnBrn(hPrivate, FIX_HW_BRN_##BRN##_BIT_MASK)
 
+#define CLK_CTRL_FORCE_ON(X, Module) \
+			X = (((X) & RGX_CR_##Module##_CLRMSK) | RGX_CR_##Module##_ON)
 /*!
 *******************************************************************************
 
@@ -348,6 +360,44 @@ PVRSRV_ERROR RGXPollReg64(const void *hPrivate,
                           IMG_UINT64 ui64RegValue,
                           IMG_UINT64 ui64RegMask);
 
+/*!
+*******************************************************************************
+
+ @Function       RGXWriteMetaRegThroughSP
+
+ @Description    Write a register value using the META slave port
+
+ @Input          hPrivate         : Implementation specific data
+ @Input          ui32RegAddr      : Register offset inside the register bank
+ @Input          ui32RegValue     : Value written to the register
+
+ @Return         PVRSRV_OK if the poll succeeds,
+                 PVRSRV error code otherwise
+
+******************************************************************************/
+PVRSRV_ERROR RGXWriteMetaRegThroughSP(const void *hPrivate,
+                                      IMG_UINT32 ui32RegAddr,
+                                      IMG_UINT32 ui32RegValue);
+
+/*!
+*******************************************************************************
+
+ @Function       RGXReadMetaRegThroughSP
+
+ @Description    Read a register value using the META slave port
+
+ @Input          hPrivate         : Implementation specific data
+ @Input          ui32RegAddr      : Register offset inside the register bank
+ @Input          *ui32RegValue    : Value read from the register
+
+ @Return         PVRSRV_OK if the poll succeeds,
+                 PVRSRV error code otherwise
+
+******************************************************************************/
+PVRSRV_ERROR RGXReadMetaRegThroughSP(const void *hPrivate,
+                                     IMG_UINT32 ui32RegAddr,
+                                     IMG_UINT32* ui32RegValue);
+
 /*!
 *******************************************************************************
 
@@ -420,11 +470,13 @@ void RGXAcquireKernelMMUPC(const void *hPrivate, IMG_DEV_PHYADDR *psPCAddr);
 
 ******************************************************************************/
 #if defined(PDUMP)
+#if !defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 void RGXWriteKernelMMUPC64(const void *hPrivate,
                            IMG_UINT32 ui32PCReg,
                            IMG_UINT32 ui32PCRegAlignShift,
                            IMG_UINT32 ui32PCRegShift,
                            IMG_UINT64 ui64PCVal);
+#endif
 
 void RGXWriteKernelMMUPC32(const void *hPrivate,
                            IMG_UINT32 ui32PCReg,
@@ -433,8 +485,10 @@ void RGXWriteKernelMMUPC32(const void *hPrivate,
                            IMG_UINT32 ui32PCVal);
 #else /* defined(PDUMP) */
 
+#if !defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 #define RGXWriteKernelMMUPC64(priv, pcreg, alignshift, shift, pcval) \
 	RGXWriteReg64(priv, pcreg, pcval)
+#endif
 
 #define RGXWriteKernelMMUPC32(priv, pcreg, alignshift, shift, pcval) \
 	RGXWriteReg32(priv, pcreg, pcval)
@@ -843,6 +897,22 @@ void RGXAcquireBootDataAddr(const void *hPrivate, IMG_DEV_VIRTADDR *psBootDataAd
 ******************************************************************************/
 IMG_BOOL RGXDeviceAckIrq(const void *hPrivate);
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/*!
+*******************************************************************************
+
+@Function       RGXMMUInitRangeValue
+
+@Description    Returns the appropriate config value for each MMU range
+
+@Input          ui32MMURange   : Hardware MMU range to be initialised
+
+@Return         64-bit register value
+
+******************************************************************************/
+IMG_UINT64 RGXMMUInitRangeValue(IMG_UINT32 ui32MMURange);
+#endif
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/drivers/gpu/drm/img-rogue/rgxlayer_impl.c b/drivers/gpu/drm/img-rogue/rgxlayer_impl.c
index 406f7b580119..2141554bfdae 100644
--- a/drivers/gpu/drm/img-rogue/rgxlayer_impl.c
+++ b/drivers/gpu/drm/img-rogue/rgxlayer_impl.c
@@ -46,9 +46,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pdump_km.h"
 #include "rgxfwutils.h"
 #include "rgxfwimageutils.h"
-#include "devicemem.h"
 #include "cache_km.h"
-#include "pmr.h"
 
 #if defined(PDUMP)
 #if defined(__linux__)
@@ -64,715 +62,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #endif /* __linux__ */
 #endif
 
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-#define RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr) \
-	(((ui32RegAddr) < RGX_HOST_SECURE_REGBANK_OFFSET) ? \
-	 ((psDevInfo)->pvRegsBaseKM) : ((psDevInfo)->pvSecureRegsBaseKM))
-#else
-#define RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr) ((psDevInfo)->pvRegsBaseKM)
-#endif
-
-void RGXMemCopy(const void *hPrivate,
-                void *pvDst,
-                void *pvSrc,
-                size_t uiSize)
-{
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-	OSDeviceMemCopy(pvDst, pvSrc, uiSize);
-}
-
-void RGXMemSet(const void *hPrivate,
-               void *pvDst,
-               IMG_UINT8 ui8Value,
-               size_t uiSize)
-{
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-	OSDeviceMemSet(pvDst, ui8Value, uiSize);
-}
-
-void RGXCommentLog(const void *hPrivate,
-                   const IMG_CHAR *pszString,
-                   ...)
-{
-#if defined(PDUMP)
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	va_list argList;
-	va_start(argList, pszString);
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	PDumpCommentWithFlagsVA(psDevInfo->psDeviceNode, PDUMP_FLAGS_CONTINUOUS, pszString, argList);
-	va_end(argList);
-#else
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-	PVR_UNREFERENCED_PARAMETER(pszString);
-#endif
-}
-
-void RGXErrorLog(const void *hPrivate,
-                 const IMG_CHAR *pszString,
-                 ...)
-{
-	IMG_CHAR szBuffer[PVR_MAX_DEBUG_MESSAGE_LEN];
-	va_list argList;
-
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-
-	va_start(argList, pszString);
-	vsnprintf(szBuffer, sizeof(szBuffer), pszString, argList);
-	va_end(argList);
-
-	PVR_DPF((PVR_DBG_ERROR, "%s", szBuffer));
-}
-
-IMG_UINT32 RGXGetOSPageSize(const void *hPrivate)
-{
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-	return OSGetPageSize();
-}
-
-IMG_INT32 RGXDeviceGetFeatureValue(const void *hPrivate, IMG_UINT64 ui64Feature)
-{
-	IMG_INT32 i32Ret = -1;
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-
-	PVR_ASSERT(hPrivate != NULL);
-
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	psDeviceNode = psDevInfo->psDeviceNode;
-
-	if ((psDeviceNode->pfnGetDeviceFeatureValue))
-	{
-		i32Ret = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode, ui64Feature);
-	}
-
-	return i32Ret;
-}
-
-IMG_BOOL RGXDeviceHasFeature(const void *hPrivate, IMG_UINT64 ui64Feature)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	return (psDevInfo->sDevFeatureCfg.ui64Features & ui64Feature) != 0;
-}
-
-IMG_UINT32 RGXGetFWCorememSize(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT32 ui32CorememSize = 0;
-
-	PVR_ASSERT(hPrivate != NULL);
-
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META_COREMEM_SIZE))
-	{
-		ui32CorememSize = RGX_GET_FEATURE_VALUE(psDevInfo, META_COREMEM_SIZE);
-	}
-
-	return ui32CorememSize;
-}
-
-void RGXWriteReg32(const void *hPrivate, IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
-#endif
-	{
-		OSWriteHWReg32(pvRegsBase, ui32RegAddr, ui32RegValue);
-	}
-
-	PDUMPREG32(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	           ui32RegAddr, ui32RegValue, psParams->ui32PdumpFlags);
-}
-
-void RGXWriteReg64(const void *hPrivate, IMG_UINT32 ui32RegAddr, IMG_UINT64 ui64RegValue)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
-#endif
-	{
-		OSWriteHWReg64(pvRegsBase, ui32RegAddr, ui64RegValue);
-	}
-
-	PDUMPREG64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	           ui32RegAddr, ui64RegValue, psParams->ui32PdumpFlags);
-}
-
-IMG_UINT32 RGXReadReg32(const void *hPrivate, IMG_UINT32 ui32RegAddr)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-	IMG_UINT32 ui32RegValue;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW)
-	{
-		ui32RegValue = IMG_UINT32_MAX;
-	}
-	else
-#endif
-	{
-		ui32RegValue = OSReadHWReg32(pvRegsBase, ui32RegAddr);
-	}
-
-	PDUMPREGREAD32(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	               ui32RegAddr, psParams->ui32PdumpFlags);
-
-	return ui32RegValue;
-}
-
-IMG_UINT64 RGXReadReg64(const void *hPrivate, IMG_UINT32 ui32RegAddr)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-	IMG_UINT64 ui64RegValue;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW)
-	{
-		ui64RegValue = IMG_UINT64_MAX;
-	}
-	else
-#endif
-	{
-		ui64RegValue = OSReadHWReg64(pvRegsBase, ui32RegAddr);
-	}
-
-	PDUMPREGREAD64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	               ui32RegAddr, PDUMP_FLAGS_CONTINUOUS);
-
-	return ui64RegValue;
-}
-
-IMG_UINT32 RGXReadModifyWriteReg64(const void *hPrivate,
-                                   IMG_UINT32 ui32RegAddr,
-                                   IMG_UINT64 uiRegValueNew,
-                                   IMG_UINT64 uiRegKeepMask)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-#if defined(PDUMP)
-	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
-#endif
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-	/* only use the new values for bits we update according to the keep mask */
-	uiRegValueNew &= ~uiRegKeepMask;
-
-#if defined(PDUMP)
-
-	PDUMP_BLKSTART(ui32PDumpFlags);
-
-	/* Store register offset to temp PDump variable */
-	PDumpRegRead64ToInternalVar(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	                            ":SYSMEM:$1", ui32RegAddr, ui32PDumpFlags);
-
-	/* Keep the bits set in the mask */
-	PDumpWriteVarANDValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-	                        uiRegKeepMask, ui32PDumpFlags);
-
-	/* OR the new values */
-	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-	                       uiRegValueNew, ui32PDumpFlags);
-
-	/* Do the actual register write */
-	PDumpInternalVarToReg64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	                        ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
-
-	PDUMP_BLKEND(ui32PDumpFlags);
-
-	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
-#endif
-
-	{
-		IMG_UINT64 uiRegValue = OSReadHWReg64(pvRegsBase, ui32RegAddr);
-		uiRegValue &= uiRegKeepMask;
-		OSWriteHWReg64(pvRegsBase, ui32RegAddr, uiRegValue | uiRegValueNew);
-	}
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR RGXPollReg32(const void *hPrivate,
-                          IMG_UINT32 ui32RegAddr,
-                          IMG_UINT32 ui32RegValue,
-                          IMG_UINT32 ui32RegMask)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
-#endif
-	{
-		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
-		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr),
-		                         ui32RegValue,
-		                         ui32RegMask,
-		                         POLL_FLAG_LOG_ERROR,
-		                         NULL) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg32: Poll for Reg (0x%x) failed", ui32RegAddr));
-			return PVRSRV_ERROR_TIMEOUT;
-		}
-	}
-
-	PDUMPREGPOL(psDevInfo->psDeviceNode,
-	            RGX_PDUMPREG_NAME,
-	            ui32RegAddr,
-	            ui32RegValue,
-	            ui32RegMask,
-	            psParams->ui32PdumpFlags,
-	            PDUMP_POLL_OPERATOR_EQUAL);
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR RGXPollReg64(const void *hPrivate,
-                          IMG_UINT32 ui32RegAddr,
-                          IMG_UINT64 ui64RegValue,
-                          IMG_UINT64 ui64RegMask)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void __iomem *pvRegsBase;
-
-	/* Split lower and upper words */
-	IMG_UINT32 ui32UpperValue = (IMG_UINT32) (ui64RegValue >> 32);
-	IMG_UINT32 ui32LowerValue = (IMG_UINT32) (ui64RegValue);
-	IMG_UINT32 ui32UpperMask = (IMG_UINT32) (ui64RegMask >> 32);
-	IMG_UINT32 ui32LowerMask = (IMG_UINT32) (ui64RegMask);
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
-
-#if defined(PDUMP)
-	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
-#endif
-	{
-		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
-		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr + 4),
-		                         ui32UpperValue,
-		                         ui32UpperMask,
-		                         POLL_FLAG_LOG_ERROR,
-		                         NULL) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg64: Poll for upper part of Reg (0x%x) failed", ui32RegAddr));
-			return PVRSRV_ERROR_TIMEOUT;
-		}
-
-		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
-		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr),
-		                         ui32LowerValue,
-		                         ui32LowerMask,
-		                         POLL_FLAG_LOG_ERROR,
-		                         NULL) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg64: Poll for lower part of Reg (0x%x) failed", ui32RegAddr));
-			return PVRSRV_ERROR_TIMEOUT;
-		}
-	}
-
-	PDUMPREGPOL(psDevInfo->psDeviceNode,
-	            RGX_PDUMPREG_NAME,
-	            ui32RegAddr + 4,
-	            ui32UpperValue,
-	            ui32UpperMask,
-	            psParams->ui32PdumpFlags,
-	            PDUMP_POLL_OPERATOR_EQUAL);
-
-
-	PDUMPREGPOL(psDevInfo->psDeviceNode,
-	            RGX_PDUMPREG_NAME,
-	            ui32RegAddr,
-	            ui32LowerValue,
-	            ui32LowerMask,
-	            psParams->ui32PdumpFlags,
-	            PDUMP_POLL_OPERATOR_EQUAL);
-
-	return PVRSRV_OK;
-}
-
-void RGXSetPoweredState(const void *hPrivate, IMG_BOOL bPowered)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	psDevInfo->bRGXPowered = bPowered;
-}
-
-void RGXWaitCycles(const void *hPrivate, IMG_UINT32 ui32Cycles, IMG_UINT32 ui32TimeUs)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-	OSWaitus(ui32TimeUs);
-	PDUMPIDLWITHFLAGS(psDevInfo->psDeviceNode, ui32Cycles, PDUMP_FLAGS_CONTINUOUS);
-}
-
-void RGXAcquireKernelMMUPC(const void *hPrivate, IMG_DEV_PHYADDR *psPCAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psPCAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sPCAddr;
-}
-
-#if defined(PDUMP)
-void RGXWriteKernelMMUPC64(const void *hPrivate,
-		IMG_UINT32 ui32PCReg,
-		IMG_UINT32 ui32PCRegAlignShift,
-		IMG_UINT32 ui32PCRegShift,
-		IMG_UINT64 ui64PCVal)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* Write the cat-base address */
-	OSWriteHWReg64(psDevInfo->pvRegsBaseKM, ui32PCReg, ui64PCVal);
-
-	/* Pdump catbase address */
-	MMU_PDumpWritePageCatBase(psDevInfo->psKernelMMUCtx,
-			RGX_PDUMPREG_NAME,
-			ui32PCReg,
-			8,
-			ui32PCRegAlignShift,
-			ui32PCRegShift,
-			PDUMP_FLAGS_CONTINUOUS);
-}
-
-void RGXWriteKernelMMUPC32(const void *hPrivate,
-                           IMG_UINT32 ui32PCReg,
-                           IMG_UINT32 ui32PCRegAlignShift,
-                           IMG_UINT32 ui32PCRegShift,
-                           IMG_UINT32 ui32PCVal)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* Write the cat-base address */
-	OSWriteHWReg32(psDevInfo->pvRegsBaseKM, ui32PCReg, ui32PCVal);
-
-	/* Pdump catbase address */
-	MMU_PDumpWritePageCatBase(psDevInfo->psKernelMMUCtx,
-	                          RGX_PDUMPREG_NAME,
-	                          ui32PCReg,
-	                          4,
-	                          ui32PCRegAlignShift,
-	                          ui32PCRegShift,
-	                          PDUMP_FLAGS_CONTINUOUS);
-}
-#endif /* defined(PDUMP) */
-
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-void RGXAcquireGPURegsAddr(const void *hPrivate, IMG_DEV_PHYADDR *psGPURegsAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psGPURegsAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sGPURegAddr;
-}
-
-#if defined(PDUMP)
-void RGXMIPSWrapperConfig(const void *hPrivate,
-		IMG_UINT32 ui32RegAddr,
-		IMG_UINT64 ui64GPURegsAddr,
-		IMG_UINT32 ui32GPURegsAlign,
-		IMG_UINT32 ui32BootMode)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	OSWriteHWReg64(psDevInfo->pvRegsBaseKM,
-			ui32RegAddr,
-			(ui64GPURegsAddr >> ui32GPURegsAlign) | ui32BootMode);
-
-	PDUMP_BLKSTART(ui32PDumpFlags);
-
-	/* Store register offset to temp PDump variable */
-	PDumpRegLabelToInternalVar(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	                           ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
-
-	/* Align register transactions identifier */
-	PDumpWriteVarSHRValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-	                        ui32GPURegsAlign, ui32PDumpFlags);
-
-	/* Enable micromips instruction encoding */
-	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-	                       ui32BootMode, ui32PDumpFlags);
-
-	/* Do the actual register write */
-	PDumpInternalVarToReg64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
-	                        ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
-
-	PDUMP_BLKEND(ui32PDumpFlags);
-}
-#endif
-
-void RGXAcquireBootRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psBootRemapAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psBootRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sBootRemapAddr;
-}
-
-void RGXAcquireCodeRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psCodeRemapAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psCodeRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sCodeRemapAddr;
-}
-
-void RGXAcquireDataRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psDataRemapAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psDataRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sDataRemapAddr;
-}
-
-void RGXAcquireTrampolineRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psTrampolineRemapAddr)
-{
-	PVR_ASSERT(hPrivate != NULL);
-	*psTrampolineRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sTrampolineRemapAddr;
-}
-
-#if defined(PDUMP)
-static inline
-void RGXWriteRemapConfig2Reg(void __iomem *pvRegs,
-		PMR *psPMR,
-		IMG_DEVMEM_OFFSET_T uiLogicalOffset,
-		IMG_UINT32 ui32RegAddr,
-		IMG_UINT64 ui64PhyAddr,
-		IMG_UINT64 ui64PhyMask,
-		IMG_UINT64 ui64Settings)
-{
-	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
-	PVRSRV_DEVICE_NODE *psDevNode;
-
-	PVR_ASSERT(psPMR != NULL);
-	psDevNode = PMR_DeviceNode(psPMR);
-
-	OSWriteHWReg64(pvRegs, ui32RegAddr, (ui64PhyAddr & ui64PhyMask) | ui64Settings);
-
-	PDUMP_BLKSTART(ui32PDumpFlags);
-
-	/* Store memory offset to temp PDump variable */
-	PDumpMemLabelToInternalVar64(":SYSMEM:$1", psPMR,
-	                             uiLogicalOffset, ui32PDumpFlags);
-
-	/* Keep only the relevant bits of the output physical address */
-	PDumpWriteVarANDValueOp(psDevNode, ":SYSMEM:$1", ui64PhyMask, ui32PDumpFlags);
-
-	/* Extra settings for this remapped region */
-	PDumpWriteVarORValueOp(psDevNode, ":SYSMEM:$1", ui64Settings, ui32PDumpFlags);
-
-	/* Do the actual register write */
-	PDumpInternalVarToReg64(psDevNode, RGX_PDUMPREG_NAME, ui32RegAddr,
-	                        ":SYSMEM:$1", ui32PDumpFlags);
-
-	PDUMP_BLKEND(ui32PDumpFlags);
-}
-
-void RGXBootRemapConfig(const void *hPrivate,
-		IMG_UINT32 ui32Config1RegAddr,
-		IMG_UINT64 ui64Config1RegValue,
-		IMG_UINT32 ui32Config2RegAddr,
-		IMG_UINT64 ui64Config2PhyAddr,
-		IMG_UINT64 ui64Config2PhyMask,
-		IMG_UINT64 ui64Config2Settings)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT32 ui32BootRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_BOOT_CODE);
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* Write remap config1 register */
-	RGXWriteReg64(hPrivate,
-			ui32Config1RegAddr,
-			ui64Config1RegValue);
-
-	/* Write remap config2 register */
-	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
-			psDevInfo->psRGXFWCodeMemDesc->psImport->hPMR,
-			psDevInfo->psRGXFWCodeMemDesc->uiOffset + ui32BootRemapMemOffset,
-			ui32Config2RegAddr,
-			ui64Config2PhyAddr,
-			ui64Config2PhyMask,
-			ui64Config2Settings);
-}
-
-void RGXCodeRemapConfig(const void *hPrivate,
-		IMG_UINT32 ui32Config1RegAddr,
-		IMG_UINT64 ui64Config1RegValue,
-		IMG_UINT32 ui32Config2RegAddr,
-		IMG_UINT64 ui64Config2PhyAddr,
-		IMG_UINT64 ui64Config2PhyMask,
-		IMG_UINT64 ui64Config2Settings)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT32 ui32CodeRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_EXCEPTIONS_CODE);
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* Write remap config1 register */
-	RGXWriteReg64(hPrivate,
-			ui32Config1RegAddr,
-			ui64Config1RegValue);
-
-	/* Write remap config2 register */
-	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
-			psDevInfo->psRGXFWCodeMemDesc->psImport->hPMR,
-			psDevInfo->psRGXFWCodeMemDesc->uiOffset + ui32CodeRemapMemOffset,
-			ui32Config2RegAddr,
-			ui64Config2PhyAddr,
-			ui64Config2PhyMask,
-			ui64Config2Settings);
-}
-
-void RGXDataRemapConfig(const void *hPrivate,
-		IMG_UINT32 ui32Config1RegAddr,
-		IMG_UINT64 ui64Config1RegValue,
-		IMG_UINT32 ui32Config2RegAddr,
-		IMG_UINT64 ui64Config2PhyAddr,
-		IMG_UINT64 ui64Config2PhyMask,
-		IMG_UINT64 ui64Config2Settings)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT32 ui32DataRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_BOOT_DATA);
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* Write remap config1 register */
-	RGXWriteReg64(hPrivate,
-			ui32Config1RegAddr,
-			ui64Config1RegValue);
-
-	/* Write remap config2 register */
-	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
-			psDevInfo->psRGXFWDataMemDesc->psImport->hPMR,
-			psDevInfo->psRGXFWDataMemDesc->uiOffset + ui32DataRemapMemOffset,
-			ui32Config2RegAddr,
-			ui64Config2PhyAddr,
-			ui64Config2PhyMask,
-			ui64Config2Settings);
-}
-
-void RGXTrampolineRemapConfig(const void *hPrivate,
-		IMG_UINT32 ui32Config1RegAddr,
-		IMG_UINT64 ui64Config1RegValue,
-		IMG_UINT32 ui32Config2RegAddr,
-		IMG_UINT64 ui64Config2PhyAddr,
-		IMG_UINT64 ui64Config2PhyMask,
-		IMG_UINT64 ui64Config2Settings)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	/* write the register for real, without PDump */
-	OSWriteHWReg64(psDevInfo->pvRegsBaseKM,
-			ui32Config1RegAddr,
-			ui64Config1RegValue);
-
-	PDUMP_BLKSTART(ui32PDumpFlags);
-
-	/* Store the memory address in a PDump variable */
-	PDumpPhysHandleToInternalVar64(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-			psDevInfo->psTrampoline->hPdumpPages,
-			ui32PDumpFlags);
-
-	/* Keep only the relevant bits of the input physical address */
-	PDumpWriteVarANDValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-			~RGX_CR_MIPS_ADDR_REMAP4_CONFIG1_BASE_ADDR_IN_CLRMSK,
-			ui32PDumpFlags);
-
-	/* Enable bit */
-	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
-			RGX_CR_MIPS_ADDR_REMAP4_CONFIG1_MODE_ENABLE_EN,
-			ui32PDumpFlags);
-
-	/* Do the PDump register write */
-	PDumpInternalVarToReg64(psDevInfo->psDeviceNode,
-			RGX_PDUMPREG_NAME,
-			ui32Config1RegAddr,
-			":SYSMEM:$1",
-			ui32PDumpFlags);
-
-	PDUMP_BLKEND(ui32PDumpFlags);
-
-	/* this can be written directly */
-	RGXWriteReg64(hPrivate,
-			ui32Config2RegAddr,
-			(ui64Config2PhyAddr & ui64Config2PhyMask) | ui64Config2Settings);
-}
-#endif /* defined(PDUMP) */
-#endif /* defined(RGX_FEATURE_MIPS_BIT_MASK) */
 
 #define MAX_NUM_COHERENCY_TESTS  (10)
 IMG_BOOL RGXDoFWSlaveBoot(const void *hPrivate)
@@ -812,7 +101,6 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 	IMG_DEVMEM_ALIGN_T uiFabricCohTestBlockAlign = sizeof(IMG_UINT64);
 	IMG_UINT32 ui32SLCCTRL = 0;
 	IMG_UINT32 ui32OddEven;
-	IMG_BOOL   bFeatureS7 = RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE);
 	IMG_UINT32 ui32OddEvenSeed = 1;
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_BOOL bFullTestPassed = IMG_TRUE;
@@ -830,15 +118,6 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 
 	PVR_LOG(("Starting fabric coherency test ....."));
 
-	if (bFeatureS7)
-	{
-		IMG_UINT64 ui64SegOutAddrTopUncached = RGXFW_SEGMMU_OUTADDR_TOP_VIVT_SLC_UNCACHED(MMU_CONTEXT_MAPPING_FWIF);
-
-		/* Configure META to use SLC force-linefill for the bootloader segment */
-		RGXWriteMetaRegThroughSP(hPrivate, META_CR_MMCU_SEGMENTn_OUTA1(6),
-				(ui64SegOutAddrTopUncached | RGXFW_BOOTLDR_DEVV_ADDR) >> 32);
-	}
-	else
 	{
 		/* Bypass the SLC when IO coherency is enabled */
 		ui32SLCCTRL = RGXReadReg32(hPrivate, RGX_CR_SLC_CTRL_BYPASS);
@@ -986,7 +265,7 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 							(IMG_CHAR *)pui32FabricCohTestBufferCpuVA + ui32Offset + sizeof(IMG_UINT32),
 							sCpuPhyAddrStart,
 							sCpuPhyAddrEnd,
-							PVRSRV_CACHE_OP_CLEAN);
+							PVRSRV_CACHE_OP_FLUSH);
 
 					/* Calculate a new value to write */
 					ui32FWValue = i + ui32OddEvenSeed;
@@ -1026,21 +305,18 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 						continue;
 					}
 
-					if (!PVRSRVSystemSnoopingOfDeviceCache(psDevInfo->psDeviceNode->psDevConfig))
-					{
-						/* Invalidate dcache to ensure that any prefetched data by the CPU from this memory
-						   region is discarded before we read (i.e. next read must trigger a cache miss).
-						   If there is snooping of device cache, then any prefetching done by the CPU
-						   will reflect the most up to date datum writing by GPU into said location,
-						   that is to say prefetching must be coherent so CPU d-flush is not needed */
-						sCpuPhyAddrEnd.uiAddr += sizeof(IMG_UINT32);
-						CacheOpExec(psDevInfo->psDeviceNode,
-								(IMG_CHAR *)pui32FabricCohTestBufferCpuVA + ui32Offset,
-								(IMG_CHAR *)pui32FabricCohTestBufferCpuVA + ui32Offset + sizeof(IMG_UINT32),
-								sCpuPhyAddrStart,
-								sCpuPhyAddrEnd,
-								PVRSRV_CACHE_OP_INVALIDATE);
-					}
+					/* Invalidate dcache to ensure that any prefetched data by the CPU from this memory
+					   region is discarded before we read (i.e. next read must trigger a cache miss).
+					   Previously there was snooping of device cache, where prefetching done by the CPU
+					   would reflect the most up to date datum writing by GPU into said location,
+					   that is to say prefetching was coherent so CPU d-flush was not needed */
+					sCpuPhyAddrEnd.uiAddr += sizeof(IMG_UINT32);
+					CacheOpExec(psDevInfo->psDeviceNode,
+							(IMG_CHAR *)pui32FabricCohTestBufferCpuVA + ui32Offset,
+							(IMG_CHAR *)pui32FabricCohTestBufferCpuVA + ui32Offset + sizeof(IMG_UINT32),
+							sCpuPhyAddrStart,
+							sCpuPhyAddrEnd,
+							PVRSRV_CACHE_OP_INVALIDATE);
 				}
 				else
 				{
@@ -1180,14 +456,6 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 	DevmemFwUnmapAndFree(psDevInfo, psFabricCohTestBufferMemDesc);
 
 e0:
-	if (bFeatureS7)
-	{
-		/* Restore bootloader segment settings */
-		IMG_UINT64 ui64SegOutAddrTopCached   = RGXFW_SEGMMU_OUTADDR_TOP_VIVT_SLC_CACHED(MMU_CONTEXT_MAPPING_FWIF);
-		RGXWriteMetaRegThroughSP(hPrivate, META_CR_MMCU_SEGMENTn_OUTA1(6),
-				(ui64SegOutAddrTopCached | RGXFW_BOOTLDR_DEVV_ADDR) >> 32);
-	}
-	else
 	{
 		/* Restore SLC bypass settings */
 		RGXWriteReg32(hPrivate, RGX_CR_SLC_CTRL_BYPASS, ui32SLCCTRL);
@@ -1208,139 +476,3 @@ PVRSRV_ERROR RGXFabricCoherencyTest(const void *hPrivate)
 	return eError;
 }
 
-IMG_BOOL RGXDeviceHasErnBrn(const void *hPrivate, IMG_UINT64 ui64ErnsBrns)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	return (psDevInfo->sDevFeatureCfg.ui64ErnsBrns & ui64ErnsBrns) != 0;
-}
-
-IMG_UINT32 RGXGetDeviceSLCBanks(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, SLC_BANKS))
-	{
-		return 0;
-	}
-	return RGX_GET_FEATURE_VALUE(psDevInfo, SLC_BANKS);
-}
-
-IMG_UINT32 RGXGetDeviceCacheLineSize(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, SLC_CACHE_LINE_SIZE_BITS))
-	{
-		return 0;
-	}
-	return RGX_GET_FEATURE_VALUE(psDevInfo, SLC_CACHE_LINE_SIZE_BITS);
-}
-
-#if defined(RGX_FEATURE_MIPS_BIT_MASK)
-IMG_UINT32 RGXGetDevicePhysBusWidth(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, PHYS_BUS_WIDTH))
-	{
-		return 0;
-	}
-	return RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH);
-}
-
-IMG_BOOL RGXDevicePA0IsValid(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	return psDevInfo->sLayerParams.bDevicePA0IsValid;
-}
-#endif
-
-void RGXAcquireBootCodeAddr(const void *hPrivate, IMG_DEV_VIRTADDR *psBootCodeAddr)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	*psBootCodeAddr = psDevInfo->sFWCodeDevVAddrBase;
-}
-
-void RGXAcquireBootDataAddr(const void *hPrivate, IMG_DEV_VIRTADDR *psBootDataAddr)
-{
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
-
-	*psBootDataAddr = psDevInfo->sFWDataDevVAddrBase;
-}
-
-void *RGXCalculateHostFWDataAddress(const void *hPrivate, void *pvHostFWDataAddr)
-{
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	IMG_UINT8 *ui8HostFWDataAddr = (IMG_UINT8*)pvHostFWDataAddr;
-	IMG_UINT32 ui32Offset = 0U;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4)
-	{
-		ui32Offset =
-			PVR_ALIGN(RGXGetFWImageSectionAllocSize(hPrivate, RISCV_UNCACHED_CODE),
-			          RGXRISCVFW_REMAP_CONFIG_DEVVADDR_ALIGN) +
-			PVR_ALIGN(RGXGetFWImageSectionAllocSize(hPrivate, RISCV_CACHED_CODE),
-			          RGXRISCVFW_REMAP_CONFIG_DEVVADDR_ALIGN);
-	}
-
-	ui8HostFWDataAddr -= ui32Offset;
-	return (void*)ui8HostFWDataAddr;
-#else
-	PVR_UNREFERENCED_PARAMETER(hPrivate);
-
-	return pvHostFWDataAddr;
-#endif
-}
-
-IMG_BOOL RGXDeviceAckIrq(const void *hPrivate)
-{
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
-
-	return (psDevInfo->pfnRGXAckIrq != NULL) ?
-			psDevInfo->pfnRGXAckIrq(psDevInfo) : IMG_TRUE;
-}
diff --git a/drivers/gpu/drm/img-rogue/rgxlayer_impl.h b/drivers/gpu/drm/img-rogue/rgxlayer_impl.h
index 4d7c0f0c7798..b46efee8c71c 100644
--- a/drivers/gpu/drm/img-rogue/rgxlayer_impl.h
+++ b/drivers/gpu/drm/img-rogue/rgxlayer_impl.h
@@ -56,12 +56,14 @@ typedef struct _RGX_LAYER_PARAMS_
 #endif
 
 	IMG_DEV_PHYADDR sPCAddr;
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	IMG_DEV_PHYADDR sGPURegAddr;
 	IMG_DEV_PHYADDR sBootRemapAddr;
 	IMG_DEV_PHYADDR sCodeRemapAddr;
 	IMG_DEV_PHYADDR sDataRemapAddr;
 	IMG_DEV_PHYADDR sTrampolineRemapAddr;
 	IMG_BOOL bDevicePA0IsValid;
+#endif
 } RGX_LAYER_PARAMS;
 
 #endif /* RGXLAYER_IMPL_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxlayer_impl_common.c b/drivers/gpu/drm/img-rogue/rgxlayer_impl_common.c
new file mode 100644
index 000000000000..7eab6fde4dcd
--- /dev/null
+++ b/drivers/gpu/drm/img-rogue/rgxlayer_impl_common.c
@@ -0,0 +1,914 @@
+/*************************************************************************/ /*!
+@File
+@Title          Common DDK implementation of the Services abstraction layer
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@Description    Common DDK implementation of the Services abstraction layer
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/ /**************************************************************************/
+
+#include "rgxlayer_impl.h"
+#include "pdump_km.h"
+#include "rgxfwutils.h"
+#include "rgxfwimageutils.h"
+
+#if defined(PDUMP)
+#if defined(__linux__)
+ #include <linux/version.h>
+
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
+  #include <linux/stdarg.h>
+ #else
+  #include <stdarg.h>
+ #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0) */
+#else
+ #include <stdarg.h>
+#endif /* __linux__ */
+#endif
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+#define RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr) \
+	(((ui32RegAddr) < RGX_HOST_SECURE_REGBANK_OFFSET) ? \
+	 ((psDevInfo)->pvRegsBaseKM) : ((psDevInfo)->pvSecureRegsBaseKM))
+#else
+#define RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr) ((psDevInfo)->pvRegsBaseKM)
+#endif
+
+void RGXMemCopy(const void *hPrivate,
+                void *pvDst,
+                void *pvSrc,
+                size_t uiSize)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+	OSDeviceMemCopy(pvDst, pvSrc, uiSize);
+}
+
+void RGXMemSet(const void *hPrivate,
+               void *pvDst,
+               IMG_UINT8 ui8Value,
+               size_t uiSize)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+	OSDeviceMemSet(pvDst, ui8Value, uiSize);
+}
+
+void RGXCommentLog(const void *hPrivate,
+                   const IMG_CHAR *pszString,
+                   ...)
+{
+#if defined(PDUMP)
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	va_list argList;
+	va_start(argList, pszString);
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	PDumpCommentWithFlagsVA(psDevInfo->psDeviceNode, PDUMP_FLAGS_CONTINUOUS, pszString, argList);
+	va_end(argList);
+#else
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+	PVR_UNREFERENCED_PARAMETER(pszString);
+#endif
+}
+
+void RGXErrorLog(const void *hPrivate,
+                 const IMG_CHAR *pszString,
+                 ...)
+{
+	IMG_CHAR szBuffer[PVR_MAX_DEBUG_MESSAGE_LEN];
+	va_list argList;
+
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+
+	va_start(argList, pszString);
+	vsnprintf(szBuffer, sizeof(szBuffer), pszString, argList);
+	va_end(argList);
+
+	PVR_DPF((PVR_DBG_ERROR, "%s", szBuffer));
+}
+
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+IMG_UINT32 RGXGetOSPageSize(const void *hPrivate)
+{
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+	return OSGetPageSize();
+}
+#endif
+
+IMG_INT32 RGXDeviceGetFeatureValue(const void *hPrivate, IMG_UINT64 ui64Feature)
+{
+	IMG_INT32 i32Ret = -1;
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+
+	PVR_ASSERT(hPrivate != NULL);
+
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	psDeviceNode = psDevInfo->psDeviceNode;
+
+	if ((psDeviceNode->pfnGetDeviceFeatureValue))
+	{
+		i32Ret = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode, ui64Feature);
+	}
+
+	return i32Ret;
+}
+
+IMG_BOOL RGXDeviceHasFeature(const void *hPrivate, IMG_UINT64 ui64Feature)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	return (psDevInfo->sDevFeatureCfg.ui64Features & ui64Feature) != 0;
+}
+
+IMG_UINT32 RGXGetFWCorememSize(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_UINT32 ui32CorememSize = 0;
+
+	PVR_ASSERT(hPrivate != NULL);
+
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META_COREMEM_SIZE))
+	{
+		ui32CorememSize = RGX_GET_FEATURE_VALUE(psDevInfo, META_COREMEM_SIZE);
+	}
+
+	return ui32CorememSize;
+}
+
+void RGXWriteReg32(const void *hPrivate, IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
+#endif
+	{
+		OSWriteUncheckedHWReg32(pvRegsBase, ui32RegAddr, ui32RegValue);
+	}
+
+	PDUMPREG32(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	           ui32RegAddr, ui32RegValue, psParams->ui32PdumpFlags);
+}
+
+void RGXWriteReg64(const void *hPrivate, IMG_UINT32 ui32RegAddr, IMG_UINT64 ui64RegValue)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
+#endif
+	{
+		OSWriteUncheckedHWReg64(pvRegsBase, ui32RegAddr, ui64RegValue);
+	}
+
+	PDUMPREG64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	           ui32RegAddr, ui64RegValue, psParams->ui32PdumpFlags);
+}
+
+IMG_UINT32 RGXReadReg32(const void *hPrivate, IMG_UINT32 ui32RegAddr)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+	IMG_UINT32 ui32RegValue;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW)
+	{
+		ui32RegValue = IMG_UINT32_MAX;
+	}
+	else
+#endif
+	{
+		ui32RegValue = OSReadUncheckedHWReg32(pvRegsBase, ui32RegAddr);
+	}
+
+	PDUMPREGREAD32(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	               ui32RegAddr, psParams->ui32PdumpFlags);
+
+	return ui32RegValue;
+}
+
+IMG_UINT64 RGXReadReg64(const void *hPrivate, IMG_UINT32 ui32RegAddr)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+	IMG_UINT64 ui64RegValue;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW)
+	{
+		ui64RegValue = IMG_UINT64_MAX;
+	}
+	else
+#endif
+	{
+		ui64RegValue = OSReadUncheckedHWReg64(pvRegsBase, ui32RegAddr);
+	}
+
+	PDUMPREGREAD64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	               ui32RegAddr, PDUMP_FLAGS_CONTINUOUS);
+
+	return ui64RegValue;
+}
+
+IMG_UINT32 RGXReadModifyWriteReg64(const void *hPrivate,
+                                   IMG_UINT32 ui32RegAddr,
+                                   IMG_UINT64 uiRegValueNew,
+                                   IMG_UINT64 uiRegKeepMask)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+#if defined(PDUMP)
+	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
+#endif
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+	/* only use the new values for bits we update according to the keep mask */
+	uiRegValueNew &= ~uiRegKeepMask;
+
+#if defined(PDUMP)
+
+	PDUMP_BLKSTART(ui32PDumpFlags);
+
+	/* Store register offset to temp PDump variable */
+	PDumpRegRead64ToInternalVar(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	                            ":SYSMEM:$1", ui32RegAddr, ui32PDumpFlags);
+
+	/* Keep the bits set in the mask */
+	PDumpWriteVarANDValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+	                        uiRegKeepMask, ui32PDumpFlags);
+
+	/* OR the new values */
+	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+	                       uiRegValueNew, ui32PDumpFlags);
+
+	/* Do the actual register write */
+	PDumpInternalVarToReg64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	                        ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
+
+	PDUMP_BLKEND(ui32PDumpFlags);
+
+	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
+#endif
+
+	{
+		IMG_UINT64 uiRegValue = OSReadUncheckedHWReg64(pvRegsBase, ui32RegAddr);
+		uiRegValue &= uiRegKeepMask;
+		OSWriteUncheckedHWReg64(pvRegsBase, ui32RegAddr, uiRegValue | uiRegValueNew);
+	}
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR RGXPollReg32(const void *hPrivate,
+                          IMG_UINT32 ui32RegAddr,
+                          IMG_UINT32 ui32RegValue,
+                          IMG_UINT32 ui32RegMask)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
+#endif
+	{
+		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
+		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr),
+		                         ui32RegValue,
+		                         ui32RegMask,
+		                         POLL_FLAG_LOG_ERROR,
+		                         NULL) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg32: Poll for Reg (0x%x) failed", ui32RegAddr));
+			return PVRSRV_ERROR_TIMEOUT;
+		}
+	}
+
+	PDUMPREGPOL(psDevInfo->psDeviceNode,
+	            RGX_PDUMPREG_NAME,
+	            ui32RegAddr,
+	            ui32RegValue,
+	            ui32RegMask,
+	            psParams->ui32PdumpFlags,
+	            PDUMP_POLL_OPERATOR_EQUAL);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR RGXPollReg64(const void *hPrivate,
+                          IMG_UINT32 ui32RegAddr,
+                          IMG_UINT64 ui64RegValue,
+                          IMG_UINT64 ui64RegMask)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+
+	/* Split lower and upper words */
+	IMG_UINT32 ui32UpperValue = (IMG_UINT32) (ui64RegValue >> 32);
+	IMG_UINT32 ui32LowerValue = (IMG_UINT32) (ui64RegValue);
+	IMG_UINT32 ui32UpperMask = (IMG_UINT32) (ui64RegMask >> 32);
+	IMG_UINT32 ui32LowerMask = (IMG_UINT32) (ui64RegMask);
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32RegAddr);
+
+#if defined(PDUMP)
+	if (!(psParams->ui32PdumpFlags & PDUMP_FLAGS_NOHW))
+#endif
+	{
+		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
+		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr + 4),
+		                         ui32UpperValue,
+		                         ui32UpperMask,
+		                         POLL_FLAG_LOG_ERROR,
+		                         NULL) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg64: Poll for upper part of Reg (0x%x) failed", ui32RegAddr));
+			return PVRSRV_ERROR_TIMEOUT;
+		}
+
+		if (PVRSRVPollForValueKM(psDevInfo->psDeviceNode,
+		                         (IMG_UINT32 __iomem *)((IMG_UINT8 __iomem *)pvRegsBase + ui32RegAddr),
+		                         ui32LowerValue,
+		                         ui32LowerMask,
+		                         POLL_FLAG_LOG_ERROR,
+		                         NULL) != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "RGXPollReg64: Poll for lower part of Reg (0x%x) failed", ui32RegAddr));
+			return PVRSRV_ERROR_TIMEOUT;
+		}
+	}
+
+	PDUMPREGPOL(psDevInfo->psDeviceNode,
+	            RGX_PDUMPREG_NAME,
+	            ui32RegAddr + 4,
+	            ui32UpperValue,
+	            ui32UpperMask,
+	            psParams->ui32PdumpFlags,
+	            PDUMP_POLL_OPERATOR_EQUAL);
+
+
+	PDUMPREGPOL(psDevInfo->psDeviceNode,
+	            RGX_PDUMPREG_NAME,
+	            ui32RegAddr,
+	            ui32LowerValue,
+	            ui32LowerMask,
+	            psParams->ui32PdumpFlags,
+	            PDUMP_POLL_OPERATOR_EQUAL);
+
+	return PVRSRV_OK;
+}
+
+void RGXSetPoweredState(const void *hPrivate, IMG_BOOL bPowered)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	psDevInfo->bRGXPowered = bPowered;
+}
+
+void RGXWaitCycles(const void *hPrivate, IMG_UINT32 ui32Cycles, IMG_UINT32 ui32TimeUs)
+{
+	__maybe_unused PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+	OSWaitus(ui32TimeUs);
+	PDUMPIDLWITHFLAGS(psDevInfo->psDeviceNode, ui32Cycles, PDUMP_FLAGS_CONTINUOUS);
+}
+
+void RGXAcquireKernelMMUPC(const void *hPrivate, IMG_DEV_PHYADDR *psPCAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psPCAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sPCAddr;
+}
+
+#if defined(PDUMP)
+#if !defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+void RGXWriteKernelMMUPC64(const void *hPrivate,
+		IMG_UINT32 ui32PCReg,
+		IMG_UINT32 ui32PCRegAlignShift,
+		IMG_UINT32 ui32PCRegShift,
+		IMG_UINT64 ui64PCVal)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	/* Write the cat-base address */
+	OSWriteHWReg64(psDevInfo->pvRegsBaseKM, ui32PCReg, ui64PCVal);
+
+	/* Pdump catbase address */
+	MMU_PDumpWritePageCatBase(psDevInfo->psKernelMMUCtx,
+			RGX_PDUMPREG_NAME,
+			ui32PCReg,
+			8,
+			ui32PCRegAlignShift,
+			ui32PCRegShift,
+			PDUMP_FLAGS_CONTINUOUS);
+}
+#endif
+
+void RGXWriteKernelMMUPC32(const void *hPrivate,
+                           IMG_UINT32 ui32PCReg,
+                           IMG_UINT32 ui32PCRegAlignShift,
+                           IMG_UINT32 ui32PCRegShift,
+                           IMG_UINT32 ui32PCVal)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	void __iomem *pvRegsBase;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+	pvRegsBase = RGX_GET_REGS_BASE(psDevInfo, ui32PCReg);
+
+	/* Write the cat-base address */
+	OSWriteUncheckedHWReg32(pvRegsBase, ui32PCReg, ui32PCVal);
+
+	/* Pdump catbase address */
+	MMU_PDumpWritePageCatBase(psDevInfo->psKernelMMUCtx,
+	                          RGX_PDUMPREG_NAME,
+	                          ui32PCReg,
+	                          4,
+	                          ui32PCRegAlignShift,
+	                          ui32PCRegShift,
+	                          PDUMP_FLAGS_CONTINUOUS);
+}
+#endif /* defined(PDUMP) */
+
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+void RGXAcquireGPURegsAddr(const void *hPrivate, IMG_DEV_PHYADDR *psGPURegsAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psGPURegsAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sGPURegAddr;
+}
+
+#if defined(PDUMP)
+void RGXMIPSWrapperConfig(const void *hPrivate,
+		IMG_UINT32 ui32RegAddr,
+		IMG_UINT64 ui64GPURegsAddr,
+		IMG_UINT32 ui32GPURegsAlign,
+		IMG_UINT32 ui32BootMode)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	OSWriteHWReg64(psDevInfo->pvRegsBaseKM,
+			ui32RegAddr,
+			(ui64GPURegsAddr >> ui32GPURegsAlign) | ui32BootMode);
+
+	PDUMP_BLKSTART(ui32PDumpFlags);
+
+	/* Store register offset to temp PDump variable */
+	PDumpRegLabelToInternalVar(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	                           ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
+
+	/* Align register transactions identifier */
+	PDumpWriteVarSHRValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+	                        ui32GPURegsAlign, ui32PDumpFlags);
+
+	/* Enable micromips instruction encoding */
+	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+	                       ui32BootMode, ui32PDumpFlags);
+
+	/* Do the actual register write */
+	PDumpInternalVarToReg64(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME,
+	                        ui32RegAddr, ":SYSMEM:$1", ui32PDumpFlags);
+
+	PDUMP_BLKEND(ui32PDumpFlags);
+}
+#endif
+
+void RGXAcquireBootRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psBootRemapAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psBootRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sBootRemapAddr;
+}
+
+void RGXAcquireCodeRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psCodeRemapAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psCodeRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sCodeRemapAddr;
+}
+
+void RGXAcquireDataRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psDataRemapAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psDataRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sDataRemapAddr;
+}
+
+void RGXAcquireTrampolineRemapAddr(const void *hPrivate, IMG_DEV_PHYADDR *psTrampolineRemapAddr)
+{
+	PVR_ASSERT(hPrivate != NULL);
+	*psTrampolineRemapAddr = ((RGX_LAYER_PARAMS*)hPrivate)->sTrampolineRemapAddr;
+}
+
+#if defined(PDUMP)
+static inline
+void RGXWriteRemapConfig2Reg(void __iomem *pvRegs,
+		PMR *psPMR,
+		IMG_DEVMEM_OFFSET_T uiLogicalOffset,
+		IMG_UINT32 ui32RegAddr,
+		IMG_UINT64 ui64PhyAddr,
+		IMG_UINT64 ui64PhyMask,
+		IMG_UINT64 ui64Settings)
+{
+	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
+	PVRSRV_DEVICE_NODE *psDevNode;
+
+	PVR_ASSERT(psPMR != NULL);
+	psDevNode = PMR_DeviceNode(psPMR);
+
+	OSWriteHWReg64(pvRegs, ui32RegAddr, (ui64PhyAddr & ui64PhyMask) | ui64Settings);
+
+	PDUMP_BLKSTART(ui32PDumpFlags);
+
+	/* Store memory offset to temp PDump variable */
+	PDumpMemLabelToInternalVar64(":SYSMEM:$1", psPMR,
+	                             uiLogicalOffset, ui32PDumpFlags);
+
+	/* Keep only the relevant bits of the output physical address */
+	PDumpWriteVarANDValueOp(psDevNode, ":SYSMEM:$1", ui64PhyMask, ui32PDumpFlags);
+
+	/* Extra settings for this remapped region */
+	PDumpWriteVarORValueOp(psDevNode, ":SYSMEM:$1", ui64Settings, ui32PDumpFlags);
+
+	/* Do the actual register write */
+	PDumpInternalVarToReg64(psDevNode, RGX_PDUMPREG_NAME, ui32RegAddr,
+	                        ":SYSMEM:$1", ui32PDumpFlags);
+
+	PDUMP_BLKEND(ui32PDumpFlags);
+}
+
+void RGXBootRemapConfig(const void *hPrivate,
+		IMG_UINT32 ui32Config1RegAddr,
+		IMG_UINT64 ui64Config1RegValue,
+		IMG_UINT32 ui32Config2RegAddr,
+		IMG_UINT64 ui64Config2PhyAddr,
+		IMG_UINT64 ui64Config2PhyMask,
+		IMG_UINT64 ui64Config2Settings)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_UINT32 ui32BootRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_BOOT_CODE);
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	/* Write remap config1 register */
+	RGXWriteReg64(hPrivate,
+			ui32Config1RegAddr,
+			ui64Config1RegValue);
+
+	/* Write remap config2 register */
+	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
+			psDevInfo->psRGXFWCodeMemDesc->psImport->hPMR,
+			psDevInfo->psRGXFWCodeMemDesc->uiOffset + ui32BootRemapMemOffset,
+			ui32Config2RegAddr,
+			ui64Config2PhyAddr,
+			ui64Config2PhyMask,
+			ui64Config2Settings);
+}
+
+void RGXCodeRemapConfig(const void *hPrivate,
+		IMG_UINT32 ui32Config1RegAddr,
+		IMG_UINT64 ui64Config1RegValue,
+		IMG_UINT32 ui32Config2RegAddr,
+		IMG_UINT64 ui64Config2PhyAddr,
+		IMG_UINT64 ui64Config2PhyMask,
+		IMG_UINT64 ui64Config2Settings)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_UINT32 ui32CodeRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_EXCEPTIONS_CODE);
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	/* Write remap config1 register */
+	RGXWriteReg64(hPrivate,
+			ui32Config1RegAddr,
+			ui64Config1RegValue);
+
+	/* Write remap config2 register */
+	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
+			psDevInfo->psRGXFWCodeMemDesc->psImport->hPMR,
+			psDevInfo->psRGXFWCodeMemDesc->uiOffset + ui32CodeRemapMemOffset,
+			ui32Config2RegAddr,
+			ui64Config2PhyAddr,
+			ui64Config2PhyMask,
+			ui64Config2Settings);
+}
+
+void RGXDataRemapConfig(const void *hPrivate,
+		IMG_UINT32 ui32Config1RegAddr,
+		IMG_UINT64 ui64Config1RegValue,
+		IMG_UINT32 ui32Config2RegAddr,
+		IMG_UINT64 ui64Config2PhyAddr,
+		IMG_UINT64 ui64Config2PhyMask,
+		IMG_UINT64 ui64Config2Settings)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_UINT32 ui32DataRemapMemOffset = RGXGetFWImageSectionOffset(NULL, MIPS_BOOT_DATA);
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	/* Write remap config1 register */
+	RGXWriteReg64(hPrivate,
+			ui32Config1RegAddr,
+			ui64Config1RegValue);
+
+	/* Write remap config2 register */
+	RGXWriteRemapConfig2Reg(psDevInfo->pvRegsBaseKM,
+			psDevInfo->psRGXFWDataMemDesc->psImport->hPMR,
+			psDevInfo->psRGXFWDataMemDesc->uiOffset + ui32DataRemapMemOffset,
+			ui32Config2RegAddr,
+			ui64Config2PhyAddr,
+			ui64Config2PhyMask,
+			ui64Config2Settings);
+}
+
+void RGXTrampolineRemapConfig(const void *hPrivate,
+		IMG_UINT32 ui32Config1RegAddr,
+		IMG_UINT64 ui64Config1RegValue,
+		IMG_UINT32 ui32Config2RegAddr,
+		IMG_UINT64 ui64Config2PhyAddr,
+		IMG_UINT64 ui64Config2PhyMask,
+		IMG_UINT64 ui64Config2Settings)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	PDUMP_FLAGS_T ui32PDumpFlags = PDUMP_FLAGS_CONTINUOUS;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	/* write the register for real, without PDump */
+	OSWriteHWReg64(psDevInfo->pvRegsBaseKM,
+			ui32Config1RegAddr,
+			ui64Config1RegValue);
+
+	PDUMP_BLKSTART(ui32PDumpFlags);
+
+	/* Store the memory address in a PDump variable */
+	PDumpPhysHandleToInternalVar64(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+			psDevInfo->psTrampoline->hPdumpPages,
+			ui32PDumpFlags);
+
+	/* Keep only the relevant bits of the input physical address */
+	PDumpWriteVarANDValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+			~RGX_CR_MIPS_ADDR_REMAP4_CONFIG1_BASE_ADDR_IN_CLRMSK,
+			ui32PDumpFlags);
+
+	/* Enable bit */
+	PDumpWriteVarORValueOp(psDevInfo->psDeviceNode, ":SYSMEM:$1",
+			RGX_CR_MIPS_ADDR_REMAP4_CONFIG1_MODE_ENABLE_EN,
+			ui32PDumpFlags);
+
+	/* Do the PDump register write */
+	PDumpInternalVarToReg64(psDevInfo->psDeviceNode,
+			RGX_PDUMPREG_NAME,
+			ui32Config1RegAddr,
+			":SYSMEM:$1",
+			ui32PDumpFlags);
+
+	PDUMP_BLKEND(ui32PDumpFlags);
+
+	/* this can be written directly */
+	RGXWriteReg64(hPrivate,
+			ui32Config2RegAddr,
+			(ui64Config2PhyAddr & ui64Config2PhyMask) | ui64Config2Settings);
+}
+#endif /* defined(PDUMP) */
+#endif /* defined(RGX_FEATURE_MIPS_BIT_MASK) */
+
+IMG_BOOL RGXDeviceHasErnBrn(const void *hPrivate, IMG_UINT64 ui64ErnsBrns)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	return (psDevInfo->sDevFeatureCfg.ui64ErnsBrns & ui64ErnsBrns) != 0;
+}
+
+IMG_UINT32 RGXGetDeviceSLCBanks(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, SLC_BANKS))
+	{
+		return 0;
+	}
+	return RGX_GET_FEATURE_VALUE(psDevInfo, SLC_BANKS);
+}
+
+IMG_UINT32 RGXGetDeviceCacheLineSize(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, SLC_CACHE_LINE_SIZE_BITS))
+	{
+		return 0;
+	}
+	return RGX_GET_FEATURE_VALUE(psDevInfo, SLC_CACHE_LINE_SIZE_BITS);
+}
+
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+IMG_UINT32 RGXGetDevicePhysBusWidth(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	if (!RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, PHYS_BUS_WIDTH))
+	{
+		return 0;
+	}
+	return RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH);
+}
+
+IMG_BOOL RGXDevicePA0IsValid(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	return psDevInfo->sLayerParams.bDevicePA0IsValid;
+}
+#endif
+
+void RGXAcquireBootCodeAddr(const void *hPrivate, IMG_DEV_VIRTADDR *psBootCodeAddr)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	*psBootCodeAddr = psDevInfo->sFWCodeDevVAddrBase;
+}
+
+void RGXAcquireBootDataAddr(const void *hPrivate, IMG_DEV_VIRTADDR *psBootDataAddr)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psDevInfo = ((RGX_LAYER_PARAMS*)hPrivate)->psDevInfo;
+
+	*psBootDataAddr = psDevInfo->sFWDataDevVAddrBase;
+}
+
+void *RGXCalculateHostFWDataAddress(const void *hPrivate, void *pvHostFWDataAddr)
+{
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	IMG_UINT8 *ui8HostFWDataAddr = (IMG_UINT8*)pvHostFWDataAddr;
+	IMG_UINT32 ui32Offset = 0U;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4)
+	{
+		ui32Offset =
+			PVR_ALIGN(RGXGetFWImageSectionAllocSize(hPrivate, RISCV_UNCACHED_CODE),
+			          RGXRISCVFW_REMAP_CONFIG_DEVVADDR_ALIGN) +
+			PVR_ALIGN(RGXGetFWImageSectionAllocSize(hPrivate, RISCV_CACHED_CODE),
+			          RGXRISCVFW_REMAP_CONFIG_DEVVADDR_ALIGN);
+	}
+
+	ui8HostFWDataAddr -= ui32Offset;
+	return (void*)ui8HostFWDataAddr;
+#else
+	PVR_UNREFERENCED_PARAMETER(hPrivate);
+
+	return pvHostFWDataAddr;
+#endif
+}
+
+IMG_BOOL RGXDeviceAckIrq(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+
+	PVR_ASSERT(hPrivate != NULL);
+	psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	psDevInfo = psParams->psDevInfo;
+
+	return (psDevInfo->pfnRGXAckIrq != NULL) ?
+			psDevInfo->pfnRGXAckIrq(psDevInfo) : IMG_TRUE;
+}
diff --git a/drivers/gpu/drm/img-rogue/rgxmem.c b/drivers/gpu/drm/img-rogue/rgxmem.c
index d9aa6adfada1..4df36ef5d1f0 100644
--- a/drivers/gpu/drm/img-rogue/rgxmem.c
+++ b/drivers/gpu/drm/img-rogue/rgxmem.c
@@ -93,6 +93,7 @@ PVRSRV_ERROR RGXInvalidateFBSCTable(PVRSRV_DEVICE_NODE *psDeviceNode,
 		if (psIter->psMMUContext == psMMUContext)
 		{
 			psServerMMUContext = psIter;
+			break;
 		}
 	}
 
@@ -274,7 +275,7 @@ PVRSRV_ERROR RGXMMUCacheInvalidateKick(PVRSRV_DEVICE_NODE *psDeviceNode,
 		goto _PowerUnlockAndReturnErr;
 	}
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = _PrepareAndSubmitCacheCommand(psDeviceNode, RGXFWIF_DM_GP, ui32FWCacheFlags,
 											   IMG_TRUE, pui32MMUInvalidateUpdate);
@@ -284,7 +285,7 @@ PVRSRV_ERROR RGXMMUCacheInvalidateKick(PVRSRV_DEVICE_NODE *psDeviceNode,
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	}
-	END_LOOP_UNTIL_TIMEOUT();
+	END_LOOP_UNTIL_TIMEOUT_US();
 
 	PVR_LOG_IF_ERROR(eError, "_PrepareAndSubmitCacheCommand");
 
@@ -317,7 +318,7 @@ PVRSRV_ERROR RGXPreKickCacheCommand(PVRSRV_RGXDEV_INFO *psDevInfo,
 		return PVRSRV_OK;
 	}
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = _PrepareAndSubmitCacheCommand(psDeviceNode, eDM, ui32FWCacheFlags,
 		                                       IMG_FALSE, pui32MMUInvalidateUpdate);
@@ -327,7 +328,7 @@ PVRSRV_ERROR RGXPreKickCacheCommand(PVRSRV_RGXDEV_INFO *psDevInfo,
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	}
-	END_LOOP_UNTIL_TIMEOUT();
+	END_LOOP_UNTIL_TIMEOUT_US();
 
 	PVR_LOG_RETURN_IF_ERROR(eError, "_PrepareAndSubmitCacheCommand");
 
@@ -474,7 +475,7 @@ static void _RecordUnregisteredMemoryContext(PVRSRV_RGXDEV_INFO *psDevInfo, SERV
 	{
 		PVR_LOG(("_RecordUnregisteredMemoryContext: Failed to get PC address for memory context"));
 	}
-	OSStringLCopy(psRecord->szProcessName, psServerMMUContext->szProcessName, sizeof(psRecord->szProcessName));
+	OSStringSafeCopy(psRecord->szProcessName, psServerMMUContext->szProcessName, sizeof(psRecord->szProcessName));
 }
 
 
@@ -697,7 +698,7 @@ PVRSRV_ERROR RGXRegisterMemoryContext(PVRSRV_DEVICE_NODE	*psDeviceNode,
 		psServerMMUContext->uiPID = OSGetCurrentClientProcessIDKM();
 		psServerMMUContext->psMMUContext = psMMUContext;
 		psServerMMUContext->psFWMemContextMemDesc = psFWMemContextMemDesc;
-		OSStringLCopy(psServerMMUContext->szProcessName,
+		OSStringSafeCopy(psServerMMUContext->szProcessName,
 		              OSGetCurrentClientProcessNameKM(),
 		              sizeof(psServerMMUContext->szProcessName));
 
@@ -774,7 +775,7 @@ void RGXCheckFaultAddress(PVRSRV_RGXDEV_INFO *psDevInfo,
 	}
 
 	/* Lastly check for fault in the kernel allocated memory */
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		if (MMU_AcquireBaseAddr(psDevInfo->psKernelMMUCtx, &sPCDevPAddr) != PVRSRV_OK)
 		{
@@ -825,12 +826,12 @@ IMG_BOOL RGXPCAddrToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_DEV_PHYADDR s
 	if (psServerMMUContext != NULL)
 	{
 		psInfo->uiPID = psServerMMUContext->uiPID;
-		OSStringLCopy(psInfo->szProcessName, psServerMMUContext->szProcessName, sizeof(psInfo->szProcessName));
+		OSStringSafeCopy(psInfo->szProcessName, psServerMMUContext->szProcessName, sizeof(psInfo->szProcessName));
 		psInfo->bUnregistered = IMG_FALSE;
 		bRet = IMG_TRUE;
 	}
 	/* else check if the input PC addr corresponds to the firmware */
-	else
+	else if (!PVRSRV_VZ_MODE_IS(GUEST, DEVINFO, psDevInfo))
 	{
 		IMG_DEV_PHYADDR sKernelPCDevPAddr;
 		PVRSRV_ERROR eError;
@@ -846,7 +847,7 @@ IMG_BOOL RGXPCAddrToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_DEV_PHYADDR s
 			if (sPCAddress.uiAddr == sKernelPCDevPAddr.uiAddr)
 			{
 				psInfo->uiPID = RGXMEM_SERVER_PID_FIRMWARE;
-				OSStringLCopy(psInfo->szProcessName, "Firmware", sizeof(psInfo->szProcessName));
+				OSStringSafeCopy(psInfo->szProcessName, "Firmware", sizeof(psInfo->szProcessName));
 				psInfo->bUnregistered = IMG_FALSE;
 				bRet = IMG_TRUE;
 			}
@@ -876,7 +877,7 @@ IMG_BOOL RGXPCAddrToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_DEV_PHYADDR s
 			if (psRecord->sPCDevPAddr.uiAddr == sPCAddress.uiAddr)
 			{
 				psInfo->uiPID = psRecord->uiPID;
-				OSStringLCopy(psInfo->szProcessName, psRecord->szProcessName, sizeof(psInfo->szProcessName));
+				OSStringSafeCopy(psInfo->szProcessName, psRecord->szProcessName, sizeof(psInfo->szProcessName));
 				psInfo->bUnregistered = IMG_TRUE;
 				bRet = IMG_TRUE;
 				break;
@@ -912,7 +913,7 @@ IMG_BOOL RGXPCPIDToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_PID uiPID,
 	if (psServerMMUContext != NULL)
 	{
 		psInfo->uiPID = psServerMMUContext->uiPID;
-		OSStringLCopy(psInfo->szProcessName, psServerMMUContext->szProcessName, sizeof(psInfo->szProcessName));
+		OSStringSafeCopy(psInfo->szProcessName, psServerMMUContext->szProcessName, sizeof(psInfo->szProcessName));
 		psInfo->bUnregistered = IMG_FALSE;
 		bRet = IMG_TRUE;
 	}
@@ -920,7 +921,7 @@ IMG_BOOL RGXPCPIDToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_PID uiPID,
 	else if (uiPID == RGXMEM_SERVER_PID_FIRMWARE)
 	{
 		psInfo->uiPID = RGXMEM_SERVER_PID_FIRMWARE;
-		OSStringLCopy(psInfo->szProcessName, "Firmware", sizeof(psInfo->szProcessName));
+		OSStringSafeCopy(psInfo->szProcessName, "Firmware", sizeof(psInfo->szProcessName));
 		psInfo->bUnregistered = IMG_FALSE;
 		bRet = IMG_TRUE;
 	}
@@ -945,7 +946,7 @@ IMG_BOOL RGXPCPIDToProcessInfo(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_PID uiPID,
 			if (psRecord->uiPID == uiPID)
 			{
 				psInfo->uiPID = psRecord->uiPID;
-				OSStringLCopy(psInfo->szProcessName, psRecord->szProcessName, sizeof(psInfo->szProcessName));
+				OSStringSafeCopy(psInfo->szProcessName, psRecord->szProcessName, sizeof(psInfo->szProcessName));
 				psInfo->bUnregistered = IMG_TRUE;
 				bRet = IMG_TRUE;
 				break;
diff --git a/drivers/gpu/drm/img-rogue/rgxmmuinit.c b/drivers/gpu/drm/img-rogue/rgxmmuinit.c
index d790c2c98e50..fdedebe7b033 100644
--- a/drivers/gpu/drm/img-rogue/rgxmmuinit.c
+++ b/drivers/gpu/drm/img-rogue/rgxmmuinit.c
@@ -43,7 +43,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxmmuinit.h"
 #include "rgxmmudefs_km.h"
 
-#include "device.h"
+#include "rgxdevice.h"
 #include "img_types.h"
 #include "img_defs.h"
 #include "mmu_common.h"
@@ -52,19 +52,28 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvr_debug.h"
 #include "pvrsrv_error.h"
 #include "rgx_memallocflags.h"
-#include "rgx_heaps.h"
+#include "rgx_heaps_server.h"
 #include "pdump_km.h"
-
+#include "allocmem.h"
 
 /* useful macros */
 /* units represented in a bitfield */
 #define UNITS_IN_BITFIELD(Mask, Shift)	((Mask >> Shift) + 1)
 
-
 /*
  * Bits of PT, PD and PC not involving addresses
  */
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/* protection bits for MMU_VERSION <= 3 */
+#define RGX_MMUCTRL_PTE_PROTMASK	(RGX_MMUCTRL_PT_DATA_PM_META_PROTECT_EN | \
+		~RGX_MMUCTRL_PT_DATA_AXCACHE_CLRMSK | \
+		RGX_MMUCTRL_PT_DATA_ENTRY_PENDING_EN | \
+		RGX_MMUCTRL_PT_DATA_PM_SRC_EN | \
+		RGX_MMUCTRL_PT_DATA_CC_EN | \
+		RGX_MMUCTRL_PT_DATA_READ_ONLY_EN | \
+		RGX_MMUCTRL_PT_DATA_VALID_EN)
+#else
 #define RGX_MMUCTRL_PTE_PROTMASK	(RGX_MMUCTRL_PT_DATA_PM_META_PROTECT_EN | \
 		RGX_MMUCTRL_PT_DATA_ENTRY_PENDING_EN | \
 		RGX_MMUCTRL_PT_DATA_PM_SRC_EN | \
@@ -72,6 +81,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 		RGX_MMUCTRL_PT_DATA_CC_EN | \
 		RGX_MMUCTRL_PT_DATA_READ_ONLY_EN | \
 		RGX_MMUCTRL_PT_DATA_VALID_EN)
+#endif
 
 #define RGX_MMUCTRL_PDE_PROTMASK	(RGX_MMUCTRL_PD_DATA_ENTRY_PENDING_EN | \
 		~RGX_MMUCTRL_PD_DATA_PAGE_SIZE_CLRMSK | \
@@ -81,6 +91,18 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 		RGX_MMUCTRL_PC_DATA_VALID_EN)
 
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/*
+ * protection bits for MMU_VERSION >= 4
+ * MMU4 has no PENDING or PAGE_SIZE fields in PxE
+ */
+#define RGX_MMU4CTRL_PTE_PROTMASK	(RGX_MMUCTRL_PTE_PROTMASK & ~RGX_MMUCTRL_PT_DATA_ENTRY_PENDING_EN)
+
+#define RGX_MMU4CTRL_PDE_PROTMASK	(RGX_MMUCTRL_PD_DATA_VALID_EN)
+
+#define RGX_MMU4CTRL_PCE_PROTMASK	(RGX_MMUCTRL_PC_DATA_VALID_EN)
+#endif
+
 
 static MMU_PxE_CONFIG sRGXMMUPCEConfig;
 static MMU_DEVVADDR_CONFIG sRGXMMUTopLevelDevVAddrConfig;
@@ -167,6 +189,15 @@ static IMG_UINT32 RGXDerivePDEProt4(IMG_UINT32 uiProtFlags);
 static IMG_UINT64 RGXDerivePTEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2DataPageSize);
 static IMG_UINT32 RGXDerivePTEProt4(IMG_UINT32 uiProtFlags);
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/* protection bits derivation functions for MMUv4 */
+static IMG_UINT64 RGXMMU4DerivePDEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2DataPageSize);
+static PVRSRV_ERROR RGXMMU4GetPageSizeFromPDE8(IMG_UINT64 ui64PDE, IMG_UINT32 *pui32Log2PageSize);
+static PVRSRV_ERROR RGXMMU4GetPageSizeFromVirtAddr(struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+												   IMG_DEV_VIRTADDR sDevVAddr,
+												   IMG_UINT32 *pui32Log2PageSize);
+#endif
+
 static PVRSRV_ERROR RGXGetPageSizeConfigCB(IMG_UINT32 uiLog2DataPageSize,
 		const MMU_PxE_CONFIG **ppsMMUPDEConfig,
 		const MMU_PxE_CONFIG **ppsMMUPTEConfig,
@@ -180,8 +211,51 @@ static PVRSRV_ERROR RGXGetPageSizeFromPDE8(IMG_UINT64 ui64PDE, IMG_UINT32 *pui32
 
 static MMU_DEVICEATTRIBS sRGXMMUDeviceAttributes;
 
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+/* This is a basis for a pattern of parity bit values for consecutive VAs.
+   For each PT with 512 entries we'd get either this pattern or its reverse. */
+static const IMG_UINT8 ui8ParityPTPattern[512] = {
+    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
+    1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
+    1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0,
+    0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+    1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0,
+    0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1,
+    0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1,
+    1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
+    1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
+    0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1,
+    1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
+    0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0,
+    0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0,
+    1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0,
+    0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0,
+    0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
+    1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1,
+    1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1};
+#endif
+
 PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
+
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK) || defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+#endif
+
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	IMG_BOOL bHaveParity = RGX_IS_FEATURE_SUPPORTED(psDevInfo, MH_PARITY);
+#endif
+
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	IMG_BOOL bHaveMMU4 = (RGX_GET_FEATURE_VALUE(psDevInfo, MMU_VERSION) >= 4);
+#define RGX_GET_MMUCTRL_PROTMASK(entry) \
+	(bHaveMMU4 ? RGX_MMU4CTRL_##entry##_PROTMASK : RGX_MMUCTRL_##entry##_PROTMASK)
+#else
+#define RGX_GET_MMUCTRL_PROTMASK(entry) RGX_MMUCTRL_##entry##_PROTMASK
+#endif
+
 	/* Setup of Px Entries:
 	 *
 	 *
@@ -237,7 +311,8 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPCEConfig.uiAddrShift = 4;         /* Shift this many bits to get PD address */
 	sRGXMMUPCEConfig.uiAddrLog2Align = 12;    /* Alignment of PD physical addresses. */
 
-	sRGXMMUPCEConfig.uiProtMask = RGX_MMUCTRL_PCE_PROTMASK; /* Mask to get the status bits (pending | valid)*/
+	sRGXMMUPCEConfig.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PCE); /* Mask to get the status bits */
+
 	sRGXMMUPCEConfig.uiProtShift = 0;                       /* Shift this many bits to get the status bits */
 
 	sRGXMMUPCEConfig.uiValidEnMask = RGX_MMUCTRL_PC_DATA_VALID_EN;     /* Mask to get entry valid bit of the PC */
@@ -279,7 +354,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_4KBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_4KBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_4KBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_4KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_4KBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_4KBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
@@ -296,12 +371,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_4KBDP.uiAddrShift = 12;
 	sRGXMMUPTEConfig_4KBDP.uiAddrLog2Align = 12; /* Alignment of the physical addresses of the pages NOT PTs */
 
-	sRGXMMUPTEConfig_4KBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_4KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_4KBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_4KBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
 	sRGXMMUPTEConfig_4KBDP.uiValidEnShift = RGX_MMUCTRL_PT_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_4KBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_4KBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUDevVAddrConfig_4KBDP
 	 */
@@ -358,7 +441,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_16KBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_16KBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_16KBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_16KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_16KBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_16KBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
@@ -375,12 +458,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_16KBDP.uiAddrShift = 14;
 	sRGXMMUPTEConfig_16KBDP.uiAddrLog2Align = 14;
 
-	sRGXMMUPTEConfig_16KBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_16KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_16KBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_16KBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
 	sRGXMMUPTEConfig_16KBDP.uiValidEnShift = RGX_MMUCTRL_PT_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_16KBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_16KBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUDevVAddrConfig_16KBDP
 	 */
@@ -439,7 +530,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_64KBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_64KBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_64KBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_64KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_64KBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_64KBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
@@ -456,12 +547,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_64KBDP.uiAddrShift = 16;
 	sRGXMMUPTEConfig_64KBDP.uiAddrLog2Align = 16;
 
-	sRGXMMUPTEConfig_64KBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_64KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_64KBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_64KBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
 	sRGXMMUPTEConfig_64KBDP.uiValidEnShift = RGX_MMUCTRL_PT_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_64KBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_64KBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUDevVAddrConfig_64KBDP
 	 */
@@ -521,7 +620,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_256KBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_256KBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_256KBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_256KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_256KBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_256KBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
@@ -538,12 +637,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_256KBDP.uiAddrShift = 18;
 	sRGXMMUPTEConfig_256KBDP.uiAddrLog2Align = 18;
 
-	sRGXMMUPTEConfig_256KBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_256KBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_256KBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_256KBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
 	sRGXMMUPTEConfig_256KBDP.uiValidEnShift = RGX_MMUCTRL_PT_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_256KBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_256KBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUDevVAddrConfig_256KBDP
 	 */
@@ -606,7 +713,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_1MBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_1MBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_1MBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_1MBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_1MBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_1MBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
@@ -623,12 +730,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_1MBDP.uiAddrShift = 20;
 	sRGXMMUPTEConfig_1MBDP.uiAddrLog2Align = 20;
 
-	sRGXMMUPTEConfig_1MBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_1MBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_1MBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_1MBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
 	sRGXMMUPTEConfig_1MBDP.uiValidEnShift = RGX_MMUCTRL_PT_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_1MBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_1MBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUDevVAddrConfig_1MBDP
 	 */
@@ -691,12 +806,20 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPDEConfig_2MBDP.uiVarCtrlMask = IMG_UINT64_C(0x000000000e);
 	sRGXMMUPDEConfig_2MBDP.uiVarCtrlShift = 1;
 
-	sRGXMMUPDEConfig_2MBDP.uiProtMask = RGX_MMUCTRL_PDE_PROTMASK;
+	sRGXMMUPDEConfig_2MBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PDE);
 	sRGXMMUPDEConfig_2MBDP.uiProtShift = 0;
 
 	sRGXMMUPDEConfig_2MBDP.uiValidEnMask = RGX_MMUCTRL_PD_DATA_VALID_EN;
 	sRGXMMUPDEConfig_2MBDP.uiValidEnShift = RGX_MMUCTRL_PD_DATA_VALID_SHIFT;
 
+#if defined(RGX_FEATURE_MH_PARITY_BIT_MASK)
+	if (bHaveParity)
+	{
+		sRGXMMUPTEConfig_2MBDP.uiParityBitMask = RGX_MMUCTRL_PT_DATA_PT_PARITY_EN;
+		sRGXMMUPTEConfig_2MBDP.uiParityBitShift = RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+#endif
+
 	/*
 	 * Setup sRGXMMUPTEConfig_2MBDP
 	 */
@@ -708,7 +831,7 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUPTEConfig_2MBDP.uiAddrShift = 21;
 	sRGXMMUPTEConfig_2MBDP.uiAddrLog2Align = 21;
 
-	sRGXMMUPTEConfig_2MBDP.uiProtMask = RGX_MMUCTRL_PTE_PROTMASK;
+	sRGXMMUPTEConfig_2MBDP.uiProtMask = RGX_GET_MMUCTRL_PROTMASK(PTE);
 	sRGXMMUPTEConfig_2MBDP.uiProtShift = 0;
 
 	sRGXMMUPTEConfig_2MBDP.uiValidEnMask = RGX_MMUCTRL_PT_DATA_VALID_EN;
@@ -756,7 +879,39 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUDeviceAttributes.psBaseConfig = &sRGXMMUPCEConfig;
 	sRGXMMUDeviceAttributes.psTopLevelDevVAddrConfig = &sRGXMMUTopLevelDevVAddrConfig;
 
-	sRGXMMUDeviceAttributes.pfnTestPremapConfigureMMU = NULL;
+#if defined(PVRSRV_MMU_PARITY_ON_PTALLOC_AND_PTEUNMAP)
+{
+	IMG_UINT32 i;
+
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_4KBDP.uiNumEntriesPT   <= 512);
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_16KBDP.uiNumEntriesPT  <= 512);
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_64KBDP.uiNumEntriesPT  <= 512);
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_256KBDP.uiNumEntriesPT <= 512);
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_1MBDP.uiNumEntriesPT   <= 512);
+	PVR_ASSERT(sRGXMMUDevVAddrConfig_2MBDP.uiNumEntriesPT   <= 512);
+
+	PVR_ASSERT(sRGXMMUPTEConfig_4KBDP.uiBytesPerEntry   == 8);
+	PVR_ASSERT(sRGXMMUPTEConfig_16KBDP.uiBytesPerEntry  == 8);
+	PVR_ASSERT(sRGXMMUPTEConfig_64KBDP.uiBytesPerEntry  == 8);
+	PVR_ASSERT(sRGXMMUPTEConfig_256KBDP.uiBytesPerEntry == 8);
+	PVR_ASSERT(sRGXMMUPTEConfig_1MBDP.uiBytesPerEntry   == 8);
+	PVR_ASSERT(sRGXMMUPTEConfig_2MBDP.uiBytesPerEntry   == 8);
+
+	sRGXMMUDeviceAttributes.pui64PrecomputedAllocParity[0] =
+	    OSAllocZMem(sRGXMMUDevVAddrConfig_4KBDP.uiNumEntriesPT * sRGXMMUPTEConfig_4KBDP.uiBytesPerEntry);
+	sRGXMMUDeviceAttributes.pui64PrecomputedAllocParity[1] =
+	    OSAllocZMem(sRGXMMUDevVAddrConfig_4KBDP.uiNumEntriesPT * sRGXMMUPTEConfig_4KBDP.uiBytesPerEntry);
+
+	/* Generate two precomputed pages in host memory for zero-initialised PTs with parity bits set. */
+	for (i=0; i<sRGXMMUDevVAddrConfig_4KBDP.uiNumEntriesPT; i++)
+	{
+		sRGXMMUDeviceAttributes.pui64PrecomputedAllocParity[0][i] =
+		    ((IMG_UINT64)(ui8ParityPTPattern[i]))         << RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+		sRGXMMUDeviceAttributes.pui64PrecomputedAllocParity[1][i] =
+		    ((IMG_UINT64)(ui8ParityPTPattern[i] ? 0 : 1)) << RGX_MMUCTRL_PT_DATA_PT_PARITY_SHIFT;
+	}
+}
+#endif
 
 	/* Functions for deriving page table/dir/cat protection bits */
 	sRGXMMUDeviceAttributes.pfnDerivePCEProt8 = RGXDerivePCEProt8;
@@ -775,6 +930,18 @@ PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode)
 	sRGXMMUDeviceAttributes.pfnGetPageSizeFromPDE8 = RGXGetPageSizeFromPDE8;
 	sRGXMMUDeviceAttributes.pfnGetPageSizeFromVirtAddr = NULL;
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	if (bHaveMMU4)
+	{
+		/* override some of these functions for MMU4 as page size is not stored in PD entries */
+		sRGXMMUDeviceAttributes.pfnDerivePDEProt8 = RGXMMU4DerivePDEProt8;
+		sRGXMMUDeviceAttributes.pfnGetPageSizeFromPDE8 = RGXMMU4GetPageSizeFromPDE8;
+		sRGXMMUDeviceAttributes.pfnGetPageSizeFromVirtAddr = RGXMMU4GetPageSizeFromVirtAddr;
+	}
+#endif
+
+	sRGXMMUDeviceAttributes.ui32ValidPageSizeMask = RGXGetValidHeapPageSizeMask();
+
 	psDeviceNode->psMMUDevAttrs = &sRGXMMUDeviceAttributes;
 
 	return PVRSRV_OK;
@@ -910,8 +1077,8 @@ static IMG_UINT64 RGXDerivePDEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2Dat
 			break;
 		default:
 			PVR_DPF((PVR_DBG_ERROR,
-					"%s:%d: in function<%s>: Invalid parameter log2_page_size. Expected {12, 14, 16, 18, 20, 21}. Got [%u]",
-					__FILE__, __LINE__, __func__, uiLog2DataPageSize));
+					"%s: Invalid parameter log2_page_size. Expected {12, 14, 16, 18, 20, 21}. Got [%u]",
+					__func__, uiLog2DataPageSize));
 		}
 	}
 	return ret_value;
@@ -967,11 +1134,13 @@ static IMG_UINT64 RGXDerivePTEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2Dat
 		ui64MMUFlags |= RGX_MMUCTRL_PT_DATA_CC_EN;
 	}
 
+#if defined(RGX_MMUCTRL_PT_DATA_SLC_BYPASS_CTRL_EN)
 	/* cache setup */
 	if ((MMU_PROTFLAGS_CACHED & uiProtFlags) == 0)
 	{
 		ui64MMUFlags |= RGX_MMUCTRL_PT_DATA_SLC_BYPASS_CTRL_EN;
 	}
+#endif
 
 	if ((uiProtFlags & MMU_PROTFLAGS_INVALID) == 0)
 	{
@@ -983,6 +1152,17 @@ static IMG_UINT64 RGXDerivePTEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2Dat
 		ui64MMUFlags |= RGX_MMUCTRL_PT_DATA_PM_META_PROTECT_EN;
 	}
 
+#if defined(RGX_MMUCTRL_PT_DATA_AXCACHE_WBRWALLOC)
+	/**
+	 * Always enable caching on the fabric level cache irrespective of type of
+	 * cache coherent interconnect and memory cache attributes.
+	 * This needs to be updated, if selective caching policy needs to be
+	 * implemented based on cache attributes requested by caller and based on
+	 * cache coherent interconnect.
+	 */
+	ui64MMUFlags |= RGX_MMUCTRL_PT_DATA_AXCACHE_WBRWALLOC;
+#endif
+
 	return ui64MMUFlags;
 }
 
@@ -1145,3 +1325,97 @@ static PVRSRV_ERROR RGXGetPageSizeFromPDE8(IMG_UINT64 ui64PDE, IMG_UINT32 *pui32
 	}
 	return PVRSRV_OK;
 }
+
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/*************************************************************************/ /*!
+@Function       RGXMMU4DerivePDEProt8
+@Description    derive the PDE protection flags based on an 8 byte entry
+
+@Input          uiLog2DataPageSize: ignored as MMU4 doesn't put page size in PD entries.
+
+@Return         PVRSRV_ERROR
+*/ /**************************************************************************/
+static IMG_UINT64 RGXMMU4DerivePDEProt8(IMG_UINT32 uiProtFlags, IMG_UINT32 uiLog2DataPageSize)
+{
+	IMG_UINT64 ret_value = 0; /* 0 means invalid */
+	PVR_UNREFERENCED_PARAMETER(uiLog2DataPageSize);
+
+	if (!(uiProtFlags & MMU_PROTFLAGS_INVALID)) /* if not invalid */
+	{
+		/*  page size in range config registers. Bits in PD entries are reserved */
+		ret_value = RGX_MMUCTRL_PD_DATA_VALID_EN;
+	}
+	return ret_value;
+}
+
+
+/*************************************************************************/ /*!
+@Function       RGXMMU4GetPageSizeFromPDE8
+@Description    The upper layers should be such that this function is never called
+                as pages size are not stored in PD entries for MMU4.
+*/ /**************************************************************************/
+static PVRSRV_ERROR RGXMMU4GetPageSizeFromPDE8(IMG_UINT64 ui64PDE, IMG_UINT32 *pui32Log2PageSize)
+{
+	PVR_UNREFERENCED_PARAMETER(ui64PDE);
+	PVR_UNREFERENCED_PARAMETER(pui32Log2PageSize);
+
+	PVR_ASSERT(0 && "RGXMMU4GetPageSizeFromPDE8 called in error. MMU4 does not store page sizes in PDT.");
+	return PVRSRV_ERROR_MMU_INVALID_PAGE_SIZE_FOR_DEVICE;
+}
+
+
+/*************************************************************************/ /*!
+@Function       RGXMMU4GetPageSizeFromVirtAddr
+@Description    Get page size by walking through range config registers
+                looking for a match against the virtual address.
+*/ /**************************************************************************/
+static PVRSRV_ERROR RGXMMU4GetPageSizeFromVirtAddr(struct _PVRSRV_DEVICE_NODE_ *psDevNode,
+												   IMG_DEV_VIRTADDR sDevVAddr,
+												   IMG_UINT32 *pui32Log2PageSize)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDevNode->pvDevice;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_UINT32 i;
+
+	/* assume default of 4KB page size */
+	*pui32Log2PageSize = 12;
+
+	/* Loop through the range registers looking for the given target address */
+	for (i = 0; i < ARRAY_SIZE(psDevInfo->aui64MMUPageSizeRangeValue); ++i)
+	{
+		IMG_UINT64 ui64RangeVal = psDevInfo->aui64MMUPageSizeRangeValue[i];
+
+		if (ui64RangeVal != 0)
+		{
+			/* end addr in register is inclusive in the range so add 1 to move it over the end */
+			IMG_UINT64 ui64Base = ((ui64RangeVal & ~RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_BASE_ADDR_CLRMSK)
+												>> RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_BASE_ADDR_SHIFT)
+												<< RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_BASE_ADDR_ALIGNSHIFT;
+			IMG_UINT64 ui64End  = (((ui64RangeVal & ~RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_END_ADDR_CLRMSK)
+												>> RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_END_ADDR_SHIFT) + 1)
+												<< RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_END_ADDR_ALIGNSHIFT;
+
+			if ((sDevVAddr.uiAddr >= ui64Base) && (sDevVAddr.uiAddr < ui64End))
+			{
+				IMG_UINT32 ui32PageSizeField = (IMG_UINT32)((ui64RangeVal & ~RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_PAGE_SIZE_CLRMSK)
+														>> RGX_CR_MMU_PAGE_SIZE_RANGE_ONE_PAGE_SIZE_SHIFT);
+				if (ui32PageSizeField < 5)
+				{
+					*pui32Log2PageSize = (ui32PageSizeField << 1) + 12;   /* 12 (4K), 14 (16K), 16 (64K), 18 (256K), 20 (1MB) */
+				}
+				else if (ui32PageSizeField == 5)
+				{
+					*pui32Log2PageSize = 21;    /* 2MB */
+				}
+				else
+				{
+					eError = PVRSRV_ERROR_MMU_INVALID_PAGE_SIZE_FOR_DEVICE;
+				}
+				break;
+			}
+		}
+	}
+
+	return eError;
+}
+#endif
diff --git a/drivers/gpu/drm/img-rogue/rgxmmuinit.h b/drivers/gpu/drm/img-rogue/rgxmmuinit.h
index 0591628d6ad3..b70ddad0cb64 100644
--- a/drivers/gpu/drm/img-rogue/rgxmmuinit.h
+++ b/drivers/gpu/drm/img-rogue/rgxmmuinit.h
@@ -56,5 +56,4 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 PVRSRV_ERROR RGXMMUInit_Register(PVRSRV_DEVICE_NODE *psDeviceNode);
 PVRSRV_ERROR RGXMMUInit_Unregister(PVRSRV_DEVICE_NODE *psDeviceNode);
 
-
 #endif /* #ifndef SRVKM_RGXMMUINIT_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxmulticore.c b/drivers/gpu/drm/img-rogue/rgxmulticore.c
index 2c8b0cf9c34e..447c50a78e00 100644
--- a/drivers/gpu/drm/img-rogue/rgxmulticore.c
+++ b/drivers/gpu/drm/img-rogue/rgxmulticore.c
@@ -49,6 +49,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "multicore_defs.h"
 #include "allocmem.h"
 #include "pvr_debug.h"
+#include "rgxfwmemctx.h"
 
 /*
  * check that register defines match our hardcoded definitions.
@@ -152,16 +153,54 @@ PVRSRV_ERROR RGXInitMultiCoreInfo(PVRSRV_DEVICE_NODE *psDeviceNode)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
 #endif
-		bPowerWasDown = (psDeviceNode->psDevConfig->pfnGpuDomainPower(psDeviceNode) == PVRSRV_SYS_POWER_STATE_OFF);
+		bPowerWasDown = ! PVRSRVIsSystemPowered(psDeviceNode);
 
 		/* Power-up the device as required to read the registers */
-		if (bPowerWasDown)
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) && bPowerWasDown)
 		{
+			PVRSRVPowerLock(psDeviceNode);
 			eError = PVRSRVSetSystemPowerState(psDeviceNode->psDevConfig, PVRSRV_SYS_POWER_STATE_ON);
-			PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState ON");
+			if (eError != PVRSRV_OK)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "%s: PVRSRVSetSystemPowerState ON failed (%u)", __func__, eError));
+				PVRSRVPowerUnlock(psDeviceNode);
+				return eError;
+			}
 		}
 
-		ui32NumCores = OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MULTICORE_SYSTEM);
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+		{
+			IMG_UINT32 ui32FwTimeout = MAX_HW_TIME_US;
+
+			LOOP_UNTIL_TIMEOUT_US(ui32FwTimeout)
+			{
+				RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfOsInit->sRGXMulticoreInfo.ui32NumCores,
+		                               INVALIDATE);
+				if (*((volatile IMG_UINT32*)&psDevInfo->psRGXFWIfOsInit->sRGXMulticoreInfo.ui32NumCores))
+				{
+					/* No need to wait if the FW has already updated the values */
+					break;
+				}
+				OSWaitus(ui32FwTimeout/WAIT_TRY_COUNT);
+			} END_LOOP_UNTIL_TIMEOUT_US();
+
+			if (*((volatile IMG_UINT32*)&psDevInfo->psRGXFWIfOsInit->sRGXMulticoreInfo.ui32NumCores) == 0)
+			{
+				PVR_DPF((PVR_DBG_ERROR, "Multicore info not available for guest"));
+				return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
+			}
+
+			ui32NumCores = psDevInfo->psRGXFWIfOsInit->sRGXMulticoreInfo.ui32NumCores;
+
+			PVR_LOG(("RGX Guest Device initialised with %u %s",
+					 ui32NumCores, (ui32NumCores == 1U) ? "core" : "cores"));
+		}
+		else
+#endif
+		{
+			ui32NumCores = OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MULTICORE_SYSTEM);
+		}
 #if !defined(NO_HARDWARE)
 		/* check that the number of cores reported is in-bounds */
 		if (ui32NumCores > (RGX_CR_MULTICORE_SYSTEM_MASKFULL >> RGX_CR_MULTICORE_SYSTEM_GPU_COUNT_SHIFT))
@@ -178,19 +217,51 @@ PVRSRV_ERROR RGXInitMultiCoreInfo(PVRSRV_DEVICE_NODE *psDeviceNode)
 
 		/* allocate storage for capabilities */
 		psDevInfo->pui64MultiCoreCapabilities = OSAllocMem(ui32NumCores * sizeof(psDevInfo->pui64MultiCoreCapabilities[0]));
-		if (psDevInfo->pui64MultiCoreCapabilities == NULL)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to alloc memory for Multicore info", __func__));
-			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
+		PVR_LOG_GOTO_IF_NOMEM(psDevInfo->pui64MultiCoreCapabilities, eError, err);
 
 		psDevInfo->ui32MultiCoreNumCores = ui32NumCores;
 
 		for (i = 0; i < ui32NumCores; ++i)
 		{
 	#if !defined(NO_HARDWARE)
-			psDevInfo->pui64MultiCoreCapabilities[i] =
-							OSReadHWReg64(psDevInfo->pvRegsBaseKM, ui32MulticoreGPUReg) & RGX_CR_MULTICORE_GPU_MASKFULL;
+#if defined(RGX_NUM_DRIVERS_SUPPORTED) && (RGX_NUM_DRIVERS_SUPPORTED > 1)
+			if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+			{
+				psDevInfo->pui64MultiCoreCapabilities[i] = psDevInfo->psRGXFWIfOsInit->sRGXMulticoreInfo.aui64MultiCoreCapabilities[i];
+			}
+			else
+#endif
+			{
+				IMG_BOOL bMulticoreRegsMapped = (psDeviceNode->psDevConfig->ui32RegsSize > ui32MulticoreGPUReg);
+				void __iomem *pvCoreRegBase;
+				IMG_INT32 ui32MulticoreRegOffset;
+
+				if (bMulticoreRegsMapped)
+				{
+					pvCoreRegBase = psDevInfo->pvRegsBaseKM;
+					ui32MulticoreRegOffset = ui32MulticoreGPUReg;
+				}
+				else
+				{
+					/* the register bank of this core is not mapped */
+					IMG_CPU_PHYADDR sMultiCoreRegsBase = psDeviceNode->psDevConfig->sRegsCpuPBase;
+
+					sMultiCoreRegsBase.uiAddr += i*ui32MulticoreRegBankOffset;
+					pvCoreRegBase = (void __iomem *) OSMapPhysToLin(sMultiCoreRegsBase, psDeviceNode->psDevConfig->ui32RegsSize, PVRSRV_MEMALLOCFLAG_CPU_UNCACHED);
+					PVR_LOG_GOTO_IF_NOMEM(pvCoreRegBase, eError, err);
+
+					/* adjust the register offset to point inside the newly mapped range */
+					ui32MulticoreRegOffset = RGX_CR_MULTICORE_GPU;
+				}
+
+				psDevInfo->pui64MultiCoreCapabilities[i] =
+							OSReadHWReg64(pvCoreRegBase, ui32MulticoreRegOffset) & RGX_CR_MULTICORE_GPU_MASKFULL;
+
+				if (!bMulticoreRegsMapped)
+				{
+					OSUnMapPhysToLin((void __force *) pvCoreRegBase, psDeviceNode->psDevConfig->ui32RegsSize);
+				}
+			}
 	#else
 			/* emulation for what we think caps are */
 			psDevInfo->pui64MultiCoreCapabilities[i] =
@@ -214,9 +285,10 @@ PVRSRV_ERROR RGXInitMultiCoreInfo(PVRSRV_DEVICE_NODE *psDeviceNode)
 		}
 
         /* revert power state to what it was on entry to this function */
-		if (bPowerWasDown)
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) && bPowerWasDown)
 		{
 			eError = PVRSRVSetSystemPowerState(psDeviceNode->psDevConfig, PVRSRV_SYS_POWER_STATE_OFF);
+			PVRSRVPowerUnlock(psDeviceNode);
 			PVR_LOG_RETURN_IF_ERROR(eError, "PVRSRVSetSystemPowerState OFF");
 		}
 
@@ -230,6 +302,10 @@ PVRSRV_ERROR RGXInitMultiCoreInfo(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 	return eError;
+
+err:
+	RGXDeInitMultiCoreInfo(psDeviceNode);
+	return eError;
 }
 
 
diff --git a/drivers/gpu/drm/img-rogue/rgxpower.c b/drivers/gpu/drm/img-rogue/rgxpower.c
index 9bc7bf9b3b79..2d608b0f653d 100644
--- a/drivers/gpu/drm/img-rogue/rgxpower.c
+++ b/drivers/gpu/drm/img-rogue/rgxpower.c
@@ -72,9 +72,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #if defined(SUPPORT_LINUX_DVFS)
 #include "pvr_dvfs_device.h"
 #endif
-#if defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE) && defined(PDUMP)
-#include "os_apphint.h"
-#include "validation_soc.h"
+
+#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
+#include "pvr_gpufreq.h"
+#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
+
+#if defined(SUPPORT_PDVFS) && (PDVFS_COM == PDVFS_COM_HOST)
+#include "rgxpdvfs.h"
 #endif
 
 static PVRSRV_ERROR RGXFWNotifyHostTimeout(PVRSRV_RGXDEV_INFO *psDevInfo)
@@ -98,49 +102,68 @@ static PVRSRV_ERROR RGXFWNotifyHostTimeout(PVRSRV_RGXDEV_INFO *psDevInfo)
 
 static void _RGXUpdateGPUUtilStats(PVRSRV_RGXDEV_INFO *psDevInfo)
 {
-	RGXFWIF_GPU_UTIL_FWCB *psUtilFWCb;
-	IMG_UINT64 (*paui64DMOSLastWord)[RGXFW_MAX_NUM_OSIDS];
-	IMG_UINT64 (*paaui64DMOSStatsCounters)[RGXFW_MAX_NUM_OSIDS][RGXFWIF_GPU_UTIL_STATE_NUM];
+	RGXFWIF_GPU_UTIL_FW *psUtilFW;
 	IMG_UINT64 ui64LastPeriod;
 	IMG_UINT64 ui64LastState;
+	IMG_UINT64 ui64LastReducedState;
 	IMG_UINT64 ui64LastTime;
 	IMG_UINT64 ui64TimeNow;
-	RGXFWIF_DM eDM;
+	IMG_UINT32 ui32DriverID;
+	IMG_UINT64 ui64DMOSStatsCounter;
 
-	psUtilFWCb = psDevInfo->psRGXFWIfGpuUtilFWCb;
-	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFWCb, INVALIDATE);
-	paui64DMOSLastWord = &psUtilFWCb->aaui64DMOSLastWord[0];
-	paaui64DMOSStatsCounters = &psUtilFWCb->aaaui64DMOSStatsCounters[0];
+	psUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
+	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFW, INVALIDATE);
 
 	OSLockAcquire(psDevInfo->hGPUUtilLock);
 
 	ui64TimeNow = RGXFWIF_GPU_UTIL_GET_TIME(RGXTimeCorrGetClockns64(psDevInfo->psDeviceNode));
 
 	/* Update counters to account for the time since the last update */
-	ui64LastState  = RGXFWIF_GPU_UTIL_GET_STATE(psUtilFWCb->ui64GpuLastWord);
-	ui64LastTime   = RGXFWIF_GPU_UTIL_GET_TIME(psUtilFWCb->ui64GpuLastWord);
+	ui64LastState  = RGXFWIF_GPU_UTIL_GET_STATE(psUtilFW->ui64GpuLastWord);
+	ui64LastTime   = RGXFWIF_GPU_UTIL_GET_TIME(psUtilFW->ui64GpuLastWord);
 	ui64LastPeriod = RGXFWIF_GPU_UTIL_GET_PERIOD(ui64TimeNow, ui64LastTime);
-	psUtilFWCb->aui64GpuStatsCounters[ui64LastState] += ui64LastPeriod;
+	psUtilFW->aui64GpuStatsCounters[ui64LastState] += ui64LastPeriod;
 
 	/* Update state and time of the latest update */
-	psUtilFWCb->ui64GpuLastWord = RGXFWIF_GPU_UTIL_MAKE_WORD(ui64TimeNow, ui64LastState);
+	psUtilFW->ui64GpuLastWord = RGXFWIF_GPU_UTIL_MAKE_WORD(ui64TimeNow, ui64LastState);
+
+	/* convert last period into the same units as used by fw */
+	ui64TimeNow  = ui64TimeNow >> RGXFWIF_DM_OS_TIMESTAMP_SHIFT;
 
-	for (eDM = 0; eDM < psDevInfo->sDevFeatureCfg.ui32MAXDMCount; eDM++)
+	FOREACH_SUPPORTED_DRIVER(ui32DriverID)
 	{
-		IMG_UINT32 ui32DriverID;
+		RGXFWIF_GPU_STATS *psStats = &psUtilFW->sStats[ui32DriverID];
+		RGXFWIF_DM eDM;
 
-		FOREACH_SUPPORTED_DRIVER(ui32DriverID)
+		for (eDM = 0; eDM < RGXFWIF_GPU_UTIL_DM_MAX; eDM++)
 		{
-			ui64LastState  = RGXFWIF_GPU_UTIL_GET_STATE(psUtilFWCb->aaui64DMOSLastWord[eDM][ui32DriverID]);
-			ui64LastTime   = RGXFWIF_GPU_UTIL_GET_TIME(psUtilFWCb->aaui64DMOSLastWord[eDM][ui32DriverID]);
+			ui64LastState  = (IMG_UINT64)RGXFWIF_GPU_UTIL_GET_STATE32(psStats->aui32DMOSLastWord[eDM]);
+			ui64LastTime   = (IMG_UINT64)RGXFWIF_GPU_UTIL_GET_TIME32(psStats->aui32DMOSLastWord[eDM]) +
+			                 ((IMG_UINT64)psStats->aui32DMOSLastWordWrap[eDM] << 32);
 			ui64LastPeriod = RGXFWIF_GPU_UTIL_GET_PERIOD(ui64TimeNow, ui64LastTime);
-			paaui64DMOSStatsCounters[eDM][ui32DriverID][ui64LastState] += ui64LastPeriod;
+			/* for states statistics per DM per driver we only care about the time in Active state,
+			so we "combine" other states (Idle and Blocked) together */
+			ui64LastReducedState = (ui64LastState == RGXFWIF_GPU_UTIL_STATE_ACTIVE) ?
+			                       RGXFWIF_GPU_UTIL_STATE_ACTIVE : RGXFWIF_GPU_UTIL_STATE_INACTIVE;
+			ui64DMOSStatsCounter = (IMG_UINT64)psStats->aaui32DMOSStatsCounters[eDM][ui64LastReducedState] + ui64LastPeriod;
+			psStats->aaui32DMOSStatsCounters[eDM][ui64LastReducedState] = (IMG_UINT32)(ui64DMOSStatsCounter & IMG_UINT32_MAX);
+			if (ui64DMOSStatsCounter > IMG_UINT32_MAX)
+			{
+				psStats->aaui32DMOSCountersWrap[eDM][ui64LastReducedState] += (IMG_UINT32)(ui64DMOSStatsCounter >> 32);
+			}
 
 			/* Update state and time of the latest update */
-			paui64DMOSLastWord[eDM][ui32DriverID] = RGXFWIF_GPU_UTIL_MAKE_WORD(ui64TimeNow, ui64LastState);
+			psStats->aui32DMOSLastWord[eDM] = RGXFWIF_GPU_UTIL_MAKE_WORD32((ui64TimeNow & (IMG_UINT64)IMG_UINT32_MAX), ui64LastState);
+			if (ui64TimeNow > IMG_UINT32_MAX)
+			{
+				if (psStats->aui32DMOSLastWordWrap[eDM] != (IMG_UINT32)(ui64TimeNow >> 32))
+				{
+					psStats->aui32DMOSLastWordWrap[eDM] = (IMG_UINT32)(ui64TimeNow >> 32);
+				}
+			}
 		}
 	}
-	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFWCb, FLUSH);
+	RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfGpuUtilFW, FLUSH);
 
 	OSLockRelease(psDevInfo->hGPUUtilLock);
 }
@@ -148,185 +171,262 @@ static void _RGXUpdateGPUUtilStats(PVRSRV_RGXDEV_INFO *psDevInfo)
 static INLINE PVRSRV_ERROR RGXDoStop(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_ERROR eError;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
-#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
-	PVRSRV_DEVICE_CONFIG *psDevConfig = psDeviceNode->psDevConfig;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
-	if (psDevConfig->pfnTDRGXStop == NULL)
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	if (psDeviceNode->psDevConfig->pfnTDRGXStop == NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "RGXPrePowerState: TDRGXStop not implemented!"));
 		return PVRSRV_ERROR_NOT_IMPLEMENTED;
 	}
 
-	eError = psDevConfig->pfnTDRGXStop(psDevConfig->hSysData);
+	psDevInfo->bRGXPowered = IMG_FALSE;
+	eError = psDeviceNode->psDevConfig->pfnTDRGXStop(psDeviceNode->psDevConfig->hSysData);
 #else
-	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
-
 	eError = RGXStop(&psDevInfo->sLayerParams);
 #endif
 
 	return eError;
 }
 
-/*
-	RGXPrePowerState
-*/
-PVRSRV_ERROR RGXPrePowerState(IMG_HANDLE				hDevHandle,
-                              PVRSRV_DEV_POWER_STATE	eNewPowerState,
-                              PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
-                              PVRSRV_POWER_FLAGS		ePwrFlags)
+/*************************************************************************/ /*!
+@Function       RGXSendPowerOffKick
+@Description    Send a KCCB kick to power off the GPU FW. This function will wait
+                for completion of the command before exiting.
+
+@Input          psDeviceNode    The device node struct associated with the GPU.
+@Input          bForce          A boolean indicating if the power off command
+                                should be forced.
+
+@Return         Failure code if the virtual address is invalid.
+*/ /**************************************************************************/
+static PVRSRV_ERROR RGXSendPowerOffKick(PVRSRV_DEVICE_NODE *psDeviceNode,
+                                        IMG_BOOL bForce)
 {
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	RGXFWIF_KCCB_CMD sPowCmd;
+	IMG_UINT32 ui32CmdKCCBSlot;
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE    *psDeviceNode = hDevHandle;
 
-	if ((eNewPowerState != eCurrentPowerState) &&
-	    (eNewPowerState != PVRSRV_DEV_POWER_STATE_ON))
+	PVR_ASSERT(psDeviceNode != NULL);
+	PVR_ASSERT(psDeviceNode->pvDevice != NULL);
+
+	psDevInfo = psDeviceNode->pvDevice;
+
+	/* Send the Power off request to the FW */
+	sPowCmd.eCmdType = RGXFWIF_KCCB_CMD_POW;
+	sPowCmd.uCmdData.sPowData.ePowType = RGXFWIF_POW_OFF_REQ;
+	sPowCmd.uCmdData.sPowData.uPowerReqData.bForced = bForce;
+
+	eError = SyncPrimSet(psDevInfo->psPowSyncPrim, 0);
+	if (eError != PVRSRV_OK)
 	{
-		PVRSRV_RGXDEV_INFO    *psDevInfo = psDeviceNode->pvDevice;
-		RGXFWIF_KCCB_CMD      sPowCmd;
-		IMG_UINT32            ui32CmdKCCBSlot;
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to set Power sync prim",
+		         __func__));
+		return eError;
+	}
 
-		const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
+	eError = RGXSendCommandAndGetKCCBSlot(psDevInfo,
+	                                      &sPowCmd,
+	                                      PDUMP_FLAGS_NONE,
+	                                      &ui32CmdKCCBSlot);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to send Power off request",
+		         __func__));
+		return eError;
+	}
 
-		/* Send the Power off request to the FW */
-		sPowCmd.eCmdType = RGXFWIF_KCCB_CMD_POW;
-		sPowCmd.uCmdData.sPowData.ePowType = RGXFWIF_POW_OFF_REQ;
-		sPowCmd.uCmdData.sPowData.uPowerReqData.bForced = BITMASK_HAS(ePwrFlags, PVRSRV_POWER_FLAGS_FORCED);
+	/* Wait for the firmware to complete processing. It cannot use PVRSRVWaitForValueKM as it relies
+	 * on the EventObject which is signalled in this MISR */
+	return RGXPollForGPCommandCompletion(psDeviceNode,
+	                                     psDevInfo->psPowSyncPrim->pui32LinAddr,
+	                                     0x1, 0xFFFFFFFF);
+}
 
-		eError = SyncPrimSet(psDevInfo->psPowSyncPrim, 0);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to set Power sync prim",
-					__func__));
-			return eError;
-		}
+/*************************************************************************/ /*!
+@Function       RGXFinalisePowerOff
+@Description    Finalises the GPU power transition to off.
 
-		eError = RGXSendCommandAndGetKCCBSlot(psDevInfo,
-		                                      &sPowCmd,
-		                                      PDUMP_FLAGS_NONE,
-		                                      &ui32CmdKCCBSlot);
-		if (eError != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Failed to send Power off request",
-					__func__));
-			return eError;
-		}
+@Input          psDeviceNode    The device node struct associated with the GPU.
 
-		/* Wait for the firmware to complete processing. It cannot use PVRSRVWaitForValueKM as it relies
-		   on the EventObject which is signalled in this MISR */
-		eError = RGXPollForGPCommandCompletion(psDeviceNode,
-								  psDevInfo->psPowSyncPrim->pui32LinAddr,
-								  0x1, 0xFFFFFFFF);
+@Return         Result code indicating the success or reason for failure.
+*/ /**************************************************************************/
+static PVRSRV_ERROR RGXFinalisePowerOff(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
-		/* Check the Power state after the answer */
-		if (eError == PVRSRV_OK)
-		{
-			RGXFwSharedMemCacheOpValue(psFwSysData->ePowState,
-			                           INVALIDATE);
-			/* Finally, de-initialise some registers. */
-			if (psFwSysData->ePowState == RGXFWIF_POW_OFF)
-			{
-#if !defined(NO_HARDWARE)
-				IMG_UINT32 ui32idx;
+#if !defined(NO_HARDWARE) && !defined(SUPPORT_SYNC_IRQ)
+	IMG_UINT32 ui32idx;
+#endif
 
-				/* Driver takes the VZ Fw-KM connection down, preventing the
-				 * firmware from submitting further interrupts */
-				KM_SET_OS_CONNECTION(OFFLINE, psDevInfo);
-				KM_CONNECTION_CACHEOP(Os, FLUSH);
+	PVR_ASSERT(psDeviceNode != NULL);
+	PVR_ASSERT(psDeviceNode->pvDevice != NULL);
+
+	psDevInfo = psDeviceNode->pvDevice;
 
+#if !defined(NO_HARDWARE)
+	/* Driver takes the VZ Fw-KM connection down, preventing the
+		* firmware from submitting further interrupts */
+	KM_SET_OS_CONNECTION(OFFLINE, psDevInfo);
+	KM_CONNECTION_CACHEOP(Os, FLUSH);
+
+#if defined(SUPPORT_SYNC_IRQ)
+	/* Wait for the pending IRQ handlers to complete. */
+	OSSyncIRQ(psDeviceNode->psDevConfig->ui32IRQ);
+#else
 #if defined(RGX_FW_IRQ_OS_COUNTERS)
-				ui32idx = RGXFW_HOST_DRIVER_ID;
+	ui32idx = RGXFW_HOST_DRIVER_ID;
 #else
-				for_each_irq_cnt(ui32idx)
+	for_each_irq_cnt(ui32idx)
 #endif /* RGX_FW_IRQ_OS_COUNTERS */
-				{
-					IMG_UINT32 ui32IrqCnt;
-
-					get_irq_cnt_val(ui32IrqCnt, ui32idx, psDevInfo);
-
-					/* Wait for the pending FW processor to host interrupts to come back. */
-					eError = PVRSRVPollForValueKM(psDeviceNode,
-					                              (IMG_UINT32 __iomem *)&psDevInfo->aui32SampleIRQCount[ui32idx],
-					                              ui32IrqCnt,
-					                              0xffffffff,
-					                              POLL_FLAG_LOG_ERROR,
-					                              NULL);
-
-					if (eError != PVRSRV_OK)
-					{
-						PVR_DPF((PVR_DBG_ERROR,
-								"%s: Wait for pending interrupts failed (DevID %u)." MSG_IRQ_CNT_TYPE " %u Host: %u, FW: %u",
-								__func__,
-								psDeviceNode->sDevId.ui32InternalID,
-								ui32idx,
-								psDevInfo->aui32SampleIRQCount[ui32idx],
-								ui32IrqCnt));
-
-						RGX_WaitForInterruptsTimeout(psDevInfo);
-					}
-				}
+	{
+		IMG_UINT32 ui32IrqCnt;
+
+		get_irq_cnt_val(ui32IrqCnt, ui32idx, psDevInfo);
+
+		/* Wait for the pending FW processor to host interrupts to come back. */
+		eError = PVRSRVPollForValueKM(psDeviceNode,
+		                              (IMG_UINT32 __iomem *)&psDevInfo->aui32SampleIRQCount[ui32idx],
+		                              ui32IrqCnt,
+		                              0xffffffff,
+		                              POLL_FLAG_LOG_ERROR | POLL_FLAG_DEBUG_DUMP,
+		                              NULL);
+
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Wait for pending interrupts failed (DevID %u)." MSG_IRQ_CNT_TYPE " %u Host: %u, FW: %u",
+			         __func__,
+			         psDeviceNode->sDevId.ui32InternalID,
+			         ui32idx,
+			         psDevInfo->aui32SampleIRQCount[ui32idx],
+			         ui32IrqCnt));
+
+			RGX_WaitForInterruptsTimeout(psDevInfo);
+#if !defined(RGX_FW_IRQ_OS_COUNTERS)
+			break;
+#endif
+		}
+	}
+#endif /* SUPPORT_SYNC_IRQ */
 #endif /* NO_HARDWARE */
 
-				/* Update GPU frequency and timer correlation related data */
-				RGXTimeCorrEnd(psDeviceNode, RGXTIMECORR_EVENT_POWER);
+	/* Update GPU frequency and timer correlation related data */
+	RGXTimeCorrEnd(psDeviceNode, RGXTIMECORR_EVENT_POWER);
 
-				/* Update GPU state counters */
-				_RGXUpdateGPUUtilStats(psDevInfo);
+	/* Update GPU state counters */
+	_RGXUpdateGPUUtilStats(psDevInfo);
 
 #if defined(SUPPORT_LINUX_DVFS)
-				eError = SuspendDVFS(psDeviceNode);
-				if (eError != PVRSRV_OK)
-				{
-					PVR_DPF((PVR_DBG_ERROR, "%s: Failed to suspend DVFS", __func__));
-					return eError;
-				}
+	eError = SuspendDVFS(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to suspend DVFS", __func__));
+		return eError;
+	}
+#endif
+
+	eError = RGXDoStop(psDeviceNode);
+	if (eError != PVRSRV_OK)
+	{
+		/* Power down failures are treated as successful since the power was removed but logged. */
+		PVR_DPF((PVR_DBG_WARNING, "%s: RGXDoStop failed (%s)",
+		         __func__, PVRSRVGetErrorString(eError)));
+		psDevInfo->ui32ActivePMReqNonIdle++;
+		eError = PVRSRV_OK;
+	}
+
+	return eError;
+}
+
+/*************************************************************************/ /*!
+@Function       RGXPrePowerState
+@Description    Initial step for setting power state, to be followed by
+                RGXPostPowerState.
+
+@Input          psDeviceNode        The device node struct associated with the GPU.
+@Input          eNewPowerState      The power state the GPU is to transition to.
+@Input          eCurrentPowerState  The current power state of the GPU.
+@Input          ePwrFlags           Flags indicating the behaviour of the transition.
+
+@Return         Result code indicating the success or reason for failure.
+*/ /**************************************************************************/
+PVRSRV_ERROR RGXPrePowerState(PVRSRV_DEVICE_NODE *psDeviceNode,
+                              PVRSRV_DEV_POWER_STATE eNewPowerState,
+                              PVRSRV_DEV_POWER_STATE eCurrentPowerState,
+                              PVRSRV_POWER_FLAGS ePwrFlags)
+{
+	PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO*)psDeviceNode->pvDevice;
+	const RGXFWIF_SYSDATA *psFwSysData;
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+	IMG_BOOL              bDeviceOk;
 #endif
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
-				/* Firmware was successfully stopped, no further interrupts expected */
-				psDevInfo->bRGXPowered = IMG_FALSE;
+	PVR_ASSERT(psDevInfo != NULL);
 
-				eError = RGXDoStop(psDeviceNode);
-				if (eError != PVRSRV_OK)
-				{
-					/* Power down failures are treated as successful since the power was removed but logged. */
-					PVR_DPF((PVR_DBG_WARNING, "%s: RGXDoStop failed (%s)",
-							__func__, PVRSRVGetErrorString(eError)));
-					psDevInfo->ui32ActivePMReqNonIdle++;
-					eError = PVRSRV_OK;
-				}
-			}
-			else
-			{
-				/* the sync was updated but the pow state isn't off -> the FW denied the transition */
-				eError = PVRSRV_ERROR_DEVICE_POWER_CHANGE_DENIED;
-
-				if (BITMASK_HAS(ePwrFlags, PVRSRV_POWER_FLAGS_FORCED))
-				{	/* It is an error for a forced request to be denied */
-					PVR_DPF((PVR_DBG_ERROR,
-							 "%s: Failure to power off during a forced power off. FW: %d",
-							 __func__, psFwSysData->ePowState));
-				}
-			}
+	psFwSysData = psDevInfo->psRGXFWIfFwSysData;
+
+	if ((eNewPowerState == eCurrentPowerState) ||
+	    (eNewPowerState == PVRSRV_DEV_POWER_STATE_ON))
+	{
+		return PVRSRV_OK;
+	}
+
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+	bDeviceOk = (OSAtomicRead(&psDeviceNode->eHealthStatus) == PVRSRV_DEVICE_HEALTH_STATUS_OK);
+	if (bDeviceOk)
+#endif
+	{
+		IMG_BOOL bForce = IMG_FALSE;
+
+		if (BITMASK_HAS(ePwrFlags, PVRSRV_POWER_FLAGS_FORCED))
+		{
+			bForce = IMG_TRUE;
 		}
-		else if (eError == PVRSRV_ERROR_TIMEOUT)
+
+		eError = RGXSendPowerOffKick(psDeviceNode, bForce);
+		if (eError == PVRSRV_ERROR_TIMEOUT)
 		{
 			/* timeout waiting for the FW to ack the request: return timeout */
 			PVR_DPF((PVR_DBG_WARNING,
-					 "%s: Timeout waiting for powoff ack from the FW",
-					 __func__));
+			         "%s: Timeout waiting for powoff ack from the FW",
+			         __func__));
+			return eError;
 		}
-		else
+		else if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
-					 "%s: Error waiting for powoff ack from the FW (%s)",
-					 __func__, PVRSRVGetErrorString(eError)));
-			eError = PVRSRV_ERROR_DEVICE_POWER_CHANGE_FAILURE;
+			         "%s: Error waiting for powoff ack from the FW (%s)",
+			         __func__, PVRSRVGetErrorString(eError)));
+			return PVRSRV_ERROR_DEVICE_POWER_CHANGE_FAILURE;
 		}
 	}
 
-	return eError;
+	/* Check the Power state after the answer */
+	RGXFwSharedMemCacheOpValue(psFwSysData->ePowState, INVALIDATE);
+	if ((psFwSysData->ePowState != RGXFWIF_POW_OFF)
+#if defined(PVRSRV_FORCE_UNLOAD_IF_BAD_STATE)
+	    && (bDeviceOk)
+#endif
+		)
+	{
+		if (BITMASK_HAS(ePwrFlags, PVRSRV_POWER_FLAGS_FORCED))
+		{	/* It is an error for a forced request to be denied */
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Failure to power off during a forced power off. FW: %d",
+			         __func__, psFwSysData->ePowState));
+		}
+
+		/* the sync was updated but the pow state isn't off -> the FW denied the transition */
+		return PVRSRV_ERROR_DEVICE_POWER_CHANGE_DENIED;
+	}
+
+	return RGXFinalisePowerOff(psDeviceNode);
 }
 
 #if defined(SUPPORT_AUTOVZ)
@@ -336,7 +436,7 @@ static PVRSRV_ERROR _RGXWaitForGuestsToDisconnect(PVRSRV_DEVICE_NODE *psDeviceNo
 	PVRSRV_ERROR eError = PVRSRV_ERROR_TIMEOUT;
 	IMG_UINT32 ui32FwTimeout = (20 * SECONDS_TO_MICROSECONDS);
 
-	LOOP_UNTIL_TIMEOUT(ui32FwTimeout)
+	LOOP_UNTIL_TIMEOUT_US(ui32FwTimeout)
 	{
 		IMG_UINT32 ui32DriverID;
 		IMG_BOOL bGuestOnline = IMG_FALSE;
@@ -351,7 +451,8 @@ static PVRSRV_ERROR _RGXWaitForGuestsToDisconnect(PVRSRV_DEVICE_NODE *psDeviceNo
 					psDevInfo->psRGXFWIfFwSysData->asOsRuntimeFlagsMirror[ui32DriverID].bfOsState;
 
 			if ((eGuestState == RGXFW_CONNECTION_FW_ACTIVE) ||
-				(eGuestState == RGXFW_CONNECTION_FW_OFFLOADING))
+				(eGuestState == RGXFW_CONNECTION_FW_GRACEFUL_OFFLOAD) ||
+				(eGuestState == RGXFW_CONNECTION_FW_FORCED_OFFLOAD))
 			{
 				bGuestOnline = IMG_TRUE;
 				PVR_DPF((PVR_DBG_WARNING, "%s: Guest OS %u still online.", __func__, ui32DriverID));
@@ -382,7 +483,7 @@ static PVRSRV_ERROR _RGXWaitForGuestsToDisconnect(PVRSRV_DEVICE_NODE *psDeviceNo
 		}
 
 		OSSleepms(10);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (!PVRSRVPwrLockIsLockedByMe(psDeviceNode))
 	{
@@ -397,13 +498,12 @@ static PVRSRV_ERROR _RGXWaitForGuestsToDisconnect(PVRSRV_DEVICE_NODE *psDeviceNo
 /*
 	RGXVzPrePowerState
 */
-PVRSRV_ERROR RGXVzPrePowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXVzPrePowerState(PVRSRV_DEVICE_NODE		*psDeviceNode,
                                 PVRSRV_DEV_POWER_STATE	eNewPowerState,
                                 PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
                                 PVRSRV_POWER_FLAGS		ePwrFlags)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
 
 	PVR_LOG_RETURN_IF_FALSE((eNewPowerState != eCurrentPowerState), "no power change", eError);
 
@@ -411,7 +511,7 @@ PVRSRV_ERROR RGXVzPrePowerState(IMG_HANDLE				hDevHandle,
 	{
 		/* powering down */
 #if defined(SUPPORT_AUTOVZ)
-		if (PVRSRV_VZ_MODE_IS(HOST) && (!psDeviceNode->bAutoVzFwIsUp || psDeviceNode->bAutoVzAllowGPUPowerdown))
+		if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode) && (!psDeviceNode->bAutoVzFwIsUp || psDeviceNode->bAutoVzAllowGPUPowerdown))
 		{
 			if (psDeviceNode->bAutoVzFwIsUp)
 			{
@@ -454,60 +554,106 @@ PVRSRV_ERROR RGXVzPrePowerState(IMG_HANDLE				hDevHandle,
 			if (KM_FW_CONNECTION_IS(ACTIVE, psDevInfo) &&
 				KM_OS_CONNECTION_IS(ACTIVE, psDevInfo))
 			{
-				PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 				PVRSRV_ERROR eError = RGXFWSetFwOsState(psDevInfo, 0, RGXFWIF_OS_OFFLINE);
 				PVR_LOG_RETURN_IF_ERROR(eError, "RGXFWSetFwOsState");
 			}
 		}
 #endif
 		PVR_DPF((PVR_DBG_WARNING, "%s: %s driver powering down: bAutoVzFwIsUp = %s",
-								__func__, PVRSRV_VZ_MODE_IS(GUEST)? "GUEST" : "HOST",
+								__func__, PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)? "GUEST" : "HOST",
 								psDeviceNode->bAutoVzFwIsUp ? "TRUE" : "FALSE"));
 	}
 	else if (eCurrentPowerState != PVRSRV_DEV_POWER_STATE_ON)
 	{
 		/* powering up */
 		PVR_DPF((PVR_DBG_WARNING, "%s: %s driver powering up: bAutoVzFwIsUp = %s",
-								__func__, PVRSRV_VZ_MODE_IS(GUEST)? "GUEST" : "HOST",
+								__func__, PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)? "GUEST" : "HOST",
 								psDeviceNode->bAutoVzFwIsUp ? "TRUE" : "FALSE"));
 
 	}
 
-	if (!(PVRSRV_VZ_MODE_IS(GUEST) || (psDeviceNode->bAutoVzFwIsUp)))
+	if (!(PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) || (psDeviceNode->bAutoVzFwIsUp)))
 	{
 		/* call regular device power function */
-		eError = RGXPrePowerState(hDevHandle, eNewPowerState, eCurrentPowerState, ePwrFlags);
+		eError = RGXPrePowerState(psDeviceNode, eNewPowerState, eCurrentPowerState, ePwrFlags);
 	}
 
 	return eError;
 }
 
+#if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
+static PVRSRV_ERROR RGXVzWaitFirmwareReady(PVRSRV_RGXDEV_INFO *psDevInfo)
+{
+	KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
+	if (!KM_FW_CONNECTION_IS(READY, psDevInfo))
+	{
+		PVR_LOG(("%s: Firmware Connection is not in Ready state. Waiting for Firmware ...", __func__));
+	}
+
+	LOOP_UNTIL_TIMEOUT_US(RGX_VZ_CONNECTION_TIMEOUT_US)
+	{
+		KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
+		if (KM_FW_CONNECTION_IS(READY, psDevInfo))
+		{
+			PVR_LOG(("%s: Firmware Connection is Ready. Initialisation proceeding.", __func__));
+			break;
+		}
+		else
+		{
+			OSSleepms(10);
+		}
+	} END_LOOP_UNTIL_TIMEOUT_US();
+
+	KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
+	if (!KM_FW_CONNECTION_IS(READY, psDevInfo))
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Timed out waiting for the Firmware to enter Ready state.", __func__));
+		return PVRSRV_ERROR_TIMEOUT;
+	}
+
+	return PVRSRV_OK;
+}
+#endif
+
 /*
 	RGXVzPostPowerState
 */
-PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXVzPostPowerState(PVRSRV_DEVICE_NODE		*psDeviceNode,
                                  PVRSRV_DEV_POWER_STATE	eNewPowerState,
                                  PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
                                  PVRSRV_POWER_FLAGS		ePwrFlags)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 	PVR_LOG_RETURN_IF_FALSE((eNewPowerState != eCurrentPowerState), "no power change", eError);
 
-	if (!(PVRSRV_VZ_MODE_IS(GUEST) || (psDeviceNode->bAutoVzFwIsUp)))
+	if (!(PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) || (psDeviceNode->bAutoVzFwIsUp)))
 	{
+		if (eCurrentPowerState != PVRSRV_DEV_POWER_STATE_ON)
+		{
+			KM_SET_OS_CONNECTION(READY, psDevInfo);
+			KM_CONNECTION_CACHEOP(Os, FLUSH);
+		}
 		/* call regular device power function */
-		eError = RGXPostPowerState(hDevHandle, eNewPowerState, eCurrentPowerState, ePwrFlags);
+		eError = RGXPostPowerState(psDeviceNode, eNewPowerState, eCurrentPowerState, ePwrFlags);
+	}
+	else
+	{
+		KM_SET_OS_CONNECTION(OFFLINE, psDevInfo);
+		KM_CONNECTION_CACHEOP(Os, FLUSH);
 	}
 
 	if (eNewPowerState != PVRSRV_DEV_POWER_STATE_ON)
 	{
 		/* powering down */
-		PVR_LOG_RETURN_IF_FALSE((!psDeviceNode->bAutoVzFwIsUp), "AutoVz Fw active, power not changed", eError);
+		if (psDeviceNode->bAutoVzFwIsUp)
+		{
+			PVR_LOG(("%s: AutoVz Fw active, power not changed", __func__));
+			return eError;
+		}
 		PVR_DPF((PVR_DBG_WARNING, "%s: %s driver powering down: bAutoVzFwIsUp = %s",
-								__func__, PVRSRV_VZ_MODE_IS(GUEST)? "GUEST" : "HOST",
+								__func__, PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)? "GUEST" : "HOST",
 								psDeviceNode->bAutoVzFwIsUp ? "TRUE" : "FALSE"));
 
 #if !defined(SUPPORT_AUTOVZ_HW_REGS)
@@ -518,7 +664,7 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 		RGXFwSharedMemCacheOpPtr(psDevInfo->psRGXFWIfConnectionCtl, FLUSH);
 #endif /* defined(SUPPORT_AUTOVZ) && !defined(SUPPORT_AUTOVZ_HW_REGS) */
 
-		if (PVRSRV_VZ_MODE_IS(GUEST) || (psDeviceNode->bAutoVzFwIsUp))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) || (psDeviceNode->bAutoVzFwIsUp))
 		{
 #if defined(SUPPORT_AUTOVZ)
 			/* AutoVz Guests attempting to suspend have updated their connections earlier in RGXVzPrePowerState.
@@ -544,9 +690,9 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 		pbUpdatedFlag = &psDevInfo->psRGXFWIfOsInit->sRGXCompChecks.bUpdated;
 
 		PVR_DPF((PVR_DBG_WARNING, "%s: %s driver powering up: bAutoVzFwIsUp = %s",
-								__func__, PVRSRV_VZ_MODE_IS(GUEST)? "GUEST" : "HOST",
+								__func__, PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode)? "GUEST" : "HOST",
 								psDeviceNode->bAutoVzFwIsUp ? "TRUE" : "FALSE"));
-		if (PVRSRV_VZ_MODE_IS(GUEST))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			/* Guests don't execute the power transition callbacks, so update their RGXPowered flag here */
 			psDevInfo->bRGXPowered = IMG_TRUE;
@@ -554,39 +700,10 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 #if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
 			/* Guest drivers expect the firmware to have set its end of the
 			 * connection to Ready state by now. */
-			KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
-			if (!KM_FW_CONNECTION_IS(READY, psDevInfo))
-			{
-				PVR_DPF((PVR_DBG_WARNING, "%s: Firmware Connection is not in Ready state. Waiting for Firmware ...", __func__));
-			}
-
-			LOOP_UNTIL_TIMEOUT(RGX_VZ_CONNECTION_TIMEOUT_US)
-			{
-				KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
-				if (KM_FW_CONNECTION_IS(READY, psDevInfo))
-				{
-					PVR_DPF((PVR_DBG_MESSAGE, "%s: Firmware Connection is Ready. Initialisation proceeding.", __func__));
-					break;
-				}
-				else
-				{
-					OSSleepms(10);
-				}
-			} END_LOOP_UNTIL_TIMEOUT();
-
-			KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
-			if (!KM_FW_CONNECTION_IS(READY, psDevInfo))
-			{
-				PVR_DPF((PVR_DBG_ERROR, "%s: Timed out waiting for the Firmware to enter Ready state.", __func__));
-				return PVRSRV_ERROR_TIMEOUT;
-			}
+			eError = RGXVzWaitFirmwareReady(psDevInfo);
+			PVR_LOG_RETURN_IF_ERROR(eError, "RGXVzWaitFirmwareReady()");
 #endif /* RGX_VZ_STATIC_CARVEOUT_FW_HEAPS */
 
-			/* Guests can only access the register holding the connection states,
-			 * after the GPU is confirmed to be powered up */
-			KM_SET_OS_CONNECTION(READY, psDevInfo);
-			KM_CONNECTION_CACHEOP(Os, FLUSH);
-
 			OSWriteDeviceMem32WithWMB(pbUpdatedFlag, IMG_FALSE);
 
 			/* Kick an initial dummy command to make the firmware initialise all
@@ -599,15 +716,15 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 				RGXFWIF_KCCB_CMD sCmpKCCBCmd;
 				sCmpKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_HEALTH_CHECK;
 
+				KM_SET_OS_CONNECTION(READY, psDevInfo);
+				KM_CONNECTION_CACHEOP(Os, FLUSH);
+
 				eError = RGXSendCommand(psDevInfo, &sCmpKCCBCmd, PDUMP_FLAGS_CONTINUOUS);
 				PVR_LOG_RETURN_IF_ERROR(eError, "RGXSendCommand()");
 			}
 		}
 		else
 		{
-			KM_SET_OS_CONNECTION(READY, psDevInfo);
-			KM_CONNECTION_CACHEOP(Os, FLUSH);
-
 #if defined(SUPPORT_AUTOVZ)
 			/* Disable power callbacks that should not be run on virtualised drivers after the GPU
 			 * is fully initialised: system layer pre/post functions and driver idle requests.
@@ -616,14 +733,33 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 									&RGXVzPrePowerState, &RGXVzPostPowerState,
 									NULL, NULL, NULL, NULL);
 
-			/* During first-time boot the flag is set here, while subsequent reboots will already
-			 * have set it earlier in RGXInit. Set to true from this point onwards in any case. */
-			psDeviceNode->bAutoVzFwIsUp = IMG_TRUE;
+			/* AutoVz Host driver reconnecting to running Firmware */
+			if (psDeviceNode->bAutoVzFwIsUp)
+			{
+				/* Firmware already running, send a KCCB command to establish the new connection */
+				RGXFWIF_KCCB_CMD sCmpKCCBCmd;
+				sCmpKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_HEALTH_CHECK;
+
+				eError = RGXVzWaitFirmwareReady(psDevInfo);
+				PVR_LOG_RETURN_IF_ERROR(eError, "RGXVzWaitFirmwareReady()");
+
+				KM_SET_OS_CONNECTION(READY, psDevInfo);
+				KM_CONNECTION_CACHEOP(Os, FLUSH);
+
+				eError = RGXSendCommand(psDevInfo, &sCmpKCCBCmd, PDUMP_FLAGS_CONTINUOUS);
+				PVR_LOG_RETURN_IF_ERROR(eError, "RGXSendCommand()");
+			}
+			else
+			{
+				/* During first-time boot the flag is set here, while subsequent reboots will already
+				 * have set it earlier in RGXInit. Set to true from this point on. */
+				psDeviceNode->bAutoVzFwIsUp = IMG_TRUE;
+			}
 #endif
 		}
 
 		/* Wait for the firmware to accept and enable the connection with this OS by setting its state to Active */
-		LOOP_UNTIL_TIMEOUT(RGX_VZ_CONNECTION_TIMEOUT_US)
+		LOOP_UNTIL_TIMEOUT_US(RGX_VZ_CONNECTION_TIMEOUT_US)
 		{
 			KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 			if (KM_FW_CONNECTION_IS(ACTIVE, psDevInfo))
@@ -636,7 +772,7 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 				PVR_DPF((PVR_DBG_WARNING, "%s: Firmware Connection is not in Active state. Waiting for Firmware ...", __func__));
 				OSSleepms(10);
 			}
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		KM_CONNECTION_CACHEOP(Fw, INVALIDATE);
 		if (!KM_FW_CONNECTION_IS(ACTIVE, psDevInfo))
@@ -645,19 +781,19 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 			return PVRSRV_ERROR_TIMEOUT;
 		}
 
-		if (PVRSRV_VZ_MODE_IS(GUEST))
+		if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			/* poll on the Firmware supplying the compatibility data */
-			LOOP_UNTIL_TIMEOUT(ui32FwTimeout)
+			LOOP_UNTIL_TIMEOUT_US(ui32FwTimeout)
 			{
 				if (*pbUpdatedFlag)
 				{
 					break;
 				}
 				OSSleepms(10);
-			} END_LOOP_UNTIL_TIMEOUT();
+			} END_LOOP_UNTIL_TIMEOUT_US();
 
-			PVR_LOG_RETURN_IF_FALSE(*pbUpdatedFlag, "Firmware does not respond with compatibility data. ", PVRSRV_ERROR_TIMEOUT);
+			PVR_LOG_RETURN_IF_FALSE(*pbUpdatedFlag, "Firmware does not respond with compatibility data.", PVRSRV_ERROR_TIMEOUT);
 		}
 
 		KM_SET_OS_CONNECTION(ACTIVE, psDevInfo);
@@ -729,6 +865,7 @@ static INLINE void RGXCheckFWBootStage(PVRSRV_RGXDEV_INFO *psDevInfo)
 static INLINE PVRSRV_ERROR RGXDoStart(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_ERROR eError;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 	PVRSRV_DEVICE_CONFIG *psDevConfig = psDeviceNode->psDevConfig;
@@ -740,9 +877,12 @@ static INLINE PVRSRV_ERROR RGXDoStart(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 	eError = psDevConfig->pfnTDRGXStart(psDevConfig->hSysData);
-#else
-	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
+	if (eError == PVRSRV_OK)
+	{
+		psDevInfo->bRGXPowered = IMG_TRUE;
+	}
+#else
 	eError = RGXStart(&psDevInfo->sLayerParams);
 #endif
 
@@ -862,238 +1002,116 @@ static PVRSRV_ERROR RGXVirtualisationPowerupSidebandTest(PVRSRV_DEVICE_NODE	 *ps
 }
 #endif /* defined(SUPPORT_GPUVIRT_VALIDATION_MTS) */
 
-#if defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE) && defined(PDUMP)
-#define SCRATCH_VALUE  (0x12345678U)
 
-static void RGXRiscvDebugModuleTest(PVRSRV_RGXDEV_INFO *psDevInfo)
+/*
+	RGXPostPowerState
+*/
+PVRSRV_ERROR RGXPostPowerState(PVRSRV_DEVICE_NODE		*psDeviceNode,
+                               PVRSRV_DEV_POWER_STATE	eNewPowerState,
+                               PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
+                               PVRSRV_POWER_FLAGS		ePwrFlags)
 {
-	void *pvAppHintState = NULL;
-	const IMG_BOOL bDefaultFalse = IMG_FALSE;
-	IMG_BOOL bRunRiscvDmiTest;
-
-	IMG_UINT32 *pui32FWCode = NULL;
-	PVRSRV_ERROR eError;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	PVRSRV_ERROR eError = PVRSRV_OK;
 
-	OSCreateAppHintState(&pvAppHintState);
-	OSGetAppHintBOOL(APPHINT_NO_DEVICE, pvAppHintState, RiscvDmiTest,
-	                   &bDefaultFalse, &bRunRiscvDmiTest);
-	OSFreeAppHintState(pvAppHintState);
+	PVR_UNREFERENCED_PARAMETER(ePwrFlags);
 
-	if (bRunRiscvDmiTest == IMG_FALSE)
+	if ((eNewPowerState == eCurrentPowerState) ||
+	    (eCurrentPowerState != PVRSRV_DEV_POWER_STATE_OFF))
 	{
-		return;
-	}
-
-	eError = DevmemAcquireCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc, (void **)&pui32FWCode);
+		PDUMPCOMMENT(psDeviceNode,
+		             "RGXPostPowerState: Current state: %d, New state: %d",
+		             eCurrentPowerState, eNewPowerState);
 
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-		         "%s: Error acquiring FW code memory pointer (%s)",
-		         __func__,
-		         PVRSRVGetErrorString(eError)));
+		return PVRSRV_OK;
 	}
 
-	PDumpIfKM(psDevInfo->psDeviceNode, "ENABLE_RISCV_DMI_TEST", PDUMP_FLAGS_CONTINUOUS);
-	PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode, PDUMP_FLAGS_CONTINUOUS, "DMI_TEST BEGIN");
-
-	RGXRiscvHalt(psDevInfo);
-
-	/*
-	 * Test RISC-V register reads/writes.
-	 * RGXRiscv[Write/Poll]Reg are used to access internal RISC-V registers
-	 * via debug module.
-	 */
-
-	/* Write RISC-V mscratch register */
-	RGXRiscvWriteReg(psDevInfo, RGXRISCVFW_MSCRATCH_ADDR, SCRATCH_VALUE);
-	/* Read RISC-V misa register (compare against default standard value) */
-	RGXRiscvPollReg(psDevInfo,  RGXRISCVFW_MISA_ADDR,     RGXRISCVFW_MISA_VALUE);
-	/* Read RISC-V mscratch register (compare against previously written value) */
-	RGXRiscvPollReg(psDevInfo,  RGXRISCVFW_MSCRATCH_ADDR, SCRATCH_VALUE);
-
-	/*
-	 * Test RISC-V memory reads/writes.
-	 * RGXRiscv[Write/Poll]Mem are used to access system memory via debug module
-	 * (from RISC-V point of view).
-	 */
-
-	if (pui32FWCode != NULL)
-	{
-		IMG_UINT32 ui32Tmp;
-		IMG_UINT32 ui32FWBootCodeRemap;
+	/* Update timer correlation related data */
+	RGXTimeCorrBegin(psDeviceNode, RGXTIMECORR_EVENT_POWER);
 
-		/* Get the FW boot code remap */
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-		if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) >= 4)
-		{
-			ui32FWBootCodeRemap = RGXRISCVFW_BOOTLDR_CODE_REMAP_SECURE;
-		}
-		else
-#endif
-		{
-			ui32FWBootCodeRemap = RGXRISCVFW_BOOTLDR_CODE_REMAP;
-		}
+	/* Update GPU state counters */
+	_RGXUpdateGPUUtilStats(psDevInfo);
 
-		/* Acquire pointer to FW code (bootloader) */
-		pui32FWCode += RGXGetFWImageSectionOffset(NULL, RISCV_UNCACHED_CODE) / sizeof(IMG_UINT32);
-		/* Save FW code at address (bootloader) */
-		ui32Tmp = *pui32FWCode;
+	eError = RGXDoStart(psDeviceNode);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXDoStart", fail);
 
-		/* Write FW code at address (bootloader) */
-		RGXWriteFWModuleAddr(psDevInfo, ui32FWBootCodeRemap,     SCRATCH_VALUE);
-		/* Read FW code at address (bootloader + 4) (compare against value read from Host) */
-		RGXRiscvPollMem(psDevInfo,  ui32FWBootCodeRemap + 4, *(pui32FWCode + 1));
-		/* Read FW code at address (bootloader) (compare against previously written value) */
-		RGXRiscvPollMem(psDevInfo,  ui32FWBootCodeRemap,     SCRATCH_VALUE);
-		/* Restore FW code at address (bootloader) */
-		RGXWriteFWModuleAddr(psDevInfo, ui32FWBootCodeRemap,     ui32Tmp);
+	OSMemoryBarrier(NULL);
 
-		DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc);
-	}
 
 	/*
-	 * Test GPU register reads/writes.
-	 * RGXRiscv[Write/Poll]Mem are used to access GPU registers via debug module
-	 * (from RISC-V point of view).
-	 * Note that system memory and GPU register accesses both use the same
-	 * debug module interface, targeting different address ranges.
-	 */
-
-	/* Write SCRATCH0 from the Host */
-	PDUMPREG32(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME, RGX_CR_SCRATCH0,
-	           SCRATCH_VALUE, PDUMP_FLAGS_CONTINUOUS);
-	/* Read SCRATCH0 */
-	RGXRiscvPollMem(psDevInfo,  RGXRISCVFW_SOCIF_BASE | RGX_CR_SCRATCH0, SCRATCH_VALUE);
-	/* Write SCRATCH0 */
-	RGXWriteFWModuleAddr(psDevInfo, RGXRISCVFW_SOCIF_BASE | RGX_CR_SCRATCH0, ~SCRATCH_VALUE);
-	/* Read SCRATCH0 from the Host */
-	PDUMPREGPOL(psDevInfo->psDeviceNode, RGX_PDUMPREG_NAME, RGX_CR_SCRATCH0,
-	            ~SCRATCH_VALUE, 0xFFFFFFFFU,
-	            PDUMP_FLAGS_CONTINUOUS, PDUMP_POLL_OPERATOR_EQUAL);
-
-	RGXRiscvResume(psDevInfo);
-
-	PDUMPCOMMENTWITHFLAGS(psDevInfo->psDeviceNode, PDUMP_FLAGS_CONTINUOUS, "DMI_TEST END");
-	PDumpFiKM(psDevInfo->psDeviceNode, "ENABLE_RISCV_DMI_TEST", PDUMP_FLAGS_CONTINUOUS);
-}
-#endif
-
-/*
-	RGXPostPowerState
-*/
-PVRSRV_ERROR RGXPostPowerState(IMG_HANDLE				hDevHandle,
-                               PVRSRV_DEV_POWER_STATE	eNewPowerState,
-                               PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
-                               PVRSRV_POWER_FLAGS		ePwrFlags)
-{
-	PVRSRV_DEVICE_NODE	 *psDeviceNode = hDevHandle;
-	PVRSRV_RGXDEV_INFO	 *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_ERROR		 eError = PVRSRV_OK;
-
-	if ((eNewPowerState != eCurrentPowerState) &&
-	    (eCurrentPowerState != PVRSRV_DEV_POWER_STATE_ON))
+		* Check whether the FW has started by polling on bFirmwareStarted flag
+		*/
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->bFirmwareStarted,
+	                           INVALIDATE);
+	if (PVRSRVPollForValueKM(psDeviceNode,
+	                         (IMG_UINT32 __iomem *)&psDevInfo->psRGXFWIfSysInit->bFirmwareStarted,
+	                         IMG_TRUE,
+	                         0xFFFFFFFF,
+	                         POLL_FLAG_LOG_ERROR | POLL_FLAG_DEBUG_DUMP,
+	                         RGXFwSharedMemCacheOpExecPfn) != PVRSRV_OK)
 	{
-		if (eCurrentPowerState == PVRSRV_DEV_POWER_STATE_OFF)
-		{
-			/* Update timer correlation related data */
-			RGXTimeCorrBegin(psDeviceNode, RGXTIMECORR_EVENT_POWER);
-
-			/* Update GPU state counters */
-			_RGXUpdateGPUUtilStats(psDevInfo);
-
-			eError = RGXDoStart(psDeviceNode);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXDoStart", fail);
-
-			OSMemoryBarrier(NULL);
-
-			/*
-			 * Check whether the FW has started by polling on bFirmwareStarted flag
-			 */
-			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->bFirmwareStarted,
-			                           INVALIDATE);
-			if (PVRSRVPollForValueKM(psDeviceNode,
-			                         (IMG_UINT32 __iomem *)&psDevInfo->psRGXFWIfSysInit->bFirmwareStarted,
-			                         IMG_TRUE,
-			                         0xFFFFFFFF,
-			                         POLL_FLAG_LOG_ERROR | POLL_FLAG_DEBUG_DUMP,
-			                         RGXFwSharedMemCacheOpExecPfn) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR, "RGXPostPowerState: Polling for 'FW started' flag failed."));
-				eError = PVRSRV_ERROR_TIMEOUT;
+		PVR_DPF((PVR_DBG_ERROR, "RGXPostPowerState: Polling for 'FW started' flag failed."));
+		eError = PVRSRV_ERROR_TIMEOUT;
 
 #if defined(TRACK_FW_BOOT)
-				RGXCheckFWBootStage(psDevInfo);
+		RGXCheckFWBootStage(psDevInfo);
 #endif
 
-				/*
-				 * When bFirmwareStarted fails some info may be gained by doing the following
-				 * debug dump but unfortunately it could be potentially dangerous if the reason
-				 * for not booting is the GPU power is not ON. However, if we have reached this
-				 * point the System Layer has returned without errors, we assume the GPU power
-				 * is indeed ON.
-				 */
-				RGXDumpRGXDebugSummary(NULL, NULL, psDeviceNode->pvDevice, IMG_TRUE);
-				RGXDumpRGXRegisters(NULL, NULL, psDeviceNode->pvDevice);
-
-				PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVPollForValueKM(bFirmwareStarted)", fail);
-			}
+		/*
+		* When bFirmwareStarted fails some info may be gained by doing the following
+		* debug dump but unfortunately it could be potentially dangerous if the reason
+		* for not booting is the GPU power is not ON. However, if we have reached this
+		* point the System Layer has returned without errors, we assume the GPU power
+		* is indeed ON.
+		*/
+		RGXDumpRGXDebugSummary(NULL, NULL, psDeviceNode->pvDevice, IMG_TRUE);
+		RGXDumpRGXRegisters(NULL, NULL, psDeviceNode->pvDevice);
+
+		PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVPollForValueKM(bFirmwareStarted)", fail);
+	}
 
 #if defined(PDUMP)
-			PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS, "Wait for the Firmware to start.");
-			eError = DevmemPDumpDevmemPol32(psDevInfo->psRGXFWIfSysInitMemDesc,
-			                                offsetof(RGXFWIF_SYSINIT, bFirmwareStarted),
-			                                IMG_TRUE,
-			                                0xFFFFFFFFU,
-			                                PDUMP_POLL_OPERATOR_EQUAL,
-			                                PDUMP_FLAGS_CONTINUOUS);
-
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-				         "RGXPostPowerState: problem pdumping POL for psRGXFWIfSysInitMemDesc (%d)",
-				         eError));
-				PVR_LOG_GOTO_IF_ERROR(eError, "DevmemPDumpDevmemPol32", fail);
-			}
+	PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS, "Wait for the Firmware to start.");
+	eError = DevmemPDumpDevmemPol32(psDevInfo->psRGXFWIfSysInitMemDesc,
+	                                offsetof(RGXFWIF_SYSINIT, bFirmwareStarted),
+	                                IMG_TRUE,
+	                                0xFFFFFFFFU,
+	                                PDUMP_POLL_OPERATOR_EQUAL,
+	                                PDUMP_FLAGS_CONTINUOUS);
+
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		         "RGXPostPowerState: problem pdumping POL for psRGXFWIfSysInitMemDesc (%d)",
+		         eError));
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemPDumpDevmemPol32", fail);
+	}
 
-#if defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE)
-			/* Check if the Validation IRQ flag is set */
-			if ((psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags & RGXFWIF_INICFG_VALIDATE_IRQ) != 0)
-			{
-				eError = PVRSRVValidateIrqs(psDeviceNode);
-				PVR_LOG_GOTO_IF_ERROR(eError, "PVRSRVValidateIrqs", fail);
-			}
-#endif /* defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE) */
 #endif /* defined(PDUMP) */
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION_MTS)
-			eError = RGXVirtualisationPowerupSidebandTest(psDeviceNode, psDevInfo->psRGXFWIfSysInit, psDevInfo);
-			PVR_LOG_GOTO_IF_ERROR(eError, "RGXVirtualisationPowerupSidebandTest", fail);
+	eError = RGXVirtualisationPowerupSidebandTest(psDeviceNode, psDevInfo->psRGXFWIfSysInit, psDevInfo);
+	PVR_LOG_GOTO_IF_ERROR(eError, "RGXVirtualisationPowerupSidebandTest", fail);
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(NO_HARDWARE) && defined(PDUMP)
-			RGXRiscvDebugModuleTest(psDevInfo);
-#endif
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
-			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp,
-			                           INVALIDATE);
-			PVRSRVSetFirmwareStartTime(psDeviceNode->psPowerDev,
-			                           psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp);
-			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp,
-			                           FLUSH);
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp,
+	                           INVALIDATE);
+	PVRSRVSetFirmwareStartTime(psDeviceNode->psPowerDev,
+	                           psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp);
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32FirmwareStartedTimeStamp,
+	                           FLUSH);
 #endif
 
-			RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32MarkerVal,
-			                           INVALIDATE);
-			HTBSyncPartitionMarker(psDevInfo->psRGXFWIfSysInit->ui32MarkerVal);
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfSysInit->ui32MarkerVal,
+	                           INVALIDATE);
+	HTBSyncPartitionMarker(psDevInfo->psRGXFWIfSysInit->ui32MarkerVal);
 
 #if defined(SUPPORT_LINUX_DVFS)
-			eError = ResumeDVFS(psDeviceNode);
-			PVR_LOG_GOTO_IF_ERROR(eError, "ResumeDVFS", fail);
+	eError = ResumeDVFS(psDeviceNode);
+	PVR_LOG_GOTO_IF_ERROR(eError, "ResumeDVFS", fail);
 #endif
-		}
-	}
 
 	PDUMPCOMMENT(psDeviceNode,
 	             "RGXPostPowerState: Current state: %d, New state: %d",
@@ -1110,16 +1128,14 @@ PVRSRV_ERROR RGXPostPowerState(IMG_HANDLE				hDevHandle,
 /*
 	RGXPreClockSpeedChange
 */
-PVRSRV_ERROR RGXPreClockSpeedChange(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPreClockSpeedChange(PVRSRV_DEVICE_NODE		*psDeviceNode,
                                     PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
 	const PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	const RGX_DATA *psRGXData = (RGX_DATA*)psDeviceNode->psDevConfig->hDevData;
+	__maybe_unused const RGX_DATA *psRGXData = (RGX_DATA*)psDeviceNode->psDevConfig->hDevData;
 	const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
-	PVR_UNREFERENCED_PARAMETER(psRGXData);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	PVR_DPF((PVR_DBG_MESSAGE, "RGXPreClockSpeedChange: RGX clock speed was %uHz",
 			psRGXData->psRGXTimingInfo->ui32CoreClockSpeed));
@@ -1140,17 +1156,16 @@ PVRSRV_ERROR RGXPreClockSpeedChange(IMG_HANDLE				hDevHandle,
 /*
 	RGXPostClockSpeedChange
 */
-PVRSRV_ERROR RGXPostClockSpeedChange(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPostClockSpeedChange(PVRSRV_DEVICE_NODE		*psDeviceNode,
                                      PVRSRV_DEV_POWER_STATE	eCurrentPowerState)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
 	const PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	const RGX_DATA *psRGXData = (RGX_DATA*)psDeviceNode->psDevConfig->hDevData;
 	const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_UINT32 ui32NewClockSpeed = psRGXData->psRGXTimingInfo->ui32CoreClockSpeed;
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	/* Update runtime configuration with the new value */
 	OSWriteDeviceMem32WithWMB(&psDevInfo->psRGXFWIfRuntimeCfg->ui32CoreClockSpeed,
@@ -1186,6 +1201,11 @@ PVRSRV_ERROR RGXPostClockSpeedChange(IMG_HANDLE				hDevHandle,
 			return eError;
 		}
 
+#if defined(PVRSRV_ANDROID_TRACE_GPU_FREQ)
+		GpuTraceFrequency(psDeviceNode->sDevId.ui32InternalID,
+				psRGXData->psRGXTimingInfo->ui32CoreClockSpeed);
+#endif /* defined(PVRSRV_ANDROID_TRACE_GPU_FREQ) */
+
 		PVR_DPF((PVR_DBG_MESSAGE, "RGXPostClockSpeedChange: RGX clock speed changed to %uHz",
 				psRGXData->psRGXTimingInfo->ui32CoreClockSpeed));
 	}
@@ -1194,48 +1214,65 @@ PVRSRV_ERROR RGXPostClockSpeedChange(IMG_HANDLE				hDevHandle,
 }
 
 /*!
- ******************************************************************************
+******************************************************************************
 
- @Function	RGXDustCountChange
+ @Function	RGXPowUnitsChange
 
- @Description
+ @Description Change power units state
 
-	Does change of number of DUSTs
-
- @Input	   hDevHandle : RGX Device Node
- @Input	   ui32NumberOfDusts : Number of DUSTs to make transition to
+ @Input	   psDeviceNode : RGX Device Node
+ @Input	   ui32PowUnits : On Rogue: Number of DUSTs to make transition to.
+                          On Volcanic: Mask containing power state of SPUs.
+                          Each bit corresponds to an SPU and value must be non-zero.
 
  @Return   PVRSRV_ERROR :
 
- ******************************************************************************/
-PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE		hDevHandle,
-                                IMG_UINT32		ui32NumberOfDusts)
-{
+******************************************************************************/
+PVRSRV_ERROR RGXPowUnitsChange(PVRSRV_DEVICE_NODE *psDeviceNode,
+                               IMG_UINT32 ui32PowUnits)
 
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+{
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_ERROR		eError;
-	RGXFWIF_KCCB_CMD	sDustCountChange;
-	IMG_UINT32			ui32MaxAvailableDusts = psDevInfo->sDevFeatureCfg.ui32MAXDustCount;
+	RGXFWIF_KCCB_CMD	sPowUnitsChange;
+	IMG_UINT32			ui32AvailablePowUnits;
 	IMG_UINT32			ui32CmdKCCBSlot;
 	RGXFWIF_RUNTIME_CFG *psRuntimeCfg = psDevInfo->psRGXFWIfRuntimeCfg;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
+
+#if defined(PVR_ARCH_VOLCANIC)
+	ui32AvailablePowUnits = psDevInfo->ui32AvailablePowUnitsMask;
 
-	if (ui32NumberOfDusts > ui32MaxAvailableDusts)
+	/**
+	 * Validate the input. At-least one PU must be powered on and all requested
+	 * PU's must be a subset of full PU mask.
+	 */
+	if ((ui32PowUnits == 0) || (ui32PowUnits & ~ui32AvailablePowUnits))
 	{
-		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: Invalid number of DUSTs (%u) while expecting value within <0,%u>. Error:%u",
+				"%s: Invalid Power Units mask requested (0x%X). Value should be non-zero and sub-set of 0x%X mask",
 				__func__,
-				ui32NumberOfDusts,
-				ui32MaxAvailableDusts,
-				eError));
-		return eError;
+				ui32PowUnits,
+				ui32AvailablePowUnits));
+		return PVRSRV_ERROR_INVALID_SPU_MASK;
+	}
+#else
+	ui32AvailablePowUnits = psDevInfo->sDevFeatureCfg.ui32MAXPowUnitCount;
+
+	if (ui32PowUnits > ui32AvailablePowUnits)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				"%s: Invalid number of DUSTs (%u) while expecting value within <0,%u>",
+				__func__,
+				ui32PowUnits,
+				ui32AvailablePowUnits));
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
+#endif
 
-	psRuntimeCfg->ui32DefaultDustsNumInit = ui32NumberOfDusts;
-	OSWriteMemoryBarrier(&psRuntimeCfg->ui32DefaultDustsNumInit);
-	RGXFwSharedMemCacheOpValue(psRuntimeCfg->ui32DefaultDustsNumInit, FLUSH);
+	psRuntimeCfg->ui32PowUnitsState = ui32PowUnits;
+	OSWriteMemoryBarrier(&psRuntimeCfg->ui32PowUnitsState);
+	RGXFwSharedMemCacheOpValue(psRuntimeCfg->ui32PowUnitsState, FLUSH);
 
 #if !defined(NO_HARDWARE)
 	{
@@ -1252,7 +1289,7 @@ PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE		hDevHandle,
 		{
 			eError = PVRSRV_ERROR_DEVICE_POWER_CHANGE_DENIED;
 			PVR_DPF((PVR_DBG_ERROR,
-					 "%s: Attempt to change dust count when not IDLE",
+					 "%s: Powered units state can not be changed when not IDLE",
 					 __func__));
 			return eError;
 		}
@@ -1267,25 +1304,34 @@ PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE		hDevHandle,
 		return eError;
 	}
 
-	sDustCountChange.eCmdType = RGXFWIF_KCCB_CMD_POW;
-	sDustCountChange.uCmdData.sPowData.ePowType = RGXFWIF_POW_NUM_UNITS_CHANGE;
-	sDustCountChange.uCmdData.sPowData.uPowerReqData.ui32NumOfDusts = ui32NumberOfDusts;
+	sPowUnitsChange.eCmdType = RGXFWIF_KCCB_CMD_POW;
+	sPowUnitsChange.uCmdData.sPowData.ePowType = RGXFWIF_POW_NUM_UNITS_CHANGE;
+	sPowUnitsChange.uCmdData.sPowData.uPowerReqData.ui32PowUnits = ui32PowUnits;
+#if defined(RGX_FEATURE_POWER_ISLAND_VERSION_MAX_VALUE_IDX)
+	sPowUnitsChange.uCmdData.sPowData.uPowerReqData.ui32RACUnits = 0;
+
+	if (RGX_GET_FEATURE_VALUE(psDevInfo, POWER_ISLAND_VERSION) >= 3)
+	{
+		sPowUnitsChange.uCmdData.sPowData.uPowerReqData.ui32RACUnits =
+			(1U << psDevInfo->sDevFeatureCfg.ui32MAXRACCount) - 1;
+	}
+#endif
 
 	PDUMPCOMMENT(psDeviceNode,
-	             "Scheduling command to change Dust Count to %u",
-	             ui32NumberOfDusts);
+	             "Scheduling command to change power units state to 0x%X",
+	             ui32PowUnits);
 	eError = RGXSendCommandAndGetKCCBSlot(psDeviceNode->pvDevice,
-	                                      &sDustCountChange,
+	                                      &sPowUnitsChange,
 	                                      PDUMP_FLAGS_NONE,
 	                                      &ui32CmdKCCBSlot);
 
 	if (eError != PVRSRV_OK)
 	{
 		PDUMPCOMMENT(psDeviceNode,
-		             "Scheduling command to change Dust Count failed. Error:%u",
+		             "Scheduling command to change power units state. Error:%u",
 		             eError);
 		PVR_DPF((PVR_DBG_ERROR,
-				 "%s: Scheduling KCCB to change Dust Count failed. Error:%u",
+				 "%s: Scheduling KCCB to change power units state. Error:%u",
 				 __func__, eError));
 		return eError;
 	}
@@ -1320,24 +1366,20 @@ PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE		hDevHandle,
 /*
  @Function	RGXAPMLatencyChange
 */
-PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE		hDevHandle,
-                                 IMG_UINT32		ui32ActivePMLatencyms,
-                                 IMG_BOOL		bActivePMLatencyPersistant)
+PVRSRV_ERROR RGXAPMLatencyChange(PVRSRV_DEVICE_NODE	*psDeviceNode,
+                                 IMG_UINT32			ui32ActivePMLatencyms,
+                                 IMG_BOOL			bActivePMLatencyPersistant)
 {
-
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_ERROR		eError;
 	RGXFWIF_RUNTIME_CFG	*psRuntimeCfg = psDevInfo->psRGXFWIfRuntimeCfg;
 	IMG_UINT32			ui32CmdKCCBSlot;
 	PVRSRV_DEV_POWER_STATE	ePowerState;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
-	eError = PVRSRVPowerLock(psDeviceNode);
-	if (eError != PVRSRV_OK)
+	if (psRuntimeCfg == NULL)
 	{
-		PVR_DPF((PVR_DBG_ERROR, "RGXAPMLatencyChange: Failed to acquire power lock"));
-		return eError;
+		return PVRSRV_ERROR_NOT_INITIALISED;
 	}
 
 	/* Update runtime configuration with the new values and ensure the
@@ -1350,6 +1392,19 @@ PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE		hDevHandle,
 	RGXFwSharedMemCacheOpValue(psRuntimeCfg->ui32ActivePMLatencyms, FLUSH);
 	RGXFwSharedMemCacheOpValue(psRuntimeCfg->bActivePMLatencyPersistant, FLUSH);
 
+	eError = PVRSRVPowerLock(psDeviceNode);
+	if (eError == PVRSRV_ERROR_SYSTEM_STATE_POWERED_OFF)
+	{
+		/* Power is off, APM latency will be read on next firmware boot */
+		return PVRSRV_OK;
+	}
+	else if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Failed to acquire power lock (%u)",
+		         __func__, eError));
+		return eError;
+	}
+
 	eError = PVRSRVGetDevicePowerState(psDeviceNode, &ePowerState);
 
 	if ((eError == PVRSRV_OK) && (ePowerState != PVRSRV_DEV_POWER_STATE_OFF))
@@ -1371,7 +1426,9 @@ PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE		hDevHandle,
 			PDUMPCOMMENT(psDeviceNode,
 			             "Scheduling command to change APM latency failed. Error:%u",
 			             eError);
-			PVR_DPF((PVR_DBG_ERROR, "RGXAPMLatencyChange: Scheduling KCCB to change APM latency failed. Error:%u", eError));
+			PVR_DPF((PVR_DBG_ERROR,
+			         "%s: Scheduling KCCB to change APM latency failed. Error:%u",
+			         __func__, eError));
 			goto ErrorExit;
 		}
 	}
@@ -1385,13 +1442,12 @@ PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE		hDevHandle,
 /*
 	RGXActivePowerRequest
 */
-PVRSRV_ERROR RGXActivePowerRequest(IMG_HANDLE hDevHandle)
+PVRSRV_ERROR RGXActivePowerRequest(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	const RGXFWIF_SYSDATA *psFwSysData = psDevInfo->psRGXFWIfFwSysData;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 
 	psDevInfo->ui32ActivePMReqTotal++;
@@ -1459,9 +1515,8 @@ PVRSRV_ERROR RGXActivePowerRequest(IMG_HANDLE hDevHandle)
 
 #define RGX_FORCED_IDLE_RETRY_COUNT 10
 
-PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPermitted)
+PVRSRV_ERROR RGXForcedIdleRequest(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_BOOL bDeviceOffPermitted)
 {
-	PVRSRV_DEVICE_NODE    *psDeviceNode = hDevHandle;
 	PVRSRV_RGXDEV_INFO    *psDevInfo = psDeviceNode->pvDevice;
 	RGXFWIF_KCCB_CMD      sPowCmd;
 	PVRSRV_ERROR          eError;
@@ -1470,7 +1525,7 @@ PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPerm
 #if !defined(NO_HARDWARE)
 	const RGXFWIF_SYSDATA *psFwSysData;
 #endif
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 #if !defined(NO_HARDWARE)
 	psFwSysData = psDevInfo->psRGXFWIfFwSysData;
@@ -1486,6 +1541,8 @@ PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPerm
 	/* Firmware is not powered. Sometimes this is permitted, for instance we were forcing idle to power down. */
 	if (psFwSysData->ePowState == RGXFWIF_POW_OFF)
 	{
+		PVR_DPF((PVR_DBG_WARNING, "Firmware is powered OFF (bDeviceOffPermitted = %s)",
+				 bDeviceOffPermitted ? "Yes" : "No"));
 		return (bDeviceOffPermitted) ? PVRSRV_OK : PVRSRV_ERROR_DEVICE_IDLE_REQUEST_DENIED;
 	}
 #endif
@@ -1558,6 +1615,8 @@ PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPerm
 	                           INVALIDATE);
 	if (psFwSysData->ePowState != RGXFWIF_POW_FORCED_IDLE)
 	{
+		PVR_DPF((PVR_DBG_WARNING, "FW power state (%u) is not RGXFWIF_POW_FORCED_IDLE (%u)",
+				 psFwSysData->ePowState, RGXFWIF_POW_FORCED_IDLE));
 		return PVRSRV_ERROR_DEVICE_IDLE_REQUEST_DENIED;
 	}
 #endif
@@ -1568,14 +1627,13 @@ PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPerm
 /*
 	RGXCancelForcedIdleRequest
 */
-PVRSRV_ERROR RGXCancelForcedIdleRequest(IMG_HANDLE hDevHandle)
+PVRSRV_ERROR RGXCancelForcedIdleRequest(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
 	RGXFWIF_KCCB_CMD	sPowCmd;
 	PVRSRV_ERROR		eError = PVRSRV_OK;
 	IMG_UINT32			ui32CmdKCCBSlot;
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_OK);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_OK);
 
 	eError = SyncPrimSet(psDevInfo->psPowSyncPrim, 0);
 	if (eError != PVRSRV_OK)
@@ -1637,54 +1695,134 @@ PVRSRV_ERROR RGXCancelForcedIdleRequest(IMG_HANDLE hDevHandle)
 	return eError;
 }
 
-/*!
- ******************************************************************************
+#if defined(SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY)
+#if defined(SUPPORT_PDVFS) && (PDVFS_COM == PDVFS_COM_HOST)
+/*************************************************************************/ /*!
+@Function       PDVFSProcessCoreClkChangeRequest
+@Description    Processes a core clock rate change request.
+@Input          psDevInfo            A pointer to PVRSRV_RGXDEV_INFO.
+@Input          ui32CoreClockRate    New core clock rate.
+@Return         PVRSRV_ERROR.
+*/ /**************************************************************************/
+PVRSRV_ERROR RGXProcessCoreClkChangeRequest(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32CoreClockRate)
+{
+	PVRSRV_DEVICE_CONFIG *psDevConfig = psDevInfo->psDeviceNode->psDevConfig;
+	IMG_DVFS_DEVICE_CFG *psDVFSDeviceCfg = &psDevConfig->sDVFS.sDVFSDeviceCfg;
+	RGX_TIMING_INFORMATION *psRGXTimingInfo = ((RGX_DATA*)(psDevConfig->hDevData))->psRGXTimingInfo;
+	IMG_UINT32 ui32CoreClockRateCurrent = psRGXTimingInfo->ui32CoreClockSpeed;
+	const IMG_OPP *psOpp = NULL;
+	IMG_UINT32 ui32Index;
+	PVRSRV_ERROR eError;
+
+	if (!_PDVFSEnabled())
+	{
+		/* No error message to avoid excessive messages */
+		return PVRSRV_OK;
+	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "Core clock rate = %u", ui32CoreClockRate));
+
+	/* Find the matching OPP (Exact). */
+	for (ui32Index = 0; ui32Index < psDVFSDeviceCfg->ui32OPPTableSize; ui32Index++)
+	{
+		if (ui32CoreClockRate == psDVFSDeviceCfg->pasOPPTable[ui32Index].ui32Freq)
+		{
+			psOpp = &psDVFSDeviceCfg->pasOPPTable[ui32Index];
+			break;
+		}
+	}
 
- @Function	PVRSRVGetNextDustCount
+	if (! psOpp)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "Frequency not present in OPP table - %u", ui32CoreClockRate));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
 
- @Description
+	eError = PVRSRVDevicePreClockSpeedChange(psDevInfo->psDeviceNode, psDVFSDeviceCfg->bIdleReq, NULL);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "PVRSRVDevicePreClockSpeedChange failed"));
+		return eError;
+	}
 
-	Calculate a sequence of dust counts to achieve full transition coverage.
-	We increment two counts of dusts and switch up and down between them.
-	It does contain a few redundant transitions. If two dust exist, the
-	output transitions should be as follows.
+	psRGXTimingInfo->ui32CoreClockSpeed = ui32CoreClockRate;
 
-	0->1, 0<-1, 0->2, 0<-2, (0->1)
-	1->1, 1->2, 1<-2, (1->2)
-	2->2, (2->0),
-	0->0. Repeat.
+	/* Increasing frequency, change voltage first */
+	if (ui32CoreClockRate > ui32CoreClockRateCurrent)
+	{
+		psDVFSDeviceCfg->pfnSetVoltage(psDevConfig->hSysData, psOpp->ui32Volt);
+	}
 
-	Redundant transitions in brackets.
+	psDVFSDeviceCfg->pfnSetFrequency(psDevConfig->hSysData, ui32CoreClockRate);
 
- @Input		psDustReqState : Counter state used to calculate next dust count
- @Input		ui32DustCount : Number of dusts in the core
+	/* Decreasing frequency, change frequency first */
+	if (ui32CoreClockRate < ui32CoreClockRateCurrent)
+	{
+		psDVFSDeviceCfg->pfnSetVoltage(psDevConfig->hSysData, psOpp->ui32Volt);
+	}
 
- @Return	PVRSRV_ERROR
+	PVRSRVDevicePostClockSpeedChange(psDevInfo->psDeviceNode, psDVFSDeviceCfg->bIdleReq, NULL);
 
- ******************************************************************************/
-IMG_UINT32 RGXGetNextDustCount(RGX_DUST_STATE *psDustReqState, IMG_UINT32 ui32DustCount)
+	return PVRSRV_OK;
+}
+#else
+/*************************************************************************/ /*!
+@Function       PDVFSProcessCoreClkChangeNotification
+@Description    Processes a core clock rate change notification.
+@Input          psDevInfo            A pointer to PVRSRV_RGXDEV_INFO.
+@Input          ui32CoreClockRate    New core clock rate.
+@Return         PVRSRV_ERROR.
+*/ /**************************************************************************/
+PVRSRV_ERROR RGXProcessCoreClkChangeNotification(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32CoreClockRate)
 {
-	if (psDustReqState->bToggle)
+	PVRSRV_DEVICE_CONFIG *psDevConfig = psDevInfo->psDeviceNode->psDevConfig;
+	RGX_TIMING_INFORMATION *psRGXTimingInfo = ((RGX_DATA*)(psDevConfig->hDevData))->psRGXTimingInfo;
+	PVRSRV_DEV_POWER_STATE ePowerState;
+	PVRSRV_ERROR eError;
+
+	eError = PVRSRVPowerLock(psDevInfo->psDeviceNode);
+
+	if (eError != PVRSRV_OK)
 	{
-		psDustReqState->ui32DustCount2++;
+		PVR_DPF((PVR_DBG_ERROR, "%s: failed to acquire lock (%s)",
+				 __func__, PVRSRVGetErrorString(eError)));
+		return eError;
 	}
 
-	if (psDustReqState->ui32DustCount2 > ui32DustCount)
+	eError = PVRSRVGetDevicePowerState(psDevInfo->psDeviceNode, &ePowerState);
+
+	if (eError != PVRSRV_OK)
 	{
-		psDustReqState->ui32DustCount1++;
-		psDustReqState->ui32DustCount2 = psDustReqState->ui32DustCount1;
+		PVR_DPF((PVR_DBG_ERROR, "%s: failed to acquire power state (%s)",
+				 __func__, PVRSRVGetErrorString(eError)));
+		PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
+		return eError;
 	}
 
-	if (psDustReqState->ui32DustCount1 > ui32DustCount)
+	/* Guest drivers do not initialize psRGXFWIfFwSysData */
+	RGXFwSharedMemCacheOpValue(psDevInfo->psRGXFWIfFwSysData->ePowState,
+	                           INVALIDATE);
+	if ((ePowerState != PVRSRV_DEV_POWER_STATE_OFF)
+	    && ((psDevInfo->psRGXFWIfFwSysData == NULL) || (psDevInfo->psRGXFWIfFwSysData->ePowState != RGXFWIF_POW_OFF)))
 	{
-		psDustReqState->ui32DustCount1 = 0;
-		psDustReqState->ui32DustCount2 = 0;
+		/* Update GPU frequency and timer correlation related data */
+		RGXTimeCorrEnd(psDevInfo->psDeviceNode, RGXTIMECORR_EVENT_DVFS);
+		psRGXTimingInfo->ui32CoreClockSpeed = ui32CoreClockRate;
+		RGXTimeCorrBegin(psDevInfo->psDeviceNode, RGXTIMECORR_EVENT_DVFS);
+	}
+	else
+	{
+		psRGXTimingInfo->ui32CoreClockSpeed = ui32CoreClockRate;
 	}
 
-	psDustReqState->bToggle = !psDustReqState->bToggle;
+	PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
 
-	return (psDustReqState->bToggle) ? psDustReqState->ui32DustCount1 : psDustReqState->ui32DustCount2;
+	return PVRSRV_OK;
 }
+#endif
+#endif /* SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY */
+
+
 
 /******************************************************************************
  End of file (rgxpower.c)
diff --git a/drivers/gpu/drm/img-rogue/rgxpower.h b/drivers/gpu/drm/img-rogue/rgxpower.h
index a6cd3f2b2d10..dbe9130d7a7b 100644
--- a/drivers/gpu/drm/img-rogue/rgxpower.h
+++ b/drivers/gpu/drm/img-rogue/rgxpower.h
@@ -59,14 +59,14 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
  does necessary preparation before power state transition
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eNewPowerState : New power state
  @Input	   eCurrentPowerState : Current power state
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXPrePowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPrePowerState(PPVRSRV_DEVICE_NODE		psDeviceNode,
 							  PVRSRV_DEV_POWER_STATE	eNewPowerState,
 							  PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
 							  PVRSRV_POWER_FLAGS		ePwrFlags);
@@ -80,14 +80,14 @@ PVRSRV_ERROR RGXPrePowerState(IMG_HANDLE				hDevHandle,
 
  does necessary preparation after power state transition
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eNewPowerState : New power state
  @Input	   eCurrentPowerState : Current power state
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXPostPowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPostPowerState(PPVRSRV_DEVICE_NODE		psDeviceNode,
 							   PVRSRV_DEV_POWER_STATE	eNewPowerState,
 							   PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
 							   PVRSRV_POWER_FLAGS		ePwrFlags);
@@ -101,14 +101,14 @@ PVRSRV_ERROR RGXPostPowerState(IMG_HANDLE				hDevHandle,
 
  does necessary preparation before power state transition on a vz driver
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eNewPowerState : New power state
  @Input	   eCurrentPowerState : Current power state
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXVzPrePowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXVzPrePowerState(PPVRSRV_DEVICE_NODE		psDeviceNode,
 								PVRSRV_DEV_POWER_STATE	eNewPowerState,
 								PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
 								PVRSRV_POWER_FLAGS		ePwrFlags);
@@ -122,14 +122,14 @@ PVRSRV_ERROR RGXVzPrePowerState(IMG_HANDLE				hDevHandle,
 
  does necessary preparation after power state transition on a vz driver
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eNewPowerState : New power state
  @Input	   eCurrentPowerState : Current power state
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXVzPostPowerState(PPVRSRV_DEVICE_NODE	psDeviceNode,
 								 PVRSRV_DEV_POWER_STATE	eNewPowerState,
 								 PVRSRV_DEV_POWER_STATE	eCurrentPowerState,
 								 PVRSRV_POWER_FLAGS		ePwrFlags);
@@ -143,13 +143,13 @@ PVRSRV_ERROR RGXVzPostPowerState(IMG_HANDLE				hDevHandle,
 
 	Does processing required before an RGX clock speed change.
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eCurrentPowerState : Power state of the device
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXPreClockSpeedChange(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPreClockSpeedChange(PPVRSRV_DEVICE_NODE		psDeviceNode,
 									PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
 /*!
@@ -161,31 +161,66 @@ PVRSRV_ERROR RGXPreClockSpeedChange(IMG_HANDLE				hDevHandle,
 
 	Does processing required after an RGX clock speed change.
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   eCurrentPowerState : Power state of the device
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXPostClockSpeedChange(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXPostClockSpeedChange(PPVRSRV_DEVICE_NODE	psDeviceNode,
 									 PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 
 
+#if defined(SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY)
+#if defined(SUPPORT_PDVFS) && (PDVFS_COM == PDVFS_COM_HOST)
 /*!
 ******************************************************************************
 
- @Function	RGXDustCountChange
+ @Function	RGXProcessCoreClkChangeRequest
 
- @Description Change of number of DUSTs
+ @Input	   psDevInfo : RGX Device Info
+ @Input	   ui32CoreClockRate : New clock frequency to send to system layer.
 
- @Input	   hDevHandle : RGX Device Node
- @Input	   ui32NumberOfDusts : Number of DUSTs to make transition to
+ @Return   PVRSRV_ERROR :
+
+******************************************************************************/
+PVRSRV_ERROR RGXProcessCoreClkChangeRequest(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32CoreClockRate);
+#define RGX_PROCESS_CORE_CLK_RATE_CHANGE(devinfo, clk)  RGXProcessCoreClkChangeRequest(devinfo, clk)
+
+#else
+/*!
+******************************************************************************
+
+ @Function	RGXProcessCoreClkChangeNotification
+
+ @Input	   psDevInfo : RGX Device Info
+ @Input	   ui32CoreClockRate : New clock frequency.
+
+ @Return   PVRSRV_ERROR :
+
+******************************************************************************/
+PVRSRV_ERROR RGXProcessCoreClkChangeNotification(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32CoreClockRate);
+#define RGX_PROCESS_CORE_CLK_RATE_CHANGE(devinfo, clk)  RGXProcessCoreClkChangeNotification(devinfo, clk)
+#endif
+#endif /* SUPPORT_FW_CORE_CLK_RATE_CHANGE_NOTIFY */
+
+/*!
+******************************************************************************
+
+ @Function	RGXPowUnitsChange
+
+ @Description Change power units state
+
+ @Input	   psDeviceNode : RGX Device Node
+ @Input	   ui32PowUnits : On Rogue: Number of DUSTs to make transition to.
+                          On Volcanic: Mask containing power state of SPUs.
+                          Each bit corresponds to an SPU and value must be non-zero.
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE hDevHandle,
-								IMG_UINT32 ui32NumberOfDusts);
+PVRSRV_ERROR RGXPowUnitsChange(PPVRSRV_DEVICE_NODE psDeviceNode,
+                               IMG_UINT32 ui32PowUnits);
 
 /*!
 ******************************************************************************
@@ -200,14 +235,14 @@ PVRSRV_ERROR RGXDustCountChange(IMG_HANDLE hDevHandle,
 	power management activity. If bPersistent is NOT set, APM latency will
 	return back to system default on power up.
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
  @Input	   ui32ActivePMLatencyms : Number of milliseconds to wait
  @Input	   bActivePMLatencyPersistant : Set to ensure new value is not reset
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE				hDevHandle,
+PVRSRV_ERROR RGXAPMLatencyChange(PPVRSRV_DEVICE_NODE	psDeviceNode,
 				IMG_UINT32				ui32ActivePMLatencyms,
 				IMG_BOOL				bActivePMLatencyPersistant);
 
@@ -218,12 +253,12 @@ PVRSRV_ERROR RGXAPMLatencyChange(IMG_HANDLE				hDevHandle,
 
  @Description Initiate a handshake with the FW to power off the GPU
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXActivePowerRequest(IMG_HANDLE hDevHandle);
+PVRSRV_ERROR RGXActivePowerRequest(PPVRSRV_DEVICE_NODE psDeviceNode);
 
 /*!
 ******************************************************************************
@@ -232,7 +267,7 @@ PVRSRV_ERROR RGXActivePowerRequest(IMG_HANDLE hDevHandle);
 
  @Description Initiate a handshake with the FW to idle the GPU
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
 
  @Input    bDeviceOffPermitted : Set to indicate device state being off is not
                                  erroneous.
@@ -240,7 +275,8 @@ PVRSRV_ERROR RGXActivePowerRequest(IMG_HANDLE hDevHandle);
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPermitted);
+PVRSRV_ERROR RGXForcedIdleRequest(PPVRSRV_DEVICE_NODE psDeviceNode,
+                                  IMG_BOOL bDeviceOffPermitted);
 
 /*!
 ******************************************************************************
@@ -249,38 +285,12 @@ PVRSRV_ERROR RGXForcedIdleRequest(IMG_HANDLE hDevHandle, IMG_BOOL bDeviceOffPerm
 
  @Description Send a request to cancel idle to the firmware.
 
- @Input	   hDevHandle : RGX Device Node
+ @Input	   psDeviceNode : RGX Device Node
 
  @Return   PVRSRV_ERROR :
 
 ******************************************************************************/
-PVRSRV_ERROR RGXCancelForcedIdleRequest(IMG_HANDLE hDevHandle);
-
-/*!
-******************************************************************************
+PVRSRV_ERROR RGXCancelForcedIdleRequest(PPVRSRV_DEVICE_NODE psDeviceNode);
 
- @Function	PVRSRVGetNextDustCount
-
- @Description
-
-	Calculate a sequence of dust counts to achieve full transition coverage.
-	We increment two counts of dusts and switch up and down between them.
-	It does contain a few redundant transitions. If two dust exist, the
-	output transitions should be as follows.
-
-	0->1, 0<-1, 0->2, 0<-2, (0->1)
-	1->1, 1->2, 1<-2, (1->2)
-	2->2, (2->0),
-	0->0. Repeat.
-
-	Redundant transitions in brackets.
-
- @Input		psDustReqState : Counter state used to calculate next dust count
- @Input		ui32DustCount : Number of dusts in the core
-
- @Return	PVRSRV_ERROR
-
-******************************************************************************/
-IMG_UINT32 RGXGetNextDustCount(RGX_DUST_STATE *psDustState, IMG_UINT32 ui32DustCount);
 
 #endif /* RGXPOWER_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxregconfig.c b/drivers/gpu/drm/img-rogue/rgxregconfig.c
index ef39bea255eb..c2f681c70f12 100644
--- a/drivers/gpu/drm/img-rogue/rgxregconfig.c
+++ b/drivers/gpu/drm/img-rogue/rgxregconfig.c
@@ -57,7 +57,7 @@ PVRSRV_ERROR PVRSRVRGXSetRegConfigTypeKM(CONNECTION_DATA * psDevConnection,
 #if defined(SUPPORT_USER_REGISTER_CONFIGURATION)
 	PVRSRV_ERROR          eError      = PVRSRV_OK;
 	PVRSRV_RGXDEV_INFO    *psDevInfo  = psDeviceNode->pvDevice;
-	RGX_REG_CONFIG        *psRegCfg   = &psDevInfo->sRegCongfig;
+	RGX_REG_CONFIG        *psRegCfg   = &psDevInfo->sRegConfig;
 	RGXFWIF_REG_CFG_TYPE  eRegCfgType = (RGXFWIF_REG_CFG_TYPE) ui8RegCfgType;
 
 	PVR_UNREFERENCED_PARAMETER(psDevConnection);
@@ -83,6 +83,8 @@ PVRSRV_ERROR PVRSRVRGXSetRegConfigTypeKM(CONNECTION_DATA * psDevConnection,
 	return eError;
 #else
 	PVR_UNREFERENCED_PARAMETER(psDevConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(ui8RegCfgType);
 
 	PVR_DPF((PVR_DBG_ERROR,
 		 "%s: Feature disabled. Compile with SUPPORT_USER_REGISTER_CONFIGURATION",
@@ -101,11 +103,11 @@ PVRSRV_ERROR PVRSRVRGXAddRegConfigKM(CONNECTION_DATA * psConnection,
 	PVRSRV_ERROR		eError = PVRSRV_OK;
 	RGXFWIF_KCCB_CMD	sRegCfgCmd;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegCongfig;
+	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegConfig;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	OSLockAcquire(psRegCfg->hLock);
 
@@ -154,6 +156,10 @@ PVRSRV_ERROR PVRSRVRGXAddRegConfigKM(CONNECTION_DATA * psConnection,
 	return eError;
 #else
 	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+	PVR_UNREFERENCED_PARAMETER(ui32RegAddr);
+	PVR_UNREFERENCED_PARAMETER(ui64RegValue);
+	PVR_UNREFERENCED_PARAMETER(ui64RegMask);
 
 	PVR_DPF((PVR_DBG_ERROR,
 		 "%s: Feature disabled. Compile with SUPPORT_USER_REGISTER_CONFIGURATION",
@@ -169,11 +175,11 @@ PVRSRV_ERROR PVRSRVRGXClearRegConfigKM(CONNECTION_DATA * psConnection,
 	PVRSRV_ERROR		eError = PVRSRV_OK;
 	RGXFWIF_KCCB_CMD	sRegCfgCmd;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegCongfig;
+	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegConfig;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	OSLockAcquire(psRegCfg->hLock);
 
@@ -210,12 +216,14 @@ PVRSRV_ERROR PVRSRVRGXClearRegConfigKM(CONNECTION_DATA * psConnection,
 
 	return eError;
 #else
+
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
 	PVR_DPF((PVR_DBG_ERROR,
 		 "%s: Feature disabled. Compile with SUPPORT_USER_REGISTER_CONFIGURATION",
 		 __func__));
 
-	PVR_UNREFERENCED_PARAMETER(psConnection);
-
 	return PVRSRV_ERROR_FEATURE_DISABLED;
 #endif
 }
@@ -227,11 +235,11 @@ PVRSRV_ERROR PVRSRVRGXEnableRegConfigKM(CONNECTION_DATA * psConnection,
 	PVRSRV_ERROR		eError = PVRSRV_OK;
 	RGXFWIF_KCCB_CMD	sRegCfgCmd;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegCongfig;
+	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegConfig;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	OSLockAcquire(psRegCfg->hLock);
 
@@ -259,6 +267,7 @@ PVRSRV_ERROR PVRSRVRGXEnableRegConfigKM(CONNECTION_DATA * psConnection,
 	return eError;
 #else
 	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 
 	PVR_DPF((PVR_DBG_ERROR,
 		 "%s: Feature disabled. Compile with SUPPORT_USER_REGISTER_CONFIGURATION",
@@ -274,11 +283,11 @@ PVRSRV_ERROR PVRSRVRGXDisableRegConfigKM(CONNECTION_DATA * psConnection,
 	PVRSRV_ERROR		eError = PVRSRV_OK;
 	RGXFWIF_KCCB_CMD	sRegCfgCmd;
 	PVRSRV_RGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegCongfig;
+	RGX_REG_CONFIG		*psRegCfg = &psDevInfo->sRegConfig;
 
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	PVRSRV_VZ_RET_IF_MODE(GUEST, PVRSRV_ERROR_NOT_SUPPORTED);
+	PVRSRV_VZ_RET_IF_MODE(GUEST, DEVNODE, psDeviceNode, PVRSRV_ERROR_NOT_SUPPORTED);
 
 	OSLockAcquire(psRegCfg->hLock);
 
@@ -305,10 +314,13 @@ PVRSRV_ERROR PVRSRVRGXDisableRegConfigKM(CONNECTION_DATA * psConnection,
 
 	return eError;
 #else
+
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
 	PVR_DPF((PVR_DBG_ERROR,
 		 "%s: Feature disabled. Compile with SUPPORT_USER_REGISTER_CONFIGURATION",
 		 __func__));
-	PVR_UNREFERENCED_PARAMETER(psConnection);
 
 	return PVRSRV_ERROR_FEATURE_DISABLED;
 #endif
diff --git a/drivers/gpu/drm/img-rogue/rgxshader.c b/drivers/gpu/drm/img-rogue/rgxshader.c
index e29a4e3ab683..85cf498f037c 100644
--- a/drivers/gpu/drm/img-rogue/rgxshader.c
+++ b/drivers/gpu/drm/img-rogue/rgxshader.c
@@ -51,6 +51,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "physmem.h"
 #include "ri_server.h"
 #include "pvr_ricommon.h"
+#include "pvrsrv.h"
 
 static void
 RGXShaderReadHeader(OS_FW_IMAGE *psShaderFW, RGX_SHADER_HEADER *psHeader)
@@ -111,14 +112,12 @@ _GetShaderFileName(PVRSRV_DEVICE_NODE * psDeviceNode,
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 	OSSNPrintf(pszShaderFilenameStr, RGX_SHADER_FILENAME_MAX_SIZE,
-			   "%s." RGX_BVNC_STR_FMTSPEC,
-			   RGX_SH_FILENAME,
+			   RGX_SH_FILENAME "." RGX_BVNC_STR_FMTSPEC,
 			   psDevInfo->sDevFeatureCfg.ui32B, psDevInfo->sDevFeatureCfg.ui32V,
 			   psDevInfo->sDevFeatureCfg.ui32N, psDevInfo->sDevFeatureCfg.ui32C);
 
 	OSSNPrintf(pszShaderpFilenameStr, RGX_SHADER_FILENAME_MAX_SIZE,
-			   "%s." RGX_BVNC_STRP_FMTSPEC,
-			   RGX_SH_FILENAME,
+			   RGX_SH_FILENAME "." RGX_BVNC_STRP_FMTSPEC,
 			   psDevInfo->sDevFeatureCfg.ui32B, psDevInfo->sDevFeatureCfg.ui32V,
 			   psDevInfo->sDevFeatureCfg.ui32N, psDevInfo->sDevFeatureCfg.ui32C);
 }
@@ -135,6 +134,9 @@ PVRSRVTQLoadShaders(PVRSRV_DEVICE_NODE * psDeviceNode)
 	IMG_CHAR            aszShaderpFilenameStr[RGX_SHADER_FILENAME_MAX_SIZE];
 	const IMG_CHAR      *pszShaderFilenameStr = aszShaderFilenameStr;
 	size_t              uiNumBytes;
+	PVRSRV_DEVICE_NODE *psHostDevNode = PVRSRVGetPVRSRVData()->psHostMemDeviceNode;
+	size_t              uiLog2PageSize = OSGetPageShift();
+	IMG_DEVMEM_SIZE_T   uiTQUSCMemSize;
 	PVRSRV_ERROR        eError;
 
 	_GetShaderFileName(psDeviceNode, aszShaderFilenameStr, aszShaderpFilenameStr);
@@ -170,17 +172,27 @@ PVRSRVTQLoadShaders(PVRSRV_DEVICE_NODE * psDeviceNode)
 		goto failed_firmware;
 	}
 
-	ui32NumPages = (sHeader.ui32SizeFragment / RGX_BIF_PM_PHYSICAL_PAGE_SIZE) + 1;
+	ui32NumPages = (sHeader.ui32SizeFragment / IMG_PAGE2BYTES32(uiLog2PageSize)) + 1;
+
+	uiTQUSCMemSize = ui32NumPages * IMG_PAGE2BYTES32(uiLog2PageSize);
+
+	if (uiTQUSCMemSize > RGXFWIF_KM_USC_TQ_SHADER_CODE_MAX_SIZE_BYTES)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: TQ shaders out of space ("IMG_DEVMEM_SIZE_FMTSPEC" > 0x%X)",
+				 __func__, uiTQUSCMemSize, RGXFWIF_KM_USC_TQ_SHADER_CODE_MAX_SIZE_BYTES));
+		eError = PVRSRV_ERROR_NOT_SUPPORTED;
+		goto failed_firmware;
+	}
 
 	PDUMPCOMMENT(psDeviceNode, "Allocate TDM USC PMR Block (Pages %08X)", ui32NumPages);
 
 	eError = PhysmemNewRamBackedPMR(NULL,
 									psDeviceNode,
-									(IMG_DEVMEM_SIZE_T)ui32NumPages * RGX_BIF_PM_PHYSICAL_PAGE_SIZE,
+									uiTQUSCMemSize,
 									1,
 									1,
 									&ui32MappingTable,
-									RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT,
+									uiLog2PageSize,
 									PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE
 									| PVRSRV_MEMALLOCFLAG_GPU_READABLE
 									| PVRSRV_MEMALLOCFLAG_GPU_CACHE_INCOHERENT
@@ -219,21 +231,25 @@ PVRSRVTQLoadShaders(PVRSRV_DEVICE_NODE * psDeviceNode)
 		goto failed_uscpmr;
 	}
 
-	ui32NumPages = (sHeader.ui32SizeClientMem / RGX_BIF_PM_PHYSICAL_PAGE_SIZE) + 1;
+	PDUMPCOMMENT(psDeviceNode, "Load TDM USC PMR Block (Size "IMG_SIZE_FMTSPECX")", RGXShaderUSCMemSize(psShaderFW));
+	PMRPDumpLoadMem(psDevInfo->hTQUSCSharedMem, 0, RGXShaderUSCMemSize(psShaderFW), PDUMP_FLAGS_CONTINUOUS, false);
+
+	ui32NumPages = (sHeader.ui32SizeClientMem / IMG_PAGE2BYTES32(uiLog2PageSize)) + 1;
 
 	PDUMPCOMMENT(psDeviceNode, "Allocate TDM Client PMR Block (Pages %08X)", ui32NumPages);
 
 	eError = PhysmemNewRamBackedPMR(NULL,
-									psDeviceNode,
-									(IMG_DEVMEM_SIZE_T)ui32NumPages * RGX_BIF_PM_PHYSICAL_PAGE_SIZE,
+									psHostDevNode,
+									(IMG_DEVMEM_SIZE_T)ui32NumPages * IMG_PAGE2BYTES32(uiLog2PageSize),
 									1,
 									1,
 									&ui32MappingTable,
-									RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT,
+									uiLog2PageSize,
 									PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE
 									| PVRSRV_MEMALLOCFLAG_CPU_READABLE
 									| PVRSRV_MEMALLOCFLAG_CPU_CACHE_INCOHERENT
-									| PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER,
+									| PVRSRV_MEMALLOCFLAG_VAL_SHARED_BUFFER
+									| PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(CPU_LOCAL),
 									sizeof("tqclipmr"),
 									"tqclipmr",
 									PVR_SYS_ALLOC_PID,
@@ -287,15 +303,12 @@ PVRSRVTQLoadShaders(PVRSRV_DEVICE_NODE * psDeviceNode)
 
 void
 PVRSRVTQAcquireShaders(PVRSRV_DEVICE_NODE  * psDeviceNode,
-					   PMR                ** ppsCLIPMRMem,
-					   PMR                ** ppsUSCPMRMem)
+					   PMR                ** ppsCLIPMRMem)
 {
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
-	PVR_ASSERT(psDevInfo->hTQUSCSharedMem != NULL);
 	PVR_ASSERT(psDevInfo->hTQCLISharedMem != NULL);
 
-	*ppsUSCPMRMem = psDevInfo->hTQUSCSharedMem;
 	*ppsCLIPMRMem = psDevInfo->hTQCLISharedMem;
 }
 
diff --git a/drivers/gpu/drm/img-rogue/rgxshader.h b/drivers/gpu/drm/img-rogue/rgxshader.h
index 7676ede51b7f..4ba50fc3fc86 100644
--- a/drivers/gpu/drm/img-rogue/rgxshader.h
+++ b/drivers/gpu/drm/img-rogue/rgxshader.h
@@ -66,12 +66,10 @@ PVRSRVTQLoadShaders(PVRSRV_DEVICE_NODE *psDeviceNode);
 @Description    Get handle to ready allocated shader PMR memory
 @Input          psDeviceNode Device node
 @Output         ppsCLIPMRMem Shader data used by CPU client side.
-@Output         ppsUSCPMRMem Shader usc code used by GPU.
 */ /**************************************************************************/
 void
 PVRSRVTQAcquireShaders(PVRSRV_DEVICE_NODE  *psDeviceNode,
-                       PMR                **ppsCLIPMRMem,
-                       PMR                **ppsUSCPMRMem);
+                       PMR                **ppsCLIPMRMem);
 
 /*************************************************************************/ /*!
 @Function       PVRSRVTQUnLoadShaders
diff --git a/drivers/gpu/drm/img-rogue/rgxsrvinit.c b/drivers/gpu/drm/img-rogue/rgxsrvinit.c
index fd6516cc1e98..9b1077273542 100644
--- a/drivers/gpu/drm/img-rogue/rgxsrvinit.c
+++ b/drivers/gpu/drm/img-rogue/rgxsrvinit.c
@@ -54,6 +54,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgx_fwif_km.h"
 #include "pdump_km.h"
 
+#include "rgxinit_apphints.h"
 #include "rgxinit.h"
 #include "rgxmulticore.h"
 
@@ -87,10 +88,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_device.h"
 #endif
 
-#define DRIVER_MODE_HOST               0          /* AppHint value for host driver mode */
-
 #define	HW_PERF_FILTER_DEFAULT         0x00000000 /* Default to no HWPerf */
 #define HW_PERF_FILTER_DEFAULT_ALL_ON  0xFFFFFFFF /* All events */
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+#define AVAIL_POW_UNITS_MASK_DEFAULT   (PVRSRV_APPHINT_HWVALAVAILABLESPUMASK)
+#define AVAIL_RAC_MASK_DEFAULT         (PVRSRV_APPHINT_HWVALAVAILABLERACMASK)
+#endif
 
 /* Kernel CCB size */
 
@@ -107,73 +110,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #error PVRSRV_APPHINT_KCCB_SIZE_LOG2 is too high.
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-#include "pvrsrv_apphint.h"
-#endif
 
 #include "os_apphint.h"
 
-/*
- * Container for all the apphints used by this module
- */
-typedef struct _RGX_SRVINIT_APPHINTS_
-{
-	IMG_UINT32 ui32DriverMode;
-	IMG_BOOL   bGPUUnitsPowerChange;
-	IMG_BOOL   bEnableSignatureChecks;
-	IMG_UINT32 ui32SignatureChecksBufSize;
-
-	IMG_BOOL   bAssertOnOutOfMem;
-	IMG_BOOL   bAssertOnHWRTrigger;
-#if defined(SUPPORT_VALIDATION)
-	IMG_BOOL   bValidateIrq;
-	IMG_BOOL   bValidateSOCUSCTimer;
-	IMG_UINT32 ui32FBCDCVersionOverride;
-	IMG_UINT32 aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_LAST];
-#endif
-	IMG_UINT32 ui32TFBCCompressionControlGroup;
-	IMG_UINT32 ui32TFBCCompressionControlScheme;
-	IMG_BOOL   bTFBCCompressionControlYUVFormat;
-	IMG_BOOL   bTFBCCompressionControlLossyMinChannel;
-	IMG_BOOL   bCheckMlist;
-	IMG_BOOL   bDisableClockGating;
-	IMG_BOOL   bDisableDMOverlap;
-	IMG_BOOL   bDisableFEDLogging;
-	IMG_BOOL   bDisablePDP;
-	IMG_BOOL   bEnableCDMKillRand;
-	IMG_BOOL   bEnableRandomCsw;
-	IMG_BOOL   bEnableSoftResetCsw;
-	IMG_BOOL   bFilteringMode;
-	IMG_BOOL   bHWPerfDisableCustomCounterFilter;
-	IMG_BOOL   bZeroFreelist;
-	IMG_UINT32 ui32EnableFWContextSwitch;
-	IMG_UINT32 ui32FWContextSwitchProfile;
-
-	IMG_UINT32 ui32HWPerfFWBufSize;
-	IMG_UINT32 ui32HWPerfHostBufSize;
-	IMG_UINT32 ui32HWPerfFilter0;
-	IMG_UINT32 ui32HWPerfFilter1;
-	IMG_UINT32 ui32HWPerfHostFilter;
-	IMG_UINT32 ui32TimeCorrClock;
-	IMG_UINT32 ui32HWRDebugDumpLimit;
-	IMG_UINT32 ui32JonesDisableMask;
-	IMG_UINT32 ui32LogType;
-	IMG_UINT32 ui32TruncateMode;
-	IMG_UINT32 ui32KCCBSizeLog2;
-	FW_PERF_CONF eFirmwarePerf;
-	RGX_ACTIVEPM_CONF eRGXActivePMConf;
-	RGX_RD_POWER_ISLAND_CONF eRGXRDPowerIslandConf;
-
-	IMG_BOOL   bEnableTrustedDeviceAceConfig;
-	IMG_UINT32 ui32FWContextSwitchCrossDM;
-#if defined(SUPPORT_PHYSMEM_TEST) && !defined(INTEGRITY_OS) && !defined(__QNXNTO__)
-	IMG_UINT32 ui32PhysMemTestPasses;
-#endif
-
-	RGX_FWT_LOGTYPE eDebugDumpFWTLogType;
-	IMG_UINT32 ui32TFBCVersion;
-} RGX_SRVINIT_APPHINTS;
-
 /*
  * _ParseHTBAppHints:
  *
@@ -203,67 +142,103 @@ _ParseHTBAppHints(PVRSRV_DEVICE_NODE *psDeviceNode, void *pvAppHintState)
 	                     &ui32AppHintDefault, &ui32BufferSize);
 }
 
+/*!
+*******************************************************************************
+
+ @Function      GetFilterFlags
+
+ @Description   Initialise and return filter flags
+
+ @Input         bFilteringMode : Enable new TPU filtering mode
+ @Input         ui32TruncateMode : TPU Truncate mode
+
+ @Return        IMG_UINT32 : Filter flags
+
+******************************************************************************/
+static INLINE IMG_UINT32 GetFilterFlags(IMG_BOOL bFilteringMode, IMG_UINT32 ui32TruncateMode)
+{
+	IMG_UINT32 ui32FilterFlags = 0;
+
+	ui32FilterFlags |= bFilteringMode ? RGXFWIF_FILTCFG_NEW_FILTER_MODE : 0;
+	if (ui32TruncateMode == 2)
+	{
+		ui32FilterFlags |= RGXFWIF_FILTCFG_TRUNCATE_INT;
+	}
+	else if (ui32TruncateMode == 3)
+	{
+		ui32FilterFlags |= RGXFWIF_FILTCFG_TRUNCATE_HALF;
+	}
+
+	return ui32FilterFlags;
+}
+
+
+/*!
+*******************************************************************************
+
+ @Function      InitDeviceFlags
+
+ @Description   Initialise and return device flags
+
+ @Input         psDeviceNode     : Pointer to device node
+ @Input         pvAppHintState   : Pointer to apphint state
+ @Input         psHints          : Apphints container
+
+ @Return        void
+
+******************************************************************************/
+static INLINE void InitDeviceFlags(PVRSRV_DEVICE_NODE *psDeviceNode,
+                                   void *pvAppHintState,
+                                   RGX_INIT_APPHINTS *psHints)
+{
+	IMG_UINT32 ui32DeviceFlags = 0;
+	IMG_BOOL bAppHintDefault;
+	IMG_BOOL bZeroFreelist;
+	IMG_BOOL bDisableFEDLogging;
+
+
+	bAppHintDefault = PVRSRV_APPHINT_ZEROFREELIST;
+	OSGetAppHintBOOL(psDeviceNode,  pvAppHintState,  ZeroFreelist,
+	                   &bAppHintDefault,         &bZeroFreelist);
+	ui32DeviceFlags |= bZeroFreelist ? RGXKM_DEVICE_STATE_ZERO_FREELIST : 0;
+
+	bAppHintDefault = PVRSRV_APPHINT_DISABLEFEDLOGGING;
+	OSGetAppHintBOOL(psDeviceNode,    pvAppHintState,    DisableFEDLogging,
+	                   &bAppHintDefault,        &bDisableFEDLogging);
+	ui32DeviceFlags |= bDisableFEDLogging ? RGXKM_DEVICE_STATE_DISABLE_DW_LOGGING_EN : 0;
+
+
+#if defined(PVRSRV_ENABLE_CCCB_GROW)
+	BITMASK_SET(ui32DeviceFlags, RGXKM_DEVICE_STATE_CCB_GROW_EN);
+#endif
+
+	psHints->ui32DeviceFlags = ui32DeviceFlags;
+}
+
 /*!
 *******************************************************************************
 
  @Function      GetApphints
 
- @Description   Read init time apphints and initialise internal variables
+ @Description   Read init time apphints and initialise apphints structure
 
  @Input         psHints : Pointer to apphints container
 
  @Return        void
 
 ******************************************************************************/
-static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHINTS *psHints)
+static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_INIT_APPHINTS *psHints)
 {
 	void *pvAppHintState = NULL;
 	IMG_UINT32 ui32AppHintDefault;
 	IMG_BOOL bAppHintDefault;
 	IMG_UINT32 ui32ParamTemp;
-	IMG_BOOL bS7TopInfra = IMG_FALSE, bE42290 = IMG_FALSE, bTPUFiltermodeCtrl = IMG_FALSE;
-	IMG_BOOL bE42606 = IMG_FALSE;
-#if defined(EMULATOR)
-	IMG_BOOL bAXIACELite = IMG_FALSE;
-#endif
-
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, S7_TOP_INFRASTRUCTURE))
-	{
-		bS7TopInfra = IMG_TRUE;
-	}
-#if defined(RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_BIT_MASK)
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TPU_FILTERING_MODE_CONTROL))
-	{
-		bTPUFiltermodeCtrl = IMG_TRUE;
-	}
-#endif
-#if defined(HW_ERN_42290_BIT_MASK)
-	if (RGX_IS_ERN_SUPPORTED(psDevInfo, 42290))
-	{
-		bE42290 = IMG_TRUE;
-	}
-#endif
-#if defined(HW_ERN_42606_BIT_MASK)
-	if (RGX_IS_ERN_SUPPORTED(psDevInfo, 42606))
-	{
-		bE42606 = IMG_TRUE;
-	}
-#endif
-#if defined(HW_FEATURE_AXI_ACELITE_BIT_MASK) && defined(EMULATOR)
-	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, AXI_ACELITE))
-	{
-		bAXIACELite = IMG_TRUE;
-	}
+#if defined(__linux__)
+	IMG_UINT64 ui64AppHintDefault;
 #endif
 
 	OSCreateAppHintState(&pvAppHintState);
 
-	ui32AppHintDefault = PVRSRV_APPHINT_DRIVERMODE;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    DriverMode,
-	                     &ui32AppHintDefault,    &psHints->ui32DriverMode);
-	bAppHintDefault = PVRSRV_APPHINT_GPUUNITSPOWERCHANGE;
-	OSGetAppHintBOOL(psDevInfo->psDeviceNode,  pvAppHintState,    GPUUnitsPowerChange,
-	                     &bAppHintDefault,    &psHints->bGPUUnitsPowerChange);
 	bAppHintDefault = PVRSRV_APPHINT_ENABLESIGNATURECHECKS;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE,        pvAppHintState,    EnableSignatureChecks,
 	                     &bAppHintDefault,    &psHints->bEnableSignatureChecks);
@@ -286,16 +261,13 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	bAppHintDefault = PVRSRV_APPHINT_DISABLEDMOVERLAP;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE,          pvAppHintState,    DisableDMOverlap,
 	                   &bAppHintDefault,        &psHints->bDisableDMOverlap);
-	bAppHintDefault = PVRSRV_APPHINT_DISABLEFEDLOGGING;
-	OSGetAppHintBOOL(psDevInfo->psDeviceNode,    pvAppHintState,    DisableFEDLogging,
-	                   &bAppHintDefault,        &psHints->bDisableFEDLogging);
 	ui32AppHintDefault = PVRSRV_APPHINT_ENABLEAPM;
 	OSGetAppHintUINT32(psDevInfo->psDeviceNode,  pvAppHintState,    EnableAPM,
 	                     &ui32AppHintDefault,      &ui32ParamTemp);
 	psHints->eRGXActivePMConf = ui32ParamTemp;
 	bAppHintDefault = PVRSRV_APPHINT_ENABLECDMKILLINGRANDMODE;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE,        pvAppHintState,    EnableCDMKillingRandMode,
-	                   &bAppHintDefault,      &psHints->bEnableCDMKillRand);
+	                   &bAppHintDefault,      &psHints->bEnableDMKillRand);
 	bAppHintDefault = PVRSRV_APPHINT_ENABLERANDOMCONTEXTSWITCH;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE,        pvAppHintState,    EnableRandomContextSwitch,
 	                   &bAppHintDefault,      &psHints->bEnableRandomCsw);
@@ -309,6 +281,11 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    EnableRDPowerIsland,
 	                     &ui32AppHintDefault,    &ui32ParamTemp);
 	psHints->eRGXRDPowerIslandConf = ui32ParamTemp;
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	bAppHintDefault = PVRSRV_APPHINT_ENABLESPUCLOCKGATING;
+	OSGetAppHintBOOL(APPHINT_NO_DEVICE,          pvAppHintState,    EnableSPUClockGating,
+	                   &bAppHintDefault,           &psHints->bSPUClockGating);
+#endif
 	ui32AppHintDefault = PVRSRV_APPHINT_FIRMWAREPERF;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    FirmwarePerf,
 	                     &ui32AppHintDefault,    &ui32ParamTemp);
@@ -316,15 +293,20 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	ui32AppHintDefault = PVRSRV_APPHINT_FWCONTEXTSWITCHPROFILE;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    FWContextSwitchProfile,
 	                     &ui32AppHintDefault,    &psHints->ui32FWContextSwitchProfile);
+
+	/*
+	 * HWPerf apphints *
+	 */
 	bAppHintDefault = PVRSRV_APPHINT_HWPERFDISABLECUSTOMCOUNTERFILTER;
 	OSGetAppHintBOOL(APPHINT_NO_DEVICE,        pvAppHintState,    HWPerfDisableCustomCounterFilter,
-	                     &bAppHintDefault,    &psHints->bHWPerfDisableCustomCounterFilter);
+	                     &bAppHintDefault,    &psHints->bHWPerfDisableCounterFilter);
 	ui32AppHintDefault = PVRSRV_APPHINT_HWPERFHOSTBUFSIZEINKB;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    HWPerfHostBufSizeInKB,
 	                     &ui32AppHintDefault,    &psHints->ui32HWPerfHostBufSize);
 	ui32AppHintDefault = PVRSRV_APPHINT_HWPERFFWBUFSIZEINKB;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,    HWPerfFWBufSizeInKB,
 	                     &ui32AppHintDefault,    &psHints->ui32HWPerfFWBufSize);
+
 	ui32AppHintDefault = PVRSRV_APPHINT_KCCB_SIZE_LOG2;
 	OSGetAppHintUINT32(psDevInfo->psDeviceNode,  pvAppHintState,  KernelCCBSizeLog2,
 	                     &ui32AppHintDefault,    &psHints->ui32KCCBSizeLog2);
@@ -342,21 +324,21 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 		psHints->ui32KCCBSizeLog2 = PVRSRV_RGX_LOG2_KERNEL_CCB_MAX_SIZE;
 	}
 
-#if defined(SUPPORT_VALIDATION)
-	if (psHints->ui32KCCBSizeLog2 != PVRSRV_APPHINT_KCCB_SIZE_LOG2)
-	{
-		PVR_LOG(("KernelCCBSizeLog2 set to %u", psHints->ui32KCCBSizeLog2));
-	}
+
+#if defined(PVR_ARCH_VOLCANIC)
+	ui32AppHintDefault = PVRSRV_APPHINT_ISPSCHEDULINGLATENCYMODE;
+	OSGetAppHintUINT32(APPHINT_NO_DEVICE,    pvAppHintState,  ISPSchedulingLatencyMode,
+	                     &ui32AppHintDefault,  &psHints->ui32ISPSchedulingLatencyMode);
 #endif
 
 #if defined(__linux__)
 	/* name changes */
 	{
 		IMG_UINT64 ui64Tmp;
-		IMG_UINT64 ui64AppHintDefault = PVRSRV_APPHINT_HWPERFFWFILTER;
 		bAppHintDefault = PVRSRV_APPHINT_DISABLEPDUMPPANIC;
 		OSGetAppHintBOOL(psDevInfo->psDeviceNode,    pvAppHintState,  DisablePDumpPanic,
-		                   &bAppHintDefault,        &psHints->bDisablePDP);
+		                   &bAppHintDefault,           &psHints->bDisablePDP);
+		ui64AppHintDefault = PVRSRV_APPHINT_HWPERFFWFILTER;
 		OSGetAppHintUINT64(psDevInfo->psDeviceNode,  pvAppHintState,  HWPerfFWFilter,
 		                   &ui64AppHintDefault,        &ui64Tmp);
 		psHints->ui32HWPerfFilter0 = (IMG_UINT32)(ui64Tmp & 0xffffffffllu);
@@ -375,41 +357,35 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	                     &ui32AppHintDefault,          &ui32ParamTemp);
 	psHints->ui32HWRDebugDumpLimit = MIN(ui32ParamTemp, RGXFWIF_HWR_DEBUG_DUMP_ALL);
 
-	if (bS7TopInfra)
 	{
-	#define RGX_CR_JONES_FIX_MT_ORDER_ISP_TE_CLRMSK	(0XFFFFFFCFU)
-	#define RGX_CR_JONES_FIX_MT_ORDER_ISP_EN	(0X00000020U)
-	#define RGX_CR_JONES_FIX_MT_ORDER_TE_EN		(0X00000010U)
-
-		ui32AppHintDefault = PVRSRV_APPHINT_JONESDISABLEMASK;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  JonesDisableMask,
-		                     &ui32AppHintDefault,  &ui32ParamTemp);
-		if (((ui32ParamTemp & ~RGX_CR_JONES_FIX_MT_ORDER_ISP_TE_CLRMSK) == RGX_CR_JONES_FIX_MT_ORDER_ISP_EN) ||
-			((ui32ParamTemp & ~RGX_CR_JONES_FIX_MT_ORDER_ISP_TE_CLRMSK) == RGX_CR_JONES_FIX_MT_ORDER_TE_EN))
+		IMG_BOOL bFilteringMode = IMG_FALSE;
+		IMG_UINT32 ui32TruncateMode = 0U;
+
+#if defined(HW_ERN_42290_BIT_MASK) && defined(RGX_FEATURE_TPU_FILTERING_MODE_CONTROL_BIT_MASK)
+		if (RGX_IS_ERN_SUPPORTED(psDevInfo, 42290) && RGX_IS_FEATURE_SUPPORTED(psDevInfo, TPU_FILTERING_MODE_CONTROL))
+#endif
 		{
-			ui32ParamTemp |= (RGX_CR_JONES_FIX_MT_ORDER_TE_EN |
-							  RGX_CR_JONES_FIX_MT_ORDER_ISP_EN);
-			PVR_DPF((PVR_DBG_WARNING, "Tile reordering mode requires both TE and ISP enabled. Forcing JonesDisableMask = %d",
-					ui32ParamTemp));
+			bAppHintDefault = PVRSRV_APPHINT_NEWFILTERINGMODE;
+			OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  NewFilteringMode,
+			                   &bAppHintDefault,  &bFilteringMode);
 		}
-		psHints->ui32JonesDisableMask = ui32ParamTemp;
-	}
 
-	if ((bE42290) && (bTPUFiltermodeCtrl))
-	{
-		bAppHintDefault = PVRSRV_APPHINT_NEWFILTERINGMODE;
-		OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  NewFilteringMode,
-		                   &bAppHintDefault,  &psHints->bFilteringMode);
-	}
+#if defined(HW_ERN_42606_BIT_MASK)
+		if (RGX_IS_ERN_SUPPORTED(psDevInfo, 42606))
+#endif
+		{
+			ui32AppHintDefault = PVRSRV_APPHINT_TRUNCATEMODE;
+			OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TruncateMode,
+			                     &ui32AppHintDefault,  &ui32TruncateMode);
+		}
 
-	if (bE42606)
-	{
-		ui32AppHintDefault = PVRSRV_APPHINT_TRUNCATEMODE;
-		OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TruncateMode,
-		                     &ui32AppHintDefault,  &psHints->ui32TruncateMode);
+		psHints->ui32FilterFlags = GetFilterFlags(bFilteringMode, ui32TruncateMode);
 	}
+
 #if defined(EMULATOR)
-	if (bAXIACELite)
+#if defined(RGX_FEATURE_AXI_ACELITE_BIT_MASK)
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, AXI_ACELITE))
+#endif
 	{
 		bAppHintDefault = PVRSRV_APPHINT_ENABLETRUSTEDDEVICEACECONFIG;
 		OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  EnableTrustedDeviceAceConfig,
@@ -417,10 +393,6 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	}
 #endif
 
-	bAppHintDefault = PVRSRV_APPHINT_ZEROFREELIST;
-	OSGetAppHintBOOL(psDevInfo->psDeviceNode,  pvAppHintState,  ZeroFreelist,
-	                   &bAppHintDefault,         &psHints->bZeroFreelist);
-
 #if defined(__linux__)
 	ui32AppHintDefault = 0;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE,      pvAppHintState,  FWContextSwitchCrossDM,
@@ -433,35 +405,13 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 	                     &ui32AppHintDefault,    &psHints->ui32PhysMemTestPasses);
 #endif
 
-#if defined(SUPPORT_VALIDATION)
-	/* Apphints for TPU trilinear frac masking */
-	ui32AppHintDefault = 0xF;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TPUTrilinearFracMaskPDM, &ui32AppHintDefault, &psHints->aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_PDM]);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TPUTrilinearFracMaskVDM, &ui32AppHintDefault, &psHints->aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_VDM]);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TPUTrilinearFracMaskCDM, &ui32AppHintDefault, &psHints->aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_CDM]);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TPUTrilinearFracMaskTDM, &ui32AppHintDefault, &psHints->aui32TPUTrilinearFracMask[RGXFWIF_TPU_DM_TDM]);
-	bAppHintDefault = PVRSRV_APPHINT_VALIDATEIRQ;
-	OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  ValidateIrq,             &bAppHintDefault,    &psHints->bValidateIrq);
-	bAppHintDefault = PVRSRV_APPHINT_VALIDATESOCUSCTIMERS;
-	OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  ValidateSOCUSCTimer,     &bAppHintDefault,    &psHints->bValidateSOCUSCTimer);
-	ui32AppHintDefault = PVRSRV_APPHINT_FBCDCVERSIONOVERRIDE;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  FBCDCVersionOverride,    &ui32AppHintDefault, &psHints->ui32FBCDCVersionOverride);
-	ui32AppHintDefault = PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TFBCCompressionControlGroup, &ui32AppHintDefault, &psHints->ui32TFBCCompressionControlGroup);
-	ui32AppHintDefault = PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLSCHEME;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE,  pvAppHintState,  TFBCCompressionControlScheme, &ui32AppHintDefault, &psHints->ui32TFBCCompressionControlScheme);
-	bAppHintDefault = IMG_FALSE;
-	OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  TFBCCompressionControlYUVFormat, &bAppHintDefault, &psHints->bTFBCCompressionControlYUVFormat);
-	OSGetAppHintBOOL(APPHINT_NO_DEVICE,    pvAppHintState,  TFBCCompressionControlLossyMinChannel, &bAppHintDefault, &psHints->bTFBCCompressionControlLossyMinChannel);
-#else
-	psHints->bTFBCCompressionControlLossyMinChannel = false;
-	psHints->bTFBCCompressionControlYUVFormat = false;
-	psHints->ui32TFBCCompressionControlScheme =
-	    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLSCHEME;
-	psHints->ui32TFBCCompressionControlGroup =
-	    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP;
-#endif
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	psHints->ui32AvailablePowUnitsMask = AVAIL_POW_UNITS_MASK_DEFAULT;
+	psHints->ui32AvailableRACMask = AVAIL_RAC_MASK_DEFAULT;
+#endif /* defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX) */
+
 
+#if defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX)
 	ui32AppHintDefault = PVRSRV_APPHINT_TFBCVERSION;
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, TFBCVersionDowngrade,
 	 &ui32AppHintDefault, &psHints->ui32TFBCVersion);
@@ -471,8 +421,17 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 		PVR_LOG(("TFBCVersionDowngrade set to %u", psHints->ui32TFBCVersion));
 	}
 
+	psHints->bTFBCCompressionControlLossyMinChannel = false;
+	psHints->bTFBCCompressionControlYUVFormat = false;
+	psHints->ui32TFBCCompressionControlScheme =
+	    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLSCHEME;
+	psHints->ui32TFBCCompressionControlGroup =
+	    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP;
+#endif /* defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX) */
+
 	ui32AppHintDefault = PVRSRV_APPHINT_DEBUGDUMPFWTLOGTYPE;
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, DebugDumpFWTLogType, &ui32AppHintDefault, &psHints->eDebugDumpFWTLogType);
+	OSGetAppHintUINT32(APPHINT_NO_DEVICE,    pvAppHintState,  DebugDumpFWTLogType,
+	                     &ui32AppHintDefault,  &psHints->eDebugDumpFWTLogType);
 	if ((IMG_UINT32)psHints->eDebugDumpFWTLogType > RGX_FWT_LOGTYPE_PARTIAL)
 	{
 		psHints->eDebugDumpFWTLogType = RGX_FWT_LOGTYPE_NONE;
@@ -509,6 +468,8 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 
 	_ParseHTBAppHints(psDevInfo->psDeviceNode, pvAppHintState);
 
+	InitDeviceFlags(psDevInfo->psDeviceNode, pvAppHintState, psHints);
+
 	OSFreeAppHintState(pvAppHintState);
 }
 
@@ -527,73 +488,121 @@ static INLINE void GetApphints(PVRSRV_RGXDEV_INFO *psDevInfo, RGX_SRVINIT_APPHIN
 
 ******************************************************************************/
 static INLINE void GetFWConfigFlags(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                    RGX_SRVINIT_APPHINTS *psHints,
+                                    RGX_INIT_APPHINTS *psHints,
                                     IMG_UINT32 *pui32FWConfigFlags,
                                     IMG_UINT32 *pui32FWConfigFlagsExt,
                                     IMG_UINT32 *pui32FwOsCfgFlags)
 {
 	IMG_UINT32 ui32FWConfigFlags = 0;
 	IMG_UINT32 ui32FWConfigFlagsExt = 0;
+	IMG_UINT32 ui32FwOsCfgFlags = psHints->ui32FWContextSwitchCrossDM |
+	                              (psHints->ui32EnableFWContextSwitch & ~RGXFWIF_INICFG_OS_CTXSWITCH_CLRMSK);
+
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+#if defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX)
 	IMG_UINT32 ui32FWConfigFlagsSupValExt = 0;
+	IMG_UINT32 ui32TFBCVersion = 0U;
+#endif
 
-	if (PVRSRV_VZ_MODE_IS(GUEST))
+	ui32FWConfigFlags |= psHints->bAssertOnOutOfMem ? RGXFWIF_INICFG_ASSERT_ON_OUTOFMEMORY : 0;
+	ui32FWConfigFlags |= psHints->bAssertOnHWRTrigger ? RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER : 0;
+	ui32FWConfigFlags |= psHints->bCheckMlist ? RGXFWIF_INICFG_CHECK_MLIST_EN : 0;
+	ui32FWConfigFlags |= psHints->bDisableClockGating ? RGXFWIF_INICFG_DISABLE_CLKGATING_EN : 0;
+
+#if defined(RGX_FEATURE_PIPELINED_DATAMASTERS_VERSION_MAX_VALUE_IDX)
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, PIPELINED_DATAMASTERS_VERSION)  &&
+		(RGX_GET_FEATURE_VALUE(psDevInfo, PIPELINED_DATAMASTERS_VERSION) > 0) &&
+		!RGX_IS_FEATURE_SUPPORTED(psDevInfo, ERYX_TOP_INFRASTRUCTURE))
 	{
-		ui32FWConfigFlags = 0;
-		ui32FWConfigFlagsExt = 0;
+		/* Pipeline DM roadblocks are currently enabled pre-Eryx. */
+		ui32FWConfigFlags |= RGXFWIF_INICFG_DM_PIPELINE_ROADBLOCKS_EN;
 	}
-	else
+#endif
+
+	ui32FWConfigFlags |= psHints->bDisableDMOverlap ? RGXFWIF_INICFG_DISABLE_DM_OVERLAP : 0;
+
+	if ((RGX_GET_FEATURE_VALUE(psDevInfo, SLC_SIZE_IN_KILOBYTES) <= 2))
 	{
-		PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-
-		IMG_UINT32 ui32TFBCVersion = 0U;
-
-		ui32FWConfigFlags |= psHints->bAssertOnOutOfMem ? RGXFWIF_INICFG_ASSERT_ON_OUTOFMEMORY : 0;
-		ui32FWConfigFlags |= psHints->bAssertOnHWRTrigger ? RGXFWIF_INICFG_ASSERT_ON_HWR_TRIGGER : 0;
-		ui32FWConfigFlags |= psHints->bCheckMlist ? RGXFWIF_INICFG_CHECK_MLIST_EN : 0;
-		ui32FWConfigFlags |= psHints->bDisableClockGating ? RGXFWIF_INICFG_DISABLE_CLKGATING_EN : 0;
-		ui32FWConfigFlags |= psHints->bDisableDMOverlap ? RGXFWIF_INICFG_DISABLE_DM_OVERLAP : 0;
-		ui32FWConfigFlags |= psHints->bDisablePDP ? RGXFWIF_INICFG_DISABLE_PDP_EN : 0;
-		ui32FWConfigFlags |= psHints->bEnableCDMKillRand ? RGXFWIF_INICFG_DM_KILL_MODE_RAND_EN : 0;
-		ui32FWConfigFlags |= psHints->bEnableRandomCsw ? RGXFWIF_INICFG_CTXSWITCH_MODE_RAND : 0;
-		ui32FWConfigFlags |= psHints->bEnableSoftResetCsw ? RGXFWIF_INICFG_CTXSWITCH_SRESET_EN : 0;
-		ui32FWConfigFlags |= (psHints->ui32HWPerfFilter0 != 0 || psHints->ui32HWPerfFilter1 != 0) ? RGXFWIF_INICFG_HWPERF_EN : 0;
-		ui32FWConfigFlags |= psHints->bHWPerfDisableCustomCounterFilter ? RGXFWIF_INICFG_HWP_DISABLE_FILTER : 0;
-		ui32FWConfigFlags |= (psHints->ui32FWContextSwitchProfile << RGXFWIF_INICFG_CTXSWITCH_PROFILE_SHIFT) & RGXFWIF_INICFG_CTXSWITCH_PROFILE_MASK;
-
-#if defined(SUPPORT_VALIDATION)
-#if defined(NO_HARDWARE) && defined(PDUMP)
-		ui32FWConfigFlags |= psHints->bValidateIrq ? RGXFWIF_INICFG_VALIDATE_IRQ : 0;
+		ui32FWConfigFlags |= RGXFWIF_INICFG_DISABLE_DM_OVERLAP;
+	}
+
+	ui32FWConfigFlags |= psHints->bDisablePDP ? RGXFWIF_INICFG_DISABLE_PDP_EN : 0;
+	ui32FWConfigFlags |= psHints->bEnableDMKillRand ? RGXFWIF_INICFG_DM_KILL_MODE_RAND_EN : 0;
+	ui32FWConfigFlags |= psHints->bEnableRandomCsw ? RGXFWIF_INICFG_CTXSWITCH_MODE_RAND : 0;
+	ui32FWConfigFlags |= psHints->bEnableSoftResetCsw ? RGXFWIF_INICFG_CTXSWITCH_SRESET_EN : 0;
+	ui32FWConfigFlags |= (psHints->ui32HWPerfFilter0 != 0 || psHints->ui32HWPerfFilter1 != 0) ? RGXFWIF_INICFG_HWPERF_EN : 0;
+	ui32FWConfigFlags |= psHints->bHWPerfDisableCounterFilter ? RGXFWIF_INICFG_HWP_DISABLE_FILTER : 0;
+	ui32FWConfigFlags |= (psHints->ui32FWContextSwitchProfile << RGXFWIF_INICFG_CTXSWITCH_PROFILE_SHIFT) & RGXFWIF_INICFG_CTXSWITCH_PROFILE_MASK;
+#if defined(PVR_ARCH_VOLCANIC)
+	ui32FWConfigFlags |= (psHints->ui32ISPSchedulingLatencyMode << RGXFWIF_INICFG_ISPSCHEDMODE_SHIFT) & RGXFWIF_INICFG_ISPSCHEDMODE_MASK;
 #endif
 
-		if (psHints->ui32FBCDCVersionOverride > 0)
-		{
-			ui32FWConfigFlags |= (psHints->ui32FBCDCVersionOverride == 2) ? RGXFWIF_INICFG_FBCDC_V3_1_EN : 0;
-		}
-		else
-#endif /* defined(SUPPORT_VALIDATION) */
-		{
-			ui32FWConfigFlags |= psDeviceNode->pfnHasFBCDCVersion31(psDeviceNode) ? RGXFWIF_INICFG_FBCDC_V3_1_EN : 0;
-		}
+	{
+		ui32FWConfigFlags |= psDeviceNode->pfnHasFBCDCVersion31(psDeviceNode) ? RGXFWIF_INICFG_FBCDC_V3_1_EN : 0;
+	}
 
-#if defined(SUPPORT_VALIDATION)
-		ui32FWConfigFlags |= psHints->bValidateSOCUSCTimer ? RGXFWIF_INICFG_VALIDATE_SOCUSC_TIMER : 0;
 
-		if ((ui32FWConfigFlags & RGXFWIF_INICFG_VALIDATE_SOCUSC_TIMER) &&
-		    ((psHints->eRGXActivePMConf != 0) || (psHints->eRGXRDPowerIslandConf != 0)))
-		{
-			psHints->eRGXActivePMConf = 0;
-			psHints->eRGXRDPowerIslandConf = 0;
-			PVR_DPF((PVR_DBG_WARNING, "SoC/USC Timer test needs to run with both EnableAPM and EnableRDPowerIsland disabled.\n"
-				 "Overriding current value for both with new value 0."));
-		}
+#if defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX)
+
+	/* Determine if we need to present a TFBC v1.0, v1.1 or native
+	 * behaviour. For V1.0 we need to set the following features:
+	 *  TFBCCompressionControlLossyMinChannel = 0x1
+	 *  TFBCCompressionControlYUVFormat = 0x1
+	 *  TFBCCompressionControlScheme = 0x2
+	 *  TFBCCompressionControlGroup = 0x0
+	 * For V1.1 we need to set the following:
+	 *  TFBCCompressionControlLossyMinChannel = 0x1
+	 *  TFBCCompressionControlYUVFormat = 0x0
+	 *  TFBCCompressionControlScheme = 0x1
+	 *  TFBCCompressionControlGroup = 0 / 1 (depends on LOSSY_37_PERCENT)
+	 * The gating for these values depends on whether the GPU supports
+	 * RGX_FEATURE_TFBC_VERSION = 20U
+	 */
 
-		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_LOSSY_37_PERCENT) ||
-		    RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_DELTA_CORRELATION) ||
-		    RGX_IS_FEATURE_SUPPORTED(psDevInfo, TFBC_NATIVE_YUV10))
+	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, TFBC_VERSION))
+	{
+		ui32TFBCVersion = RGX_GET_FEATURE_VALUE(psDevInfo, TFBC_VERSION);
+
+		if (ui32TFBCVersion >= 20U)
 		{
-			ui32FWConfigFlagsSupValExt = ui32FWConfigFlagsExt;
+			switch (psHints->ui32TFBCVersion) {
+				case 10:	/* TFBC Version 1.0 */
+					psHints->bTFBCCompressionControlLossyMinChannel = true;
+					psHints->bTFBCCompressionControlYUVFormat = true;
+					psHints->ui32TFBCCompressionControlScheme = 2U;
+					psHints->ui32TFBCCompressionControlGroup = 0U;
+
+#if defined(DEBUG)
+					PVR_LOG(("%s: Setting TFBC Version 1.0, Native v%u",
+					         __func__, ui32TFBCVersion));
+#endif
+					break;
+
+				case 11:	/* TFBC Version 1.1 */
+					psHints->bTFBCCompressionControlLossyMinChannel = true;
+					psHints->bTFBCCompressionControlYUVFormat = false;
+					psHints->ui32TFBCCompressionControlScheme = 1U;
+					psHints->ui32TFBCCompressionControlGroup =
+					    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP;
+
+#if defined(DEBUG)
+					PVR_LOG(("%s: Setting TFBC Version 1.1, Native v%u",
+					         __func__, ui32TFBCVersion));
+#endif
+					break;
+
+				case 0:		/* Leave with whatever the ui32TFBCVersion is */
+					break;
+				default:	/* Unexpected / unsupported value */
+					PVR_DPF((PVR_DBG_WARNING,
+					         "%s: Unexpected TFBC Version %u"
+					         " Ignoring. Using value %u instead",
+					         __func__, psHints->ui32TFBCVersion,
+					         ui32TFBCVersion));
+					break;
+			}
 
-			ui32FWConfigFlagsSupValExt |=
+			ui32FWConfigFlagsExt |=
 				((((psHints->ui32TFBCCompressionControlGroup  << RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_SHIFT) &
 															    ~RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_CLRMSK) |
 				  ((psHints->ui32TFBCCompressionControlScheme << RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_SHIFT) &
@@ -601,226 +610,76 @@ static INLINE void GetFWConfigFlags(PVRSRV_DEVICE_NODE *psDeviceNode,
 				  ((psHints->bTFBCCompressionControlYUVFormat) ? RGX_CR_TFBC_COMPRESSION_CONTROL_YUV10_OVERRIDE_EN : 0) |
 				  ((psHints->bTFBCCompressionControlLossyMinChannel) ? RGX_CR_TFBC_COMPRESSION_CONTROL_LOSSY_MIN_CHANNEL_OVERRIDE_EN : 0))
 				<< RGXFWIF_INICFG_EXT_TFBC_CONTROL_SHIFT) & RGXFWIF_INICFG_EXT_TFBC_CONTROL_MASK;
-			/* Save TFBCCompressionControlGroup for later querying by
-			 * ->pfnGetTFBCLossyGroup()
-			 */
+			/* Save the CompressionControlGroup for later use by
+			 * ->pfnGetTFBCLossyGroup() */
 #if defined(RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK)
 			psDevInfo->ui32TFBCLossyGroup = psHints->ui32TFBCCompressionControlGroup;
 #endif
 		}
-#endif	/* defined(SUPPORT_VALIDATION) */
-		/* Determine if we need to present a TFBC v1.0, v1.1 or native
-		 * behaviour. For V1.0 we need to set the following features:
-		 *  TFBCCompressionControlLossyMinChannel = 0x1
-		 *  TFBCCompressionControlYUVFormat = 0x1
-		 *  TFBCCompressionControlScheme = 0x2
-		 *  TFBCCompressionControlGroup = 0x0
-		 * For V1.1 we need to set the following:
-		 *  TFBCCompressionControlLossyMinChannel = 0x1
-		 *  TFBCCompressionControlYUVFormat = 0x0
-		 *  TFBCCompressionControlScheme = 0x1
-		 *  TFBCCompressionControlGroup = 0 / 1 (depends on LOSSY_37_PERCENT)
-		 * The gating for these values depends on whether the GPU supports
-		 * RGX_FEATURE_TFBC_VERSION = 20U
-		 */
-
-		if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, TFBC_VERSION))
+		else if (ui32TFBCVersion == 11U)
 		{
-			ui32TFBCVersion = RGX_GET_FEATURE_VALUE(psDevInfo, TFBC_VERSION);
-
-			if (ui32TFBCVersion >= 20U)
-			{
-				switch (psHints->ui32TFBCVersion) {
-					case 10:	/* TFBC Version 1.0 */
-						psHints->bTFBCCompressionControlLossyMinChannel = true;
-						psHints->bTFBCCompressionControlYUVFormat = true;
-						psHints->ui32TFBCCompressionControlScheme = 2U;
-						psHints->ui32TFBCCompressionControlGroup = 0U;
-
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
-						PVR_LOG(("%s: Setting TFBC Version 1.0, Native v%u",
-						         __func__, ui32TFBCVersion));
-#endif
-						break;
-
-					case 11:	/* TFBC Version 1.1 */
-						psHints->bTFBCCompressionControlLossyMinChannel = true;
-						psHints->bTFBCCompressionControlYUVFormat = false;
-						psHints->ui32TFBCCompressionControlScheme = 1U;
-#if !defined(SUPPORT_VALIDATION)
-						psHints->ui32TFBCCompressionControlGroup =
-						    PVRSRV_APPHINT_TFBCCOMPRESSIONCONTROLGROUP;
+			switch (psHints->ui32TFBCVersion) {
+				case 10:	/* TFBC Version 1.0 */
+					psHints->bTFBCCompressionControlLossyMinChannel = true;
+					psHints->bTFBCCompressionControlYUVFormat = true;
+					psHints->ui32TFBCCompressionControlScheme = 2U;
+					psHints->ui32TFBCCompressionControlGroup = 0U;
+
+#if defined(DEBUG)
+					PVR_LOG(("%s: Setting TFBC Version 1.0, Native v%u",
+					         __func__, ui32TFBCVersion));
 #endif
+					break;
 
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
-						PVR_LOG(("%s: Setting TFBC Version 1.1, Native v%u",
-						         __func__, ui32TFBCVersion));
-#endif
-						break;
-
-					case 0:		/* Leave with whatever the ui32TFBCVersion is */
-						break;
-					default:	/* Unexpected / unsupported value */
-						PVR_DPF((PVR_DBG_WARNING,
-						         "%s: Unexpected TFBC Version %u"
-						         " Ignoring. Using value %u instead",
-						         __func__, psHints->ui32TFBCVersion,
-						         ui32TFBCVersion));
-						break;
-				}
-
-#if defined(FIX_HW_BRN_73472_BIT_MASK)
-				if (RGX_IS_BRN_SUPPORTED(psDevInfo, 73472))
-				{
-					if (psHints->ui32TFBCCompressionControlScheme != 1U)
-					{
-						PVR_DPF((PVR_DBG_WARNING, "Ignoring TFBCCompressionControlScheme value. Setting to 1 (as per BRN73472)"));
-					}
+				case 0:		/* Leave with whatever the ui32TFBCVersion is */
+					break;
 
-					psHints->ui32TFBCCompressionControlScheme = 1U;
-				}
-#endif
-				ui32FWConfigFlagsExt |=
-					((((psHints->ui32TFBCCompressionControlGroup  << RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_SHIFT) &
-																    ~RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_CLRMSK) |
-					  ((psHints->ui32TFBCCompressionControlScheme << RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_SHIFT) &
-																    ~RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_CLRMSK) |
-					  ((psHints->bTFBCCompressionControlYUVFormat) ? RGX_CR_TFBC_COMPRESSION_CONTROL_YUV10_OVERRIDE_EN : 0) |
-					  ((psHints->bTFBCCompressionControlLossyMinChannel) ? RGX_CR_TFBC_COMPRESSION_CONTROL_LOSSY_MIN_CHANNEL_OVERRIDE_EN : 0))
-					<< RGXFWIF_INICFG_EXT_TFBC_CONTROL_SHIFT) & RGXFWIF_INICFG_EXT_TFBC_CONTROL_MASK;
-				/* Save the CompressionControlGroup for later use by
-				 * ->pfnGetTFBCLossyGroup() */
-#if defined(RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK)
-				psDevInfo->ui32TFBCLossyGroup = psHints->ui32TFBCCompressionControlGroup;
-#endif
+				default:	/* Unexpected / unsupported value */
+					PVR_DPF((PVR_DBG_WARNING,
+					         "%s: Unexpected TFBC Version %u"
+				             " Ignoring. Using value %u instead",
+				             __func__, psHints->ui32TFBCVersion,
+				             ui32TFBCVersion));
+					break;
 			}
-			else if (ui32TFBCVersion == 11U)
-			{
-				switch (psHints->ui32TFBCVersion) {
-					case 10:	/* TFBC Version 1.0 */
-						psHints->bTFBCCompressionControlLossyMinChannel = true;
-						psHints->bTFBCCompressionControlYUVFormat = true;
-						psHints->ui32TFBCCompressionControlScheme = 2U;
-						psHints->ui32TFBCCompressionControlGroup = 0U;
-
-#if defined(DEBUG) || defined(SUPPORT_VALIDATION)
-						PVR_LOG(("%s: Setting TFBC Version 1.0, Native v%u",
-						         __func__, ui32TFBCVersion));
-#endif
-						break;
-
-					case 0:		/* Leave with whatever the ui32TFBCVersion is */
-						break;
-
-					default:	/* Unexpected / unsupported value */
-						PVR_DPF((PVR_DBG_WARNING,
-						         "%s: Unexpected TFBC Version %u"
-					             " Ignoring. Using value %u instead",
-					             __func__, psHints->ui32TFBCVersion,
-					             ui32TFBCVersion));
-						break;
-				}
-				ui32FWConfigFlagsExt |=
-					((((psHints->ui32TFBCCompressionControlGroup  << RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_SHIFT) &
-																    ~RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_CLRMSK) |
-					  ((psHints->ui32TFBCCompressionControlScheme << RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_SHIFT) &
-																    ~RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_CLRMSK) |
-					  ((psHints->bTFBCCompressionControlYUVFormat) ? RGX_CR_TFBC_COMPRESSION_CONTROL_YUV10_OVERRIDE_EN : 0) |
-					  ((psHints->bTFBCCompressionControlLossyMinChannel) ? RGX_CR_TFBC_COMPRESSION_CONTROL_LOSSY_MIN_CHANNEL_OVERRIDE_EN : 0))
-					<< RGXFWIF_INICFG_EXT_TFBC_CONTROL_SHIFT) & RGXFWIF_INICFG_EXT_TFBC_CONTROL_MASK;
-				/* Save the CompressionControlGroup for later use by
-				 * ->pfnGetTFBCLossyGroup() */
+			ui32FWConfigFlagsExt |=
+				((((psHints->ui32TFBCCompressionControlGroup  << RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_SHIFT) &
+															    ~RGX_CR_TFBC_COMPRESSION_CONTROL_GROUP_CONTROL_CLRMSK) |
+				  ((psHints->ui32TFBCCompressionControlScheme << RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_SHIFT) &
+															    ~RGX_CR_TFBC_COMPRESSION_CONTROL_SCHEME_CLRMSK) |
+				  ((psHints->bTFBCCompressionControlYUVFormat) ? RGX_CR_TFBC_COMPRESSION_CONTROL_YUV10_OVERRIDE_EN : 0) |
+				  ((psHints->bTFBCCompressionControlLossyMinChannel) ? RGX_CR_TFBC_COMPRESSION_CONTROL_LOSSY_MIN_CHANNEL_OVERRIDE_EN : 0))
+				<< RGXFWIF_INICFG_EXT_TFBC_CONTROL_SHIFT) & RGXFWIF_INICFG_EXT_TFBC_CONTROL_MASK;
+			/* Save the CompressionControlGroup for later use by
+			 * ->pfnGetTFBCLossyGroup() */
 #if defined(RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK)
-				psDevInfo->ui32TFBCLossyGroup = psHints->ui32TFBCCompressionControlGroup;
+			psDevInfo->ui32TFBCLossyGroup = psHints->ui32TFBCCompressionControlGroup;
 #endif
-			}
-			else	/* TFBC v1.0 */
-			{
-#if defined(SUPPORT_VALIDATION)
-				ui32FWConfigFlagsExt = ui32FWConfigFlagsSupValExt;
-#else /* !defined(SUPPORT_VALIDATION) */
-				PVR_UNREFERENCED_PARAMETER(ui32FWConfigFlagsSupValExt);
-#endif /* !defined(SUPPORT_VALIDATION) */
+		}
+		else	/* TFBC v1.0 */
+		{
+			PVR_UNREFERENCED_PARAMETER(ui32FWConfigFlagsSupValExt);
 #if defined(RGX_FEATURE_TFBC_LOSSY_37_PERCENT_BIT_MASK)
-				psDevInfo->ui32TFBCLossyGroup = 0;
+			psDevInfo->ui32TFBCLossyGroup = 0;
 #endif
-				if ((psHints->ui32TFBCVersion != 0U) &&
-				    (psHints->ui32TFBCVersion != ui32TFBCVersion))
-				{
-					PVR_DPF((PVR_DBG_WARNING,
-					        "%s: Cannot specify TFBC version %u"
-					         " on a version %u GPU core", __func__,
-					         psHints->ui32TFBCVersion, ui32TFBCVersion));
-				}
+			if ((psHints->ui32TFBCVersion != 0U) &&
+			    (psHints->ui32TFBCVersion != ui32TFBCVersion))
+			{
+				PVR_DPF((PVR_DBG_WARNING,
+				        "%s: Cannot specify TFBC version %u"
+				         " on a version %u GPU core", __func__,
+				         psHints->ui32TFBCVersion, ui32TFBCVersion));
 			}
 		}
 	}
+#endif /* defined(RGX_FEATURE_TFBC_VERSION_MAX_VALUE_IDX) */
 
 	*pui32FWConfigFlags    = ui32FWConfigFlags;
 	*pui32FWConfigFlagsExt = ui32FWConfigFlagsExt;
-	*pui32FwOsCfgFlags     = psHints->ui32FWContextSwitchCrossDM |
-	                         (psHints->ui32EnableFWContextSwitch & ~RGXFWIF_INICFG_OS_CTXSWITCH_CLRMSK);
+	*pui32FwOsCfgFlags     = ui32FwOsCfgFlags;
 }
 
 
-/*!
-*******************************************************************************
-
- @Function      GetFilterFlags
-
- @Description   Initialise and return filter flags
-
- @Input         psHints : Apphints container
-
- @Return        IMG_UINT32 : Filter flags
-
-******************************************************************************/
-static INLINE IMG_UINT32 GetFilterFlags(RGX_SRVINIT_APPHINTS *psHints)
-{
-	IMG_UINT32 ui32FilterFlags = 0;
-
-	ui32FilterFlags |= psHints->bFilteringMode ? RGXFWIF_FILTCFG_NEW_FILTER_MODE : 0;
-	if (psHints->ui32TruncateMode == 2)
-	{
-		ui32FilterFlags |= RGXFWIF_FILTCFG_TRUNCATE_INT;
-	}
-	else if (psHints->ui32TruncateMode == 3)
-	{
-		ui32FilterFlags |= RGXFWIF_FILTCFG_TRUNCATE_HALF;
-	}
-
-	return ui32FilterFlags;
-}
-
-
-/*!
-*******************************************************************************
-
- @Function      InitDeviceFlags
-
- @Description   Initialise and return device flags
-
- @Input         psHints          : Apphints container
- @Input         pui32DeviceFlags : Pointer to device flags
-
- @Return        void
-
-******************************************************************************/
-static INLINE void InitDeviceFlags(RGX_SRVINIT_APPHINTS *psHints,
-                                  IMG_UINT32 *pui32DeviceFlags)
-{
-	IMG_UINT32 ui32DeviceFlags = 0;
-
-	ui32DeviceFlags |= psHints->bGPUUnitsPowerChange ? RGXKM_DEVICE_STATE_GPU_UNITS_POWER_CHANGE_EN : 0;
-	ui32DeviceFlags |= psHints->bZeroFreelist ? RGXKM_DEVICE_STATE_ZERO_FREELIST : 0;
-	ui32DeviceFlags |= psHints->bDisableFEDLogging ? RGXKM_DEVICE_STATE_DISABLE_DW_LOGGING_EN : 0;
-#if defined(PVRSRV_ENABLE_CCCB_GROW)
-	BITMASK_SET(ui32DeviceFlags, RGXKM_DEVICE_STATE_CCB_GROW_EN);
-#endif
-
-	*pui32DeviceFlags = ui32DeviceFlags;
-}
-
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 /*!
 *******************************************************************************
@@ -831,18 +690,17 @@ static INLINE void InitDeviceFlags(RGX_SRVINIT_APPHINTS *psHints,
                 the FW image setup
 
  @Input         psDeviceNode : Device node
- @Input         psRGXFW      : Firmware blob
- @Input         puFWParams   : Parameters used by the FW at boot time
+ @Input         psFWParams : Firmware and parameters used by the FW
 
  @Return        PVRSRV_ERROR
 ******************************************************************************/
 static PVRSRV_ERROR RGXTDProcessFWImage(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                        OS_FW_IMAGE *psRGXFW,
-                                        PVRSRV_FW_BOOT_PARAMS *puFWParams)
+                                        PVRSRV_FW_PARAMS *psFWParams)
 {
 	PVRSRV_DEVICE_CONFIG *psDevConfig = psDeviceNode->psDevConfig;
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_TD_FW_PARAMS sTDFWParams;
+#endif
 	PVRSRV_ERROR eError;
 
 	if (psDevConfig->pfnTDSendFWImage == NULL)
@@ -851,34 +709,21 @@ static PVRSRV_ERROR RGXTDProcessFWImage(PVRSRV_DEVICE_NODE *psDeviceNode,
 		return PVRSRV_ERROR_NOT_IMPLEMENTED;
 	}
 
-	sTDFWParams.pvFirmware       = OSFirmwareData(psRGXFW);
-	sTDFWParams.ui32FirmwareSize = OSFirmwareSize(psRGXFW);
-
-	if (RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META))
-	{
-		sTDFWParams.uFWP.sMeta = puFWParams->sMeta;
-	}
 #if defined(RGX_FEATURE_MIPS_BIT_MASK)
-	else if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS))
 	{
-		sTDFWParams.uFWP.sMips = puFWParams->sMips;
-
-		if (sTDFWParams.uFWP.sMips.ui32FWPageTableNumPages > TD_MAX_NUM_MIPS_PAGETABLE_PAGES)
+		if (psFWParams->uFWP.sMips.ui32FWPageTableNumPages > TD_MAX_NUM_MIPS_PAGETABLE_PAGES)
 		{
 			PVR_DPF((PVR_DBG_ERROR, "%s: Number of page table pages %u greater "
 					 "than what is allowed by the TD interface (%u), FW might "
 					 "not work properly!", __func__,
-					 puFWParams->sMips.ui32FWPageTableNumPages,
+					 psFWParams->uFWP.sMips.ui32FWPageTableNumPages,
 					 TD_MAX_NUM_MIPS_PAGETABLE_PAGES));
 		}
 	}
 #endif
-	else
-	{
-		sTDFWParams.uFWP.sRISCV = puFWParams->sRISCV;
-	}
 
-	eError = psDevConfig->pfnTDSendFWImage(psDevConfig->hSysData, &sTDFWParams);
+	eError = psDevConfig->pfnTDSendFWImage(psDevConfig->hSysData, psFWParams);
 
 	return eError;
 }
@@ -975,16 +820,14 @@ static PVRSRV_ERROR RGXAcquireMipsBootldrData(PVRSRV_DEVICE_NODE *psDeviceNode,
  @Description   Allocate, initialise and pdump Firmware code and data memory
 
  @Input         psDeviceNode : Device Node
- @Input         psHints      : Apphints
 
  @Return        PVRSRV_ERROR
 
 ******************************************************************************/
-static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
-                                 RGX_SRVINIT_APPHINTS *psHints)
+static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	OS_FW_IMAGE       *psRGXFW = NULL;
-	const IMG_BYTE    *pbRGXFirmware = NULL;
+	PVRSRV_FW_PARAMS  sFWParams = {0};
 
 	/* FW code memory */
 	IMG_DEVMEM_SIZE_T uiFWCodeAllocSize;
@@ -1003,22 +846,23 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	void              *pvFWCorememDataHostAddr = NULL;
 
 	PVRSRV_FW_BOOT_PARAMS uFWParams;
-	RGX_LAYER_PARAMS sLayerParams;
 	PVRSRV_ERROR eError;
 	PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO *)psDeviceNode->pvDevice;
 
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 	IMG_BOOL bUseSecureFWData =
 								RGX_IS_FEATURE_VALUE_SUPPORTED(psDevInfo, META) ||
-	                            RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR) ||
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
 	                            (RGX_IS_FEATURE_SUPPORTED(psDevInfo, MIPS) &&
-	                             RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH) > 32);
+	                             RGX_GET_FEATURE_VALUE(psDevInfo, PHYS_BUS_WIDTH) > 32) ||
+#endif
+	                            RGX_IS_FEATURE_SUPPORTED(psDevInfo, RISCV_FW_PROCESSOR);
 #endif
 
 	/*
 	 * Get pointer to Firmware image
 	 */
-	eError = RGXLoadAndGetFWData(psDeviceNode, &psRGXFW, &pbRGXFirmware);
+	eError = RGXLoadAndGetFWData(psDeviceNode, &psRGXFW);
 
 	if (eError != PVRSRV_OK)
 	{
@@ -1026,15 +870,30 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 		goto fw_load_fail;
 	}
 
-	sLayerParams.psDevInfo = psDevInfo;
+	/*
+	 * Get pointer and size
+	 */
+	sFWParams.pvFirmware       = OSFirmwareData(psRGXFW);
+	sFWParams.ui32FirmwareSize = OSFirmwareSize(psRGXFW);
+
+	/*
+	 * Allow it to be pre-processed by the platform hook
+	 */
+	if (psDeviceNode->psDevConfig->pfnPrepareFWImage != NULL)
+	{
+		eError = psDeviceNode->psDevConfig->pfnPrepareFWImage(
+				psDeviceNode->psDevConfig->hSysData, &sFWParams);
+		if (eError != PVRSRV_OK)
+			goto cleanup_initfw;
+	}
 
 	/*
 	 * Allocate Firmware memory
 	 */
 
-	eError = RGXGetFWImageAllocSize(&sLayerParams,
-	                                pbRGXFirmware,
-	                                OSFirmwareSize(psRGXFW),
+	eError = RGXGetFWImageAllocSize(&psDevInfo->sLayerParams,
+	                                sFWParams.pvFirmware,
+	                                sFWParams.ui32FirmwareSize,
 	                                &uiFWCodeAllocSize,
 	                                &uiFWDataAllocSize,
 	                                &uiFWCorememCodeAllocSize,
@@ -1053,7 +912,7 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	 * Initiate FW compatibility check for Native and Host.
 	 * Guest compatibility check must be done after FW boot.
 	 */
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = PVRSRVDevInitCompatCheck(psDeviceNode);
 		if (eError != PVRSRV_OK)
@@ -1068,14 +927,11 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	psDevInfo->ui32FWCodeSizeInBytes = uiFWCodeAllocSize;
 
 #if defined(SUPPORT_TRUSTED_DEVICE)
-	if (!RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_DMA))
-	{
-		PVR_DPF((PVR_DBG_WARNING,
-		        "%s: META DMA not available, disabling core memory code/data",
-		        __func__));
-		uiFWCorememCodeAllocSize = 0;
-		uiFWCorememDataAllocSize = 0;
-	}
+    PVR_DPF((PVR_DBG_WARNING,
+            "%s: META DMA not available, disabling core memory code/data",
+            __func__));
+    uiFWCorememCodeAllocSize = 0;
+    uiFWCorememDataAllocSize = 0;
 #endif
 
 	psDevInfo->ui32FWCorememCodeSizeInBytes = uiFWCorememCodeAllocSize;
@@ -1098,14 +954,18 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	 * Acquire pointers to Firmware allocations
 	 */
 
-#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(NO_HARDWARE) || defined(SUPPORT_SECURITY_VALIDATION)
-	eError = DevmemAcquireCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc, &pvFWCodeHostAddr);
-	PVR_LOG_GOTO_IF_ERROR(eError, "DevmemAcquireCpuVirtAddr", cleanup_initfw);
-
-#else
-	/* We can't get a pointer to a secure FW allocation from within the DDK */
-	pvFWCodeHostAddr = NULL;
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	if (bUseSecureFWData)
+	{
+		/* We can't get a pointer to a secure FW allocation from within the DDK */
+		pvFWCodeHostAddr = NULL;
+	}
+	else
 #endif
+	{
+		eError = DevmemAcquireCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc, &pvFWCodeHostAddr);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemAcquireCpuVirtAddr", cleanup_initfw);
+	}
 
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 	if (bUseSecureFWData)
@@ -1120,16 +980,19 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemAcquireCpuVirtAddr", release_code);
 	}
 
-#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(NO_HARDWARE) || defined(SUPPORT_SECURITY_VALIDATION)
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	if (bUseSecureFWData)
+	{
+		/* We can't get a pointer to a secure FW allocation from within the DDK */
+		pvFWCorememCodeHostAddr = NULL;
+	}
+	else
+#endif
 	if (uiFWCorememCodeAllocSize != 0)
 	{
 		eError = DevmemAcquireCpuVirtAddr(psDevInfo->psRGXFWCorememCodeMemDesc, &pvFWCorememCodeHostAddr);
 		PVR_LOG_GOTO_IF_ERROR(eError, "DevmemAcquireCpuVirtAddr", release_data);
 	}
-#else
-	/* We can't get a pointer to a secure FW allocation from within the DDK */
-	pvFWCorememCodeHostAddr = NULL;
-#endif
 
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 	if (bUseSecureFWData)
@@ -1180,6 +1043,9 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 #endif
 	else
 	{
+		uFWParams.sRISCV.sFWCodeDevVAddr = psDevInfo->sFWCodeDevVAddrBase;
+		uFWParams.sRISCV.sFWDataDevVAddr = psDevInfo->sFWDataDevVAddrBase;
+
 		uFWParams.sRISCV.sFWCorememCodeDevVAddr = psDevInfo->sFWCorememCodeDevVAddrBase;
 		uFWParams.sRISCV.sFWCorememCodeFWAddr   = psDevInfo->sFWCorememCodeFWAddr;
 		uFWParams.sRISCV.uiFWCorememCodeSize    = uiFWCorememCodeAllocSize;
@@ -1200,8 +1066,8 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	 */
 	if (!psDeviceNode->bAutoVzFwIsUp)
 	{
-		eError = RGXProcessFWImage(&sLayerParams,
-								   pbRGXFirmware,
+		eError = RGXProcessFWImage(&psDevInfo->sLayerParams,
+								   sFWParams.pvFirmware,
 								   pvFWCodeHostAddr,
 								   pvFWDataHostAddr,
 								   pvFWCorememCodeHostAddr,
@@ -1238,7 +1104,8 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	}
 
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
-	RGXTDProcessFWImage(psDeviceNode, psRGXFW, &uFWParams);
+	sFWParams.uFWP = uFWParams;
+	RGXTDProcessFWImage(psDeviceNode, &sFWParams);
 #endif
 
 
@@ -1307,16 +1174,16 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	}
 
 release_corememcode:
-#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(NO_HARDWARE) || defined(SUPPORT_SECURITY_VALIDATION)
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	if (!bUseSecureFWData && (uiFWCorememCodeAllocSize != 0))
+#else
 	if (uiFWCorememCodeAllocSize != 0)
+#endif
 	{
 		DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWCorememCodeMemDesc);
 	}
-#endif
 
-#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(NO_HARDWARE) || defined(SUPPORT_SECURITY_VALIDATION)
 release_data:
-#endif
 #if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
 	if (!bUseSecureFWData)
 #endif
@@ -1325,9 +1192,12 @@ static PVRSRV_ERROR InitFirmware(PVRSRV_DEVICE_NODE *psDeviceNode,
 	}
 
 release_code:
-#if !defined(SUPPORT_TRUSTED_DEVICE) || defined(NO_HARDWARE) || defined(SUPPORT_SECURITY_VALIDATION)
-	DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc);
+#if defined(SUPPORT_TRUSTED_DEVICE) && !defined(NO_HARDWARE) && !defined(SUPPORT_SECURITY_VALIDATION)
+	if (!bUseSecureFWData)
 #endif
+	{
+		DevmemReleaseCpuVirtAddr(psDevInfo->psRGXFWCodeMemDesc);
+	}
 cleanup_initfw:
 	OSUnloadFirmware(psRGXFW);
 fw_load_fail:
@@ -1376,8 +1246,8 @@ static void InitialiseHWPerfCounters(PVRSRV_DEVICE_NODE *psDeviceNode,
 
 	for (ui32BlkCfgIdx = 0; ui32BlkCfgIdx < ui32CntBlkModelLen; ui32BlkCfgIdx++)
 	{
-		IMG_UINT32 uiUnit;
-		IMG_BOOL bDirect;
+		__maybe_unused IMG_UINT32 uiUnit;
+		__maybe_unused IMG_BOOL bDirect;
 
 		/* Exit early if this core does not have any of these counter blocks
 		 * due to core type/BVNC features.... */
@@ -1639,11 +1509,14 @@ static PVRSRV_ERROR RGXValidateTDHeaps(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVRSRV_ERROR eError;
 
-	eError = RGXValidateTDHeap(psDeviceNode, PVRSRV_PHYS_HEAP_FW_PRIV_DATA, PHYS_HEAP_USAGE_FW_PRIV_DATA);
-	PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeap:FW_PRIV_DATA");
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
+	{
+		eError = RGXValidateTDHeap(psDeviceNode, PVRSRV_PHYS_HEAP_FW_PRIV_DATA, PHYS_HEAP_USAGE_FW_PRIV_DATA);
+		PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeap:FW_PRIV_DATA");
 
-	eError = RGXValidateTDHeap(psDeviceNode, PVRSRV_PHYS_HEAP_FW_CODE, PHYS_HEAP_USAGE_FW_CODE);
-	PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeap:FW_CODE");
+		eError = RGXValidateTDHeap(psDeviceNode, PVRSRV_PHYS_HEAP_FW_CODE, PHYS_HEAP_USAGE_FW_CODE);
+		PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeap:FW_CODE");
+	}
 
 	eError = RGXValidateTDHeap(psDeviceNode, PVRSRV_PHYS_HEAP_GPU_SECURE, PHYS_HEAP_USAGE_GPU_SECURE);
 	PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeap:GPU_SECURE");
@@ -1669,12 +1542,10 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	PVRSRV_ERROR eError;
 
 	/* Services initialisation parameters */
-	RGX_SRVINIT_APPHINTS sApphints = {0};
+	RGX_INIT_APPHINTS sApphints = {0};
 	IMG_UINT32 ui32FWConfigFlags, ui32FWConfigFlagsExt, ui32FwOsCfgFlags;
-	IMG_UINT32 ui32DeviceFlags;
 
 	PVRSRV_RGXDEV_INFO *psDevInfo = (PVRSRV_RGXDEV_INFO *)psDeviceNode->pvDevice;
-	RGX_LAYER_PARAMS sLayerParams;
 
 	PDUMPCOMMENT(psDeviceNode, "RGX Initialisation Part 1");
 
@@ -1698,28 +1569,24 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	             psDevInfo->sDevFeatureCfg.ui32N,
 	             psDevInfo->sDevFeatureCfg.ui32C);
 
-	RGXInitMultiCoreInfo(psDeviceNode);
-
-	sLayerParams.psDevInfo = psDevInfo;
-
 #if defined(SUPPORT_TRUSTED_DEVICE)
 	eError = RGXValidateTDHeaps(psDeviceNode);
 	PVR_LOG_RETURN_IF_ERROR(eError, "RGXValidateTDHeaps");
 #endif
 
 #if defined(SUPPORT_AUTOVZ)
-	if (PVRSRV_VZ_MODE_IS(HOST))
+	if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode))
 	{
-		/* The RGX_CR_MTS_DM0_INTERRUPT_ENABLE register is always set by the firmware during initialisation
+		/* The RGX_CR_MTS_DM4_INTERRUPT_ENABLE register is always set by the firmware during initialisation
 		 * and it provides a good method of determining if the firmware has been booted previously */
-		psDeviceNode->bAutoVzFwIsUp = (OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MTS_DM0_INTERRUPT_ENABLE) != 0);
+		psDeviceNode->bAutoVzFwIsUp = (OSReadHWReg32(psDevInfo->pvRegsBaseKM, RGX_CR_MTS_DM4_INTERRUPT_ENABLE) != 0);
 
 		PVR_LOG(("AutoVz startup check: firmware is %s;",
 				(psDeviceNode->bAutoVzFwIsUp) ? "already running" : "powered down"));
 		PVR_LOG(("AutoVz allow GPU powerdown is %s:",
 				(psDeviceNode->bAutoVzAllowGPUPowerdown) ? "enabled" : "disabled"));
 	}
-	else if (PVRSRV_VZ_MODE_IS(GUEST))
+	else if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* Guest assumes the firmware is always available */
 		psDeviceNode->bAutoVzFwIsUp = IMG_TRUE;
@@ -1732,7 +1599,7 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 		psDeviceNode->bAutoVzFwIsUp = IMG_FALSE;
 	}
 
-	if (PVRSRV_VZ_MODE_IS(GUEST) || (psDeviceNode->bAutoVzFwIsUp))
+	if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode) || (psDeviceNode->bAutoVzFwIsUp))
 	{
 		/* set the device power state here as the regular power
 		 * callbacks will not be executed on this driver */
@@ -1742,13 +1609,17 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	/* Set which HW Safety Events will be handled by the driver */
 	psDevInfo->ui32HostSafetyEventMask |= RGX_IS_FEATURE_SUPPORTED(psDevInfo, WATCHDOG_TIMER) ?
 										  RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__WATCHDOG_TIMEOUT_EN : 0;
-	psDevInfo->ui32HostSafetyEventMask |= (RGX_DEVICE_HAS_FEATURE_VALUE(&sLayerParams, ECC_RAMS)
-										   && (RGX_DEVICE_GET_FEATURE_VALUE(&sLayerParams, ECC_RAMS) > 0)) ?
+	psDevInfo->ui32HostSafetyEventMask |= (RGX_DEVICE_HAS_FEATURE_VALUE(&psDevInfo->sLayerParams, ECC_RAMS)
+										   && (RGX_DEVICE_GET_FEATURE_VALUE(&psDevInfo->sLayerParams, ECC_RAMS) > 0)) ?
 										  RGX_CR_SAFETY_EVENT_STATUS__ROGUEXE__FAULT_FW_EN : 0;
 
+#if defined(PDUMP)
+	PDUMPCOMMENTWITHFLAGS(psDeviceNode, PDUMP_FLAGS_CONTINUOUS,
+	                      "Register defs revision: %d", RGX_CR_DEFS_KM_REVISION);
+#endif
+
 	/* Services initialisation parameters */
 	GetApphints(psDevInfo, &sApphints);
-	InitDeviceFlags(&sApphints, &ui32DeviceFlags);
 
 #if defined(SUPPORT_GPUVIRT_VALIDATION)
 #if defined(EMULATOR)
@@ -1769,9 +1640,9 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 		goto cleanup;
 	}
 
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
-		eError = InitFirmware(psDeviceNode, &sApphints);
+		eError = InitFirmware(psDeviceNode);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
@@ -1788,25 +1659,8 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	GetFWConfigFlags(psDeviceNode, &sApphints, &ui32FWConfigFlags, &ui32FWConfigFlagsExt, &ui32FwOsCfgFlags);
 
 	eError = RGXInitFirmware(psDeviceNode,
-	                         sApphints.bEnableSignatureChecks,
-	                         sApphints.ui32SignatureChecksBufSize,
-	                         sApphints.ui32HWPerfFWBufSize,
-	                         (IMG_UINT64)sApphints.ui32HWPerfFilter0 |
-	                         ((IMG_UINT64)sApphints.ui32HWPerfFilter1 << 32),
+	                         &sApphints,
 	                         ui32FWConfigFlags,
-	                         sApphints.ui32LogType,
-	                         GetFilterFlags(&sApphints),
-	                         sApphints.ui32JonesDisableMask,
-	                         sApphints.ui32HWRDebugDumpLimit,
-	                         sizeof(RGXFWIF_HWPERF_CTL),
-#if defined(SUPPORT_VALIDATION)
-	                         &sApphints.aui32TPUTrilinearFracMask[0],
-#else
-	                         NULL,
-#endif
-	                         sApphints.eRGXRDPowerIslandConf,
-	                         sApphints.eFirmwarePerf,
-	                         sApphints.ui32KCCBSizeLog2,
 	                         ui32FWConfigFlagsExt,
 	                         ui32FwOsCfgFlags);
 
@@ -1819,7 +1673,7 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	}
 
 #if defined(PDUMP)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		eError = InitialiseAllCounters(psDeviceNode);
 		if (eError != PVRSRV_OK)
@@ -1836,10 +1690,7 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 	 * Perform second stage of RGX initialisation
 	 */
 	eError = RGXInitDevPart2(psDeviceNode,
-	                         ui32DeviceFlags,
-	                         sApphints.ui32HWPerfHostFilter,
-	                         sApphints.eRGXActivePMConf,
-	                         sApphints.eDebugDumpFWTLogType);
+	                         &sApphints);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
@@ -1848,9 +1699,6 @@ PVRSRV_ERROR RGXInit(PVRSRV_DEVICE_NODE *psDeviceNode)
 		goto cleanup;
 	}
 
-#if defined(SUPPORT_VALIDATION)
-	PVRSRVAppHintDumpState(psDeviceNode);
-#endif
 
 	eError = PVRSRV_OK;
 
diff --git a/drivers/gpu/drm/img-rogue/rgxstartstop.c b/drivers/gpu/drm/img-rogue/rgxstartstop.c
index 924c435c55de..2b93b46ff3ef 100644
--- a/drivers/gpu/drm/img-rogue/rgxstartstop.c
+++ b/drivers/gpu/drm/img-rogue/rgxstartstop.c
@@ -48,33 +48,141 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * Any new code should be built on top of the existing abstraction layer,
  * which should be extended when necessary. */
 #include "rgxstartstop.h"
-#include "rgxfwutils.h"
 
-#if defined(SUPPORT_SHARED_SLC)
-#include "rgxapi_km.h"
+#define SOC_FEATURE_STRICT_SAME_ADDRESS_WRITE_ORDERING
+
+/*
+	RGXWriteMetaRegThroughSP
+*/
+PVRSRV_ERROR RGXWriteMetaRegThroughSP(const void *hPrivate,
+                                      IMG_UINT32 ui32RegAddr,
+                                      IMG_UINT32 ui32RegValue)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_UINT32 ui32StateReg, ui32StateReadyFlag;
+	IMG_UINT32 ui32CtrlReg, ui32DataReg;
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, META_REGISTER_UNPACKED_ACCESSES))
+	{
+		/* ensure the meta_registers_unpacked_accesses auto-increment feature is not used */
+		BITMASK_UNSET(ui32RegAddr, RGX_CR_META_SP_MSLVCTRL0_AUTOINCR_EN);
+
+		if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, HOST_SECURITY_VERSION) > 1)
+		{
+			ui32StateReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA;
+			ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN |
+								 RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN;
+			ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA;
+			ui32DataReg = RGX_CR_META_SP_MSLVDATAT__HOST_SECURITY_GT1_AND_MRUA;
+		}
+		else
+		{
+			ui32StateReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA;
+			ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN |
+								 RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN;
+			ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA;
+			ui32DataReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA;
+		}
+	}
+	else
 #endif
+	{
+		ui32StateReg = RGX_CR_META_SP_MSLVCTRL1;
+		ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1_READY_EN |
+							 RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN;
+		ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL0;
+		ui32DataReg = RGX_CR_META_SP_MSLVDATAT;
+	}
 
-#include "rgxdevice.h"
-#include "km/rgxdefs_km.h"
+	eError = RGXPollReg32(hPrivate, ui32StateReg, ui32StateReadyFlag, ui32StateReadyFlag);
 
-#define SOC_FEATURE_STRICT_SAME_ADDRESS_WRITE_ORDERING
+	if (eError == PVRSRV_OK)
+	{
+		/* Issue a Write */
+		RGXWriteReg32(hPrivate, ui32CtrlReg, ui32RegAddr);
+		(void) RGXReadReg32(hPrivate, ui32CtrlReg); /* Fence write */
+		RGXWriteReg32(hPrivate, ui32DataReg, ui32RegValue);
+		(void) RGXReadReg32(hPrivate, ui32DataReg); /* Fence write */
+	}
 
+	return eError;
+}
 
-/*!
-*******************************************************************************
+/*
+	RGXReadMetaRegThroughSP
+*/
+PVRSRV_ERROR RGXReadMetaRegThroughSP(const void *hPrivate,
+                                     IMG_UINT32 ui32RegAddr,
+                                     IMG_UINT32* ui32RegValue)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_UINT32 ui32StateReg, ui32StateReadyFlag;
+	IMG_UINT32 ui32CtrlReg, ui32DataReg;
+
+#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, META_REGISTER_UNPACKED_ACCESSES))
+	{
+		/* ensure the meta_registers_unpacked_accesses auto-increment feature is not used */
+		BITMASK_UNSET(ui32RegAddr, RGX_CR_META_SP_MSLVCTRL0_AUTOINCR_EN);
 
- @Function      RGXEnableClocks
+		if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, HOST_SECURITY_VERSION) > 1)
+		{
+			ui32StateReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA;
+			ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__READY_EN |
+								 RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_GT1_AND_MRUA__GBLPORT_IDLE_EN;
+			ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA;
+			ui32DataReg = RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_GT1_AND_MRUA;
+			BITMASK_SET(ui32RegAddr, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_GT1_AND_MRUA__RD_EN);
+		}
+		else
+		{
+			ui32StateReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA;
+			ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__READY_EN |
+								 RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA__GBLPORT_IDLE_EN;
+			ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL1__HOST_SECURITY_EQ1_AND_MRUA;
+			ui32DataReg = RGX_CR_META_SP_MSLVDATAX__HOST_SECURITY_EQ1_AND_MRUA;
+			BITMASK_SET(ui32RegAddr, RGX_CR_META_SP_MSLVCTRL0__HOST_SECURITY_EQ1_AND_MRUA__RD_EN);
+		}
+	}
+	else
+#endif
+	{
+		ui32StateReg = RGX_CR_META_SP_MSLVCTRL1;
+		ui32StateReadyFlag = RGX_CR_META_SP_MSLVCTRL1_READY_EN |
+							 RGX_CR_META_SP_MSLVCTRL1_GBLPORT_IDLE_EN;
+		ui32CtrlReg = RGX_CR_META_SP_MSLVCTRL0;
+		ui32DataReg = RGX_CR_META_SP_MSLVDATAX;
+		BITMASK_SET(ui32RegAddr, RGX_CR_META_SP_MSLVCTRL0_RD_EN);
+	}
 
- @Description   Enable RGX Clocks
+	/* Wait for Slave Port to be Ready */
+	eError = RGXPollReg32(hPrivate,
+						  ui32StateReg,
+						  ui32StateReadyFlag,
+						  ui32StateReadyFlag);
+	if (eError == PVRSRV_OK)
+	{
+		/* Issue a Read */
+		RGXWriteReg32(hPrivate, ui32CtrlReg, ui32RegAddr);
+		(void) RGXReadReg32(hPrivate, ui32CtrlReg); /* Fence write */
 
- @Input         hPrivate  : Implementation specific data
+		/* Wait for Slave Port to be Ready */
+		eError = RGXPollReg32(hPrivate,
+				  ui32StateReg,
+				  ui32StateReadyFlag,
+				  ui32StateReadyFlag);
+		if (eError != PVRSRV_OK) return eError;
+	}
 
- @Return        void
+#if !defined(NO_HARDWARE)
+	*ui32RegValue = RGXReadReg32(hPrivate, ui32DataReg);
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32DataReg);
+	*ui32RegValue = 0xFFFFFFFF;
+#endif
 
-******************************************************************************/
-static void RGXEnableClocks(const void *hPrivate)
-{
-	RGXCommentLog(hPrivate, "RGX clock: use default (automatic clock gating)");
+	return eError;
 }
 
 static PVRSRV_ERROR RGXWriteMetaCoreRegThoughSP(const void *hPrivate,
@@ -143,22 +251,11 @@ static void RGXInitMetaProcWrapper(const void *hPrivate)
 {
 	IMG_UINT64 ui64GartenConfig;
 
-	/* Set Garten IDLE to META idle and Set the Garten Wrapper BIF Fence address */
-
 	/* Garten IDLE bit controlled by META */
 	ui64GartenConfig = RGX_CR_MTS_GARTEN_WRAPPER_CONFIG_IDLE_CTRL_META;
 
-	/* The fence addr is set at the fw init sequence */
-
-	if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
-	{
-		/* Set PC = 0 for fences */
-		ui64GartenConfig &= RGX_CR_MTS_GARTEN_WRAPPER_CONFIG__S7_INFRA__FENCE_PC_BASE_CLRMSK;
-		ui64GartenConfig |= (IMG_UINT64)MMU_CONTEXT_MAPPING_FWPRIV
-		                    << RGX_CR_MTS_GARTEN_WRAPPER_CONFIG__S7_INFRA__FENCE_PC_BASE_SHIFT;
-
-	}
-	else
+#if defined(RGX_CR_MTS_GARTEN_WRAPPER_CONFIG__S7_INFRA__FENCE_PC_BASE_SHIFT)
+	/* Set the Garten Wrapper BIF Fence address */
 	{
 		/* Set PC = 0 for fences */
 		ui64GartenConfig &= RGX_CR_MTS_GARTEN_WRAPPER_CONFIG_FENCE_PC_BASE_CLRMSK;
@@ -168,6 +265,7 @@ static void RGXInitMetaProcWrapper(const void *hPrivate)
 		/* Set SLC DM=META */
 		ui64GartenConfig |= ((IMG_UINT64) RGXFW_SEGMMU_META_BIFDM_ID) << RGX_CR_MTS_GARTEN_WRAPPER_CONFIG_FENCE_DM_SHIFT;
 	}
+#endif
 
 	RGXCommentLog(hPrivate, "RGXStart: Configure META wrapper");
 	RGXWriteReg64(hPrivate, RGX_CR_MTS_GARTEN_WRAPPER_CONFIG, ui64GartenConfig);
@@ -374,10 +472,6 @@ static void RGXInitMipsProcWrapper(const void *hPrivate)
 ******************************************************************************/
 static void RGXInitRiscvProcWrapper(const void *hPrivate)
 {
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	RGX_LAYER_PARAMS *psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	PVRSRV_RGXDEV_INFO *psDevInfo = psParams->psDevInfo;
-#endif
 	IMG_UINT32 ui32BootCodeRemap = RGXRISCVFW_BOOTLDR_CODE_REMAP;
 	IMG_UINT32 ui32BootDataRemap = RGXRISCVFW_BOOTLDR_DATA_REMAP;
 	IMG_DEV_VIRTADDR sTmp;
@@ -385,7 +479,7 @@ static void RGXInitRiscvProcWrapper(const void *hPrivate)
 	RGXCommentLog(hPrivate, "RGXStart: Configure RISCV wrapper");
 
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) < 4)
+	if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, HOST_SECURITY_VERSION) < 4)
 #endif
 	{
 		RGXCommentLog(hPrivate, "RGXStart: Write boot code remap");
@@ -406,7 +500,7 @@ static void RGXInitRiscvProcWrapper(const void *hPrivate)
 		              (IMG_UINT64) (RGX_FIRMWARE_RAW_HEAP_SIZE >> FWCORE_ADDR_REMAP_CONFIG0_SIZE_ALIGNSHIFT)
 		                << RGX_CR_FWCORE_ADDR_REMAP_CONFIG0_SIZE_SHIFT |
 		              (IMG_UINT64) MMU_CONTEXT_MAPPING_FWPRIV << FWCORE_ADDR_REMAP_CONFIG0_MMU_CONTEXT_SHIFT |
-#if defined(SUPPORT_TRUSTED_DEVICE)
+#if defined(SUPPORT_TRUSTED_DEVICE) && defined(RGX_CR_FWCORE_ADDR_REMAP_CONFIG0_TRUSTED_EN)
 		              RGX_CR_FWCORE_ADDR_REMAP_CONFIG0_TRUSTED_EN |
 #endif
 		              RGX_CR_FWCORE_ADDR_REMAP_CONFIG0_LOAD_STORE_EN_EN);
@@ -432,74 +526,6 @@ static void RGXInitRiscvProcWrapper(const void *hPrivate)
 ******************************************************************************/
 static void __RGXInitSLC(const void *hPrivate)
 {
-	if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_CACHE_HIERARCHY))
-	{
-		IMG_UINT32 ui32Reg;
-		IMG_UINT32 ui32RegVal;
-
-		/*
-		 * SLC control
-		 */
-		ui32Reg = RGX_CR_SLC3_CTRL_MISC;
-		ui32RegVal = RGX_CR_SLC3_CTRL_MISC_ADDR_DECODE_MODE_SCRAMBLE_PVR_HASH |
-		    RGX_CR_SLC3_CTRL_MISC_WRITE_COMBINER_EN;
-		RGXWriteReg32(hPrivate, ui32Reg, ui32RegVal);
-
-		/*
-		 * SLC scramble bits
-		 */
-		{
-		    IMG_UINT32 i;
-		    IMG_UINT32 ui32Count=0;
-		    IMG_UINT32 ui32SLCBanks = RGXGetDeviceSLCBanks(hPrivate);
-		    IMG_UINT64 aui64ScrambleValues[4];
-		    IMG_UINT32 aui32ScrambleRegs[] = {
-			RGX_CR_SLC3_SCRAMBLE,
-			RGX_CR_SLC3_SCRAMBLE2,
-			RGX_CR_SLC3_SCRAMBLE3,
-			RGX_CR_SLC3_SCRAMBLE4
-		    };
-
-		    if (2 == ui32SLCBanks)
-		    {
-			aui64ScrambleValues[0] = IMG_UINT64_C(0x6965a99a55696a6a);
-			aui64ScrambleValues[1] = IMG_UINT64_C(0x6aa9aa66959aaa9a);
-			aui64ScrambleValues[2] = IMG_UINT64_C(0x9a5665965a99a566);
-			aui64ScrambleValues[3] = IMG_UINT64_C(0x5aa69596aa66669a);
-			ui32Count = 4;
-		    }
-		    else if (4 == ui32SLCBanks)
-		    {
-			aui64ScrambleValues[0] = IMG_UINT64_C(0xc6788d722dd29ce4);
-			aui64ScrambleValues[1] = IMG_UINT64_C(0x7272e4e11b279372);
-			aui64ScrambleValues[2] = IMG_UINT64_C(0x87d872d26c6c4be1);
-			aui64ScrambleValues[3] = IMG_UINT64_C(0xe1b4878d4b36e478);
-			ui32Count = 4;
-
-		    }
-		    else if (8 == ui32SLCBanks)
-		    {
-			aui64ScrambleValues[0] = IMG_UINT64_C(0x859d6569e8fac688);
-			aui64ScrambleValues[1] = IMG_UINT64_C(0xf285e1eae4299d33);
-			aui64ScrambleValues[2] = IMG_UINT64_C(0x1e1af2be3c0aa447);
-			ui32Count = 3;
-		    }
-
-		    for (i = 0; i < ui32Count; i++)
-		    {
-			IMG_UINT32 ui32Reg = aui32ScrambleRegs[i];
-			IMG_UINT64 ui64Value = aui64ScrambleValues[i];
-			RGXWriteReg64(hPrivate, ui32Reg, ui64Value);
-		    }
-		}
-
-		{
-			/* Disable the forced SLC coherency which the hardware enables for compatibility with older pdumps */
-			RGXCommentLog(hPrivate, "Disable forced SLC coherency");
-			RGXWriteReg64(hPrivate, RGX_CR_GARTEN_SLC, 0);
-		}
-	}
-	else
 	{
 		IMG_UINT32 ui32Reg;
 		IMG_UINT32 ui32RegVal;
@@ -556,6 +582,11 @@ static void __RGXInitSLC(const void *hPrivate)
 			ui32RegVal |= RGX_CR_SLC_CTRL_MISC_BYPASS_BURST_COMBINER_EN;
 		}
 
+		if (RGX_DEVICE_HAS_BRN(hPrivate, 71242) && !RGX_DEVICE_HAS_FEATURE(hPrivate, GPU_MULTICORE_SUPPORT))
+		{
+			ui32RegVal |= RGX_CR_SLC_CTRL_MISC_LAZYWB_OVERRIDE_EN;
+		}
+
 		RGXWriteReg32(hPrivate, ui32Reg, ui32RegVal);
 	}
 }
@@ -563,45 +594,6 @@ static void __RGXInitSLC(const void *hPrivate)
 
 static void RGXWriteKernelCatBase(const void *hPrivate, IMG_DEV_PHYADDR sPCAddr)
 {
-	IMG_UINT32 uiPCAddr;
-
-#if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
-	RGX_LAYER_PARAMS *psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	PVRSRV_RGXDEV_INFO *psDevInfo = psParams->psDevInfo;
-
-	if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
-	{
-		IMG_UINT32 ui32CBaseMapCtxReg = RGX_CR_MMU_CBASE_MAPPING_CONTEXT__HOST_SECURITY_GT1_AND_MHPW_LT6_AND_MMU_VER_GEQ4;
-
-		uiPCAddr = (((sPCAddr.uiAddr >> RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_ALIGNSHIFT)
-		             << RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_SHIFT)
-		            & ~RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_CLRMSK);
-
-		/* Set the mapping context */
-		RGXWriteReg32(hPrivate, ui32CBaseMapCtxReg, MMU_CONTEXT_MAPPING_FWPRIV);
-		(void)RGXReadReg32(hPrivate, ui32CBaseMapCtxReg); /* Fence write */
-
-		/* Write the cat-base address */
-		RGXWriteKernelMMUPC32(hPrivate,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_ALIGNSHIFT,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_SHIFT,
-		                      uiPCAddr);
-
-#if (MMU_CONTEXT_MAPPING_FWIF != MMU_CONTEXT_MAPPING_FWPRIV)
-		/* Set-up different MMU ID mapping to the same PC used above */
-		RGXWriteReg32(hPrivate, ui32CBaseMapCtxReg, MMU_CONTEXT_MAPPING_FWIF);
-		(void)RGXReadReg32(hPrivate, ui32CBaseMapCtxReg); /* Fence write */
-
-		RGXWriteKernelMMUPC32(hPrivate,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_ALIGNSHIFT,
-		                      RGX_CR_MMU_CBASE_MAPPING__HOST_SECURITY_GT1__BASE_ADDR_SHIFT,
-		                      uiPCAddr);
-#endif
-	}
-#else /* defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX) */
-	if (!RGX_DEVICE_HAS_FEATURE(hPrivate, SLC_VIVT))
 	{
 		/* Write the cat-base address */
 		RGXWriteKernelMMUPC64(hPrivate,
@@ -634,36 +626,6 @@ static void RGXWriteKernelCatBase(const void *hPrivate, IMG_DEV_PHYADDR sPCAddr)
 		RGXWriteReg32(hPrivate, RGX_CR_BIF_TRUST, RGX_CR_BIF_TRUST_ENABLE_EN);
 #endif
 	}
-#endif /* defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX) */
-	else
-	{
-		uiPCAddr = (((sPCAddr.uiAddr >> RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_ALIGNSHIFT)
-		             << RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_SHIFT)
-		            & ~RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_CLRMSK);
-
-		/* Set the mapping context */
-		RGXWriteReg32(hPrivate, RGX_CR_MMU_CBASE_MAPPING_CONTEXT, MMU_CONTEXT_MAPPING_FWPRIV);
-		(void)RGXReadReg32(hPrivate, RGX_CR_MMU_CBASE_MAPPING_CONTEXT); /* Fence write */
-
-		/* Write the cat-base address */
-		RGXWriteKernelMMUPC32(hPrivate,
-		                      RGX_CR_MMU_CBASE_MAPPING,
-		                      RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_ALIGNSHIFT,
-		                      RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_SHIFT,
-		                      uiPCAddr);
-
-#if (MMU_CONTEXT_MAPPING_FWIF != MMU_CONTEXT_MAPPING_FWPRIV)
-		/* Set-up different MMU ID mapping to the same PC used above */
-		RGXWriteReg32(hPrivate, RGX_CR_MMU_CBASE_MAPPING_CONTEXT, MMU_CONTEXT_MAPPING_FWIF);
-		(void)RGXReadReg32(hPrivate, RGX_CR_MMU_CBASE_MAPPING_CONTEXT); /* Fence write */
-
-		RGXWriteKernelMMUPC32(hPrivate,
-		                      RGX_CR_MMU_CBASE_MAPPING,
-		                      RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_ALIGNSHIFT,
-		                      RGX_CR_MMU_CBASE_MAPPING_BASE_ADDR_SHIFT,
-		                      uiPCAddr);
-#endif
-	}
 }
 
 /*!
@@ -711,23 +673,46 @@ static void RGXInitBIF(const void *hPrivate)
 }
 
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+/**************************************************************************/ /*!
+@Function       RGXInitMMURangeRegisters
+@Description    Initialises MMU range registers for Non4K pages.
+@Input          hPrivate           Implementation specific data
+@Return         void
+ */ /**************************************************************************/
+static void RGXInitMMURangeRegisters(const void *hPrivate)
+{
+	RGX_LAYER_PARAMS *psParams = (RGX_LAYER_PARAMS*)hPrivate;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psParams->psDevInfo;
+	IMG_UINT32 ui32RegAddr = RGX_CR_MMU_PAGE_SIZE_RANGE_ONE;
+	IMG_UINT32 i;
+
+	for (i = 0; i < ARRAY_SIZE(psDevInfo->aui64MMUPageSizeRangeValue); ++i, ui32RegAddr += sizeof(IMG_UINT64))
+	{
+		RGXWriteReg64(hPrivate, ui32RegAddr, psDevInfo->aui64MMUPageSizeRangeValue[i]);
+	}
+}
+#endif
+
+
 /*!
 *******************************************************************************
 
- @Function      RGXAXIACELiteInit
+ @Function      RGXInitAXIACE
 
- @Description   Initialise AXI-ACE Lite interface
+ @Description    Initialise AXI-ACE interface
 
  @Input         hPrivate : Implementation specific data
 
  @Return        void
 
 ******************************************************************************/
-static void RGXAXIACELiteInit(const void *hPrivate)
+static void RGXInitAXIACE(const void *hPrivate)
 {
-	IMG_UINT32 ui32RegAddr;
 	IMG_UINT64 ui64RegVal;
+	IMG_UINT32 ui32RegAddr;
 
+#if defined(RGX_FEATURE_AXI_ACELITE_BIT_MASK)
 	ui32RegAddr = RGX_CR_AXI_ACE_LITE_CONFIGURATION;
 
 	/* Setup AXI-ACE config. Set everything to outer cache */
@@ -754,118 +739,146 @@ static void RGXAXIACELiteInit(const void *hPrivate)
 		ui64RegVal |= (IMG_UINT64)1 << RGX_CR_AXI_ACE_LITE_CONFIGURATION_ENABLE_FENCE_OUT_SHIFT;
 	}
 #endif
+#else /* defined(RGX_FEATURE_AXI_ACELITE_BIT_MASK) */
+	ui32RegAddr = RGX_CR_ACE_CTRL;
+
+	/**
+	 * The below configuration is only applicable for RGX cores supporting
+	 * ACE/ACE-lite protocol and connected to ACE coherent interconnect.
+	 */
+
+	/**
+	 * Configure AxDomain and AxCache for MMU transactions.
+	 * AxDomain set to non sharable (0x0).
+	 */
+	ui64RegVal = RGX_CR_ACE_CTRL_MMU_AWCACHE_WRITE_BACK_WRITE_ALLOCATE |
+				 RGX_CR_ACE_CTRL_MMU_ARCACHE_WRITE_BACK_READ_ALLOCATE;
+
+	/**
+	 * Configure AxCache for PM/MMU transactions.
+	 * Set to same value (i.e WBRWALLOC caching, rgxmmunit.c:RGXDerivePTEProt8)
+	 * as non-coherent PTEs
+	 */
+	ui64RegVal |= (IMG_UINT64_C(0xF)) << RGX_CR_ACE_CTRL_PM_MMU_AXCACHE_SHIFT;
+
+	/**
+	 * Configure AxDomain for non MMU transactions.
+	 */
+	ui64RegVal |= (IMG_UINT64)(RGX_CR_ACE_CTRL_COH_DOMAIN_OUTER_SHAREABLE |
+							   RGX_CR_ACE_CTRL_NON_COH_DOMAIN_NON_SHAREABLE);
+#endif /* defined(RGX_FEATURE_AXI_ACELITE_BIT_MASK) */
 
 	RGXCommentLog(hPrivate, "Init AXI-ACE interface");
 	RGXWriteReg64(hPrivate, ui32RegAddr, ui64RegVal);
 }
 
-PVRSRV_ERROR RGXStart(const void *hPrivate)
+static void RGXResetSequence(const void *hPrivate, const IMG_CHAR *pcRGXFW_PROCESSOR)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	IMG_CHAR *pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_MIPS;
-	IMG_BOOL bDoFWSlaveBoot = IMG_FALSE;
-	IMG_BOOL bMetaFW = IMG_FALSE;
+	IMG_UINT64 ui64SoftResetMask;
 
-	if (RGX_DEVICE_HAS_FEATURE(hPrivate, RISCV_FW_PROCESSOR))
+#if defined(RGX_CR_SOFT_RESET__PBE2_XE__MASKFULL)
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, PBE2_IN_XE))
 	{
-		pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_RISCV;
-	}
-	else if (RGX_DEVICE_HAS_FEATURE_VALUE(hPrivate, META))
-	{
-		pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_META;
-		bMetaFW = IMG_TRUE;
-		bDoFWSlaveBoot = RGXDoFWSlaveBoot(hPrivate);
+		ui64SoftResetMask = RGX_CR_SOFT_RESET__PBE2_XE__MASKFULL;
 	}
-
-	if (RGX_DEVICE_HAS_FEATURE(hPrivate, SYS_BUS_SECURE_RESET))
+	else
+#endif
 	{
-		/* Disable the default sys_bus_secure protection to perform minimal setup */
-		RGXCommentLog(hPrivate, "RGXStart: Disable sys_bus_secure");
-		RGXWriteReg32(hPrivate, RGX_CR_SYS_BUS_SECURE, 0);
-		(void) RGXReadReg32(hPrivate, RGX_CR_SYS_BUS_SECURE); /* Fence write */
+		ui64SoftResetMask = RGX_CR_SOFT_RESET_MASKFULL;
 	}
 
-#if defined(SUPPORT_SHARED_SLC)
-	/* When the SLC is shared, the SLC reset is performed by the System layer when calling
-	 * RGXInitSLC (before any device uses it), therefore mask out the SLC bit to avoid
-	 * soft_resetting it here.
-	 */
-#define RGX_CR_SOFT_RESET_ALL  (RGX_CR_SOFT_RESET_MASKFULL ^ RGX_CR_SOFT_RESET_SLC_EN)
-	RGXCommentLog(hPrivate, "RGXStart: Shared SLC (don't reset SLC as part of RGX reset)");
-#else
-#define RGX_CR_SOFT_RESET_ALL  (RGX_CR_SOFT_RESET_MASKFULL)
-#endif
-
 	if (RGX_DEVICE_HAS_FEATURE(hPrivate, RISCV_FW_PROCESSOR))
 	{
 		RGXCommentLog(hPrivate, "RGXStart: soft reset cpu core");
 		RGXWriteReg32(hPrivate, RGX_CR_FWCORE_BOOT, 0);
 	}
 
-#if defined(RGX_S7_SOFT_RESET_DUSTS)
-	if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
 	{
 		/* Set RGX in soft-reset */
-		RGXCommentLog(hPrivate, "RGXStart: soft reset assert step 1");
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_S7_SOFT_RESET_DUSTS);
+		RGXCommentLog(hPrivate, "RGXStart: soft reset everything");
+		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, ui64SoftResetMask);
 
 		/* Read soft-reset to fence previous write in order to clear the SOCIF pipeline */
 		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET2);
 
-		RGXCommentLog(hPrivate, "RGXStart: soft reset assert step 2");
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_S7_SOFT_RESET_JONES_ALL | RGX_S7_SOFT_RESET_DUSTS);
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET2, RGX_S7_SOFT_RESET2);
+		/* Take Rascal and Dust out of reset */
+		RGXCommentLog(hPrivate, "RGXStart: Rascal and Dust out of reset");
+		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, ui64SoftResetMask ^ RGX_CR_SOFT_RESET_RASCALDUSTS_EN);
 
 		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET2);
 
 		/* Take everything out of reset but the FW processor */
-		RGXCommentLog(hPrivate, "RGXStart: soft reset de-assert step 1 excluding %s", pcRGXFW_PROCESSOR);
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_S7_SOFT_RESET_DUSTS | RGX_CR_SOFT_RESET_GARTEN_EN);
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET2, 0x0);
-
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET2);
+		RGXCommentLog(hPrivate, "RGXStart: Take everything out of reset but %s", pcRGXFW_PROCESSOR);
 
-		RGXCommentLog(hPrivate, "RGXStart: soft reset de-assert step 2 excluding %s", pcRGXFW_PROCESSOR);
 		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_CR_SOFT_RESET_GARTEN_EN);
 
 		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
 	}
-	else
-#endif
-	{
-		/* Set RGX in soft-reset */
-		RGXCommentLog(hPrivate, "RGXStart: soft reset everything");
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_CR_SOFT_RESET_ALL);
+}
 
-		/* Read soft-reset to fence previous write in order to clear the SOCIF pipeline */
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
+static void DeassertMetaReset(const void *hPrivate)
+{
+	/* Need to wait for at least 32 cycles before taking the FW processor out of reset ... */
+	RGXWaitCycles(hPrivate, 32, 3);
 
-		/* Take Rascal and Dust out of reset */
-		RGXCommentLog(hPrivate, "RGXStart: Rascal and Dust out of reset");
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_CR_SOFT_RESET_ALL ^ RGX_CR_SOFT_RESET_RASCALDUSTS_EN);
+	RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, 0x0);
+	(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
 
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
+	/* ... and afterwards */
+	RGXWaitCycles(hPrivate, 32, 3);
+}
 
-		/* Take everything out of reset but the FW processor */
-		RGXCommentLog(hPrivate, "RGXStart: Take everything out of reset but %s", pcRGXFW_PROCESSOR);
+PVRSRV_ERROR RGXStart(const void *hPrivate)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_CHAR *pcRGXFW_PROCESSOR;
+	IMG_BOOL bDoFWSlaveBoot = IMG_FALSE;
+	IMG_BOOL bMetaFW = IMG_FALSE;
 
-		RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, RGX_CR_SOFT_RESET_GARTEN_EN);
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, RISCV_FW_PROCESSOR))
+	{
+		pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_RISCV;
+	}
+#if defined(RGX_FEATURE_MIPS_BIT_MASK)
+	else if (RGX_DEVICE_HAS_FEATURE(hPrivate, MIPS))
+	{
+		pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_MIPS;
+	}
+#endif
+	else
+	{
+		pcRGXFW_PROCESSOR = RGXFW_PROCESSOR_META;
+		bMetaFW = IMG_TRUE;
+		bDoFWSlaveBoot = RGXDoFWSlaveBoot(hPrivate);
+	}
 
-		(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, SYS_BUS_SECURE_RESET))
+	{
+		/* Disable the default sys_bus_secure protection to perform minimal setup */
+		RGXCommentLog(hPrivate, "RGXStart: Disable sys_bus_secure");
+		RGXWriteReg32(hPrivate, RGX_CR_SYS_BUS_SECURE, 0);
+		(void) RGXReadReg32(hPrivate, RGX_CR_SYS_BUS_SECURE); /* Fence write */
+	}
+
+#if defined(RGX_FEATURE_HYPERVISOR_MMU_BIT_MASK)
+	/* Only bypass HMMU if the module is present */
+	if (RGX_DEVICE_HAS_FEATURE(hPrivate, HYPERVISOR_MMU))
+	{
+		/* Always set HMMU in bypass mode */
+		RGXWriteReg32(hPrivate, RGX_CR_HMMU_BYPASS, RGX_CR_HMMU_BYPASS_MASKFULL);
+		(void) RGXReadReg32(hPrivate, RGX_CR_HMMU_BYPASS);
 	}
+#endif
 
-	/* Enable clocks */
-	RGXEnableClocks(hPrivate);
+	/*!
+	 * Start FW init sequence
+	 */
+	RGXResetSequence(hPrivate, pcRGXFW_PROCESSOR);
 
 	/*
 	 * Initialise SLC.
 	 */
-#if !defined(SUPPORT_SHARED_SLC)
 	__RGXInitSLC(hPrivate);
-#endif
 
 	if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, ECC_RAMS) > 0)
 	{
@@ -908,10 +921,20 @@ PVRSRV_ERROR RGXStart(const void *hPrivate)
 	}
 #endif
 
+#if defined(RGX_FEATURE_MMU_VERSION_MAX_VALUE_IDX)
+	if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, MMU_VERSION) >= 4)
+	{
+		/* initialise the MMU range based config registers for Non4K pages */
+		RGXInitMMURangeRegisters(hPrivate);
+	}
+#endif
+
+#if defined(RGX_FEATURE_AXI_ACELITE_BIT_MASK)
 	if (RGX_DEVICE_HAS_FEATURE(hPrivate, AXI_ACELITE))
+#endif
 	{
 		/* We must init the AXI-ACE interface before 1st BIF transaction */
-		RGXAXIACELiteInit(hPrivate);
+		RGXInitAXIACE(hPrivate);
 	}
 
 	/*
@@ -922,15 +945,7 @@ PVRSRV_ERROR RGXStart(const void *hPrivate)
 	RGXSetPoweredState(hPrivate, IMG_TRUE);
 
 	RGXCommentLog(hPrivate, "RGXStart: Take %s out of reset", pcRGXFW_PROCESSOR);
-
-	/* Need to wait for at least 32 cycles before taking the FW processor out of reset ... */
-	RGXWaitCycles(hPrivate, 32, 3);
-
-	RGXWriteReg64(hPrivate, RGX_CR_SOFT_RESET, 0x0);
-	(void) RGXReadReg64(hPrivate, RGX_CR_SOFT_RESET);
-
-	/* ... and afterwards */
-	RGXWaitCycles(hPrivate, 32, 3);
+	DeassertMetaReset(hPrivate);
 
 	if (bMetaFW && bDoFWSlaveBoot)
 	{
@@ -951,7 +966,7 @@ PVRSRV_ERROR RGXStart(const void *hPrivate)
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 			if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, HOST_SECURITY_VERSION) >= 4)
 			{
-				RGXWriteReg32(hPrivate, RGX_CR_FWCORE_DMI_DMCONTROL__RISCV_AND_HOST_SECURITY_GEQ4, RGX_CR_FWCORE_DMI_DMCONTROL__RISCV_AND_HOST_SECURITY_GEQ4__DMACTIVE_EN);
+				RGXWriteReg32(hPrivate, RGX_CR_FWCORE_DMI_DMCONTROL__HOST_SECURITY_GEQ4, RGX_CR_FWCORE_DMI_DMCONTROL__HOST_SECURITY_GEQ4__DMACTIVE_EN);
 			}
 			else
 #endif
@@ -976,31 +991,19 @@ PVRSRV_ERROR RGXStart(const void *hPrivate)
 
 PVRSRV_ERROR RGXStop(const void *hPrivate)
 {
-	IMG_BOOL bMipsFW = RGX_DEVICE_HAS_FEATURE(hPrivate, MIPS);
-	IMG_BOOL bRiscvFW = RGX_DEVICE_HAS_FEATURE(hPrivate, RISCV_FW_PROCESSOR);
-	IMG_BOOL bMetaFW = !bMipsFW && !bRiscvFW;
 	PVRSRV_ERROR eError = PVRSRV_OK;
-	RGX_LAYER_PARAMS *psParams;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	PVR_ASSERT(hPrivate != NULL);
-	psParams = (RGX_LAYER_PARAMS*)hPrivate;
-	psDevInfo = psParams->psDevInfo;
+	IMG_BOOL bMetaFW = RGX_DEVICE_HAS_FEATURE_VALUE(hPrivate, META);
 
 	RGXDeviceAckIrq(hPrivate);
 
+	/* Set FW power state OFF to disable LISR handler */
+	RGXSetPoweredState(hPrivate, IMG_FALSE);
+
 	/* Wait for Sidekick/Jones to signal IDLE except for the Garten Wrapper
 	 * For LAYOUT_MARS = 1, SIDEKICK would have been powered down by FW
 	 */
-	if (!(PVRSRV_GET_DEVICE_FEATURE_VALUE(psDevInfo->psDeviceNode, LAYOUT_MARS) > 0))
+	if (!(RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, LAYOUT_MARS) > 0))
 	{
-		if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
-		{
-			eError = RGXPollReg32(hPrivate,
-					RGX_CR_JONES_IDLE,
-					RGX_CR_JONES_IDLE_MASKFULL^(RGX_CR_JONES_IDLE_GARTEN_EN|RGX_CR_JONES_IDLE_SOCIF_EN|RGX_CR_JONES_IDLE_HOSTIF_EN),
-					RGX_CR_JONES_IDLE_MASKFULL^(RGX_CR_JONES_IDLE_GARTEN_EN|RGX_CR_JONES_IDLE_SOCIF_EN|RGX_CR_JONES_IDLE_HOSTIF_EN));
-		}
-		else
 		{
 			eError = RGXPollReg32(hPrivate,
 					RGX_CR_SIDEKICK_IDLE,
@@ -1011,28 +1014,18 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 		if (eError != PVRSRV_OK) return eError;
 	}
 
-	if (!(PVRSRV_GET_DEVICE_FEATURE_VALUE(psDevInfo->psDeviceNode, LAYOUT_MARS) > 0))
+	if (!(RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, LAYOUT_MARS) > 0))
 	{
-#if !defined(SUPPORT_SHARED_SLC)
 		/*
 		 * Wait for SLC to signal IDLE
 		 * For LAYOUT_MARS = 1, SLC would have been powered down by FW
 		 */
-		if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
-		{
-			eError = RGXPollReg32(hPrivate,
-					RGX_CR_SLC3_IDLE,
-					RGX_CR_SLC3_IDLE_MASKFULL,
-					RGX_CR_SLC3_IDLE_MASKFULL);
-		}
-		else
 		{
 			eError = RGXPollReg32(hPrivate,
 					RGX_CR_SLC_IDLE,
 					RGX_CR_SLC_IDLE_MASKFULL,
 					RGX_CR_SLC_IDLE_MASKFULL);
 		}
-#endif /* SUPPORT_SHARED_SLC */
 		if (eError != PVRSRV_OK) return eError;
 	}
 
@@ -1046,16 +1039,17 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 	              RGX_CR_MTS_BGCTX_THREAD0_DM_ASSOC_DM_ASSOC_CLRMSK
 	              & RGX_CR_MTS_BGCTX_THREAD0_DM_ASSOC_MASKFULL);
 
-#if defined(RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC)
-	RGXWriteReg32(hPrivate,
-	              RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC,
-	              RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC_DM_ASSOC_CLRMSK
-	              & RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC_MASKFULL);
-	RGXWriteReg32(hPrivate,
-	              RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC,
-	              RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC_DM_ASSOC_CLRMSK
-	              & RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC_MASKFULL);
-#endif
+	if (bMetaFW)
+	{
+		RGXWriteReg32(hPrivate,
+					  RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC,
+					  RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC_DM_ASSOC_CLRMSK
+					  & RGX_CR_MTS_INTCTX_THREAD1_DM_ASSOC_MASKFULL);
+		RGXWriteReg32(hPrivate,
+					  RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC,
+					  RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC_DM_ASSOC_CLRMSK
+					  & RGX_CR_MTS_BGCTX_THREAD1_DM_ASSOC_MASKFULL);
+	}
 
 #if defined(PDUMP)
 	if (bMetaFW)
@@ -1080,9 +1074,9 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 		 */
 #if defined(RGX_FEATURE_HOST_SECURITY_VERSION_MAX_VALUE_IDX)
 		/* Wait for the Slave Port to finish all the transactions */
-		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, META_REGISTER_UNPACKED_ACCESSES))
+		if (RGX_DEVICE_HAS_FEATURE(hPrivate, META_REGISTER_UNPACKED_ACCESSES))
 		{
-			if (RGX_GET_FEATURE_VALUE(psDevInfo, HOST_SECURITY_VERSION) > 1)
+			if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, HOST_SECURITY_VERSION) > 1)
 			{
 				RGXWriteReg32(hPrivate, RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA, 0x0);
 				(void)RGXReadReg32(hPrivate, RGX_CR_META_SP_MSLVIRQSTATUS__HOST_SECURITY_GT1_AND_MRUA); /* Fence write */
@@ -1136,8 +1130,7 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 	                      RGX_CR_BIFPM_STATUS_MMU_MASKFULL);
 	if (eError != PVRSRV_OK) return eError;
 
-	if (!RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE) &&
-	    !RGX_DEVICE_HAS_FEATURE(hPrivate, XT_TOP_INFRASTRUCTURE))
+	if (!RGX_DEVICE_HAS_FEATURE(hPrivate, XT_TOP_INFRASTRUCTURE))
 	{
 		eError = RGXPollReg32(hPrivate,
 		                      RGX_CR_BIF_READS_EXT_STATUS,
@@ -1151,14 +1144,12 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 	                      0,
 	                      RGX_CR_BIFPM_READS_EXT_STATUS_MASKFULL);
 	if (eError != PVRSRV_OK) return eError;
-	{
-		IMG_UINT64 ui64SLCMask = RGX_CR_SLC_STATUS1_MASKFULL;
-		eError = RGXPollReg64(hPrivate,
-		                      RGX_CR_SLC_STATUS1,
-		                      0,
-		                      ui64SLCMask);
-		if (eError != PVRSRV_OK) return eError;
-	}
+
+	eError = RGXPollReg64(hPrivate,
+	                      RGX_CR_SLC_STATUS1,
+	                      0,
+		                  RGX_CR_SLC_STATUS1_MASKFULL);
+	if (eError != PVRSRV_OK) return eError;
 
 	if (4 == RGXGetDeviceSLCBanks(hPrivate))
 	{
@@ -1169,47 +1160,26 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 		if (eError != PVRSRV_OK) return eError;
 	}
 
-	if (!(PVRSRV_GET_DEVICE_FEATURE_VALUE(psDevInfo->psDeviceNode, LAYOUT_MARS) > 0))
+	if (!(RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, LAYOUT_MARS) > 0))
 	{
-#if !defined(SUPPORT_SHARED_SLC)
 		/*
 		 * Wait for SLC to signal IDLE
 		 * For LAYOUT_MARS = 1, SLC would have been powered down by FW
 		 */
-		if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
-		{
-			eError = RGXPollReg32(hPrivate,
-					RGX_CR_SLC3_IDLE,
-					RGX_CR_SLC3_IDLE_MASKFULL,
-					RGX_CR_SLC3_IDLE_MASKFULL);
-		}
-		else
 		{
 			eError = RGXPollReg32(hPrivate,
 					RGX_CR_SLC_IDLE,
 					RGX_CR_SLC_IDLE_MASKFULL,
 					RGX_CR_SLC_IDLE_MASKFULL);
 		}
-#endif /* SUPPORT_SHARED_SLC */
 		if (eError != PVRSRV_OK) return eError;
 	}
 
 	/* Wait for Sidekick/Jones to signal IDLE except for the Garten Wrapper
 	 * For LAYOUT_MARS = 1, SIDEKICK would have been powered down by FW
 	 */
-	if (!(PVRSRV_GET_DEVICE_FEATURE_VALUE(psDevInfo->psDeviceNode, LAYOUT_MARS) > 0))
+	if (!(RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, LAYOUT_MARS) > 0))
 	{
-		if (RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
-		{
-			if (!RGX_DEVICE_HAS_FEATURE(hPrivate, FASTRENDER_DM))
-			{
-				eError = RGXPollReg32(hPrivate,
-						RGX_CR_JONES_IDLE,
-						RGX_CR_JONES_IDLE_MASKFULL^(RGX_CR_JONES_IDLE_GARTEN_EN|RGX_CR_JONES_IDLE_SOCIF_EN|RGX_CR_JONES_IDLE_HOSTIF_EN),
-						RGX_CR_JONES_IDLE_MASKFULL^(RGX_CR_JONES_IDLE_GARTEN_EN|RGX_CR_JONES_IDLE_SOCIF_EN|RGX_CR_JONES_IDLE_HOSTIF_EN));
-			}
-		}
-		else
 		{
 			eError = RGXPollReg32(hPrivate,
 					RGX_CR_SIDEKICK_IDLE,
@@ -1234,7 +1204,6 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 			/* Wait for Sidekick/Jones to signal IDLE including
 			 * the Garten Wrapper if there is no debugger attached
 			 * (TxVECINT_BHALT = 0x0) */
-			if (!RGX_DEVICE_HAS_FEATURE(hPrivate, S7_TOP_INFRASTRUCTURE))
 			{
 				eError = RGXPollReg32(hPrivate,
 				                      RGX_CR_SIDEKICK_IDLE,
@@ -1242,19 +1211,11 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 				                      RGX_CR_SIDEKICK_IDLE_GARTEN_EN);
 				if (eError != PVRSRV_OK) return eError;
 			}
-			else
-			{
-				eError = RGXPollReg32(hPrivate,
-				                      RGX_CR_JONES_IDLE,
-				                      RGX_CR_JONES_IDLE_GARTEN_EN,
-				                      RGX_CR_JONES_IDLE_GARTEN_EN);
-				if (eError != PVRSRV_OK) return eError;
-			}
 		}
 	}
 	else
 	{
-		if (PVRSRV_GET_DEVICE_FEATURE_VALUE(psDevInfo->psDeviceNode, LAYOUT_MARS) > 0)
+		if (RGX_DEVICE_GET_FEATURE_VALUE(hPrivate, LAYOUT_MARS) > 0)
 		{
 			/* As FW core has been moved from SIDEKICK to the new MARS domain, checking
 			 * idle bits for CPU & System Arbiter excluding SOCIF which will never be Idle
@@ -1279,36 +1240,6 @@ PVRSRV_ERROR RGXStop(const void *hPrivate)
 	return eError;
 }
 
-
-/*
- * RGXInitSLC
- */
-#if defined(SUPPORT_SHARED_SLC)
-PVRSRV_ERROR RGXInitSLC(IMG_HANDLE hDevHandle)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-	void *pvPowerParams;
-
-	if (psDeviceNode == NULL)
-	{
-		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	psDevInfo = psDeviceNode->pvDevice;
-	pvPowerParams = &psDevInfo->sLayerParams;
-
-	/* reset the SLC */
-	RGXCommentLog(pvPowerParams, "RGXInitSLC: soft reset SLC");
-	RGXWriteReg64(pvPowerParams, RGX_CR_SOFT_RESET, RGX_CR_SOFT_RESET_SLC_EN);
-
-	/* Read soft-reset to fence previous write in order to clear the SOCIF pipeline */
-	(void) RGXReadReg64(pvPowerParams, RGX_CR_SOFT_RESET);
-
-	/* Take everything out of reset */
-	RGXWriteReg64(pvPowerParams, RGX_CR_SOFT_RESET, 0x0);
-
-	__RGXInitSLC(pvPowerParams);
-
-	return PVRSRV_OK;
-}
-#endif
+/******************************************************************************
+ End of file (rgxstartstop.c)
+******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/rgxta3d.c b/drivers/gpu/drm/img-rogue/rgxta3d.c
index 9e547542dad9..595c6e6f357e 100644
--- a/drivers/gpu/drm/img-rogue/rgxta3d.c
+++ b/drivers/gpu/drm/img-rogue/rgxta3d.c
@@ -75,6 +75,10 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sync.h"
 #include "process_stats.h"
 
+#if !defined(PM_INTERACTIVE_MODE)
+#include "rgxpmdefs.h"
+#endif
+
 #include "rgxtimerquery.h"
 
 #if defined(SUPPORT_BUFFER_SYNC)
@@ -204,16 +208,10 @@ PVRSRV_ERROR _DestroyTAContext(RGX_SERVER_RC_TA_DATA *psTAData,
 											  psTAData->psServerCommonContext,
 											  RGXFWIF_DM_GEOM,
 											  PDUMP_FLAGS_CONTINUOUS);
-	if (RGXIsErrorAndDeviceRecoverable(psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 	/* ... it has so we can free its resources */
 	FWCommonContextFree(psTAData->psServerCommonContext);
@@ -234,16 +232,10 @@ PVRSRV_ERROR _Destroy3DContext(RGX_SERVER_RC_3D_DATA *ps3DData,
 											  ps3DData->psServerCommonContext,
 											  RGXFWIF_DM_3D,
 											  PDUMP_FLAGS_CONTINUOUS);
-	if (RGXIsErrorAndDeviceRecoverable(psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 	/* ... it has so we can free its resources */
 	FWCommonContextFree(ps3DData->psServerCommonContext);
@@ -558,13 +550,14 @@ PVRSRV_ERROR RGXGrowFreeList(RGX_FREELIST *psFreeList,
 	}
 
 	 /* Attach RI information */
-	eError = RIWriteMEMDESCEntryKM(psPMRNode->psPMR,
+	eError = RIWriteMEMDESCEntryKM(psFreeList->psConnection,
+	                               psFreeList->psDevInfo->psDeviceNode,
+	                               psPMRNode->psPMR,
 	                               OSStringNLength(szAllocName, DEVMEM_ANNOTATION_MAX_LEN),
 	                               szAllocName,
 	                               0,
 	                               uiSize,
-	                               IMG_FALSE,
-	                               IMG_FALSE,
+	                               0,
 	                               &psPMRNode->hRIHandle);
 	PVR_LOG_IF_ERROR(eError, "RIWriteMEMDESCEntryKM");
 
@@ -599,13 +592,12 @@ PVRSRV_ERROR RGXGrowFreeList(RGX_FREELIST *psFreeList,
 		size_t uiNumBytes;
 		PVRSRV_ERROR res;
 		IMG_HANDLE hMapHandle;
-		IMG_DEVMEM_SIZE_T uiPMRSize;
-
-		PMR_LogicalSize(psFreeList->psFreeListPMR, &uiPMRSize);
 
 		/* Check for overflow. Validate size and offset. */
-		PVR_GOTO_IF_INVALID_PARAM(psFreeList->uiFreeListPMROffset + ui32MapSize > psFreeList->uiFreeListPMROffset, eError, ErrorPopulateFreelist);
-		PVR_GOTO_IF_INVALID_PARAM(psFreeList->uiFreeListPMROffset + ui32MapSize <= uiPMRSize, eError, ErrorPopulateFreelist);
+		PVR_GOTO_IF_INVALID_PARAM(psFreeList->uiFreeListPMROffset + ui32MapSize > psFreeList->uiFreeListPMROffset,
+		                          eError, ErrorPopulateFreelist);
+		PVR_GOTO_IF_INVALID_PARAM(psFreeList->uiFreeListPMROffset + ui32MapSize <= PMR_LogicalSize(psFreeList->psFreeListPMR),
+		                          eError, ErrorPopulateFreelist);
 
 		/* Map both the FL and the shadow FL */
 		res = PMRAcquireKernelMappingData(psFreeList->psFreeListPMR, psFreeList->uiFreeListPMROffset, ui32MapSize,
@@ -914,8 +906,14 @@ void RGXProcessRequestGrow(PVRSRV_RGXDEV_INFO *psDevInfo,
 	s3DCCBCmd.uCmdData.sFreeListGSData.ui32NewPages = psFreeList->ui32CurrentFLPages + psFreeList->ui32ReadyFLPages;
 	s3DCCBCmd.uCmdData.sFreeListGSData.ui32ReadyPages = psFreeList->ui32ReadyFLPages;
 
+	PVR_DPF((PVR_DBG_MESSAGE, "Freelist [%p]: Grow pages=%u, new pages=%u, ready pages=%u, counter=%d",
+	         psFreeList,
+	         ui32GrowValue,
+	         s3DCCBCmd.uCmdData.sFreeListGSData.ui32NewPages,
+	         s3DCCBCmd.uCmdData.sFreeListGSData.ui32ReadyPages,
+	         psFreeList->ui32NumGrowReqByFW));
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 		                            RGXFWIF_DM_3D,
@@ -926,7 +924,7 @@ void RGXProcessRequestGrow(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 	/* Kernel CCB should never fill up, as the FW is processing them right away */
 
 	PVR_ASSERT(eError == PVRSRV_OK);
@@ -1027,20 +1025,70 @@ static PVRSRV_ERROR RGXReconstructFreeList(RGX_FREELIST *psFreeList)
 		return PVRSRV_ERROR_FREELIST_RECONSTRUCTION_FAILED;
 	}
 
-	/* Reset the firmware freelist structure */
+	/* Update firmware freelist structure */
 	eError = DevmemAcquireCpuVirtAddr(psFreeList->psFWFreelistMemDesc, (void **)&psFWFreeList);
 	if (eError != PVRSRV_OK)
 	{
 		return eError;
 	}
 
+	psFWFreeList->ui32MaxPages     = psFreeList->ui32MaxFLPages;
+	psFWFreeList->ui32GrowPages    = psFreeList->ui32GrowFLPages;
+	psFWFreeList->ui32CurrentPages = psFreeList->ui32CurrentFLPages;
+	psFWFreeList->ui32FreeListID   = psFreeList->ui32FreelistID;
+	psFWFreeList->bGrowPending     = IMG_FALSE;
+	psFWFreeList->ui32ReadyPages   = psFreeList->ui32ReadyFLPages;
+
+#if defined(PM_INTERACTIVE_MODE)
 	psFWFreeList->ui32CurrentStackTop       = psFWFreeList->ui32CurrentPages - 1;
 	psFWFreeList->ui32AllocatedPageCount    = 0;
 	psFWFreeList->ui32AllocatedMMUPageCount = 0;
+#else
+	psFWFreeList->bUpdatePending                   = IMG_FALSE;
+	psFWFreeList->ui32UpdateNewPages               = 0;
+	psFWFreeList->ui32UpdateNewReadyPages          = 0;
+	psFWFreeList->sFreeListLastGrowDevVAddr.uiAddr = 0;
+#endif
 	RGXFwSharedMemCacheOpPtr(psFWFreeList, FLUSH);
 
 	DevmemReleaseCpuVirtAddr(psFreeList->psFWFreelistMemDesc);
 
+#if !defined(PM_INTERACTIVE_MODE)
+	/* Reset freelist state buffer */
+	{
+		RGX_PM_FREELISTSTATE_BUFFER		sFLState;
+		size_t uiNbBytes;
+		IMG_DEV_VIRTADDR sFLBaseAddr;
+
+		eError = PMR_ReadBytes(psFreeList->psFreeListStatePMR, psFreeList->uiFreeListStatePMROffset, (IMG_UINT8*)&sFLState, sizeof(sFLState), &uiNbBytes);
+
+		if (eError != PVRSRV_OK)
+		{
+			return eError;
+		}
+
+		PVR_ASSERT(uiNbBytes == sizeof(sFLState));
+
+		sFLBaseAddr.uiAddr = (psFreeList->sFreeListBaseDevVAddr.uiAddr +
+		                      ((psFreeList->ui32MaxFLPages - psFreeList->ui32CurrentFLPages) * sizeof(IMG_UINT32))) &
+		                      ~((IMG_UINT64)RGX_BIF_PM_FREELIST_BASE_ADDR_ALIGNSIZE-1);
+		/* Note: Freelist base address is packed shifted down. */
+		RGX_PM_FREELISTSTATE_BUFFER_SET_BASE_ADDR(sFLState, sFLBaseAddr.uiAddr >> RGX_PM_FREELISTSTATE_BASE_ADDR_ALIGNSHIFT);
+		RGX_PM_FREELISTSTATE_BUFFER_SET_STACK_PTR(sFLState, psFreeList->ui32CurrentFLPages - 1);
+		RGX_PM_FREELISTSTATE_BUFFER_SET_PAGE_STATUS(sFLState, 0);
+		RGX_PM_FREELISTSTATE_BUFFER_SET_MMUPAGE_STATUS(sFLState, 0);
+
+		eError = PMR_WriteBytes(psFreeList->psFreeListStatePMR, psFreeList->uiFreeListStatePMROffset, (IMG_UINT8*)&sFLState, sizeof(sFLState), &uiNbBytes);
+
+		if (eError != PVRSRV_OK)
+		{
+			return eError;
+		}
+
+		PVR_ASSERT(uiNbBytes == sizeof(sFLState));
+	}
+#endif
+
 	/* Check the Freelist checksum if required (as the list is fully populated) */
 	if (psFreeList->bCheckFreelist)
 	{
@@ -1066,8 +1114,8 @@ void RGXProcessRequestFreelistsReconstruction(PVRSRV_RGXDEV_INFO *psDevInfo,
 	RGX_KM_HW_RT_DATASET *psKMHWRTDataSet;
 	RGXFWIF_HWRTDATA     *psHWRTData;
 #endif
-	IMG_UINT32        ui32FinalFreelistsCount = 0;
-	IMG_UINT32        aui32FinalFreelists[RGXFWIF_MAX_FREELISTS_TO_RECONSTRUCT * 2]; /* Worst-case is double what we are sent */
+	IMG_UINT32        ui32PIDCount = 0;
+	IMG_UINT32        aui32PIDList[RGXFWIF_MAX_FREELISTS_TO_RECONSTRUCT];
 
 	PVR_ASSERT(psDevInfo != NULL);
 	PVR_ASSERT(ui32FreelistsCount <= RGXFWIF_MAX_FREELISTS_TO_RECONSTRUCT);
@@ -1089,69 +1137,53 @@ void RGXProcessRequestFreelistsReconstruction(PVRSRV_RGXDEV_INFO *psDevInfo,
 	{
 		sTACCBCmd.uCmdData.sFreeListsReconstructionData.aui32FreelistIDs[ui32Loop] = paui32Freelists[ui32Loop] |
 				RGXFWIF_FREELISTS_RECONSTRUCTION_FAILED_FLAG;
-		aui32FinalFreelists[ui32Loop] = paui32Freelists[ui32Loop];
 	}
 
-	ui32FinalFreelistsCount = ui32FreelistsCount;
-
 	/*
-	 *  The list of freelists we have been given for reconstruction will
-	 *  consist of local and global freelists (maybe MMU as well). Any
-	 *  local freelists should have their global list specified as well.
-	 *  There may be cases where the global freelist is not given (in
-	 *  cases of partial setups before a poll failure for example). To
-	 *  handle that we must first ensure every local freelist has a global
-	 *  freelist specified, otherwise we add that to the 'final' list.
-	 *  This final list of freelists is created in a first pass.
-	 *
-	 *  Even with the global freelists listed, there may be other local
-	 *  freelists not listed, which are going to have their global freelist
-	 *  reconstructed. Therefore we have to find those freelists as well
-	 *  meaning we will have to iterate the entire list of freelists to
-	 *  find which must be reconstructed. This is the second pass.
+	 *  All freelists belonging to the same PID will be reconstructed.
+	 *  This simplifies tracking for AGP, since there is no longer a
+	 *  single global freelist per local freelist. The list of unique
+	 *  PIDs is calculated from the list of freelists in this first pass.
 	 */
 	OSLockAcquire(psDevInfo->hLockFreeList);
 	dllist_foreach_node(&psDevInfo->sFreeListHead, psNode, psNext)
 	{
 		RGX_FREELIST  *psFreeList   = IMG_CONTAINER_OF(psNode, RGX_FREELIST, sNode);
-		IMG_BOOL      bInList       = IMG_FALSE;
-		IMG_BOOL      bGlobalInList = IMG_FALSE;
 
-		/* Check if this local freelist is in the list and ensure its global is too. */
-		if (psFreeList->ui32FreelistGlobalID != 0)
+		for (ui32Loop = 0; ui32Loop < ui32FreelistsCount; ui32Loop++)
 		{
-			for (ui32Loop = 0; ui32Loop < ui32FinalFreelistsCount; ui32Loop++)
+			IMG_UINT32 ui32PIDLoop;
+
+			if (paui32Freelists[ui32Loop] == psFreeList->ui32FreelistID)
 			{
-				if (aui32FinalFreelists[ui32Loop] == psFreeList->ui32FreelistID)
+				for (ui32PIDLoop = 0; ui32PIDLoop < ui32PIDCount; ui32PIDLoop++)
 				{
-					bInList = IMG_TRUE;
+					if (aui32PIDList[ui32PIDLoop] == psFreeList->ownerPid)
+					{
+						break;
+					}
 				}
-				if (aui32FinalFreelists[ui32Loop] == psFreeList->ui32FreelistGlobalID)
+
+				if (ui32PIDLoop == ui32PIDCount)
 				{
-					bGlobalInList = IMG_TRUE;
+					aui32PIDList[ui32PIDCount++] = psFreeList->ownerPid;
 				}
 			}
-
-			if (bInList  &&  !bGlobalInList)
-			{
-				aui32FinalFreelists[ui32FinalFreelistsCount] = psFreeList->ui32FreelistGlobalID;
-				ui32FinalFreelistsCount++;
-			}
 		}
 	}
 	dllist_foreach_node(&psDevInfo->sFreeListHead, psNode, psNext)
 	{
 		RGX_FREELIST  *psFreeList  = IMG_CONTAINER_OF(psNode, RGX_FREELIST, sNode);
 		IMG_BOOL      bReconstruct = IMG_FALSE;
+		IMG_UINT32    ui32PIDLoop;
 
 		/*
-		 *  Check if this freelist needs to be reconstructed (was it requested
-		 *  or is its global freelist going to be reconstructed)...
+		 *  Check if this freelist needs to be reconstructed (is it in the list
+		 *  of PIDs which will have every single one of their freelists reconstructed)
 		 */
-		for (ui32Loop = 0; ui32Loop < ui32FinalFreelistsCount; ui32Loop++)
+		for (ui32PIDLoop = 0; ui32PIDLoop < ui32PIDCount; ui32PIDLoop++)
 		{
-			if (aui32FinalFreelists[ui32Loop] == psFreeList->ui32FreelistID  ||
-			    aui32FinalFreelists[ui32Loop] == psFreeList->ui32FreelistGlobalID)
+			if (aui32PIDList[ui32PIDLoop] == psFreeList->ownerPid)
 			{
 				bReconstruct = IMG_TRUE;
 				break;
@@ -1217,7 +1249,7 @@ void RGXProcessRequestFreelistsReconstruction(PVRSRV_RGXDEV_INFO *psDevInfo,
 	}
 
 	/* send feedback */
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 		                            RGXFWIF_DM_GEOM,
@@ -1228,26 +1260,25 @@ void RGXProcessRequestFreelistsReconstruction(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	/* Kernel CCB should never fill up, as the FW is processing them right away */
 	PVR_ASSERT(eError == PVRSRV_OK);
 }
 
 /* Create a single HWRTData instance */
-static PVRSRV_ERROR RGXCreateHWRTData_aux(
-		CONNECTION_DATA      *psConnection,
-		PVRSRV_DEVICE_NODE	*psDeviceNode,
-		IMG_DEV_VIRTADDR	psVHeapTableDevVAddr,
-		IMG_DEV_VIRTADDR		psPMMListDevVAddr, /* per-HWRTData */
-		RGX_FREELIST			*apsFreeLists[RGXFW_MAX_FREELISTS],
-		IMG_DEV_VIRTADDR		sTailPtrsDevVAddr,
-		IMG_DEV_VIRTADDR	sMacrotileArrayDevVAddr, /* per-HWRTData */
-		IMG_DEV_VIRTADDR	sRgnHeaderDevVAddr, /* per-HWRTData */
-		IMG_DEV_VIRTADDR	sRTCDevVAddr,
-		IMG_UINT16			ui16MaxRTs,
-		RGX_HWRTDATA_COMMON_COOKIE	*psHWRTDataCommonCookie,
-		RGX_KM_HW_RT_DATASET **ppsKMHWRTDataSet) /* per-HWRTData */
+static PVRSRV_ERROR RGXCreateHWRTData_aux(CONNECTION_DATA		*psConnection,
+                                          PVRSRV_DEVICE_NODE	*psDeviceNode,
+                                          IMG_DEV_VIRTADDR		psVHeapTableDevVAddr,
+                                          IMG_DEV_VIRTADDR		sPMDataDevVAddr, /* per-HWRTData */
+                                          RGX_FREELIST			*apsFreeLists[RGXFW_MAX_FREELISTS],
+                                          IMG_DEV_VIRTADDR		sTailPtrsDevVAddr,
+                                          IMG_DEV_VIRTADDR		sMacrotileArrayDevVAddr, /* per-HWRTData */
+                                          IMG_DEV_VIRTADDR		sRgnHeaderDevVAddr, /* per-HWRTData */
+                                          IMG_DEV_VIRTADDR		sRTCDevVAddr,
+                                          IMG_UINT16			ui16MaxRTs,
+                                          RGX_HWRTDATA_COMMON_COOKIE	*psHWRTDataCommonCookie,
+                                          RGX_KM_HW_RT_DATASET	**ppsKMHWRTDataSet) /* per-HWRTData */
 {
 	PVRSRV_ERROR eError;
 	PVRSRV_RGXDEV_INFO *psDevInfo;
@@ -1264,6 +1295,14 @@ static PVRSRV_ERROR RGXCreateHWRTData_aux(
 	/* local pointer for CPU-mapped [FW]HWRTData */
 	RGXFWIF_HWRTDATA *psHWRTData = NULL;
 
+	/*
+	 * Fill in a local copy of RGXFWIF_HWRTDATA first to reduces reads and writes to
+	 * device memory. Using a byte array buffer avoids the limitation that some OSs
+	 * cannot align local variables to 64 bytes, usually needed by RGXFWIF_HWRTDATA
+	 */
+	IMG_BYTE aui8HWRTDataLocal[sizeof(RGXFWIF_HWRTDATA)] = {0};
+	RGXFWIF_HWRTDATA *psHWRTDataLocal = (RGXFWIF_HWRTDATA *)aui8HWRTDataLocal;
+
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
 	/* Prepare the HW RT DataSet struct */
@@ -1311,35 +1350,25 @@ static PVRSRV_ERROR RGXCreateHWRTData_aux(
 									  (void **)&psHWRTData);
 	PVR_LOG_GOTO_IF_ERROR(eError, "Devmem AcquireCpuVirtAddr", FWRTDataCpuMapError);
 
-	psHWRTData->psVHeapTableDevVAddr = psVHeapTableDevVAddr;
-
-	psHWRTData->sHWRTDataCommonFwAddr = psHWRTDataCommonCookie->sHWRTDataCommonFwAddr;
-
-	psHWRTData->psPMMListDevVAddr = psPMMListDevVAddr;
+#if defined(PM_INTERACTIVE_MODE)
+	psHWRTDataLocal->psVHeapTableDevVAddr = psVHeapTableDevVAddr;
+#endif
 
-	psHWRTData->sTailPtrsDevVAddr     = sTailPtrsDevVAddr;
-	psHWRTData->sMacrotileArrayDevVAddr = sMacrotileArrayDevVAddr;
-	psHWRTData->sRgnHeaderDevVAddr		= sRgnHeaderDevVAddr;
-	psHWRTData->sRTCDevVAddr			= sRTCDevVAddr;
+	psHWRTDataLocal->sHWRTDataCommonFwAddr = psHWRTDataCommonCookie->sHWRTDataCommonFwAddr;
 
-	OSLockAcquire(psDevInfo->hLockFreeList);
-	for (ui32Loop = 0; ui32Loop < RGXFW_MAX_FREELISTS; ui32Loop++)
-	{
-		psKMHWRTDataSet->apsFreeLists[ui32Loop] = apsFreeLists[ui32Loop];
-		psKMHWRTDataSet->apsFreeLists[ui32Loop]->ui32RefCount++;
-		psHWRTData->apsFreeLists[ui32Loop].ui32Addr = psKMHWRTDataSet->apsFreeLists[ui32Loop]->sFreeListFWDevVAddr.ui32Addr;
-		/* invalid initial snapshot value, the snapshot is always taken during first kick
-		 * and hence the value get replaced during the first kick anyway. So it's safe to set it 0.
-		*/
-		psHWRTData->aui32FreeListHWRSnapshot[ui32Loop] = 0;
-	}
-#if !defined(SUPPORT_SHADOW_FREELISTS)
-	dllist_add_to_tail(&apsFreeLists[RGXFW_LOCAL_FREELIST]->sNodeHWRTDataHead, &(psKMHWRTDataSet->sNodeHWRTData));
+#if defined(PM_INTERACTIVE_MODE)
+	psHWRTDataLocal->psPMMListDevVAddr = sPMDataDevVAddr;
+#else
+	psHWRTDataLocal->sPMRenderStateDevVAddr = sPMDataDevVAddr;
 #endif
-	OSLockRelease(psDevInfo->hLockFreeList);
+
+	psHWRTDataLocal->sTailPtrsDevVAddr     = sTailPtrsDevVAddr;
+	psHWRTDataLocal->sMacrotileArrayDevVAddr = sMacrotileArrayDevVAddr;
+	psHWRTDataLocal->sRgnHeaderDevVAddr		= sRgnHeaderDevVAddr;
+	psHWRTDataLocal->sRTCDevVAddr			= sRTCDevVAddr;
 
 	{
-		RGXFWIF_RTA_CTL *psRTACtl = &psHWRTData->sRTACtl;
+		RGXFWIF_RTA_CTL *psRTACtl = &psHWRTDataLocal->sRTACtl;
 
 		psRTACtl->ui32RenderTargetIndex = 0;
 		psRTACtl->ui32ActiveRenderTargets = 0;
@@ -1409,6 +1438,24 @@ static PVRSRV_ERROR RGXCreateHWRTData_aux(
 		}
 	}
 
+	OSLockAcquire(psDevInfo->hLockFreeList);
+	for (ui32Loop = 0; ui32Loop < RGXFW_MAX_FREELISTS; ui32Loop++)
+	{
+		psKMHWRTDataSet->apsFreeLists[ui32Loop] = apsFreeLists[ui32Loop];
+		psKMHWRTDataSet->apsFreeLists[ui32Loop]->ui32RefCount++;
+		psHWRTDataLocal->apsFreeLists[ui32Loop].ui32Addr = psKMHWRTDataSet->apsFreeLists[ui32Loop]->sFreeListFWDevVAddr.ui32Addr;
+		/* Invalid initial snapshot value. The snapshot is always taken during the first
+		 * kick and hence this value gets replaced, so it's safe to set it to zero.
+		 */
+		psHWRTDataLocal->aui32FreeListHWRSnapshot[ui32Loop] = 0;
+	}
+#if !defined(SUPPORT_SHADOW_FREELISTS)
+	dllist_add_to_tail(&apsFreeLists[RGXFW_LOCAL_FREELIST]->sNodeHWRTDataHead, &(psKMHWRTDataSet->sNodeHWRTData));
+#endif
+	OSLockRelease(psDevInfo->hLockFreeList);
+
+	OSCachedMemCopy(psHWRTData, psHWRTDataLocal, sizeof(*psHWRTDataLocal));
+
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDeviceNode, "Dump HWRTData 0x%08X", psKMHWRTDataSet->sHWRTDataFwAddr.ui32Addr);
 	DevmemPDumpLoadMem(psKMHWRTDataSet->psHWRTDataFwMemDesc, 0, sizeof(*psHWRTData), PDUMP_FLAGS_CONTINUOUS);
@@ -1421,17 +1468,10 @@ static PVRSRV_ERROR RGXCreateHWRTData_aux(
 FWAllocRTAccArryFwAddrError:
 	DevmemFwUnmapAndFree(psDevInfo, psRendersAccArrayFwMemDesc);
 FWAllocateRTAccArryError:
-	RGXUnsetFirmwareAddress(psKMHWRTDataSet->psRTArrayFwMemDesc);
+	RGXUnsetFirmwareAddress(psRTArrayFwMemDesc);
 FWAllocateRTArryFwAddrError:
-	DevmemFwUnmapAndFree(psDevInfo, psKMHWRTDataSet->psRTArrayFwMemDesc);
+	DevmemFwUnmapAndFree(psDevInfo, psRTArrayFwMemDesc);
 FWAllocateRTArryError:
-	OSLockAcquire(psDevInfo->hLockFreeList);
-	for (ui32Loop = 0; ui32Loop < RGXFW_MAX_FREELISTS; ui32Loop++)
-	{
-		PVR_ASSERT(psKMHWRTDataSet->apsFreeLists[ui32Loop]->ui32RefCount > 0);
-		psKMHWRTDataSet->apsFreeLists[ui32Loop]->ui32RefCount--;
-	}
-	OSLockRelease(psDevInfo->hLockFreeList);
 	DevmemReleaseCpuVirtAddr(psKMHWRTDataSet->psHWRTDataFwMemDesc);
 FWRTDataCpuMapError:
 	RGXUnsetFirmwareAddress(psKMHWRTDataSet->psHWRTDataFwMemDesc);
@@ -1490,8 +1530,9 @@ static void RGXDestroyHWRTData_aux(RGX_KM_HW_RT_DATASET *psKMHWRTDataSet)
 }
 
 /* Create set of HWRTData(s) and bind it with a shared FW HWRTDataCommon */
-PVRSRV_ERROR RGXCreateHWRTDataSet(CONNECTION_DATA      *psConnection,
-		PVRSRV_DEVICE_NODE	*psDeviceNode,
+PVRSRV_ERROR RGXCreateHWRTDataSet(
+		CONNECTION_DATA			*psConnection,
+		PVRSRV_DEVICE_NODE		*psDeviceNode,
 		IMG_DEV_VIRTADDR	asVHeapTableDevVAddr[RGXMKIF_NUM_GEOMDATAS],
 		IMG_DEV_VIRTADDR		asPMMListDevVAddr[RGXMKIF_NUM_RTDATAS],
 		RGX_FREELIST			*apsFreeLists[RGXMKIF_NUM_RTDATA_FREELISTS],
@@ -1518,7 +1559,7 @@ PVRSRV_ERROR RGXCreateHWRTDataSet(CONNECTION_DATA      *psConnection,
 		IMG_UINT32			uiRgnHeaderSize,
 		IMG_UINT32			ui32ISPMtileSize,
 		IMG_UINT16			ui16MaxRTs,
-		RGX_KM_HW_RT_DATASET *pasKMHWRTDataSet[RGXMKIF_NUM_RTDATAS])
+		RGX_KM_HW_RT_DATASET	*pasKMHWRTDataSet[RGXMKIF_NUM_RTDATAS])
 {
 	PVRSRV_ERROR eError;
 	IMG_UINT32 ui32RTDataID;
@@ -1529,6 +1570,8 @@ PVRSRV_ERROR RGXCreateHWRTDataSet(CONNECTION_DATA      *psConnection,
 	DEVMEM_MEMDESC				*psHWRTDataCommonFwMemDesc;
 	RGXFWIF_DEV_VIRTADDR		sHWRTDataCommonFwAddr;
 
+	PVR_LOG_RETURN_IF_INVALID_PARAM(0 < ui16MaxRTs && ui16MaxRTs <= RGX_MAX_TA_RENDER_TARGETS, "Number of TA Render targets outside the range (0, RGX_MAX_TA_RENDER_TARGETS) is unsupported");
+
 	/* Prepare KM cleanup object for HWRTDataCommon FW object */
 	psHWRTDataCommonCookie = OSAllocZMem(sizeof(*psHWRTDataCommonCookie));
 	if (psHWRTDataCommonCookie == NULL)
@@ -1671,16 +1714,10 @@ PVRSRV_ERROR RGXDestroyHWRTDataSet(RGX_KM_HW_RT_DATASET *psKMHWRTDataSet)
 
 	/* Cleanup HWRTData */
 	eError = RGXFWRequestHWRTDataCleanUp(psDevNode, psHWRTData);
-	if (RGXIsErrorAndDeviceRecoverable(psDevNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestHWRTDataCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDevNode,
+						   eError,
+						   RGXFWRequestHWRTDataCleanUp);
 
 	psCommonCookie = psKMHWRTDataSet->psHWRTDataCommonCookie;
 
@@ -1720,25 +1757,68 @@ PVRSRV_ERROR RGXDestroyHWRTDataSet(RGX_KM_HW_RT_DATASET *psKMHWRTDataSet)
 	return eError;
 }
 
-PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
-                               PVRSRV_DEVICE_NODE	*psDeviceNode,
-                               IMG_HANDLE			hMemCtxPrivData,
-                               IMG_UINT32			ui32MaxFLPages,
-                               IMG_UINT32			ui32InitFLPages,
-                               IMG_UINT32			ui32GrowFLPages,
-                               IMG_UINT32           ui32GrowParamThreshold,
-                               RGX_FREELIST			*psGlobalFreeList,
-                               IMG_BOOL				bCheckFreelist,
-                               IMG_DEV_VIRTADDR		sFreeListDevVAddr,
-                               PMR					*psFreeListPMR,
-                               IMG_DEVMEM_OFFSET_T	uiFreeListPMROffset,
-                               RGX_FREELIST			**ppsFreeList)
+PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA			*psConnection,
+                               PVRSRV_DEVICE_NODE			*psDeviceNode,
+                               IMG_HANDLE				hMemCtxPrivData,
+                               IMG_UINT32				ui32MaxFLPages,
+                               IMG_UINT32				ui32InitFLPages,
+                               IMG_UINT32				ui32GrowFLPages,
+                               IMG_UINT32				ui32GrowParamThreshold,
+                               RGX_FREELIST				*psGlobalFreeList,
+                               IMG_BOOL					bCheckFreelist,
+                               DEVMEMINT_RESERVATION		*psFreeListReservation,
+                               RGX_FREELIST				**ppsFreeList)
 {
-	PVRSRV_ERROR				eError;
-	RGXFWIF_FREELIST			*psFWFreeList;
-	DEVMEM_MEMDESC				*psFWFreelistMemDesc;
-	RGX_FREELIST				*psFreeList;
-	PVRSRV_RGXDEV_INFO			*psDevInfo = psDeviceNode->pvDevice;
+	PVRSRV_ERROR       eError;
+	RGXFWIF_FREELIST   *psFWFreeList;
+	RGXFWIF_FREELIST   sFWFreeList = {{0}};
+	DEVMEM_MEMDESC     *psFWFreelistMemDesc;
+	RGX_FREELIST       *psFreeList;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	IMG_DEV_VIRTADDR   sFreeListDevVAddr;
+	PMR*               psFreeListPMR = NULL;
+
+	/* Obtain reference to reservation object */
+	if (!DevmemIntReservationAcquire(psFreeListReservation))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: Failed to acquire reservation for freelist buffer",
+		        __func__));
+		eError = PVRSRV_ERROR_REFCOUNT_OVERFLOW;
+		goto ErrorReservationAcquire;
+	}
+
+	eError = DevmemIntGetReservationData(psFreeListReservation, &psFreeListPMR, &sFreeListDevVAddr);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: Error from DevmemIntGetReservationData: %s",
+		        __func__, PVRSRVGetErrorString(eError)));
+
+		goto ErrorAllocHost;
+	}
+
+	/* Check if client properly allocated PMMETA_PROTECT */
+	if ((PMR_Flags(psFreeListPMR) & PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT)) == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: Freelist PMR must have PMMETA_PROTECT set",
+		        __func__));
+		eError = PVRSRV_ERROR_INVALID_FLAGS;
+		goto ErrorAllocHost;
+	}
+
+	if (PMR_IsSparse(psFreeListPMR))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: Free list PMR cannot be sparse!",
+		        __func__));
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		goto ErrorAllocHost;
+	}
+
+	/* Ref the PMR to prevent resource being destroyed before use */
+	PMRRefPMR(psFreeListPMR);
 
 	if (OSGetPageShift() > RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT)
 	{
@@ -1759,7 +1839,7 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 		ui32NewMaxFLPages = ui32Size >> RGX_BIF_PM_PHYSICAL_PAGE_ALIGNSHIFT;
 
 		PVR_DPF((PVR_DBG_MESSAGE, "%s: Increased number of PB pages: Init %u -> %u, Grow %u -> %u, Max %u -> %u",
-				 __func__, ui32InitFLPages, ui32NewInitFLPages, ui32GrowFLPages, ui32NewGrowFLPages, ui32MaxFLPages, ui32NewMaxFLPages));
+		        __func__, ui32InitFLPages, ui32NewInitFLPages, ui32GrowFLPages, ui32NewGrowFLPages, ui32MaxFLPages, ui32NewMaxFLPages));
 
 		ui32InitFLPages = ui32NewInitFLPages;
 		ui32GrowFLPages = ui32NewGrowFLPages;
@@ -1771,8 +1851,8 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	if (psFreeList == NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: failed to allocate host data structure",
-				__func__));
+		        "%s: failed to allocate host data structure",
+		        __func__));
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorAllocHost;
 	}
@@ -1785,25 +1865,24 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	 * suffice on the CPU side (WC buffer will be flushed at the first TA-kick)
 	 */
 	eError = DevmemFwAllocate(psDevInfo,
-							sizeof(*psFWFreeList),
-							PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) |
-							PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(FIRMWARE_CACHED) |
-							PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC |
-							PVRSRV_MEMALLOCFLAG_GPU_READABLE |
-							PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
-							PVRSRV_MEMALLOCFLAG_GPU_CACHE_INCOHERENT |
-							PVRSRV_MEMALLOCFLAG_CPU_READABLE |
-							PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE |
-							PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC |
-							PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE |
-							PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN),
-							"FwFreeList",
-							&psFWFreelistMemDesc);
+	                          sizeof(*psFWFreeList),
+	                          PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) |
+	                          PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(FIRMWARE_CACHED) |
+	                          PVRSRV_MEMALLOCFLAG_GPU_READABLE |
+	                          PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
+	                          PVRSRV_MEMALLOCFLAG_GPU_CACHE_INCOHERENT |
+	                          PVRSRV_MEMALLOCFLAG_CPU_READABLE |
+	                          PVRSRV_MEMALLOCFLAG_CPU_WRITEABLE |
+	                          PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC |
+	                          PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE |
+	                          PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(FW_MAIN),
+	                          "FwFreeList",
+	                          &psFWFreelistMemDesc);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: DevmemAllocate for RGXFWIF_FREELIST failed",
-				__func__));
+		        "%s: DevmemAllocate for RGXFWIF_FREELIST failed",
+		        __func__));
 		goto FWFreeListAlloc;
 	}
 
@@ -1812,10 +1891,10 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	psFreeList->psConnection = psConnection;
 
 	psFreeList->psFreeListPMR = psFreeListPMR;
-	/* Ref the PMR to prevent resource being destroyed before use */
-	PMRRefPMR(psFreeList->psFreeListPMR);
+	psFreeList->psFreeListReservation = psFreeListReservation;
+
+	psFreeList->uiFreeListPMROffset = 0U;
 
-	psFreeList->uiFreeListPMROffset = uiFreeListPMROffset;
 	psFreeList->psFWFreelistMemDesc = psFWFreelistMemDesc;
 	eError = RGXSetFirmwareAddress(&psFreeList->sFreeListFWDevVAddr, psFWFreelistMemDesc, 0, RFW_FWADDR_FLAG_NONE);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXSetFirmwareAddress", ErrorSetFwAddr);
@@ -1853,29 +1932,30 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	{
 		const IMG_UINT32 ui32ReadyPages = _CalculateFreelistReadyPages(psFreeList, ui32InitFLPages);
 
-		psFWFreeList->ui32MaxPages = ui32MaxFLPages;
-		psFWFreeList->ui32CurrentPages = ui32InitFLPages - ui32ReadyPages;
-		psFWFreeList->ui32GrowPages = ui32GrowFLPages;
-		psFWFreeList->ui32CurrentStackTop = psFWFreeList->ui32CurrentPages - 1;
-		psFWFreeList->psFreeListDevVAddr = sFreeListDevVAddr;
-		psFWFreeList->ui64CurrentDevVAddr = (sFreeListDevVAddr.uiAddr +
-				((ui32MaxFLPages - psFWFreeList->ui32CurrentPages) * sizeof(IMG_UINT32))) &
-						~((IMG_UINT64)RGX_BIF_PM_FREELIST_BASE_ADDR_ALIGNSIZE-1);
-		psFWFreeList->ui32FreeListID = psFreeList->ui32FreelistID;
-		psFWFreeList->bGrowPending = IMG_FALSE;
-		psFWFreeList->ui32ReadyPages = ui32ReadyPages;
-		RGXFwSharedMemCacheOpPtr(psFWFreeList, FLUSH);
+		sFWFreeList.ui32MaxPages = ui32MaxFLPages;
+		sFWFreeList.ui32CurrentPages = ui32InitFLPages - ui32ReadyPages;
+		sFWFreeList.ui32GrowPages = ui32GrowFLPages;
+		sFWFreeList.psFreeListDevVAddr = sFreeListDevVAddr;
+#if defined(PM_INTERACTIVE_MODE)
+		sFWFreeList.ui32CurrentStackTop = sFWFreeList.ui32CurrentPages - 1;
+		sFWFreeList.ui64CurrentDevVAddr = (sFreeListDevVAddr.uiAddr +
+		        ((ui32MaxFLPages - sFWFreeList.ui32CurrentPages) * sizeof(IMG_UINT32))) &
+		                ~((IMG_UINT64)RGX_BIF_PM_FREELIST_BASE_ADDR_ALIGNSIZE-1);
+#endif
+		sFWFreeList.ui32FreeListID = psFreeList->ui32FreelistID;
+		sFWFreeList.bGrowPending = IMG_FALSE;
+		sFWFreeList.ui32ReadyPages = ui32ReadyPages;
 
 #if defined(SUPPORT_SHADOW_FREELISTS)
 		/* Get the FW Memory Context address... */
-		eError = RGXSetFirmwareAddress(&psFWFreeList->psFWMemContext,
+		eError = RGXSetFirmwareAddress(&sFWFreeList.psFWMemContext,
 		                               RGXGetFWMemDescFromMemoryContextHandle(hMemCtxPrivData),
 		                               0, RFW_FWADDR_NOREF_FLAG);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
-					"%s: RGXSetFirmwareAddress for RGXFWIF_FWMEMCONTEXT failed",
-					__func__));
+			        "%s: RGXSetFirmwareAddress for RGXFWIF_FWMEMCONTEXT failed",
+			        __func__));
 			DevmemReleaseCpuVirtAddr(psFreeList->psFWFreelistMemDesc);
 			goto FWFreeListCpuMap;
 		}
@@ -1884,35 +1964,39 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 #endif
 	}
 
+	OSCachedMemCopy(psFWFreeList, &sFWFreeList, sizeof(sFWFreeList));
+	RGXFwSharedMemCacheOpPtr(psFWFreeList, FLUSH);
+
 	PVR_DPF((PVR_DBG_MESSAGE,
-			"Freelist %p created: Max pages 0x%08x, Init pages 0x%08x, "
-			"Max FL base address 0x%016" IMG_UINT64_FMTSPECx ", "
-			"Init FL base address 0x%016" IMG_UINT64_FMTSPECx,
-			psFreeList,
-			ui32MaxFLPages,
-			ui32InitFLPages,
-			sFreeListDevVAddr.uiAddr,
-			psFWFreeList->ui64CurrentDevVAddr));
+	        "Freelist %p created: Max pages 0x%08x, Init pages 0x%08x, "
+	        "Max FL base address 0x%016" IMG_UINT64_FMTSPECx ", "
+	        "Init FL base address 0x%016" IMG_UINT64_FMTSPECx,
+	        psFreeList,
+	        ui32MaxFLPages,
+	        ui32InitFLPages,
+	        sFreeListDevVAddr.uiAddr,
+	        sFWFreeList.ui64CurrentDevVAddr));
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDeviceNode, "Dump FW FreeList");
 	DevmemPDumpLoadMem(psFreeList->psFWFreelistMemDesc, 0, sizeof(*psFWFreeList), PDUMP_FLAGS_CONTINUOUS);
 
+#if defined(PM_INTERACTIVE_MODE)
 	/*
 	 * Separate dump of the Freelist's number of Pages and stack pointer.
 	 * This allows to easily modify the PB size in the out2.txt files.
 	 */
 	PDUMPCOMMENT(psDeviceNode, "FreeList TotalPages");
 	DevmemPDumpLoadMemValue32(psFreeList->psFWFreelistMemDesc,
-							offsetof(RGXFWIF_FREELIST, ui32CurrentPages),
-							psFWFreeList->ui32CurrentPages,
-							PDUMP_FLAGS_CONTINUOUS);
+	                          offsetof(RGXFWIF_FREELIST, ui32CurrentPages),
+	                          sFWFreeList.ui32CurrentPages,
+	                          PDUMP_FLAGS_CONTINUOUS);
 	PDUMPCOMMENT(psDeviceNode, "FreeList StackPointer");
 	DevmemPDumpLoadMemValue32(psFreeList->psFWFreelistMemDesc,
-							offsetof(RGXFWIF_FREELIST, ui32CurrentStackTop),
-							psFWFreeList->ui32CurrentStackTop,
-							PDUMP_FLAGS_CONTINUOUS);
+	                          offsetof(RGXFWIF_FREELIST, ui32CurrentStackTop),
+	                          sFWFreeList.ui32CurrentStackTop,
+	                          PDUMP_FLAGS_CONTINUOUS);
+#endif
 #endif
-
 	DevmemReleaseCpuVirtAddr(psFreeList->psFWFreelistMemDesc);
 
 	/* Add initial PB block */
@@ -1923,10 +2007,10 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: failed to allocate initial memory block for free list 0x%016" IMG_UINT64_FMTSPECx " (%s)",
-				__func__,
-				sFreeListDevVAddr.uiAddr,
-				PVRSRVGetErrorString(eError)));
+		         "%s: failed to allocate initial memory block for free list 0x%016" IMG_UINT64_FMTSPECx " (%s)",
+		         __func__,
+		         sFreeListDevVAddr.uiAddr,
+		         PVRSRVGetErrorString(eError)));
 		goto FWFreeListCpuMap;
 	}
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
@@ -1962,6 +2046,9 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
 	OSFreeMem(psFreeList);
 
 ErrorAllocHost:
+	DevmemIntReservationRelease(psFreeListReservation);
+
+ErrorReservationAcquire:
 	PVR_ASSERT(eError != PVRSRV_OK);
 	return eError;
 }
@@ -1990,18 +2077,14 @@ PVRSRV_ERROR RGXDestroyFreeList(RGX_FREELIST *psFreeList)
 	/* Freelist is not in use => start firmware cleanup */
 	eError = RGXFWRequestFreeListCleanUp(psFreeList->psDevInfo,
 										 psFreeList->sFreeListFWDevVAddr);
-	if (RGXIsErrorAndDeviceRecoverable(psFreeList->psDevInfo->psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		/* Can happen if the firmware took too long to handle the cleanup request,
-		 * or if SLC-flushes didn't went through (due to some GPU lockup) */
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestFreeListCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psFreeList->psDevInfo->psDeviceNode,
+						   eError,
+						   RGXFWRequestFreeListCleanUp);
+
+	/* Device becomes unrecoverable if the firmware took too long to
+	 * handle the cleanup request, or if SLC-flushes didn't go through
+	 * (due to some GPU lockup) */
 
 	/* Remove FreeList from linked list before we destroy it... */
 	OSLockAcquire(psFreeList->psDevInfo->hLockFreeList);
@@ -2012,6 +2095,7 @@ PVRSRV_ERROR RGXDestroyFreeList(RGX_FREELIST *psFreeList)
 #endif
 	OSLockRelease(psFreeList->psDevInfo->hLockFreeList);
 
+#if defined(PM_INTERACTIVE_MODE)
 	if (psFreeList->bCheckFreelist)
 	{
 		RGXFWIF_FREELIST  *psFWFreeList;
@@ -2041,6 +2125,7 @@ PVRSRV_ERROR RGXDestroyFreeList(RGX_FREELIST *psFreeList)
 			_CheckFreelist(psFreeList, ui32CurrentStackTop+1, 0, &ui64CheckSum);
 		}
 	}
+#endif
 
 	/* Destroy FW structures */
 	RGXUnsetFirmwareAddress(psFreeList->psFWFreelistMemDesc);
@@ -2061,8 +2146,9 @@ PVRSRV_ERROR RGXDestroyFreeList(RGX_FREELIST *psFreeList)
 	PVR_ASSERT(dllist_is_empty(&psFreeList->sMemoryBlockInitHead));
 	PVR_ASSERT(psFreeList->ui32CurrentFLPages == 0);
 
-	/* Remove reference from the PMR resource */
+	/* Remove reference from the PMR and reservation resources */
 	PMRUnrefPMR(psFreeList->psFreeListPMR);
+	DevmemIntReservationRelease(psFreeList->psFreeListReservation);
 
 	/* free Freelist */
 	OSFreeMem(psFreeList);
@@ -2084,6 +2170,7 @@ PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA * psConnection,
 	PVRSRV_ERROR				eError;
 	PVRSRV_RGXDEV_INFO			*psDevInfo = psDeviceNode->pvDevice;
 	RGXFWIF_PRBUFFER			*psFWZSBuffer;
+	RGXFWIF_PRBUFFER			sFWZSBuffer = {0};
 	RGX_ZSBUFFER_DATA			*psZSBuffer;
 	DEVMEM_MEMDESC				*psFWZSBufferMemDesc;
 	IMG_BOOL					bOnDemand = PVRSRV_CHECK_ON_DEMAND(uiMapFlags) ? IMG_TRUE : IMG_FALSE;
@@ -2117,19 +2204,9 @@ PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA * psConnection,
 	/* Obtain reference to PMR */
 	PMRRefPMR(psZSBuffer->psPMR);
 
-	psZSBuffer->uiMapFlags = uiMapFlags;
 	psZSBuffer->ui32RefCount = 0;
+	psZSBuffer->bIsBacked = IMG_FALSE;
 	psZSBuffer->bOnDemand = bOnDemand;
-	if (bOnDemand)
-	{
-		/* psZSBuffer->ui32ZSBufferID set below with lock... */
-		psZSBuffer->psMapping = NULL;
-
-		OSLockAcquire(psDevInfo->hLockZSBuffer);
-		psZSBuffer->ui32ZSBufferID = psDevInfo->ui32ZSBufferCurrID++;
-		dllist_add_to_tail(&psDevInfo->sZSBufferHead, &psZSBuffer->sNode);
-		OSLockRelease(psDevInfo->hLockZSBuffer);
-	}
 
 	/* Allocate firmware memory for ZS-Buffer. */
 	PDUMPCOMMENT(psDeviceNode, "Allocate firmware ZS-Buffer data structure");
@@ -2137,7 +2214,6 @@ PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA * psConnection,
 							sizeof(*psFWZSBuffer),
 							PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(PMMETA_PROTECT) |
 							PVRSRV_MEMALLOCFLAG_DEVICE_FLAG(FIRMWARE_CACHED) |
-							PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC |
 							PVRSRV_MEMALLOCFLAG_GPU_READABLE |
 							PVRSRV_MEMALLOCFLAG_GPU_WRITEABLE |
 							PVRSRV_MEMALLOCFLAG_GPU_CACHE_INCOHERENT |
@@ -2170,15 +2246,25 @@ PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA * psConnection,
 		goto ErrorAcquireFWZSBuffer;
 	}
 
-	/* Populate FW ZS-Buffer data structure */
-	psFWZSBuffer->bOnDemand = bOnDemand;
-	psFWZSBuffer->eState = (bOnDemand) ? RGXFWIF_PRBUFFER_UNBACKED : RGXFWIF_PRBUFFER_BACKED;
-	psFWZSBuffer->ui32BufferID = psZSBuffer->ui32ZSBufferID;
-
 	/* Get firmware address of ZS-Buffer. */
 	eError = RGXSetFirmwareAddress(&psZSBuffer->sZSBufferFWDevVAddr, psFWZSBufferMemDesc, 0, RFW_FWADDR_FLAG_NONE);
 	PVR_LOG_GOTO_IF_ERROR(eError, "RGXSetFirmwareAddress", ErrorSetFwAddr);
 
+	if (bOnDemand)
+	{
+		/* psZSBuffer->ui32ZSBufferID set below with lock... */
+		OSLockAcquire(psDevInfo->hLockZSBuffer);
+		psZSBuffer->ui32ZSBufferID = psDevInfo->ui32ZSBufferCurrID++;
+		dllist_add_to_tail(&psDevInfo->sZSBufferHead, &psZSBuffer->sNode);
+		OSLockRelease(psDevInfo->hLockZSBuffer);
+	}
+
+	/* Populate FW ZS-Buffer data structure */
+	sFWZSBuffer.bOnDemand = bOnDemand;
+	sFWZSBuffer.eState = (bOnDemand) ? RGXFWIF_PRBUFFER_UNBACKED : RGXFWIF_PRBUFFER_BACKED;
+	sFWZSBuffer.ui32BufferID = psZSBuffer->ui32ZSBufferID;
+
+	OSCachedMemCopy(psFWZSBuffer, &sFWZSBuffer, sizeof(sFWZSBuffer));
 	/* Dump the ZS-Buffer and the memory content */
 #if defined(PDUMP)
 	PDUMPCOMMENT(psDeviceNode, "Dump firmware ZS-Buffer");
@@ -2231,25 +2317,22 @@ PVRSRV_ERROR RGXDestroyZSBufferKM(RGX_ZSBUFFER_DATA *psZSBuffer)
 	PVR_ASSERT(psZSBuffer);
 	hLockZSBuffer = psZSBuffer->psDevInfo->hLockZSBuffer;
 
-	if (psZSBuffer->ui32RefCount != 0)
-	{
-		PVR_ASSERT(IMG_FALSE);
-		/* ZS-Buffer is still referenced (by population object) */
-		return PVRSRV_ERROR_RETRY;
-	}
-
 	/* Request ZS Buffer cleanup */
 	eError = RGXFWRequestZSBufferCleanUp(psZSBuffer->psDevInfo,
 										psZSBuffer->sZSBufferFWDevVAddr);
-	if (RGXIsErrorAndDeviceRecoverable(psZSBuffer->psDevInfo->psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psZSBuffer->psDevInfo->psDeviceNode,
+						   eError,
+						   RGXFWRequestZSBufferCleanUp);
+
+	OSLockAcquire(hLockZSBuffer);
+
+	if (psZSBuffer->ui32RefCount != 0)
 	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestZSBufferCleanUp (%s)",
-				__func__,
-				PVRSRVGetErrorString(eError)));
+		/* ZS-Buffer is still referenced */
+		OSLockRelease(hLockZSBuffer);
+		PVR_DPF((PVR_DBG_WARNING, "Trying to destroy a ZS-Buffer [%p] that's still in use.", psZSBuffer));
+		return PVRSRV_ERROR_RETRY;
 	}
 
 	/* Free the firmware render context. */
@@ -2259,10 +2342,8 @@ PVRSRV_ERROR RGXDestroyZSBufferKM(RGX_ZSBUFFER_DATA *psZSBuffer)
 	/* Remove Deferred Allocation from list */
 	if (psZSBuffer->bOnDemand)
 	{
-		OSLockAcquire(hLockZSBuffer);
 		PVR_ASSERT(dllist_node_is_in_list(&psZSBuffer->sNode));
 		dllist_remove_node(&psZSBuffer->sNode);
-		OSLockRelease(hLockZSBuffer);
 	}
 
 	PVR_DPF((PVR_DBG_MESSAGE, "ZS-Buffer [%p] destroyed", psZSBuffer));
@@ -2274,6 +2355,8 @@ PVRSRV_ERROR RGXDestroyZSBufferKM(RGX_ZSBUFFER_DATA *psZSBuffer)
 	/* Free ZS-Buffer host data structure */
 	OSFreeMem(psZSBuffer);
 
+	OSLockRelease(hLockZSBuffer);
+
 	return eError;
 }
 
@@ -2302,26 +2385,19 @@ RGXBackingZSBuffer(RGX_ZSBUFFER_DATA *psZSBuffer)
 
 	OSLockAcquire(hLockZSBuffer);
 
-	if (psZSBuffer->ui32RefCount == 0)
+	if (psZSBuffer->bIsBacked == IMG_FALSE)
 	{
 		IMG_HANDLE hDevmemHeap;
 
-		PVR_ASSERT(psZSBuffer->psMapping == NULL);
-
 		/* Get Heap */
 		eError = DevmemServerGetHeapHandle(psZSBuffer->psReservation, &hDevmemHeap);
-		PVR_ASSERT(psZSBuffer->psMapping == NULL);
 		if (unlikely(hDevmemHeap == (IMG_HANDLE)NULL))
 		{
 			OSLockRelease(hLockZSBuffer);
 			return PVRSRV_ERROR_INVALID_HEAP;
 		}
 
-		eError = DevmemIntMapPMR(hDevmemHeap,
-				psZSBuffer->psReservation,
-				psZSBuffer->psPMR,
-				psZSBuffer->uiMapFlags,
-				&psZSBuffer->psMapping);
+		eError = DevmemIntMapPMR(psZSBuffer->psReservation, psZSBuffer->psPMR);
 		if (eError != PVRSRV_OK)
 		{
 			PVR_DPF((PVR_DBG_ERROR,
@@ -2334,12 +2410,11 @@ RGXBackingZSBuffer(RGX_ZSBUFFER_DATA *psZSBuffer)
 
 		}
 		PVR_DPF((PVR_DBG_MESSAGE, "ZS Buffer [%p, ID=0x%08x]: Physical backing acquired",
-				psZSBuffer,
-				psZSBuffer->ui32ZSBufferID));
-	}
+		                          psZSBuffer,
+		                          psZSBuffer->ui32ZSBufferID));
 
-	/* Increase refcount*/
-	psZSBuffer->ui32RefCount++;
+		psZSBuffer->bIsBacked = IMG_TRUE;
+	}
 
 	OSLockRelease(hLockZSBuffer);
 
@@ -2354,6 +2429,10 @@ RGXPopulateZSBufferKM(RGX_ZSBUFFER_DATA *psZSBuffer,
 	RGX_POPULATION *psPopulation;
 	PVRSRV_ERROR eError;
 
+	OSLockAcquire(psZSBuffer->psDevInfo->hLockZSBuffer);
+	psZSBuffer->ui32RefCount++;
+	OSLockRelease(psZSBuffer->psDevInfo->hLockZSBuffer);
+
 	psZSBuffer->ui32NumReqByApp++;
 
 #if defined(PVRSRV_ENABLE_PROCESS_STATS)
@@ -2388,6 +2467,11 @@ RGXPopulateZSBufferKM(RGX_ZSBUFFER_DATA *psZSBuffer,
 
 OnErrorBacking:
 	PVR_ASSERT(eError != PVRSRV_OK);
+
+	OSLockAcquire(psZSBuffer->psDevInfo->hLockZSBuffer);
+	psZSBuffer->ui32RefCount--;
+	OSLockRelease(psZSBuffer->psDevInfo->hLockZSBuffer);
+
 	return eError;
 }
 
@@ -2413,33 +2497,27 @@ RGXUnbackingZSBuffer(RGX_ZSBUFFER_DATA *psZSBuffer)
 
 	OSLockAcquire(hLockZSBuffer);
 
-	if (psZSBuffer->bOnDemand)
+	if (psZSBuffer->bOnDemand && psZSBuffer->bIsBacked == IMG_TRUE)
 	{
-		if (psZSBuffer->ui32RefCount == 1)
+		eError = DevmemIntUnmapPMR(psZSBuffer->psReservation);
+		if (eError != PVRSRV_OK)
 		{
-			PVR_ASSERT(psZSBuffer->psMapping);
+			PVR_DPF((PVR_DBG_ERROR,
+					"Unable to unpopulate ZS Buffer [%p, ID=0x%08x] (%s)",
+					psZSBuffer,
+					psZSBuffer->ui32ZSBufferID,
+					PVRSRVGetErrorString(eError)));
+			OSLockRelease(hLockZSBuffer);
+			return eError;
+		}
 
-			eError = DevmemIntUnmapPMR(psZSBuffer->psMapping);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-						"Unable to unpopulate ZS Buffer [%p, ID=0x%08x] (%s)",
-						psZSBuffer,
-						psZSBuffer->ui32ZSBufferID,
-						PVRSRVGetErrorString(eError)));
-				OSLockRelease(hLockZSBuffer);
-				return eError;
-			}
+		PVR_DPF((PVR_DBG_MESSAGE, "ZS Buffer [%p, ID=0x%08x]: Physical backing removed",
+									psZSBuffer,
+									psZSBuffer->ui32ZSBufferID));
 
-			PVR_DPF((PVR_DBG_MESSAGE, "ZS Buffer [%p, ID=0x%08x]: Physical backing removed",
-										psZSBuffer,
-										psZSBuffer->ui32ZSBufferID));
-		}
+		psZSBuffer->bIsBacked = IMG_FALSE;
 	}
 
-	/* Decrease refcount*/
-	psZSBuffer->ui32RefCount--;
-
 	OSLockRelease(hLockZSBuffer);
 
 	return PVRSRV_OK;
@@ -2449,24 +2527,30 @@ PVRSRV_ERROR
 RGXUnpopulateZSBufferKM(RGX_POPULATION *psPopulation)
 {
 	PVRSRV_ERROR eError;
-
+	POS_LOCK hLockZSBuffer;
 	if (!psPopulation)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
+	hLockZSBuffer = psPopulation->psZSBuffer->psDevInfo->hLockZSBuffer;
+
 	eError = RGXUnbackingZSBuffer(psPopulation->psZSBuffer);
 	if (eError != PVRSRV_OK)
 	{
 		return eError;
 	}
 
+	OSLockAcquire(hLockZSBuffer);
+	psPopulation->psZSBuffer->ui32RefCount--;
+	OSLockRelease(hLockZSBuffer);
+
 	OSFreeMem(psPopulation);
 
 	return PVRSRV_OK;
 }
 
-static RGX_ZSBUFFER_DATA *FindZSBuffer(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32ZSBufferID)
+static RGX_ZSBUFFER_DATA *FindAndRefZSBuffer(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32 ui32ZSBufferID)
 {
 	DLLIST_NODE *psNode, *psNext;
 	RGX_ZSBUFFER_DATA *psZSBuffer = NULL;
@@ -2480,10 +2564,13 @@ static RGX_ZSBUFFER_DATA *FindZSBuffer(PVRSRV_RGXDEV_INFO *psDevInfo, IMG_UINT32
 		if (psThisZSBuffer->ui32ZSBufferID == ui32ZSBufferID)
 		{
 			psZSBuffer = psThisZSBuffer;
+
+			psZSBuffer->ui32RefCount++;
 			break;
 		}
 	}
 
+
 	OSLockRelease(psDevInfo->hLockZSBuffer);
 	return psZSBuffer;
 }
@@ -2499,7 +2586,7 @@ void RGXProcessRequestZSBufferBacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PVR_ASSERT(psDevInfo);
 
 	/* scan all deferred allocations */
-	psZSBuffer = FindZSBuffer(psDevInfo, ui32ZSBufferID);
+	psZSBuffer = FindAndRefZSBuffer(psDevInfo, ui32ZSBufferID);
 
 	if (psZSBuffer == NULL)
 	{
@@ -2526,7 +2613,7 @@ void RGXProcessRequestZSBufferBacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 	sTACCBCmd.uCmdData.sZSBufferBackingData.sZSBufferFWDevVAddr.ui32Addr = psZSBuffer->sZSBufferFWDevVAddr.ui32Addr;
 	sTACCBCmd.uCmdData.sZSBufferBackingData.bDone = bBackingDone;
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 		                            RGXFWIF_DM_GEOM,
@@ -2537,7 +2624,7 @@ void RGXProcessRequestZSBufferBacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	/* Kernel CCB should never fill up, as the FW is processing them right away */
 	PVR_ASSERT(eError == PVRSRV_OK);
@@ -2548,6 +2635,11 @@ void RGXProcessRequestZSBufferBacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PVRSRVStatsUpdateZSBufferStats(psDevInfo->psDeviceNode,
 	                               0, 1, psZSBuffer->owner);
 #endif
+
+	OSLockAcquire(psDevInfo->hLockZSBuffer);
+	psZSBuffer->ui32RefCount--;
+	OSLockRelease(psDevInfo->hLockZSBuffer);
+
 }
 
 void RGXProcessRequestZSBufferUnbacking(PVRSRV_RGXDEV_INFO *psDevInfo,
@@ -2560,7 +2652,7 @@ void RGXProcessRequestZSBufferUnbacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 	PVR_ASSERT(psDevInfo);
 
 	/* scan all deferred allocations */
-	psZSBuffer = FindZSBuffer(psDevInfo, ui32ZSBufferID);
+	psZSBuffer = FindAndRefZSBuffer(psDevInfo, ui32ZSBufferID);
 
 	if (psZSBuffer == NULL)
 	{
@@ -2587,7 +2679,7 @@ void RGXProcessRequestZSBufferUnbacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 	sTACCBCmd.uCmdData.sZSBufferBackingData.sZSBufferFWDevVAddr.ui32Addr = psZSBuffer->sZSBufferFWDevVAddr.ui32Addr;
 	sTACCBCmd.uCmdData.sZSBufferBackingData.bDone = IMG_TRUE;
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psDevInfo,
 		                            RGXFWIF_DM_GEOM,
@@ -2598,10 +2690,14 @@ void RGXProcessRequestZSBufferUnbacking(PVRSRV_RGXDEV_INFO *psDevInfo,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	/* Kernel CCB should never fill up, as the FW is processing them right away */
 	PVR_ASSERT(eError == PVRSRV_OK);
+
+	OSLockAcquire(psDevInfo->hLockZSBuffer);
+	psZSBuffer->ui32RefCount--;
+	OSLockRelease(psDevInfo->hLockZSBuffer);
 }
 
 static
@@ -2741,6 +2837,19 @@ PVRSRV_ERROR _Create3DContext(CONNECTION_DATA *psConnection,
 	*/
 	PDUMPCOMMENT(psDeviceNode, "Allocate RGX firmware 3D context suspend state");
 
+#if defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX)
+	uiNumISPStoreRegs = RGXFWIF_IPP_RESUME_REG_COUNT; /* default 1 register for IPP_resume */
+
+	uiNumISPStoreRegs += (RGX_GET_FEATURE_VALUE(psDevInfo, NUM_SPU) *
+								RGX_GET_FEATURE_VALUE(psDevInfo, NUM_ISP_PER_SPU) *
+								RGXFWIF_PIPE_COUNT_PER_ISP);
+
+
+	if (uiNumISPStoreRegs > (RGXFWIF_ISP_PIPE_COUNT_MAX + RGXFWIF_IPP_RESUME_REG_COUNT))
+	{
+		return PVRSRV_ERROR_NOT_SUPPORTED;
+	}
+#else /* defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX) */
 	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, XE_MEMORY_HIERARCHY))
 	{
 		uiNumISPStoreRegs = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode,
@@ -2756,6 +2865,7 @@ PVRSRV_ERROR _Create3DContext(CONNECTION_DATA *psConnection,
 		uiNumISPStoreRegs = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode,
 				RGX_FEATURE_NUM_ISP_IPP_PIPES_IDX);
 	}
+#endif /* defined(RGX_FEATURE_NUM_SPU_MAX_VALUE_IDX) */
 
 	/* Size of the CS buffer */
 	/* Calculate the size of the 3DCTX ISP state */
@@ -2887,7 +2997,7 @@ PVRSRV_ERROR PVRSRVRGXCreateRenderContextKM(CONNECTION_DATA				*psConnection,
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		WorkEstInitTA3D(psDevInfo, &psRenderContext->sWorkEstData);
 	}
@@ -3015,7 +3125,7 @@ PVRSRV_ERROR PVRSRVRGXCreateRenderContextKM(CONNECTION_DATA				*psConnection,
 fail_buffer_sync_context_create:
 #endif
 fail_acquire_cpu_mapping:
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		PVRSRV_ERROR eError2 = _DestroyTAContext(&psRenderContext->sTAData,
 		                                         psDeviceNode);
@@ -3025,9 +3135,9 @@ PVRSRV_ERROR PVRSRVRGXCreateRenderContextKM(CONNECTION_DATA				*psConnection,
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	}
-	END_LOOP_UNTIL_TIMEOUT();
+	END_LOOP_UNTIL_TIMEOUT_US();
 fail_tacontext:
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		PVRSRV_ERROR eError2 = _Destroy3DContext(&psRenderContext->s3DData,
 		                                         psRenderContext->psDeviceNode);
@@ -3037,7 +3147,7 @@ PVRSRV_ERROR PVRSRVRGXCreateRenderContextKM(CONNECTION_DATA				*psConnection,
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
 	}
-	END_LOOP_UNTIL_TIMEOUT();
+	END_LOOP_UNTIL_TIMEOUT_US();
 fail_3dcontext:
 fail_frameworkcopy:
 	if (psRenderContext->psFWFrameworkMemDesc)
@@ -3113,7 +3223,7 @@ PVRSRV_ERROR PVRSRVRGXDestroyRenderContextKM(RGX_SERVER_RENDER_CONTEXT *psRender
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 	{
 		RGXFWIF_FWRENDERCONTEXT	*psFWRenderContext;
 		IMG_UINT32 ui32WorkEstCCBSubmitted;
@@ -3170,7 +3280,7 @@ PVRSRV_ERROR PVRSRVRGXDestroyRenderContextKM(RGX_SERVER_RENDER_CONTEXT *psRender
 		SyncAddrListDeinit(&psRenderContext->sSyncAddrList3DUpdate);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 		{
 			WorkEstDeInitTA3D(psDevInfo, &psRenderContext->sWorkEstData);
 		}
@@ -3376,50 +3486,51 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 	RGX_CCB_CMD_HELPER_DATA *pasTACmdHelperData = psRenderContext->asTACmdHelperData;
 	RGX_CCB_CMD_HELPER_DATA *pas3DCmdHelperData = psRenderContext->as3DCmdHelperData;
 
-	IMG_UINT32				ui32TACmdCount=0;
-	IMG_UINT32				ui323DCmdCount=0;
-	IMG_UINT32				ui32TACmdOffset=0;
-	IMG_UINT32				ui323DCmdOffset=0;
-	RGXFWIF_UFO				sPRUFO;
-	IMG_UINT32				i;
-	PVRSRV_ERROR			eError = PVRSRV_OK;
-	PVRSRV_ERROR			eError2 = PVRSRV_OK;
+	IMG_UINT32                ui32TACmdCount=0;
+	IMG_UINT32                ui323DCmdCount=0;
+	__maybe_unused IMG_UINT32 ui32TACmdOffset=0;
+	__maybe_unused IMG_UINT32 ui323DCmdOffset=0;
+
+	RGXFWIF_UFO        sPRUFO;
+	IMG_UINT32         i;
+	PVRSRV_ERROR       eError = PVRSRV_OK;
+	PVRSRV_ERROR       eError2 = PVRSRV_OK;
 
-	PVRSRV_RGXDEV_INFO      *psDevInfo = FWCommonContextGetRGXDevInfo(psRenderContext->s3DData.psServerCommonContext);
-	IMG_UINT32              ui32IntJobRef = OSAtomicIncrement(&psDevInfo->iCCBSubmissionOrdinal);
-	IMG_BOOL                bCCBStateOpen = IMG_FALSE;
+	PVRSRV_RGXDEV_INFO *psDevInfo = FWCommonContextGetRGXDevInfo(psRenderContext->s3DData.psServerCommonContext);
+	IMG_UINT32         ui32IntJobRef = OSAtomicIncrement(&psDevInfo->iCCBSubmissionOrdinal);
+	IMG_BOOL           bCCBStateOpen = IMG_FALSE;
 
-	IMG_UINT32				ui32ClientPRUpdateCount = 0;
-	PRGXFWIF_UFO_ADDR		*pauiClientPRUpdateUFOAddress = NULL;
-	IMG_UINT32				*paui32ClientPRUpdateValue = NULL;
+	IMG_UINT32         ui32ClientPRUpdateCount = 0;
+	PRGXFWIF_UFO_ADDR  *pauiClientPRUpdateUFOAddress = NULL;
+	IMG_UINT32         *paui32ClientPRUpdateValue = NULL;
 
 	PRGXFWIF_TIMESTAMP_ADDR pPreAddr;
 	PRGXFWIF_TIMESTAMP_ADDR pPostAddr;
 	PRGXFWIF_UFO_ADDR       pRMWUFOAddr;
 
-	PRGXFWIF_UFO_ADDR		*pauiClientTAFenceUFOAddress = NULL;
-	PRGXFWIF_UFO_ADDR		*pauiClientTAUpdateUFOAddress = NULL;
-	PRGXFWIF_UFO_ADDR		*pauiClient3DFenceUFOAddress = NULL;
-	PRGXFWIF_UFO_ADDR		*pauiClient3DUpdateUFOAddress = NULL;
-	PRGXFWIF_UFO_ADDR		uiPRFenceUFOAddress;
+	PRGXFWIF_UFO_ADDR  *pauiClientTAFenceUFOAddress = NULL;
+	PRGXFWIF_UFO_ADDR  *pauiClientTAUpdateUFOAddress = NULL;
+	PRGXFWIF_UFO_ADDR  *pauiClient3DFenceUFOAddress = NULL;
+	PRGXFWIF_UFO_ADDR  *pauiClient3DUpdateUFOAddress = NULL;
+	PRGXFWIF_UFO_ADDR  uiPRFenceUFOAddress;
 
-	IMG_UINT64               uiCheckTAFenceUID = 0;
-	IMG_UINT64               uiCheck3DFenceUID = 0;
-	IMG_UINT64               uiUpdateTAFenceUID = 0;
-	IMG_UINT64               uiUpdate3DFenceUID = 0;
+	IMG_UINT64         uiCheckTAFenceUID = 0;
+	IMG_UINT64         uiCheck3DFenceUID = 0;
+	IMG_UINT64         uiUpdateTAFenceUID = 0;
+	IMG_UINT64         uiUpdate3DFenceUID = 0;
 
 	IMG_BOOL bUseCombined3DAnd3DPR = bKickPR && bKick3D && !pui83DPRDMCmd;
 
-	RGXFWIF_KCCB_CMD_KICK_DATA	sTACmdKickData;
-	RGXFWIF_KCCB_CMD_KICK_DATA	s3DCmdKickData;
+	RGXFWIF_KCCB_CMD_KICK_DATA sTACmdKickData;
+	RGXFWIF_KCCB_CMD_KICK_DATA s3DCmdKickData;
 	IMG_BOOL bUseSingleFWCommand = bKickTA && (bKickPR || bKick3D);
 
 	IMG_UINT32 ui32TACmdSizeTmp = 0, ui323DCmdSizeTmp = 0;
 
 	IMG_BOOL bTAFenceOnSyncCheckpointsOnly = IMG_FALSE;
 
-	PVRSRV_FENCE	iUpdateTAFence = PVRSRV_NO_FENCE;
-	PVRSRV_FENCE	iUpdate3DFence = PVRSRV_NO_FENCE;
+	PVRSRV_FENCE iUpdateTAFence = PVRSRV_NO_FENCE;
+	PVRSRV_FENCE iUpdate3DFence = PVRSRV_NO_FENCE;
 
 	IMG_BOOL b3DFenceOnSyncCheckpointsOnly = IMG_FALSE;
 	IMG_UINT32 ui32TAFenceTimelineUpdateValue = 0;
@@ -3447,10 +3558,6 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 	RGX_SYNC_DATA s3DSyncData = {NULL};		/*!< Contains internal update syncs for 3D */
 
 	IMG_BOOL bTestSLRAdd3DCheck = IMG_FALSE;
-#if defined(SUPPORT_VALIDATION)
-	PVRSRV_FENCE hTestSLRTmpFence = PVRSRV_NO_FENCE;
-	PSYNC_CHECKPOINT psDummySyncCheckpoint = NULL;
-#endif
 
 #if defined(SUPPORT_BUFFER_SYNC)
 	PSYNC_CHECKPOINT *apsBufferFenceSyncCheckpoints = NULL;
@@ -3519,6 +3626,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		CMDTA3D_SHARED *psGeomCmdShared = (CMDTA3D_SHARED *)pui8TADMCmd;
 		CMDTA3D_SHARED *ps3DCmdShared = (CMDTA3D_SHARED *)pui83DDMCmd;
 		CMDTA3D_SHARED *psPR3DCmdShared = (CMDTA3D_SHARED *)pui83DPRDMCmd;
+		RGXFWIF_DEV_VIRTADDR sNullFWAddr = {0};
 
 		if (psKMHWRTDataSet == NULL)
 		{
@@ -3530,48 +3638,53 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		*/
 		if (psGeomCmdShared != NULL)
 		{
-			psGeomCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
-
-			if (psZSBuffer != NULL)
-			{
-				psGeomCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] = psZSBuffer->sZSBufferFWDevVAddr;
-			}
-			if (psMSAAScratchBuffer != NULL)
+			if (ui32TACmdSize < sizeof(*psGeomCmdShared))
 			{
-				psGeomCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] = psMSAAScratchBuffer->sZSBufferFWDevVAddr;
+				PVR_DPF((PVR_DBG_ERROR, "%s: Invalid TACmd size", __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
 			}
+
+			psGeomCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
+
+			psGeomCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] =
+			    psZSBuffer ? psZSBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
+			psGeomCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] =
+			    psMSAAScratchBuffer ? psMSAAScratchBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
 		}
 
 		/* Write FW address for 3D CMD
 		*/
 		if (ps3DCmdShared != NULL)
 		{
-			ps3DCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
-
-			if (psZSBuffer != NULL)
-			{
-				ps3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] = psZSBuffer->sZSBufferFWDevVAddr;
-			}
-			if (psMSAAScratchBuffer != NULL)
+			if (ui323DCmdSize < sizeof(*ps3DCmdShared))
 			{
-				ps3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] = psMSAAScratchBuffer->sZSBufferFWDevVAddr;
+				PVR_DPF((PVR_DBG_ERROR, "%s: Invalid 3DCmd size", __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
 			}
+
+			ps3DCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
+
+			ps3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] =
+			    psZSBuffer ? psZSBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
+			ps3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] =
+			    psMSAAScratchBuffer ? psMSAAScratchBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
 		}
 
 		/* Write FW address for PR3D CMD
 		*/
 		if (psPR3DCmdShared != NULL)
 		{
-			psPR3DCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
-
-			if (psZSBuffer != NULL)
-			{
-				psPR3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] = psZSBuffer->sZSBufferFWDevVAddr;
-			}
-			if (psMSAAScratchBuffer != NULL)
+			if (ui323DPRCmdSize < sizeof(*psPR3DCmdShared))
 			{
-				psPR3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] = psMSAAScratchBuffer->sZSBufferFWDevVAddr;
+				PVR_DPF((PVR_DBG_ERROR, "%s: Invalid 3DPRCmd size", __func__));
+				return PVRSRV_ERROR_INVALID_PARAMS;
 			}
+
+			psPR3DCmdShared->sHWRTData = psKMHWRTDataSet->sHWRTDataFwAddr;
+			psPR3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_ZSBUFFER] =
+			    psZSBuffer ? psZSBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
+			psPR3DCmdShared->asPRBuffer[RGXFWIF_PRBUFFER_MSAABUFFER] =
+			    psMSAAScratchBuffer ? psMSAAScratchBuffer->sZSBufferFWDevVAddr : sNullFWAddr;
 		}
 	}
 
@@ -3801,50 +3914,6 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 				UPDATE_FENCE_CHECKPOINT_COUNT : 0;
 	}
 
-#if defined(SUPPORT_VALIDATION)
-	/* Check if TestingSLR is adding an extra sync checkpoint to the
-	 * 3D fence check (which we won't signal)
-	 */
-	if ((psDevInfo->ui32TestSLRInterval > 0) &&
-	    (--psDevInfo->ui32TestSLRCount == 0))
-	{
-		bTestSLRAdd3DCheck = IMG_TRUE;
-		psDevInfo->ui32TestSLRCount = psDevInfo->ui32TestSLRInterval;
-	}
-
-	if ((bTestSLRAdd3DCheck) && (iUpdate3DTimeline != PVRSRV_NO_TIMELINE))
-	{
-		if (iUpdate3DTimeline == PVRSRV_NO_TIMELINE)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "%s: Would append additional SLR checkpoint "
-			         "to 3D fence but no update 3D timeline provided", __func__));
-		}
-		else
-		{
-			SyncCheckpointAlloc(psRenderContext->psDeviceNode->hSyncCheckpointContext,
-			                    iUpdate3DTimeline,
-			                    hTestSLRTmpFence,
-			                    "TestSLRCheck",
-			                    &psDummySyncCheckpoint);
-			PVR_DPF((PVR_DBG_WARNING, "%s: Appending additional SLR checkpoint to 3D fence "
-			                          "checkpoints (psDummySyncCheckpoint=<%p>)",
-			                          __func__, (void*)psDummySyncCheckpoint));
-			SyncAddrListAppendCheckpoints(&psRenderContext->sSyncAddrList3DFence,
-			                              1,
-			                              &psDummySyncCheckpoint);
-			if (!pauiClient3DFenceUFOAddress)
-			{
-				pauiClient3DFenceUFOAddress = psRenderContext->sSyncAddrList3DFence.pasFWAddrs;
-			}
-
-			if (ui32Client3DFenceCount == 0)
-			{
-				b3DFenceOnSyncCheckpointsOnly = IMG_TRUE;
-			}
-			ui323DFenceCount++;
-		}
-	}
-#endif /* defined(SUPPORT_VALIDATION) */
 
 	if (bKickTA)
 	{
@@ -4651,7 +4720,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if ((!PVRSRV_VZ_MODE_IS(GUEST)) && (bKickTA || bKick3D || bAbort))
+	if ((!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode)) && (bKickTA || bKick3D || bAbort))
 	{
 		sWorkloadCharacteristics.sTA3D.ui32RenderTargetSize  = ui32RenderTargetSize;
 		sWorkloadCharacteristics.sTA3D.ui32NumberOfDrawCalls = ui32NumberOfDrawCalls;
@@ -4666,7 +4735,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		RGX_SERVER_RC_TA_DATA *psTAData = &psRenderContext->sTAData;
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 		{
 			/* Prepare workload estimation */
 			WorkEstPrepare(psRenderContext->psDeviceNode->pvDevice,
@@ -4683,7 +4752,8 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		CHKPT_DBG((PVR_DBG_ERROR,
 				   "%s:   calling RGXCmdHelperInitCmdCCB(), ui32ClientTAFenceCount=%d, ui32ClientTAUpdateCount=%d",
 				   __func__, ui32ClientTAFenceCount, ui32ClientTAUpdateCount));
-		RGXCmdHelperInitCmdCCB_OtherData(FWCommonContextGetClientCCB(psTAData->psServerCommonContext),
+		RGXCmdHelperInitCmdCCB_OtherData(psDevInfo,
+		                                 FWCommonContextGetClientCCB(psTAData->psServerCommonContext),
 		                                 ui32ClientTAFenceCount,
 		                                 pauiClientTAFenceUFOAddress,
 		                                 paui32ClientTAFenceValue,
@@ -4709,7 +4779,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		                                 pasTACmdHelperData);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 		{
 			/* The following is used to determine the offset of the command header containing
 			   the workload estimation data so that can be accessed when the KCCB is read */
@@ -4747,7 +4817,8 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		CHKPT_DBG((PVR_DBG_ERROR,
 				   "%s:   calling RGXCmdHelperInitCmdCCB(), ui32Client3DFenceCount=%d",
 				   __func__, ui32Client3DFenceCount));
-		RGXCmdHelperInitCmdCCB_OtherData(FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
+		RGXCmdHelperInitCmdCCB_OtherData(psDevInfo,
+		                                 FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
 		                                 ui32Client3DFenceCount + (bTestSLRAdd3DCheck ? 1 : 0),
 		                                 pauiClient3DFenceUFOAddress,
 		                                 NULL,
@@ -4793,7 +4864,8 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 			CHKPT_DBG((PVR_DBG_ERROR,
 					   "%s:   calling RGXCmdHelperInitCmdCCB(), ui32ClientPRUpdateCount=%d",
 					   __func__, ui32ClientPRUpdateCount));
-			RGXCmdHelperInitCmdCCB_OtherData(FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
+			RGXCmdHelperInitCmdCCB_OtherData(psDevInfo,
+			                                 FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
 			                                 0,
 			                                 NULL,
 			                                 NULL,
@@ -4822,7 +4894,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		const RGXFWIF_CCB_CMD_TYPE e3DCmdType = bAbort ? RGXFWIF_CCB_CMD_TYPE_ABORT : RGXFWIF_CCB_CMD_TYPE_3D;
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 		{
 			/* Prepare workload estimation */
 			WorkEstPrepare(psRenderContext->psDeviceNode->pvDevice,
@@ -4836,7 +4908,8 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 #endif
 
 		/* Init the 3D command helper */
-		RGXCmdHelperInitCmdCCB_OtherData(FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
+		RGXCmdHelperInitCmdCCB_OtherData(psDevInfo,
+		                                 FWCommonContextGetClientCCB(ps3DData->psServerCommonContext),
 		                                 bKickTA ? 0 : ui32Client3DFenceCount,  /* For a kick with a TA, the 3D fences are added before the PR command instead */
 		                                 bKickTA ? NULL : pauiClient3DFenceUFOAddress,
 		                                 NULL,
@@ -4862,7 +4935,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		                                 &pas3DCmdHelperData[ui323DCmdCount++]);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psRenderContext->psDeviceNode))
 		{
 			/* The following are used to determine the offset of the command header containing the workload estimation
 			   data so that can be accessed when the KCCB is read */
@@ -4962,7 +5035,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 								  FWCommonContextGetFWAddress(psRenderContext->sTAData.psServerCommonContext).ui32Addr);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 		{
 			ui32TACmdOffsetWrapCheck = RGXGetHostWriteOffsetCCB(FWCommonContextGetClientCCB(psRenderContext->sTAData.psServerCommonContext));
 
@@ -4989,7 +5062,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 								  FWCommonContextGetFWAddress(psRenderContext->s3DData.psServerCommonContext).ui32Addr);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 		{
 			ui323DCmdOffsetWrapCheck = RGXGetHostWriteOffsetCCB(FWCommonContextGetClientCCB(psRenderContext->s3DData.psServerCommonContext));
 
@@ -5016,7 +5089,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		sTACmdKickData.ui32CWrapMaskUpdate = RGXGetWrapMaskCCB(psClientCCB);
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 		{
 			/* Add the Workload data into the KCCB kick */
 			sTACmdKickData.ui32WorkEstCmdHeaderOffset = ui32TACommandOffset + ui32TACmdHeaderOffset;
@@ -5054,7 +5127,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 			sTAKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_KICK;
 			sTAKCCBCmd.uCmdData.sCmdKickData = sTACmdKickData;
 
-			LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+			LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 			{
 				eError2 = RGXScheduleCommandWithoutPowerLock(psRenderContext->psDeviceNode->pvDevice,
 						RGXFWIF_DM_GEOM,
@@ -5065,7 +5138,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 					break;
 				}
 				OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-			} END_LOOP_UNTIL_TIMEOUT();
+			} END_LOOP_UNTIL_TIMEOUT_US();
 		}
 
 		if (eError2 != PVRSRV_OK)
@@ -5094,7 +5167,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 
 		/* Add the Workload data into the KCCB kick */
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDevInfo->psDeviceNode))
 		{
 			/* Store the offset to the CCCB command header so that it can be referenced when the KCCB command reaches the FW */
 			s3DCmdKickData.ui32WorkEstCmdHeaderOffset = ui323DCommandOffset + ui323DCmdHeaderOffset + ui323DFullRenderCommandOffset;
@@ -5139,7 +5212,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 			s3DKCCBCmd.uCmdData.sCmdKickData = s3DCmdKickData;
 		}
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			eError2 = RGXScheduleCommandWithoutPowerLock(psRenderContext->psDeviceNode->pvDevice,
 										 RGXFWIF_DM_3D,
@@ -5150,7 +5223,7 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		if (eError2 != PVRSRV_OK)
 		{
@@ -5287,12 +5360,6 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 		OSFreeMem(s3DSyncData.paui32ClientUpdateValue);
 	}
 
-#if defined(SUPPORT_VALIDATION)
-	if (bTestSLRAdd3DCheck)
-	{
-		SyncCheckpointFree(psDummySyncCheckpoint);
-	}
-#endif
 	OSLockRelease(psRenderContext->hLock);
 
 	return PVRSRV_OK;
@@ -5376,12 +5443,6 @@ PVRSRV_ERROR PVRSRVRGXKickTA3DKM(RGX_SERVER_RENDER_CONTEXT	*psRenderContext,
 	{
 		OSFreeMem(s3DSyncData.paui32ClientUpdateValue);
 	}
-#if defined(SUPPORT_VALIDATION)
-	if (bTestSLRAdd3DCheck)
-	{
-		SyncCheckpointFree(psDummySyncCheckpoint);
-	}
-#endif
 #if defined(SUPPORT_BUFFER_SYNC)
 	if (psBufferSyncData)
 	{
@@ -5422,7 +5483,7 @@ PVRSRV_ERROR PVRSRVRGXSendZSStoreDisableKM(CONNECTION_DATA *psConnection,
 		return PVRSRV_ERROR_INVALID_CONTEXT;
 	}
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psRenderContext->psDeviceNode->pvDevice,
 									RGXFWIF_DM_3D,
@@ -5433,7 +5494,7 @@ PVRSRV_ERROR PVRSRVRGXSendZSStoreDisableKM(CONNECTION_DATA *psConnection,
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (eError != PVRSRV_OK)
 	{
diff --git a/drivers/gpu/drm/img-rogue/rgxta3d.h b/drivers/gpu/drm/img-rogue/rgxta3d.h
index d789e62a2602..45c71796793e 100644
--- a/drivers/gpu/drm/img-rogue/rgxta3d.h
+++ b/drivers/gpu/drm/img-rogue/rgxta3d.h
@@ -148,6 +148,8 @@ struct _RGX_FREELIST_ {
 	PMR						*psFreeListPMR;
 	IMG_DEVMEM_OFFSET_T		uiFreeListPMROffset;
 
+	DEVMEMINT_RESERVATION* psFreeListReservation;
+
 	/* Freelist config */
 	IMG_UINT32				ui32MaxFLPages;
 	IMG_UINT32				ui32InitFLPages;
@@ -200,11 +202,10 @@ typedef struct {
 
 	DEVMEMINT_RESERVATION	*psReservation;
 	PMR						*psPMR;
-	DEVMEMINT_MAPPING		*psMapping;
-	PVRSRV_MEMALLOCFLAGS_T	uiMapFlags;
 	IMG_UINT32				ui32ZSBufferID;
 	IMG_UINT32				ui32RefCount;
 	IMG_BOOL				bOnDemand;
+	IMG_BOOL				bIsBacked;
 
 	IMG_UINT32				ui32NumReqByApp;		/* Number of Backing Requests from Application */
 	IMG_UINT32				ui32NumReqByFW;			/* Number of Backing Requests from Firmware */
@@ -259,12 +260,12 @@ PVRSRV_ERROR RGXDestroyHWRTDataSet(RGX_KM_HW_RT_DATASET *psKMHWRTDataSet);
 /*
 	RGXCreateZSBufferKM
 */
-PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA			*psConnection,
-                                 PVRSRV_DEVICE_NODE			*psDeviceNode,
-                                 DEVMEMINT_RESERVATION		*psReservation,
-                                 PMR						*psPMR,
+PVRSRV_ERROR RGXCreateZSBufferKM(CONNECTION_DATA * psConnection,
+                                 PVRSRV_DEVICE_NODE	*psDeviceNode,
+                                 DEVMEMINT_RESERVATION	*psReservation,
+                                 PMR					*psPMR,
                                  PVRSRV_MEMALLOCFLAGS_T		uiMapFlags,
-                                 RGX_ZSBUFFER_DATA			**ppsZSBuffer);
+                                 RGX_ZSBUFFER_DATA **ppsZSBuffer);
 
 /*
 	RGXDestroyZSBufferKM
@@ -331,9 +332,7 @@ PVRSRV_ERROR RGXCreateFreeList(CONNECTION_DATA      *psConnection,
                                IMG_UINT32           ui32GrowParamThreshold,
                                RGX_FREELIST			*psGlobalFreeList,
                                IMG_BOOL				bCheckFreelist,
-                               IMG_DEV_VIRTADDR		sFreeListDevVAddr,
-                               PMR					*psFreeListPMR,
-                               IMG_DEVMEM_OFFSET_T	uiFreeListPMROffset,
+                               DEVMEMINT_RESERVATION* psFreeListReservation,
                                RGX_FREELIST			**ppsFreeList);
 
 /* Destroy free list */
diff --git a/drivers/gpu/drm/img-rogue/rgxtdmtransfer.c b/drivers/gpu/drm/img-rogue/rgxtdmtransfer.c
index 469a81e80bc6..ff33e864d971 100644
--- a/drivers/gpu/drm/img-rogue/rgxtdmtransfer.c
+++ b/drivers/gpu/drm/img-rogue/rgxtdmtransfer.c
@@ -71,9 +71,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvr_buffer_sync.h"
 #endif
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER)
-#include "validation_soc.h"
-#endif
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
 #include "rgxworkest.h"
@@ -81,6 +78,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "rgxtimerquery.h"
 
+
 /* Enable this to dump the compiled list of UFOs prior to kick call */
 #define ENABLE_TDM_UFO_DUMP	0
 
@@ -124,6 +122,7 @@ static PVRSRV_ERROR _CreateTDMTransferContext(
 	SERVER_MMU_CONTEXT      * psServerMMUContext,
 	DEVMEM_MEMDESC          * psFWMemContextMemDesc,
 	IMG_INT32                 i32Priority,
+	IMG_INT32                 ui32MaxDeadlineMS,
 	RGX_COMMON_CONTEXT_INFO * psInfo,
 	RGX_SERVER_TQ_TDM_DATA  * psTDMData,
 	IMG_UINT32                ui32CCBAllocSizeLog2,
@@ -162,7 +161,7 @@ static PVRSRV_ERROR _CreateTDMTransferContext(
 			ui32CCBMaxAllocSizeLog2 ? ui32CCBMaxAllocSizeLog2 : RGX_TDM_CCB_MAX_SIZE_LOG2,
 			ui32ContextFlags,
 			i32Priority,
-			UINT_MAX, /* max deadline MS */
+			ui32MaxDeadlineMS,
 			ui64RobustnessAddress,
 			psInfo,
 			&psTDMData->psServerCommonContext);
@@ -197,16 +196,10 @@ static PVRSRV_ERROR _DestroyTDMTransferContext(
 		psTDMData->psServerCommonContext,
 		RGXFWIF_DM_TDM,
 		PDUMP_FLAGS_CONTINUOUS);
-	if (RGXIsErrorAndDeviceRecoverable(psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				 __func__,
-				 PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 	/* ... it has so we can free it's resources */
 	FWCommonContextFree(psTDMData->psServerCommonContext);
@@ -233,6 +226,7 @@ PVRSRV_ERROR PVRSRVRGXTDMCreateTransferContextKM(
 	IMG_UINT32                   ui32PackedCCBSizeU88,
 	IMG_UINT32                   ui32ContextFlags,
 	IMG_UINT64                   ui64RobustnessAddress,
+	IMG_UINT32                   ui32MaxDeadlineMS,
 	RGX_SERVER_TQ_TDM_CONTEXT ** ppsTransferContext)
 {
 	RGX_SERVER_TQ_TDM_CONTEXT * psTransferContext;
@@ -317,6 +311,7 @@ PVRSRV_ERROR PVRSRVRGXTDMCreateTransferContextKM(
 	                                   hMemCtxPrivData,
 	                                   psFWMemContextMemDesc,
 	                                   i32Priority,
+	                                   ui32MaxDeadlineMS,
 	                                   &sInfo,
 	                                   &psTransferContext->sTDMData,
 									   U32toU8_Unpack1(ui32PackedCCBSizeU88),
@@ -329,7 +324,7 @@ PVRSRV_ERROR PVRSRVRGXTDMCreateTransferContextKM(
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		WorkEstInitTDM(psDevInfo, &psTransferContext->sWorkEstData);
 	}
@@ -365,10 +360,11 @@ PVRSRV_ERROR PVRSRVRGXTDMCreateTransferContextKM(
 PVRSRV_ERROR PVRSRVRGXTDMGetSharedMemoryKM(
 	CONNECTION_DATA           * psConnection,
 	PVRSRV_DEVICE_NODE        * psDeviceNode,
-	PMR                      ** ppsCLIPMRMem,
-	PMR                      ** ppsUSCPMRMem)
+	PMR                      ** ppsCLIPMRMem)
 {
-	PVRSRVTQAcquireShaders(psDeviceNode, ppsCLIPMRMem, ppsUSCPMRMem);
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
+	PVRSRVTQAcquireShaders(psDeviceNode, ppsCLIPMRMem);
 
 	return PVRSRV_OK;
 }
@@ -383,10 +379,11 @@ PVRSRV_ERROR PVRSRVRGXTDMReleaseSharedMemoryKM(PMR * psPMRMem)
 PVRSRV_ERROR PVRSRVRGXTDMDestroyTransferContextKM(RGX_SERVER_TQ_TDM_CONTEXT *psTransferContext)
 {
 	PVRSRV_ERROR eError;
-	PVRSRV_RGXDEV_INFO *psDevInfo = psTransferContext->psDeviceNode->pvDevice;
+	PVRSRV_DEVICE_NODE *psDeviceNode = psTransferContext->psDeviceNode;
+	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		RGXFWIF_FWTDMCONTEXT	*psFWTransferContext;
 		IMG_UINT32 ui32WorkEstCCBSubmitted;
@@ -438,7 +435,7 @@ PVRSRV_ERROR PVRSRVRGXTDMDestroyTransferContextKM(RGX_SERVER_TQ_TDM_CONTEXT *psT
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		WorkEstDeInitTDM(psDevInfo, &psTransferContext->sWorkEstData);
 	}
@@ -473,6 +470,7 @@ PVRSRV_ERROR PVRSRVRGXTDMDestroyTransferContextKM(RGX_SERVER_TQ_TDM_CONTEXT *psT
 /*
  * PVRSRVSubmitTQ3DKickKM
  */
+/* Old bridge call for backwards compatibility. */
 PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 	RGX_SERVER_TQ_TDM_CONTEXT * psTransferContext,
 	IMG_UINT32                  ui32PDumpFlags,
@@ -493,6 +491,50 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 	IMG_UINT32                  ui32TDMCharacteristic1,
 	IMG_UINT32                  ui32TDMCharacteristic2,
 	IMG_UINT64                  ui64DeadlineInus)
+{
+	return PVRSRVRGXTDMSubmitTransfer3KM(psTransferContext,
+										 ui32PDumpFlags,
+										 ui32ClientUpdateCount,
+										 pauiClientUpdateUFODevVarBlock,
+										 paui32ClientUpdateSyncOffset,
+										 paui32ClientUpdateValue,
+										 iCheckFence,
+										 iUpdateTimeline,
+										 piUpdateFence,
+										 szUpdateFenceName,
+										 PVRSRV_NO_FENCE,
+										 ui32FWCommandSize,
+										 pui8FWCommand,
+										 ui32ExtJobRef,
+										 ui32SyncPMRCount,
+										 paui32SyncPMRFlags,
+										 ppsSyncPMRs,
+										 ui32TDMCharacteristic1,
+										 ui32TDMCharacteristic2,
+										 ui64DeadlineInus);
+}
+
+PVRSRV_ERROR PVRSRVRGXTDMSubmitTransfer3KM(
+	RGX_SERVER_TQ_TDM_CONTEXT * psTransferContext,
+	IMG_UINT32                  ui32PDumpFlags,
+	IMG_UINT32                  ui32ClientUpdateCount,
+	SYNC_PRIMITIVE_BLOCK     ** pauiClientUpdateUFODevVarBlock,
+	IMG_UINT32                * paui32ClientUpdateSyncOffset,
+	IMG_UINT32                * paui32ClientUpdateValue,
+	PVRSRV_FENCE                iCheckFence,
+	PVRSRV_TIMELINE             iUpdateTimeline,
+	PVRSRV_FENCE              * piUpdateFence,
+	IMG_CHAR                    szUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
+	PVRSRV_FENCE                iExportFenceToSignal,
+	IMG_UINT32                  ui32FWCommandSize,
+	IMG_UINT8                 * pui8FWCommand,
+	IMG_UINT32                  ui32ExtJobRef,
+	IMG_UINT32                  ui32SyncPMRCount,
+	IMG_UINT32                * paui32SyncPMRFlags,
+	PMR                      ** ppsSyncPMRs,
+	IMG_UINT32                  ui32TDMCharacteristic1,
+	IMG_UINT32                  ui32TDMCharacteristic2,
+	IMG_UINT64                  ui64DeadlineInus)
 {
 	PVRSRV_DEVICE_NODE *psDeviceNode = psTransferContext->psDeviceNode;
 	RGX_CCB_CMD_HELPER_DATA *psCmdHelper;
@@ -534,6 +576,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 #endif
 
 	PSYNC_CHECKPOINT psUpdateSyncCheckpoint = NULL;
+	PSYNC_CHECKPOINT psExportFenceSyncCheckpoint = NULL;
 	PSYNC_CHECKPOINT *apsFenceSyncCheckpoints = NULL;
 	IMG_UINT32 ui32FenceSyncCheckpointCount = 0;
 	IMG_UINT32 *pui32IntAllocatedUpdateValues = NULL;
@@ -565,7 +608,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 	}
 
 	/* Ensure the string is null-terminated (Required for safety) */
-	szUpdateFenceName[31] = '\0';
+	szUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH-1] = '\0';
 
 	if (ui32SyncPMRCount != 0)
 	{
@@ -703,6 +746,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 				ui32IntClientUpdateCount++;
 			}
 #else /* defined(SUPPORT_BUFFER_SYNC) */
+			PVR_UNREFERENCED_PARAMETER(paui32SyncPMRFlags);
 			PVR_DPF((PVR_DBG_ERROR, "%s: Buffer sync not supported but got %u buffers", __func__, ui32SyncPMRCount));
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 			goto fail_populate_sync_addr_list;
@@ -749,6 +793,38 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 				goto fail_create_output_fence;
 			}
 
+			/* Resolve the iExportFenceToSignal (if required) */
+			if (iExportFenceToSignal != PVRSRV_NO_FENCE)
+			{
+				IMG_UINT32 iii;
+
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: SyncCheckpointResolveExportFence(iExportFenceToSignal=%d), ui32FenceSyncCheckpointCount=%d", __func__, iExportFenceToSignal, ui32FenceSyncCheckpointCount));
+				eError = SyncCheckpointResolveExportFence(iExportFenceToSignal,
+														  psTransferContext->psDeviceNode->hSyncCheckpointContext,
+														  &psExportFenceSyncCheckpoint,
+														  ui32PDumpFlags);
+				if (eError != PVRSRV_OK)
+				{
+					CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned error (%s) psExportFenceSyncCheckpoint=<%p>", __func__, PVRSRVGetErrorString(eError), psExportFenceSyncCheckpoint));
+					goto fail_resolve_export_fence;
+				}
+
+				/* Check that the export fence was not also included as part of the
+				 * check fence (which is an error and would lead to a stalled kick).
+				 */
+				for (iii=0; iii<ui32FenceSyncCheckpointCount; iii++)
+				{
+					if (apsFenceSyncCheckpoints[iii] == psExportFenceSyncCheckpoint)
+					{
+						CHKPT_DBG((PVR_DBG_ERROR, "%s: apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, iii, apsFenceSyncCheckpoints[iii], SyncCheckpointGetFirmwareAddr(apsFenceSyncCheckpoints[iii])));
+						CHKPT_DBG((PVR_DBG_ERROR, "%s: ERROR psExportFenceSyncCheckpoint=<%p>", __func__, psExportFenceSyncCheckpoint));
+						eError = PVRSRV_ERROR_INVALID_PARAMS;
+						PVR_DPF((PVR_DBG_ERROR, " %s - iCheckFence includes iExportFenceToSignal", PVRSRVGetErrorString(eError)));
+						goto fail_check_fence_includes_export_fence;
+					}
+				}
+			}
+
 			/* Append the sync prim update for the timeline (if required) */
 			if (psFenceTimelineUpdateSync)
 			{
@@ -868,6 +944,34 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 #endif
 		}
 
+		if (psExportFenceSyncCheckpoint)
+		{
+			/* Append the update (from export fence) */
+			CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append 1 sync checkpoint to Transfer CDM Update (&psTransferContext->sSyncAddrListUpdate=<%p>, psExportFenceSyncCheckpoint=<%p>)...", __func__, (void*)&psTransferContext->sSyncAddrListUpdate , (void*)psExportFenceSyncCheckpoint));
+			SyncAddrListAppendCheckpoints(&psTransferContext->sSyncAddrListUpdate,
+										  1,
+										  &psExportFenceSyncCheckpoint);
+			if (!pauiIntUpdateUFOAddress)
+			{
+				pauiIntUpdateUFOAddress = psTransferContext->sSyncAddrListUpdate.pasFWAddrs;
+			}
+			ui32IntClientUpdateCount++;
+#if defined(CMP_CHECKPOINT_DEBUG)
+			if (ui32IntClientUpdateCount > 0)
+			{
+				IMG_UINT32 iii;
+				IMG_UINT32 *pui32Tmp = (IMG_UINT32*)pauiIntUpdateUFOAddress;
+
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress=<%p>, pui32Tmp=<%p>, ui32IntClientUpdateCount=%u", __func__, (void*)pauiIntUpdateUFOAddress, (void*)pui32Tmp, ui32IntClientUpdateCount));
+				for (iii=0; iii<ui32IntClientUpdateCount; iii++)
+				{
+					CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress[%d](<%p>) = 0x%x", __func__, iii, (void*)pui32Tmp, *pui32Tmp));
+					pui32Tmp++;
+				}
+			}
+#endif
+		}
+
 #if (ENABLE_TDM_UFO_DUMP == 1)
 		PVR_DPF((PVR_DBG_ERROR, "%s: dumping TDM fence/updates syncs...", __func__));
 		{
@@ -925,7 +1029,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 #endif
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			sWorkloadCharacteristics.sTransfer.ui32Characteristic1 = ui32TDMCharacteristic1;
 			sWorkloadCharacteristics.sTransfer.ui32Characteristic2 = ui32TDMCharacteristic2;
@@ -970,6 +1074,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 		                       pszCommandName,
 		                       bCCBStateOpen,
 		                       psCmdHelper);
+
 	}
 
 	/*
@@ -1008,7 +1113,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 	}
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		ui32CmdOffset = RGXGetHostWriteOffsetCCB(FWCommonContextGetClientCCB(psTransferContext->sTDMData.psServerCommonContext));
 	}
@@ -1020,7 +1125,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 
 
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		/* The following is used to determine the offset of the command header containing
 		   the workload estimation data so that can be accessed when the KCCB is read */
@@ -1061,7 +1166,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 
 		/* Add the Workload data into the KCCB kick */
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-		if (!PVRSRV_VZ_MODE_IS(GUEST))
+		if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 		{
 			/* Store the offset to the CCCB command header so that it can be referenced
 			 * when the KCCB command reaches the FW */
@@ -1086,7 +1191,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 		                  NO_DEADLINE,
 		                  NO_CYCEST);
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			eError = RGXScheduleCommandWithoutPowerLock(psDeviceNode->pvDevice,
 			                             RGXFWIF_DM_TDM,
@@ -1097,7 +1202,7 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		PVRSRVPowerUnlock(psDevInfo->psDeviceNode);
 
@@ -1122,6 +1227,11 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 		SyncPrimNoHwUpdate(psFenceTimelineUpdateSync, ui32FenceTimelineUpdateValue);
 	}
 	SyncCheckpointNoHWUpdateTimelines(NULL);
+	if (psExportFenceSyncCheckpoint)
+	{
+		SyncCheckpointSignalNoHW(psExportFenceSyncCheckpoint);
+		SyncCheckpointNoHWSignalExportFence(iExportFenceToSignal);
+	}
 #endif /* defined(NO_HARDWARE) */
 
 #if defined(SUPPORT_BUFFER_SYNC)
@@ -1185,10 +1295,12 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 		pui32IntAllocatedUpdateValues = NULL;
 	}
 fail_alloc_update_values_mem:
-
-/* fail_pdumpcheck: */
-/* fail_cmdtype: */
-
+	if (psExportFenceSyncCheckpoint)
+	{
+		SyncCheckpointRollbackExportFence(iExportFenceToSignal);
+	}
+fail_check_fence_includes_export_fence:
+fail_resolve_export_fence:
 	if (iUpdateFence != PVRSRV_NO_FENCE)
 	{
 		SyncCheckpointRollbackFenceData(iUpdateFence, pvUpdateFenceFinaliseData);
@@ -1239,7 +1351,7 @@ PVRSRV_ERROR PVRSRVRGXTDMNotifyWriteOffsetUpdateKM(
 	sKCCBCmd.eCmdType = RGXFWIF_KCCB_CMD_NOTIFY_WRITE_OFFSET_UPDATE;
 	sKCCBCmd.uCmdData.sWriteOffsetUpdateData.psContext = FWCommonContextGetFWAddress(psTransferContext->sTDMData.psServerCommonContext);
 
-	LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+	LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 	{
 		eError = RGXScheduleCommand(psTransferContext->psDeviceNode->pvDevice,
 		                            RGXFWIF_DM_TDM,
@@ -1250,7 +1362,7 @@ PVRSRV_ERROR PVRSRVRGXTDMNotifyWriteOffsetUpdateKM(
 			break;
 		}
 		OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-	} END_LOOP_UNTIL_TIMEOUT();
+	} END_LOOP_UNTIL_TIMEOUT_US();
 
 	if (eError != PVRSRV_OK)
 	{
diff --git a/drivers/gpu/drm/img-rogue/rgxtdmtransfer.h b/drivers/gpu/drm/img-rogue/rgxtdmtransfer.h
index a7fc39bcf34e..b0f003cf3ad3 100644
--- a/drivers/gpu/drm/img-rogue/rgxtdmtransfer.h
+++ b/drivers/gpu/drm/img-rogue/rgxtdmtransfer.h
@@ -68,14 +68,14 @@ PVRSRV_ERROR PVRSRVRGXTDMCreateTransferContextKM(
 	IMG_UINT32					ui32PackedCCBSizeU88,
 	IMG_UINT32                  ui32ContextFlags,
 	IMG_UINT64					ui64RobustnessAddress,
+	IMG_UINT32                  ui32MaxDeadlineMS,
 	RGX_SERVER_TQ_TDM_CONTEXT **ppsTransferContext);
 
 
 PVRSRV_ERROR PVRSRVRGXTDMGetSharedMemoryKM(
 	CONNECTION_DATA           * psConnection,
 	PVRSRV_DEVICE_NODE        * psDeviceNode,
-	PMR                      ** ppsCLIPMRMem,
-	PMR                      ** ppsUSCPMRMem);
+	PMR                      ** ppsCLIPMRMem);
 
 
 PVRSRV_ERROR PVRSRVRGXTDMReleaseSharedMemoryKM(PMR * psUSCPMRMem);
@@ -105,6 +105,28 @@ PVRSRV_ERROR PVRSRVRGXTDMSubmitTransferKM(
 	IMG_UINT32					ui32TDMCharacteristic2,
 	IMG_UINT64					ui64DeadlineInus);
 
+PVRSRV_ERROR PVRSRVRGXTDMSubmitTransfer3KM(
+	RGX_SERVER_TQ_TDM_CONTEXT * psTransferContext,
+	IMG_UINT32                  ui32PDumpFlags,
+	IMG_UINT32                  ui32ClientUpdateCount,
+	SYNC_PRIMITIVE_BLOCK     ** pauiClientUpdateUFODevVarBlock,
+	IMG_UINT32                * paui32ClientUpdateSyncOffset,
+	IMG_UINT32                * paui32ClientUpdateValue,
+	PVRSRV_FENCE                iCheckFence,
+	PVRSRV_TIMELINE             iUpdateTimeline,
+	PVRSRV_FENCE              * piUpdateFence,
+	IMG_CHAR                    szUpdateFenceName[PVRSRV_SYNC_NAME_LENGTH],
+	PVRSRV_FENCE                iExportFenceToSignal,
+	IMG_UINT32                  ui32FWCommandSize,
+	IMG_UINT8                 * pui8FWCommand,
+	IMG_UINT32                  ui32ExtJobRef,
+	IMG_UINT32                  ui32SyncPMRCount,
+	IMG_UINT32                * pui32SyncPMRFlags,
+	PMR                      ** ppsSyncPMRs,
+	IMG_UINT32					ui32TDMCharacteristic1,
+	IMG_UINT32					ui32TDMCharacteristic2,
+	IMG_UINT64					ui64DeadlineInus);
+
 PVRSRV_ERROR PVRSRVRGXTDMNotifyWriteOffsetUpdateKM(
 	RGX_SERVER_TQ_TDM_CONTEXT *psTransferContext,
 	IMG_UINT32                 ui32PDumpFlags);
diff --git a/drivers/gpu/drm/img-rogue/rgxtimecorr.c b/drivers/gpu/drm/img-rogue/rgxtimecorr.c
index b70b1e407da5..29ac662ed418 100644
--- a/drivers/gpu/drm/img-rogue/rgxtimecorr.c
+++ b/drivers/gpu/drm/img-rogue/rgxtimecorr.c
@@ -161,23 +161,48 @@ IMG_UINT64 RGXTimeCorrGetClockus64(const PVRSRV_DEVICE_NODE *psDeviceNode)
 	return OSDivide64r64(RGXTimeCorrGetClockns64(psDeviceNode), 1000, &rem);
 }
 
+static IMG_UINT64 RGXTimeGetDeviceTimestampInTicks(PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	IMG_UINT64 ui64DeviceTimestamp;
+
+	/* In case of powerlock acquire fails or device is powered off, return
+	 * last device power off timestamp plus ticks corresponding to device off time. */
+	ui64DeviceTimestamp = psDeviceNode->ui64LastDeviceOffTimestamp +
+			       RGXTimeCorrDeltaOSNsToDeltaCR(psDeviceNode,
+						OSClockns64() - psDeviceNode->ui64LastDeviceOffHostTimestampNs);
+
+	if (PVRSRV_OK == PVRSRVPowerLock(psDeviceNode))
+	{
+		PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+		RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
+
+		if (PVRSRVIsDevicePowered(psDeviceNode))
+		{
+			ui64DeviceTimestamp = RGXReadHWTimerReg(psDevInfo) + psGpuUtilFW->i64DeviceTimestampOffset;
+		}
+		PVRSRVPowerUnlock(psDeviceNode);
+	}
+
+	return ui64DeviceTimestamp;
+}
+
 void RGXGetTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode,
 							RGXFWIF_TIME_CORR *psTimeCorrs,
 							IMG_UINT32 ui32NumOut)
 {
 	PVRSRV_RGXDEV_INFO    *psDevInfo     = psDeviceNode->pvDevice;
-	RGXFWIF_GPU_UTIL_FWCB *psGpuUtilFWCB = psDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_UTIL_FW   *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
 	IMG_UINT32 ui32CurrentIndex;
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->ui32TimeCorrSeqCount, INVALIDATE);
-	ui32CurrentIndex = psGpuUtilFWCB->ui32TimeCorrSeqCount;
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->ui32TimeCorrSeqCount, INVALIDATE);
+	ui32CurrentIndex = psGpuUtilFW->ui32TimeCorrSeqCount;
 
-	RGXFwSharedMemCacheOpExec(&psGpuUtilFWCB->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32CurrentIndex - ui32NumOut)],
-	                          sizeof(psGpuUtilFWCB->sTimeCorr[0]) * ui32NumOut,
+	RGXFwSharedMemCacheOpExec(&psGpuUtilFW->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32CurrentIndex - ui32NumOut)],
+	                          sizeof(psGpuUtilFW->sTimeCorr[0]) * ui32NumOut,
 	                          PVRSRV_CACHE_OP_INVALIDATE);
 	while (ui32NumOut--)
 	{
-		*(psTimeCorrs++) = psGpuUtilFWCB->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32CurrentIndex)];
+		*(psTimeCorrs++) = psGpuUtilFW->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32CurrentIndex)];
 		ui32CurrentIndex--;
 	}
 }
@@ -246,22 +271,22 @@ static inline void _DumpTimerCorrelationHistory(PVRSRV_RGXDEV_INFO *psDevInfo)
 static void _RGXMakeTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode, RGXTIMECORR_EVENT eEvent)
 {
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	RGXFWIF_GPU_UTIL_FWCB *psGpuUtilFWCB = psDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
 	IMG_UINT32 ui32NewSeqCount;
 	RGXFWIF_TIME_CORR *psTimeCorr;
 	RGXFWIF_TIME_CORR sTimeCorr = {0};
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->ui32TimeCorrSeqCount, INVALIDATE);
-	ui32NewSeqCount = psGpuUtilFWCB->ui32TimeCorrSeqCount + 1;
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32NewSeqCount)], INVALIDATE);
-	psTimeCorr = &psGpuUtilFWCB->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32NewSeqCount)];
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->ui32TimeCorrSeqCount, INVALIDATE);
+	ui32NewSeqCount = psGpuUtilFW->ui32TimeCorrSeqCount + 1;
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32NewSeqCount)], INVALIDATE);
+	psTimeCorr = &psGpuUtilFW->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(ui32NewSeqCount)];
 
 	/*
 	 * The following reads must be done as close together as possible, because
 	 * they represent the same current time sampled from different clock sources.
 	 */
 #if defined(SUPPORT_WORKLOAD_ESTIMATION)
-	if (!PVRSRV_VZ_MODE_IS(GUEST))
+	if (!PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 	{
 		if (OSClockMonotonicns64(&sTimeCorr.ui64OSMonoTimeStamp) != PVRSRV_OK)
 		{
@@ -271,6 +296,7 @@ static void _RGXMakeTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode, RGXTIMECORR_E
 		}
 	}
 #endif
+
 	sTimeCorr.ui64CRTimeStamp = RGXReadHWTimerReg(psDevInfo);
 	sTimeCorr.ui64OSTimeStamp = RGXTimeCorrGetClockns64(psDeviceNode);
 	sTimeCorr.ui32CoreClockSpeed = _RGXGetEstimatedGPUClockSpeed(psDevInfo);
@@ -294,9 +320,17 @@ static void _RGXMakeTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode, RGXTIMECORR_E
 
 
 	/* Update the index of the current entry in the timer correlation array */
-	psGpuUtilFWCB->ui32TimeCorrSeqCount = ui32NewSeqCount;
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->ui32TimeCorrSeqCount, FLUSH);
+	psGpuUtilFW->ui32TimeCorrSeqCount = ui32NewSeqCount;
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->ui32TimeCorrSeqCount, FLUSH);
+
 
+	if (RGXTIMECORR_EVENT_POWER == eEvent && psDeviceNode->ui64LastDeviceOffTimestamp)
+	{
+		/* Capture effective timestamp offset on device power on */
+		psGpuUtilFW->i64DeviceTimestampOffset = psDeviceNode->ui64LastDeviceOffTimestamp - RGXReadHWTimerReg(psDevInfo) +
+								RGXTimeCorrDeltaOSNsToDeltaCR(psDeviceNode,
+									OSClockns64() - psDeviceNode->ui64LastDeviceOffHostTimestampNs);
+	}
 
 	PVR_DPF((PVR_DBG_MESSAGE,
 	         "Timer correlation data (post %s event): OS %" IMG_UINT64_FMTSPEC " ns, "
@@ -325,7 +359,7 @@ static void _RGXCheckTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode,
 #if !defined(NO_HARDWARE) && !defined(VIRTUAL_PLATFORM) && defined(DEBUG)
 #define SCALING_FACTOR (10)
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	RGXFWIF_GPU_UTIL_FWCB *psGpuUtilFWCB = psDevInfo->psRGXFWIfGpuUtilFWCb;
+	RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
 	IMG_UINT32 ui32Index;
 	RGXFWIF_TIME_CORR *psTimeCorr;
 	IMG_UINT64 ui64EstimatedTime, ui64CRTimeStamp, ui64OSTimeStamp;
@@ -333,10 +367,10 @@ static void _RGXCheckTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode,
 	IMG_INT64 i64Diff;
 	IMG_UINT32 ui32Ratio, ui32Remainder;
 
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->ui32TimeCorrSeqCount, INVALIDATE);
-	ui32Index = RGXFWIF_TIME_CORR_CURR_INDEX(psGpuUtilFWCB->ui32TimeCorrSeqCount);
-	RGXFwSharedMemCacheOpValue(psGpuUtilFWCB->sTimeCorr[ui32Index], INVALIDATE);
-	psTimeCorr = &psGpuUtilFWCB->sTimeCorr[ui32Index];
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->ui32TimeCorrSeqCount, INVALIDATE);
+	ui32Index = RGXFWIF_TIME_CORR_CURR_INDEX(psGpuUtilFW->ui32TimeCorrSeqCount);
+	RGXFwSharedMemCacheOpValue(psGpuUtilFW->sTimeCorr[ui32Index], INVALIDATE);
+	psTimeCorr = &psGpuUtilFW->sTimeCorr[ui32Index];
 
 	/*
 	 * The following reads must be done as close together as possible, because
@@ -630,7 +664,7 @@ void RGXTimeCorrBegin(IMG_HANDLE hDevHandle, RGXTIMECORR_EVENT eEvent)
 	PVRSRV_DEVICE_NODE  *psDeviceNode   = hDevHandle;
 	PVRSRV_RGXDEV_INFO  *psDevInfo      = psDeviceNode->pvDevice;
 	RGX_GPU_DVFS_TABLE  *psGpuDVFSTable = psDevInfo->psGpuDVFSTable;
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVNODE, psDeviceNode);
 
 	_RGXGPUFreqCalibrationPeriodStart(psDeviceNode, psGpuDVFSTable);
 	_RGXMakeTimeCorrData(psDeviceNode, eEvent);
@@ -641,7 +675,7 @@ void RGXTimeCorrEnd(IMG_HANDLE hDevHandle, RGXTIMECORR_EVENT eEvent)
 	PVRSRV_DEVICE_NODE  *psDeviceNode   = hDevHandle;
 	PVRSRV_RGXDEV_INFO  *psDevInfo      = psDeviceNode->pvDevice;
 	RGX_GPU_DVFS_TABLE  *psGpuDVFSTable = psDevInfo->psGpuDVFSTable;
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVNODE, psDeviceNode);
 
 	_RGXGPUFreqCalibrationPeriodStop(psDeviceNode, psGpuDVFSTable);
 
@@ -649,6 +683,15 @@ void RGXTimeCorrEnd(IMG_HANDLE hDevHandle, RGXTIMECORR_EVENT eEvent)
 	{
 		_RGXGPUFreqCalibrationCalculate(psDeviceNode, psGpuDVFSTable, eEvent);
 	}
+
+	if (RGXTIMECORR_EVENT_POWER == eEvent)
+	{
+		RGXFWIF_GPU_UTIL_FW *psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
+
+		/* Capture effective device power off timestamp */
+		psDeviceNode->ui64LastDeviceOffTimestamp = RGXReadHWTimerReg(psDevInfo) + psGpuUtilFW->i64DeviceTimestampOffset;
+		psDeviceNode->ui64LastDeviceOffHostTimestampNs = OSClockns64();
+	}
 }
 
 void RGXTimeCorrRestartPeriodic(IMG_HANDLE hDevHandle)
@@ -658,7 +701,7 @@ void RGXTimeCorrRestartPeriodic(IMG_HANDLE hDevHandle)
 	RGX_GPU_DVFS_TABLE     *psGpuDVFSTable = psDevInfo->psGpuDVFSTable;
 	IMG_UINT64             ui64TimeNow     = RGXTimeCorrGetClockus64(psDeviceNode);
 	PVRSRV_DEV_POWER_STATE ePowerState = PVRSRV_DEV_POWER_STATE_DEFAULT;
-	PVRSRV_VZ_RETN_IF_MODE(GUEST);
+	PVRSRV_VZ_RETN_IF_MODE(GUEST, DEVNODE, psDeviceNode);
 
 	if (psGpuDVFSTable == NULL)
 	{
@@ -713,15 +756,32 @@ PVRSRV_ERROR RGXTimeCorrSetClockSource(PVRSRV_DEVICE_NODE *psDeviceNode,
 }
 
 PVRSRV_ERROR
-PVRSRVRGXCurrentTime(CONNECTION_DATA    * psConnection,
-                     PVRSRV_DEVICE_NODE * psDeviceNode,
-                     IMG_UINT64         * pui64Time)
+PVRSRVRGXCurrentTime(CONNECTION_DATA    *psConnection,
+                     PVRSRV_DEVICE_NODE *psDeviceNode,
+                     IMG_UINT8           ui8TimestampType,
+                     IMG_UINT64         *pui64Time)
 {
+	RGX_QUERY_TIMESTAMP_TYPE eTimestampType = (RGX_QUERY_TIMESTAMP_TYPE)ui8TimestampType;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
 	PVR_UNREFERENCED_PARAMETER(psConnection);
 
-	*pui64Time = RGXTimeCorrGetClockns64(psDeviceNode);
+	switch (eTimestampType)
+	{
+		case RGX_QUERY_HOST_TIMESTAMP:
+		*pui64Time = RGXTimeCorrGetClockns64(psDeviceNode);
+		break;
 
-	return PVRSRV_OK;
+		case RGX_QUERY_DEVICE_TIMESTAMP:
+		*pui64Time = RGXTimeGetDeviceTimestampInTicks(psDeviceNode);
+		break;
+
+		default:
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+		break;
+	}
+
+	return eError;
 }
 
 /******************************************************************************
diff --git a/drivers/gpu/drm/img-rogue/rgxtimecorr.h b/drivers/gpu/drm/img-rogue/rgxtimecorr.h
index e1cfff9b7abc..9758e61909c8 100644
--- a/drivers/gpu/drm/img-rogue/rgxtimecorr.h
+++ b/drivers/gpu/drm/img-rogue/rgxtimecorr.h
@@ -48,6 +48,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "device.h"
 #include "osfunc.h"
 #include "connection_server.h"
+#include "rgxdevice.h"
 
 typedef enum
 {
@@ -117,6 +118,41 @@ static inline IMG_UINT64 RGXTimeCorrGetConversionFactor(IMG_UINT32 ui32ClockSpee
 	                     RGXFWIF_CONVERT_TO_KHZ(ui32ClockSpeed), &ui32Remainder);
 }
 
+/*!
+******************************************************************************
+
+ @Function    RGXTimeCorrDeltaOSNsToDeltaCR
+
+ @Description Convert OS timestamp difference in ns to device tick difference
+
+ @Input       psDeviceNode, ui64DeltaOSNs
+
+ @Return      0 on failure, deltaCR otherwise
+
+******************************************************************************/
+static inline IMG_UINT64 RGXTimeCorrDeltaOSNsToDeltaCR(PVRSRV_DEVICE_NODE *psDeviceNode, IMG_UINT64 ui64DeltaOSNs)
+{
+	RGXFWIF_GPU_UTIL_FW *psGpuUtilFW;
+	PVRSRV_RGXDEV_INFO *psDevInfo;
+	RGXFWIF_TIME_CORR *psTimeCorr;
+	IMG_UINT32 ui32Remainder;
+
+	PVR_ASSERT(psDeviceNode && psDeviceNode->pvDevice);
+	psDevInfo = psDeviceNode->pvDevice;
+	psGpuUtilFW = psDevInfo->psRGXFWIfGpuUtilFW;
+	PVR_ASSERT(psGpuUtilFW);
+	psTimeCorr = &psGpuUtilFW->sTimeCorr[RGXFWIF_TIME_CORR_CURR_INDEX(psGpuUtilFW->ui32TimeCorrSeqCount)];
+
+	if (psTimeCorr->ui64CRDeltaToOSDeltaKNs == 0)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: ui64CRDeltaToOSDeltaKNs is 0", __func__));
+		return 0;
+	}
+
+	return OSDivide64r64(ui64DeltaOSNs << RGXFWIF_CRDELTA_TO_OSDELTA_ACCURACY_SHIFT,
+	                     psTimeCorr->ui64CRDeltaToOSDeltaKNs, &ui32Remainder);
+}
+
 /*!
 ******************************************************************************
 
@@ -257,16 +293,24 @@ void RGXGetTimeCorrData(PVRSRV_DEVICE_NODE *psDeviceNode,
 							RGXFWIF_TIME_CORR *psTimeCorrs,
 							IMG_UINT32 ui32NumOut);
 
-/**************************************************************************/ /*!
-@Function       PVRSRVRGXCurrentTime
-@Description    Returns the current state of the device timer
-@Input          psDevData  Device data.
-@Out            pui64Time
-@Return         PVRSRV_OK on success.
-*/ /***************************************************************************/
-PVRSRV_ERROR
-PVRSRVRGXCurrentTime(CONNECTION_DATA    * psConnection,
-                     PVRSRV_DEVICE_NODE * psDeviceNode,
-                     IMG_UINT64         * pui64Time);
+/*!
+******************************************************************************
 
+ @Function    PVRSRVRGXCurrentTime
+
+ @Description Server-side implementation of RGXCurrentTime
+
+ @Input       psConnection     : Connection handle
+ @Input       psDeviceNode     : RGX Device Node
+ @Input       ui8TimestampType : Timestamp type
+ @Output      pui64Time        : Timestamp
+
+ @Return      PVRSRV_ERROR
+
+******************************************************************************/
+PVRSRV_ERROR
+PVRSRVRGXCurrentTime(CONNECTION_DATA    *psConnection,
+                     PVRSRV_DEVICE_NODE *psDeviceNode,
+                     IMG_UINT8           ui8TimestampType,
+                     IMG_UINT64         *pui64Time);
 #endif /* RGXTIMECORR_H */
diff --git a/drivers/gpu/drm/img-rogue/rgxtransfer.c b/drivers/gpu/drm/img-rogue/rgxtransfer.c
index e8b619d31a8e..360d6282e674 100644
--- a/drivers/gpu/drm/img-rogue/rgxtransfer.c
+++ b/drivers/gpu/drm/img-rogue/rgxtransfer.c
@@ -78,6 +78,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "rgxtimerquery.h"
 
+
 /* Enable this to dump the compiled list of UFOs prior to kick call */
 #define ENABLE_TQ_UFO_DUMP	0
 
@@ -143,14 +144,24 @@ static PVRSRV_ERROR _Create3DTransferContext(CONNECTION_DATA *psConnection,
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 	PVRSRV_ERROR eError;
 	IMG_UINT	ui3DRegISPStateStoreSize = 0;
-	IMG_UINT	uiNumISPStoreRegs = 1; /* default value 1 expected */
+	IMG_UINT	uiNumISPStoreRegs;
 	/*
 		Allocate device memory for the firmware GPU context suspend state.
 		Note: the FW reads/writes the state to memory by accessing the GPU register interface.
 	*/
 	PDUMPCOMMENT(psDeviceNode, "Allocate RGX firmware TQ/3D context suspend state");
 
-	if (!RGX_IS_FEATURE_SUPPORTED(psDevInfo, XE_MEMORY_HIERARCHY))
+	if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, XE_MEMORY_HIERARCHY))
+	{
+		uiNumISPStoreRegs = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode,
+				RGX_FEATURE_NUM_RASTER_PIPES_IDX);
+		if (RGX_IS_FEATURE_SUPPORTED(psDevInfo, GPU_MULTICORE_SUPPORT))
+		{
+			uiNumISPStoreRegs *= (1U + psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode,
+					RGX_FEATURE_XPU_MAX_SLAVES_IDX));
+		}
+	}
+	else
 	{
 		uiNumISPStoreRegs = psDeviceNode->pfnGetDeviceFeatureValue(psDeviceNode,
 													RGX_FEATURE_NUM_ISP_IPP_PIPES_IDX);
@@ -303,16 +314,10 @@ static PVRSRV_ERROR _Destroy2DTransferContext(RGX_SERVER_TQ_2D_DATA *ps2DData,
 											  ps2DData->psServerCommonContext,
 											  RGXFWIF_DM_2D,
 											  ui32PDumpFlags);
-	if (RGXIsErrorAndDeviceRecoverable(psDeviceNode, &eError))
-	{
-		return eError;
-	}
-	else if (eError != PVRSRV_OK)
-	{
-		PVR_LOG(("%s: Unexpected error from RGXFWRequestCommonContextCleanUp (%s)",
-				 __func__,
-				 PVRSRVGetErrorString(eError)));
-	}
+
+	RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDeviceNode,
+						   eError,
+						   RGXFWRequestCommonContextCleanUp);
 
 	/* ... it has so we can free its resources */
 	FWCommonContextFree(ps2DData->psServerCommonContext);
@@ -602,6 +607,7 @@ PVRSRV_ERROR PVRSRVRGXDestroyTransferContextKM(RGX_SERVER_TQ_CONTEXT *psTransfer
 /*
  * PVRSRVSubmitTQ3DKickKM
  */
+/* Old bridge call for backwards compatibility. */
 PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 									   IMG_UINT32				ui32PrepareCount,
 									   IMG_UINT32				*paui32ClientUpdateCount,
@@ -621,6 +627,49 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 									   IMG_UINT32				ui32SyncPMRCount,
 									   IMG_UINT32				*paui32SyncPMRFlags,
 									   PMR						**ppsSyncPMRs)
+{
+	return PVRSRVRGXSubmitTransfer3KM(psTransferContext,
+									  ui32PrepareCount,
+									  paui32ClientUpdateCount,
+									  papauiClientUpdateUFODevVarBlock,
+									  papaui32ClientUpdateSyncOffset,
+									  papaui32ClientUpdateValue,
+									  iCheckFence,
+									  i2DUpdateTimeline,
+									  pi2DUpdateFence,
+									  i3DUpdateTimeline,
+									  pi3DUpdateFence,
+									  szFenceName,
+									  PVRSRV_NO_FENCE,
+									  paui32FWCommandSize,
+									  papaui8FWCommand,
+									  pui32TQPrepareFlags,
+									  ui32ExtJobRef,
+									  ui32SyncPMRCount,
+									  paui32SyncPMRFlags,
+									  ppsSyncPMRs);
+}
+
+PVRSRV_ERROR PVRSRVRGXSubmitTransfer3KM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
+									   IMG_UINT32				ui32PrepareCount,
+									   IMG_UINT32				*paui32ClientUpdateCount,
+									   SYNC_PRIMITIVE_BLOCK		***papauiClientUpdateUFODevVarBlock,
+									   IMG_UINT32				**papaui32ClientUpdateSyncOffset,
+									   IMG_UINT32				**papaui32ClientUpdateValue,
+									   PVRSRV_FENCE				iCheckFence,
+									   PVRSRV_TIMELINE			i2DUpdateTimeline,
+									   PVRSRV_FENCE				*pi2DUpdateFence,
+									   PVRSRV_TIMELINE			i3DUpdateTimeline,
+									   PVRSRV_FENCE				*pi3DUpdateFence,
+									   IMG_CHAR					szFenceName[32],
+									   PVRSRV_FENCE				iExportFenceToSignal,
+									   IMG_UINT32				*paui32FWCommandSize,
+									   IMG_UINT8				**papaui8FWCommand,
+									   IMG_UINT32				*pui32TQPrepareFlags,
+									   IMG_UINT32				ui32ExtJobRef,
+									   IMG_UINT32				ui32SyncPMRCount,
+									   IMG_UINT32				*paui32SyncPMRFlags,
+									   PMR						**ppsSyncPMRs)
 {
 	PVRSRV_DEVICE_NODE *psDeviceNode = psTransferContext->psDeviceNode;
 	PVRSRV_RGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
@@ -628,13 +677,13 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 #if defined(RGX_FEATURE_TLA_BIT_MASK)
 	RGX_CCB_CMD_HELPER_DATA *pas2DCmdHelper;
 #endif
-	IMG_UINT32 ui323DCmdCount = 0;
-	IMG_UINT32 ui323DCmdLast = 0;
-	IMG_UINT32 ui323DCmdOffset = 0;
+	IMG_UINT32                ui323DCmdCount = 0;
+	IMG_UINT32                ui323DCmdLast = 0;
+	__maybe_unused IMG_UINT32 ui323DCmdOffset = 0;
 #if defined(RGX_FEATURE_TLA_BIT_MASK)
-	IMG_UINT32 ui322DCmdCount = 0;
-	IMG_UINT32 ui322DCmdLast = 0;
-	IMG_UINT32 ui322DCmdOffset = 0;
+	IMG_UINT32                ui322DCmdCount = 0;
+	IMG_UINT32                ui322DCmdLast = 0;
+	__maybe_unused IMG_UINT32 ui322DCmdOffset = 0;
 #endif
 	IMG_UINT32 ui32PDumpFlags = PDUMP_FLAGS_NONE;
 	IMG_UINT32 i;
@@ -645,11 +694,14 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 	IMG_UINT64 ui3DUpdateFenceUID = 0;
 
 	PSYNC_CHECKPOINT ps3DUpdateSyncCheckpoint = NULL;
+	PSYNC_CHECKPOINT ps3DExportFenceSyncCheckpoint = NULL;
+	PSYNC_CHECKPOINT *ppsExportFenceSyncCheckpoint = NULL;
 	PSYNC_CHECKPOINT *apsFenceSyncCheckpoints = NULL;
 	IMG_UINT32 ui32FenceSyncCheckpointCount = 0;
 	IMG_UINT32 *pui323DIntAllocatedUpdateValues = NULL;
 #if defined(RGX_FEATURE_TLA_BIT_MASK)
 	PSYNC_CHECKPOINT ps2DUpdateSyncCheckpoint = NULL;
+	PSYNC_CHECKPOINT ps2DExportFenceSyncCheckpoint = NULL;
 	IMG_UINT32 *pui322DIntAllocatedUpdateValues = NULL;
 	PVRSRV_CLIENT_SYNC_PRIM *ps2DFenceTimelineUpdateSync = NULL;
 	IMG_UINT32 ui322DFenceTimelineUpdateValue = 0;
@@ -735,7 +787,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 	}
 
 	/* Ensure the string is null-terminated (Required for safety) */
-	szFenceName[31] = '\0';
+	szFenceName[PVRSRV_SYNC_NAME_LENGTH-1] = '\0';
 
 	if ((ui32PrepareCount == 0) || (ui32PrepareCount > TQ_MAX_PREPARES_PER_SUBMIT))
 	{
@@ -853,6 +905,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		IMG_UINT32 **ppui32IntAllocatedUpdateValues = NULL;
 		IMG_BOOL bCheckFence = IMG_FALSE;
 		IMG_BOOL bUpdateFence = IMG_FALSE;
+		IMG_BOOL bExportFence = IMG_FALSE;
 		IMG_UINT64 *puiUpdateFenceUID = NULL;
 
 		IMG_BOOL bCCBStateOpen = IMG_FALSE;
@@ -870,6 +923,8 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 			bCheckFence = ui323DCmdCount == 1;
 			bUpdateFence = ui323DCmdCount == ui323DCmdLast
 				&& i3DUpdateTimeline != PVRSRV_NO_TIMELINE;
+			bExportFence = ui323DCmdCount == ui323DCmdLast
+				&& iExportFenceToSignal != PVRSRV_NO_FENCE;
 
 			if (bUpdateFence)
 			{
@@ -882,6 +937,11 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 				ppui32IntAllocatedUpdateValues = &pui323DIntAllocatedUpdateValues;
 				puiUpdateFenceUID = &ui3DUpdateFenceUID;
 			}
+
+			if (bExportFence)
+			{
+				ppsExportFenceSyncCheckpoint = &ps3DExportFenceSyncCheckpoint;
+			}
 		}
 		else
 #if defined(RGX_FEATURE_TLA_BIT_MASK)
@@ -899,6 +959,8 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 			bCheckFence = ui322DCmdCount == 1;
 			bUpdateFence = ui322DCmdCount == ui322DCmdLast
 				&& i2DUpdateTimeline != PVRSRV_NO_TIMELINE;
+			bExportFence = ui322DCmdCount == ui322DCmdLast
+				&& iExportFenceToSignal != PVRSRV_NO_FENCE;
 
 			if (bUpdateFence)
 			{
@@ -911,6 +973,11 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 				ppui32IntAllocatedUpdateValues = &pui322DIntAllocatedUpdateValues;
 				puiUpdateFenceUID = &ui2DUpdateFenceUID;
 			}
+
+			if (bExportFence)
+			{
+				ppsExportFenceSyncCheckpoint = &ps2DExportFenceSyncCheckpoint;
+			}
 		}
 		else
 #endif
@@ -1061,6 +1128,47 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 
 			CHKPT_DBG((PVR_DBG_ERROR, "%s: returned from SyncCheckpointCreateFence (piUpdateFence=%p)", __func__, piUpdateFence));
 
+			/* Resolve the iExportFenceToSignal (if required) */
+			if (bExportFence)
+			{
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: SyncCheckpointResolveExportFence(iExportFenceToSignal=%d), ui32FenceSyncCheckpointCount=%d", __func__, iExportFenceToSignal, ui32FenceSyncCheckpointCount));
+				eError = SyncCheckpointResolveExportFence(iExportFenceToSignal,
+														  psDeviceNode->hSyncCheckpointContext,
+														  ppsExportFenceSyncCheckpoint,
+														  ui32PDumpFlags);
+				if (eError != PVRSRV_OK)
+				{
+					CHKPT_DBG((PVR_DBG_ERROR, "%s: ...returned error (%s) psExportFenceSyncCheckpoint=<%p>", __func__, PVRSRVGetErrorString(eError), *ppsExportFenceSyncCheckpoint));
+					goto fail_prepare_loop;
+				}
+
+				/* Check that the export fence was not also included as part of the
+				 * check fence (which is an error and would lead to a stalled kick).
+				 */
+				if (ui32FenceSyncCheckpointCount > 0)
+				{
+					CHKPT_DBG((PVR_DBG_ERROR, "%s:   Checking export fence is not part of check fence...", __func__));
+					CHKPT_DBG((PVR_DBG_ERROR, "%s:   ui32FenceSyncCheckpointCount=%d",
+							   __func__, ui32FenceSyncCheckpointCount));
+					if (ui32FenceSyncCheckpointCount > 0)
+					{
+						IMG_UINT32 iii;
+
+						for (iii=0; iii<ui32FenceSyncCheckpointCount; iii++)
+						{
+							CHKPT_DBG((PVR_DBG_ERROR, "%s: apsFenceSyncCheckpoints[%d]=<%p>, FWAddr=0x%x", __func__, iii, apsFenceSyncCheckpoints[iii], SyncCheckpointGetFirmwareAddr(apsFenceSyncCheckpoints[iii])));
+							if (apsFenceSyncCheckpoints[iii] == *ppsExportFenceSyncCheckpoint)
+							{
+								CHKPT_DBG((PVR_DBG_ERROR, "%s: ERROR psExportFenceSyncCheckpoint=<%p>", __func__, *ppsExportFenceSyncCheckpoint));
+								eError = PVRSRV_ERROR_INVALID_PARAMS;
+								PVR_DPF((PVR_DBG_ERROR, " %s - iCheckFence includes iExportFenceToSignal", PVRSRVGetErrorString(eError)));
+								goto fail_prepare_loop;
+							}
+						}
+					}
+				}
+			}
+
 			/* Append the sync prim update for the timeline (if required) */
 			if (*ppsFenceTimelineUpdateSync)
 			{
@@ -1180,6 +1288,35 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 			}
 #endif
 		}
+
+		if (bExportFence && *ppsExportFenceSyncCheckpoint)
+		{
+			/* Append the update (from export fence) */
+			CHKPT_DBG((PVR_DBG_ERROR, "%s:   Append 1 sync checkpoint to Transfer Update (psSyncAddrListUpdate=<%p>, psExportFenceSyncCheckpoint=<%p>)...", __func__, (void*)psSyncAddrListUpdate , (void*)*ppsExportFenceSyncCheckpoint));
+			SyncAddrListAppendCheckpoints(psSyncAddrListUpdate,
+										  1,
+										  ppsExportFenceSyncCheckpoint);
+			if (!pauiIntUpdateUFOAddress)
+			{
+				pauiIntUpdateUFOAddress = psSyncAddrListUpdate->pasFWAddrs;
+			}
+			ui32IntClientUpdateCount++;
+#if defined(CMP_CHECKPOINT_DEBUG)
+			if (ui32IntClientUpdateCount > 0)
+			{
+				IMG_UINT32 iii;
+				IMG_UINT32 *pui32Tmp = (IMG_UINT32*)pauiIntUpdateUFOAddress;
+
+				CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress=<%p>, pui32Tmp=<%p>, ui32IntClientUpdateCount=%u", __func__, (void*)pauiIntUpdateUFOAddress, (void*)pui32Tmp, ui32IntClientUpdateCount));
+				for (iii=0; iii<ui32IntClientUpdateCount; iii++)
+				{
+					CHKPT_DBG((PVR_DBG_ERROR, "%s: pauiIntUpdateUFOAddress[%d](<%p>) = 0x%x", __func__, iii, (void*)pui32Tmp, *pui32Tmp));
+					pui32Tmp++;
+				}
+			}
+#endif
+		}
+
 		CHKPT_DBG((PVR_DBG_ERROR, "%s:   (after pvr_sync) ui32IntClientFenceCount=%d, ui32IntClientUpdateCount=%d", __func__, ui32IntClientFenceCount, ui32IntClientUpdateCount));
 
 #if (ENABLE_TQ_UFO_DUMP == 1)
@@ -1243,6 +1380,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		                       pszCommandName,
 		                       bCCBStateOpen,
 		                       psCmdHelper);
+
 	}
 
 	/*
@@ -1359,7 +1497,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		                  NO_DEADLINE,
 		                  NO_CYCEST);
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			eError2 = RGXScheduleCommandWithoutPowerLock(psDevInfo,
 										RGXFWIF_DM_3D,
@@ -1370,7 +1508,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		if (eError2 != PVRSRV_OK)
 		{
@@ -1429,7 +1567,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		                  NO_DEADLINE,
 		                  NO_CYCEST);
 
-		LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+		LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 		{
 			eError2 = RGXScheduleCommandWithoutPowerLock(psDevInfo,
 										RGXFWIF_DM_2D,
@@ -1440,7 +1578,7 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 				break;
 			}
 			OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-		} END_LOOP_UNTIL_TIMEOUT();
+		} END_LOOP_UNTIL_TIMEOUT_US();
 
 		if (eError2 != PVRSRV_OK)
 		{
@@ -1491,6 +1629,16 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		SyncPrimNoHwUpdate(ps3DFenceTimelineUpdateSync, ui323DFenceTimelineUpdateValue);
 	}
 	SyncCheckpointNoHWUpdateTimelines(NULL);
+
+	if (ppsExportFenceSyncCheckpoint && *ppsExportFenceSyncCheckpoint)
+	{
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   Signalling NOHW sync checkpoint<%p>, ID:%d, FwAddr=0x%x", __func__,
+		           (void*)*ppsExportFenceSyncCheckpoint, SyncCheckpointGetId(*ppsExportFenceSyncCheckpoint),
+		           SyncCheckpointGetFirmwareAddr(*ppsExportFenceSyncCheckpoint)));
+		SyncCheckpointSignalNoHW(*ppsExportFenceSyncCheckpoint);
+		CHKPT_DBG((PVR_DBG_ERROR, "%s:   SyncCheckpointNoHWSignalExportFence(iExportFenceToSignal=%d)", __func__, iExportFenceToSignal));
+		SyncCheckpointNoHWSignalExportFence(iExportFenceToSignal);
+	}
 #endif /* defined(NO_HARDWARE) */
 
 #if defined(SUPPORT_BUFFER_SYNC)
@@ -1598,6 +1746,10 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 		OSFreeMem(pui323DIntAllocatedUpdateValues);
 		pui323DIntAllocatedUpdateValues = NULL;
 	}
+	if (ppsExportFenceSyncCheckpoint && *ppsExportFenceSyncCheckpoint)
+	{
+		SyncCheckpointRollbackExportFence(iExportFenceToSignal);
+	}
 #if defined(RGX_FEATURE_TLA_BIT_MASK)
 	if (i2DUpdateFence != PVRSRV_NO_FENCE)
 	{
@@ -1819,10 +1971,9 @@ IMG_UINT32 CheckForStalledClientTransferCtxt(PVRSRV_RGXDEV_INFO *psDevInfo)
 PVRSRV_ERROR PVRSRVRGXTQGetSharedMemoryKM(
 	CONNECTION_DATA           * psConnection,
 	PVRSRV_DEVICE_NODE        * psDeviceNode,
-	PMR                      ** ppsCLIPMRMem,
-	PMR                      ** ppsUSCPMRMem)
+	PMR                      ** ppsCLIPMRMem)
 {
-	PVRSRVTQAcquireShaders(psDeviceNode, ppsCLIPMRMem, ppsUSCPMRMem);
+	PVRSRVTQAcquireShaders(psDeviceNode, ppsCLIPMRMem);
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/rgxtransfer.h b/drivers/gpu/drm/img-rogue/rgxtransfer.h
index 8bd0b76c75d7..3cdc454d3de0 100644
--- a/drivers/gpu/drm/img-rogue/rgxtransfer.h
+++ b/drivers/gpu/drm/img-rogue/rgxtransfer.h
@@ -129,6 +129,27 @@ PVRSRV_ERROR PVRSRVRGXSubmitTransferKM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
 									IMG_UINT32				*paui32SyncPMRFlags,
 									PMR						**ppsSyncPMRs);
 
+PVRSRV_ERROR PVRSRVRGXSubmitTransfer3KM(RGX_SERVER_TQ_CONTEXT	*psTransferContext,
+									IMG_UINT32				ui32PrepareCount,
+									IMG_UINT32				*paui32ClientUpdateCount,
+									SYNC_PRIMITIVE_BLOCK		***papauiClientUpdateUFODevVarBlock,
+									IMG_UINT32				**papaui32ClientUpdateSyncOffset,
+									IMG_UINT32				**papaui32ClientUpdateValue,
+									PVRSRV_FENCE			iCheckFence,
+									PVRSRV_TIMELINE			i2DUpdateTimeline,
+									PVRSRV_FENCE			*pi2DUpdateFence,
+									PVRSRV_TIMELINE			i3DUpdateTimeline,
+									PVRSRV_FENCE			*pi3DUpdateFence,
+									IMG_CHAR				szFenceName[32],
+									PVRSRV_FENCE			iExportFenceToSignal,
+									IMG_UINT32				*paui32FWCommandSize,
+									IMG_UINT8				**papaui8FWCommand,
+									IMG_UINT32				*pui32TQPrepareFlags,
+									IMG_UINT32				ui32ExtJobRef,
+									IMG_UINT32				ui32SyncPMRCount,
+									IMG_UINT32				*paui32SyncPMRFlags,
+									PMR						**ppsSyncPMRs);
+
 PVRSRV_ERROR PVRSRVRGXSetTransferContextPriorityKM(CONNECTION_DATA *psConnection,
                                                    PVRSRV_DEVICE_NODE * psDevNode,
 												   RGX_SERVER_TQ_CONTEXT *psTransferContext,
@@ -151,8 +172,7 @@ IMG_UINT32 CheckForStalledClientTransferCtxt(PVRSRV_RGXDEV_INFO *psDevInfo);
 PVRSRV_ERROR PVRSRVRGXTQGetSharedMemoryKM(
 	CONNECTION_DATA           * psConnection,
 	PVRSRV_DEVICE_NODE        * psDeviceNode,
-	PMR                      ** ppsCLIPMRMem,
-	PMR                      ** ppsUSCPMRMem);
+	PMR                      ** ppsCLIPMRMem);
 
 PVRSRV_ERROR PVRSRVRGXTQReleaseSharedMemoryKM(PMR * psUSCPMRMem);
 
diff --git a/drivers/gpu/drm/img-rogue/rgxtransfer_shader.h b/drivers/gpu/drm/img-rogue/rgxtransfer_shader.h
index b7b3a645e453..f261d2d04075 100644
--- a/drivers/gpu/drm/img-rogue/rgxtransfer_shader.h
+++ b/drivers/gpu/drm/img-rogue/rgxtransfer_shader.h
@@ -55,15 +55,13 @@ typedef struct _RGX_SHADER_HEADER_
 	IMG_UINT32 ui32Version;
 	IMG_UINT32 ui32NumFragment;
 	IMG_UINT32 ui32SizeFragment;
-	IMG_UINT32 ui32NumTDMFragment;
-	IMG_UINT32 ui32SizeTDMFragment;
 	IMG_UINT32 ui32SizeClientMem;
 } RGX_SHADER_HEADER;
 
 /* TQ shaders version is used to check compatibility between the
    binary TQ shaders file and the DDK. This number should be incremented
    if a change to the TQ shader factory breaks compatibility. */
-#define RGX_TQ_SHADERS_VERSION 1U
+#define RGX_TQ_SHADERS_VERSION 2U
 
 #define RGX_TQ_SHADERS_VERSION_PACK \
 	(((RGX_TQ_SHADERS_VERSION & 0xFFU) << 16) | ((PVRVERSION_MAJ & 0xFFU) << 8) | ((PVRVERSION_MIN & 0xFFU) << 0))
diff --git a/drivers/gpu/drm/img-rogue/rgxutils.c b/drivers/gpu/drm/img-rogue/rgxutils.c
index 7b5bcc804f85..4ffc08c07add 100644
--- a/drivers/gpu/drm/img-rogue/rgxutils.c
+++ b/drivers/gpu/drm/img-rogue/rgxutils.c
@@ -51,7 +51,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv.h"
 #include "sync_internal.h"
 #include "rgxfwutils.h"
-
+#include "rgxlayer.h"
 
 PVRSRV_ERROR RGXQueryAPMState(const PVRSRV_DEVICE_NODE *psDeviceNode,
 	const void *pvPrivateData,
@@ -216,7 +216,7 @@ inline const char * RGXStringifyKickTypeDM(RGX_KICK_TYPE_DM eKickTypeDM)
 	}
 }
 
-PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags)
+PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags, PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PHYS_HEAP_POLICY ui32Policy;
 
@@ -231,13 +231,13 @@ PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags)
 			 PHYS_HEAP_USAGE_FW_CODE      |
 			 PHYS_HEAP_USAGE_FW_PRIV_DATA)))
 		{
-			if (PVRSRV_VZ_MODE_IS(GUEST))
+			if (PVRSRV_VZ_MODE_IS(GUEST, DEVNODE, psDeviceNode))
 			{
-				/* Guest Firmware heaps are always premepped */
+				/* Guest Firmware heaps are always premapped */
 				ui32Policy = PHYS_HEAP_POLICY_DEFAULT;
 			}
 #if defined(RGX_PREMAP_FW_HEAPS)
-			else if (PVRSRV_VZ_MODE_IS(HOST))
+			else if (PVRSRV_VZ_MODE_IS(HOST, DEVNODE, psDeviceNode))
 			{
 				/* All Firmware heaps are premapped under AutoVz*/
 				ui32Policy = PHYS_HEAP_POLICY_DEFAULT;
diff --git a/drivers/gpu/drm/img-rogue/rgxutils.h b/drivers/gpu/drm/img-rogue/rgxutils.h
index 67d4bb840a6a..be6e586e2279 100644
--- a/drivers/gpu/drm/img-rogue/rgxutils.h
+++ b/drivers/gpu/drm/img-rogue/rgxutils.h
@@ -187,11 +187,12 @@ const char* RGXStringifyKickTypeDM(RGX_KICK_TYPE_DM eKickTypeDM);
                 usage flags
 
 @Input          ui32UsageFlags Flags specifying a heap's intended use
+@Input          psDeviceNode The device node.
 
 @Return         PHYS_HEAP_POLICY The recommended LMA policy
 
 */ /**************************************************************************/
-PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags);
+PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags, PVRSRV_DEVICE_NODE *psDeviceNode);
 
 #define RGX_STRINGIFY_KICK_TYPE_DM_IF_SET(bitmask, eKickTypeDM) bitmask & eKickTypeDM ? RGXStringifyKickTypeDM(eKickTypeDM) : ""
 
@@ -206,6 +207,30 @@ PHYS_HEAP_POLICY RGXPhysHeapGetLMAPolicy(PHYS_HEAP_USAGE_FLAGS ui32UsageFlags);
 */ /**************************************************************************/
 IMG_BOOL RGXIsErrorAndDeviceRecoverable(PVRSRV_DEVICE_NODE *psDeviceNode, PVRSRV_ERROR *peError);
 
+/*
+ * To avoid repeated calls and avoid double frees, the error value is set to PVRSRV_OK
+ * if RGXIsErrorAndDeviceRecoverable is false.
+ */
+#define RGX_RETURN_IF_ERROR_AND_DEVICE_RECOVERABLE(psDeviceNode, eError, cleanupFunc) \
+	do \
+	{ \
+		if (RGXIsErrorAndDeviceRecoverable(psDeviceNode, &eError)) \
+		{ \
+			return eError; \
+		} \
+		else if (eError != PVRSRV_OK) \
+		{ \
+			PVR_LOG(("%s: Unexpected error from " #cleanupFunc "(%s)", \
+					__func__, \
+					PVRSRVGetErrorString(eError))); \
+			/* Device is dead. \
+			 * Change error type to make callers destroy the resource handle. \
+			 * This is to prevent repeated calls to this function. \
+			 */ \
+			eError = PVRSRV_OK; \
+		} \
+	} while (false)
+
 /******************************************************************************
  End of file (rgxutils.h)
 ******************************************************************************/
diff --git a/drivers/gpu/drm/img-rogue/ri_server.c b/drivers/gpu/drm/img-rogue/ri_server.c
index 82a26cb69d27..eec752d26017 100644
--- a/drivers/gpu/drm/img-rogue/ri_server.c
+++ b/drivers/gpu/drm/img-rogue/ri_server.c
@@ -91,15 +91,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 #define _RI_INITIAL_HASH_TABLE_SIZE	64
 
-/*
- * Values written to the 'valid' field of RI structures when created and
- * cleared prior to being destroyed. The code can then check this value
- * before accessing the provided pointer contents as a valid RI structure.
- */
-#define _VALID_RI_LIST_ENTRY	0x66bccb66
-#define _VALID_RI_SUBLIST_ENTRY	0x77cddc77
-#define _INVALID				0x00000000
-
 /*
  * If this define is set to 1, details of the linked lists (addresses,
  * prev/next ptrs, etc) are also output when function RIDumpList() is called.
@@ -113,21 +104,25 @@ typedef IMG_UINT64 _RI_BASE_T;
 /* No +1 in SIZE macros since sizeof includes \0 byte in size */
 
 #define RI_PROC_BUF_SIZE    16
+#define RI_ANNO_BUF_SIZE    80
+#define RI_ANNO_FRMT_SIZE (sizeof(RI_ANNO_FRMT))
 
 #define RI_DEV_ID_BUF_SIZE  4
 
-#define RI_MEMDESC_SUM_FRMT     "PID %d %s MEMDESCs Alloc'd:0x%010" IMG_UINT64_FMTSPECx " (%" IMG_UINT64_FMTSPEC "K) + "\
+#define RI_MEMDESC_SUM_FRMT     "PID:%d %s MEMDESCs Alloc'd:0x%010" IMG_UINT64_FMTSPECx " (%" IMG_UINT64_FMTSPEC "K) + "\
                                                   "Imported:0x%010" IMG_UINT64_FMTSPECx " (%" IMG_UINT64_FMTSPEC "K) = "\
                                                      "Total:0x%010" IMG_UINT64_FMTSPECx " (%" IMG_UINT64_FMTSPEC "K)\n"
 #define RI_MEMDESC_SUM_BUF_SIZE (sizeof(RI_MEMDESC_SUM_FRMT)+5+RI_PROC_BUF_SIZE+30+60)
 
 
-#define RI_PMR_SUM_FRMT     "PID %d %s PMRs Alloc'd:0x%010" IMG_UINT64_FMTSPECx ", %" IMG_UINT64_FMTSPEC "K  "\
+#define RI_PMR_SUM_FRMT     "PID:%d %s PMRs Alloc'd:0x%010" IMG_UINT64_FMTSPECx ", %" IMG_UINT64_FMTSPEC "K  "\
                                         "[Physical: 0x%010" IMG_UINT64_FMTSPECx ", %" IMG_UINT64_FMTSPEC "K]\n"
 #define RI_PMR_SUM_BUF_SIZE (sizeof(RI_PMR_SUM_FRMT)+(20+40))
 
-#define RI_PMR_ENTRY_FRMT      "%%sPID:%%-5d DEV:%%s <%%p>\t%%-%ds\t%%-%ds\t0x%%010" IMG_UINT64_FMTSPECx "\t[0x%%010" IMG_UINT64_FMTSPECx "]\t%%c"
-#define RI_PMR_ENTRY_BUF_SIZE  (sizeof(RI_PMR_ENTRY_FRMT)+(3+5+RI_DEV_ID_BUF_SIZE+16+(PVR_ANNOTATION_MAX_LEN/2)+PHYS_HEAP_NAME_SIZE+10+10))
+#define RI_FREED_BY_DRIVER "{Freed by KM}"
+
+#define RI_PMR_ENTRY_FRMT      "%%sPID:%%-5d DEV:%%s <%%p>\t%%-%ds\t%%-%ds\t0x%%010" IMG_UINT64_FMTSPECx "\t[0x%%010" IMG_UINT64_FMTSPECx "]\t%%s%%c"
+#define RI_PMR_ENTRY_BUF_SIZE  (sizeof(RI_PMR_ENTRY_FRMT)+(3+5+RI_DEV_ID_BUF_SIZE+16+(PVR_ANNOTATION_MAX_LEN/2)+PHYS_HEAP_NAME_SIZE+10+10)+ sizeof(RI_FREED_BY_DRIVER))
 #define RI_PMR_ENTRY_FRMT_SIZE (sizeof(RI_PMR_ENTRY_FRMT))
 
 /* Use %5d rather than %d so the output aligns in server/kernel.log, debugFS sees extra spaces */
@@ -141,9 +136,9 @@ static IMG_CHAR g_szSysAllocImport[RI_SYS_ALLOC_IMPORT_FRMT_SIZE];
 #define RI_MEMDESC_ENTRY_IMPORT_FRMT     "{Import from PID %d}"
 #define RI_MEMDESC_ENTRY_IMPORT_BUF_SIZE (sizeof(RI_MEMDESC_ENTRY_IMPORT_FRMT)+5)
 
-#define RI_MEMDESC_ENTRY_FRMT      "%%sPID:%%-5d DEV:%%s 0x%%010" IMG_UINT64_FMTSPECx "\t%%-%ds %%s\t0x%%010" IMG_UINT64_FMTSPECx "\t<%%p> %%s%%s%%c"
+#define RI_MEMDESC_ENTRY_FRMT      "%%sPID:%%-5d DEV:%%s 0x%%010" IMG_UINT64_FMTSPECx "\t%%-%ds %%s\t0x%%010" IMG_UINT64_FMTSPECx "\t<%%p> %%s%%s %%s%%c"
 #define RI_MEMDESC_ENTRY_BUF_SIZE  (sizeof(RI_MEMDESC_ENTRY_FRMT)+(3+5+RI_DEV_ID_BUF_SIZE+10+PVR_ANNOTATION_MAX_LEN+RI_MEMDESC_ENTRY_PROC_BUF_SIZE+16+\
-                                               RI_MEMDESC_ENTRY_IMPORT_BUF_SIZE+RI_SYS_ALLOC_IMPORT_FRMT_SIZE))
+                                               RI_MEMDESC_ENTRY_IMPORT_BUF_SIZE+RI_SYS_ALLOC_IMPORT_FRMT_SIZE)) + sizeof(RI_FREED_BY_DRIVER)
 #define RI_MEMDESC_ENTRY_FRMT_SIZE (sizeof(RI_MEMDESC_ENTRY_FRMT))
 
 
@@ -152,25 +147,60 @@ static IMG_CHAR g_szSysAllocImport[RI_SYS_ALLOC_IMPORT_FRMT_SIZE];
                                   MAX(RI_MEMDESC_SUM_BUF_SIZE,\
                                       RI_PMR_SUM_BUF_SIZE))))
 
+typedef struct _RI_PMR_INFO_
+{
+	uintptr_t uiAddr;
+	PHYS_HEAP *psHeap;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	size_t uiLogicalSize;
+	size_t uiPhysicalSize;
+	IMG_CHAR *pszAnnotation;
+} RI_PMR_INFO;
+
+
+#define RI_DEVID_MASK						0xFF /* Highest value is PVRSRV_HOST_DEVICE_ID[255] */
+
+/* Flags for Memdescs(RI_SUBLIST) */
+#define RI_IMPORT_FLAG						(8)  /* Indicates the PMR is an import */
+#define RI_SUBALLOC_FLAG					(9)  /* Indicates the PMR is sub-allocatable */
+
+/* Flags for PMRs(RI_LIST) */
+#define RI_SYSALLOC_PMR_FLAG				(10) /* Indicates the PMR belongs to the 'system' process */
+#define RI_PMR_PHYS_COUNTED_BY_DEBUGFS_FLAG	(11) /* Indicates size counted prior, to prevent double reads */
+
+/* Shared flags */
+#define RI_RACC_FLAG						(12) /* Freed by Driver after disconnect */
+#define RI_VALID_FLAG						(13) /* Valid on creation, Only invalid after delete */
+#define RI_HAS_PMR_INFO						(14) /* Entry has RI_PMR_INFO object rather than reference to a PMR */
+
+#define GET_DEVICE_ID(entry)			((entry)->ui16Flags & RI_DEVID_MASK)
+#define SET_DEVICE_ID(entry,id)			BITMASK_SET((entry)->ui16Flags, (id & RI_DEVID_MASK))
+#define IS_HOST_DEVICE(entry)			(((entry)->ui16Flags & RI_DEVID_MASK) == PVRSRV_HOST_DEVICE_ID)
 
+#define IS_IMPORT(entry)				BIT_ISSET((entry)->ui16Flags, RI_IMPORT_FLAG)
+#define IS_SUBALLOC(entry)				BIT_ISSET((entry)->ui16Flags, RI_SUBALLOC_FLAG)
 
+#define IS_SYSPMR(entry)				BIT_ISSET((entry)->ui16Flags, RI_SYSALLOC_PMR_FLAG)
+#define IS_COUNTED_BY_DEBUGFS(entry)	BIT_ISSET((entry)->ui16Flags, RI_PMR_PHYS_COUNTED_BY_DEBUGFS_FLAG)
+
+#define IS_RACC(entry)					BIT_ISSET((entry)->ui16Flags, RI_RACC_FLAG)
+#define IS_VALID(entry)					BIT_ISSET((entry)->ui16Flags, RI_VALID_FLAG)
+#define HAS_PMR_INFO(entry)				BIT_ISSET((entry)->ui16Flags, RI_HAS_PMR_INFO)
 
 /* Structure used to make linked sublist of memory allocations (MEMDESC) */
 struct _RI_SUBLIST_ENTRY_
 {
 	DLLIST_NODE				sListNode;
+	DLLIST_NODE				sProcListNode;
+	CONNECTION_DATA			*psConnection;
 	struct _RI_LIST_ENTRY_	*psRI;
-	IMG_UINT32				valid;
-	IMG_BOOL				bIsImport;
-	IMG_BOOL				bIsSuballoc;
-	IMG_PID					pid;
-	IMG_UINT32				ui32DevID;
-	IMG_CHAR				ai8ProcName[RI_PROC_BUF_SIZE];
+	IMG_CHAR				*pszTextB; /* Annotation+(NUL)+ProcName+(NUL) */
 	IMG_DEV_VIRTADDR		sVAddr;
 	IMG_UINT64				ui64Offset;
 	IMG_UINT64				ui64Size;
-	IMG_CHAR				ai8TextB[DEVMEM_ANNOTATION_MAX_LEN+1];
-	DLLIST_NODE				sProcListNode;
+	IMG_PID					pid;
+	IMG_UINT16				ui16TextBLength; /* Total length of Annotation+(NUL)+ProcName+(NUL) */
+	IMG_UINT16				ui16Flags; /* Refer to above */
 };
 
 /*
@@ -180,26 +210,56 @@ struct _RI_SUBLIST_ENTRY_
 struct _RI_LIST_ENTRY_
 {
 	DLLIST_NODE				sListNode;
-	DLLIST_NODE				sSysAllocListNode;
 	DLLIST_NODE				sSubListFirst;
-	IMG_UINT32				valid;
-	PMR						*psPMR;
+	union {
+		PMR *psPMR;
+		RI_PMR_INFO *psPmrInfo;
+	} pmr_info;
 	IMG_PID					pid;
-	IMG_UINT32				ui32DevID;
-	IMG_CHAR				ai8ProcName[RI_PROC_BUF_SIZE];
 	IMG_UINT16				ui16SubListCount;
-	IMG_UINT16				ui16MaxSubListCount;
-	IMG_UINT32				ui32RIPMRFlags; /* Flags used to indicate the type of allocation */
-	IMG_UINT32				ui32Flags; /* Flags used to indicate if PMR appears in ri debugfs output */
+	IMG_UINT16				ui16Flags; /* Refer to above */
 };
 
+#define GET_ADDR(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (void*)(entry)->pmr_info.psPmrInfo->uiAddr \
+			: (void*)(entry)->pmr_info.psPMR \
+	)
+#define GET_HEAP(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (entry)->pmr_info.psPmrInfo->psHeap \
+			: PMR_PhysHeap((entry)->pmr_info.psPMR) \
+	)
+#define GET_DEVNODE(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (entry)->pmr_info.psPmrInfo->psDeviceNode \
+			: (PVRSRV_DEVICE_NODE *) PMR_DeviceNode((entry)->pmr_info.psPMR) \
+	)
+#define GET_LOGICAL_SIZE(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (entry)->pmr_info.psPmrInfo->uiLogicalSize \
+			: PMR_LogicalSize((entry)->pmr_info.psPMR) \
+	)
+#define GET_PHYSICAL_SIZE(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (entry)->pmr_info.psPmrInfo->uiPhysicalSize \
+			: PMR_PhysicalSize((entry)->pmr_info.psPMR) \
+	)
+#define GET_NAME(entry) ( \
+		HAS_PMR_INFO(entry) \
+			? (entry)->pmr_info.psPmrInfo->pszAnnotation \
+			: PMR_GetAnnotation((entry)->pmr_info.psPMR) \
+	)
+
+/* pszTextB = <Memdesc Annotation>,0,<Proc Name>,0 */
+/* Retrieve the string pointer to the ProcName */
+#define GET_PROC(entry) ((IMG_CHAR*) (strchr((entry)->pszTextB, '\0') + 1))
+
 typedef struct _RI_LIST_ENTRY_ RI_LIST_ENTRY;
 typedef struct _RI_SUBLIST_ENTRY_ RI_SUBLIST_ENTRY;
 
-static IMG_UINT16	g_ui16RICount;
-static HASH_TABLE	*g_pRIHashTable;
-static IMG_UINT16	g_ui16ProcCount;
-static HASH_TABLE	*g_pProcHashTable;
+static HASH_TABLE	*g_pPMR2RIListHashTable;
+static HASH_TABLE	*g_PID2RISublistHashTable;
 
 static POS_LOCK		g_hRILock;
 
@@ -220,7 +280,7 @@ static IMG_BOOL		bRIDeInitDeferred = IMG_FALSE;
  * Used as head of linked-list of PMR RI entries - this is useful when we wish
  * to iterate all PMR list entries (when we don't have a PMR ref)
  */
-static DLLIST_NODE	sListFirst;
+static DLLIST_NODE	g_sClientsListHead;
 
 /* Function used to produce string containing info for MEMDESC RI entries (used for both debugfs and kernel log output) */
 static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry, IMG_BOOL bDebugFs, IMG_UINT16 ui16MaxStrLen, IMG_CHAR *pszEntryString);
@@ -233,9 +293,6 @@ static PVRSRV_ERROR _DeleteAllProcEntries (uintptr_t k, uintptr_t v, void* pvPri
 static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid);
 #define _RIOutput(x) PVR_LOG(x)
 
-#define RI_FLAG_PMR_PHYS_COUNTED_BY_DEBUGFS	0x1
-#define RI_FLAG_SYSALLOC_PMR				0x2
-
 static IMG_UINT32
 _ProcHashFunc(size_t uKeySize, void *pKey, IMG_UINT32 uHashTabLen);
 
@@ -308,6 +365,66 @@ static void _RIUnlock(void)
  */
 static IMG_UINT32 g_ui32SysAllocPMRCount;
 
+static IMG_BOOL RICheckListHandle(RI_HANDLE hRIHandle)
+{
+	RI_LIST_ENTRY *psRIEntry = (RI_LIST_ENTRY *) hRIHandle, *psTableEntry;
+	void *pPMRHashKey;
+	IMG_BOOL bValid = IMG_FALSE;
+
+	if ((GET_DEVICE_ID(psRIEntry) > PVRSRV_MAX_DEVICES &&
+	     !IS_HOST_DEVICE(psRIEntry)) ||
+	    !g_pPMR2RIListHashTable)
+	{
+		//Shortcut check
+		return IMG_FALSE;
+	}
+
+	pPMRHashKey = GET_ADDR(psRIEntry);
+
+	_RILock();
+
+	/* Look-up psPMR in Hash Table */
+	psTableEntry = (RI_LIST_ENTRY *) HASH_Retrieve_Extended(g_pPMR2RIListHashTable,
+	                                                        &pPMRHashKey);
+	if (psTableEntry != NULL)
+	{
+		bValid = IS_VALID(psTableEntry);
+	}
+
+	_RIUnlock();
+
+	return bValid;
+}
+
+static IMG_BOOL RICheckSubListHandle(RI_HANDLE hRIHandle)
+{
+	RI_SUBLIST_ENTRY *psRISubEntry, *psTableEntry;
+	uintptr_t hashData;
+	IMG_PID pid;
+	IMG_BOOL bValid = IMG_FALSE;
+
+
+	psRISubEntry = (RI_SUBLIST_ENTRY *)hRIHandle;
+	if ((GET_DEVICE_ID(psRISubEntry) > PVRSRV_MAX_DEVICES) || !g_PID2RISublistHashTable)
+	{
+		//Shortcut check
+		return bValid;
+	}
+	pid = psRISubEntry->pid;
+
+	_RILock();
+	/* Look-up psPMR in Hash Table */
+	hashData = HASH_Retrieve_Extended (g_PID2RISublistHashTable, (void *)&pid);
+	if (hashData)
+	{
+		psTableEntry = IMG_CONTAINER_OF((PDLLIST_NODE)hashData, RI_SUBLIST_ENTRY, sProcListNode);
+		bValid = IS_VALID(psTableEntry);
+	}
+
+	/* Release RI Lock */
+	_RIUnlock();
+	return bValid;
+}
 
 PVRSRV_ERROR RIInitKM(void)
 {
@@ -344,15 +461,16 @@ PVRSRV_ERROR RIInitKM(void)
 #endif
 	return eError;
 }
+
 void RIDeInitKM(void)
 {
 #if (USE_RI_LOCK == 1)
-	if (g_ui16RICount > 0)
+	if (g_pPMR2RIListHashTable != NULL && HASH_Count(g_pPMR2RIListHashTable) > 0)
 	{
 		PVR_DPF((PVR_DBG_WARNING,
 		         "%s: called with %d entries remaining - deferring OSLockDestroy()",
 		         __func__,
-		         g_ui16RICount));
+		         HASH_Count(g_pPMR2RIListHashTable)));
 		bRIDeInitDeferred = IMG_TRUE;
 	}
 	else
@@ -422,18 +540,19 @@ void RILockReleaseKM(void)
 PVRSRV_ERROR RIWritePMREntryWithOwnerKM(PMR *psPMR,
                                         IMG_PID ui32Owner)
 {
+	PVRSRV_ERROR eError = PVRSRV_OK;
 	PMR *pPMRHashKey = psPMR;
 	RI_LIST_ENTRY *psRIEntry;
 	uintptr_t hashData;
 
 	/* if Hash table has not been created, create it now */
-	if (!g_pRIHashTable)
+	if (!g_pPMR2RIListHashTable)
 	{
-		g_pRIHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(PMR*), HASH_Func_Default, HASH_Key_Comp_Default);
-		g_pProcHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(IMG_PID), _ProcHashFunc, _ProcHashComp);
+		g_pPMR2RIListHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(PMR*), HASH_Func_Default, HASH_Key_Comp_Default);
+		g_PID2RISublistHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(IMG_PID), _ProcHashFunc, _ProcHashComp);
 	}
-	PVR_RETURN_IF_NOMEM(g_pRIHashTable);
-	PVR_RETURN_IF_NOMEM(g_pProcHashTable);
+	PVR_RETURN_IF_NOMEM(g_pPMR2RIListHashTable);
+	PVR_RETURN_IF_NOMEM(g_PID2RISublistHashTable);
 
 	PVR_RETURN_IF_INVALID_PARAM(psPMR);
 
@@ -441,9 +560,9 @@ PVRSRV_ERROR RIWritePMREntryWithOwnerKM(PMR *psPMR,
 	_RILock();
 
 	/* Look-up psPMR in Hash Table */
-	hashData = HASH_Retrieve_Extended (g_pRIHashTable, (void *)&pPMRHashKey);
+	hashData = HASH_Retrieve_Extended (g_pPMR2RIListHashTable, (void *)&pPMRHashKey);
 	psRIEntry = (RI_LIST_ENTRY *)hashData;
-	if (!psRIEntry)
+	if (psRIEntry == NULL)
 	{
 		PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *)PMR_DeviceNode(psPMR);
 
@@ -453,30 +572,30 @@ PVRSRV_ERROR RIWritePMREntryWithOwnerKM(PMR *psPMR,
 		psRIEntry = (RI_LIST_ENTRY *)OSAllocZMemNoStats(sizeof(RI_LIST_ENTRY));
 		if (!psRIEntry)
 		{
-			/* Release RI Lock */
-			_RIUnlock();
 			/* Error - no memory to allocate for new RI entry */
-			return PVRSRV_ERROR_OUT_OF_MEMORY;
+			PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_OUT_OF_MEMORY, exit_);
 		}
 		else
 		{
 			PMR_FLAGS_T uiPMRFlags = PMR_Flags(psPMR);
+			IMG_UINT32 ui32RICount = HASH_Count(g_pPMR2RIListHashTable);
 
 			/*
 			 * Add new RI Entry
 			 */
-			if (g_ui16RICount == 0)
+			if (ui32RICount == 0)
 			{
 				/* Initialise PMR entry linked-list head */
-				dllist_init(&sListFirst);
+				dllist_init(&g_sClientsListHead);
+			}
+			else if (ui32RICount == IMG_UINT32_MAX)
+			{
+				PVR_LOG_GOTO_WITH_ERROR("ui32RICount", eError, PVRSRV_ERROR_REFCOUNT_OVERFLOW, exit_);
 			}
-			g_ui16RICount++;
 
-			dllist_init (&(psRIEntry->sSysAllocListNode));
+			dllist_init (&(psRIEntry->sListNode));
 			dllist_init (&(psRIEntry->sSubListFirst));
-			psRIEntry->ui16SubListCount = 0;
-			psRIEntry->ui16MaxSubListCount = 0;
-			psRIEntry->valid = _VALID_RI_LIST_ENTRY;
+			BIT_SET(psRIEntry->ui16Flags, RI_VALID_FLAG);
 
 			/* Check if this PMR should be accounted for under the
 			 * PVR_SYS_ALLOC_PID debugFS entry. This should happen if
@@ -490,46 +609,35 @@ PVRSRV_ERROR RIWritePMREntryWithOwnerKM(PMR *psPMR,
 				ui32Owner == PVR_SYS_ALLOC_PID ||
 				psDeviceNode == PVRSRVGetPVRSRVData()->psHostMemDeviceNode)
 			{
-				psRIEntry->ui32RIPMRFlags = RI_FLAG_SYSALLOC_PMR;
-				OSSNPrintf(psRIEntry->ai8ProcName,
-						RI_PROC_BUF_SIZE,
-						"SysProc");
+				BIT_SET(psRIEntry->ui16Flags, RI_SYSALLOC_PMR_FLAG);
 				psRIEntry->pid = PVR_SYS_ALLOC_PID;
 				OSLockAcquire(g_hSysAllocPidListLock);
 				/* Add this psRIEntry to the list of entries for PVR_SYS_ALLOC_PID */
-				dllist_add_to_tail(&g_sSysAllocPidListHead, (PDLLIST_NODE)&(psRIEntry->sSysAllocListNode));
+				dllist_add_to_tail(&g_sSysAllocPidListHead, (PDLLIST_NODE)&(psRIEntry->sListNode));
 				OSLockRelease(g_hSysAllocPidListLock);
 				g_ui32SysAllocPMRCount++;
 			}
 			else
 			{
-				psRIEntry->ui32RIPMRFlags = 0;
 				psRIEntry->pid = ui32Owner;
+				dllist_add_to_tail(&g_sClientsListHead, (PDLLIST_NODE)&(psRIEntry->sListNode));
 			}
-
-			OSSNPrintf(psRIEntry->ai8ProcName,
-					RI_PROC_BUF_SIZE,
-					"%s",
-					OSGetCurrentClientProcessNameKM());
-			/* Add PMR entry to linked-list of all PMR entries */
-			dllist_init (&(psRIEntry->sListNode));
-			dllist_add_to_tail(&sListFirst, (PDLLIST_NODE)&(psRIEntry->sListNode));
 		}
 
-		psRIEntry->psPMR = psPMR;
-		psRIEntry->ui32Flags = 0;
-		psRIEntry->ui32DevID = psDeviceNode->sDevId.ui32InternalID;
+		psRIEntry->pmr_info.psPMR = psPMR;
+		SET_DEVICE_ID(psRIEntry, psDeviceNode->sDevId.ui32InternalID);
 
 		/* Create index entry in Hash Table */
-		HASH_Insert_Extended (g_pRIHashTable, (void *)&pPMRHashKey, (uintptr_t)psRIEntry);
+		HASH_Insert_Extended (g_pPMR2RIListHashTable, (void *)&pPMRHashKey, (uintptr_t)psRIEntry);
 
 		/* Store phRIHandle in PMR structure, so it can delete the associated RI entry when it destroys the PMR */
 		PMRStoreRIHandle(psPMR, psRIEntry);
 	}
+exit_:
 	/* Release RI Lock */
 	_RIUnlock();
 
-	return PVRSRV_OK;
+	return eError;
 }
 
 /*!
@@ -563,25 +671,27 @@ PVRSRV_ERROR RIWritePMREntryKM(PMR *psPMR)
             The new entry will be inserted at the head of the sublist of
             the indicated PMR list entry, and assigned the values provided.
 
+ @input     psConnection - Reference to the Services connection
+ @input     psDeviceNode - Reference to the device node
  @input     psPMR - Reference (handle) to the PMR to which this MEMDESC RI entry relates
  @input     ui32TextBSize - Length of string provided in psz8TextB parameter
  @input     psz8TextB - String describing this secondary reference (may be null)
  @input     ui64Offset - Offset from the start of the PMR at which this allocation begins
  @input     ui64Size - Size of this allocation
- @input     bIsImport - Flag indicating if this is an allocation or an import
- @input     bIsSuballoc - Flag indicating if this is a sub-allocation
+ @input     uiFlags - Flags indicating if this is a sub-allocation or an import
  @output    phRIHandle - Handle to the created RI entry
 
  @Return	PVRSRV_ERROR
 
 ******************************************************************************/
-PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
+PVRSRV_ERROR RIWriteMEMDESCEntryKM(void* psConnection,
+                                   PVRSRV_DEVICE_NODE *psDeviceNode,
+                                   PMR *psPMR,
                                    IMG_UINT32 ui32TextBSize,
                                    const IMG_CHAR *psz8TextB,
                                    IMG_UINT64 ui64Offset,
                                    IMG_UINT64 ui64Size,
-                                   IMG_BOOL bIsImport,
-                                   IMG_BOOL bIsSuballoc,
+                                   PVRSRV_MEMALLOCFLAGS_T uiFlags,
                                    RI_HANDLE *phRIHandle)
 {
 	RI_SUBLIST_ENTRY *psRISubEntry;
@@ -590,20 +700,28 @@ PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
 	uintptr_t hashData;
 	IMG_PID	pid;
 
+	IMG_CHAR szProcName[RI_PROC_BUF_SIZE];
+
+	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
+
 	/* Check Hash tables have been created (meaning at least one PMR has been defined) */
-	PVR_RETURN_IF_INVALID_PARAM(g_pRIHashTable);
-	PVR_RETURN_IF_INVALID_PARAM(g_pProcHashTable);
+	PVR_RETURN_IF_INVALID_PARAM(g_pPMR2RIListHashTable);
+	PVR_RETURN_IF_INVALID_PARAM(g_PID2RISublistHashTable);
 
 	PVR_RETURN_IF_INVALID_PARAM(psPMR);
 	PVR_RETURN_IF_INVALID_PARAM(phRIHandle);
 
+	/* Only allow request for a firmware context that comes from a direct bridge
+	 * (psConnection == NULL). */
+	PVR_RETURN_IF_INVALID_PARAM(!(psConnection != NULL && PVRSRV_CHECK_RI_FWKMD_ALLOC(uiFlags)));
+
 	/* Acquire RI Lock */
 	_RILock();
 
 	*phRIHandle = NULL;
 
 	/* Look-up psPMR in Hash Table */
-	hashData = HASH_Retrieve_Extended (g_pRIHashTable, (void *)&pPMRHashKey);
+	hashData = HASH_Retrieve_Extended (g_pPMR2RIListHashTable, (void *)&pPMRHashKey);
 	psRIEntry = (RI_LIST_ENTRY *)hashData;
 	if (!psRIEntry)
 	{
@@ -640,48 +758,129 @@ PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
 
 		/* Increment number of entries in sublist */
 		psRIEntry->ui16SubListCount++;
-		if (psRIEntry->ui16SubListCount > psRIEntry->ui16MaxSubListCount)
-		{
-			psRIEntry->ui16MaxSubListCount = psRIEntry->ui16SubListCount;
-		}
-		psRISubEntry->valid = _VALID_RI_SUBLIST_ENTRY;
+		BIT_SET(psRISubEntry->ui16Flags, RI_VALID_FLAG);
+	}
+
+	if (PVRSRV_CHECK_RI_IMPORT(uiFlags))
+	{
+		BIT_SET(psRISubEntry->ui16Flags, RI_IMPORT_FLAG);
+	}
+	else
+	{
+		BIT_UNSET(psRISubEntry->ui16Flags, RI_IMPORT_FLAG);
+	}
+
+	if (PVRSRV_CHECK_RI_SUBALLOC(uiFlags))
+	{
+		BIT_SET(psRISubEntry->ui16Flags, RI_SUBALLOC_FLAG);
+	}
+	else
+	{
+		BIT_UNSET(psRISubEntry->ui16Flags, RI_SUBALLOC_FLAG);
 	}
 
 	/* If allocation is made during device or driver initialisation,
 	 * track the MEMDESC entry under PVR_SYS_ALLOC_PID, otherwise use
-	 * the current PID.
-	 * Record host dev node allocations on the system PID.
-	 */
+	 * the current PID. */
 	{
-		PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *)PMR_DeviceNode(psRISubEntry->psRI->psPMR);
+		PVRSRV_DEVICE_NODE *psRIDeviceNode = GET_DEVNODE(psRISubEntry->psRI);
+		IMG_INT iRet;
+
+		/* HostMemDevice doesn't update eDevState hence there's no need to test
+		 * for it. */
+		if (psRIDeviceNode == PVRSRVGetPVRSRVData()->psHostMemDeviceNode)
+		{
+			/* Imports on HostMemDev should be attributed to the importing
+			 * process. This way if an import is not freed before disconnect
+			 * it will be outlined in the gpu_mem_area for the given process.
+			 * Otherwise attribute the rest of the records to PVR_SYS_ALLOC_PID. */
+			if (IS_IMPORT(psRISubEntry))
+			{
+				psRISubEntry->pid = OSGetCurrentClientProcessIDKM();
+				iRet = OSStringSafeCopy(szProcName, OSGetCurrentClientProcessNameKM(),
+				                        RI_PROC_BUF_SIZE);
+			}
+			else
+			{
+				psRISubEntry->pid = PVR_SYS_ALLOC_PID;
+				iRet = OSStringSafeCopy(szProcName, "SysProc", RI_PROC_BUF_SIZE);
 
-		if (psDeviceNode->eDevState < PVRSRV_DEVICE_STATE_ACTIVE ||
-			psDeviceNode == PVRSRVGetPVRSRVData()->psHostMemDeviceNode)
+				if (psRISubEntry->pid != psRISubEntry->psRI->pid)
+				{
+					PVR_LOG(("%s(1): current PID = %u, RI entry PID = %u, RI sub-entry PID = %u",
+					         __func__, OSGetCurrentClientProcessIDKM(), psRISubEntry->psRI->pid,
+					         psRISubEntry->pid));
+				}
+			}
+		}
+		else
+		{
+			/* All allocations done during device initialisation or belonging
+			 * to the Firmware should be attributed to PVR_SYS_ALLOC_PID. */
+			if (psRIDeviceNode->eDevState < PVRSRV_DEVICE_STATE_ACTIVE ||
+			    PVRSRV_CHECK_RI_FWKMD_ALLOC(uiFlags))
+			{
+				psRISubEntry->pid = PVR_SYS_ALLOC_PID;
+				iRet = OSStringSafeCopy(szProcName, "SysProc", RI_PROC_BUF_SIZE);
+
+				if (psRISubEntry->pid != psRISubEntry->psRI->pid)
+				{
+					PVR_LOG(("%s(2): current PID = %u, RI entry PID = %u, RI sub-entry PID = %u",
+					         __func__, OSGetCurrentClientProcessIDKM(), psRISubEntry->psRI->pid,
+					         psRISubEntry->pid));
+				}
+			}
+			else
+			{
+				psRISubEntry->pid = OSGetCurrentClientProcessIDKM();
+				iRet = OSStringSafeCopy(szProcName, OSGetCurrentClientProcessNameKM(),
+				                        RI_PROC_BUF_SIZE);
+			}
+		}
+		if (iRet < 0)
 		{
-			psRISubEntry->pid = psRISubEntry->psRI->pid;
+			PVR_DPF((PVR_DBG_WARNING, "%s: process name has been truncated from '%s' to '%s'",
+			         __func__, OSGetCurrentClientProcessNameKM(), szProcName));
+			psRISubEntry->ui16TextBLength = RI_PROC_BUF_SIZE - 1;
 		}
 		else
 		{
-			psRISubEntry->pid = OSGetCurrentClientProcessIDKM();
+			psRISubEntry->ui16TextBLength = iRet;
 		}
 
-		if (ui32TextBSize > sizeof(psRISubEntry->ai8TextB)-1)
+		if (psz8TextB == NULL)
+		{
+			psz8TextB = "";
+			ui32TextBSize = 0;
+		}
+		if (ui32TextBSize > (RI_ANNO_BUF_SIZE))
 		{
 			PVR_DPF((PVR_DBG_WARNING,
 					 "%s: TextBSize too long (%u). Text will be truncated "
-					 "to %zu characters", __func__,
-					 ui32TextBSize, sizeof(psRISubEntry->ai8TextB)-1));
+					 "to %d characters", __func__,
+					 ui32TextBSize, RI_ANNO_BUF_SIZE));
+			ui32TextBSize = RI_ANNO_BUF_SIZE;
 		}
 
-		/* copy ai8TextB field data */
-		OSSNPrintf((IMG_CHAR *)psRISubEntry->ai8TextB, sizeof(psRISubEntry->ai8TextB), "%s", psz8TextB);
+		/* copy TextB field data plus separator char and terminator */
+		psRISubEntry->ui16TextBLength += ui32TextBSize + 2;
+		psRISubEntry->pszTextB = OSAllocZMemNoStats(psRISubEntry->ui16TextBLength);
+		if (!psRISubEntry->pszTextB)
+		{
+			OSFreeMemNoStats(psRISubEntry);
+			_RIUnlock();
+			return PVRSRV_ERROR_OUT_OF_MEMORY;
+		}
+		/* TextB is formatted as Annotation+NullTerm+ProcName so we can still
+		 * print annotation without proc name.
+		 * If any of the strings is too long it will be truncated. */
+		(void) OSStringSafeCopy(psRISubEntry->pszTextB, psz8TextB, ui32TextBSize + 1);
+		(void) OSStringSafeCopy(psRISubEntry->pszTextB + ui32TextBSize + 1, szProcName,
+		                        psRISubEntry->ui16TextBLength - ui32TextBSize - 1);
 
-		psRISubEntry->ui32DevID = psDeviceNode->sDevId.ui32InternalID;
 		psRISubEntry->ui64Offset = ui64Offset;
 		psRISubEntry->ui64Size = ui64Size;
-		psRISubEntry->bIsImport = bIsImport;
-		psRISubEntry->bIsSuballoc = bIsSuballoc;
-		OSSNPrintf((IMG_CHAR *)psRISubEntry->ai8ProcName, RI_PROC_BUF_SIZE, "%s", OSGetCurrentClientProcessNameKM());
+		psRISubEntry->psConnection = psConnection;
 		dllist_init (&(psRISubEntry->sProcListNode));
 	}
 
@@ -690,15 +889,24 @@ PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
 	 */
 	/* look-up pid in Hash Table */
 	pid = psRISubEntry->pid;
-	hashData = HASH_Retrieve_Extended (g_pProcHashTable, (void *)&pid);
+	hashData = HASH_Retrieve_Extended (g_PID2RISublistHashTable, (void *)&pid);
 	if (!hashData)
 	{
 		/*
 		 * No allocations for this pid yet
 		 */
-		HASH_Insert_Extended (g_pProcHashTable, (void *)&pid, (uintptr_t)&(psRISubEntry->sProcListNode));
-		/* Increment number of entries in proc hash table */
-		g_ui16ProcCount++;
+		if (!HASH_Insert_Extended(g_PID2RISublistHashTable,
+		                          (void *) &pid,
+		                          (uintptr_t) &psRISubEntry->sProcListNode))
+		{
+			dllist_remove_node(&psRISubEntry->sListNode);
+			psRIEntry->ui16SubListCount--;
+			OSFreeMemNoStats(psRISubEntry->pszTextB);
+			OSFreeMemNoStats(psRISubEntry);
+
+			_RIUnlock();
+			return PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED;
+		}
 	}
 	else
 	{
@@ -741,6 +949,8 @@ PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
             To remove entries from the per-process list, just use
             RIDeleteMEMDESCEntryKM().
 
+ @input     psConnection - Reference to the Services connection
+ @input     psDeviceNode - Reference to the device node
  @input     psz8TextB - String describing this secondary reference (may be null)
  @input     ui64Size - Size of this allocation
  @input     ui64DevVAddr - Virtual address of this entry
@@ -749,7 +959,7 @@ PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
  @Return	PVRSRV_ERROR
 
 ******************************************************************************/
-PVRSRV_ERROR RIWriteProcListEntryKM(CONNECTION_DATA *psConnection,
+PVRSRV_ERROR RIWriteProcListEntryKM(void* psConnection,
                                     PVRSRV_DEVICE_NODE *psDeviceNode,
                                     IMG_UINT32 ui32TextBSize,
                                     const IMG_CHAR *psz8TextB,
@@ -760,15 +970,14 @@ PVRSRV_ERROR RIWriteProcListEntryKM(CONNECTION_DATA *psConnection,
 	uintptr_t hashData = 0;
 	IMG_PID		pid;
 	RI_SUBLIST_ENTRY *psRISubEntry = NULL;
+	IMG_INT iRet;
 
-	PVR_UNREFERENCED_PARAMETER(psConnection);
-
-	if (!g_pRIHashTable)
+	if (!g_pPMR2RIListHashTable)
 	{
-		g_pRIHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(PMR*), HASH_Func_Default, HASH_Key_Comp_Default);
-		g_pProcHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(IMG_PID), _ProcHashFunc, _ProcHashComp);
+		g_pPMR2RIListHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(PMR*), HASH_Func_Default, HASH_Key_Comp_Default);
+		g_PID2RISublistHashTable = HASH_Create_Extended(_RI_INITIAL_HASH_TABLE_SIZE, sizeof(IMG_PID), _ProcHashFunc, _ProcHashComp);
 
-		if (!g_pRIHashTable || !g_pProcHashTable)
+		if (!g_pPMR2RIListHashTable || !g_PID2RISublistHashTable)
 		{
 			/* Error - no memory to allocate for Hash table(s) */
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -789,28 +998,50 @@ PVRSRV_ERROR RIWriteProcListEntryKM(CONNECTION_DATA *psConnection,
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	psRISubEntry->valid = _VALID_RI_SUBLIST_ENTRY;
+	BIT_SET(psRISubEntry->ui16Flags, RI_VALID_FLAG);
 
 	psRISubEntry->pid = OSGetCurrentClientProcessIDKM();
-	psRISubEntry->ui32DevID = psDeviceNode->sDevId.ui32InternalID;
+	SET_DEVICE_ID(psRISubEntry, psDeviceNode->sDevId.ui32InternalID);
 
-	if (ui32TextBSize > sizeof(psRISubEntry->ai8TextB)-1)
+	if (psz8TextB == NULL)
+	{
+		psz8TextB = "";
+		ui32TextBSize = 0;
+	}
+	if (ui32TextBSize > (RI_ANNO_BUF_SIZE))
 	{
 		PVR_DPF((PVR_DBG_WARNING,
-		         "%s: TextBSize too long (%u). Text will be truncated "
-		         "to %zu characters", __func__,
-		         ui32TextBSize, sizeof(psRISubEntry->ai8TextB)-1));
+				 "%s: TextBSize too long (%u). Text will be truncated "
+				 "to %d characters", __func__,
+				 ui32TextBSize, RI_ANNO_BUF_SIZE));
+		ui32TextBSize = RI_ANNO_BUF_SIZE;
 	}
 
-	/* copy ai8TextB field data */
-	OSSNPrintf((IMG_CHAR *)psRISubEntry->ai8TextB, sizeof(psRISubEntry->ai8TextB), "%s", psz8TextB);
-
-	psRISubEntry->ui64Offset = 0;
+	/* copy TextB field data */
+	psRISubEntry->ui16TextBLength = ui32TextBSize + RI_PROC_BUF_SIZE;
+	psRISubEntry->pszTextB = OSAllocZMemNoStats(psRISubEntry->ui16TextBLength);
+	if (!psRISubEntry->pszTextB)
+	{
+		OSFreeMemNoStats(psRISubEntry);
+		_RIUnlock();
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+	/* TextB is formatted as Annotation+NullTerm+ProcName so we can still
+	 * print annotation without proc name.
+	 */
+	(void) OSStringSafeCopy(psRISubEntry->pszTextB, psz8TextB, ui32TextBSize + 1);
+	iRet = OSStringSafeCopy(psRISubEntry->pszTextB + ui32TextBSize + 1,
+	                        OSGetCurrentClientProcessNameKM(),
+	                        psRISubEntry->ui16TextBLength - ui32TextBSize - 1);
+	if (iRet < 0)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%s: process name has been truncated from '%s' to '%s'",
+		         __func__, OSGetCurrentClientProcessNameKM(),
+		         psRISubEntry->pszTextB + ui32TextBSize + 1));
+	}
 	psRISubEntry->ui64Size = ui64Size;
 	psRISubEntry->sVAddr.uiAddr = ui64DevVAddr;
-	psRISubEntry->bIsImport = IMG_FALSE;
-	psRISubEntry->bIsSuballoc = IMG_FALSE;
-	OSSNPrintf((IMG_CHAR *)psRISubEntry->ai8ProcName, RI_PROC_BUF_SIZE, "%s", OSGetCurrentClientProcessNameKM());
+	psRISubEntry->psConnection = psConnection;
 	dllist_init (&(psRISubEntry->sProcListNode));
 
 	/*
@@ -818,15 +1049,21 @@ PVRSRV_ERROR RIWriteProcListEntryKM(CONNECTION_DATA *psConnection,
 	 */
 	/* look-up pid in Hash Table */
 	pid = psRISubEntry->pid;
-	hashData = HASH_Retrieve_Extended (g_pProcHashTable, (void *)&pid);
+	hashData = HASH_Retrieve_Extended (g_PID2RISublistHashTable, (void *)&pid);
 	if (!hashData)
 	{
 		/*
 		 * No allocations for this pid yet
 		 */
-		HASH_Insert_Extended (g_pProcHashTable, (void *)&pid, (uintptr_t)&(psRISubEntry->sProcListNode));
-		/* Increment number of entries in proc hash table */
-		g_ui16ProcCount++;
+		if (!HASH_Insert_Extended(g_PID2RISublistHashTable,
+		                          (void *) &pid,
+		                          (uintptr_t) &psRISubEntry->sProcListNode))
+		{
+			OSFreeMemNoStats(psRISubEntry->pszTextB);
+			OSFreeMemNoStats(psRISubEntry);
+			_RIUnlock();
+			return PVRSRV_ERROR_INSERT_HASH_TABLE_DATA_FAILED;
+		}
 	}
 	else
 	{
@@ -869,7 +1106,7 @@ PVRSRV_ERROR RIUpdateMEMDESCAddrKM(RI_HANDLE hRIHandle,
 	PVR_RETURN_IF_INVALID_PARAM(hRIHandle);
 
 	psRISubEntry = (RI_SUBLIST_ENTRY *)hRIHandle;
-	if (psRISubEntry->valid != _VALID_RI_SUBLIST_ENTRY)
+	if (!IS_VALID(psRISubEntry))
 	{
 		/* Pointer does not point to valid structure */
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -886,127 +1123,138 @@ PVRSRV_ERROR RIUpdateMEMDESCAddrKM(RI_HANDLE hRIHandle,
 	return PVRSRV_OK;
 }
 
-/*!
-*******************************************************************************
-
- @Function	RIDeletePMREntryKM
-
- @Description
-            Delete a Resource Information entry.
-
- @input     hRIHandle - Handle of object whose reference info is to be deleted
-
- @Return	PVRSRV_ERROR
-
-******************************************************************************/
-PVRSRV_ERROR RIDeletePMREntryKM(RI_HANDLE hRIHandle)
+static PVRSRV_ERROR RIDeletePMREntryUnlocked(RI_LIST_ENTRY *psRIEntry)
 {
-	RI_LIST_ENTRY *psRIEntry;
 	PMR			*pPMRHashKey;
-	PVRSRV_ERROR eResult = PVRSRV_OK;
+	uintptr_t hashValue = 0;
 
-	PVR_RETURN_IF_INVALID_PARAM(hRIHandle);
+	/* Remove the HASH table index entry */
+	pPMRHashKey = GET_ADDR(psRIEntry);
+	hashValue = HASH_Remove_Extended(g_pPMR2RIListHashTable, (void *)&pPMRHashKey);
+	PVR_LOG_RETURN_IF_INVALID_PARAM(hashValue, "RI");
+
+	BIT_UNSET(psRIEntry->ui16Flags, RI_VALID_FLAG);
 
-	psRIEntry = (RI_LIST_ENTRY *)hRIHandle;
+	/* Remove PMR entry from linked-list of PMR entries */
+	dllist_remove_node((PDLLIST_NODE)&(psRIEntry->sListNode));
 
-	if (psRIEntry->valid != _VALID_RI_LIST_ENTRY)
+	if (IS_SYSPMR(psRIEntry))
 	{
-		/* Pointer does not point to valid structure */
-		return PVRSRV_ERROR_INVALID_PARAMS;
+		g_ui32SysAllocPMRCount--;
 	}
 
-	if (psRIEntry->ui16SubListCount == 0)
+	if (IS_RACC(psRIEntry))
 	{
-		/* Acquire RI lock*/
-		_RILock();
-
-		/* Remove the HASH table index entry */
-		pPMRHashKey = psRIEntry->psPMR;
-		HASH_Remove_Extended(g_pRIHashTable, (void *)&pPMRHashKey);
+		OSFreeMemNoStats(psRIEntry->pmr_info.psPmrInfo);
+	}
 
-		psRIEntry->valid = _INVALID;
+	/* Now, free the memory used to store the RI entry */
+	OSFreeMemNoStats(psRIEntry);
+	psRIEntry = NULL;
 
-		/* Remove PMR entry from linked-list of PMR entries */
-		dllist_remove_node((PDLLIST_NODE)&(psRIEntry->sListNode));
+	/* If the hash table is now empty we can delete the RI hash table */
+	if (HASH_Count(g_pPMR2RIListHashTable) == 0)
+	{
+		HASH_Delete(g_pPMR2RIListHashTable);
+		g_pPMR2RIListHashTable = NULL;
+	}
+	return PVRSRV_OK;
+}
 
-		if (psRIEntry->ui32RIPMRFlags & RI_FLAG_SYSALLOC_PMR)
-		{
-			dllist_remove_node((PDLLIST_NODE)&(psRIEntry->sSysAllocListNode));
-			g_ui32SysAllocPMRCount--;
-		}
+static PVRSRV_ERROR _RICreateAndSetPmrInfo(RI_LIST_ENTRY *const psRIEntry)
+{
+	const IMG_CHAR *const pszAnnotation = PMR_GetAnnotation(psRIEntry->pmr_info.psPMR);
+	const IMG_UINT32 uiLength = OSStringNLength(pszAnnotation, DEVMEM_ANNOTATION_MAX_LEN) + 1;
 
-		/* Now, free the memory used to store the RI entry */
-		OSFreeMemNoStats(psRIEntry);
-		psRIEntry = NULL;
+	RI_PMR_INFO *psPmrInfo = OSAllocZMemNoStats(sizeof(*psPmrInfo) + uiLength);
+	PVR_LOG_RETURN_IF_NOMEM(psPmrInfo, "OSAllocZMemNoStats");
 
-		/*
-		 * Decrement number of RI entries - if this is now zero,
-		 * we can delete the RI hash table
-		 */
-		if (--g_ui16RICount == 0)
-		{
-			HASH_Delete(g_pRIHashTable);
-			g_pRIHashTable = NULL;
+	psPmrInfo->uiAddr = (uintptr_t) psRIEntry->pmr_info.psPMR;
+	psPmrInfo->psHeap = PMR_PhysHeap(psRIEntry->pmr_info.psPMR);
+	psPmrInfo->psDeviceNode = (PVRSRV_DEVICE_NODE *) PMR_DeviceNode(psRIEntry->pmr_info.psPMR);
+	psPmrInfo->uiLogicalSize = PMR_LogicalSize(psRIEntry->pmr_info.psPMR);
+	psPmrInfo->uiPhysicalSize = PMR_PhysicalSize(psRIEntry->pmr_info.psPMR);
 
-			_RIUnlock();
+	psPmrInfo->pszAnnotation = IMG_OFFSET_ADDR(psPmrInfo, sizeof(*psPmrInfo));
+	OSStringSafeCopy(psPmrInfo->pszAnnotation, pszAnnotation, uiLength);
 
-			/* If deInit has been deferred, we can now destroy the RI Lock */
-			if (bRIDeInitDeferred)
-			{
-				OSLockDestroy(g_hRILock);
-			}
-		}
-		else
-		{
-			/* Release RI lock*/
-			_RIUnlock();
-		}
-		/*
-		 * Make the handle NULL once PMR RI entry is deleted
-		 */
-		hRIHandle = NULL;
-	}
-	else
-	{
-		eResult = PVRSRV_ERROR_DEVICEMEM_ALLOCATIONS_REMAIN_IN_HEAP;
-	}
+	psRIEntry->pmr_info.psPmrInfo = psPmrInfo;
+	BIT_SET(psRIEntry->ui16Flags, RI_HAS_PMR_INFO);
 
-	return eResult;
+	return PVRSRV_OK;
 }
 
 /*!
 *******************************************************************************
 
- @Function	RIDeleteMEMDESCEntryKM
+ @Function	RIDeletePMREntryKM
 
  @Description
             Delete a Resource Information entry.
-            Entry can be from RIEntry list or ProcList.
 
  @input     hRIHandle - Handle of object whose reference info is to be deleted
 
  @Return	PVRSRV_ERROR
 
 ******************************************************************************/
-PVRSRV_ERROR RIDeleteMEMDESCEntryKM(RI_HANDLE hRIHandle)
+PVRSRV_ERROR RIDeletePMREntryKM(RI_HANDLE hRIHandle)
 {
-	RI_LIST_ENTRY *psRIEntry = NULL;
-	RI_SUBLIST_ENTRY *psRISubEntry;
-	uintptr_t hashData;
-	IMG_PID pid;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	RI_LIST_ENTRY *psRIEntry;
 
-	PVR_RETURN_IF_INVALID_PARAM(hRIHandle);
+	psRIEntry = (RI_LIST_ENTRY *) hRIHandle;
 
-	psRISubEntry = (RI_SUBLIST_ENTRY *)hRIHandle;
-	if (psRISubEntry->valid != _VALID_RI_SUBLIST_ENTRY)
+	if (!RICheckListHandle(hRIHandle))
 	{
-		/* Pointer does not point to valid structure */
-		return PVRSRV_ERROR_INVALID_PARAMS;
+		/* Pointer does not point to valid structure. */
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_INVALID_PARAMS, ErrReturn);
+	}
+	else if (IS_RACC(psRIEntry))
+	{
+		/* Keep this entry so that it can be inspected as a memory leak in the
+		 * gpu_mem_area stats. */
+		return PVRSRV_OK;
+	}
+
+	if (psRIEntry->ui16SubListCount != 0)
+	{
+		PVR_DPF((PVR_DBG_WARNING, "%p not deleted. RIEntry(%s) still has %u allocation(s)",
+		         psRIEntry, GET_NAME(psRIEntry), psRIEntry->ui16SubListCount));
+
+		PVR_GOTO_WITH_ERROR(eError, PVRSRV_ERROR_DEVICEMEM_ALLOCATIONS_REMAIN_IN_HEAP,
+		                    ErrCreateAndAssignPmrInfo);
 	}
 
-	/* Acquire RI lock*/
 	_RILock();
 
+	eError = RIDeletePMREntryUnlocked(psRIEntry);
+
+	_RIUnlock();
+
+	/* If deInit has been deferred, we can now destroy the RI Lock */
+	if (bRIDeInitDeferred && (g_pPMR2RIListHashTable == NULL || HASH_Count(g_pPMR2RIListHashTable) == 0))
+	{
+		OSLockDestroy(g_hRILock);
+	}
+
+	return PVRSRV_OK;
+
+ErrCreateAndAssignPmrInfo:
+	{
+		PVRSRV_ERROR eError2 = _RICreateAndSetPmrInfo(psRIEntry);
+		PVR_RETURN_IF_ERROR(eError2);
+	}
+ErrReturn:
+	return eError;
+}
+
+static PVRSRV_ERROR RIDeleteMemdescEntryUnlocked(RI_SUBLIST_ENTRY *psRISubEntry)
+{
+	RI_LIST_ENTRY *psRIEntry = NULL;
+	uintptr_t hashData;
+	uintptr_t hashValue = 0;
+	IMG_PID pid;
+
 	/* For entries which do have a parent PMR remove the node from the sublist */
 	if (psRISubEntry->psRI)
 	{
@@ -1016,33 +1264,36 @@ PVRSRV_ERROR RIDeleteMEMDESCEntryKM(RI_HANDLE hRIHandle)
 		dllist_remove_node(&(psRISubEntry->sListNode));
 	}
 
-	psRISubEntry->valid = _INVALID;
+	BIT_UNSET(psRISubEntry->ui16Flags, RI_VALID_FLAG);
 
 	/* Remove the entry from the proc allocations linked list */
 	pid = psRISubEntry->pid;
 	/* If this is the only allocation for this pid, just remove it from the hash table */
 	if (dllist_get_next_node(&(psRISubEntry->sProcListNode)) == NULL)
 	{
-		HASH_Remove_Extended(g_pProcHashTable, (void *)&pid);
-		/* Decrement number of entries in proc hash table, and delete the hash table if there are now none */
-		if (--g_ui16ProcCount == 0)
+		hashValue = HASH_Remove_Extended(g_PID2RISublistHashTable, (void *)&pid);
+		PVR_LOG_RETURN_IF_INVALID_PARAM(hashValue, "PID");
+		/* Delete the hash table if there are now no entries */
+		if (HASH_Count(g_PID2RISublistHashTable) == 0)
 		{
-			HASH_Delete(g_pProcHashTable);
-			g_pProcHashTable = NULL;
+			HASH_Delete(g_PID2RISublistHashTable);
+			g_PID2RISublistHashTable = NULL;
 		}
 	}
 	else
 	{
-		hashData = HASH_Retrieve_Extended (g_pProcHashTable, (void *)&pid);
+		hashData = HASH_Retrieve_Extended (g_PID2RISublistHashTable, (void *)&pid);
 		if ((PDLLIST_NODE)hashData == &(psRISubEntry->sProcListNode))
 		{
-			HASH_Remove_Extended(g_pProcHashTable, (void *)&pid);
-			HASH_Insert_Extended (g_pProcHashTable, (void *)&pid, (uintptr_t)dllist_get_next_node(&(psRISubEntry->sProcListNode)));
+			hashValue = HASH_Remove_Extended(g_PID2RISublistHashTable, (void *)&pid);
+			PVR_LOG_RETURN_IF_INVALID_PARAM(hashValue, "PID");
+			HASH_Insert_Extended (g_PID2RISublistHashTable, (void *)&pid, (uintptr_t)dllist_get_next_node(&(psRISubEntry->sProcListNode)));
 		}
 	}
 	dllist_remove_node(&(psRISubEntry->sProcListNode));
 
 	/* Now, free the memory used to store the sublist entry */
+	OSFreeMemNoStats(psRISubEntry->pszTextB);
 	OSFreeMemNoStats(psRISubEntry);
 	psRISubEntry = NULL;
 
@@ -1053,6 +1304,42 @@ PVRSRV_ERROR RIDeleteMEMDESCEntryKM(RI_HANDLE hRIHandle)
 	{
 		psRIEntry->ui16SubListCount--;
 	}
+	return PVRSRV_OK;
+}
+
+/*!
+*******************************************************************************
+
+ @Function	RIDeleteMEMDESCEntryKM
+
+ @Description
+            Delete a Resource Information entry.
+            Entry can be from RIEntry list or ProcList.
+
+ @input     hRIHandle - Handle of object whose reference info is to be deleted
+
+ @Return	PVRSRV_ERROR
+
+******************************************************************************/
+PVRSRV_ERROR RIDeleteMEMDESCEntryKM(RI_HANDLE hRIHandle)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	RI_SUBLIST_ENTRY *psRISubEntry;
+
+	psRISubEntry = (RI_SUBLIST_ENTRY *)hRIHandle;
+	if (!RICheckSubListHandle(hRIHandle))
+	{
+		/* Pointer does not point to valid structure */
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	else if (IS_RACC(psRISubEntry))
+	{
+		return PVRSRV_OK;
+	}
+	/* Acquire RI lock*/
+	_RILock();
+
+	eError = RIDeleteMemdescEntryUnlocked(psRISubEntry);
 
 	/* Release RI lock*/
 	_RIUnlock();
@@ -1062,7 +1349,7 @@ PVRSRV_ERROR RIDeleteMEMDESCEntryKM(RI_HANDLE hRIHandle)
 	 */
 	hRIHandle = NULL;
 
-	return PVRSRV_OK;
+	return eError;
 }
 
 /*!
@@ -1083,9 +1370,9 @@ PVRSRV_ERROR RIDeleteListKM(void)
 
 	_RILock();
 
-	if (g_pRIHashTable)
+	if (g_pPMR2RIListHashTable)
 	{
-		eResult = HASH_Iterate(g_pRIHashTable, (HASH_pfnCallback)_DeleteAllEntries, NULL);
+		eResult = HASH_Iterate(g_pPMR2RIListHashTable, (HASH_pfnCallback)_DeleteAllEntries, NULL);
 		if (eResult == PVRSRV_ERROR_RESOURCE_UNAVAILABLE)
 		{
 			/*
@@ -1101,9 +1388,9 @@ PVRSRV_ERROR RIDeleteListKM(void)
 	 * still entries left in the per-process hash table because they were added with
 	 * RIWriteProcListEntryKM() and have no PMR parent associated.
 	 */
-	if (g_pProcHashTable)
+	if (g_PID2RISublistHashTable)
 	{
-		eResult = HASH_Iterate(g_pProcHashTable, (HASH_pfnCallback) _DeleteAllProcEntries, NULL);
+		eResult = HASH_Iterate(g_PID2RISublistHashTable, (HASH_pfnCallback) _DeleteAllProcEntries, NULL);
 		if (eResult == PVRSRV_ERROR_RESOURCE_UNAVAILABLE)
 		{
 			/*
@@ -1207,13 +1494,13 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 	{
 	case RI_GET_STATE_MEMDESCS_LIST_START:
 		/* look-up pid in Hash Table, to obtain first entry for pid */
-		hashData = HASH_Retrieve_Extended(g_pProcHashTable, (void *)&hashKey);
+		hashData = HASH_Retrieve_Extended(g_PID2RISublistHashTable, (void *)&hashKey);
 		if (hashData)
 		{
 			if (*ppHandle)
 			{
 				psRISubEntry = (RI_SUBLIST_ENTRY *)*ppHandle;
-				if (psRISubEntry->valid != _VALID_RI_SUBLIST_ENTRY)
+				if (!IS_VALID(psRISubEntry))
 				{
 					psRISubEntry = NULL;
 				}
@@ -1221,7 +1508,7 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 			else
 			{
 				psRISubEntry = IMG_CONTAINER_OF((PDLLIST_NODE)hashData, RI_SUBLIST_ENTRY, sProcListNode);
-				if (psRISubEntry->valid != _VALID_RI_SUBLIST_ENTRY)
+				if (!IS_VALID(psRISubEntry))
 				{
 					psRISubEntry = NULL;
 				}
@@ -1232,7 +1519,7 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 		{
 			PDLLIST_NODE psNextProcListNode = dllist_get_next_node(&psRISubEntry->sProcListNode);
 
-			if (psRISubEntry->bIsImport)
+			if (IS_IMPORT(psRISubEntry))
 			{
 				ui64TotalImport += psRISubEntry->ui64Size;
 			}
@@ -1248,8 +1535,8 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 
 			if (szProcName[0] == '\0')
 			{
-				OSStringLCopy(szProcName, (pid == PVR_SYS_ALLOC_PID) ?
-						PVRSRV_MODNAME : psRISubEntry->ai8ProcName, RI_PROC_BUF_SIZE);
+				OSStringSafeCopy(szProcName, (pid == PVR_SYS_ALLOC_PID) ?
+						PVRSRV_MODNAME : GET_PROC(psRISubEntry), RI_PROC_BUF_SIZE);
 			}
 
 
@@ -1310,22 +1597,17 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 
 			if (szProcName[0] == '\0')
 			{
-				OSStringLCopy(szProcName, PVRSRV_MODNAME, RI_PROC_BUF_SIZE);
+				OSStringSafeCopy(szProcName, PVRSRV_MODNAME, RI_PROC_BUF_SIZE);
 			}
 			if (psSysAllocNode != NULL && psSysAllocNode != &g_sSysAllocPidListHead)
 			{
-				IMG_DEVMEM_SIZE_T uiPMRPhysicalBacking, uiPMRLogicalSize = 0;
-
-				psRIEntry = IMG_CONTAINER_OF((PDLLIST_NODE)psSysAllocNode, RI_LIST_ENTRY, sSysAllocListNode);
+				psRIEntry = IMG_CONTAINER_OF((PDLLIST_NODE)psSysAllocNode, RI_LIST_ENTRY, sListNode);
 				_GeneratePMREntryString(psRIEntry,
 										IMG_TRUE,
 										RI_PMR_ENTRY_BUF_SIZE,
 										acStringBuffer);
-				PMR_LogicalSize(psRIEntry->psPMR,
-								&uiPMRLogicalSize);
-				ui64TotalPMRAlloc += uiPMRLogicalSize;
-				PMR_PhysicalSize(psRIEntry->psPMR, &uiPMRPhysicalBacking);
-				ui64TotalPMRBacked += uiPMRPhysicalBacking;
+				ui64TotalPMRAlloc += GET_LOGICAL_SIZE(psRIEntry);
+				ui64TotalPMRBacked += GET_PHYSICAL_SIZE(psRIEntry);
 
 				ui32ProcessedSysAllocPMRCount++;
 				if (ui32ProcessedSysAllocPMRCount > g_ui32SysAllocPMRCount+1)
@@ -1348,35 +1630,32 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 			/* Iterate through the 'touched' PMRs and display details */
 			if (!psNode)
 			{
-				psNode = dllist_get_next_node(&sListFirst);
+				psNode = dllist_get_next_node(&g_sClientsListHead);
 			}
 			else
 			{
 				psNode = dllist_get_next_node(psNode);
 			}
 
-			while ((psNode != NULL && psNode != &sListFirst) &&
+			while ((psNode != NULL && psNode != &g_sClientsListHead) &&
 					!bPMRToDisplay)
 			{
 				psRIEntry =	IMG_CONTAINER_OF(psNode, RI_LIST_ENTRY, sListNode);
 				if (psRIEntry->pid == pid)
 				{
-					IMG_DEVMEM_SIZE_T uiPMRPhysicalBacking, uiPMRLogicalSize = 0;
-
 					/* This PMR was 'touched', so display details and unflag it*/
 					_GeneratePMREntryString(psRIEntry,
 											IMG_TRUE,
 											RI_PMR_ENTRY_BUF_SIZE,
 											acStringBuffer);
-					PMR_LogicalSize(psRIEntry->psPMR, &uiPMRLogicalSize);
-					ui64TotalPMRAlloc += uiPMRLogicalSize;
-					PMR_PhysicalSize(psRIEntry->psPMR, &uiPMRPhysicalBacking);
-					ui64TotalPMRBacked += uiPMRPhysicalBacking;
+					ui64TotalPMRAlloc += GET_LOGICAL_SIZE(psRIEntry);
+					ui64TotalPMRBacked += GET_PHYSICAL_SIZE(psRIEntry);
 
 					/* Remember the name of the process for 1 PMR for the summary */
 					if (szProcName[0] == '\0')
 					{
-						OSStringLCopy(szProcName, psRIEntry->ai8ProcName, RI_PROC_BUF_SIZE);
+						psRISubEntry = IMG_CONTAINER_OF(dllist_get_next_node(&(psRIEntry->sSubListFirst)), RI_SUBLIST_ENTRY, sListNode);
+						OSStringSafeCopy(szProcName, GET_PROC(psRISubEntry), RI_PROC_BUF_SIZE);
 					}
 					bPMRToDisplay = IMG_TRUE;
 				}
@@ -1386,7 +1665,7 @@ IMG_BOOL RIGetListEntryKM(IMG_PID pid,
 				}
 			}
 
-			if (psNode == NULL || (psNode == &sListFirst))
+			if (psNode == NULL || (psNode == &g_sClientsListHead))
 			{
 				g_bNextGetState = RI_GET_STATE_PMR_SUMMARY;
 			}
@@ -1445,15 +1724,15 @@ static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry,
 	const IMG_CHAR *pszAnnotationText;
 	IMG_PID uiRIPid = 0;
 	PMR* psRIPMR = NULL;
-	IMG_UINT32 ui32RIPMRFlags = 0;
-	IMG_BOOL bHostDevice = psRISubEntry->ui32DevID == PVRSRV_HOST_DEVICE_ID;
+	IMG_BOOL bSysPMR = IMG_FALSE;
+	IMG_BOOL bHostDevice = IS_HOST_DEVICE(psRISubEntry);
 	IMG_CHAR szDeviceID[RI_DEV_ID_BUF_SIZE];
 
 	if (psRISubEntry->psRI != NULL)
 	{
 		uiRIPid = psRISubEntry->psRI->pid;
-		psRIPMR = psRISubEntry->psRI->psPMR;
-		ui32RIPMRFlags = psRISubEntry->psRI->ui32RIPMRFlags;
+		psRIPMR = (PMR*)GET_ADDR(psRISubEntry->psRI);
+		bSysPMR = IS_SYSPMR(psRISubEntry->psRI);
 	}
 
 	OSSNPrintf(szEntryFormat,
@@ -1468,7 +1747,7 @@ static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry,
 				RI_MEMDESC_ENTRY_PROC_BUF_SIZE,
 				RI_MEMDESC_ENTRY_PROC_FRMT,
 				psRISubEntry->pid,
-				psRISubEntry->ai8ProcName);
+				GET_PROC(psRISubEntry));
 	}
 
 	if (!bHostDevice)
@@ -1476,27 +1755,27 @@ static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry,
 		OSSNPrintf(szDeviceID,
 				   sizeof(szDeviceID),
 				   "%-3d",
-				   psRISubEntry->ui32DevID);
+				   GET_DEVICE_ID(psRISubEntry));
 	}
 
-	if (psRISubEntry->bIsImport && psRIPMR)
+	if (IS_IMPORT(psRISubEntry) && psRIPMR)
 	{
 		OSSNPrintf((IMG_CHAR *)&szImport,
 		           RI_MEMDESC_ENTRY_IMPORT_BUF_SIZE,
 		           RI_MEMDESC_ENTRY_IMPORT_FRMT,
 		           uiRIPid);
 		/* Set pszAnnotationText to that of the 'parent' PMR RI entry */
-		pszAnnotationText = PMR_GetAnnotation(psRIPMR);
+		pszAnnotationText = GET_NAME(psRISubEntry->psRI);
 	}
-	else if (!psRISubEntry->bIsSuballoc && psRIPMR)
+	else if (!IS_SUBALLOC(psRISubEntry) && psRIPMR)
 	{
 		/* Set pszAnnotationText to that of the 'parent' PMR RI entry */
-		pszAnnotationText = PMR_GetAnnotation(psRIPMR);
+		pszAnnotationText = GET_NAME(psRISubEntry->psRI);
 	}
 	else
 	{
 		/* Set pszAnnotationText to that of the MEMDESC RI entry */
-		pszAnnotationText = psRISubEntry->ai8TextB;
+		pszAnnotationText = psRISubEntry->pszTextB;
 	}
 
 	/* Don't print memdescs if they are local imports
@@ -1504,7 +1783,7 @@ static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry,
 	 */
 	if (bDebugFs &&
 		((psRISubEntry->sVAddr.uiAddr + psRISubEntry->ui64Offset) == 0) &&
-		(psRISubEntry->bIsImport && ((psRISubEntry->pid == uiRIPid)
+		(IS_IMPORT(psRISubEntry) && ((psRISubEntry->pid == uiRIPid)
 									 || (psRISubEntry->pid == PVR_SYS_ALLOC_PID))))
 	{
 		/* Don't print this entry */
@@ -1523,8 +1802,11 @@ static void _GenerateMEMDESCEntryString(RI_SUBLIST_ENTRY *psRISubEntry,
 				   (bDebugFs ? "" : (char *)szProc),
 				   psRISubEntry->ui64Size,
 				   psRIPMR,
-				   (psRISubEntry->bIsImport ? (char *)&szImport : ""),
-				   (!psRISubEntry->bIsImport && (ui32RIPMRFlags & RI_FLAG_SYSALLOC_PMR) && (psRISubEntry->pid != PVR_SYS_ALLOC_PID)) ? g_szSysAllocImport : "",
+				   (IS_IMPORT(psRISubEntry) ? (char *)&szImport : ""),
+				   (!IS_IMPORT(psRISubEntry) &&
+				    (bSysPMR) &&
+				    (psRISubEntry->pid != PVR_SYS_ALLOC_PID)) ? g_szSysAllocImport : "",
+				   (IS_RACC(psRISubEntry) ? RI_FREED_BY_DRIVER : ""),
 				   (bDebugFs ? '\n' : ' '));
 	}
 }
@@ -1538,16 +1820,10 @@ static void _GeneratePMREntryString(RI_LIST_ENTRY *psRIEntry,
 	const IMG_CHAR*   pszAnnotationText;
 	const IMG_CHAR*   pszHeapText;
 
-	IMG_DEVMEM_SIZE_T uiLogicalSize = 0;
-	IMG_DEVMEM_SIZE_T uiPhysicalSize = 0;
 	IMG_CHAR          szEntryFormat[RI_PMR_ENTRY_FRMT_SIZE];
-	IMG_BOOL          bHostDevice = psRIEntry->ui32DevID == PVRSRV_HOST_DEVICE_ID;
+	IMG_BOOL          bHostDevice = IS_HOST_DEVICE(psRIEntry);
 	IMG_CHAR          szDeviceID[RI_DEV_ID_BUF_SIZE];
 
-	PMR_LogicalSize(psRIEntry->psPMR, &uiLogicalSize);
-
-	PMR_PhysicalSize(psRIEntry->psPMR, &uiPhysicalSize);
-
 	OSSNPrintf(szEntryFormat,
 			RI_PMR_ENTRY_FRMT_SIZE,
 			RI_PMR_ENTRY_FRMT,
@@ -1555,17 +1831,17 @@ static void _GeneratePMREntryString(RI_LIST_ENTRY *psRIEntry,
 			PHYS_HEAP_NAME_SIZE);
 
 	/* Set pszAnnotationText to that PMR RI entry */
-	pszAnnotationText = (IMG_PCHAR) PMR_GetAnnotation(psRIEntry->psPMR);
+	pszAnnotationText = GET_NAME(psRIEntry);
 
 	/* Acquire PhysHeap Name to that PMR RI entry */
-	pszHeapText = PhysHeapName((PMR_PhysHeap(psRIEntry->psPMR)));
+	pszHeapText = PhysHeapName(GET_HEAP(psRIEntry));
 
 	if (!bHostDevice)
 	{
 		OSSNPrintf(szDeviceID,
 				   sizeof(szDeviceID),
 				   "%-3d",
-				   psRIEntry->ui32DevID);
+				   GET_DEVICE_ID(psRIEntry));
 	}
 
 	OSSNPrintf(pszEntryString,
@@ -1574,11 +1850,12 @@ static void _GeneratePMREntryString(RI_LIST_ENTRY *psRIEntry,
 	           (bDebugFs ? "" : "   "),
 	           psRIEntry->pid,
 	           (bHostDevice ? "-  " : szDeviceID),
-	           (void*)psRIEntry->psPMR,
+	           GET_ADDR(psRIEntry),
 	           pszAnnotationText,
 	           pszHeapText,
-	           uiLogicalSize,
-	           uiPhysicalSize,
+	           GET_LOGICAL_SIZE(psRIEntry),
+	           GET_PHYSICAL_SIZE(psRIEntry),
+	           (IS_RACC(psRIEntry) ? RI_FREED_BY_DRIVER : ""),
 	           (bDebugFs ? '\n' : ' '));
 }
 
@@ -1608,17 +1885,16 @@ static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid)
 	IMG_PID hashKey;
 	PMR *pPMRHashKey = psPMR;
 	IMG_BOOL bDisplayedThisPMR = IMG_FALSE;
-	IMG_UINT64 ui64LogicalSize = 0;
 
 	PVR_RETURN_IF_INVALID_PARAM(psPMR);
 
-	if (g_pRIHashTable && g_pProcHashTable)
+	if (g_pPMR2RIListHashTable && g_PID2RISublistHashTable)
 	{
 		if (pid != 0)
 		{
 			/* look-up pid in Hash Table */
 			hashKey = pid;
-			hashData = HASH_Retrieve_Extended (g_pProcHashTable, (void *)&hashKey);
+			hashData = HASH_Retrieve_Extended (g_PID2RISublistHashTable, (void *)&hashKey);
 			if (hashData)
 			{
 				psRISubEntry = IMG_CONTAINER_OF((PDLLIST_NODE)hashData, RI_SUBLIST_ENTRY, sProcListNode);
@@ -1631,7 +1907,7 @@ static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid)
 		else
 		{
 			/* Look-up psPMR in Hash Table */
-			hashData = HASH_Retrieve_Extended (g_pRIHashTable, (void *)&pPMRHashKey);
+			hashData = HASH_Retrieve_Extended (g_pPMR2RIListHashTable, (void *)&pPMRHashKey);
 			psRIEntry = (RI_LIST_ENTRY *)hashData;
 		}
 		if (!psRIEntry)
@@ -1645,13 +1921,11 @@ static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid)
 			/* Output details for RI entry */
 			if (!pid)
 			{
-				PMR_LogicalSize(psPMR, (IMG_DEVMEM_SIZE_T*)&ui64LogicalSize);
-
 				_RIOutput (("%s <%p> suballocs:%d size:0x%010" IMG_UINT64_FMTSPECx,
-				            PMR_GetAnnotation(psRIEntry->psPMR),
-				            psRIEntry->psPMR,
+				            GET_NAME(psRIEntry),
+				            GET_ADDR(psRIEntry),
 				            (IMG_UINT)psRIEntry->ui16SubListCount,
-				            ui64LogicalSize));
+				            GET_LOGICAL_SIZE(psRIEntry)));
 				bDisplayedThisPMR = IMG_TRUE;
 			}
 			ui16SubEntriesParsed = 0;
@@ -1677,13 +1951,11 @@ static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid)
 						}
 						if (!bDisplayedThisPMR)
 						{
-							PMR_LogicalSize(psPMR, (IMG_DEVMEM_SIZE_T*)&ui64LogicalSize);
-
 							_RIOutput (("%s <%p> suballocs:%d size:0x%010" IMG_UINT64_FMTSPECx,
-								    PMR_GetAnnotation(psRIEntry->psPMR),
-								    psRIEntry->psPMR,
+								    GET_NAME(psRIEntry),
+								    GET_ADDR(psRIEntry),
 								    (IMG_UINT)psRIEntry->ui16SubListCount,
-								    ui64LogicalSize));
+								    GET_LOGICAL_SIZE(psRIEntry)));
 							bDisplayedThisPMR = IMG_TRUE;
 						}
 					}
@@ -1777,9 +2049,9 @@ static PVRSRV_ERROR _DumpList(PMR *psPMR, IMG_PID pid)
 ******************************************************************************/
 PVRSRV_ERROR RIDumpAllKM(void)
 {
-	if (g_pRIHashTable)
+	if (g_pPMR2RIListHashTable)
 	{
-		return HASH_Iterate(g_pRIHashTable, (HASH_pfnCallback)_DumpAllEntries, NULL);
+		return HASH_Iterate(g_pPMR2RIListHashTable, (HASH_pfnCallback)_DumpAllEntries, NULL);
 	}
 	return PVRSRV_OK;
 }
@@ -1803,7 +2075,7 @@ PVRSRV_ERROR RIDumpProcessKM(IMG_PID pid)
 	PVRSRV_ERROR eError;
 	IMG_UINT32 dummyPMR;
 
-	if (!g_pProcHashTable)
+	if (!g_PID2RISublistHashTable)
 	{
 		return PVRSRV_OK;
 	}
@@ -1835,112 +2107,129 @@ PVRSRV_ERROR RIDumpProcessKM(IMG_PID pid)
             specified heap type (in bytes).
 
 ******************************************************************************/
-static IMG_INT32 _TotalAllocsForProcess(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapType)
+static IMG_INT32 _TotalAllocsForProcess(const IMG_PID pid, const PHYS_HEAP_TYPE ePhysHeapType)
 {
-	RI_LIST_ENTRY *psRIEntry = NULL;
-	RI_SUBLIST_ENTRY *psInitialRISubEntry = NULL;
-	RI_SUBLIST_ENTRY *psRISubEntry = NULL;
-	uintptr_t hashData = 0;
-	IMG_PID hashKey;
 	IMG_INT32 i32TotalPhysical = 0;
 
-	if (g_pRIHashTable && g_pProcHashTable)
+	if (g_pPMR2RIListHashTable && g_PID2RISublistHashTable)
 	{
 		if (pid == PVR_SYS_ALLOC_PID)
 		{
-			IMG_UINT32 ui32ProcessedSysAllocPMRCount = 0;
 			DLLIST_NODE *psSysAllocNode = NULL;
 
 			OSLockAcquire(g_hSysAllocPidListLock);
-			psSysAllocNode = dllist_get_next_node(&g_sSysAllocPidListHead);
-			while (psSysAllocNode && psSysAllocNode != &g_sSysAllocPidListHead)
+
+			for (psSysAllocNode = dllist_get_next_node(&g_sSysAllocPidListHead);
+			     psSysAllocNode != NULL && psSysAllocNode != &g_sSysAllocPidListHead;
+			     psSysAllocNode = dllist_get_next_node(psSysAllocNode))
 			{
-				psRIEntry = IMG_CONTAINER_OF((PDLLIST_NODE)psSysAllocNode, RI_LIST_ENTRY, sSysAllocListNode);
-				ui32ProcessedSysAllocPMRCount++;
-				if (PhysHeapGetType(PMR_PhysHeap(psRIEntry->psPMR)) == ePhysHeapType)
+				const RI_LIST_ENTRY *const psRIEntry =
+					IMG_CONTAINER_OF((PDLLIST_NODE)psSysAllocNode, RI_LIST_ENTRY, sListNode);
+
+				/* Exclude RACC entries from the stats. This memory should have
+				 * been already freed during connection destruction so they should
+				 * not affect figure showing memory usage. Also RACC entries existence
+				 * is to show unfreed memory in `gpu_mem_area`, not to affect other
+				 * process stats. Finally if the RI entry exists only due to sub-entries
+				 * referencing it but the underlying PMR has been freed don't include
+				 * it in the total stats. */
+				if (PhysHeapGetType(GET_HEAP(psRIEntry)) == ePhysHeapType &&
+				    !IS_RACC(psRIEntry) && !HAS_PMR_INFO(psRIEntry))
 				{
-					IMG_UINT64 ui64PhysicalSize;
+					IMG_UINT64 ui64PhysicalSize = GET_PHYSICAL_SIZE(psRIEntry);
 
-					PMR_PhysicalSize(psRIEntry->psPMR, (IMG_DEVMEM_SIZE_T*)&ui64PhysicalSize);
-					if (((IMG_UINT64)i32TotalPhysical + ui64PhysicalSize > 0x7fffffff))
+					if (((IMG_UINT64)i32TotalPhysical + ui64PhysicalSize > IMG_INT32_MAX))
 					{
-						PVR_DPF((PVR_DBG_WARNING, "%s: i32TotalPhysical exceeding size for i32",__func__));
+						PVR_DPF((PVR_DBG_WARNING, "%s: i32TotalPhysical exceeding size for i32",
+						         __func__));
 					}
 					i32TotalPhysical += (IMG_INT32)(ui64PhysicalSize & 0x00000000ffffffff);
 				}
-				psSysAllocNode = dllist_get_next_node(psSysAllocNode);
 			}
+
 			OSLockRelease(g_hSysAllocPidListLock);
 		}
 		else
 		{
+			RI_LIST_ENTRY *psRIEntry = NULL;
+			RI_SUBLIST_ENTRY *psInitialRISubEntry = NULL, *psRISubEntry = NULL;
+			uintptr_t hashData = 0;
+
 			if (pid != 0)
 			{
 				/* look-up pid in Hash Table */
-				hashKey = pid;
-				hashData = HASH_Retrieve_Extended (g_pProcHashTable, (void *)&hashKey);
+				IMG_PID hashKey = pid;
+				hashData = HASH_Retrieve_Extended(g_PID2RISublistHashTable, (void *)&hashKey);
 				if (hashData)
 				{
 					psInitialRISubEntry = IMG_CONTAINER_OF((PDLLIST_NODE)hashData, RI_SUBLIST_ENTRY, sProcListNode);
-					psRISubEntry = psInitialRISubEntry;
-					if (psRISubEntry)
+					if (psInitialRISubEntry != NULL)
 					{
-						psRIEntry = psRISubEntry->psRI;
+						psRISubEntry = psInitialRISubEntry;
+						psRIEntry = psInitialRISubEntry->psRI;
 					}
 				}
 			}
 
-			while (psRISubEntry && psRIEntry)
+			while (psRISubEntry != NULL && psRIEntry != NULL)
 			{
-				if (!psRISubEntry->bIsImport && !(psRIEntry->ui32RIPMRFlags & RI_FLAG_PMR_PHYS_COUNTED_BY_DEBUGFS) &&
-					(pid == PVR_SYS_ALLOC_PID || !(psRIEntry->ui32RIPMRFlags & RI_FLAG_SYSALLOC_PMR)) &&
-					(PhysHeapGetType(PMR_PhysHeap(psRIEntry->psPMR)) == ePhysHeapType))
-				{
-					IMG_UINT64 ui64PhysicalSize;
+				DLLIST_NODE *psNextNode;
 
+				if (!IS_IMPORT(psRISubEntry) &&
+				    !IS_RACC(psRISubEntry) &&
+					!IS_COUNTED_BY_DEBUGFS(psRIEntry) &&
+				    !IS_SYSPMR(psRIEntry) &&
+				    (PhysHeapGetType(GET_HEAP(psRIEntry)) == ePhysHeapType))
+				{
+					IMG_UINT64 ui64PhysicalSize = GET_PHYSICAL_SIZE(psRIEntry);
 
-					PMR_PhysicalSize(psRIEntry->psPMR, (IMG_DEVMEM_SIZE_T*)&ui64PhysicalSize);
-					if (((IMG_UINT64)i32TotalPhysical + ui64PhysicalSize > 0x7fffffff))
+					if (((IMG_UINT64)i32TotalPhysical + ui64PhysicalSize > IMG_INT32_MAX))
 					{
-						PVR_DPF((PVR_DBG_WARNING, "%s: i32TotalPhysical exceeding size for i32",__func__));
+						PVR_DPF((PVR_DBG_WARNING, "%s: i32TotalPhysical exceeding size for i32",
+						         __func__));
 					}
+
 					i32TotalPhysical += (IMG_INT32)(ui64PhysicalSize & 0x00000000ffffffff);
-					psRIEntry->ui32RIPMRFlags |= RI_FLAG_PMR_PHYS_COUNTED_BY_DEBUGFS;
+					BIT_SET(psRIEntry->ui16Flags, RI_PMR_PHYS_COUNTED_BY_DEBUGFS_FLAG);
 				}
-				if ((dllist_get_next_node(&(psRISubEntry->sProcListNode)) == NULL) ||
-					(dllist_get_next_node(&(psRISubEntry->sProcListNode)) == (PDLLIST_NODE)hashData))
+
+				psNextNode = dllist_get_next_node(&(psRISubEntry->sProcListNode));
+				if (psNextNode == NULL || psNextNode == (PDLLIST_NODE)hashData)
 				{
 					psRISubEntry = NULL;
 					psRIEntry = NULL;
 				}
 				else
 				{
-					psRISubEntry = IMG_CONTAINER_OF(dllist_get_next_node(&(psRISubEntry->sProcListNode)),
-					                                RI_SUBLIST_ENTRY, sProcListNode);
+					psRISubEntry = IMG_CONTAINER_OF(psNextNode, RI_SUBLIST_ENTRY, sProcListNode);
 					if (psRISubEntry)
 					{
 						psRIEntry = psRISubEntry->psRI;
 					}
 				}
 			}
+
 			psRISubEntry = psInitialRISubEntry;
 			if (psRISubEntry)
 			{
 				psRIEntry = psRISubEntry->psRI;
 			}
-			while (psRISubEntry && psRIEntry)
+
+			while (psRISubEntry != NULL && psRIEntry != NULL)
 			{
-				psRIEntry->ui32RIPMRFlags &= ~RI_FLAG_PMR_PHYS_COUNTED_BY_DEBUGFS;
-				if ((dllist_get_next_node(&(psRISubEntry->sProcListNode)) == NULL) ||
-					(dllist_get_next_node(&(psRISubEntry->sProcListNode)) == (PDLLIST_NODE)hashData))
+				const DLLIST_NODE *const psNextNode =
+				    dllist_get_next_node(&(psRISubEntry->sProcListNode));
+
+				BIT_UNSET(psRIEntry->ui16Flags, RI_PMR_PHYS_COUNTED_BY_DEBUGFS_FLAG);
+
+				if (psNextNode == NULL || psNextNode == (PDLLIST_NODE)hashData)
 				{
 					psRISubEntry = NULL;
 					psRIEntry = NULL;
 				}
 				else
 				{
-					psRISubEntry = IMG_CONTAINER_OF(dllist_get_next_node(&(psRISubEntry->sProcListNode)),
-					                                RI_SUBLIST_ENTRY, sProcListNode);
+					psRISubEntry = IMG_CONTAINER_OF(psNextNode, RI_SUBLIST_ENTRY, sProcListNode);
 					if (psRISubEntry)
 					{
 						psRIEntry = psRISubEntry->psRI;
@@ -1949,6 +2238,7 @@ static IMG_INT32 _TotalAllocsForProcess(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapTyp
 			}
 		}
 	}
+
 	return i32TotalPhysical;
 }
 
@@ -1965,19 +2255,13 @@ static IMG_INT32 _TotalAllocsForProcess(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapTyp
  @Return	Amount of physical backing allocated (in bytes)
 
 ******************************************************************************/
-IMG_INT32 RITotalAllocProcessKM(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapType)
+IMG_INT32 RITotalAllocProcessUnlocked(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapType)
 {
 	IMG_INT32 i32BackingTotal = 0;
 
-	if (g_pProcHashTable)
+	if (g_PID2RISublistHashTable)
 	{
-		/* Acquire RI lock*/
-		_RILock();
-
 		i32BackingTotal = _TotalAllocsForProcess(pid, ePhysHeapType);
-
-		/* Release RI lock*/
-		_RIUnlock();
 	}
 	return i32BackingTotal;
 }
@@ -2015,12 +2299,12 @@ static PVRSRV_ERROR _DumpProcessList(PMR *psPMR,
 
 	PVR_RETURN_IF_INVALID_PARAM(psPMR);
 
-	if (g_pRIHashTable && g_pProcHashTable)
+	if (g_pPMR2RIListHashTable && g_PID2RISublistHashTable)
 	{
 		PVR_ASSERT(psPMR && pid);
 
 		/* Look-up psPMR in Hash Table */
-		hashData = HASH_Retrieve_Extended (g_pRIHashTable, (void *)&pPMRHashKey);
+		hashData = HASH_Retrieve_Extended (g_pPMR2RIListHashTable, (void *)&pPMRHashKey);
 		psRIEntry = (RI_LIST_ENTRY *)hashData;
 
 		if (!psRIEntry)
@@ -2078,7 +2362,7 @@ PVRSRV_ERROR RIDumpProcessListKM(PMR *psPMR,
 {
 	PVRSRV_ERROR eError;
 
-	if (!g_pProcHashTable)
+	if (!g_PID2RISublistHashTable)
 	{
 		return PVRSRV_OK;
 	}
@@ -2098,6 +2382,132 @@ PVRSRV_ERROR RIDumpProcessListKM(PMR *psPMR,
 }
 #endif
 
+static PVRSRV_ERROR _MarkRACCEntries(uintptr_t k, uintptr_t v, void *psConnection)
+{
+	DLLIST_NODE *psListHead = (DLLIST_NODE *) v;
+	DLLIST_NODE *psNextNode = psListHead;
+
+	PVR_UNREFERENCED_PARAMETER(k);
+
+	do
+	{
+		RI_SUBLIST_ENTRY *psRISubEntry = IMG_CONTAINER_OF(psNextNode, RI_SUBLIST_ENTRY,
+		                                                  sProcListNode);
+
+		if (psRISubEntry->psConnection == psConnection)
+		{
+			RI_LIST_ENTRY *psRIEntry = psRISubEntry->psRI;
+
+			BIT_SET(psRISubEntry->ui16Flags, RI_RACC_FLAG);
+
+			/* RI sub-entry may not have an RI entry associated with it. If that's the
+			 * case just skip processing it. */
+			if (psRIEntry != NULL)
+			{
+				if (!IS_RACC(psRIEntry) &&
+				    !HAS_PMR_INFO(psRIEntry) &&
+				    /* Mark as RACC only if the entry doesn't belong to the system process.
+				     * System process allocations are alive for the whole driver lifetime
+					 * hence they will always exist at a connection closed for every process
+					 * that references them. */
+				    psRIEntry->pid != PVR_SYS_ALLOC_PID)
+				{
+					PVRSRV_ERROR eError;
+
+					eError = _RICreateAndSetPmrInfo(psRIEntry);
+					PVR_LOG_RETURN_IF_ERROR(eError, "_RICreateAndSetPmrInfo");
+
+					BIT_SET(psRIEntry->ui16Flags, RI_RACC_FLAG);
+				}
+				else
+				{
+					PVR_DPF((PVR_DBG_MESSAGE, "RIEntry(%s) is already RACC", GET_NAME(psRIEntry)));
+				}
+			}
+		}
+
+		psNextNode = dllist_get_next_node(psNextNode);
+	} while (psNextNode != NULL && psNextNode != psListHead);
+
+	return PVRSRV_OK;
+}
+
+void RIConnectionClosed(void* psConnection)
+{
+	PVRSRV_ERROR eError;
+	if (g_PID2RISublistHashTable)
+	{
+		_RILock();
+		eError = HASH_Iterate(g_PID2RISublistHashTable, (HASH_pfnCallback)_MarkRACCEntries, psConnection);
+		PVR_LOG_IF_FALSE(eError == PVRSRV_OK, "_MarkRACCEntries");
+		_RIUnlock();
+	}
+}
+
+static PVRSRV_ERROR DeleteRACCEntry(RI_SUBLIST_ENTRY *psRISubEntry)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	RI_LIST_ENTRY *psRIEntry = psRISubEntry->psRI;
+
+	PVR_LOG_IF_FALSE_VA(PVR_DBG_WARNING, IS_RACC(psRISubEntry), "Non-RACC entry(%s)",
+	                    psRISubEntry->pszTextB);
+
+	eError = RIDeleteMemdescEntryUnlocked(psRISubEntry);
+	PVR_LOG_IF_ERROR(eError, "RIDeleteMemdescEntryUnlocked");
+
+	/* RI sub-entry may not have an RI entry associated with it. If that's the
+	 * case just skip processing it. */
+	if (psRIEntry != NULL)
+	{
+		if (psRIEntry->ui16SubListCount)
+		{
+			PVR_DPF((PVR_DBG_MESSAGE, "%p: More than 1 sublist present! (%s)",
+			         psRIEntry, __func__));
+		}
+		else
+		{
+			eError = RIDeletePMREntryUnlocked(psRIEntry);
+			PVR_LOG_IF_ERROR(eError, "RIDeletePMREntryUnlocked");
+		}
+	}
+
+	return eError;
+}
+
+PVRSRV_ERROR RIDeleteEntriesForPID(IMG_PID pid)
+{
+	DLLIST_NODE *psListHead;
+	PVRSRV_ERROR eError = PVRSRV_OK;
+	IMG_PID hashKey  = pid;
+
+	_RILock();
+
+	PVR_GOTO_IF_FALSE(g_PID2RISublistHashTable != NULL, ErrHashError);
+
+	psListHead = (DLLIST_NODE *) HASH_Retrieve_Extended(g_PID2RISublistHashTable,
+	                                                    (void *) &hashKey);
+
+	while (psListHead != NULL)
+	{
+		DLLIST_NODE *psNextNode = dllist_get_next_node(psListHead);
+		RI_SUBLIST_ENTRY *psRISubEntry = IMG_CONTAINER_OF(psListHead, RI_SUBLIST_ENTRY,
+		                                                  sProcListNode);
+
+		eError = DeleteRACCEntry(psRISubEntry);
+		PVR_LOG_GOTO_IF_ERROR(eError, "DeleteRACCEntry", ErrUnlockAndReturn);
+
+		psListHead = psNextNode;
+	}
+
+ErrHashError:
+    eError = PVRSRV_ERROR_UNABLE_TO_RETRIEVE_HASH_VALUE;
+
+ErrUnlockAndReturn:
+	_RIUnlock();
+
+	return eError;
+}
+
 static PVRSRV_ERROR _DumpAllEntries (uintptr_t k, uintptr_t v, void* pvPriv)
 {
 	RI_LIST_ENTRY *psRIEntry = (RI_LIST_ENTRY *)v;
@@ -2105,7 +2515,7 @@ static PVRSRV_ERROR _DumpAllEntries (uintptr_t k, uintptr_t v, void* pvPriv)
 	PVR_UNREFERENCED_PARAMETER (k);
 	PVR_UNREFERENCED_PARAMETER (pvPriv);
 
-	return RIDumpListKM(psRIEntry->psPMR);
+	return RIDumpListKM(GET_ADDR(psRIEntry));
 }
 
 static PVRSRV_ERROR _DeleteAllEntries (uintptr_t k, uintptr_t v, void* pvPriv)
@@ -2129,7 +2539,7 @@ static PVRSRV_ERROR _DeleteAllEntries (uintptr_t k, uintptr_t v, void* pvPriv)
 		 * If we've deleted the Hash table, return
 		 * an error to stop the iterator...
 		 */
-		if (!g_pRIHashTable)
+		if (!g_pPMR2RIListHashTable)
 		{
 			eResult = PVRSRV_ERROR_RESOURCE_UNAVAILABLE;
 		}
@@ -2146,7 +2556,7 @@ static PVRSRV_ERROR _DeleteAllProcEntries (uintptr_t k, uintptr_t v, void* pvPri
 	PVR_UNREFERENCED_PARAMETER (pvPriv);
 
 	eResult = RIDeleteMEMDESCEntryKM((RI_HANDLE) psRISubEntry);
-	if (eResult == PVRSRV_OK && !g_pProcHashTable)
+	if (eResult == PVRSRV_OK && !g_PID2RISublistHashTable)
 	{
 		/*
 		 * If we've deleted the Hash table, return
diff --git a/drivers/gpu/drm/img-rogue/ri_server.h b/drivers/gpu/drm/img-rogue/ri_server.h
index 69266b8b5d89..a8bcd9f32039 100644
--- a/drivers/gpu/drm/img-rogue/ri_server.h
+++ b/drivers/gpu/drm/img-rogue/ri_server.h
@@ -63,16 +63,17 @@ PVRSRV_ERROR RIWritePMREntryKM(PMR *psPMR);
 PVRSRV_ERROR RIWritePMREntryWithOwnerKM(PMR *psPMR,
                                         IMG_PID ui32Owner);
 
-PVRSRV_ERROR RIWriteMEMDESCEntryKM(PMR *psPMR,
+PVRSRV_ERROR RIWriteMEMDESCEntryKM(void* psConnection,
+                                   PVRSRV_DEVICE_NODE *psDeviceNode,
+                                   PMR *psPMR,
                                    IMG_UINT32 ui32TextBSize,
                                    const IMG_CHAR *psz8TextB,
                                    IMG_UINT64 uiOffset,
                                    IMG_UINT64 uiSize,
-                                   IMG_BOOL bIsImport,
-                                   IMG_BOOL bIsSuballoc,
+                                   PVRSRV_MEMALLOCFLAGS_T uiFlags,
                                    RI_HANDLE *phRIHandle);
 
-PVRSRV_ERROR RIWriteProcListEntryKM(CONNECTION_DATA *psConnection,
+PVRSRV_ERROR RIWriteProcListEntryKM(void* psConnection,
                                     PVRSRV_DEVICE_NODE *psDeviceNode,
                                     IMG_UINT32 ui32TextBSize,
                                     const IMG_CHAR *psz8TextB,
@@ -101,10 +102,14 @@ PVRSRV_ERROR RIDumpProcessListKM(PMR *psPMR,
                                  IMG_DEV_VIRTADDR *psDevVAddr);
 #endif
 
+void RIConnectionClosed(void* psConnection);
+
+PVRSRV_ERROR RIDeleteEntriesForPID(IMG_PID pid);
+
 IMG_BOOL RIGetListEntryKM(IMG_PID pid,
                           IMG_HANDLE **ppHandle,
                           IMG_CHAR **ppszEntryString);
 
-IMG_INT32 RITotalAllocProcessKM(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapType);
+IMG_INT32 RITotalAllocProcessUnlocked(IMG_PID pid, PHYS_HEAP_TYPE ePhysHeapType);
 
 #endif /* RI_SERVER_H */
diff --git a/drivers/gpu/drm/img-rogue/rogue_trace_events.h b/drivers/gpu/drm/img-rogue/rogue_trace_events.h
index b079d73af784..8952bec0f102 100644
--- a/drivers/gpu/drm/img-rogue/rogue_trace_events.h
+++ b/drivers/gpu/drm/img-rogue/rogue_trace_events.h
@@ -59,9 +59,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define show_usecs_from_ns(ns) \
 	({ \
 		u64 t = ns + (NSEC_PER_USEC / 2); \
-		u32 rem; \
 		do_div(t, NSEC_PER_USEC); \
-		rem = do_div(t, USEC_PER_SEC); \
+		do_div(t, USEC_PER_SEC); \
 	})
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
@@ -558,7 +557,7 @@ TRACE_EVENT_FN(rogue_firmware_activity,
 
 	TP_fast_assign(
 		__entry->timestamp = timestamp;
-		__entry->gpu_id = gpu_id,
+		__entry->gpu_id = gpu_id;
 		__assign_str(task, task);
 		__entry->fw_event = fw_event;
 	),
diff --git a/drivers/gpu/drm/img-rogue/server_cache_bridge.c b/drivers/gpu/drm/img-rogue/server_cache_bridge.c
index bddcd95e0953..b2f5267cc597 100644
--- a/drivers/gpu/drm/img-rogue/server_cache_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_cache_bridge.c
@@ -423,13 +423,16 @@ PVRSRV_ERROR InitCACHEBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CACHE, PVRSRV_BRIDGE_CACHE_CACHEOPQUEUE,
-			      PVRSRVBridgeCacheOpQueue, NULL);
+			      PVRSRVBridgeCacheOpQueue, NULL, sizeof(PVRSRV_BRIDGE_IN_CACHEOPQUEUE),
+			      sizeof(PVRSRV_BRIDGE_OUT_CACHEOPQUEUE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CACHE, PVRSRV_BRIDGE_CACHE_CACHEOPEXEC,
-			      PVRSRVBridgeCacheOpExec, NULL);
+			      PVRSRVBridgeCacheOpExec, NULL, sizeof(PVRSRV_BRIDGE_IN_CACHEOPEXEC),
+			      sizeof(PVRSRV_BRIDGE_OUT_CACHEOPEXEC));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CACHE, PVRSRV_BRIDGE_CACHE_CACHEOPLOG,
-			      PVRSRVBridgeCacheOpLog, NULL);
+			      PVRSRVBridgeCacheOpLog, NULL, sizeof(PVRSRV_BRIDGE_IN_CACHEOPLOG),
+			      sizeof(PVRSRV_BRIDGE_OUT_CACHEOPLOG));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_cmm_bridge.c b/drivers/gpu/drm/img-rogue/server_cmm_bridge.c
index b95f8589ae99..cc658c793d3b 100644
--- a/drivers/gpu/drm/img-rogue/server_cmm_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_cmm_bridge.c
@@ -340,17 +340,16 @@ PVRSRVBridgeDevmemIntAcquireRemoteCtx(IMG_UINT32 ui32DispatchTableEntry,
 			 * This should never fail... */
 			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
 
-			/* Avoid freeing/destroying/releasing the resource a second time below */
-			psContextInt = NULL;
 			/* Release now we have cleaned up creation handles. */
 			UnlockHandle(psConnection->psHandleBase);
 
 		}
 
-		if (psContextInt)
+		else if (psContextInt)
 		{
 			DevmemIntCtxDestroy(psContextInt);
 		}
+
 	}
 
 	return 0;
@@ -373,13 +372,19 @@ PVRSRV_ERROR InitCMMBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CMM, PVRSRV_BRIDGE_CMM_DEVMEMINTEXPORTCTX,
-			      PVRSRVBridgeDevmemIntExportCtx, NULL);
+			      PVRSRVBridgeDevmemIntExportCtx, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTEXPORTCTX),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTEXPORTCTX));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CMM, PVRSRV_BRIDGE_CMM_DEVMEMINTUNEXPORTCTX,
-			      PVRSRVBridgeDevmemIntUnexportCtx, NULL);
+			      PVRSRVBridgeDevmemIntUnexportCtx, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTUNEXPORTCTX),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTUNEXPORTCTX));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_CMM, PVRSRV_BRIDGE_CMM_DEVMEMINTACQUIREREMOTECTX,
-			      PVRSRVBridgeDevmemIntAcquireRemoteCtx, NULL);
+			      PVRSRVBridgeDevmemIntAcquireRemoteCtx, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTACQUIREREMOTECTX),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTACQUIREREMOTECTX));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_devicememhistory_bridge.c b/drivers/gpu/drm/img-rogue/server_devicememhistory_bridge.c
index 14fc7041b469..72c6a86a0ec8 100644
--- a/drivers/gpu/drm/img-rogue/server_devicememhistory_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_devicememhistory_bridge.c
@@ -779,24 +779,33 @@ PVRSRV_ERROR InitDEVICEMEMHISTORYBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DEVICEMEMHISTORY,
 			      PVRSRV_BRIDGE_DEVICEMEMHISTORY_DEVICEMEMHISTORYMAP,
-			      PVRSRVBridgeDevicememHistoryMap, pDEVICEMEMHISTORYBridgeLock);
+			      PVRSRVBridgeDevicememHistoryMap, pDEVICEMEMHISTORYBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVICEMEMHISTORYMAP),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVICEMEMHISTORYMAP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DEVICEMEMHISTORY,
 			      PVRSRV_BRIDGE_DEVICEMEMHISTORY_DEVICEMEMHISTORYUNMAP,
-			      PVRSRVBridgeDevicememHistoryUnmap, pDEVICEMEMHISTORYBridgeLock);
+			      PVRSRVBridgeDevicememHistoryUnmap, pDEVICEMEMHISTORYBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVICEMEMHISTORYUNMAP),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVICEMEMHISTORYUNMAP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DEVICEMEMHISTORY,
 			      PVRSRV_BRIDGE_DEVICEMEMHISTORY_DEVICEMEMHISTORYMAPVRANGE,
-			      PVRSRVBridgeDevicememHistoryMapVRange, pDEVICEMEMHISTORYBridgeLock);
+			      PVRSRVBridgeDevicememHistoryMapVRange, pDEVICEMEMHISTORYBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVICEMEMHISTORYMAPVRANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVICEMEMHISTORYMAPVRANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DEVICEMEMHISTORY,
 			      PVRSRV_BRIDGE_DEVICEMEMHISTORY_DEVICEMEMHISTORYUNMAPVRANGE,
-			      PVRSRVBridgeDevicememHistoryUnmapVRange, pDEVICEMEMHISTORYBridgeLock);
+			      PVRSRVBridgeDevicememHistoryUnmapVRange, pDEVICEMEMHISTORYBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVICEMEMHISTORYUNMAPVRANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVICEMEMHISTORYUNMAPVRANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DEVICEMEMHISTORY,
 			      PVRSRV_BRIDGE_DEVICEMEMHISTORY_DEVICEMEMHISTORYSPARSECHANGE,
-			      PVRSRVBridgeDevicememHistorySparseChange,
-			      pDEVICEMEMHISTORYBridgeLock);
+			      PVRSRVBridgeDevicememHistorySparseChange, pDEVICEMEMHISTORYBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVICEMEMHISTORYSPARSECHANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVICEMEMHISTORYSPARSECHANGE));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_di_bridge.c b/drivers/gpu/drm/img-rogue/server_di_bridge.c
index 96acc090a989..154bccdaae5e 100644
--- a/drivers/gpu/drm/img-rogue/server_di_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_di_bridge.c
@@ -186,10 +186,36 @@ PVRSRVBridgeDICreateContext(IMG_UINT32 ui32DispatchTableEntry,
 
 	if (psDICreateContextOUT->eError != PVRSRV_OK)
 	{
-		if (psContextInt)
+		if (psDICreateContextOUT->hContext)
+		{
+			PVRSRV_ERROR eError;
+
+			/* Lock over handle creation cleanup. */
+			LockHandle(psConnection->psHandleBase);
+
+			eError = PVRSRVDestroyHandleUnlocked(psConnection->psHandleBase,
+							     (IMG_HANDLE) psDICreateContextOUT->
+							     hContext,
+							     PVRSRV_HANDLE_TYPE_DI_CONTEXT);
+			if (unlikely((eError != PVRSRV_OK) && (eError != PVRSRV_ERROR_RETRY)))
+			{
+				PVR_DPF((PVR_DBG_ERROR,
+					 "%s: %s", __func__, PVRSRVGetErrorString(eError)));
+			}
+			/* Releasing the handle should free/destroy/release the resource.
+			 * This should never fail... */
+			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
+
+			/* Release now we have cleaned up creation handles. */
+			UnlockHandle(psConnection->psHandleBase);
+
+		}
+
+		else if (psContextInt)
 		{
 			DIDestroyContextKM(psContextInt);
 		}
+
 	}
 
 	/* Allocated space should be equal to the last updated offset */
@@ -582,19 +608,27 @@ PVRSRV_ERROR InitDIBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DI, PVRSRV_BRIDGE_DI_DICREATECONTEXT,
-			      PVRSRVBridgeDICreateContext, NULL);
+			      PVRSRVBridgeDICreateContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DICREATECONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_DICREATECONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DI, PVRSRV_BRIDGE_DI_DIDESTROYCONTEXT,
-			      PVRSRVBridgeDIDestroyContext, NULL);
+			      PVRSRVBridgeDIDestroyContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DIDESTROYCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_DIDESTROYCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DI, PVRSRV_BRIDGE_DI_DIREADENTRY,
-			      PVRSRVBridgeDIReadEntry, NULL);
+			      PVRSRVBridgeDIReadEntry, NULL, sizeof(PVRSRV_BRIDGE_IN_DIREADENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_DIREADENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DI, PVRSRV_BRIDGE_DI_DIWRITEENTRY,
-			      PVRSRVBridgeDIWriteEntry, NULL);
+			      PVRSRVBridgeDIWriteEntry, NULL, sizeof(PVRSRV_BRIDGE_IN_DIWRITEENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_DIWRITEENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DI, PVRSRV_BRIDGE_DI_DILISTALLENTRIES,
-			      PVRSRVBridgeDIListAllEntries, NULL);
+			      PVRSRVBridgeDIListAllEntries, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DILISTALLENTRIES),
+			      sizeof(PVRSRV_BRIDGE_OUT_DILISTALLENTRIES));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_dmabuf_bridge.c b/drivers/gpu/drm/img-rogue/server_dmabuf_bridge.c
index fdfa03d54e5a..89aa1477f55a 100644
--- a/drivers/gpu/drm/img-rogue/server_dmabuf_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_dmabuf_bridge.c
@@ -221,162 +221,6 @@ PVRSRVBridgePhysmemImportDmaBuf(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static PVRSRV_ERROR _PhysmemImportDmaBufLockedpsPMRPtrIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = PMRUnrefUnlockPMR((PMR *) pvData);
-	return eError;
-}
-
-static_assert(DEVMEM_ANNOTATION_MAX_LEN <= IMG_UINT32_MAX,
-	      "DEVMEM_ANNOTATION_MAX_LEN must not be larger than IMG_UINT32_MAX");
-
-static IMG_INT
-PVRSRVBridgePhysmemImportDmaBufLocked(IMG_UINT32 ui32DispatchTableEntry,
-				      IMG_UINT8 * psPhysmemImportDmaBufLockedIN_UI8,
-				      IMG_UINT8 * psPhysmemImportDmaBufLockedOUT_UI8,
-				      CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_PHYSMEMIMPORTDMABUFLOCKED *psPhysmemImportDmaBufLockedIN =
-	    (PVRSRV_BRIDGE_IN_PHYSMEMIMPORTDMABUFLOCKED *)
-	    IMG_OFFSET_ADDR(psPhysmemImportDmaBufLockedIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUFLOCKED *psPhysmemImportDmaBufLockedOUT =
-	    (PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUFLOCKED *)
-	    IMG_OFFSET_ADDR(psPhysmemImportDmaBufLockedOUT_UI8, 0);
-
-	IMG_CHAR *uiNameInt = NULL;
-	PMR *psPMRPtrInt = NULL;
-
-	IMG_UINT32 ui32NextOffset = 0;
-	IMG_BYTE *pArrayArgsBuffer = NULL;
-	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
-
-	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psPhysmemImportDmaBufLockedIN->ui32NameSize * sizeof(IMG_CHAR)) + 0;
-
-	if (unlikely(psPhysmemImportDmaBufLockedIN->ui32NameSize > DEVMEM_ANNOTATION_MAX_LEN))
-	{
-		psPhysmemImportDmaBufLockedOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto PhysmemImportDmaBufLocked_exit;
-	}
-
-	if (ui64BufferSize > IMG_UINT32_MAX)
-	{
-		psPhysmemImportDmaBufLockedOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto PhysmemImportDmaBufLocked_exit;
-	}
-
-	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
-
-	if (ui32BufferSize != 0)
-	{
-		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
-		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psPhysmemImportDmaBufLockedIN), sizeof(unsigned long));
-		IMG_UINT32 ui32InBufferExcessSize =
-		    ui32InBufferOffset >=
-		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
-
-		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
-		if (bHaveEnoughSpace)
-		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psPhysmemImportDmaBufLockedIN;
-
-			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
-		}
-		else
-		{
-			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
-
-			if (!pArrayArgsBuffer)
-			{
-				psPhysmemImportDmaBufLockedOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto PhysmemImportDmaBufLocked_exit;
-			}
-		}
-	}
-
-	if (psPhysmemImportDmaBufLockedIN->ui32NameSize != 0)
-	{
-		uiNameInt = (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psPhysmemImportDmaBufLockedIN->ui32NameSize * sizeof(IMG_CHAR);
-	}
-
-	/* Copy the data over */
-	if (psPhysmemImportDmaBufLockedIN->ui32NameSize * sizeof(IMG_CHAR) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, uiNameInt, (const void __user *)psPhysmemImportDmaBufLockedIN->puiName,
-		     psPhysmemImportDmaBufLockedIN->ui32NameSize * sizeof(IMG_CHAR)) != PVRSRV_OK)
-		{
-			psPhysmemImportDmaBufLockedOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-			goto PhysmemImportDmaBufLocked_exit;
-		}
-		((IMG_CHAR *)
-		 uiNameInt)[(psPhysmemImportDmaBufLockedIN->ui32NameSize * sizeof(IMG_CHAR)) - 1] =
-       '\0';
-	}
-
-	psPhysmemImportDmaBufLockedOUT->eError =
-	    PhysmemImportDmaBufLocked(psConnection, OSGetDevNode(psConnection),
-				      psPhysmemImportDmaBufLockedIN->ifd,
-				      psPhysmemImportDmaBufLockedIN->uiFlags,
-				      psPhysmemImportDmaBufLockedIN->ui32NameSize,
-				      uiNameInt,
-				      &psPMRPtrInt,
-				      &psPhysmemImportDmaBufLockedOUT->uiSize,
-				      &psPhysmemImportDmaBufLockedOUT->uiAlign);
-	/* Exit early if bridged call fails */
-	if (unlikely(psPhysmemImportDmaBufLockedOUT->eError != PVRSRV_OK))
-	{
-		goto PhysmemImportDmaBufLocked_exit;
-	}
-
-	/* Lock over handle creation. */
-	LockHandle(psConnection->psHandleBase);
-
-	psPhysmemImportDmaBufLockedOUT->eError =
-	    PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-				      &psPhysmemImportDmaBufLockedOUT->hPMRPtr, (void *)psPMRPtrInt,
-				      PVRSRV_HANDLE_TYPE_PHYSMEM_PMR,
-				      PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-				      (PFN_HANDLE_RELEASE) &
-				      _PhysmemImportDmaBufLockedpsPMRPtrIntRelease);
-	if (unlikely(psPhysmemImportDmaBufLockedOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto PhysmemImportDmaBufLocked_exit;
-	}
-
-	/* Release now we have created handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-PhysmemImportDmaBufLocked_exit:
-
-	if (psPhysmemImportDmaBufLockedOUT->eError != PVRSRV_OK)
-	{
-		if (psPMRPtrInt)
-		{
-			LockHandle(KERNEL_HANDLE_BASE);
-			PMRUnrefUnlockPMR(psPMRPtrInt);
-			UnlockHandle(KERNEL_HANDLE_BASE);
-		}
-	}
-
-	/* Allocated space should be equal to the last updated offset */
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psPhysmemImportDmaBufLockedOUT->eError == PVRSRV_OK)
-		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
-#endif /* PVRSRV_NEED_PVR_ASSERT */
-
-	if (!bHaveEnoughSpace && pArrayArgsBuffer)
-		OSFreeMemNoStats(pArrayArgsBuffer);
-
-	return 0;
-}
-
 static IMG_INT
 PVRSRVBridgePhysmemExportDmaBuf(IMG_UINT32 ui32DispatchTableEntry,
 				IMG_UINT8 * psPhysmemExportDmaBufIN_UI8,
@@ -430,6 +274,59 @@ PVRSRVBridgePhysmemExportDmaBuf(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
+static IMG_INT
+PVRSRVBridgePhysmemExportGemHandle(IMG_UINT32 ui32DispatchTableEntry,
+				   IMG_UINT8 * psPhysmemExportGemHandleIN_UI8,
+				   IMG_UINT8 * psPhysmemExportGemHandleOUT_UI8,
+				   CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_PHYSMEMEXPORTGEMHANDLE *psPhysmemExportGemHandleIN =
+	    (PVRSRV_BRIDGE_IN_PHYSMEMEXPORTGEMHANDLE *)
+	    IMG_OFFSET_ADDR(psPhysmemExportGemHandleIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTGEMHANDLE *psPhysmemExportGemHandleOUT =
+	    (PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTGEMHANDLE *)
+	    IMG_OFFSET_ADDR(psPhysmemExportGemHandleOUT_UI8, 0);
+
+	IMG_HANDLE hPMR = psPhysmemExportGemHandleIN->hPMR;
+	PMR *psPMRInt = NULL;
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psPhysmemExportGemHandleOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psPMRInt,
+				       hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+	if (unlikely(psPhysmemExportGemHandleOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto PhysmemExportGemHandle_exit;
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psPhysmemExportGemHandleOUT->eError =
+	    PhysmemExportGemHandle(psConnection, OSGetDevNode(psConnection),
+				   psPMRInt, &psPhysmemExportGemHandleOUT->ui32Handle);
+
+PhysmemExportGemHandle_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psPMRInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	return 0;
+}
+
 static PVRSRV_ERROR _PhysmemImportSparseDmaBufpsPMRPtrIntRelease(void *pvData)
 {
 	PVRSRV_ERROR eError;
@@ -637,16 +534,24 @@ PVRSRV_ERROR InitDMABUFBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUF,
-			      PVRSRVBridgePhysmemImportDmaBuf, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUFLOCKED,
-			      PVRSRVBridgePhysmemImportDmaBufLocked, NULL);
+			      PVRSRVBridgePhysmemImportDmaBuf, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMIMPORTDMABUF),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTDMABUF));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTDMABUF,
-			      PVRSRVBridgePhysmemExportDmaBuf, NULL);
+			      PVRSRVBridgePhysmemExportDmaBuf, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMEXPORTDMABUF),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTDMABUF));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTGEMHANDLE,
+			      PVRSRVBridgePhysmemExportGemHandle, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMEXPORTGEMHANDLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMEXPORTGEMHANDLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTSPARSEDMABUF,
-			      PVRSRVBridgePhysmemImportSparseDmaBuf, NULL);
+			      PVRSRVBridgePhysmemImportSparseDmaBuf, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMIMPORTSPARSEDMABUF),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMIMPORTSPARSEDMABUF));
 
 	return PVRSRV_OK;
 }
@@ -659,11 +564,10 @@ void DeinitDMABUFBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUF);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF,
-				PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTDMABUFLOCKED);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTDMABUF);
 
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF, PVRSRV_BRIDGE_DMABUF_PHYSMEMEXPORTGEMHANDLE);
+
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_DMABUF,
 				PVRSRV_BRIDGE_DMABUF_PHYSMEMIMPORTSPARSEDMABUF);
 
diff --git a/drivers/gpu/drm/img-rogue/server_htbuffer_bridge.c b/drivers/gpu/drm/img-rogue/server_htbuffer_bridge.c
index 50b4fcbe2dee..9b730d28e5b4 100644
--- a/drivers/gpu/drm/img-rogue/server_htbuffer_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_htbuffer_bridge.c
@@ -198,7 +198,9 @@ PVRSRV_ERROR InitHTBUFFERBridge(void)
 	PVR_LOG_RETURN_IF_ERROR(OSLockCreate(&pHTBUFFERBridgeLock), "OSLockCreate");
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_HTBUFFER, PVRSRV_BRIDGE_HTBUFFER_HTBCONTROL,
-			      PVRSRVBridgeHTBControl, pHTBUFFERBridgeLock);
+			      PVRSRVBridgeHTBControl, pHTBUFFERBridgeLock,
+			      sizeof(PVRSRV_BRIDGE_IN_HTBCONTROL),
+			      sizeof(PVRSRV_BRIDGE_OUT_HTBCONTROL));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_mm_bridge.c b/drivers/gpu/drm/img-rogue/server_mm_bridge.c
index 7842b7c3516f..43535d109c8b 100644
--- a/drivers/gpu/drm/img-rogue/server_mm_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_mm_bridge.c
@@ -241,18 +241,17 @@ PVRSRVBridgePMRExportPMR(IMG_UINT32 ui32DispatchTableEntry,
 			 * This should never fail... */
 			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
 
-			/* Avoid freeing/destroying/releasing the resource a second time below */
-			psPMRExportInt = NULL;
 			/* Release now we have cleaned up creation handles. */
 			UnlockHandle(psConnection->psProcessHandleBase->psHandleBase);
 		}
 
-		if (psPMRExportInt)
+		else if (psPMRExportInt)
 		{
 			LockHandle(KERNEL_HANDLE_BASE);
 			PMRUnexportPMR(psPMRExportInt);
 			UnlockHandle(KERNEL_HANDLE_BASE);
 		}
+
 	}
 
 	return 0;
@@ -769,42 +768,6 @@ PVRSRVBridgePMRUnrefPMR(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static IMG_INT
-PVRSRVBridgePMRUnrefUnlockPMR(IMG_UINT32 ui32DispatchTableEntry,
-			      IMG_UINT8 * psPMRUnrefUnlockPMRIN_UI8,
-			      IMG_UINT8 * psPMRUnrefUnlockPMROUT_UI8,
-			      CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_PMRUNREFUNLOCKPMR *psPMRUnrefUnlockPMRIN =
-	    (PVRSRV_BRIDGE_IN_PMRUNREFUNLOCKPMR *) IMG_OFFSET_ADDR(psPMRUnrefUnlockPMRIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_PMRUNREFUNLOCKPMR *psPMRUnrefUnlockPMROUT =
-	    (PVRSRV_BRIDGE_OUT_PMRUNREFUNLOCKPMR *) IMG_OFFSET_ADDR(psPMRUnrefUnlockPMROUT_UI8, 0);
-
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psPMRUnrefUnlockPMROUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psPMRUnrefUnlockPMRIN->hPMR,
-					      PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
-	if (unlikely((psPMRUnrefUnlockPMROUT->eError != PVRSRV_OK) &&
-		     (psPMRUnrefUnlockPMROUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
-		     (psPMRUnrefUnlockPMROUT->eError != PVRSRV_ERROR_RETRY)))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s", __func__, PVRSRVGetErrorString(psPMRUnrefUnlockPMROUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto PMRUnrefUnlockPMR_exit;
-	}
-
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-PMRUnrefUnlockPMR_exit:
-
-	return 0;
-}
-
 static PVRSRV_ERROR _PhysmemNewRamBackedPMRpsPMRPtrIntRelease(void *pvData)
 {
 	PVRSRV_ERROR eError;
@@ -1097,17 +1060,16 @@ PVRSRVBridgeDevmemIntCtxCreate(IMG_UINT32 ui32DispatchTableEntry,
 			 * This should never fail... */
 			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
 
-			/* Avoid freeing/destroying/releasing the resource a second time below */
-			psDevMemServerContextInt = NULL;
 			/* Release now we have cleaned up creation handles. */
 			UnlockHandle(psConnection->psHandleBase);
 
 		}
 
-		if (psDevMemServerContextInt)
+		else if (psDevMemServerContextInt)
 		{
 			DevmemIntCtxDestroy(psDevMemServerContextInt);
 		}
+
 	}
 
 	return 0;
@@ -1197,9 +1159,7 @@ PVRSRVBridgeDevmemIntHeapCreate(IMG_UINT32 ui32DispatchTableEntry,
 	psDevmemIntHeapCreateOUT->eError =
 	    DevmemIntHeapCreate(psDevmemCtxInt,
 				psDevmemIntHeapCreateIN->ui32HeapConfigIndex,
-				psDevmemIntHeapCreateIN->ui32HeapIndex,
-				psDevmemIntHeapCreateIN->sHeapBaseAddr,
-				psDevmemIntHeapCreateIN->ui32Log2DataPageSize, &psDevmemHeapPtrInt);
+				psDevmemIntHeapCreateIN->ui32HeapIndex, &psDevmemHeapPtrInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psDevmemIntHeapCreateOUT->eError != PVRSRV_OK))
 	{
@@ -1290,13 +1250,6 @@ PVRSRVBridgeDevmemIntHeapDestroy(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static PVRSRV_ERROR _DevmemIntMapPMRpsMappingIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = DevmemIntUnmapPMR((DEVMEMINT_MAPPING *) pvData);
-	return eError;
-}
-
 static IMG_INT
 PVRSRVBridgeDevmemIntMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 			    IMG_UINT8 * psDevmemIntMapPMRIN_UI8,
@@ -1307,29 +1260,14 @@ PVRSRVBridgeDevmemIntMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 	PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR *psDevmemIntMapPMROUT =
 	    (PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR *) IMG_OFFSET_ADDR(psDevmemIntMapPMROUT_UI8, 0);
 
-	IMG_HANDLE hDevmemServerHeap = psDevmemIntMapPMRIN->hDevmemServerHeap;
-	DEVMEMINT_HEAP *psDevmemServerHeapInt = NULL;
 	IMG_HANDLE hReservation = psDevmemIntMapPMRIN->hReservation;
 	DEVMEMINT_RESERVATION *psReservationInt = NULL;
 	IMG_HANDLE hPMR = psDevmemIntMapPMRIN->hPMR;
 	PMR *psPMRInt = NULL;
-	DEVMEMINT_MAPPING *psMappingInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Look up the address from the handle */
-	psDevmemIntMapPMROUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psDevmemServerHeapInt,
-				       hDevmemServerHeap,
-				       PVRSRV_HANDLE_TYPE_DEVMEMINT_HEAP, IMG_TRUE);
-	if (unlikely(psDevmemIntMapPMROUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto DevmemIntMapPMR_exit;
-	}
-
 	/* Look up the address from the handle */
 	psDevmemIntMapPMROUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
@@ -1355,47 +1293,13 @@ PVRSRVBridgeDevmemIntMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psDevmemIntMapPMROUT->eError =
-	    DevmemIntMapPMR(psDevmemServerHeapInt,
-			    psReservationInt,
-			    psPMRInt, psDevmemIntMapPMRIN->uiMapFlags, &psMappingInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psDevmemIntMapPMROUT->eError != PVRSRV_OK))
-	{
-		goto DevmemIntMapPMR_exit;
-	}
-
-	/* Lock over handle creation. */
-	LockHandle(psConnection->psHandleBase);
-
-	psDevmemIntMapPMROUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								 &psDevmemIntMapPMROUT->hMapping,
-								 (void *)psMappingInt,
-								 PVRSRV_HANDLE_TYPE_DEVMEMINT_MAPPING,
-								 PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								 (PFN_HANDLE_RELEASE) &
-								 _DevmemIntMapPMRpsMappingIntRelease);
-	if (unlikely(psDevmemIntMapPMROUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto DevmemIntMapPMR_exit;
-	}
-
-	/* Release now we have created handles. */
-	UnlockHandle(psConnection->psHandleBase);
+	psDevmemIntMapPMROUT->eError = DevmemIntMapPMR(psReservationInt, psPMRInt);
 
 DevmemIntMapPMR_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Unreference the previously looked up handle */
-	if (psDevmemServerHeapInt)
-	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hDevmemServerHeap, PVRSRV_HANDLE_TYPE_DEVMEMINT_HEAP);
-	}
-
 	/* Unreference the previously looked up handle */
 	if (psReservationInt)
 	{
@@ -1412,14 +1316,6 @@ PVRSRVBridgeDevmemIntMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	if (psDevmemIntMapPMROUT->eError != PVRSRV_OK)
-	{
-		if (psMappingInt)
-		{
-			DevmemIntUnmapPMR(psMappingInt);
-		}
-	}
-
 	return 0;
 }
 
@@ -1434,28 +1330,42 @@ PVRSRVBridgeDevmemIntUnmapPMR(IMG_UINT32 ui32DispatchTableEntry,
 	PVRSRV_BRIDGE_OUT_DEVMEMINTUNMAPPMR *psDevmemIntUnmapPMROUT =
 	    (PVRSRV_BRIDGE_OUT_DEVMEMINTUNMAPPMR *) IMG_OFFSET_ADDR(psDevmemIntUnmapPMROUT_UI8, 0);
 
-	/* Lock over handle destruction. */
+	IMG_HANDLE hReservation = psDevmemIntUnmapPMRIN->hReservation;
+	DEVMEMINT_RESERVATION *psReservationInt = NULL;
+
+	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
+	/* Look up the address from the handle */
 	psDevmemIntUnmapPMROUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psDevmemIntUnmapPMRIN->hMapping,
-					      PVRSRV_HANDLE_TYPE_DEVMEMINT_MAPPING);
-	if (unlikely((psDevmemIntUnmapPMROUT->eError != PVRSRV_OK) &&
-		     (psDevmemIntUnmapPMROUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
-		     (psDevmemIntUnmapPMROUT->eError != PVRSRV_ERROR_RETRY)))
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psReservationInt,
+				       hReservation,
+				       PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION, IMG_TRUE);
+	if (unlikely(psDevmemIntUnmapPMROUT->eError != PVRSRV_OK))
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s", __func__, PVRSRVGetErrorString(psDevmemIntUnmapPMROUT->eError)));
 		UnlockHandle(psConnection->psHandleBase);
 		goto DevmemIntUnmapPMR_exit;
 	}
-
-	/* Release now we have destroyed handles. */
+	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
+	psDevmemIntUnmapPMROUT->eError = DevmemIntUnmapPMR(psReservationInt);
+
 DevmemIntUnmapPMR_exit:
 
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psReservationInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hReservation, PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
 	return 0;
 }
 
@@ -1503,7 +1413,8 @@ PVRSRVBridgeDevmemIntReserveRange(IMG_UINT32 ui32DispatchTableEntry,
 	psDevmemIntReserveRangeOUT->eError =
 	    DevmemIntReserveRange(psDevmemServerHeapInt,
 				  psDevmemIntReserveRangeIN->sAddress,
-				  psDevmemIntReserveRangeIN->uiLength, &psReservationInt);
+				  psDevmemIntReserveRangeIN->uiLength,
+				  psDevmemIntReserveRangeIN->uiFlags, &psReservationInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psDevmemIntReserveRangeOUT->eError != PVRSRV_OK))
 	{
@@ -1555,10 +1466,10 @@ PVRSRVBridgeDevmemIntReserveRange(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static PVRSRV_ERROR _DevmemIntReserveRangeAndMapPMRpsMappingIntRelease(void *pvData)
+static PVRSRV_ERROR _DevmemIntReserveRangeAndMapPMRpsReservationIntRelease(void *pvData)
 {
 	PVRSRV_ERROR eError;
-	eError = DevmemIntUnreserveRangeAndUnmapPMR((DEVMEMINT_MAPPING *) pvData);
+	eError = DevmemIntUnreserveRange((DEVMEMINT_RESERVATION *) pvData);
 	return eError;
 }
 
@@ -1579,7 +1490,7 @@ PVRSRVBridgeDevmemIntReserveRangeAndMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 	DEVMEMINT_HEAP *psDevmemServerHeapInt = NULL;
 	IMG_HANDLE hPMR = psDevmemIntReserveRangeAndMapPMRIN->hPMR;
 	PMR *psPMRInt = NULL;
-	DEVMEMINT_MAPPING *psMappingInt = NULL;
+	DEVMEMINT_RESERVATION *psReservationInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
@@ -1614,8 +1525,8 @@ PVRSRVBridgeDevmemIntReserveRangeAndMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 					   psDevmemIntReserveRangeAndMapPMRIN->sAddress,
 					   psDevmemIntReserveRangeAndMapPMRIN->uiLength,
 					   psPMRInt,
-					   psDevmemIntReserveRangeAndMapPMRIN->uiMapFlags,
-					   &psMappingInt);
+					   psDevmemIntReserveRangeAndMapPMRIN->uiFlags,
+					   &psReservationInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psDevmemIntReserveRangeAndMapPMROUT->eError != PVRSRV_OK))
 	{
@@ -1627,11 +1538,12 @@ PVRSRVBridgeDevmemIntReserveRangeAndMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 
 	psDevmemIntReserveRangeAndMapPMROUT->eError =
 	    PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-				      &psDevmemIntReserveRangeAndMapPMROUT->hMapping,
-				      (void *)psMappingInt, PVRSRV_HANDLE_TYPE_DEVMEMINT_MAPPING,
+				      &psDevmemIntReserveRangeAndMapPMROUT->hReservation,
+				      (void *)psReservationInt,
+				      PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION,
 				      PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 				      (PFN_HANDLE_RELEASE) &
-				      _DevmemIntReserveRangeAndMapPMRpsMappingIntRelease);
+				      _DevmemIntReserveRangeAndMapPMRpsReservationIntRelease);
 	if (unlikely(psDevmemIntReserveRangeAndMapPMROUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
@@ -1664,60 +1576,15 @@ PVRSRVBridgeDevmemIntReserveRangeAndMapPMR(IMG_UINT32 ui32DispatchTableEntry,
 
 	if (psDevmemIntReserveRangeAndMapPMROUT->eError != PVRSRV_OK)
 	{
-		if (psMappingInt)
+		if (psReservationInt)
 		{
-			DevmemIntUnreserveRangeAndUnmapPMR(psMappingInt);
+			DevmemIntUnreserveRange(psReservationInt);
 		}
 	}
 
 	return 0;
 }
 
-static IMG_INT
-PVRSRVBridgeDevmemIntUnreserveRangeAndUnmapPMR(IMG_UINT32 ui32DispatchTableEntry,
-					       IMG_UINT8 *
-					       psDevmemIntUnreserveRangeAndUnmapPMRIN_UI8,
-					       IMG_UINT8 *
-					       psDevmemIntUnreserveRangeAndUnmapPMROUT_UI8,
-					       CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_DEVMEMINTUNRESERVERANGEANDUNMAPPMR *psDevmemIntUnreserveRangeAndUnmapPMRIN
-	    =
-	    (PVRSRV_BRIDGE_IN_DEVMEMINTUNRESERVERANGEANDUNMAPPMR *)
-	    IMG_OFFSET_ADDR(psDevmemIntUnreserveRangeAndUnmapPMRIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGEANDUNMAPPMR
-	    *psDevmemIntUnreserveRangeAndUnmapPMROUT =
-	    (PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGEANDUNMAPPMR *)
-	    IMG_OFFSET_ADDR(psDevmemIntUnreserveRangeAndUnmapPMROUT_UI8, 0);
-
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psDevmemIntUnreserveRangeAndUnmapPMROUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psDevmemIntUnreserveRangeAndUnmapPMRIN->
-					      hMapping, PVRSRV_HANDLE_TYPE_DEVMEMINT_MAPPING);
-	if (unlikely
-	    ((psDevmemIntUnreserveRangeAndUnmapPMROUT->eError != PVRSRV_OK)
-	     && (psDevmemIntUnreserveRangeAndUnmapPMROUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
-	     && (psDevmemIntUnreserveRangeAndUnmapPMROUT->eError != PVRSRV_ERROR_RETRY)))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s",
-			 __func__,
-			 PVRSRVGetErrorString(psDevmemIntUnreserveRangeAndUnmapPMROUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto DevmemIntUnreserveRangeAndUnmapPMR_exit;
-	}
-
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-DevmemIntUnreserveRangeAndUnmapPMR_exit:
-
-	return 0;
-}
-
 static IMG_INT
 PVRSRVBridgeDevmemIntUnreserveRange(IMG_UINT32 ui32DispatchTableEntry,
 				    IMG_UINT8 * psDevmemIntUnreserveRangeIN_UI8,
@@ -1774,12 +1641,10 @@ PVRSRVBridgeChangeSparseMem(IMG_UINT32 ui32DispatchTableEntry,
 	PVRSRV_BRIDGE_OUT_CHANGESPARSEMEM *psChangeSparseMemOUT =
 	    (PVRSRV_BRIDGE_OUT_CHANGESPARSEMEM *) IMG_OFFSET_ADDR(psChangeSparseMemOUT_UI8, 0);
 
-	IMG_HANDLE hSrvDevMemHeap = psChangeSparseMemIN->hSrvDevMemHeap;
-	DEVMEMINT_HEAP *psSrvDevMemHeapInt = NULL;
-	IMG_HANDLE hPMR = psChangeSparseMemIN->hPMR;
-	PMR *psPMRInt = NULL;
 	IMG_UINT32 *ui32AllocPageIndicesInt = NULL;
 	IMG_UINT32 *ui32FreePageIndicesInt = NULL;
+	IMG_HANDLE hReservation = psChangeSparseMemIN->hReservation;
+	DEVMEMINT_RESERVATION *psReservationInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
@@ -1885,19 +1750,9 @@ PVRSRVBridgeChangeSparseMem(IMG_UINT32 ui32DispatchTableEntry,
 	/* Look up the address from the handle */
 	psChangeSparseMemOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psSrvDevMemHeapInt,
-				       hSrvDevMemHeap, PVRSRV_HANDLE_TYPE_DEVMEMINT_HEAP, IMG_TRUE);
-	if (unlikely(psChangeSparseMemOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto ChangeSparseMem_exit;
-	}
-
-	/* Look up the address from the handle */
-	psChangeSparseMemOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psPMRInt,
-				       hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+				       (void **)&psReservationInt,
+				       hReservation,
+				       PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION, IMG_TRUE);
 	if (unlikely(psChangeSparseMemOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
@@ -1907,16 +1762,11 @@ PVRSRVBridgeChangeSparseMem(IMG_UINT32 ui32DispatchTableEntry,
 	UnlockHandle(psConnection->psHandleBase);
 
 	psChangeSparseMemOUT->eError =
-	    DevmemIntChangeSparse(psSrvDevMemHeapInt,
-				  psPMRInt,
-				  psChangeSparseMemIN->ui32AllocPageCount,
+	    DevmemIntChangeSparse(psChangeSparseMemIN->ui32AllocPageCount,
 				  ui32AllocPageIndicesInt,
 				  psChangeSparseMemIN->ui32FreePageCount,
 				  ui32FreePageIndicesInt,
-				  psChangeSparseMemIN->ui32SparseFlags,
-				  psChangeSparseMemIN->uiFlags,
-				  psChangeSparseMemIN->sDevVAddr,
-				  psChangeSparseMemIN->ui64CPUVAddr);
+				  psChangeSparseMemIN->ui32SparseFlags, psReservationInt);
 
 ChangeSparseMem_exit:
 
@@ -1924,17 +1774,10 @@ PVRSRVBridgeChangeSparseMem(IMG_UINT32 ui32DispatchTableEntry,
 	LockHandle(psConnection->psHandleBase);
 
 	/* Unreference the previously looked up handle */
-	if (psSrvDevMemHeapInt)
-	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hSrvDevMemHeap, PVRSRV_HANDLE_TYPE_DEVMEMINT_HEAP);
-	}
-
-	/* Unreference the previously looked up handle */
-	if (psPMRInt)
+	if (psReservationInt)
 	{
 		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+					    hReservation, PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION);
 	}
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
@@ -2988,115 +2831,174 @@ PVRSRV_ERROR InitMMBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMREXPORTPMR,
-			      PVRSRVBridgePMRExportPMR, NULL);
+			      PVRSRVBridgePMRExportPMR, NULL, sizeof(PVRSRV_BRIDGE_IN_PMREXPORTPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMREXPORTPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNEXPORTPMR,
-			      PVRSRVBridgePMRUnexportPMR, NULL);
+			      PVRSRVBridgePMRUnexportPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PMRUNEXPORTPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRUNEXPORTPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRGETUID, PVRSRVBridgePMRGetUID,
-			      NULL);
+			      NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PMRGETUID),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRGETUID));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRMAKELOCALIMPORTHANDLE,
-			      PVRSRVBridgePMRMakeLocalImportHandle, NULL);
+			      PVRSRVBridgePMRMakeLocalImportHandle, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PMRMAKELOCALIMPORTHANDLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRMAKELOCALIMPORTHANDLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNMAKELOCALIMPORTHANDLE,
-			      PVRSRVBridgePMRUnmakeLocalImportHandle, NULL);
+			      PVRSRVBridgePMRUnmakeLocalImportHandle, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PMRUNMAKELOCALIMPORTHANDLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRUNMAKELOCALIMPORTHANDLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRIMPORTPMR,
-			      PVRSRVBridgePMRImportPMR, NULL);
+			      PVRSRVBridgePMRImportPMR, NULL, sizeof(PVRSRV_BRIDGE_IN_PMRIMPORTPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRIMPORTPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRLOCALIMPORTPMR,
-			      PVRSRVBridgePMRLocalImportPMR, NULL);
+			      PVRSRVBridgePMRLocalImportPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PMRLOCALIMPORTPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRLOCALIMPORTPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNREFPMR,
-			      PVRSRVBridgePMRUnrefPMR, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNREFUNLOCKPMR,
-			      PVRSRVBridgePMRUnrefUnlockPMR, NULL);
+			      PVRSRVBridgePMRUnrefPMR, NULL, sizeof(PVRSRV_BRIDGE_IN_PMRUNREFPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PMRUNREFPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PHYSMEMNEWRAMBACKEDPMR,
-			      PVRSRVBridgePhysmemNewRamBackedPMR, NULL);
+			      PVRSRVBridgePhysmemNewRamBackedPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMNEWRAMBACKEDPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMNEWRAMBACKEDPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTCTXCREATE,
-			      PVRSRVBridgeDevmemIntCtxCreate, NULL);
+			      PVRSRVBridgeDevmemIntCtxCreate, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTCTXCREATE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTCTXCREATE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTCTXDESTROY,
-			      PVRSRVBridgeDevmemIntCtxDestroy, NULL);
+			      PVRSRVBridgeDevmemIntCtxDestroy, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTCTXDESTROY),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTCTXDESTROY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTHEAPCREATE,
-			      PVRSRVBridgeDevmemIntHeapCreate, NULL);
+			      PVRSRVBridgeDevmemIntHeapCreate, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTHEAPCREATE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTHEAPCREATE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTHEAPDESTROY,
-			      PVRSRVBridgeDevmemIntHeapDestroy, NULL);
+			      PVRSRVBridgeDevmemIntHeapDestroy, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTHEAPDESTROY),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTHEAPDESTROY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTMAPPMR,
-			      PVRSRVBridgeDevmemIntMapPMR, NULL);
+			      PVRSRVBridgeDevmemIntMapPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTMAPPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTMAPPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTUNMAPPMR,
-			      PVRSRVBridgeDevmemIntUnmapPMR, NULL);
+			      PVRSRVBridgeDevmemIntUnmapPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTUNMAPPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTUNMAPPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGE,
-			      PVRSRVBridgeDevmemIntReserveRange, NULL);
+			      PVRSRVBridgeDevmemIntReserveRange, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTRESERVERANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGEANDMAPPMR,
-			      PVRSRVBridgeDevmemIntReserveRangeAndMapPMR, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGEANDUNMAPPMR,
-			      PVRSRVBridgeDevmemIntUnreserveRangeAndUnmapPMR, NULL);
+			      PVRSRVBridgeDevmemIntReserveRangeAndMapPMR, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTRESERVERANGEANDMAPPMR),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTRESERVERANGEANDMAPPMR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGE,
-			      PVRSRVBridgeDevmemIntUnreserveRange, NULL);
+			      PVRSRVBridgeDevmemIntUnreserveRange, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTUNRESERVERANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTUNRESERVERANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_CHANGESPARSEMEM,
-			      PVRSRVBridgeChangeSparseMem, NULL);
+			      PVRSRVBridgeChangeSparseMem, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_CHANGESPARSEMEM),
+			      sizeof(PVRSRV_BRIDGE_OUT_CHANGESPARSEMEM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMISVDEVADDRVALID,
-			      PVRSRVBridgeDevmemIsVDevAddrValid, NULL);
+			      PVRSRVBridgeDevmemIsVDevAddrValid, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMISVDEVADDRVALID),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMISVDEVADDRVALID));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINVALIDATEFBSCTABLE,
-			      PVRSRVBridgeDevmemInvalidateFBSCTable, NULL);
+			      PVRSRVBridgeDevmemInvalidateFBSCTable, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINVALIDATEFBSCTABLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINVALIDATEFBSCTABLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGCOUNT,
-			      PVRSRVBridgeHeapCfgHeapConfigCount, NULL);
+			      PVRSRVBridgeHeapCfgHeapConfigCount, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_HEAPCFGHEAPCONFIGCOUNT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_HEAPCFGHEAPCOUNT,
-			      PVRSRVBridgeHeapCfgHeapCount, NULL);
+			      PVRSRVBridgeHeapCfgHeapCount, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_HEAPCFGHEAPCOUNT),
+			      sizeof(PVRSRV_BRIDGE_OUT_HEAPCFGHEAPCOUNT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_HEAPCFGHEAPCONFIGNAME,
-			      PVRSRVBridgeHeapCfgHeapConfigName, NULL);
+			      PVRSRVBridgeHeapCfgHeapConfigName, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_HEAPCFGHEAPCONFIGNAME),
+			      sizeof(PVRSRV_BRIDGE_OUT_HEAPCFGHEAPCONFIGNAME));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_HEAPCFGHEAPDETAILS,
-			      PVRSRVBridgeHeapCfgHeapDetails, NULL);
+			      PVRSRVBridgeHeapCfgHeapDetails, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_HEAPCFGHEAPDETAILS),
+			      sizeof(PVRSRV_BRIDGE_OUT_HEAPCFGHEAPDETAILS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTREGISTERPFNOTIFYKM,
-			      PVRSRVBridgeDevmemIntRegisterPFNotifyKM, NULL);
+			      PVRSRVBridgeDevmemIntRegisterPFNotifyKM, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMINTREGISTERPFNOTIFYKM),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMINTREGISTERPFNOTIFYKM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PHYSHEAPGETMEMINFO,
-			      PVRSRVBridgePhysHeapGetMemInfo, NULL);
+			      PVRSRVBridgePhysHeapGetMemInfo, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSHEAPGETMEMINFO),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSHEAPGETMEMINFO));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_GETDEFAULTPHYSICALHEAP,
-			      PVRSRVBridgeGetDefaultPhysicalHeap, NULL);
+			      PVRSRVBridgeGetDefaultPhysicalHeap, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_GETDEFAULTPHYSICALHEAP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMGETFAULTADDRESS,
-			      PVRSRVBridgeDevmemGetFaultAddress, NULL);
+			      PVRSRVBridgeDevmemGetFaultAddress, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMGETFAULTADDRESS),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMGETFAULTADDRESS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PVRSRVSTATSUPDATEOOMSTAT,
-			      PVRSRVBridgePVRSRVStatsUpdateOOMStat, NULL);
+			      PVRSRVBridgePVRSRVStatsUpdateOOMStat, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PVRSRVSTATSUPDATEOOMSTAT),
+			      sizeof(PVRSRV_BRIDGE_OUT_PVRSRVSTATSUPDATEOOMSTAT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMXINTRESERVERANGE,
-			      PVRSRVBridgeDevmemXIntReserveRange, NULL);
+			      PVRSRVBridgeDevmemXIntReserveRange, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMXINTRESERVERANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMXINTRESERVERANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMXINTUNRESERVERANGE,
-			      PVRSRVBridgeDevmemXIntUnreserveRange, NULL);
+			      PVRSRVBridgeDevmemXIntUnreserveRange, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMXINTUNRESERVERANGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMXINTUNRESERVERANGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMXINTMAPPAGES,
-			      PVRSRVBridgeDevmemXIntMapPages, NULL);
+			      PVRSRVBridgeDevmemXIntMapPages, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMXINTMAPPAGES),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMXINTMAPPAGES));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMXINTUNMAPPAGES,
-			      PVRSRVBridgeDevmemXIntUnmapPages, NULL);
+			      PVRSRVBridgeDevmemXIntUnmapPages, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMXINTUNMAPPAGES),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMXINTUNMAPPAGES));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMXINTMAPVRANGETOBACKINGPAGE,
-			      PVRSRVBridgeDevmemXIntMapVRangeToBackingPage, NULL);
+			      PVRSRVBridgeDevmemXIntMapVRangeToBackingPage, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DEVMEMXINTMAPVRANGETOBACKINGPAGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_DEVMEMXINTMAPVRANGETOBACKINGPAGE));
 
 	return PVRSRV_OK;
 }
@@ -3123,8 +3025,6 @@ void DeinitMMBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNREFPMR);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PMRUNREFUNLOCKPMR);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_PHYSMEMNEWRAMBACKEDPMR);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTCTXCREATE);
@@ -3143,9 +3043,6 @@ void DeinitMMBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTRESERVERANGEANDMAPPMR);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM,
-				PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGEANDUNMAPPMR);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_DEVMEMINTUNRESERVERANGE);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_MM, PVRSRV_BRIDGE_MM_CHANGESPARSEMEM);
diff --git a/drivers/gpu/drm/img-rogue/server_mmextmem_bridge.c b/drivers/gpu/drm/img-rogue/server_mmextmem_bridge.c
index 954713f7691c..538d04cdf0e0 100644
--- a/drivers/gpu/drm/img-rogue/server_mmextmem_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_mmextmem_bridge.c
@@ -148,7 +148,9 @@ PVRSRV_ERROR InitMMEXTMEMBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MMEXTMEM, PVRSRV_BRIDGE_MMEXTMEM_PHYSMEMWRAPEXTMEM,
-			      PVRSRVBridgePhysmemWrapExtMem, NULL);
+			      PVRSRVBridgePhysmemWrapExtMem, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_PHYSMEMWRAPEXTMEM),
+			      sizeof(PVRSRV_BRIDGE_OUT_PHYSMEMWRAPEXTMEM));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_pvrtl_bridge.c b/drivers/gpu/drm/img-rogue/server_pvrtl_bridge.c
index bbf2d33f8dae..9facf794011e 100644
--- a/drivers/gpu/drm/img-rogue/server_pvrtl_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_pvrtl_bridge.c
@@ -217,17 +217,16 @@ PVRSRVBridgeTLOpenStream(IMG_UINT32 ui32DispatchTableEntry,
 			 * This should never fail... */
 			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
 
-			/* Avoid freeing/destroying/releasing the resource a second time below */
-			psSDInt = NULL;
 			/* Release now we have cleaned up creation handles. */
 			UnlockHandle(psConnection->psHandleBase);
 
 		}
 
-		if (psSDInt)
+		else if (psSDInt)
 		{
 			TLServerCloseStreamKM(psSDInt);
 		}
+
 	}
 
 	/* Allocated space should be equal to the last updated offset */
@@ -763,28 +762,42 @@ PVRSRV_ERROR InitPVRTLBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLOPENSTREAM,
-			      PVRSRVBridgeTLOpenStream, NULL);
+			      PVRSRVBridgeTLOpenStream, NULL, sizeof(PVRSRV_BRIDGE_IN_TLOPENSTREAM),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLOPENSTREAM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLCLOSESTREAM,
-			      PVRSRVBridgeTLCloseStream, NULL);
+			      PVRSRVBridgeTLCloseStream, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLCLOSESTREAM),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLCLOSESTREAM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLACQUIREDATA,
-			      PVRSRVBridgeTLAcquireData, NULL);
+			      PVRSRVBridgeTLAcquireData, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLACQUIREDATA),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLACQUIREDATA));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLRELEASEDATA,
-			      PVRSRVBridgeTLReleaseData, NULL);
+			      PVRSRVBridgeTLReleaseData, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLRELEASEDATA),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLRELEASEDATA));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLDISCOVERSTREAMS,
-			      PVRSRVBridgeTLDiscoverStreams, NULL);
+			      PVRSRVBridgeTLDiscoverStreams, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLDISCOVERSTREAMS),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLDISCOVERSTREAMS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLRESERVESTREAM,
-			      PVRSRVBridgeTLReserveStream, NULL);
+			      PVRSRVBridgeTLReserveStream, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLRESERVESTREAM),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLRESERVESTREAM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLCOMMITSTREAM,
-			      PVRSRVBridgeTLCommitStream, NULL);
+			      PVRSRVBridgeTLCommitStream, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_TLCOMMITSTREAM),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLCOMMITSTREAM));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PVRTL, PVRSRV_BRIDGE_PVRTL_TLWRITEDATA,
-			      PVRSRVBridgeTLWriteData, NULL);
+			      PVRSRVBridgeTLWriteData, NULL, sizeof(PVRSRV_BRIDGE_IN_TLWRITEDATA),
+			      sizeof(PVRSRV_BRIDGE_OUT_TLWRITEDATA));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxbreakpoint_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxbreakpoint_bridge.c
index a4b80284cd78..78fd2b405e92 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxbreakpoint_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxbreakpoint_bridge.c
@@ -316,23 +316,33 @@ PVRSRV_ERROR InitRGXBREAKPOINTBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXBREAKPOINT,
 			      PVRSRV_BRIDGE_RGXBREAKPOINT_RGXSETBREAKPOINT,
-			      PVRSRVBridgeRGXSetBreakpoint, NULL);
+			      PVRSRVBridgeRGXSetBreakpoint, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETBREAKPOINT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETBREAKPOINT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXBREAKPOINT,
 			      PVRSRV_BRIDGE_RGXBREAKPOINT_RGXCLEARBREAKPOINT,
-			      PVRSRVBridgeRGXClearBreakpoint, NULL);
+			      PVRSRVBridgeRGXClearBreakpoint, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCLEARBREAKPOINT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCLEARBREAKPOINT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXBREAKPOINT,
 			      PVRSRV_BRIDGE_RGXBREAKPOINT_RGXENABLEBREAKPOINT,
-			      PVRSRVBridgeRGXEnableBreakpoint, NULL);
+			      PVRSRVBridgeRGXEnableBreakpoint, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXENABLEBREAKPOINT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXENABLEBREAKPOINT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXBREAKPOINT,
 			      PVRSRV_BRIDGE_RGXBREAKPOINT_RGXDISABLEBREAKPOINT,
-			      PVRSRVBridgeRGXDisableBreakpoint, NULL);
+			      PVRSRVBridgeRGXDisableBreakpoint, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDISABLEBREAKPOINT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDISABLEBREAKPOINT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXBREAKPOINT,
 			      PVRSRV_BRIDGE_RGXBREAKPOINT_RGXOVERALLOCATEBPREGISTERS,
-			      PVRSRVBridgeRGXOverallocateBPRegisters, NULL);
+			      PVRSRVBridgeRGXOverallocateBPRegisters, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXOVERALLOCATEBPREGISTERS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXOVERALLOCATEBPREGISTERS));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxcmp_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxcmp_bridge.c
index 72836a97b47d..8910cfb5ba6a 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxcmp_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxcmp_bridge.c
@@ -431,6 +431,73 @@ PVRSRVBridgeRGXFlushComputeData(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
+static IMG_INT
+PVRSRVBridgeRGXSendCancelCmd(IMG_UINT32 ui32DispatchTableEntry,
+			     IMG_UINT8 * psRGXSendCancelCmdIN_UI8,
+			     IMG_UINT8 * psRGXSendCancelCmdOUT_UI8, CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXSENDCANCELCMD *psRGXSendCancelCmdIN =
+	    (PVRSRV_BRIDGE_IN_RGXSENDCANCELCMD *) IMG_OFFSET_ADDR(psRGXSendCancelCmdIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSENDCANCELCMD *psRGXSendCancelCmdOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSENDCANCELCMD *) IMG_OFFSET_ADDR(psRGXSendCancelCmdOUT_UI8, 0);
+
+	IMG_HANDLE hComputeContext = psRGXSendCancelCmdIN->hComputeContext;
+	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
+
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
+
+		/* Check that device supports the required feature */
+		if ((psDeviceNode->pfnCheckDeviceFeature) &&
+		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
+							 RGX_FEATURE_COMPUTE_BIT_MASK))
+		{
+			psRGXSendCancelCmdOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXSendCancelCmd_exit;
+		}
+	}
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXSendCancelCmdOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psComputeContextInt,
+				       hComputeContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSendCancelCmdOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXSendCancelCmd_exit;
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXSendCancelCmdOUT->eError =
+	    PVRSRVRGXSendCancelCmdKM(psComputeContextInt,
+				     psRGXSendCancelCmdIN->i32FirstIntJobRefToCancel,
+				     psRGXSendCancelCmdIN->i32LastIntJobRefToCancel);
+
+RGXSendCancelCmd_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psComputeContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hComputeContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	return 0;
+}
+
 static IMG_INT
 PVRSRVBridgeRGXSetComputeContextPriority(IMG_UINT32 ui32DispatchTableEntry,
 					 IMG_UINT8 * psRGXSetComputeContextPriorityIN_UI8,
@@ -527,9 +594,284 @@ PVRSRVBridgeRGXNotifyComputeWriteOffsetUpdate(IMG_UINT32 ui32DispatchTableEntry,
 		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
 							 RGX_FEATURE_COMPUTE_BIT_MASK))
 		{
-			psRGXNotifyComputeWriteOffsetUpdateOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+			psRGXNotifyComputeWriteOffsetUpdateOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXNotifyComputeWriteOffsetUpdate_exit;
+		}
+	}
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXNotifyComputeWriteOffsetUpdateOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psComputeContextInt,
+				       hComputeContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXNotifyComputeWriteOffsetUpdateOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXNotifyComputeWriteOffsetUpdate_exit;
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXNotifyComputeWriteOffsetUpdateOUT->eError =
+	    PVRSRVRGXNotifyComputeWriteOffsetUpdateKM(psComputeContextInt);
+
+RGXNotifyComputeWriteOffsetUpdate_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psComputeContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hComputeContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	return 0;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXSetComputeContextProperty(IMG_UINT32 ui32DispatchTableEntry,
+					 IMG_UINT8 * psRGXSetComputeContextPropertyIN_UI8,
+					 IMG_UINT8 * psRGXSetComputeContextPropertyOUT_UI8,
+					 CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPROPERTY *psRGXSetComputeContextPropertyIN =
+	    (PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPROPERTY *)
+	    IMG_OFFSET_ADDR(psRGXSetComputeContextPropertyIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPROPERTY *psRGXSetComputeContextPropertyOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPROPERTY *)
+	    IMG_OFFSET_ADDR(psRGXSetComputeContextPropertyOUT_UI8, 0);
+
+	IMG_HANDLE hComputeContext = psRGXSetComputeContextPropertyIN->hComputeContext;
+	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
+
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
+
+		/* Check that device supports the required feature */
+		if ((psDeviceNode->pfnCheckDeviceFeature) &&
+		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
+							 RGX_FEATURE_COMPUTE_BIT_MASK))
+		{
+			psRGXSetComputeContextPropertyOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXSetComputeContextProperty_exit;
+		}
+	}
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXSetComputeContextPropertyOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psComputeContextInt,
+				       hComputeContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSetComputeContextPropertyOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXSetComputeContextProperty_exit;
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXSetComputeContextPropertyOUT->eError =
+	    PVRSRVRGXSetComputeContextPropertyKM(psComputeContextInt,
+						 psRGXSetComputeContextPropertyIN->ui32Property,
+						 psRGXSetComputeContextPropertyIN->ui64Input,
+						 &psRGXSetComputeContextPropertyOUT->ui64Output);
+
+RGXSetComputeContextProperty_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psComputeContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hComputeContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	return 0;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXGetLastDeviceError(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXGetLastDeviceErrorIN_UI8,
+				  IMG_UINT8 * psRGXGetLastDeviceErrorOUT_UI8,
+				  CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXGETLASTDEVICEERROR *psRGXGetLastDeviceErrorIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETLASTDEVICEERROR *)
+	    IMG_OFFSET_ADDR(psRGXGetLastDeviceErrorIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETLASTDEVICEERROR *psRGXGetLastDeviceErrorOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXGETLASTDEVICEERROR *)
+	    IMG_OFFSET_ADDR(psRGXGetLastDeviceErrorOUT_UI8, 0);
+
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
+
+		/* Check that device supports the required feature */
+		if ((psDeviceNode->pfnCheckDeviceFeature) &&
+		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
+							 RGX_FEATURE_COMPUTE_BIT_MASK))
+		{
+			psRGXGetLastDeviceErrorOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXGetLastDeviceError_exit;
+		}
+	}
+
+	PVR_UNREFERENCED_PARAMETER(psRGXGetLastDeviceErrorIN);
+
+	psRGXGetLastDeviceErrorOUT->eError =
+	    PVRSRVRGXGetLastDeviceErrorKM(psConnection, OSGetDevNode(psConnection),
+					  &psRGXGetLastDeviceErrorOUT->ui32Error);
+
+RGXGetLastDeviceError_exit:
+
+	return 0;
+}
+
+static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
+	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+
+static IMG_INT
+PVRSRVBridgeRGXKickTimestampQuery(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXKickTimestampQueryIN_UI8,
+				  IMG_UINT8 * psRGXKickTimestampQueryOUT_UI8,
+				  CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY *psRGXKickTimestampQueryIN =
+	    (PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY *)
+	    IMG_OFFSET_ADDR(psRGXKickTimestampQueryIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY *psRGXKickTimestampQueryOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY *)
+	    IMG_OFFSET_ADDR(psRGXKickTimestampQueryOUT_UI8, 0);
+
+	IMG_HANDLE hComputeContext = psRGXKickTimestampQueryIN->hComputeContext;
+	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
+	IMG_CHAR *uiUpdateFenceNameInt = NULL;
+	IMG_BYTE *ui8DMCmdInt = NULL;
+
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
+
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
+	    ((IMG_UINT64) psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE)) + 0;
+
+	if (unlikely(psRGXKickTimestampQueryIN->ui32CmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
+	{
+		psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTimestampQuery_exit;
+	}
+
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
+
+		/* Check that device supports the required feature */
+		if ((psDeviceNode->pfnCheckDeviceFeature) &&
+		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
+							 RGX_FEATURE_COMPUTE_BIT_MASK))
+		{
+			psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXKickTimestampQuery_exit;
+		}
+	}
+
+	if (ui64BufferSize > IMG_UINT32_MAX)
+	{
+		psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXKickTimestampQuery_exit;
+	}
+
+	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
+
+	if (ui32BufferSize != 0)
+	{
+		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
+		IMG_UINT32 ui32InBufferOffset =
+		    PVR_ALIGN(sizeof(*psRGXKickTimestampQueryIN), sizeof(unsigned long));
+		IMG_UINT32 ui32InBufferExcessSize =
+		    ui32InBufferOffset >=
+		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
+
+		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
+		if (bHaveEnoughSpace)
+		{
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickTimestampQueryIN;
+
+			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
+		}
+		else
+		{
+			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
+
+			if (!pArrayArgsBuffer)
+			{
+				psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXKickTimestampQuery_exit;
+			}
+		}
+	}
+
+	{
+		uiUpdateFenceNameInt =
+		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+	}
+
+	/* Copy the data over */
+	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, uiUpdateFenceNameInt,
+		     (const void __user *)psRGXKickTimestampQueryIN->puiUpdateFenceName,
+		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		{
+			psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXKickTimestampQuery_exit;
+		}
+		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
+						    1] = '\0';
+	}
+	if (psRGXKickTimestampQueryIN->ui32CmdSize != 0)
+	{
+		ui8DMCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE);
+	}
+
+	/* Copy the data over */
+	if (psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui8DMCmdInt, (const void __user *)psRGXKickTimestampQueryIN->pui8DMCmd,
+		     psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		{
+			psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXNotifyComputeWriteOffsetUpdate_exit;
+			goto RGXKickTimestampQuery_exit;
 		}
 	}
 
@@ -537,23 +879,29 @@ PVRSRVBridgeRGXNotifyComputeWriteOffsetUpdate(IMG_UINT32 ui32DispatchTableEntry,
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXNotifyComputeWriteOffsetUpdateOUT->eError =
+	psRGXKickTimestampQueryOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
 				       (void **)&psComputeContextInt,
 				       hComputeContext,
 				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXNotifyComputeWriteOffsetUpdateOUT->eError != PVRSRV_OK))
+	if (unlikely(psRGXKickTimestampQueryOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXNotifyComputeWriteOffsetUpdate_exit;
+		goto RGXKickTimestampQuery_exit;
 	}
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXNotifyComputeWriteOffsetUpdateOUT->eError =
-	    PVRSRVRGXNotifyComputeWriteOffsetUpdateKM(psComputeContextInt);
+	psRGXKickTimestampQueryOUT->eError =
+	    PVRSRVRGXKickTimestampQueryKM(psComputeContextInt,
+					  psRGXKickTimestampQueryIN->hCheckFenceFd,
+					  psRGXKickTimestampQueryIN->hUpdateTimeline,
+					  &psRGXKickTimestampQueryOUT->hUpdateFence,
+					  uiUpdateFenceNameInt,
+					  psRGXKickTimestampQueryIN->ui32CmdSize,
+					  ui8DMCmdInt, psRGXKickTimestampQueryIN->ui32ExtJobRef);
 
-RGXNotifyComputeWriteOffsetUpdate_exit:
+RGXKickTimestampQuery_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
@@ -568,6 +916,15 @@ PVRSRVBridgeRGXNotifyComputeWriteOffsetUpdate(IMG_UINT32 ui32DispatchTableEntry,
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXKickTimestampQueryOUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
 	return 0;
 }
 
@@ -581,16 +938,16 @@ static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
 	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
 
 static IMG_INT
-PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
-			IMG_UINT8 * psRGXKickCDM2IN_UI8,
-			IMG_UINT8 * psRGXKickCDM2OUT_UI8, CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXKickCDM(IMG_UINT32 ui32DispatchTableEntry,
+		       IMG_UINT8 * psRGXKickCDMIN_UI8,
+		       IMG_UINT8 * psRGXKickCDMOUT_UI8, CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXKICKCDM2 *psRGXKickCDM2IN =
-	    (PVRSRV_BRIDGE_IN_RGXKICKCDM2 *) IMG_OFFSET_ADDR(psRGXKickCDM2IN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXKICKCDM2 *psRGXKickCDM2OUT =
-	    (PVRSRV_BRIDGE_OUT_RGXKICKCDM2 *) IMG_OFFSET_ADDR(psRGXKickCDM2OUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXKICKCDM *psRGXKickCDMIN =
+	    (PVRSRV_BRIDGE_IN_RGXKICKCDM *) IMG_OFFSET_ADDR(psRGXKickCDMIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXKICKCDM *psRGXKickCDMOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXKICKCDM *) IMG_OFFSET_ADDR(psRGXKickCDMOUT_UI8, 0);
 
-	IMG_HANDLE hComputeContext = psRGXKickCDM2IN->hComputeContext;
+	IMG_HANDLE hComputeContext = psRGXKickCDMIN->hComputeContext;
 	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
 	SYNC_PRIMITIVE_BLOCK **psClientUpdateUFOSyncPrimBlockInt = NULL;
 	IMG_HANDLE *hClientUpdateUFOSyncPrimBlockInt2 = NULL;
@@ -608,32 +965,32 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 
 	IMG_UINT32 ui32BufferSize = 0;
 	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
 	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32CmdSize * sizeof(IMG_BYTE)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(PMR *)) +
-	    ((IMG_UINT64) psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32CmdSize * sizeof(IMG_BYTE)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32SyncPMRCount * sizeof(PMR *)) +
+	    ((IMG_UINT64) psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
 
-	if (unlikely(psRGXKickCDM2IN->ui32ClientUpdateCount > PVRSRV_MAX_SYNCS))
+	if (unlikely(psRGXKickCDMIN->ui32ClientUpdateCount > PVRSRV_MAX_SYNCS))
 	{
-		psRGXKickCDM2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickCDM2_exit;
+		psRGXKickCDMOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickCDM_exit;
 	}
 
-	if (unlikely(psRGXKickCDM2IN->ui32CmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
+	if (unlikely(psRGXKickCDMIN->ui32CmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
 	{
-		psRGXKickCDM2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickCDM2_exit;
+		psRGXKickCDMOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickCDM_exit;
 	}
 
-	if (unlikely(psRGXKickCDM2IN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
+	if (unlikely(psRGXKickCDMIN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
 	{
-		psRGXKickCDM2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickCDM2_exit;
+		psRGXKickCDMOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickCDM_exit;
 	}
 
 	{
@@ -644,16 +1001,16 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
 							 RGX_FEATURE_COMPUTE_BIT_MASK))
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXKickCDM2OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXKickCDM2_exit;
+		psRGXKickCDMOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXKickCDM_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -662,7 +1019,7 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXKickCDM2IN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXKickCDMIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -670,7 +1027,7 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickCDM2IN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickCDMIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -680,77 +1037,77 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXKickCDM2OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXKickCDM2_exit;
+				psRGXKickCDMOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXKickCDM_exit;
 			}
 		}
 	}
 
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount != 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount != 0)
 	{
 		psClientUpdateUFOSyncPrimBlockInt =
 		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
 		OSCachedMemSet(psClientUpdateUFOSyncPrimBlockInt, 0,
-			       psRGXKickCDM2IN->ui32ClientUpdateCount *
+			       psRGXKickCDMIN->ui32ClientUpdateCount *
 			       sizeof(SYNC_PRIMITIVE_BLOCK *));
 		ui32NextOffset +=
-		    psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
+		    psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
 		hClientUpdateUFOSyncPrimBlockInt2 =
 		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE);
+		ui32NextOffset += psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_HANDLE);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE) > 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_HANDLE) > 0)
 	{
 		if (OSCopyFromUser
 		    (NULL, hClientUpdateUFOSyncPrimBlockInt2,
-		     (const void __user *)psRGXKickCDM2IN->phClientUpdateUFOSyncPrimBlock,
-		     psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		     (const void __user *)psRGXKickCDMIN->phClientUpdateUFOSyncPrimBlock,
+		     psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount != 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount != 0)
 	{
 		ui32ClientUpdateOffsetInt =
 		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
+		ui32NextOffset += psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
 	{
 		if (OSCopyFromUser
 		    (NULL, ui32ClientUpdateOffsetInt,
-		     (const void __user *)psRGXKickCDM2IN->pui32ClientUpdateOffset,
-		     psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		     (const void __user *)psRGXKickCDMIN->pui32ClientUpdateOffset,
+		     psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount != 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount != 0)
 	{
 		ui32ClientUpdateValueInt =
 		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
+		ui32NextOffset += psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
+	if (psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
 	{
 		if (OSCopyFromUser
 		    (NULL, ui32ClientUpdateValueInt,
-		     (const void __user *)psRGXKickCDM2IN->pui32ClientUpdateValue,
-		     psRGXKickCDM2IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		     (const void __user *)psRGXKickCDMIN->pui32ClientUpdateValue,
+		     psRGXKickCDMIN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
 
@@ -765,73 +1122,73 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		if (OSCopyFromUser
 		    (NULL, uiUpdateFenceNameInt,
-		     (const void __user *)psRGXKickCDM2IN->puiUpdateFenceName,
+		     (const void __user *)psRGXKickCDMIN->puiUpdateFenceName,
 		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
 						    1] = '\0';
 	}
-	if (psRGXKickCDM2IN->ui32CmdSize != 0)
+	if (psRGXKickCDMIN->ui32CmdSize != 0)
 	{
 		ui8DMCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32CmdSize * sizeof(IMG_BYTE);
+		ui32NextOffset += psRGXKickCDMIN->ui32CmdSize * sizeof(IMG_BYTE);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32CmdSize * sizeof(IMG_BYTE) > 0)
+	if (psRGXKickCDMIN->ui32CmdSize * sizeof(IMG_BYTE) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui8DMCmdInt, (const void __user *)psRGXKickCDM2IN->pui8DMCmd,
-		     psRGXKickCDM2IN->ui32CmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		    (NULL, ui8DMCmdInt, (const void __user *)psRGXKickCDMIN->pui8DMCmd,
+		     psRGXKickCDMIN->ui32CmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
-	if (psRGXKickCDM2IN->ui32SyncPMRCount != 0)
+	if (psRGXKickCDMIN->ui32SyncPMRCount != 0)
 	{
 		ui32SyncPMRFlagsInt =
 		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_UINT32);
+		ui32NextOffset += psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_UINT32);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
+	if (psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
 	{
 		if (OSCopyFromUser
 		    (NULL, ui32SyncPMRFlagsInt,
-		     (const void __user *)psRGXKickCDM2IN->pui32SyncPMRFlags,
-		     psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		     (const void __user *)psRGXKickCDMIN->pui32SyncPMRFlags,
+		     psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
-	if (psRGXKickCDM2IN->ui32SyncPMRCount != 0)
+	if (psRGXKickCDMIN->ui32SyncPMRCount != 0)
 	{
 		psSyncPMRsInt = (PMR **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psSyncPMRsInt, 0, psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(PMR *));
-		ui32NextOffset += psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(PMR *);
+		OSCachedMemSet(psSyncPMRsInt, 0, psRGXKickCDMIN->ui32SyncPMRCount * sizeof(PMR *));
+		ui32NextOffset += psRGXKickCDMIN->ui32SyncPMRCount * sizeof(PMR *);
 		hSyncPMRsInt2 = (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
+		ui32NextOffset += psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
+	if (psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, hSyncPMRsInt2, (const void __user *)psRGXKickCDM2IN->phSyncPMRs,
-		     psRGXKickCDM2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		    (NULL, hSyncPMRsInt2, (const void __user *)psRGXKickCDMIN->phSyncPMRs,
+		     psRGXKickCDMIN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
 		{
-			psRGXKickCDM2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickCDMOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickCDM2_exit;
+			goto RGXKickCDM_exit;
 		}
 	}
 
@@ -839,34 +1196,34 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXKickCDM2OUT->eError =
+	psRGXKickCDMOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
 				       (void **)&psComputeContextInt,
 				       hComputeContext,
 				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXKickCDM2OUT->eError != PVRSRV_OK))
+	if (unlikely(psRGXKickCDMOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXKickCDM2_exit;
+		goto RGXKickCDM_exit;
 	}
 
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickCDM2IN->ui32ClientUpdateCount; i++)
+		for (i = 0; i < psRGXKickCDMIN->ui32ClientUpdateCount; i++)
 		{
 			/* Look up the address from the handle */
-			psRGXKickCDM2OUT->eError =
+			psRGXKickCDMOUT->eError =
 			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
 						       (void **)
 						       &psClientUpdateUFOSyncPrimBlockInt[i],
 						       hClientUpdateUFOSyncPrimBlockInt2[i],
 						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
 						       IMG_TRUE);
-			if (unlikely(psRGXKickCDM2OUT->eError != PVRSRV_OK))
+			if (unlikely(psRGXKickCDMOUT->eError != PVRSRV_OK))
 			{
 				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickCDM2_exit;
+				goto RGXKickCDM_exit;
 			}
 		}
 	}
@@ -874,46 +1231,47 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickCDM2IN->ui32SyncPMRCount; i++)
+		for (i = 0; i < psRGXKickCDMIN->ui32SyncPMRCount; i++)
 		{
 			/* Look up the address from the handle */
-			psRGXKickCDM2OUT->eError =
+			psRGXKickCDMOUT->eError =
 			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
 						       (void **)&psSyncPMRsInt[i],
 						       hSyncPMRsInt2[i],
 						       PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
-			if (unlikely(psRGXKickCDM2OUT->eError != PVRSRV_OK))
+			if (unlikely(psRGXKickCDMOUT->eError != PVRSRV_OK))
 			{
 				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickCDM2_exit;
+				goto RGXKickCDM_exit;
 			}
 		}
 	}
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXKickCDM2OUT->eError =
+	psRGXKickCDMOUT->eError =
 	    PVRSRVRGXKickCDMKM(psComputeContextInt,
-			       psRGXKickCDM2IN->ui32ClientUpdateCount,
+			       psRGXKickCDMIN->ui32ClientUpdateCount,
 			       psClientUpdateUFOSyncPrimBlockInt,
 			       ui32ClientUpdateOffsetInt,
 			       ui32ClientUpdateValueInt,
-			       psRGXKickCDM2IN->hCheckFenceFd,
-			       psRGXKickCDM2IN->hUpdateTimeline,
-			       &psRGXKickCDM2OUT->hUpdateFence,
+			       psRGXKickCDMIN->hCheckFenceFd,
+			       psRGXKickCDMIN->hUpdateTimeline,
+			       &psRGXKickCDMOUT->hUpdateFence,
 			       uiUpdateFenceNameInt,
-			       psRGXKickCDM2IN->ui32CmdSize,
+			       psRGXKickCDMIN->hExportFenceToSignal,
+			       psRGXKickCDMIN->ui32CmdSize,
 			       ui8DMCmdInt,
-			       psRGXKickCDM2IN->ui32PDumpFlags,
-			       psRGXKickCDM2IN->ui32ExtJobRef,
-			       psRGXKickCDM2IN->ui32SyncPMRCount,
+			       psRGXKickCDMIN->ui32PDumpFlags,
+			       psRGXKickCDMIN->ui32ExtJobRef,
+			       psRGXKickCDMIN->ui32SyncPMRCount,
 			       ui32SyncPMRFlagsInt,
 			       psSyncPMRsInt,
-			       psRGXKickCDM2IN->ui32NumOfWorkgroups,
-			       psRGXKickCDM2IN->ui32NumOfWorkitems,
-			       psRGXKickCDM2IN->ui64DeadlineInus);
+			       psRGXKickCDMIN->ui32NumOfWorkgroups,
+			       psRGXKickCDMIN->ui32NumOfWorkitems,
+			       psRGXKickCDMIN->ui64DeadlineInus, &psRGXKickCDMOUT->ui32IntJobRef);
 
-RGXKickCDM2_exit:
+RGXKickCDM_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
@@ -930,7 +1288,7 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickCDM2IN->ui32ClientUpdateCount; i++)
+		for (i = 0; i < psRGXKickCDMIN->ui32ClientUpdateCount; i++)
 		{
 
 			/* Unreference the previously looked up handle */
@@ -948,7 +1306,7 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickCDM2IN->ui32SyncPMRCount; i++)
+		for (i = 0; i < psRGXKickCDMIN->ui32SyncPMRCount; i++)
 		{
 
 			/* Unreference the previously looked up handle */
@@ -965,7 +1323,7 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXKickCDM2OUT->eError == PVRSRV_OK)
+	if (psRGXKickCDMOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -975,21 +1333,27 @@ PVRSRVBridgeRGXKickCDM2(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
+static PVRSRV_ERROR _RGXCDMGetSharedMemorypsCLIPMRMemIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = PVRSRVRGXCDMReleaseSharedMemoryKM((PMR *) pvData);
+	return eError;
+}
+
 static IMG_INT
-PVRSRVBridgeRGXSetComputeContextProperty(IMG_UINT32 ui32DispatchTableEntry,
-					 IMG_UINT8 * psRGXSetComputeContextPropertyIN_UI8,
-					 IMG_UINT8 * psRGXSetComputeContextPropertyOUT_UI8,
-					 CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXCDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXCDMGetSharedMemoryIN_UI8,
+				  IMG_UINT8 * psRGXCDMGetSharedMemoryOUT_UI8,
+				  CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPROPERTY *psRGXSetComputeContextPropertyIN =
-	    (PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPROPERTY *)
-	    IMG_OFFSET_ADDR(psRGXSetComputeContextPropertyIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPROPERTY *psRGXSetComputeContextPropertyOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPROPERTY *)
-	    IMG_OFFSET_ADDR(psRGXSetComputeContextPropertyOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXCDMGETSHAREDMEMORY *psRGXCDMGetSharedMemoryIN =
+	    (PVRSRV_BRIDGE_IN_RGXCDMGETSHAREDMEMORY *)
+	    IMG_OFFSET_ADDR(psRGXCDMGetSharedMemoryIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCDMGETSHAREDMEMORY *psRGXCDMGetSharedMemoryOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCDMGETSHAREDMEMORY *)
+	    IMG_OFFSET_ADDR(psRGXCDMGetSharedMemoryOUT_UI8, 0);
 
-	IMG_HANDLE hComputeContext = psRGXSetComputeContextPropertyIN->hComputeContext;
-	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
+	PMR *psCLIPMRMemInt = NULL;
 
 	{
 		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
@@ -999,124 +1363,68 @@ PVRSRVBridgeRGXSetComputeContextProperty(IMG_UINT32 ui32DispatchTableEntry,
 		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
 							 RGX_FEATURE_COMPUTE_BIT_MASK))
 		{
-			psRGXSetComputeContextPropertyOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+			psRGXCDMGetSharedMemoryOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
 
-			goto RGXSetComputeContextProperty_exit;
+			goto RGXCDMGetSharedMemory_exit;
 		}
 	}
 
-	/* Lock over handle lookup. */
-	LockHandle(psConnection->psHandleBase);
+	PVR_UNREFERENCED_PARAMETER(psRGXCDMGetSharedMemoryIN);
 
-	/* Look up the address from the handle */
-	psRGXSetComputeContextPropertyOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psComputeContextInt,
-				       hComputeContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXSetComputeContextPropertyOUT->eError != PVRSRV_OK))
+	psRGXCDMGetSharedMemoryOUT->eError =
+	    PVRSRVRGXCDMGetSharedMemoryKM(psConnection, OSGetDevNode(psConnection),
+					  &psCLIPMRMemInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXCDMGetSharedMemoryOUT->eError != PVRSRV_OK))
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXSetComputeContextProperty_exit;
+		goto RGXCDMGetSharedMemory_exit;
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-	psRGXSetComputeContextPropertyOUT->eError =
-	    PVRSRVRGXSetComputeContextPropertyKM(psComputeContextInt,
-						 psRGXSetComputeContextPropertyIN->ui32Property,
-						 psRGXSetComputeContextPropertyIN->ui64Input,
-						 &psRGXSetComputeContextPropertyOUT->ui64Output);
-
-RGXSetComputeContextProperty_exit:
 
-	/* Lock over handle lookup cleanup. */
+	/* Lock over handle creation. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Unreference the previously looked up handle */
-	if (psComputeContextInt)
+	psRGXCDMGetSharedMemoryOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+								       &psRGXCDMGetSharedMemoryOUT->
+								       hCLIPMRMem,
+								       (void *)psCLIPMRMemInt,
+								       PVRSRV_HANDLE_TYPE_PMR_LOCAL_EXPORT_HANDLE,
+								       PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+								       (PFN_HANDLE_RELEASE) &
+								       _RGXCDMGetSharedMemorypsCLIPMRMemIntRelease);
+	if (unlikely(psRGXCDMGetSharedMemoryOUT->eError != PVRSRV_OK))
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hComputeContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT);
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCDMGetSharedMemory_exit;
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	return 0;
-}
+	/* Release now we have created handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-static IMG_INT
-PVRSRVBridgeRGXGetLastDeviceError(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXGetLastDeviceErrorIN_UI8,
-				  IMG_UINT8 * psRGXGetLastDeviceErrorOUT_UI8,
-				  CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXGETLASTDEVICEERROR *psRGXGetLastDeviceErrorIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETLASTDEVICEERROR *)
-	    IMG_OFFSET_ADDR(psRGXGetLastDeviceErrorIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETLASTDEVICEERROR *psRGXGetLastDeviceErrorOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXGETLASTDEVICEERROR *)
-	    IMG_OFFSET_ADDR(psRGXGetLastDeviceErrorOUT_UI8, 0);
+RGXCDMGetSharedMemory_exit:
 
+	if (psRGXCDMGetSharedMemoryOUT->eError != PVRSRV_OK)
 	{
-		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
-
-		/* Check that device supports the required feature */
-		if ((psDeviceNode->pfnCheckDeviceFeature) &&
-		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
-							 RGX_FEATURE_COMPUTE_BIT_MASK))
+		if (psCLIPMRMemInt)
 		{
-			psRGXGetLastDeviceErrorOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
-
-			goto RGXGetLastDeviceError_exit;
+			PVRSRVRGXCDMReleaseSharedMemoryKM(psCLIPMRMemInt);
 		}
 	}
 
-	PVR_UNREFERENCED_PARAMETER(psRGXGetLastDeviceErrorIN);
-
-	psRGXGetLastDeviceErrorOUT->eError =
-	    PVRSRVRGXGetLastDeviceErrorKM(psConnection, OSGetDevNode(psConnection),
-					  &psRGXGetLastDeviceErrorOUT->ui32Error);
-
-RGXGetLastDeviceError_exit:
-
 	return 0;
 }
 
-static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
-
 static IMG_INT
-PVRSRVBridgeRGXKickTimestampQuery(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXKickTimestampQueryIN_UI8,
-				  IMG_UINT8 * psRGXKickTimestampQueryOUT_UI8,
-				  CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXCDMReleaseSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
+				      IMG_UINT8 * psRGXCDMReleaseSharedMemoryIN_UI8,
+				      IMG_UINT8 * psRGXCDMReleaseSharedMemoryOUT_UI8,
+				      CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY *psRGXKickTimestampQueryIN =
-	    (PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY *)
-	    IMG_OFFSET_ADDR(psRGXKickTimestampQueryIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY *psRGXKickTimestampQueryOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY *)
-	    IMG_OFFSET_ADDR(psRGXKickTimestampQueryOUT_UI8, 0);
-
-	IMG_HANDLE hComputeContext = psRGXKickTimestampQueryIN->hComputeContext;
-	RGX_SERVER_COMPUTE_CONTEXT *psComputeContextInt = NULL;
-	IMG_BYTE *ui8DMCmdInt = NULL;
-
-	IMG_UINT32 ui32NextOffset = 0;
-	IMG_BYTE *pArrayArgsBuffer = NULL;
-	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
-
-	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE)) + 0;
-
-	if (unlikely(psRGXKickTimestampQueryIN->ui32CmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
-	{
-		psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTimestampQuery_exit;
-	}
+	PVRSRV_BRIDGE_IN_RGXCDMRELEASESHAREDMEMORY *psRGXCDMReleaseSharedMemoryIN =
+	    (PVRSRV_BRIDGE_IN_RGXCDMRELEASESHAREDMEMORY *)
+	    IMG_OFFSET_ADDR(psRGXCDMReleaseSharedMemoryIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCDMRELEASESHAREDMEMORY *psRGXCDMReleaseSharedMemoryOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCDMRELEASESHAREDMEMORY *)
+	    IMG_OFFSET_ADDR(psRGXCDMReleaseSharedMemoryOUT_UI8, 0);
 
 	{
 		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
@@ -1126,113 +1434,34 @@ PVRSRVBridgeRGXKickTimestampQuery(IMG_UINT32 ui32DispatchTableEntry,
 		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
 							 RGX_FEATURE_COMPUTE_BIT_MASK))
 		{
-			psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
-
-			goto RGXKickTimestampQuery_exit;
-		}
-	}
-
-	if (ui64BufferSize > IMG_UINT32_MAX)
-	{
-		psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXKickTimestampQuery_exit;
-	}
-
-	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
-
-	if (ui32BufferSize != 0)
-	{
-		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
-		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXKickTimestampQueryIN), sizeof(unsigned long));
-		IMG_UINT32 ui32InBufferExcessSize =
-		    ui32InBufferOffset >=
-		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
-
-		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
-		if (bHaveEnoughSpace)
-		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickTimestampQueryIN;
-
-			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
-		}
-		else
-		{
-			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
-
-			if (!pArrayArgsBuffer)
-			{
-				psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXKickTimestampQuery_exit;
-			}
-		}
-	}
-
-	if (psRGXKickTimestampQueryIN->ui32CmdSize != 0)
-	{
-		ui8DMCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE);
-	}
-
-	/* Copy the data over */
-	if (psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, ui8DMCmdInt, (const void __user *)psRGXKickTimestampQueryIN->pui8DMCmd,
-		     psRGXKickTimestampQueryIN->ui32CmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
-		{
-			psRGXKickTimestampQueryOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCDMReleaseSharedMemoryOUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
 
-			goto RGXKickTimestampQuery_exit;
+			goto RGXCDMReleaseSharedMemory_exit;
 		}
 	}
 
-	/* Lock over handle lookup. */
+	/* Lock over handle destruction. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Look up the address from the handle */
-	psRGXKickTimestampQueryOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psComputeContextInt,
-				       hComputeContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXKickTimestampQueryOUT->eError != PVRSRV_OK))
+	psRGXCDMReleaseSharedMemoryOUT->eError =
+	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
+					      (IMG_HANDLE) psRGXCDMReleaseSharedMemoryIN->hPMRMem,
+					      PVRSRV_HANDLE_TYPE_PMR_LOCAL_EXPORT_HANDLE);
+	if (unlikely((psRGXCDMReleaseSharedMemoryOUT->eError != PVRSRV_OK) &&
+		     (psRGXCDMReleaseSharedMemoryOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
+		     (psRGXCDMReleaseSharedMemoryOUT->eError != PVRSRV_ERROR_RETRY)))
 	{
+		PVR_DPF((PVR_DBG_ERROR,
+			 "%s: %s",
+			 __func__, PVRSRVGetErrorString(psRGXCDMReleaseSharedMemoryOUT->eError)));
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXKickTimestampQuery_exit;
+		goto RGXCDMReleaseSharedMemory_exit;
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-	psRGXKickTimestampQueryOUT->eError =
-	    PVRSRVRGXKickTimestampQueryKM(psComputeContextInt,
-					  psRGXKickTimestampQueryIN->hCheckFenceFd,
-					  psRGXKickTimestampQueryIN->ui32CmdSize,
-					  ui8DMCmdInt, psRGXKickTimestampQueryIN->ui32ExtJobRef);
-
-RGXKickTimestampQuery_exit:
-
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
 
-	/* Unreference the previously looked up handle */
-	if (psComputeContextInt)
-	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hComputeContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_COMPUTE_CONTEXT);
-	}
-	/* Release now we have cleaned up look up handles. */
+	/* Release now we have destroyed handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	/* Allocated space should be equal to the last updated offset */
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXKickTimestampQueryOUT->eError == PVRSRV_OK)
-		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
-#endif /* PVRSRV_NEED_PVR_ASSERT */
-
-	if (!bHaveEnoughSpace && pArrayArgsBuffer)
-		OSFreeMemNoStats(pArrayArgsBuffer);
+RGXCDMReleaseSharedMemory_exit:
 
 	return 0;
 }
@@ -1251,34 +1480,64 @@ PVRSRV_ERROR InitRGXCMPBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXCREATECOMPUTECONTEXT,
-			      PVRSRVBridgeRGXCreateComputeContext, NULL);
+			      PVRSRVBridgeRGXCreateComputeContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATECOMPUTECONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATECOMPUTECONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXDESTROYCOMPUTECONTEXT,
-			      PVRSRVBridgeRGXDestroyComputeContext, NULL);
+			      PVRSRVBridgeRGXDestroyComputeContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYCOMPUTECONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYCOMPUTECONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXFLUSHCOMPUTEDATA,
-			      PVRSRVBridgeRGXFlushComputeData, NULL);
+			      PVRSRVBridgeRGXFlushComputeData, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFLUSHCOMPUTEDATA),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFLUSHCOMPUTEDATA));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXSENDCANCELCMD,
+			      PVRSRVBridgeRGXSendCancelCmd, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSENDCANCELCMD),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSENDCANCELCMD));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 			      PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPRIORITY,
-			      PVRSRVBridgeRGXSetComputeContextPriority, NULL);
+			      PVRSRVBridgeRGXSetComputeContextPriority, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPRIORITY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPRIORITY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 			      PVRSRV_BRIDGE_RGXCMP_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE,
-			      PVRSRVBridgeRGXNotifyComputeWriteOffsetUpdate, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM2,
-			      PVRSRVBridgeRGXKickCDM2, NULL);
+			      PVRSRVBridgeRGXNotifyComputeWriteOffsetUpdate, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 			      PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPROPERTY,
-			      PVRSRVBridgeRGXSetComputeContextProperty, NULL);
+			      PVRSRVBridgeRGXSetComputeContextProperty, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETCOMPUTECONTEXTPROPERTY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETCOMPUTECONTEXTPROPERTY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXGETLASTDEVICEERROR,
-			      PVRSRVBridgeRGXGetLastDeviceError, NULL);
+			      PVRSRVBridgeRGXGetLastDeviceError, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETLASTDEVICEERROR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKTIMESTAMPQUERY,
-			      PVRSRVBridgeRGXKickTimestampQuery, NULL);
+			      PVRSRVBridgeRGXKickTimestampQuery, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXKICKTIMESTAMPQUERY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXKICKTIMESTAMPQUERY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM,
+			      PVRSRVBridgeRGXKickCDM, NULL, sizeof(PVRSRV_BRIDGE_IN_RGXKICKCDM),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXKICKCDM));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXCDMGETSHAREDMEMORY,
+			      PVRSRVBridgeRGXCDMGetSharedMemory, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCDMGETSHAREDMEMORY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXCDMRELEASESHAREDMEMORY,
+			      PVRSRVBridgeRGXCDMReleaseSharedMemory, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCDMRELEASESHAREDMEMORY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCDMRELEASESHAREDMEMORY));
 
 	return PVRSRV_OK;
 }
@@ -1296,14 +1555,14 @@ void DeinitRGXCMPBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXFLUSHCOMPUTEDATA);
 
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXSENDCANCELCMD);
+
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 				PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPRIORITY);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 				PVRSRV_BRIDGE_RGXCMP_RGXNOTIFYCOMPUTEWRITEOFFSETUPDATE);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM2);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
 				PVRSRV_BRIDGE_RGXCMP_RGXSETCOMPUTECONTEXTPROPERTY);
 
@@ -1311,4 +1570,11 @@ void DeinitRGXCMPBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKTIMESTAMPQUERY);
 
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXKICKCDM);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP, PVRSRV_BRIDGE_RGXCMP_RGXCDMGETSHAREDMEMORY);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXCMP,
+				PVRSRV_BRIDGE_RGXCMP_RGXCDMRELEASESHAREDMEMORY);
+
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxfwdbg_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxfwdbg_bridge.c
index b186658608cf..e5646490aa2d 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxfwdbg_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxfwdbg_bridge.c
@@ -109,43 +109,40 @@ PVRSRVBridgeRGXFWDebugDumpFreelistPageList(IMG_UINT32 ui32DispatchTableEntry,
 }
 
 static IMG_INT
-PVRSRVBridgeRGXFWDebugSuspendDevice(IMG_UINT32 ui32DispatchTableEntry,
-				    IMG_UINT8 * psRGXFWDebugSuspendDeviceIN_UI8,
-				    IMG_UINT8 * psRGXFWDebugSuspendDeviceOUT_UI8,
-				    CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXFWDebugPowerOff(IMG_UINT32 ui32DispatchTableEntry,
+			       IMG_UINT8 * psRGXFWDebugPowerOffIN_UI8,
+			       IMG_UINT8 * psRGXFWDebugPowerOffOUT_UI8,
+			       CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXFWDEBUGSUSPENDDEVICE *psRGXFWDebugSuspendDeviceIN =
-	    (PVRSRV_BRIDGE_IN_RGXFWDEBUGSUSPENDDEVICE *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugSuspendDeviceIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXFWDEBUGSUSPENDDEVICE *psRGXFWDebugSuspendDeviceOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXFWDEBUGSUSPENDDEVICE *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugSuspendDeviceOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWEROFF *psRGXFWDebugPowerOffIN =
+	    (PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWEROFF *) IMG_OFFSET_ADDR(psRGXFWDebugPowerOffIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWEROFF *psRGXFWDebugPowerOffOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWEROFF *) IMG_OFFSET_ADDR(psRGXFWDebugPowerOffOUT_UI8,
+								     0);
 
-	PVR_UNREFERENCED_PARAMETER(psRGXFWDebugSuspendDeviceIN);
+	PVR_UNREFERENCED_PARAMETER(psRGXFWDebugPowerOffIN);
 
-	psRGXFWDebugSuspendDeviceOUT->eError =
-	    PVRSRVRGXFWDebugSuspendDeviceKM(psConnection, OSGetDevNode(psConnection));
+	psRGXFWDebugPowerOffOUT->eError =
+	    PVRSRVRGXFWDebugPowerOffKM(psConnection, OSGetDevNode(psConnection));
 
 	return 0;
 }
 
 static IMG_INT
-PVRSRVBridgeRGXFWDebugResumeDevice(IMG_UINT32 ui32DispatchTableEntry,
-				   IMG_UINT8 * psRGXFWDebugResumeDeviceIN_UI8,
-				   IMG_UINT8 * psRGXFWDebugResumeDeviceOUT_UI8,
-				   CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXFWDebugPowerOn(IMG_UINT32 ui32DispatchTableEntry,
+			      IMG_UINT8 * psRGXFWDebugPowerOnIN_UI8,
+			      IMG_UINT8 * psRGXFWDebugPowerOnOUT_UI8,
+			      CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXFWDEBUGRESUMEDEVICE *psRGXFWDebugResumeDeviceIN =
-	    (PVRSRV_BRIDGE_IN_RGXFWDEBUGRESUMEDEVICE *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugResumeDeviceIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXFWDEBUGRESUMEDEVICE *psRGXFWDebugResumeDeviceOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXFWDEBUGRESUMEDEVICE *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugResumeDeviceOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWERON *psRGXFWDebugPowerOnIN =
+	    (PVRSRV_BRIDGE_IN_RGXFWDEBUGPOWERON *) IMG_OFFSET_ADDR(psRGXFWDebugPowerOnIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWERON *psRGXFWDebugPowerOnOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWERON *) IMG_OFFSET_ADDR(psRGXFWDebugPowerOnOUT_UI8, 0);
 
-	PVR_UNREFERENCED_PARAMETER(psRGXFWDebugResumeDeviceIN);
+	PVR_UNREFERENCED_PARAMETER(psRGXFWDebugPowerOnIN);
 
-	psRGXFWDebugResumeDeviceOUT->eError =
-	    PVRSRVRGXFWDebugResumeDeviceKM(psConnection, OSGetDevNode(psConnection));
+	psRGXFWDebugPowerOnOUT->eError =
+	    PVRSRVRGXFWDebugPowerOnKM(psConnection, OSGetDevNode(psConnection));
 
 	return 0;
 }
@@ -171,7 +168,7 @@ PVRSRVBridgeRGXFWDebugSetVzConnectionCooldownPeriodInSec(IMG_UINT32 ui32Dispatch
 	    PVRSRVRGXFWDebugSetVzConnectionCooldownPeriodInSecKM(psConnection,
 								 OSGetDevNode(psConnection),
 								 psRGXFWDebugSetVzConnectionCooldownPeriodInSecIN->
-								 ui32ui32VzConnectionCooldownPeriodInSec);
+								 ui32VzConne);
 
 	return 0;
 }
@@ -233,7 +230,8 @@ PVRSRVBridgeRGXFWDebugSetDriverTimeSlice(IMG_UINT32 ui32DispatchTableEntry,
 	psRGXFWDebugSetDriverTimeSliceOUT->eError =
 	    PVRSRVRGXFWDebugSetDriverTimeSliceKM(psConnection, OSGetDevNode(psConnection),
 						 psRGXFWDebugSetDriverTimeSliceIN->ui32DriverID,
-						 psRGXFWDebugSetDriverTimeSliceIN->ui32TimeSlice);
+						 psRGXFWDebugSetDriverTimeSliceIN->
+						 ui32TSPercentage);
 
 	return 0;
 }
@@ -258,7 +256,7 @@ PVRSRVBridgeRGXFWDebugSetDriverTimeSliceInterval(IMG_UINT32 ui32DispatchTableEnt
 	psRGXFWDebugSetDriverTimeSliceIntervalOUT->eError =
 	    PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(psConnection, OSGetDevNode(psConnection),
 							 psRGXFWDebugSetDriverTimeSliceIntervalIN->
-							 ui32TimeSliceInterval);
+							 ui32TSIntervalMs);
 
 	return 0;
 }
@@ -381,41 +379,14 @@ PVRSRVBridgeRGXCurrentTime(IMG_UINT32 ui32DispatchTableEntry,
 	PVRSRV_BRIDGE_OUT_RGXCURRENTTIME *psRGXCurrentTimeOUT =
 	    (PVRSRV_BRIDGE_OUT_RGXCURRENTTIME *) IMG_OFFSET_ADDR(psRGXCurrentTimeOUT_UI8, 0);
 
-	PVR_UNREFERENCED_PARAMETER(psRGXCurrentTimeIN);
-
 	psRGXCurrentTimeOUT->eError =
 	    PVRSRVRGXCurrentTime(psConnection, OSGetDevNode(psConnection),
-				 &psRGXCurrentTimeOUT->ui64Time);
+				 psRGXCurrentTimeIN->ui8TimerType, &psRGXCurrentTimeOUT->ui64Time);
 
 	return 0;
 }
 
-#if defined(SUPPORT_VALIDATION)
-
-static IMG_INT
-PVRSRVBridgeRGXFWDebugInjectFault(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXFWDebugInjectFaultIN_UI8,
-				  IMG_UINT8 * psRGXFWDebugInjectFaultOUT_UI8,
-				  CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXFWDEBUGINJECTFAULT *psRGXFWDebugInjectFaultIN =
-	    (PVRSRV_BRIDGE_IN_RGXFWDEBUGINJECTFAULT *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugInjectFaultIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXFWDEBUGINJECTFAULT *psRGXFWDebugInjectFaultOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXFWDEBUGINJECTFAULT *)
-	    IMG_OFFSET_ADDR(psRGXFWDebugInjectFaultOUT_UI8, 0);
-
-	PVR_UNREFERENCED_PARAMETER(psRGXFWDebugInjectFaultIN);
-
-	psRGXFWDebugInjectFaultOUT->eError =
-	    PVRSRVRGXFWDebugInjectFaultKM(psConnection, OSGetDevNode(psConnection));
-
-	return 0;
-}
-
-#else
 #define PVRSRVBridgeRGXFWDebugInjectFault NULL
-#endif
 
 /* ***************************************************************************
  * Server bridge dispatch related glue
@@ -431,61 +402,89 @@ PVRSRV_ERROR InitRGXFWDBGBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETFWLOG,
-			      PVRSRVBridgeRGXFWDebugSetFWLog, NULL);
+			      PVRSRVBridgeRGXFWDebugSetFWLog, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETFWLOG),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETFWLOG));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGDUMPFREELISTPAGELIST,
-			      PVRSRVBridgeRGXFWDebugDumpFreelistPageList, NULL);
+			      PVRSRVBridgeRGXFWDebugDumpFreelistPageList, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGDUMPFREELISTPAGELIST));
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
-			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSUSPENDDEVICE,
-			      PVRSRVBridgeRGXFWDebugSuspendDevice, NULL);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWEROFF,
+			      PVRSRVBridgeRGXFWDebugPowerOff, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWEROFF));
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGRESUMEDEVICE,
-			      PVRSRVBridgeRGXFWDebugResumeDevice, NULL);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWERON,
+			      PVRSRVBridgeRGXFWDebugPowerOn, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGPOWERON));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC,
-			      PVRSRVBridgeRGXFWDebugSetVzConnectionCooldownPeriodInSec, NULL);
+			      PVRSRVBridgeRGXFWDebugSetVzConnectionCooldownPeriodInSec, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC),
+			      sizeof
+			      (PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETHCSDEADLINE,
-			      PVRSRVBridgeRGXFWDebugSetHCSDeadline, NULL);
+			      PVRSRVBridgeRGXFWDebugSetHCSDeadline, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETHCSDEADLINE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETHCSDEADLINE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETDRIVERPRIORITY,
-			      PVRSRVBridgeRGXFWDebugSetDriverPriority, NULL);
+			      PVRSRVBridgeRGXFWDebugSetDriverPriority, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERPRIORITY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERPRIORITY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETDRIVERTIMESLICE,
-			      PVRSRVBridgeRGXFWDebugSetDriverTimeSlice, NULL);
+			      PVRSRVBridgeRGXFWDebugSetDriverTimeSlice, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERTIMESLICE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETDRIVERTIMESLICEINTERVAL,
-			      PVRSRVBridgeRGXFWDebugSetDriverTimeSliceInterval, NULL);
+			      PVRSRVBridgeRGXFWDebugSetDriverTimeSliceInterval, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERTIMESLICEINTERVAL),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERTIMESLICEINTERVAL));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETDRIVERISOLATIONGROUP,
-			      PVRSRVBridgeRGXFWDebugSetDriverIsolationGroup, NULL);
+			      PVRSRVBridgeRGXFWDebugSetDriverIsolationGroup, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETDRIVERISOLATIONGROUP),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETDRIVERISOLATIONGROUP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 			      PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETOSNEWONLINESTATE,
-			      PVRSRVBridgeRGXFWDebugSetOSNewOnlineState, NULL);
+			      PVRSRVBridgeRGXFWDebugSetOSNewOnlineState, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGSETOSNEWONLINESTATE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGSETOSNEWONLINESTATE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGMAPGUESTHEAP,
-			      PVRSRVBridgeRGXFWDebugMapGuestHeap, NULL);
+			      PVRSRVBridgeRGXFWDebugMapGuestHeap, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGMAPGUESTHEAP),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGMAPGUESTHEAP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPHRCONFIGURE,
-			      PVRSRVBridgeRGXFWDebugPHRConfigure, NULL);
+			      PVRSRVBridgeRGXFWDebugPHRConfigure, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGPHRCONFIGURE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGPHRCONFIGURE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGWDGCONFIGURE,
-			      PVRSRVBridgeRGXFWDebugWdgConfigure, NULL);
+			      PVRSRVBridgeRGXFWDebugWdgConfigure, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXFWDEBUGWDGCONFIGURE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGWDGCONFIGURE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXCURRENTTIME,
-			      PVRSRVBridgeRGXCurrentTime, NULL);
+			      PVRSRVBridgeRGXCurrentTime, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCURRENTTIME),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCURRENTTIME));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGINJECTFAULT,
-			      PVRSRVBridgeRGXFWDebugInjectFault, NULL);
+			      PVRSRVBridgeRGXFWDebugInjectFault, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXFWDEBUGINJECTFAULT));
 
 	return PVRSRV_OK;
 }
@@ -501,11 +500,9 @@ void DeinitRGXFWDBGBridge(void)
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 				PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGDUMPFREELISTPAGELIST);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
-				PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSUSPENDDEVICE);
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWEROFF);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
-				PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGRESUMEDEVICE);
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG, PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGPOWERON);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXFWDBG,
 				PVRSRV_BRIDGE_RGXFWDBG_RGXFWDEBUGSETVZCONNECTIONCOOLDOWNPERIODINSEC);
diff --git a/drivers/gpu/drm/img-rogue/server_rgxhwperf_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxhwperf_bridge.c
index 9a88ae828497..ea76a5ef2fb1 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxhwperf_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxhwperf_bridge.c
@@ -66,83 +66,37 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * Server-side bridge entry points
  */
 
-static IMG_INT
-PVRSRVBridgeRGXCtrlHWPerf(IMG_UINT32 ui32DispatchTableEntry,
-			  IMG_UINT8 * psRGXCtrlHWPerfIN_UI8,
-			  IMG_UINT8 * psRGXCtrlHWPerfOUT_UI8, CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXCTRLHWPERF *psRGXCtrlHWPerfIN =
-	    (PVRSRV_BRIDGE_IN_RGXCTRLHWPERF *) IMG_OFFSET_ADDR(psRGXCtrlHWPerfIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCTRLHWPERF *psRGXCtrlHWPerfOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCTRLHWPERF *) IMG_OFFSET_ADDR(psRGXCtrlHWPerfOUT_UI8, 0);
-
-	psRGXCtrlHWPerfOUT->eError =
-	    PVRSRVRGXCtrlHWPerfKM(psConnection, OSGetDevNode(psConnection),
-				  psRGXCtrlHWPerfIN->ui32StreamId,
-				  psRGXCtrlHWPerfIN->bToggle, psRGXCtrlHWPerfIN->ui64Mask);
-
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXGetHWPerfBvncFeatureFlags(IMG_UINT32 ui32DispatchTableEntry,
-					 IMG_UINT8 * psRGXGetHWPerfBvncFeatureFlagsIN_UI8,
-					 IMG_UINT8 * psRGXGetHWPerfBvncFeatureFlagsOUT_UI8,
-					 CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXGETHWPERFBVNCFEATUREFLAGS *psRGXGetHWPerfBvncFeatureFlagsIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETHWPERFBVNCFEATUREFLAGS *)
-	    IMG_OFFSET_ADDR(psRGXGetHWPerfBvncFeatureFlagsIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS *psRGXGetHWPerfBvncFeatureFlagsOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS *)
-	    IMG_OFFSET_ADDR(psRGXGetHWPerfBvncFeatureFlagsOUT_UI8, 0);
-
-	PVR_UNREFERENCED_PARAMETER(psRGXGetHWPerfBvncFeatureFlagsIN);
-
-	psRGXGetHWPerfBvncFeatureFlagsOUT->eError =
-	    PVRSRVRGXGetHWPerfBvncFeatureFlagsKM(psConnection, OSGetDevNode(psConnection),
-						 &psRGXGetHWPerfBvncFeatureFlagsOUT->sBVNC);
-
-	return 0;
-}
-
-static_assert(RGXFWIF_HWPERF_CTRL_BLKS_MAX <= IMG_UINT32_MAX,
-	      "RGXFWIF_HWPERF_CTRL_BLKS_MAX must not be larger than IMG_UINT32_MAX");
+static_assert(1 <= IMG_UINT32_MAX, "1 must not be larger than IMG_UINT32_MAX");
 
 static IMG_INT
-PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
-				       IMG_UINT8 * psRGXConfigMuxHWPerfCountersIN_UI8,
-				       IMG_UINT8 * psRGXConfigMuxHWPerfCountersOUT_UI8,
-				       CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
+					   IMG_UINT8 * psRGXGetConfiguredHWPerfCountersIN_UI8,
+					   IMG_UINT8 * psRGXGetConfiguredHWPerfCountersOUT_UI8,
+					   CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS *psRGXConfigMuxHWPerfCountersIN =
-	    (PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXConfigMuxHWPerfCountersIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS *psRGXConfigMuxHWPerfCountersOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXConfigMuxHWPerfCountersOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS *psRGXGetConfiguredHWPerfCountersIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfCountersIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS *psRGXGetConfiguredHWPerfCountersOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfCountersOUT_UI8, 0);
 
-	RGX_HWPERF_CONFIG_MUX_CNTBLK *psBlockConfigsInt = NULL;
+	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCountersInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
 	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
 	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
-	     sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) + 0;
+	IMG_UINT64 ui64BufferSize = ((IMG_UINT64) 1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK)) + 0;
 
-	if (unlikely(psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
-	{
-		psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXConfigMuxHWPerfCounters_exit;
-	}
+	psRGXGetConfiguredHWPerfCountersOUT->psConfiguredCounters =
+	    psRGXGetConfiguredHWPerfCountersIN->psConfiguredCounters;
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXConfigMuxHWPerfCounters_exit;
+		psRGXGetConfiguredHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXGetConfiguredHWPerfCounters_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -151,7 +105,7 @@ PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXConfigMuxHWPerfCountersIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXGetConfiguredHWPerfCountersIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -160,7 +114,7 @@ PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 		if (bHaveEnoughSpace)
 		{
 			IMG_BYTE *pInputBuffer =
-			    (IMG_BYTE *) (void *)psRGXConfigMuxHWPerfCountersIN;
+			    (IMG_BYTE *) (void *)psRGXGetConfiguredHWPerfCountersIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -170,48 +124,51 @@ PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXConfigMuxHWPerfCountersOUT->eError =
+				psRGXGetConfiguredHWPerfCountersOUT->eError =
 				    PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXConfigMuxHWPerfCounters_exit;
+				goto RGXGetConfiguredHWPerfCounters_exit;
 			}
 		}
 	}
 
-	if (psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen != 0)
+	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
 	{
-		psBlockConfigsInt =
-		    (RGX_HWPERF_CONFIG_MUX_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer,
-								     ui32NextOffset);
-		ui32NextOffset +=
-		    psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
-		    sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK);
+		psConfiguredCountersInt =
+		    (RGX_HWPERF_CONFIG_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += 1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK);
 	}
 
-	/* Copy the data over */
-	if (psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK) > 0)
+	psRGXGetConfiguredHWPerfCountersOUT->eError =
+	    PVRSRVRGXGetConfiguredHWPerfCountersKM(psConnection, OSGetDevNode(psConnection),
+						   psRGXGetConfiguredHWPerfCountersIN->ui32BlockID,
+						   psConfiguredCountersInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXGetConfiguredHWPerfCountersOUT->eError != PVRSRV_OK))
 	{
-		if (OSCopyFromUser
-		    (NULL, psBlockConfigsInt,
-		     (const void __user *)psRGXConfigMuxHWPerfCountersIN->psBlockConfigs,
-		     psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
-		     sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) != PVRSRV_OK)
+		goto RGXGetConfiguredHWPerfCounters_exit;
+	}
+
+	/* If dest ptr is non-null and we have data to copy */
+	if ((psConfiguredCountersInt) && ((1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK)) > 0))
+	{
+		if (unlikely
+		    (OSCopyToUser
+		     (NULL,
+		      (void __user *)psRGXGetConfiguredHWPerfCountersOUT->psConfiguredCounters,
+		      psConfiguredCountersInt,
+		      (1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK))) != PVRSRV_OK))
 		{
-			psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXGetConfiguredHWPerfCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXConfigMuxHWPerfCounters_exit;
+			goto RGXGetConfiguredHWPerfCounters_exit;
 		}
 	}
 
-	psRGXConfigMuxHWPerfCountersOUT->eError =
-	    PVRSRVRGXConfigMuxHWPerfCountersKM(psConnection, OSGetDevNode(psConnection),
-					       psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen,
-					       psBlockConfigsInt);
-
-RGXConfigMuxHWPerfCounters_exit:
+RGXGetConfiguredHWPerfCounters_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXConfigMuxHWPerfCountersOUT->eError == PVRSRV_OK)
+	if (psRGXGetConfiguredHWPerfCountersOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -221,23 +178,20 @@ PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static_assert(RGXFWIF_HWPERF_CTRL_BLKS_MAX <= IMG_UINT32_MAX,
-	      "RGXFWIF_HWPERF_CTRL_BLKS_MAX must not be larger than IMG_UINT32_MAX");
-
 static IMG_INT
-PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
-				   IMG_UINT8 * psRGXControlHWPerfBlocksIN_UI8,
-				   IMG_UINT8 * psRGXControlHWPerfBlocksOUT_UI8,
-				   CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
+				      IMG_UINT8 * psRGXGetEnabledHWPerfBlocksIN_UI8,
+				      IMG_UINT8 * psRGXGetEnabledHWPerfBlocksOUT_UI8,
+				      CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCONTROLHWPERFBLOCKS *psRGXControlHWPerfBlocksIN =
-	    (PVRSRV_BRIDGE_IN_RGXCONTROLHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXControlHWPerfBlocksIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS *psRGXControlHWPerfBlocksOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXControlHWPerfBlocksOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS *psRGXGetEnabledHWPerfBlocksIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXGetEnabledHWPerfBlocksIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS *psRGXGetEnabledHWPerfBlocksOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXGetEnabledHWPerfBlocksOUT_UI8, 0);
 
-	IMG_UINT16 *ui16BlockIDsInt = NULL;
+	IMG_UINT32 *pui32EnabledBlockIDsInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
@@ -245,18 +199,15 @@ PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 
 	IMG_UINT32 ui32BufferSize = 0;
 	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16)) + 0;
+	    ((IMG_UINT64) psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32)) + 0;
 
-	if (unlikely(psRGXControlHWPerfBlocksIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
-	{
-		psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXControlHWPerfBlocks_exit;
-	}
+	psRGXGetEnabledHWPerfBlocksOUT->pui32EnabledBlockIDs =
+	    psRGXGetEnabledHWPerfBlocksIN->pui32EnabledBlockIDs;
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXControlHWPerfBlocks_exit;
+		psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXGetEnabledHWPerfBlocks_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -265,7 +216,7 @@ PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXControlHWPerfBlocksIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXGetEnabledHWPerfBlocksIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -273,7 +224,7 @@ PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXControlHWPerfBlocksIN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXGetEnabledHWPerfBlocksIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -283,43 +234,52 @@ PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXControlHWPerfBlocks_exit;
+				psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXGetEnabledHWPerfBlocks_exit;
 			}
 		}
 	}
 
-	if (psRGXControlHWPerfBlocksIN->ui32ArrayLen != 0)
+	if (psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen != 0)
 	{
-		ui16BlockIDsInt = (IMG_UINT16 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16);
+		pui32EnabledBlockIDsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32);
 	}
 
-	/* Copy the data over */
-	if (psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16) > 0)
+	psRGXGetEnabledHWPerfBlocksOUT->eError =
+	    PVRSRVRGXGetEnabledHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
+					      psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen,
+					      &psRGXGetEnabledHWPerfBlocksOUT->ui32BlockCount,
+					      pui32EnabledBlockIDsInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXGetEnabledHWPerfBlocksOUT->eError != PVRSRV_OK))
 	{
-		if (OSCopyFromUser
-		    (NULL, ui16BlockIDsInt,
-		     (const void __user *)psRGXControlHWPerfBlocksIN->pui16BlockIDs,
-		     psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16)) != PVRSRV_OK)
+		goto RGXGetEnabledHWPerfBlocks_exit;
+	}
+
+	/* If dest ptr is non-null and we have data to copy */
+	if ((pui32EnabledBlockIDsInt) &&
+	    ((psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32)) > 0))
+	{
+		if (unlikely
+		    (OSCopyToUser
+		     (NULL, (void __user *)psRGXGetEnabledHWPerfBlocksOUT->pui32EnabledBlockIDs,
+		      pui32EnabledBlockIDsInt,
+		      (psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32))) !=
+		     PVRSRV_OK))
 		{
-			psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXControlHWPerfBlocks_exit;
+			goto RGXGetEnabledHWPerfBlocks_exit;
 		}
 	}
 
-	psRGXControlHWPerfBlocksOUT->eError =
-	    PVRSRVRGXControlHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
-					   psRGXControlHWPerfBlocksIN->bEnable,
-					   psRGXControlHWPerfBlocksIN->ui32ArrayLen,
-					   ui16BlockIDsInt);
-
-RGXControlHWPerfBlocks_exit:
+RGXGetEnabledHWPerfBlocks_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXControlHWPerfBlocksOUT->eError == PVRSRV_OK)
+	if (psRGXGetEnabledHWPerfBlocksOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -329,23 +289,91 @@ PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static_assert(RGX_HWPERF_MAX_CUSTOM_CNTRS <= IMG_UINT32_MAX,
-	      "RGX_HWPERF_MAX_CUSTOM_CNTRS must not be larger than IMG_UINT32_MAX");
+#if defined(PVRSRV_FORCE_HWPERF_TO_SCHED_CLK)
 
 static IMG_INT
-PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
-				    IMG_UINT8 * psRGXConfigCustomCountersIN_UI8,
-				    IMG_UINT8 * psRGXConfigCustomCountersOUT_UI8,
-				    CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXGetHWPerfTimeStamp(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXGetHWPerfTimeStampIN_UI8,
+				  IMG_UINT8 * psRGXGetHWPerfTimeStampOUT_UI8,
+				  CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCONFIGCUSTOMCOUNTERS *psRGXConfigCustomCountersIN =
-	    (PVRSRV_BRIDGE_IN_RGXCONFIGCUSTOMCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXConfigCustomCountersIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCONFIGCUSTOMCOUNTERS *psRGXConfigCustomCountersOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCONFIGCUSTOMCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXConfigCustomCountersOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP *psRGXGetHWPerfTimeStampIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP *)
+	    IMG_OFFSET_ADDR(psRGXGetHWPerfTimeStampIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP *psRGXGetHWPerfTimeStampOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP *)
+	    IMG_OFFSET_ADDR(psRGXGetHWPerfTimeStampOUT_UI8, 0);
+
+	PVR_UNREFERENCED_PARAMETER(psRGXGetHWPerfTimeStampIN);
+
+	psRGXGetHWPerfTimeStampOUT->eError =
+	    PVRSRVRGXGetHWPerfTimeStampKM(psConnection, OSGetDevNode(psConnection),
+					  &psRGXGetHWPerfTimeStampOUT->ui64TimeStamp);
+
+	return 0;
+}
+
+#else
+#define PVRSRVBridgeRGXGetHWPerfTimeStamp NULL
+#endif
+
+static IMG_INT
+PVRSRVBridgeRGXCtrlHWPerf(IMG_UINT32 ui32DispatchTableEntry,
+			  IMG_UINT8 * psRGXCtrlHWPerfIN_UI8,
+			  IMG_UINT8 * psRGXCtrlHWPerfOUT_UI8, CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCTRLHWPERF *psRGXCtrlHWPerfIN =
+	    (PVRSRV_BRIDGE_IN_RGXCTRLHWPERF *) IMG_OFFSET_ADDR(psRGXCtrlHWPerfIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCTRLHWPERF *psRGXCtrlHWPerfOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCTRLHWPERF *) IMG_OFFSET_ADDR(psRGXCtrlHWPerfOUT_UI8, 0);
+
+	psRGXCtrlHWPerfOUT->eError =
+	    PVRSRVRGXCtrlHWPerfKM(psConnection, OSGetDevNode(psConnection),
+				  psRGXCtrlHWPerfIN->ui32StreamId,
+				  psRGXCtrlHWPerfIN->bToggle, psRGXCtrlHWPerfIN->ui64Mask);
+
+	return 0;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXGetHWPerfBvncFeatureFlags(IMG_UINT32 ui32DispatchTableEntry,
+					 IMG_UINT8 * psRGXGetHWPerfBvncFeatureFlagsIN_UI8,
+					 IMG_UINT8 * psRGXGetHWPerfBvncFeatureFlagsOUT_UI8,
+					 CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXGETHWPERFBVNCFEATUREFLAGS *psRGXGetHWPerfBvncFeatureFlagsIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETHWPERFBVNCFEATUREFLAGS *)
+	    IMG_OFFSET_ADDR(psRGXGetHWPerfBvncFeatureFlagsIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS *psRGXGetHWPerfBvncFeatureFlagsOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS *)
+	    IMG_OFFSET_ADDR(psRGXGetHWPerfBvncFeatureFlagsOUT_UI8, 0);
+
+	PVR_UNREFERENCED_PARAMETER(psRGXGetHWPerfBvncFeatureFlagsIN);
+
+	psRGXGetHWPerfBvncFeatureFlagsOUT->eError =
+	    PVRSRVRGXGetHWPerfBvncFeatureFlagsKM(psConnection, OSGetDevNode(psConnection),
+						 &psRGXGetHWPerfBvncFeatureFlagsOUT->sBVNC);
+
+	return 0;
+}
+
+static_assert(RGXFWIF_HWPERF_CTRL_BLKS_MAX <= IMG_UINT32_MAX,
+	      "RGXFWIF_HWPERF_CTRL_BLKS_MAX must not be larger than IMG_UINT32_MAX");
+
+static IMG_INT
+PVRSRVBridgeRGXControlHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
+				   IMG_UINT8 * psRGXControlHWPerfBlocksIN_UI8,
+				   IMG_UINT8 * psRGXControlHWPerfBlocksOUT_UI8,
+				   CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCONTROLHWPERFBLOCKS *psRGXControlHWPerfBlocksIN =
+	    (PVRSRV_BRIDGE_IN_RGXCONTROLHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXControlHWPerfBlocksIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS *psRGXControlHWPerfBlocksOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXControlHWPerfBlocksOUT_UI8, 0);
 
-	IMG_UINT32 *ui32CustomCounterIDsInt = NULL;
+	IMG_UINT16 *ui16BlockIDsInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
@@ -353,20 +381,18 @@ PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
 
 	IMG_UINT32 ui32BufferSize = 0;
 	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32)) +
-	    0;
+	    ((IMG_UINT64) psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16)) + 0;
 
-	if (unlikely
-	    (psRGXConfigCustomCountersIN->ui16NumCustomCounters > RGX_HWPERF_MAX_CUSTOM_CNTRS))
+	if (unlikely(psRGXControlHWPerfBlocksIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
 	{
-		psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXConfigCustomCounters_exit;
+		psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXControlHWPerfBlocks_exit;
 	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXConfigCustomCounters_exit;
+		psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXControlHWPerfBlocks_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -375,7 +401,7 @@ PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXConfigCustomCountersIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXControlHWPerfBlocksIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -383,7 +409,7 @@ PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXConfigCustomCountersIN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXControlHWPerfBlocksIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -393,46 +419,43 @@ PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXConfigCustomCounters_exit;
+				psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXControlHWPerfBlocks_exit;
 			}
 		}
 	}
 
-	if (psRGXConfigCustomCountersIN->ui16NumCustomCounters != 0)
+	if (psRGXControlHWPerfBlocksIN->ui32ArrayLen != 0)
 	{
-		ui32CustomCounterIDsInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset +=
-		    psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32);
+		ui16BlockIDsInt = (IMG_UINT16 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16);
 	}
 
 	/* Copy the data over */
-	if (psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32) > 0)
+	if (psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui32CustomCounterIDsInt,
-		     (const void __user *)psRGXConfigCustomCountersIN->pui32CustomCounterIDs,
-		     psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32)) !=
-		    PVRSRV_OK)
+		    (NULL, ui16BlockIDsInt,
+		     (const void __user *)psRGXControlHWPerfBlocksIN->pui16BlockIDs,
+		     psRGXControlHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT16)) != PVRSRV_OK)
 		{
-			psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXControlHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXConfigCustomCounters_exit;
+			goto RGXControlHWPerfBlocks_exit;
 		}
 	}
 
-	psRGXConfigCustomCountersOUT->eError =
-	    PVRSRVRGXConfigCustomCountersKM(psConnection, OSGetDevNode(psConnection),
-					    psRGXConfigCustomCountersIN->ui16CustomBlockID,
-					    psRGXConfigCustomCountersIN->ui16NumCustomCounters,
-					    ui32CustomCounterIDsInt);
+	psRGXControlHWPerfBlocksOUT->eError =
+	    PVRSRVRGXControlHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
+					   psRGXControlHWPerfBlocksIN->bEnable,
+					   psRGXControlHWPerfBlocksIN->ui32ArrayLen,
+					   ui16BlockIDsInt);
 
-RGXConfigCustomCounters_exit:
+RGXControlHWPerfBlocks_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXConfigCustomCountersOUT->eError == PVRSRV_OK)
+	if (psRGXControlHWPerfBlocksOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -446,19 +469,19 @@ static_assert(RGXFWIF_HWPERF_CTRL_BLKS_MAX <= IMG_UINT32_MAX,
 	      "RGXFWIF_HWPERF_CTRL_BLKS_MAX must not be larger than IMG_UINT32_MAX");
 
 static IMG_INT
-PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
-				     IMG_UINT8 * psRGXConfigureHWPerfBlocksIN_UI8,
-				     IMG_UINT8 * psRGXConfigureHWPerfBlocksOUT_UI8,
-				     CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXConfigMuxHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
+				       IMG_UINT8 * psRGXConfigMuxHWPerfCountersIN_UI8,
+				       IMG_UINT8 * psRGXConfigMuxHWPerfCountersOUT_UI8,
+				       CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCONFIGUREHWPERFBLOCKS *psRGXConfigureHWPerfBlocksIN =
-	    (PVRSRV_BRIDGE_IN_RGXCONFIGUREHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXConfigureHWPerfBlocksIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCONFIGUREHWPERFBLOCKS *psRGXConfigureHWPerfBlocksOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCONFIGUREHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXConfigureHWPerfBlocksOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS *psRGXConfigMuxHWPerfCountersIN =
+	    (PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXConfigMuxHWPerfCountersIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS *psRGXConfigMuxHWPerfCountersOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXConfigMuxHWPerfCountersOUT_UI8, 0);
 
-	RGX_HWPERF_CONFIG_CNTBLK *psBlockConfigsInt = NULL;
+	RGX_HWPERF_CONFIG_MUX_CNTBLK *psBlockConfigsInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
@@ -466,19 +489,19 @@ PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 
 	IMG_UINT32 ui32BufferSize = 0;
 	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXConfigureHWPerfBlocksIN->ui32ArrayLen *
-	     sizeof(RGX_HWPERF_CONFIG_CNTBLK)) + 0;
+	    ((IMG_UINT64) psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
+	     sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) + 0;
 
-	if (unlikely(psRGXConfigureHWPerfBlocksIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
+	if (unlikely(psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
 	{
-		psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXConfigureHWPerfBlocks_exit;
+		psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXConfigMuxHWPerfCounters_exit;
 	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXConfigureHWPerfBlocks_exit;
+		psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXConfigMuxHWPerfCounters_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -487,7 +510,7 @@ PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXConfigureHWPerfBlocksIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXConfigMuxHWPerfCountersIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -495,7 +518,8 @@ PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXConfigureHWPerfBlocksIN;
+			IMG_BYTE *pInputBuffer =
+			    (IMG_BYTE *) (void *)psRGXConfigMuxHWPerfCountersIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -505,46 +529,48 @@ PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXConfigureHWPerfBlocks_exit;
+				psRGXConfigMuxHWPerfCountersOUT->eError =
+				    PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXConfigMuxHWPerfCounters_exit;
 			}
 		}
 	}
 
-	if (psRGXConfigureHWPerfBlocksIN->ui32ArrayLen != 0)
+	if (psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen != 0)
 	{
 		psBlockConfigsInt =
-		    (RGX_HWPERF_CONFIG_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		    (RGX_HWPERF_CONFIG_MUX_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer,
+								     ui32NextOffset);
 		ui32NextOffset +=
-		    psRGXConfigureHWPerfBlocksIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_CNTBLK);
+		    psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
+		    sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK);
 	}
 
 	/* Copy the data over */
-	if (psRGXConfigureHWPerfBlocksIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_CNTBLK) > 0)
+	if (psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK) > 0)
 	{
 		if (OSCopyFromUser
 		    (NULL, psBlockConfigsInt,
-		     (const void __user *)psRGXConfigureHWPerfBlocksIN->psBlockConfigs,
-		     psRGXConfigureHWPerfBlocksIN->ui32ArrayLen *
-		     sizeof(RGX_HWPERF_CONFIG_CNTBLK)) != PVRSRV_OK)
+		     (const void __user *)psRGXConfigMuxHWPerfCountersIN->psBlockConfigs,
+		     psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen *
+		     sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) != PVRSRV_OK)
 		{
-			psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXConfigMuxHWPerfCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXConfigureHWPerfBlocks_exit;
+			goto RGXConfigMuxHWPerfCounters_exit;
 		}
 	}
 
-	psRGXConfigureHWPerfBlocksOUT->eError =
-	    PVRSRVRGXConfigureHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
-					     psRGXConfigureHWPerfBlocksIN->ui32CtrlWord,
-					     psRGXConfigureHWPerfBlocksIN->ui32ArrayLen,
-					     psBlockConfigsInt);
+	psRGXConfigMuxHWPerfCountersOUT->eError =
+	    PVRSRVRGXConfigMuxHWPerfCountersKM(psConnection, OSGetDevNode(psConnection),
+					       psRGXConfigMuxHWPerfCountersIN->ui32ArrayLen,
+					       psBlockConfigsInt);
 
-RGXConfigureHWPerfBlocks_exit:
+RGXConfigMuxHWPerfCounters_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXConfigureHWPerfBlocksOUT->eError == PVRSRV_OK)
+	if (psRGXConfigMuxHWPerfCountersOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -554,40 +580,44 @@ PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static_assert(1 <= IMG_UINT32_MAX, "1 must not be larger than IMG_UINT32_MAX");
+static_assert(RGX_HWPERF_MAX_CUSTOM_CNTRS <= IMG_UINT32_MAX,
+	      "RGX_HWPERF_MAX_CUSTOM_CNTRS must not be larger than IMG_UINT32_MAX");
 
 static IMG_INT
-PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
-					      IMG_UINT8 * psRGXGetConfiguredHWPerfMuxCountersIN_UI8,
-					      IMG_UINT8 *
-					      psRGXGetConfiguredHWPerfMuxCountersOUT_UI8,
-					      CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXConfigCustomCounters(IMG_UINT32 ui32DispatchTableEntry,
+				    IMG_UINT8 * psRGXConfigCustomCountersIN_UI8,
+				    IMG_UINT8 * psRGXConfigCustomCountersOUT_UI8,
+				    CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *psRGXGetConfiguredHWPerfMuxCountersIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfMuxCountersIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *psRGXGetConfiguredHWPerfMuxCountersOUT
-	    =
-	    (PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfMuxCountersOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXCONFIGCUSTOMCOUNTERS *psRGXConfigCustomCountersIN =
+	    (PVRSRV_BRIDGE_IN_RGXCONFIGCUSTOMCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXConfigCustomCountersIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCONFIGCUSTOMCOUNTERS *psRGXConfigCustomCountersOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCONFIGCUSTOMCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXConfigCustomCountersOUT_UI8, 0);
 
-	RGX_HWPERF_CONFIG_MUX_CNTBLK *psConfiguredMuxCountersInt = NULL;
+	IMG_UINT32 *ui32CustomCounterIDsInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
 	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
 	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize = ((IMG_UINT64) 1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) + 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32)) +
+	    0;
 
-	psRGXGetConfiguredHWPerfMuxCountersOUT->psConfiguredMuxCounters =
-	    psRGXGetConfiguredHWPerfMuxCountersIN->psConfiguredMuxCounters;
+	if (unlikely
+	    (psRGXConfigCustomCountersIN->ui16NumCustomCounters > RGX_HWPERF_MAX_CUSTOM_CNTRS))
+	{
+		psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXConfigCustomCounters_exit;
+	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
-		    PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXGetConfiguredHWPerfMuxCounters_exit;
+		psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXConfigCustomCounters_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -596,8 +626,7 @@ PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXGetConfiguredHWPerfMuxCountersIN),
-			      sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXConfigCustomCountersIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -605,8 +634,7 @@ PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer =
-			    (IMG_BYTE *) (void *)psRGXGetConfiguredHWPerfMuxCountersIN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXConfigCustomCountersIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -616,53 +644,46 @@ PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
-				    PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXGetConfiguredHWPerfMuxCounters_exit;
+				psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXConfigCustomCounters_exit;
 			}
 		}
 	}
 
-	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
-	{
-		psConfiguredMuxCountersInt =
-		    (RGX_HWPERF_CONFIG_MUX_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer,
-								     ui32NextOffset);
-		ui32NextOffset += 1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK);
-	}
-
-	psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
-	    PVRSRVRGXGetConfiguredHWPerfMuxCountersKM(psConnection, OSGetDevNode(psConnection),
-						      psRGXGetConfiguredHWPerfMuxCountersIN->
-						      ui32BlockID, psConfiguredMuxCountersInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXGetConfiguredHWPerfMuxCountersOUT->eError != PVRSRV_OK))
+	if (psRGXConfigCustomCountersIN->ui16NumCustomCounters != 0)
 	{
-		goto RGXGetConfiguredHWPerfMuxCounters_exit;
+		ui32CustomCounterIDsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32);
 	}
 
-	/* If dest ptr is non-null and we have data to copy */
-	if ((psConfiguredMuxCountersInt) && ((1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) > 0))
+	/* Copy the data over */
+	if (psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32) > 0)
 	{
-		if (unlikely
-		    (OSCopyToUser
-		     (NULL,
-		      (void __user *)psRGXGetConfiguredHWPerfMuxCountersOUT->
-		      psConfiguredMuxCounters, psConfiguredMuxCountersInt,
-		      (1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK))) != PVRSRV_OK))
+		if (OSCopyFromUser
+		    (NULL, ui32CustomCounterIDsInt,
+		     (const void __user *)psRGXConfigCustomCountersIN->pui32CustomCounterIDs,
+		     psRGXConfigCustomCountersIN->ui16NumCustomCounters * sizeof(IMG_UINT32)) !=
+		    PVRSRV_OK)
 		{
-			psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
-			    PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXConfigCustomCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXGetConfiguredHWPerfMuxCounters_exit;
+			goto RGXConfigCustomCounters_exit;
 		}
 	}
 
-RGXGetConfiguredHWPerfMuxCounters_exit:
+	psRGXConfigCustomCountersOUT->eError =
+	    PVRSRVRGXConfigCustomCountersKM(psConnection, OSGetDevNode(psConnection),
+					    psRGXConfigCustomCountersIN->ui16CustomBlockID,
+					    psRGXConfigCustomCountersIN->ui16NumCustomCounters,
+					    ui32CustomCounterIDsInt);
+
+RGXConfigCustomCounters_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXGetConfiguredHWPerfMuxCountersOUT->eError == PVRSRV_OK)
+	if (psRGXConfigCustomCountersOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -672,37 +693,43 @@ PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-static_assert(1 <= IMG_UINT32_MAX, "1 must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_HWPERF_CTRL_BLKS_MAX <= IMG_UINT32_MAX,
+	      "RGXFWIF_HWPERF_CTRL_BLKS_MAX must not be larger than IMG_UINT32_MAX");
 
 static IMG_INT
-PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
-					   IMG_UINT8 * psRGXGetConfiguredHWPerfCountersIN_UI8,
-					   IMG_UINT8 * psRGXGetConfiguredHWPerfCountersOUT_UI8,
-					   CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXConfigureHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
+				     IMG_UINT8 * psRGXConfigureHWPerfBlocksIN_UI8,
+				     IMG_UINT8 * psRGXConfigureHWPerfBlocksOUT_UI8,
+				     CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS *psRGXGetConfiguredHWPerfCountersIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfCountersIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS *psRGXGetConfiguredHWPerfCountersOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS *)
-	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfCountersOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXCONFIGUREHWPERFBLOCKS *psRGXConfigureHWPerfBlocksIN =
+	    (PVRSRV_BRIDGE_IN_RGXCONFIGUREHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXConfigureHWPerfBlocksIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCONFIGUREHWPERFBLOCKS *psRGXConfigureHWPerfBlocksOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCONFIGUREHWPERFBLOCKS *)
+	    IMG_OFFSET_ADDR(psRGXConfigureHWPerfBlocksOUT_UI8, 0);
 
-	RGX_HWPERF_CONFIG_CNTBLK *psConfiguredCountersInt = NULL;
+	RGX_HWPERF_CONFIG_CNTBLK *psBlockConfigsInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
 	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
 	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize = ((IMG_UINT64) 1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK)) + 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXConfigureHWPerfBlocksIN->ui32ArrayLen *
+	     sizeof(RGX_HWPERF_CONFIG_CNTBLK)) + 0;
 
-	psRGXGetConfiguredHWPerfCountersOUT->psConfiguredCounters =
-	    psRGXGetConfiguredHWPerfCountersIN->psConfiguredCounters;
+	if (unlikely(psRGXConfigureHWPerfBlocksIN->ui32ArrayLen > RGXFWIF_HWPERF_CTRL_BLKS_MAX))
+	{
+		psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXConfigureHWPerfBlocks_exit;
+	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXGetConfiguredHWPerfCountersOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXGetConfiguredHWPerfCounters_exit;
+		psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXConfigureHWPerfBlocks_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -711,7 +738,7 @@ PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXGetConfiguredHWPerfCountersIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXConfigureHWPerfBlocksIN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -719,8 +746,7 @@ PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer =
-			    (IMG_BYTE *) (void *)psRGXGetConfiguredHWPerfCountersIN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXConfigureHWPerfBlocksIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -730,51 +756,46 @@ PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXGetConfiguredHWPerfCountersOUT->eError =
-				    PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXGetConfiguredHWPerfCounters_exit;
+				psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXConfigureHWPerfBlocks_exit;
 			}
 		}
 	}
 
-	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
+	if (psRGXConfigureHWPerfBlocksIN->ui32ArrayLen != 0)
 	{
-		psConfiguredCountersInt =
+		psBlockConfigsInt =
 		    (RGX_HWPERF_CONFIG_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += 1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK);
-	}
-
-	psRGXGetConfiguredHWPerfCountersOUT->eError =
-	    PVRSRVRGXGetConfiguredHWPerfCountersKM(psConnection, OSGetDevNode(psConnection),
-						   psRGXGetConfiguredHWPerfCountersIN->ui32BlockID,
-						   psConfiguredCountersInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXGetConfiguredHWPerfCountersOUT->eError != PVRSRV_OK))
-	{
-		goto RGXGetConfiguredHWPerfCounters_exit;
+		ui32NextOffset +=
+		    psRGXConfigureHWPerfBlocksIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_CNTBLK);
 	}
 
-	/* If dest ptr is non-null and we have data to copy */
-	if ((psConfiguredCountersInt) && ((1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK)) > 0))
+	/* Copy the data over */
+	if (psRGXConfigureHWPerfBlocksIN->ui32ArrayLen * sizeof(RGX_HWPERF_CONFIG_CNTBLK) > 0)
 	{
-		if (unlikely
-		    (OSCopyToUser
-		     (NULL,
-		      (void __user *)psRGXGetConfiguredHWPerfCountersOUT->psConfiguredCounters,
-		      psConfiguredCountersInt,
-		      (1 * sizeof(RGX_HWPERF_CONFIG_CNTBLK))) != PVRSRV_OK))
+		if (OSCopyFromUser
+		    (NULL, psBlockConfigsInt,
+		     (const void __user *)psRGXConfigureHWPerfBlocksIN->psBlockConfigs,
+		     psRGXConfigureHWPerfBlocksIN->ui32ArrayLen *
+		     sizeof(RGX_HWPERF_CONFIG_CNTBLK)) != PVRSRV_OK)
 		{
-			psRGXGetConfiguredHWPerfCountersOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXConfigureHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXGetConfiguredHWPerfCounters_exit;
+			goto RGXConfigureHWPerfBlocks_exit;
 		}
 	}
 
-RGXGetConfiguredHWPerfCounters_exit:
+	psRGXConfigureHWPerfBlocksOUT->eError =
+	    PVRSRVRGXConfigureHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
+					     psRGXConfigureHWPerfBlocksIN->ui32CtrlWord,
+					     psRGXConfigureHWPerfBlocksIN->ui32ArrayLen,
+					     psBlockConfigsInt);
+
+RGXConfigureHWPerfBlocks_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXGetConfiguredHWPerfCountersOUT->eError == PVRSRV_OK)
+	if (psRGXConfigureHWPerfBlocksOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -784,36 +805,40 @@ PVRSRVBridgeRGXGetConfiguredHWPerfCounters(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
+static_assert(1 <= IMG_UINT32_MAX, "1 must not be larger than IMG_UINT32_MAX");
+
 static IMG_INT
-PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
-				      IMG_UINT8 * psRGXGetEnabledHWPerfBlocksIN_UI8,
-				      IMG_UINT8 * psRGXGetEnabledHWPerfBlocksOUT_UI8,
-				      CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters(IMG_UINT32 ui32DispatchTableEntry,
+					      IMG_UINT8 * psRGXGetConfiguredHWPerfMuxCountersIN_UI8,
+					      IMG_UINT8 *
+					      psRGXGetConfiguredHWPerfMuxCountersOUT_UI8,
+					      CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS *psRGXGetEnabledHWPerfBlocksIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXGetEnabledHWPerfBlocksIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS *psRGXGetEnabledHWPerfBlocksOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS *)
-	    IMG_OFFSET_ADDR(psRGXGetEnabledHWPerfBlocksOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *psRGXGetConfiguredHWPerfMuxCountersIN =
+	    (PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfMuxCountersIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *psRGXGetConfiguredHWPerfMuxCountersOUT
+	    =
+	    (PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS *)
+	    IMG_OFFSET_ADDR(psRGXGetConfiguredHWPerfMuxCountersOUT_UI8, 0);
 
-	IMG_UINT32 *pui32EnabledBlockIDsInt = NULL;
+	RGX_HWPERF_CONFIG_MUX_CNTBLK *psConfiguredMuxCountersInt = NULL;
 
 	IMG_UINT32 ui32NextOffset = 0;
 	IMG_BYTE *pArrayArgsBuffer = NULL;
 	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
 	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32)) + 0;
+	IMG_UINT64 ui64BufferSize = ((IMG_UINT64) 1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) + 0;
 
-	psRGXGetEnabledHWPerfBlocksOUT->pui32EnabledBlockIDs =
-	    psRGXGetEnabledHWPerfBlocksIN->pui32EnabledBlockIDs;
+	psRGXGetConfiguredHWPerfMuxCountersOUT->psConfiguredMuxCounters =
+	    psRGXGetConfiguredHWPerfMuxCountersIN->psConfiguredMuxCounters;
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXGetEnabledHWPerfBlocks_exit;
+		psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
+		    PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXGetConfiguredHWPerfMuxCounters_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -822,7 +847,8 @@ PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXGetEnabledHWPerfBlocksIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXGetConfiguredHWPerfMuxCountersIN),
+			      sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -830,7 +856,8 @@ PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXGetEnabledHWPerfBlocksIN;
+			IMG_BYTE *pInputBuffer =
+			    (IMG_BYTE *) (void *)psRGXGetConfiguredHWPerfMuxCountersIN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -840,52 +867,53 @@ PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXGetEnabledHWPerfBlocks_exit;
+				psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
+				    PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXGetConfiguredHWPerfMuxCounters_exit;
 			}
 		}
 	}
 
-	if (psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen != 0)
+	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
 	{
-		pui32EnabledBlockIDsInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32);
+		psConfiguredMuxCountersInt =
+		    (RGX_HWPERF_CONFIG_MUX_CNTBLK *) IMG_OFFSET_ADDR(pArrayArgsBuffer,
+								     ui32NextOffset);
+		ui32NextOffset += 1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK);
 	}
 
-	psRGXGetEnabledHWPerfBlocksOUT->eError =
-	    PVRSRVRGXGetEnabledHWPerfBlocksKM(psConnection, OSGetDevNode(psConnection),
-					      psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen,
-					      &psRGXGetEnabledHWPerfBlocksOUT->ui32BlockCount,
-					      pui32EnabledBlockIDsInt);
+	psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
+	    PVRSRVRGXGetConfiguredHWPerfMuxCountersKM(psConnection, OSGetDevNode(psConnection),
+						      psRGXGetConfiguredHWPerfMuxCountersIN->
+						      ui32BlockID, psConfiguredMuxCountersInt);
 	/* Exit early if bridged call fails */
-	if (unlikely(psRGXGetEnabledHWPerfBlocksOUT->eError != PVRSRV_OK))
+	if (unlikely(psRGXGetConfiguredHWPerfMuxCountersOUT->eError != PVRSRV_OK))
 	{
-		goto RGXGetEnabledHWPerfBlocks_exit;
+		goto RGXGetConfiguredHWPerfMuxCounters_exit;
 	}
 
 	/* If dest ptr is non-null and we have data to copy */
-	if ((pui32EnabledBlockIDsInt) &&
-	    ((psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32)) > 0))
+	if ((psConfiguredMuxCountersInt) && ((1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK)) > 0))
 	{
 		if (unlikely
 		    (OSCopyToUser
-		     (NULL, (void __user *)psRGXGetEnabledHWPerfBlocksOUT->pui32EnabledBlockIDs,
-		      pui32EnabledBlockIDsInt,
-		      (psRGXGetEnabledHWPerfBlocksIN->ui32ArrayLen * sizeof(IMG_UINT32))) !=
-		     PVRSRV_OK))
+		     (NULL,
+		      (void __user *)psRGXGetConfiguredHWPerfMuxCountersOUT->
+		      psConfiguredMuxCounters, psConfiguredMuxCountersInt,
+		      (1 * sizeof(RGX_HWPERF_CONFIG_MUX_CNTBLK))) != PVRSRV_OK))
 		{
-			psRGXGetEnabledHWPerfBlocksOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXGetConfiguredHWPerfMuxCountersOUT->eError =
+			    PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXGetEnabledHWPerfBlocks_exit;
+			goto RGXGetConfiguredHWPerfMuxCounters_exit;
 		}
 	}
 
-RGXGetEnabledHWPerfBlocks_exit:
+RGXGetConfiguredHWPerfMuxCounters_exit:
 
 	/* Allocated space should be equal to the last updated offset */
 #ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXGetEnabledHWPerfBlocksOUT->eError == PVRSRV_OK)
+	if (psRGXGetConfiguredHWPerfMuxCountersOUT->eError == PVRSRV_OK)
 		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
 #endif /* PVRSRV_NEED_PVR_ASSERT */
 
@@ -895,34 +923,6 @@ PVRSRVBridgeRGXGetEnabledHWPerfBlocks(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-#if defined(PVRSRV_FORCE_HWPERF_TO_SCHED_CLK)
-
-static IMG_INT
-PVRSRVBridgeRGXGetHWPerfTimeStamp(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXGetHWPerfTimeStampIN_UI8,
-				  IMG_UINT8 * psRGXGetHWPerfTimeStampOUT_UI8,
-				  CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP *psRGXGetHWPerfTimeStampIN =
-	    (PVRSRV_BRIDGE_IN_RGXGETHWPERFTIMESTAMP *)
-	    IMG_OFFSET_ADDR(psRGXGetHWPerfTimeStampIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP *psRGXGetHWPerfTimeStampOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP *)
-	    IMG_OFFSET_ADDR(psRGXGetHWPerfTimeStampOUT_UI8, 0);
-
-	PVR_UNREFERENCED_PARAMETER(psRGXGetHWPerfTimeStampIN);
-
-	psRGXGetHWPerfTimeStampOUT->eError =
-	    PVRSRVRGXGetHWPerfTimeStampKM(psConnection, OSGetDevNode(psConnection),
-					  &psRGXGetHWPerfTimeStampOUT->ui64TimeStamp);
-
-	return 0;
-}
-
-#else
-#define PVRSRVBridgeRGXGetHWPerfTimeStamp NULL
-#endif
-
 /* ***************************************************************************
  * Server bridge dispatch related glue
  */
@@ -936,44 +936,62 @@ void DeinitRGXHWPERFBridge(void);
 PVRSRV_ERROR InitRGXHWPERFBridge(void)
 {
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF, PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF,
-			      PVRSRVBridgeRGXCtrlHWPerf, NULL);
-
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS,
-			      PVRSRVBridgeRGXGetHWPerfBvncFeatureFlags, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS,
+			      PVRSRVBridgeRGXGetConfiguredHWPerfCounters, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFCOUNTERS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFCOUNTERS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS,
-			      PVRSRVBridgeRGXConfigMuxHWPerfCounters, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS,
+			      PVRSRVBridgeRGXGetEnabledHWPerfBlocks, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXGETENABLEDHWPERFBLOCKS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETENABLEDHWPERFBLOCKS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS,
-			      PVRSRVBridgeRGXControlHWPerfBlocks, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP,
+			      PVRSRVBridgeRGXGetHWPerfTimeStamp, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETHWPERFTIMESTAMP));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF, PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF,
+			      PVRSRVBridgeRGXCtrlHWPerf, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCTRLHWPERF),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCTRLHWPERF));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS,
-			      PVRSRVBridgeRGXConfigCustomCounters, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS,
+			      PVRSRVBridgeRGXGetHWPerfBvncFeatureFlags, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETHWPERFBVNCFEATUREFLAGS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS,
-			      PVRSRVBridgeRGXConfigureHWPerfBlocks, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS,
+			      PVRSRVBridgeRGXControlHWPerfBlocks, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCONTROLHWPERFBLOCKS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCONTROLHWPERFBLOCKS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS,
-			      PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS,
+			      PVRSRVBridgeRGXConfigMuxHWPerfCounters, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCONFIGMUXHWPERFCOUNTERS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCONFIGMUXHWPERFCOUNTERS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS,
-			      PVRSRVBridgeRGXGetConfiguredHWPerfCounters, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS,
+			      PVRSRVBridgeRGXConfigCustomCounters, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCONFIGCUSTOMCOUNTERS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCONFIGCUSTOMCOUNTERS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS,
-			      PVRSRVBridgeRGXGetEnabledHWPerfBlocks, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS,
+			      PVRSRVBridgeRGXConfigureHWPerfBlocks, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCONFIGUREHWPERFBLOCKS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCONFIGUREHWPERFBLOCKS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP,
-			      PVRSRVBridgeRGXGetHWPerfTimeStamp, NULL);
+			      PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS,
+			      PVRSRVBridgeRGXGetConfiguredHWPerfMuxCounters, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXGETCONFIGUREDHWPERFMUXCOUNTERS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXGETCONFIGUREDHWPERFMUXCOUNTERS));
 
 	return PVRSRV_OK;
 }
@@ -984,33 +1002,33 @@ PVRSRV_ERROR InitRGXHWPERFBridge(void)
 void DeinitRGXHWPERFBridge(void)
 {
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF, PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF, PVRSRV_BRIDGE_RGXHWPERF_RGXCTRLHWPERF);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFBVNCFEATUREFLAGS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXCONTROLHWPERFBLOCKS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGMUXHWPERFCOUNTERS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFCOUNTERS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGCUSTOMCOUNTERS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXGETENABLEDHWPERFBLOCKS);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXCONFIGUREHWPERFBLOCKS);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXHWPERF,
-				PVRSRV_BRIDGE_RGXHWPERF_RGXGETHWPERFTIMESTAMP);
+				PVRSRV_BRIDGE_RGXHWPERF_RGXGETCONFIGUREDHWPERFMUXCOUNTERS);
 
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxkicksync_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxkicksync_bridge.c
index 0c301964e7ce..8d943cd536e2 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxkicksync_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxkicksync_bridge.c
@@ -540,18 +540,25 @@ PVRSRV_ERROR InitRGXKICKSYNCBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXKICKSYNC,
 			      PVRSRV_BRIDGE_RGXKICKSYNC_RGXCREATEKICKSYNCCONTEXT,
-			      PVRSRVBridgeRGXCreateKickSyncContext, NULL);
+			      PVRSRVBridgeRGXCreateKickSyncContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATEKICKSYNCCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATEKICKSYNCCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXKICKSYNC,
 			      PVRSRV_BRIDGE_RGXKICKSYNC_RGXDESTROYKICKSYNCCONTEXT,
-			      PVRSRVBridgeRGXDestroyKickSyncContext, NULL);
+			      PVRSRVBridgeRGXDestroyKickSyncContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYKICKSYNCCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYKICKSYNCCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXKICKSYNC, PVRSRV_BRIDGE_RGXKICKSYNC_RGXKICKSYNC2,
-			      PVRSRVBridgeRGXKickSync2, NULL);
+			      PVRSRVBridgeRGXKickSync2, NULL, sizeof(PVRSRV_BRIDGE_IN_RGXKICKSYNC2),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXKICKSYNC2));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXKICKSYNC,
 			      PVRSRV_BRIDGE_RGXKICKSYNC_RGXSETKICKSYNCCONTEXTPROPERTY,
-			      PVRSRVBridgeRGXSetKickSyncContextProperty, NULL);
+			      PVRSRVBridgeRGXSetKickSyncContextProperty, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETKICKSYNCCONTEXTPROPERTY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETKICKSYNCCONTEXTPROPERTY));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxregconfig_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxregconfig_bridge.c
index 4cdcb127299b..548401470d09 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxregconfig_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxregconfig_bridge.c
@@ -184,23 +184,30 @@ PVRSRV_ERROR InitRGXREGCONFIGBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXREGCONFIG,
 			      PVRSRV_BRIDGE_RGXREGCONFIG_RGXSETREGCONFIGTYPE,
-			      PVRSRVBridgeRGXSetRegConfigType, NULL);
+			      PVRSRVBridgeRGXSetRegConfigType, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETREGCONFIGTYPE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETREGCONFIGTYPE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXREGCONFIG,
 			      PVRSRV_BRIDGE_RGXREGCONFIG_RGXADDREGCONFIG,
-			      PVRSRVBridgeRGXAddRegconfig, NULL);
+			      PVRSRVBridgeRGXAddRegconfig, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXADDREGCONFIG),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXADDREGCONFIG));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXREGCONFIG,
 			      PVRSRV_BRIDGE_RGXREGCONFIG_RGXCLEARREGCONFIG,
-			      PVRSRVBridgeRGXClearRegConfig, NULL);
+			      PVRSRVBridgeRGXClearRegConfig, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCLEARREGCONFIG));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXREGCONFIG,
 			      PVRSRV_BRIDGE_RGXREGCONFIG_RGXENABLEREGCONFIG,
-			      PVRSRVBridgeRGXEnableRegConfig, NULL);
+			      PVRSRVBridgeRGXEnableRegConfig, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXENABLEREGCONFIG));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXREGCONFIG,
 			      PVRSRV_BRIDGE_RGXREGCONFIG_RGXDISABLEREGCONFIG,
-			      PVRSRVBridgeRGXDisableRegConfig, NULL);
+			      PVRSRVBridgeRGXDisableRegConfig, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDISABLEREGCONFIG));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxta3d_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxta3d_bridge.c
index b62e4ef1142d..141df870f874 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxta3d_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxta3d_bridge.c
@@ -65,995 +65,716 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * Server-side bridge entry points
  */
 
-static PVRSRV_ERROR _RGXCreateHWRTDataSetpsKmHwRTDataSetIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = RGXDestroyHWRTDataSet((RGX_KM_HW_RT_DATASET *) pvData);
-	return eError;
-}
-
-static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_RTDATA_FREELISTS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_RTDATA_FREELISTS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
-static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
-	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
-
 static IMG_INT
-PVRSRVBridgeRGXCreateHWRTDataSet(IMG_UINT32 ui32DispatchTableEntry,
-				 IMG_UINT8 * psRGXCreateHWRTDataSetIN_UI8,
-				 IMG_UINT8 * psRGXCreateHWRTDataSetOUT_UI8,
-				 CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXDestroyHWRTDataSet(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXDestroyHWRTDataSetIN_UI8,
+				  IMG_UINT8 * psRGXDestroyHWRTDataSetOUT_UI8,
+				  CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET *psRGXCreateHWRTDataSetIN =
-	    (PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET *) IMG_OFFSET_ADDR(psRGXCreateHWRTDataSetIN_UI8,
-								      0);
-	PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET *psRGXCreateHWRTDataSetOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET *)
-	    IMG_OFFSET_ADDR(psRGXCreateHWRTDataSetOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXDESTROYHWRTDATASET *psRGXDestroyHWRTDataSetIN =
+	    (PVRSRV_BRIDGE_IN_RGXDESTROYHWRTDATASET *)
+	    IMG_OFFSET_ADDR(psRGXDestroyHWRTDataSetIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXDESTROYHWRTDATASET *psRGXDestroyHWRTDataSetOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXDESTROYHWRTDATASET *)
+	    IMG_OFFSET_ADDR(psRGXDestroyHWRTDataSetOUT_UI8, 0);
 
-	IMG_DEV_VIRTADDR *sVHeapTableDevVAddrInt = NULL;
-	IMG_DEV_VIRTADDR *sPMMlistDevVAddrInt = NULL;
-	RGX_FREELIST **psapsFreeListsInt = NULL;
-	IMG_HANDLE *hapsFreeListsInt2 = NULL;
-	IMG_DEV_VIRTADDR *sTailPtrsDevVAddrInt = NULL;
-	IMG_DEV_VIRTADDR *sMacrotileArrayDevVAddrInt = NULL;
-	IMG_DEV_VIRTADDR *sRgnHeaderDevVAddrInt = NULL;
-	IMG_DEV_VIRTADDR *sRTCDevVAddrInt = NULL;
-	RGX_KM_HW_RT_DATASET **psKmHwRTDataSetInt = NULL;
-	IMG_HANDLE *hKmHwRTDataSetInt2 = NULL;
+	/* Lock over handle destruction. */
+	LockHandle(psConnection->psHandleBase);
 
-	IMG_UINT32 ui32NextOffset = 0;
-	IMG_BYTE *pArrayArgsBuffer = NULL;
-	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
+	psRGXDestroyHWRTDataSetOUT->eError =
+	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
+					      (IMG_HANDLE) psRGXDestroyHWRTDataSetIN->
+					      hKmHwRTDataSet,
+					      PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET);
+	if (unlikely
+	    ((psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_OK)
+	     && (psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
+	     && (psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_ERROR_RETRY)))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+			 "%s: %s",
+			 __func__, PVRSRVGetErrorString(psRGXDestroyHWRTDataSetOUT->eError)));
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXDestroyHWRTDataSet_exit;
+	}
 
-	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *)) +
-	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_HANDLE)) + 0;
+	/* Release now we have destroyed handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXCreateHWRTDataSetOUT->phKmHwRTDataSet = psRGXCreateHWRTDataSetIN->phKmHwRTDataSet;
+RGXDestroyHWRTDataSet_exit:
 
-	if (ui64BufferSize > IMG_UINT32_MAX)
-	{
-		psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXCreateHWRTDataSet_exit;
-	}
+	return 0;
+}
 
-	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
+static PVRSRV_ERROR _RGXCreateZSBufferpssZSBufferKMIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = RGXDestroyZSBufferKM((RGX_ZSBUFFER_DATA *) pvData);
+	return eError;
+}
 
-	if (ui32BufferSize != 0)
-	{
-		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
-		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXCreateHWRTDataSetIN), sizeof(unsigned long));
-		IMG_UINT32 ui32InBufferExcessSize =
-		    ui32InBufferOffset >=
-		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
+static IMG_INT
+PVRSRVBridgeRGXCreateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
+			      IMG_UINT8 * psRGXCreateZSBufferIN_UI8,
+			      IMG_UINT8 * psRGXCreateZSBufferOUT_UI8,
+			      CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCREATEZSBUFFER *psRGXCreateZSBufferIN =
+	    (PVRSRV_BRIDGE_IN_RGXCREATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXCreateZSBufferIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCREATEZSBUFFER *psRGXCreateZSBufferOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCREATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXCreateZSBufferOUT_UI8, 0);
 
-		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
-		if (bHaveEnoughSpace)
-		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXCreateHWRTDataSetIN;
+	IMG_HANDLE hReservation = psRGXCreateZSBufferIN->hReservation;
+	DEVMEMINT_RESERVATION *psReservationInt = NULL;
+	IMG_HANDLE hPMR = psRGXCreateZSBufferIN->hPMR;
+	PMR *psPMRInt = NULL;
+	RGX_ZSBUFFER_DATA *pssZSBufferKMInt = NULL;
 
-			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
-		}
-		else
-		{
-			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
 
-			if (!pArrayArgsBuffer)
-			{
-				psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXCreateHWRTDataSet_exit;
-			}
-		}
+	/* Look up the address from the handle */
+	psRGXCreateZSBufferOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psReservationInt,
+				       hReservation,
+				       PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION, IMG_TRUE);
+	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateZSBuffer_exit;
 	}
 
+	/* Look up the address from the handle */
+	psRGXCreateZSBufferOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psPMRInt,
+				       hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
 	{
-		sVHeapTableDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateZSBuffer_exit;
 	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
+	psRGXCreateZSBufferOUT->eError =
+	    RGXCreateZSBufferKM(psConnection, OSGetDevNode(psConnection),
+				psReservationInt,
+				psPMRInt, psRGXCreateZSBufferIN->uiMapFlags, &pssZSBufferKMInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
 	{
-		if (OSCopyFromUser
-		    (NULL, sVHeapTableDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psVHeapTableDevVAddr,
-		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-			goto RGXCreateHWRTDataSet_exit;
-		}
+		goto RGXCreateZSBuffer_exit;
 	}
 
+	/* Lock over handle creation. */
+	LockHandle(psConnection->psHandleBase);
+
+	psRGXCreateZSBufferOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+								   &psRGXCreateZSBufferOUT->
+								   hsZSBufferKM,
+								   (void *)pssZSBufferKMInt,
+								   PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER,
+								   PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+								   (PFN_HANDLE_RELEASE) &
+								   _RGXCreateZSBufferpssZSBufferKMIntRelease);
+	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
 	{
-		sPMMlistDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateZSBuffer_exit;
 	}
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, sPMMlistDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psPMMlistDevVAddr,
-		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+	/* Release now we have created handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-			goto RGXCreateHWRTDataSet_exit;
-		}
+RGXCreateZSBuffer_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psReservationInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hReservation, PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION);
 	}
 
+	/* Unreference the previously looked up handle */
+	if (psPMRInt)
 	{
-		psapsFreeListsInt =
-		    (RGX_FREELIST **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psapsFreeListsInt, 0,
-			       RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *));
-		ui32NextOffset += RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *);
-		hapsFreeListsInt2 =
-		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE);
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
 	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE) > 0)
+	if (psRGXCreateZSBufferOUT->eError != PVRSRV_OK)
 	{
-		if (OSCopyFromUser
-		    (NULL, hapsFreeListsInt2,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->phapsFreeLists,
-		     RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		if (pssZSBufferKMInt)
 		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-			goto RGXCreateHWRTDataSet_exit;
+			RGXDestroyZSBufferKM(pssZSBufferKMInt);
 		}
 	}
 
-	{
-		sTailPtrsDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
-	}
-
-	/* Copy the data over */
-	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, sTailPtrsDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psTailPtrsDevVAddr,
-		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+	return 0;
+}
 
-			goto RGXCreateHWRTDataSet_exit;
-		}
-	}
+static IMG_INT
+PVRSRVBridgeRGXDestroyZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
+			       IMG_UINT8 * psRGXDestroyZSBufferIN_UI8,
+			       IMG_UINT8 * psRGXDestroyZSBufferOUT_UI8,
+			       CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXDESTROYZSBUFFER *psRGXDestroyZSBufferIN =
+	    (PVRSRV_BRIDGE_IN_RGXDESTROYZSBUFFER *) IMG_OFFSET_ADDR(psRGXDestroyZSBufferIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXDESTROYZSBUFFER *psRGXDestroyZSBufferOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXDESTROYZSBUFFER *) IMG_OFFSET_ADDR(psRGXDestroyZSBufferOUT_UI8,
+								     0);
 
-	{
-		sMacrotileArrayDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
-	}
+	/* Lock over handle destruction. */
+	LockHandle(psConnection->psHandleBase);
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
+	psRGXDestroyZSBufferOUT->eError =
+	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
+					      (IMG_HANDLE) psRGXDestroyZSBufferIN->
+					      hsZSBufferMemDesc,
+					      PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
+	if (unlikely
+	    ((psRGXDestroyZSBufferOUT->eError != PVRSRV_OK)
+	     && (psRGXDestroyZSBufferOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
+	     && (psRGXDestroyZSBufferOUT->eError != PVRSRV_ERROR_RETRY)))
 	{
-		if (OSCopyFromUser
-		    (NULL, sMacrotileArrayDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psMacrotileArrayDevVAddr,
-		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-			goto RGXCreateHWRTDataSet_exit;
-		}
+		PVR_DPF((PVR_DBG_ERROR,
+			 "%s: %s",
+			 __func__, PVRSRVGetErrorString(psRGXDestroyZSBufferOUT->eError)));
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXDestroyZSBuffer_exit;
 	}
 
-	{
-		sRgnHeaderDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
-	}
+	/* Release now we have destroyed handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, sRgnHeaderDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psRgnHeaderDevVAddr,
-		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+RGXDestroyZSBuffer_exit:
 
-			goto RGXCreateHWRTDataSet_exit;
-		}
-	}
+	return 0;
+}
 
-	{
-		sRTCDevVAddrInt =
-		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
-	}
+static PVRSRV_ERROR _RGXPopulateZSBufferpssPopulationIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = RGXUnpopulateZSBufferKM((RGX_POPULATION *) pvData);
+	return eError;
+}
 
-	/* Copy the data over */
-	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, sRTCDevVAddrInt,
-		     (const void __user *)psRGXCreateHWRTDataSetIN->psRTCDevVAddr,
-		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+static IMG_INT
+PVRSRVBridgeRGXPopulateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
+				IMG_UINT8 * psRGXPopulateZSBufferIN_UI8,
+				IMG_UINT8 * psRGXPopulateZSBufferOUT_UI8,
+				CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXPOPULATEZSBUFFER *psRGXPopulateZSBufferIN =
+	    (PVRSRV_BRIDGE_IN_RGXPOPULATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXPopulateZSBufferIN_UI8,
+								     0);
+	PVRSRV_BRIDGE_OUT_RGXPOPULATEZSBUFFER *psRGXPopulateZSBufferOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXPOPULATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXPopulateZSBufferOUT_UI8,
+								      0);
 
-			goto RGXCreateHWRTDataSet_exit;
-		}
-	}
-	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
-	{
-		psKmHwRTDataSetInt =
-		    (RGX_KM_HW_RT_DATASET **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psKmHwRTDataSetInt, 0,
-			       RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *));
-		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *);
-		hKmHwRTDataSetInt2 =
-		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_HANDLE);
-	}
+	IMG_HANDLE hsZSBufferKM = psRGXPopulateZSBufferIN->hsZSBufferKM;
+	RGX_ZSBUFFER_DATA *pssZSBufferKMInt = NULL;
+	RGX_POPULATION *pssPopulationInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
+	/* Look up the address from the handle */
+	psRGXPopulateZSBufferOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&pssZSBufferKMInt,
+				       hsZSBufferKM,
+				       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
+	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
 	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < RGXMKIF_NUM_RTDATA_FREELISTS; i++)
-		{
-			/* Look up the address from the handle */
-			psRGXCreateHWRTDataSetOUT->eError =
-			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-						       (void **)&psapsFreeListsInt[i],
-						       hapsFreeListsInt2[i],
-						       PVRSRV_HANDLE_TYPE_RGX_FREELIST, IMG_TRUE);
-			if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
-			{
-				UnlockHandle(psConnection->psHandleBase);
-				goto RGXCreateHWRTDataSet_exit;
-			}
-		}
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXPopulateZSBuffer_exit;
 	}
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXCreateHWRTDataSetOUT->eError =
-	    RGXCreateHWRTDataSet(psConnection, OSGetDevNode(psConnection),
-				 sVHeapTableDevVAddrInt,
-				 sPMMlistDevVAddrInt,
-				 psapsFreeListsInt,
-				 psRGXCreateHWRTDataSetIN->ui32PPPScreen,
-				 psRGXCreateHWRTDataSetIN->ui64MultiSampleCtl,
-				 psRGXCreateHWRTDataSetIN->ui64FlippedMultiSampleCtl,
-				 psRGXCreateHWRTDataSetIN->ui32TPCStride,
-				 sTailPtrsDevVAddrInt,
-				 psRGXCreateHWRTDataSetIN->ui32TPCSize,
-				 psRGXCreateHWRTDataSetIN->ui32TEScreen,
-				 psRGXCreateHWRTDataSetIN->ui32TEAA,
-				 psRGXCreateHWRTDataSetIN->ui32TEMTILE1,
-				 psRGXCreateHWRTDataSetIN->ui32TEMTILE2,
-				 psRGXCreateHWRTDataSetIN->ui32MTileStride,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeLowerX,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeLowerY,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeUpperX,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeUpperY,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeScaleX,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMergeScaleY,
-				 sMacrotileArrayDevVAddrInt,
-				 sRgnHeaderDevVAddrInt,
-				 sRTCDevVAddrInt,
-				 psRGXCreateHWRTDataSetIN->ui32RgnHeaderSize,
-				 psRGXCreateHWRTDataSetIN->ui32ISPMtileSize,
-				 psRGXCreateHWRTDataSetIN->ui16MaxRTs, psKmHwRTDataSetInt);
+	psRGXPopulateZSBufferOUT->eError =
+	    RGXPopulateZSBufferKM(pssZSBufferKMInt, &pssPopulationInt);
 	/* Exit early if bridged call fails */
-	if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
+	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
 	{
-		goto RGXCreateHWRTDataSet_exit;
+		goto RGXPopulateZSBuffer_exit;
 	}
 
 	/* Lock over handle creation. */
 	LockHandle(psConnection->psHandleBase);
-	if (hKmHwRTDataSetInt2)
-	{
-		IMG_UINT32 i;
 
-		for (i = 0; i < RGXMKIF_NUM_RTDATAS; i++)
-		{
-
-			psRGXCreateHWRTDataSetOUT->eError =
-			    PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-						      &hKmHwRTDataSetInt2[i],
-						      (void *)psKmHwRTDataSetInt[i],
-						      PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET,
-						      PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-						      (PFN_HANDLE_RELEASE) &
-						      _RGXCreateHWRTDataSetpsKmHwRTDataSetIntRelease);
-			if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
-			{
-				UnlockHandle(psConnection->psHandleBase);
-				goto RGXCreateHWRTDataSet_exit;
-			}
-
-		}
+	psRGXPopulateZSBufferOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+								     &psRGXPopulateZSBufferOUT->
+								     hsPopulation,
+								     (void *)pssPopulationInt,
+								     PVRSRV_HANDLE_TYPE_RGX_POPULATION,
+								     PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+								     (PFN_HANDLE_RELEASE) &
+								     _RGXPopulateZSBufferpssPopulationIntRelease);
+	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXPopulateZSBuffer_exit;
 	}
+
 	/* Release now we have created handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	/* If dest ptr is non-null and we have data to copy */
-	if ((hKmHwRTDataSetInt2) && ((RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *)) > 0))
-	{
-		if (unlikely
-		    (OSCopyToUser
-		     (NULL, (void __user *)psRGXCreateHWRTDataSetOUT->phKmHwRTDataSet,
-		      hKmHwRTDataSetInt2,
-		      (RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *))) != PVRSRV_OK))
-		{
-			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
-
-			goto RGXCreateHWRTDataSet_exit;
-		}
-	}
-
-RGXCreateHWRTDataSet_exit:
+RGXPopulateZSBuffer_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
-	if (hapsFreeListsInt2)
+	/* Unreference the previously looked up handle */
+	if (pssZSBufferKMInt)
 	{
-		IMG_UINT32 i;
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hsZSBufferKM, PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-		for (i = 0; i < RGXMKIF_NUM_RTDATA_FREELISTS; i++)
+	if (psRGXPopulateZSBufferOUT->eError != PVRSRV_OK)
+	{
+		if (pssPopulationInt)
 		{
+			RGXUnpopulateZSBufferKM(pssPopulationInt);
+		}
+	}
 
-			/* Unreference the previously looked up handle */
-			if (psapsFreeListsInt && psapsFreeListsInt[i])
-			{
-				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-							    hapsFreeListsInt2[i],
-							    PVRSRV_HANDLE_TYPE_RGX_FREELIST);
-			}
-		}
-	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
+	return 0;
+}
 
-	if (psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK)
-	{
-		{
-			IMG_UINT32 i;
+static IMG_INT
+PVRSRVBridgeRGXUnpopulateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXUnpopulateZSBufferIN_UI8,
+				  IMG_UINT8 * psRGXUnpopulateZSBufferOUT_UI8,
+				  CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXUNPOPULATEZSBUFFER *psRGXUnpopulateZSBufferIN =
+	    (PVRSRV_BRIDGE_IN_RGXUNPOPULATEZSBUFFER *)
+	    IMG_OFFSET_ADDR(psRGXUnpopulateZSBufferIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER *psRGXUnpopulateZSBufferOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER *)
+	    IMG_OFFSET_ADDR(psRGXUnpopulateZSBufferOUT_UI8, 0);
 
-			if (hKmHwRTDataSetInt2)
-			{
-				for (i = 0; i < RGXMKIF_NUM_RTDATAS; i++)
-				{
-					if (hKmHwRTDataSetInt2[i])
-					{
-						RGXDestroyHWRTDataSet(hKmHwRTDataSetInt2[i]);
-					}
-				}
-			}
-		}
+	/* Lock over handle destruction. */
+	LockHandle(psConnection->psHandleBase);
+
+	psRGXUnpopulateZSBufferOUT->eError =
+	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
+					      (IMG_HANDLE) psRGXUnpopulateZSBufferIN->hsPopulation,
+					      PVRSRV_HANDLE_TYPE_RGX_POPULATION);
+	if (unlikely((psRGXUnpopulateZSBufferOUT->eError != PVRSRV_OK) &&
+		     (psRGXUnpopulateZSBufferOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
+		     (psRGXUnpopulateZSBufferOUT->eError != PVRSRV_ERROR_RETRY)))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+			 "%s: %s",
+			 __func__, PVRSRVGetErrorString(psRGXUnpopulateZSBufferOUT->eError)));
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXUnpopulateZSBuffer_exit;
 	}
 
-	/* Allocated space should be equal to the last updated offset */
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXCreateHWRTDataSetOUT->eError == PVRSRV_OK)
-		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
-#endif /* PVRSRV_NEED_PVR_ASSERT */
+	/* Release now we have destroyed handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	if (!bHaveEnoughSpace && pArrayArgsBuffer)
-		OSFreeMemNoStats(pArrayArgsBuffer);
+RGXUnpopulateZSBuffer_exit:
 
 	return 0;
 }
 
 static IMG_INT
-PVRSRVBridgeRGXDestroyHWRTDataSet(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXDestroyHWRTDataSetIN_UI8,
-				  IMG_UINT8 * psRGXDestroyHWRTDataSetOUT_UI8,
-				  CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXDestroyFreeList(IMG_UINT32 ui32DispatchTableEntry,
+			       IMG_UINT8 * psRGXDestroyFreeListIN_UI8,
+			       IMG_UINT8 * psRGXDestroyFreeListOUT_UI8,
+			       CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXDESTROYHWRTDATASET *psRGXDestroyHWRTDataSetIN =
-	    (PVRSRV_BRIDGE_IN_RGXDESTROYHWRTDATASET *)
-	    IMG_OFFSET_ADDR(psRGXDestroyHWRTDataSetIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXDESTROYHWRTDATASET *psRGXDestroyHWRTDataSetOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXDESTROYHWRTDATASET *)
-	    IMG_OFFSET_ADDR(psRGXDestroyHWRTDataSetOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXDESTROYFREELIST *psRGXDestroyFreeListIN =
+	    (PVRSRV_BRIDGE_IN_RGXDESTROYFREELIST *) IMG_OFFSET_ADDR(psRGXDestroyFreeListIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST *psRGXDestroyFreeListOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST *) IMG_OFFSET_ADDR(psRGXDestroyFreeListOUT_UI8,
+								     0);
 
 	/* Lock over handle destruction. */
 	LockHandle(psConnection->psHandleBase);
 
-	psRGXDestroyHWRTDataSetOUT->eError =
+	psRGXDestroyFreeListOUT->eError =
 	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psRGXDestroyHWRTDataSetIN->
-					      hKmHwRTDataSet,
-					      PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET);
-	if (unlikely
-	    ((psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_OK)
-	     && (psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
-	     && (psRGXDestroyHWRTDataSetOUT->eError != PVRSRV_ERROR_RETRY)))
+					      (IMG_HANDLE) psRGXDestroyFreeListIN->hCleanupCookie,
+					      PVRSRV_HANDLE_TYPE_RGX_FREELIST);
+	if (unlikely((psRGXDestroyFreeListOUT->eError != PVRSRV_OK) &&
+		     (psRGXDestroyFreeListOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
+		     (psRGXDestroyFreeListOUT->eError != PVRSRV_ERROR_RETRY)))
 	{
 		PVR_DPF((PVR_DBG_ERROR,
 			 "%s: %s",
-			 __func__, PVRSRVGetErrorString(psRGXDestroyHWRTDataSetOUT->eError)));
+			 __func__, PVRSRVGetErrorString(psRGXDestroyFreeListOUT->eError)));
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXDestroyHWRTDataSet_exit;
+		goto RGXDestroyFreeList_exit;
 	}
 
 	/* Release now we have destroyed handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-RGXDestroyHWRTDataSet_exit:
+RGXDestroyFreeList_exit:
 
 	return 0;
 }
 
-static PVRSRV_ERROR _RGXCreateZSBufferpssZSBufferKMIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = RGXDestroyZSBufferKM((RGX_ZSBUFFER_DATA *) pvData);
-	return eError;
-}
-
 static IMG_INT
-PVRSRVBridgeRGXCreateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
-			      IMG_UINT8 * psRGXCreateZSBufferIN_UI8,
-			      IMG_UINT8 * psRGXCreateZSBufferOUT_UI8,
-			      CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXDestroyRenderContext(IMG_UINT32 ui32DispatchTableEntry,
+				    IMG_UINT8 * psRGXDestroyRenderContextIN_UI8,
+				    IMG_UINT8 * psRGXDestroyRenderContextOUT_UI8,
+				    CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCREATEZSBUFFER *psRGXCreateZSBufferIN =
-	    (PVRSRV_BRIDGE_IN_RGXCREATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXCreateZSBufferIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCREATEZSBUFFER *psRGXCreateZSBufferOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCREATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXCreateZSBufferOUT_UI8, 0);
-
-	IMG_HANDLE hReservation = psRGXCreateZSBufferIN->hReservation;
-	DEVMEMINT_RESERVATION *psReservationInt = NULL;
-	IMG_HANDLE hPMR = psRGXCreateZSBufferIN->hPMR;
-	PMR *psPMRInt = NULL;
-	RGX_ZSBUFFER_DATA *pssZSBufferKMInt = NULL;
+	PVRSRV_BRIDGE_IN_RGXDESTROYRENDERCONTEXT *psRGXDestroyRenderContextIN =
+	    (PVRSRV_BRIDGE_IN_RGXDESTROYRENDERCONTEXT *)
+	    IMG_OFFSET_ADDR(psRGXDestroyRenderContextIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXDESTROYRENDERCONTEXT *psRGXDestroyRenderContextOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXDESTROYRENDERCONTEXT *)
+	    IMG_OFFSET_ADDR(psRGXDestroyRenderContextOUT_UI8, 0);
 
-	/* Lock over handle lookup. */
+	/* Lock over handle destruction. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Look up the address from the handle */
-	psRGXCreateZSBufferOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psReservationInt,
-				       hReservation,
-				       PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION, IMG_TRUE);
-	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
+	psRGXDestroyRenderContextOUT->eError =
+	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
+					      (IMG_HANDLE) psRGXDestroyRenderContextIN->
+					      hCleanupCookie,
+					      PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+	if (unlikely
+	    ((psRGXDestroyRenderContextOUT->eError != PVRSRV_OK)
+	     && (psRGXDestroyRenderContextOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
+	     && (psRGXDestroyRenderContextOUT->eError != PVRSRV_ERROR_RETRY)))
 	{
+		PVR_DPF((PVR_DBG_ERROR,
+			 "%s: %s",
+			 __func__, PVRSRVGetErrorString(psRGXDestroyRenderContextOUT->eError)));
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateZSBuffer_exit;
+		goto RGXDestroyRenderContext_exit;
 	}
 
-	/* Look up the address from the handle */
-	psRGXCreateZSBufferOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psPMRInt,
-				       hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
-	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateZSBuffer_exit;
-	}
-	/* Release now we have looked up handles. */
+	/* Release now we have destroyed handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXCreateZSBufferOUT->eError =
-	    RGXCreateZSBufferKM(psConnection, OSGetDevNode(psConnection),
-				psReservationInt,
-				psPMRInt, psRGXCreateZSBufferIN->uiMapFlags, &pssZSBufferKMInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
-	{
-		goto RGXCreateZSBuffer_exit;
-	}
+RGXDestroyRenderContext_exit:
 
-	/* Lock over handle creation. */
+	return 0;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXSendZSStoreDisable(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXSendZSStoreDisableIN_UI8,
+				  IMG_UINT8 * psRGXSendZSStoreDisableOUT_UI8,
+				  CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXSENDZSSTOREDISABLE *psRGXSendZSStoreDisableIN =
+	    (PVRSRV_BRIDGE_IN_RGXSENDZSSTOREDISABLE *)
+	    IMG_OFFSET_ADDR(psRGXSendZSStoreDisableIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSENDZSSTOREDISABLE *psRGXSendZSStoreDisableOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSENDZSSTOREDISABLE *)
+	    IMG_OFFSET_ADDR(psRGXSendZSStoreDisableOUT_UI8, 0);
+
+	IMG_HANDLE hRenderContext = psRGXSendZSStoreDisableIN->hRenderContext;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+
+	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
-	psRGXCreateZSBufferOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								   &psRGXCreateZSBufferOUT->
-								   hsZSBufferKM,
-								   (void *)pssZSBufferKMInt,
-								   PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER,
-								   PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								   (PFN_HANDLE_RELEASE) &
-								   _RGXCreateZSBufferpssZSBufferKMIntRelease);
-	if (unlikely(psRGXCreateZSBufferOUT->eError != PVRSRV_OK))
+	/* Look up the address from the handle */
+	psRGXSendZSStoreDisableOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psRenderContextInt,
+				       hRenderContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSendZSStoreDisableOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateZSBuffer_exit;
+		goto RGXSendZSStoreDisable_exit;
 	}
-
-	/* Release now we have created handles. */
+	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-RGXCreateZSBuffer_exit:
+	psRGXSendZSStoreDisableOUT->eError =
+	    PVRSRVRGXSendZSStoreDisableKM(psConnection, OSGetDevNode(psConnection),
+					  psRenderContextInt,
+					  psRGXSendZSStoreDisableIN->bDisableDepthStore,
+					  psRGXSendZSStoreDisableIN->bDisableStencilStore,
+					  psRGXSendZSStoreDisableIN->i32ExtJobRefToDisableZSStore);
+
+RGXSendZSStoreDisable_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Unreference the previously looked up handle */
-	if (psReservationInt)
-	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hReservation, PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION);
-	}
-
-	/* Unreference the previously looked up handle */
-	if (psPMRInt)
+	if (psRenderContextInt)
 	{
 		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+					    hRenderContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
 	}
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXCreateZSBufferOUT->eError != PVRSRV_OK)
-	{
-		if (pssZSBufferKMInt)
-		{
-			RGXDestroyZSBufferKM(pssZSBufferKMInt);
-		}
-	}
-
 	return 0;
 }
 
 static IMG_INT
-PVRSRVBridgeRGXDestroyZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
-			       IMG_UINT8 * psRGXDestroyZSBufferIN_UI8,
-			       IMG_UINT8 * psRGXDestroyZSBufferOUT_UI8,
-			       CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXSetRenderContextPriority(IMG_UINT32 ui32DispatchTableEntry,
+					IMG_UINT8 * psRGXSetRenderContextPriorityIN_UI8,
+					IMG_UINT8 * psRGXSetRenderContextPriorityOUT_UI8,
+					CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXDESTROYZSBUFFER *psRGXDestroyZSBufferIN =
-	    (PVRSRV_BRIDGE_IN_RGXDESTROYZSBUFFER *) IMG_OFFSET_ADDR(psRGXDestroyZSBufferIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXDESTROYZSBUFFER *psRGXDestroyZSBufferOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXDESTROYZSBUFFER *) IMG_OFFSET_ADDR(psRGXDestroyZSBufferOUT_UI8,
-								     0);
-
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psRGXDestroyZSBufferOUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psRGXDestroyZSBufferIN->
-					      hsZSBufferMemDesc,
-					      PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
-	if (unlikely
-	    ((psRGXDestroyZSBufferOUT->eError != PVRSRV_OK)
-	     && (psRGXDestroyZSBufferOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
-	     && (psRGXDestroyZSBufferOUT->eError != PVRSRV_ERROR_RETRY)))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s",
-			 __func__, PVRSRVGetErrorString(psRGXDestroyZSBufferOUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXDestroyZSBuffer_exit;
-	}
-
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-RGXDestroyZSBuffer_exit:
-
-	return 0;
-}
-
-static PVRSRV_ERROR _RGXPopulateZSBufferpssPopulationIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = RGXUnpopulateZSBufferKM((RGX_POPULATION *) pvData);
-	return eError;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXPopulateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
-				IMG_UINT8 * psRGXPopulateZSBufferIN_UI8,
-				IMG_UINT8 * psRGXPopulateZSBufferOUT_UI8,
-				CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXPOPULATEZSBUFFER *psRGXPopulateZSBufferIN =
-	    (PVRSRV_BRIDGE_IN_RGXPOPULATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXPopulateZSBufferIN_UI8,
-								     0);
-	PVRSRV_BRIDGE_OUT_RGXPOPULATEZSBUFFER *psRGXPopulateZSBufferOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXPOPULATEZSBUFFER *) IMG_OFFSET_ADDR(psRGXPopulateZSBufferOUT_UI8,
-								      0);
+	PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPRIORITY *psRGXSetRenderContextPriorityIN =
+	    (PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPRIORITY *)
+	    IMG_OFFSET_ADDR(psRGXSetRenderContextPriorityIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPRIORITY *psRGXSetRenderContextPriorityOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPRIORITY *)
+	    IMG_OFFSET_ADDR(psRGXSetRenderContextPriorityOUT_UI8, 0);
 
-	IMG_HANDLE hsZSBufferKM = psRGXPopulateZSBufferIN->hsZSBufferKM;
-	RGX_ZSBUFFER_DATA *pssZSBufferKMInt = NULL;
-	RGX_POPULATION *pssPopulationInt = NULL;
+	IMG_HANDLE hRenderContext = psRGXSetRenderContextPriorityIN->hRenderContext;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXPopulateZSBufferOUT->eError =
+	psRGXSetRenderContextPriorityOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&pssZSBufferKMInt,
-				       hsZSBufferKM,
-				       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
-	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
+				       (void **)&psRenderContextInt,
+				       hRenderContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSetRenderContextPriorityOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXPopulateZSBuffer_exit;
+		goto RGXSetRenderContextPriority_exit;
 	}
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXPopulateZSBufferOUT->eError =
-	    RGXPopulateZSBufferKM(pssZSBufferKMInt, &pssPopulationInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
-	{
-		goto RGXPopulateZSBuffer_exit;
-	}
-
-	/* Lock over handle creation. */
-	LockHandle(psConnection->psHandleBase);
-
-	psRGXPopulateZSBufferOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								     &psRGXPopulateZSBufferOUT->
-								     hsPopulation,
-								     (void *)pssPopulationInt,
-								     PVRSRV_HANDLE_TYPE_RGX_POPULATION,
-								     PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								     (PFN_HANDLE_RELEASE) &
-								     _RGXPopulateZSBufferpssPopulationIntRelease);
-	if (unlikely(psRGXPopulateZSBufferOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXPopulateZSBuffer_exit;
-	}
-
-	/* Release now we have created handles. */
-	UnlockHandle(psConnection->psHandleBase);
+	psRGXSetRenderContextPriorityOUT->eError =
+	    PVRSRVRGXSetRenderContextPriorityKM(psConnection, OSGetDevNode(psConnection),
+						psRenderContextInt,
+						psRGXSetRenderContextPriorityIN->i32Priority);
 
-RGXPopulateZSBuffer_exit:
+RGXSetRenderContextPriority_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Unreference the previously looked up handle */
-	if (pssZSBufferKMInt)
+	if (psRenderContextInt)
 	{
 		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hsZSBufferKM, PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
+					    hRenderContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
 	}
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXPopulateZSBufferOUT->eError != PVRSRV_OK)
-	{
-		if (pssPopulationInt)
-		{
-			RGXUnpopulateZSBufferKM(pssPopulationInt);
-		}
-	}
-
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXUnpopulateZSBuffer(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXUnpopulateZSBufferIN_UI8,
-				  IMG_UINT8 * psRGXUnpopulateZSBufferOUT_UI8,
-				  CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXUNPOPULATEZSBUFFER *psRGXUnpopulateZSBufferIN =
-	    (PVRSRV_BRIDGE_IN_RGXUNPOPULATEZSBUFFER *)
-	    IMG_OFFSET_ADDR(psRGXUnpopulateZSBufferIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER *psRGXUnpopulateZSBufferOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER *)
-	    IMG_OFFSET_ADDR(psRGXUnpopulateZSBufferOUT_UI8, 0);
-
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psRGXUnpopulateZSBufferOUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psRGXUnpopulateZSBufferIN->hsPopulation,
-					      PVRSRV_HANDLE_TYPE_RGX_POPULATION);
-	if (unlikely((psRGXUnpopulateZSBufferOUT->eError != PVRSRV_OK) &&
-		     (psRGXUnpopulateZSBufferOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
-		     (psRGXUnpopulateZSBufferOUT->eError != PVRSRV_ERROR_RETRY)))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s",
-			 __func__, PVRSRVGetErrorString(psRGXUnpopulateZSBufferOUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXUnpopulateZSBuffer_exit;
-	}
-
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-RGXUnpopulateZSBuffer_exit:
-
 	return 0;
 }
 
-static PVRSRV_ERROR _RGXCreateFreeListpsCleanupCookieIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = RGXDestroyFreeList((RGX_FREELIST *) pvData);
-	return eError;
-}
-
 static IMG_INT
-PVRSRVBridgeRGXCreateFreeList(IMG_UINT32 ui32DispatchTableEntry,
-			      IMG_UINT8 * psRGXCreateFreeListIN_UI8,
-			      IMG_UINT8 * psRGXCreateFreeListOUT_UI8,
-			      CONNECTION_DATA * psConnection)
+PVRSRVBridgeRGXRenderContextStalled(IMG_UINT32 ui32DispatchTableEntry,
+				    IMG_UINT8 * psRGXRenderContextStalledIN_UI8,
+				    IMG_UINT8 * psRGXRenderContextStalledOUT_UI8,
+				    CONNECTION_DATA * psConnection)
 {
-	PVRSRV_BRIDGE_IN_RGXCREATEFREELIST *psRGXCreateFreeListIN =
-	    (PVRSRV_BRIDGE_IN_RGXCREATEFREELIST *) IMG_OFFSET_ADDR(psRGXCreateFreeListIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST *psRGXCreateFreeListOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST *) IMG_OFFSET_ADDR(psRGXCreateFreeListOUT_UI8, 0);
+	PVRSRV_BRIDGE_IN_RGXRENDERCONTEXTSTALLED *psRGXRenderContextStalledIN =
+	    (PVRSRV_BRIDGE_IN_RGXRENDERCONTEXTSTALLED *)
+	    IMG_OFFSET_ADDR(psRGXRenderContextStalledIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXRENDERCONTEXTSTALLED *psRGXRenderContextStalledOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXRENDERCONTEXTSTALLED *)
+	    IMG_OFFSET_ADDR(psRGXRenderContextStalledOUT_UI8, 0);
 
-	IMG_HANDLE hMemCtxPrivData = psRGXCreateFreeListIN->hMemCtxPrivData;
-	IMG_HANDLE hMemCtxPrivDataInt = NULL;
-	IMG_HANDLE hsGlobalFreeList = psRGXCreateFreeListIN->hsGlobalFreeList;
-	RGX_FREELIST *pssGlobalFreeListInt = NULL;
-	IMG_HANDLE hsFreeListPMR = psRGXCreateFreeListIN->hsFreeListPMR;
-	PMR *pssFreeListPMRInt = NULL;
-	RGX_FREELIST *psCleanupCookieInt = NULL;
+	IMG_HANDLE hRenderContext = psRGXRenderContextStalledIN->hRenderContext;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXCreateFreeListOUT->eError =
+	psRGXRenderContextStalledOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&hMemCtxPrivDataInt,
-				       hMemCtxPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA, IMG_TRUE);
-	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
+				       (void **)&psRenderContextInt,
+				       hRenderContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXRenderContextStalledOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateFreeList_exit;
+		goto RGXRenderContextStalled_exit;
 	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXCreateFreeListIN->hsGlobalFreeList)
-	{
-		/* Look up the address from the handle */
-		psRGXCreateFreeListOUT->eError =
-		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-					       (void **)&pssGlobalFreeListInt,
-					       hsGlobalFreeList,
-					       PVRSRV_HANDLE_TYPE_RGX_FREELIST, IMG_TRUE);
-		if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
-		{
-			UnlockHandle(psConnection->psHandleBase);
-			goto RGXCreateFreeList_exit;
-		}
-	}
+	psRGXRenderContextStalledOUT->eError = RGXRenderContextStalledKM(psRenderContextInt);
 
-	/* Look up the address from the handle */
-	psRGXCreateFreeListOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&pssFreeListPMRInt,
-				       hsFreeListPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
-	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
+RGXRenderContextStalled_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psRenderContextInt)
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateFreeList_exit;
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hRenderContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
 	}
-	/* Release now we have looked up handles. */
+	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXCreateFreeListOUT->eError =
-	    RGXCreateFreeList(psConnection, OSGetDevNode(psConnection),
-			      hMemCtxPrivDataInt,
-			      psRGXCreateFreeListIN->ui32MaxFLPages,
-			      psRGXCreateFreeListIN->ui32InitFLPages,
-			      psRGXCreateFreeListIN->ui32GrowFLPages,
-			      psRGXCreateFreeListIN->ui32GrowParamThreshold,
-			      pssGlobalFreeListInt,
-			      psRGXCreateFreeListIN->bbFreeListCheck,
-			      psRGXCreateFreeListIN->spsFreeListDevVAddr,
-			      pssFreeListPMRInt,
-			      psRGXCreateFreeListIN->uiPMROffset, &psCleanupCookieInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
-	{
-		goto RGXCreateFreeList_exit;
-	}
+	return 0;
+}
 
-	/* Lock over handle creation. */
-	LockHandle(psConnection->psHandleBase);
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
+	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
+	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
 
-	psRGXCreateFreeListOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								   &psRGXCreateFreeListOUT->
-								   hCleanupCookie,
-								   (void *)psCleanupCookieInt,
-								   PVRSRV_HANDLE_TYPE_RGX_FREELIST,
-								   PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								   (PFN_HANDLE_RELEASE) &
-								   _RGXCreateFreeListpsCleanupCookieIntRelease);
-	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateFreeList_exit;
-	}
+static IMG_INT
+PVRSRVBridgeRGXKickTA3D2(IMG_UINT32 ui32DispatchTableEntry,
+			 IMG_UINT8 * psRGXKickTA3D2IN_UI8,
+			 IMG_UINT8 * psRGXKickTA3D2OUT_UI8, CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXKICKTA3D2 *psRGXKickTA3D2IN =
+	    (PVRSRV_BRIDGE_IN_RGXKICKTA3D2 *) IMG_OFFSET_ADDR(psRGXKickTA3D2IN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXKICKTA3D2 *psRGXKickTA3D2OUT =
+	    (PVRSRV_BRIDGE_OUT_RGXKICKTA3D2 *) IMG_OFFSET_ADDR(psRGXKickTA3D2OUT_UI8, 0);
 
-	/* Release now we have created handles. */
-	UnlockHandle(psConnection->psHandleBase);
+	IMG_HANDLE hRenderContext = psRGXKickTA3D2IN->hRenderContext;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+	SYNC_PRIMITIVE_BLOCK **psClientTAFenceSyncPrimBlockInt = NULL;
+	IMG_HANDLE *hClientTAFenceSyncPrimBlockInt2 = NULL;
+	IMG_UINT32 *ui32ClientTAFenceSyncOffsetInt = NULL;
+	IMG_UINT32 *ui32ClientTAFenceValueInt = NULL;
+	SYNC_PRIMITIVE_BLOCK **psClientTAUpdateSyncPrimBlockInt = NULL;
+	IMG_HANDLE *hClientTAUpdateSyncPrimBlockInt2 = NULL;
+	IMG_UINT32 *ui32ClientTAUpdateSyncOffsetInt = NULL;
+	IMG_UINT32 *ui32ClientTAUpdateValueInt = NULL;
+	SYNC_PRIMITIVE_BLOCK **psClient3DUpdateSyncPrimBlockInt = NULL;
+	IMG_HANDLE *hClient3DUpdateSyncPrimBlockInt2 = NULL;
+	IMG_UINT32 *ui32Client3DUpdateSyncOffsetInt = NULL;
+	IMG_UINT32 *ui32Client3DUpdateValueInt = NULL;
+	IMG_HANDLE hPRFenceUFOSyncPrimBlock = psRGXKickTA3D2IN->hPRFenceUFOSyncPrimBlock;
+	SYNC_PRIMITIVE_BLOCK *psPRFenceUFOSyncPrimBlockInt = NULL;
+	IMG_CHAR *uiUpdateFenceNameInt = NULL;
+	IMG_CHAR *uiUpdateFenceName3DInt = NULL;
+	IMG_BYTE *ui8TACmdInt = NULL;
+	IMG_BYTE *ui83DPRCmdInt = NULL;
+	IMG_BYTE *ui83DCmdInt = NULL;
+	IMG_HANDLE hKMHWRTDataSet = psRGXKickTA3D2IN->hKMHWRTDataSet;
+	RGX_KM_HW_RT_DATASET *psKMHWRTDataSetInt = NULL;
+	IMG_HANDLE hZSBuffer = psRGXKickTA3D2IN->hZSBuffer;
+	RGX_ZSBUFFER_DATA *psZSBufferInt = NULL;
+	IMG_HANDLE hMSAAScratchBuffer = psRGXKickTA3D2IN->hMSAAScratchBuffer;
+	RGX_ZSBUFFER_DATA *psMSAAScratchBufferInt = NULL;
+	IMG_UINT32 *ui32SyncPMRFlagsInt = NULL;
+	PMR **psSyncPMRsInt = NULL;
+	IMG_HANDLE *hSyncPMRsInt2 = NULL;
 
-RGXCreateFreeList_exit:
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount *
+	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount *
+	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount *
+	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
+	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *)) +
+	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
 
-	/* Unreference the previously looked up handle */
-	if (hMemCtxPrivDataInt)
+	if (unlikely(psRGXKickTA3D2IN->ui32ClientTAFenceCount > PVRSRV_MAX_SYNCS))
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hMemCtxPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA);
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
-	if (psRGXCreateFreeListIN->hsGlobalFreeList)
+	if (unlikely(psRGXKickTA3D2IN->ui32ClientTAUpdateCount > PVRSRV_MAX_SYNCS))
 	{
-
-		/* Unreference the previously looked up handle */
-		if (pssGlobalFreeListInt)
-		{
-			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-						    hsGlobalFreeList,
-						    PVRSRV_HANDLE_TYPE_RGX_FREELIST);
-		}
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
-	/* Unreference the previously looked up handle */
-	if (pssFreeListPMRInt)
+	if (unlikely(psRGXKickTA3D2IN->ui32Client3DUpdateCount > PVRSRV_MAX_SYNCS))
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hsFreeListPMR, PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXCreateFreeListOUT->eError != PVRSRV_OK)
+	if (unlikely(psRGXKickTA3D2IN->ui32TACmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
 	{
-		if (psCleanupCookieInt)
-		{
-			RGXDestroyFreeList(psCleanupCookieInt);
-		}
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXDestroyFreeList(IMG_UINT32 ui32DispatchTableEntry,
-			       IMG_UINT8 * psRGXDestroyFreeListIN_UI8,
-			       IMG_UINT8 * psRGXDestroyFreeListOUT_UI8,
-			       CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXDESTROYFREELIST *psRGXDestroyFreeListIN =
-	    (PVRSRV_BRIDGE_IN_RGXDESTROYFREELIST *) IMG_OFFSET_ADDR(psRGXDestroyFreeListIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST *psRGXDestroyFreeListOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST *) IMG_OFFSET_ADDR(psRGXDestroyFreeListOUT_UI8,
-								     0);
-
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psRGXDestroyFreeListOUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psRGXDestroyFreeListIN->hCleanupCookie,
-					      PVRSRV_HANDLE_TYPE_RGX_FREELIST);
-	if (unlikely((psRGXDestroyFreeListOUT->eError != PVRSRV_OK) &&
-		     (psRGXDestroyFreeListOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL) &&
-		     (psRGXDestroyFreeListOUT->eError != PVRSRV_ERROR_RETRY)))
+	if (unlikely(psRGXKickTA3D2IN->ui323DPRCmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s",
-			 __func__, PVRSRVGetErrorString(psRGXDestroyFreeListOUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXDestroyFreeList_exit;
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-RGXDestroyFreeList_exit:
-
-	return 0;
-}
-
-static PVRSRV_ERROR _RGXCreateRenderContextpsRenderContextIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = PVRSRVRGXDestroyRenderContextKM((RGX_SERVER_RENDER_CONTEXT *) pvData);
-	return eError;
-}
-
-static_assert(RGXFWIF_RF_CMD_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_RF_CMD_SIZE must not be larger than IMG_UINT32_MAX");
-static_assert(RGXFWIF_STATIC_RENDERCONTEXT_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_STATIC_RENDERCONTEXT_SIZE must not be larger than IMG_UINT32_MAX");
-
-static IMG_INT
-PVRSRVBridgeRGXCreateRenderContext(IMG_UINT32 ui32DispatchTableEntry,
-				   IMG_UINT8 * psRGXCreateRenderContextIN_UI8,
-				   IMG_UINT8 * psRGXCreateRenderContextOUT_UI8,
-				   CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT *psRGXCreateRenderContextIN =
-	    (PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT *)
-	    IMG_OFFSET_ADDR(psRGXCreateRenderContextIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT *psRGXCreateRenderContextOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT *)
-	    IMG_OFFSET_ADDR(psRGXCreateRenderContextOUT_UI8, 0);
-
-	IMG_BYTE *ui8FrameworkCmdInt = NULL;
-	IMG_HANDLE hPrivData = psRGXCreateRenderContextIN->hPrivData;
-	IMG_HANDLE hPrivDataInt = NULL;
-	IMG_BYTE *ui8StaticRenderContextStateInt = NULL;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
-
-	IMG_UINT32 ui32NextOffset = 0;
-	IMG_BYTE *pArrayArgsBuffer = NULL;
-	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
-
-	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE)) +
-	    ((IMG_UINT64) psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize *
-	     sizeof(IMG_BYTE)) + 0;
-
-	if (unlikely(psRGXCreateRenderContextIN->ui32FrameworkCmdSize > RGXFWIF_RF_CMD_SIZE))
+	if (unlikely(psRGXKickTA3D2IN->ui323DCmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
 	{
-		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXCreateRenderContext_exit;
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
-	if (unlikely
-	    (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize >
-	     RGXFWIF_STATIC_RENDERCONTEXT_SIZE))
+	if (unlikely(psRGXKickTA3D2IN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
 	{
-		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXCreateRenderContext_exit;
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXKickTA3D2_exit;
 	}
 
 	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXCreateRenderContext_exit;
+		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXKickTA3D2_exit;
 	}
 
 	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
@@ -1062,7 +783,7 @@ PVRSRVBridgeRGXCreateRenderContext(IMG_UINT32 ui32DispatchTableEntry,
 	{
 		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
 		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXCreateRenderContextIN), sizeof(unsigned long));
+		    PVR_ALIGN(sizeof(*psRGXKickTA3D2IN), sizeof(unsigned long));
 		IMG_UINT32 ui32InBufferExcessSize =
 		    ui32InBufferOffset >=
 		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
@@ -1070,7 +791,7 @@ PVRSRVBridgeRGXCreateRenderContext(IMG_UINT32 ui32DispatchTableEntry,
 		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
 		if (bHaveEnoughSpace)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXCreateRenderContextIN;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickTA3D2IN;
 
 			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
@@ -1080,1263 +801,1597 @@ PVRSRVBridgeRGXCreateRenderContext(IMG_UINT32 ui32DispatchTableEntry,
 
 			if (!pArrayArgsBuffer)
 			{
-				psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXCreateRenderContext_exit;
+				psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXKickTA3D2_exit;
 			}
 		}
 	}
 
-	if (psRGXCreateRenderContextIN->ui32FrameworkCmdSize != 0)
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
 	{
-		ui8FrameworkCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		psClientTAFenceSyncPrimBlockInt =
+		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psClientTAFenceSyncPrimBlockInt, 0,
+			       psRGXKickTA3D2IN->ui32ClientTAFenceCount *
+			       sizeof(SYNC_PRIMITIVE_BLOCK *));
 		ui32NextOffset +=
-		    psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE);
-	}
+		    psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
+		hClientTAFenceSyncPrimBlockInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE);
+	}
 
 	/* Copy the data over */
-	if (psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE) > 0)
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui8FrameworkCmdInt,
-		     (const void __user *)psRGXCreateRenderContextIN->pui8FrameworkCmd,
-		     psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE)) !=
-		    PVRSRV_OK)
+		    (NULL, hClientTAFenceSyncPrimBlockInt2,
+		     (const void __user *)psRGXKickTA3D2IN->phClientTAFenceSyncPrimBlock,
+		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
 		{
-			psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXCreateRenderContext_exit;
+			goto RGXKickTA3D2_exit;
 		}
 	}
-	if (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize != 0)
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
 	{
-		ui8StaticRenderContextStateInt =
-		    (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset +=
-		    psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize * sizeof(IMG_BYTE);
+		ui32ClientTAFenceSyncOffsetInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32);
 	}
 
 	/* Copy the data over */
-	if (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize * sizeof(IMG_BYTE) > 0)
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui8StaticRenderContextStateInt,
-		     (const void __user *)psRGXCreateRenderContextIN->pui8StaticRenderContextState,
-		     psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize *
-		     sizeof(IMG_BYTE)) != PVRSRV_OK)
+		    (NULL, ui32ClientTAFenceSyncOffsetInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAFenceSyncOffset,
+		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
 		{
-			psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXCreateRenderContext_exit;
+			goto RGXKickTA3D2_exit;
 		}
 	}
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
+	{
+		ui32ClientTAFenceValueInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32);
+	}
 
-	/* Lock over handle lookup. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32ClientTAFenceValueInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAFenceValue,
+		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Look up the address from the handle */
-	psRGXCreateRenderContextOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&hPrivDataInt,
-				       hPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA, IMG_TRUE);
-	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateRenderContext_exit;
+		psClientTAUpdateSyncPrimBlockInt =
+		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psClientTAUpdateSyncPrimBlockInt, 0,
+			       psRGXKickTA3D2IN->ui32ClientTAUpdateCount *
+			       sizeof(SYNC_PRIMITIVE_BLOCK *));
+		ui32NextOffset +=
+		    psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
+		hClientTAUpdateSyncPrimBlockInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE);
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXCreateRenderContextOUT->eError =
-	    PVRSRVRGXCreateRenderContextKM(psConnection, OSGetDevNode(psConnection),
-					   psRGXCreateRenderContextIN->i32Priority,
-					   psRGXCreateRenderContextIN->sVDMCallStackAddr,
-					   psRGXCreateRenderContextIN->ui32ui32CallStackDepth,
-					   psRGXCreateRenderContextIN->ui32FrameworkCmdSize,
-					   ui8FrameworkCmdInt,
-					   hPrivDataInt,
-					   psRGXCreateRenderContextIN->
-					   ui32StaticRenderContextStateSize,
-					   ui8StaticRenderContextStateInt,
-					   psRGXCreateRenderContextIN->ui32PackedCCBSizeU8888,
-					   psRGXCreateRenderContextIN->ui32ContextFlags,
-					   psRGXCreateRenderContextIN->ui64RobustnessAddress,
-					   psRGXCreateRenderContextIN->ui32MaxTADeadlineMS,
-					   psRGXCreateRenderContextIN->ui32Max3DDeadlineMS,
-					   &psRenderContextInt);
-	/* Exit early if bridged call fails */
-	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE) > 0)
 	{
-		goto RGXCreateRenderContext_exit;
+		if (OSCopyFromUser
+		    (NULL, hClientTAUpdateSyncPrimBlockInt2,
+		     (const void __user *)psRGXKickTA3D2IN->phClientTAUpdateSyncPrimBlock,
+		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
+	{
+		ui32ClientTAUpdateSyncOffsetInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32);
 	}
 
-	/* Lock over handle creation. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32ClientTAUpdateSyncOffsetInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAUpdateSyncOffset,
+		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	psRGXCreateRenderContextOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-									&psRGXCreateRenderContextOUT->
-									hRenderContext,
-									(void *)psRenderContextInt,
-									PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT,
-									PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-									(PFN_HANDLE_RELEASE) &
-									_RGXCreateRenderContextpsRenderContextIntRelease);
-	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXCreateRenderContext_exit;
+		ui32ClientTAUpdateValueInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32);
 	}
 
-	/* Release now we have created handles. */
-	UnlockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32ClientTAUpdateValueInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAUpdateValue,
+		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-RGXCreateRenderContext_exit:
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
+	{
+		psClient3DUpdateSyncPrimBlockInt =
+		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psClient3DUpdateSyncPrimBlockInt, 0,
+			       psRGXKickTA3D2IN->ui32Client3DUpdateCount *
+			       sizeof(SYNC_PRIMITIVE_BLOCK *));
+		ui32NextOffset +=
+		    psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
+		hClient3DUpdateSyncPrimBlockInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE);
+	}
 
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, hClient3DUpdateSyncPrimBlockInt2,
+		     (const void __user *)psRGXKickTA3D2IN->phClient3DUpdateSyncPrimBlock,
+		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Unreference the previously looked up handle */
-	if (hPrivDataInt)
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA);
+		ui32Client3DUpdateSyncOffsetInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32);
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXCreateRenderContextOUT->eError != PVRSRV_OK)
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32) > 0)
 	{
-		if (psRenderContextInt)
+		if (OSCopyFromUser
+		    (NULL, ui32Client3DUpdateSyncOffsetInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32Client3DUpdateSyncOffset,
+		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
 		{
-			PVRSRVRGXDestroyRenderContextKM(psRenderContextInt);
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXKickTA3D2_exit;
 		}
 	}
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
+	{
+		ui32Client3DUpdateValueInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32);
+	}
 
-	/* Allocated space should be equal to the last updated offset */
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXCreateRenderContextOUT->eError == PVRSRV_OK)
-		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
-#endif /* PVRSRV_NEED_PVR_ASSERT */
-
-	if (!bHaveEnoughSpace && pArrayArgsBuffer)
-		OSFreeMemNoStats(pArrayArgsBuffer);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32Client3DUpdateValueInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32Client3DUpdateValue,
+		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	return 0;
-}
+			goto RGXKickTA3D2_exit;
+		}
+	}
 
-static IMG_INT
-PVRSRVBridgeRGXDestroyRenderContext(IMG_UINT32 ui32DispatchTableEntry,
-				    IMG_UINT8 * psRGXDestroyRenderContextIN_UI8,
-				    IMG_UINT8 * psRGXDestroyRenderContextOUT_UI8,
-				    CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXDESTROYRENDERCONTEXT *psRGXDestroyRenderContextIN =
-	    (PVRSRV_BRIDGE_IN_RGXDESTROYRENDERCONTEXT *)
-	    IMG_OFFSET_ADDR(psRGXDestroyRenderContextIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXDESTROYRENDERCONTEXT *psRGXDestroyRenderContextOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXDESTROYRENDERCONTEXT *)
-	    IMG_OFFSET_ADDR(psRGXDestroyRenderContextOUT_UI8, 0);
+	{
+		uiUpdateFenceNameInt =
+		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+	}
 
-	/* Lock over handle destruction. */
-	LockHandle(psConnection->psHandleBase);
-
-	psRGXDestroyRenderContextOUT->eError =
-	    PVRSRVDestroyHandleStagedUnlocked(psConnection->psHandleBase,
-					      (IMG_HANDLE) psRGXDestroyRenderContextIN->
-					      hCleanupCookie,
-					      PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
-	if (unlikely
-	    ((psRGXDestroyRenderContextOUT->eError != PVRSRV_OK)
-	     && (psRGXDestroyRenderContextOUT->eError != PVRSRV_ERROR_KERNEL_CCB_FULL)
-	     && (psRGXDestroyRenderContextOUT->eError != PVRSRV_ERROR_RETRY)))
+	/* Copy the data over */
+	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
 	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: %s",
-			 __func__, PVRSRVGetErrorString(psRGXDestroyRenderContextOUT->eError)));
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXDestroyRenderContext_exit;
-	}
-
-	/* Release now we have destroyed handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-RGXDestroyRenderContext_exit:
-
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXSendZSStoreDisable(IMG_UINT32 ui32DispatchTableEntry,
-				  IMG_UINT8 * psRGXSendZSStoreDisableIN_UI8,
-				  IMG_UINT8 * psRGXSendZSStoreDisableOUT_UI8,
-				  CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXSENDZSSTOREDISABLE *psRGXSendZSStoreDisableIN =
-	    (PVRSRV_BRIDGE_IN_RGXSENDZSSTOREDISABLE *)
-	    IMG_OFFSET_ADDR(psRGXSendZSStoreDisableIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXSENDZSSTOREDISABLE *psRGXSendZSStoreDisableOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXSENDZSSTOREDISABLE *)
-	    IMG_OFFSET_ADDR(psRGXSendZSStoreDisableOUT_UI8, 0);
-
-	IMG_HANDLE hRenderContext = psRGXSendZSStoreDisableIN->hRenderContext;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+		if (OSCopyFromUser
+		    (NULL, uiUpdateFenceNameInt,
+		     (const void __user *)psRGXKickTA3D2IN->puiUpdateFenceName,
+		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Lock over handle lookup. */
-	LockHandle(psConnection->psHandleBase);
+			goto RGXKickTA3D2_exit;
+		}
+		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
+						    1] = '\0';
+	}
 
-	/* Look up the address from the handle */
-	psRGXSendZSStoreDisableOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psRenderContextInt,
-				       hRenderContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXSendZSStoreDisableOUT->eError != PVRSRV_OK))
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXSendZSStoreDisable_exit;
+		uiUpdateFenceName3DInt =
+		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-	psRGXSendZSStoreDisableOUT->eError =
-	    PVRSRVRGXSendZSStoreDisableKM(psConnection, OSGetDevNode(psConnection),
-					  psRenderContextInt,
-					  psRGXSendZSStoreDisableIN->bDisableDepthStore,
-					  psRGXSendZSStoreDisableIN->bDisableStencilStore,
-					  psRGXSendZSStoreDisableIN->i32ExtJobRefToDisableZSStore);
-
-RGXSendZSStoreDisable_exit:
 
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, uiUpdateFenceName3DInt,
+		     (const void __user *)psRGXKickTA3D2IN->puiUpdateFenceName3D,
+		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Unreference the previously looked up handle */
-	if (psRenderContextInt)
+			goto RGXKickTA3D2_exit;
+		}
+		((IMG_CHAR *) uiUpdateFenceName3DInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
+						      1] = '\0';
+	}
+	if (psRGXKickTA3D2IN->ui32TACmdSize != 0)
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hRenderContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+		ui8TACmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE);
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-	return 0;
-}
 
-static IMG_INT
-PVRSRVBridgeRGXSetRenderContextPriority(IMG_UINT32 ui32DispatchTableEntry,
-					IMG_UINT8 * psRGXSetRenderContextPriorityIN_UI8,
-					IMG_UINT8 * psRGXSetRenderContextPriorityOUT_UI8,
-					CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPRIORITY *psRGXSetRenderContextPriorityIN =
-	    (PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPRIORITY *)
-	    IMG_OFFSET_ADDR(psRGXSetRenderContextPriorityIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPRIORITY *psRGXSetRenderContextPriorityOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPRIORITY *)
-	    IMG_OFFSET_ADDR(psRGXSetRenderContextPriorityOUT_UI8, 0);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui8TACmdInt, (const void __user *)psRGXKickTA3D2IN->pui8TACmd,
+		     psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	IMG_HANDLE hRenderContext = psRGXSetRenderContextPriorityIN->hRenderContext;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui323DPRCmdSize != 0)
+	{
+		ui83DPRCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE);
+	}
 
-	/* Lock over handle lookup. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui83DPRCmdInt, (const void __user *)psRGXKickTA3D2IN->pui83DPRCmd,
+		     psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Look up the address from the handle */
-	psRGXSetRenderContextPriorityOUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psRenderContextInt,
-				       hRenderContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXSetRenderContextPriorityOUT->eError != PVRSRV_OK))
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui323DCmdSize != 0)
 	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXSetRenderContextPriority_exit;
+		ui83DCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE);
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXSetRenderContextPriorityOUT->eError =
-	    PVRSRVRGXSetRenderContextPriorityKM(psConnection, OSGetDevNode(psConnection),
-						psRenderContextInt,
-						psRGXSetRenderContextPriorityIN->i32Priority);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui83DCmdInt, (const void __user *)psRGXKickTA3D2IN->pui83DCmd,
+		     psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-RGXSetRenderContextPriority_exit:
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32SyncPMRCount != 0)
+	{
+		ui32SyncPMRFlagsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32);
+	}
 
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32SyncPMRFlagsInt,
+		     (const void __user *)psRGXKickTA3D2IN->pui32SyncPMRFlags,
+		     psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	/* Unreference the previously looked up handle */
-	if (psRenderContextInt)
+			goto RGXKickTA3D2_exit;
+		}
+	}
+	if (psRGXKickTA3D2IN->ui32SyncPMRCount != 0)
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hRenderContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+		psSyncPMRsInt = (PMR **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psSyncPMRsInt, 0,
+			       psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *));
+		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *);
+		hSyncPMRsInt2 = (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXRenderContextStalled(IMG_UINT32 ui32DispatchTableEntry,
-				    IMG_UINT8 * psRGXRenderContextStalledIN_UI8,
-				    IMG_UINT8 * psRGXRenderContextStalledOUT_UI8,
-				    CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXRENDERCONTEXTSTALLED *psRGXRenderContextStalledIN =
-	    (PVRSRV_BRIDGE_IN_RGXRENDERCONTEXTSTALLED *)
-	    IMG_OFFSET_ADDR(psRGXRenderContextStalledIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXRENDERCONTEXTSTALLED *psRGXRenderContextStalledOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXRENDERCONTEXTSTALLED *)
-	    IMG_OFFSET_ADDR(psRGXRenderContextStalledOUT_UI8, 0);
+	/* Copy the data over */
+	if (psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, hSyncPMRsInt2, (const void __user *)psRGXKickTA3D2IN->phSyncPMRs,
+		     psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		{
+			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	IMG_HANDLE hRenderContext = psRGXRenderContextStalledIN->hRenderContext;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+			goto RGXKickTA3D2_exit;
+		}
+	}
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXRenderContextStalledOUT->eError =
+	psRGXKickTA3D2OUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
 				       (void **)&psRenderContextInt,
 				       hRenderContext,
 				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXRenderContextStalledOUT->eError != PVRSRV_OK))
+	if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXRenderContextStalled_exit;
+		goto RGXKickTA3D2_exit;
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXRenderContextStalledOUT->eError = RGXRenderContextStalledKM(psRenderContextInt);
+	{
+		IMG_UINT32 i;
 
-RGXRenderContextStalled_exit:
-
-	/* Lock over handle lookup cleanup. */
-	LockHandle(psConnection->psHandleBase);
-
-	/* Unreference the previously looked up handle */
-	if (psRenderContextInt)
-	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hRenderContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAFenceCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXKickTA3D2OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)&psClientTAFenceSyncPrimBlockInt[i],
+						       hClientTAFenceSyncPrimBlockInt2[i],
+						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
+						       IMG_TRUE);
+			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXKickTA3D2_exit;
+			}
+		}
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	return 0;
-}
-
-static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
-	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
-static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
-	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
-static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
-	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
-static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
-	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
-static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
-	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
-static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
-static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
-static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
-	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
-static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
-	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
-
-static IMG_INT
-PVRSRVBridgeRGXKickTA3D2(IMG_UINT32 ui32DispatchTableEntry,
-			 IMG_UINT8 * psRGXKickTA3D2IN_UI8,
-			 IMG_UINT8 * psRGXKickTA3D2OUT_UI8, CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXKICKTA3D2 *psRGXKickTA3D2IN =
-	    (PVRSRV_BRIDGE_IN_RGXKICKTA3D2 *) IMG_OFFSET_ADDR(psRGXKickTA3D2IN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXKICKTA3D2 *psRGXKickTA3D2OUT =
-	    (PVRSRV_BRIDGE_OUT_RGXKICKTA3D2 *) IMG_OFFSET_ADDR(psRGXKickTA3D2OUT_UI8, 0);
+	{
+		IMG_UINT32 i;
 
-	IMG_HANDLE hRenderContext = psRGXKickTA3D2IN->hRenderContext;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
-	SYNC_PRIMITIVE_BLOCK **psClientTAFenceSyncPrimBlockInt = NULL;
-	IMG_HANDLE *hClientTAFenceSyncPrimBlockInt2 = NULL;
-	IMG_UINT32 *ui32ClientTAFenceSyncOffsetInt = NULL;
-	IMG_UINT32 *ui32ClientTAFenceValueInt = NULL;
-	SYNC_PRIMITIVE_BLOCK **psClientTAUpdateSyncPrimBlockInt = NULL;
-	IMG_HANDLE *hClientTAUpdateSyncPrimBlockInt2 = NULL;
-	IMG_UINT32 *ui32ClientTAUpdateSyncOffsetInt = NULL;
-	IMG_UINT32 *ui32ClientTAUpdateValueInt = NULL;
-	SYNC_PRIMITIVE_BLOCK **psClient3DUpdateSyncPrimBlockInt = NULL;
-	IMG_HANDLE *hClient3DUpdateSyncPrimBlockInt2 = NULL;
-	IMG_UINT32 *ui32Client3DUpdateSyncOffsetInt = NULL;
-	IMG_UINT32 *ui32Client3DUpdateValueInt = NULL;
-	IMG_HANDLE hPRFenceUFOSyncPrimBlock = psRGXKickTA3D2IN->hPRFenceUFOSyncPrimBlock;
-	SYNC_PRIMITIVE_BLOCK *psPRFenceUFOSyncPrimBlockInt = NULL;
-	IMG_CHAR *uiUpdateFenceNameInt = NULL;
-	IMG_CHAR *uiUpdateFenceName3DInt = NULL;
-	IMG_BYTE *ui8TACmdInt = NULL;
-	IMG_BYTE *ui83DPRCmdInt = NULL;
-	IMG_BYTE *ui83DCmdInt = NULL;
-	IMG_HANDLE hKMHWRTDataSet = psRGXKickTA3D2IN->hKMHWRTDataSet;
-	RGX_KM_HW_RT_DATASET *psKMHWRTDataSetInt = NULL;
-	IMG_HANDLE hZSBuffer = psRGXKickTA3D2IN->hZSBuffer;
-	RGX_ZSBUFFER_DATA *psZSBufferInt = NULL;
-	IMG_HANDLE hMSAAScratchBuffer = psRGXKickTA3D2IN->hMSAAScratchBuffer;
-	RGX_ZSBUFFER_DATA *psMSAAScratchBufferInt = NULL;
-	IMG_UINT32 *ui32SyncPMRFlagsInt = NULL;
-	PMR **psSyncPMRsInt = NULL;
-	IMG_HANDLE *hSyncPMRsInt2 = NULL;
+		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAUpdateCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXKickTA3D2OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)
+						       &psClientTAUpdateSyncPrimBlockInt[i],
+						       hClientTAUpdateSyncPrimBlockInt2[i],
+						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
+						       IMG_TRUE);
+			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXKickTA3D2_exit;
+			}
+		}
+	}
 
-	IMG_UINT32 ui32NextOffset = 0;
-	IMG_BYTE *pArrayArgsBuffer = NULL;
-	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
+	{
+		IMG_UINT32 i;
 
-	IMG_UINT32 ui32BufferSize = 0;
-	IMG_UINT64 ui64BufferSize =
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount *
-	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount *
-	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount *
-	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
-	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *)) +
-	    ((IMG_UINT64) psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
+		for (i = 0; i < psRGXKickTA3D2IN->ui32Client3DUpdateCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXKickTA3D2OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)
+						       &psClient3DUpdateSyncPrimBlockInt[i],
+						       hClient3DUpdateSyncPrimBlockInt2[i],
+						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
+						       IMG_TRUE);
+			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXKickTA3D2_exit;
+			}
+		}
+	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui32ClientTAFenceCount > PVRSRV_MAX_SYNCS))
+	/* Look up the address from the handle */
+	psRGXKickTA3D2OUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psPRFenceUFOSyncPrimBlockInt,
+				       hPRFenceUFOSyncPrimBlock,
+				       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK, IMG_TRUE);
+	if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		UnlockHandle(psConnection->psHandleBase);
 		goto RGXKickTA3D2_exit;
 	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui32ClientTAUpdateCount > PVRSRV_MAX_SYNCS))
+	if (psRGXKickTA3D2IN->hKMHWRTDataSet)
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
+		/* Look up the address from the handle */
+		psRGXKickTA3D2OUT->eError =
+		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+					       (void **)&psKMHWRTDataSetInt,
+					       hKMHWRTDataSet,
+					       PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET, IMG_TRUE);
+		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+		{
+			UnlockHandle(psConnection->psHandleBase);
+			goto RGXKickTA3D2_exit;
+		}
 	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui32Client3DUpdateCount > PVRSRV_MAX_SYNCS))
+	if (psRGXKickTA3D2IN->hZSBuffer)
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
+		/* Look up the address from the handle */
+		psRGXKickTA3D2OUT->eError =
+		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+					       (void **)&psZSBufferInt,
+					       hZSBuffer,
+					       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
+		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+		{
+			UnlockHandle(psConnection->psHandleBase);
+			goto RGXKickTA3D2_exit;
+		}
 	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui32TACmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
+	if (psRGXKickTA3D2IN->hMSAAScratchBuffer)
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
+		/* Look up the address from the handle */
+		psRGXKickTA3D2OUT->eError =
+		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+					       (void **)&psMSAAScratchBufferInt,
+					       hMSAAScratchBuffer,
+					       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
+		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+		{
+			UnlockHandle(psConnection->psHandleBase);
+			goto RGXKickTA3D2_exit;
+		}
 	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui323DPRCmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXKickTA3D2IN->ui32SyncPMRCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXKickTA3D2OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)&psSyncPMRsInt[i],
+						       hSyncPMRsInt2[i],
+						       PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXKickTA3D2_exit;
+			}
+		}
 	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXKickTA3D2OUT->eError =
+	    PVRSRVRGXKickTA3DKM(psRenderContextInt,
+				psRGXKickTA3D2IN->ui32ClientTAFenceCount,
+				psClientTAFenceSyncPrimBlockInt,
+				ui32ClientTAFenceSyncOffsetInt,
+				ui32ClientTAFenceValueInt,
+				psRGXKickTA3D2IN->ui32ClientTAUpdateCount,
+				psClientTAUpdateSyncPrimBlockInt,
+				ui32ClientTAUpdateSyncOffsetInt,
+				ui32ClientTAUpdateValueInt,
+				psRGXKickTA3D2IN->ui32Client3DUpdateCount,
+				psClient3DUpdateSyncPrimBlockInt,
+				ui32Client3DUpdateSyncOffsetInt,
+				ui32Client3DUpdateValueInt,
+				psPRFenceUFOSyncPrimBlockInt,
+				psRGXKickTA3D2IN->ui32PRFenceUFOSyncOffset,
+				psRGXKickTA3D2IN->ui32PRFenceValue,
+				psRGXKickTA3D2IN->hCheckFence,
+				psRGXKickTA3D2IN->hUpdateTimeline,
+				&psRGXKickTA3D2OUT->hUpdateFence,
+				uiUpdateFenceNameInt,
+				psRGXKickTA3D2IN->hCheckFence3D,
+				psRGXKickTA3D2IN->hUpdateTimeline3D,
+				&psRGXKickTA3D2OUT->hUpdateFence3D,
+				uiUpdateFenceName3DInt,
+				psRGXKickTA3D2IN->ui32TACmdSize,
+				ui8TACmdInt,
+				psRGXKickTA3D2IN->ui323DPRCmdSize,
+				ui83DPRCmdInt,
+				psRGXKickTA3D2IN->ui323DCmdSize,
+				ui83DCmdInt,
+				psRGXKickTA3D2IN->ui32ExtJobRef,
+				psRGXKickTA3D2IN->bbKickTA,
+				psRGXKickTA3D2IN->bbKickPR,
+				psRGXKickTA3D2IN->bbKick3D,
+				psRGXKickTA3D2IN->bbAbort,
+				psRGXKickTA3D2IN->ui32PDumpFlags,
+				psKMHWRTDataSetInt,
+				psZSBufferInt,
+				psMSAAScratchBufferInt,
+				psRGXKickTA3D2IN->ui32SyncPMRCount,
+				ui32SyncPMRFlagsInt,
+				psSyncPMRsInt,
+				psRGXKickTA3D2IN->ui32RenderTargetSize,
+				psRGXKickTA3D2IN->ui32NumberOfDrawCalls,
+				psRGXKickTA3D2IN->ui32NumberOfIndices,
+				psRGXKickTA3D2IN->ui32NumberOfMRTs, psRGXKickTA3D2IN->ui64Deadline);
+
+RGXKickTA3D2_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
 
-	if (unlikely(psRGXKickTA3D2IN->ui323DCmdSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
+	/* Unreference the previously looked up handle */
+	if (psRenderContextInt)
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hRenderContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
 	}
 
-	if (unlikely(psRGXKickTA3D2IN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
+	if (hClientTAFenceSyncPrimBlockInt2)
 	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
-		goto RGXKickTA3D2_exit;
-	}
+		IMG_UINT32 i;
 
-	if (ui64BufferSize > IMG_UINT32_MAX)
-	{
-		psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
-		goto RGXKickTA3D2_exit;
-	}
+		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAFenceCount; i++)
+		{
 
-	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
+			/* Unreference the previously looked up handle */
+			if (psClientTAFenceSyncPrimBlockInt && psClientTAFenceSyncPrimBlockInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hClientTAFenceSyncPrimBlockInt2[i],
+							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+			}
+		}
+	}
 
-	if (ui32BufferSize != 0)
+	if (hClientTAUpdateSyncPrimBlockInt2)
 	{
-		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
-		IMG_UINT32 ui32InBufferOffset =
-		    PVR_ALIGN(sizeof(*psRGXKickTA3D2IN), sizeof(unsigned long));
-		IMG_UINT32 ui32InBufferExcessSize =
-		    ui32InBufferOffset >=
-		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
+		IMG_UINT32 i;
 
-		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
-		if (bHaveEnoughSpace)
+		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAUpdateCount; i++)
 		{
-			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXKickTA3D2IN;
 
-			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
+			/* Unreference the previously looked up handle */
+			if (psClientTAUpdateSyncPrimBlockInt && psClientTAUpdateSyncPrimBlockInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hClientTAUpdateSyncPrimBlockInt2[i],
+							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+			}
 		}
-		else
+	}
+
+	if (hClient3DUpdateSyncPrimBlockInt2)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXKickTA3D2IN->ui32Client3DUpdateCount; i++)
 		{
-			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
 
-			if (!pArrayArgsBuffer)
+			/* Unreference the previously looked up handle */
+			if (psClient3DUpdateSyncPrimBlockInt && psClient3DUpdateSyncPrimBlockInt[i])
 			{
-				psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-				goto RGXKickTA3D2_exit;
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hClient3DUpdateSyncPrimBlockInt2[i],
+							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
 			}
 		}
 	}
 
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
+	/* Unreference the previously looked up handle */
+	if (psPRFenceUFOSyncPrimBlockInt)
 	{
-		psClientTAFenceSyncPrimBlockInt =
-		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psClientTAFenceSyncPrimBlockInt, 0,
-			       psRGXKickTA3D2IN->ui32ClientTAFenceCount *
-			       sizeof(SYNC_PRIMITIVE_BLOCK *));
-		ui32NextOffset +=
-		    psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
-		hClientTAFenceSyncPrimBlockInt2 =
-		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE);
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hPRFenceUFOSyncPrimBlock,
+					    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
 	}
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE) > 0)
+	if (psRGXKickTA3D2IN->hKMHWRTDataSet)
 	{
-		if (OSCopyFromUser
-		    (NULL, hClientTAFenceSyncPrimBlockInt2,
-		     (const void __user *)psRGXKickTA3D2IN->phClientTAFenceSyncPrimBlock,
-		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+		/* Unreference the previously looked up handle */
+		if (psKMHWRTDataSetInt)
+		{
+			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+						    hKMHWRTDataSet,
+						    PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET);
 		}
 	}
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
-	{
-		ui32ClientTAFenceSyncOffsetInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32);
-	}
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32) > 0)
+	if (psRGXKickTA3D2IN->hZSBuffer)
 	{
-		if (OSCopyFromUser
-		    (NULL, ui32ClientTAFenceSyncOffsetInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAFenceSyncOffset,
-		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+		/* Unreference the previously looked up handle */
+		if (psZSBufferInt)
+		{
+			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+						    hZSBuffer,
+						    PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
 		}
 	}
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount != 0)
+
+	if (psRGXKickTA3D2IN->hMSAAScratchBuffer)
 	{
-		ui32ClientTAFenceValueInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32);
+
+		/* Unreference the previously looked up handle */
+		if (psMSAAScratchBufferInt)
+		{
+			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+						    hMSAAScratchBuffer,
+						    PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
+		}
 	}
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32) > 0)
+	if (hSyncPMRsInt2)
 	{
-		if (OSCopyFromUser
-		    (NULL, ui32ClientTAFenceValueInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAFenceValue,
-		     psRGXKickTA3D2IN->ui32ClientTAFenceCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXKickTA3D2IN->ui32SyncPMRCount; i++)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			/* Unreference the previously looked up handle */
+			if (psSyncPMRsInt && psSyncPMRsInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hSyncPMRsInt2[i],
+							    PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+			}
 		}
 	}
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXKickTA3D2OUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
+	return 0;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXSetRenderContextProperty(IMG_UINT32 ui32DispatchTableEntry,
+					IMG_UINT8 * psRGXSetRenderContextPropertyIN_UI8,
+					IMG_UINT8 * psRGXSetRenderContextPropertyOUT_UI8,
+					CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPROPERTY *psRGXSetRenderContextPropertyIN =
+	    (PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPROPERTY *)
+	    IMG_OFFSET_ADDR(psRGXSetRenderContextPropertyIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY *psRGXSetRenderContextPropertyOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY *)
+	    IMG_OFFSET_ADDR(psRGXSetRenderContextPropertyOUT_UI8, 0);
+
+	IMG_HANDLE hRenderContext = psRGXSetRenderContextPropertyIN->hRenderContext;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXSetRenderContextPropertyOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psRenderContextInt,
+				       hRenderContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSetRenderContextPropertyOUT->eError != PVRSRV_OK))
 	{
-		psClientTAUpdateSyncPrimBlockInt =
-		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psClientTAUpdateSyncPrimBlockInt, 0,
-			       psRGXKickTA3D2IN->ui32ClientTAUpdateCount *
-			       sizeof(SYNC_PRIMITIVE_BLOCK *));
-		ui32NextOffset +=
-		    psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
-		hClientTAUpdateSyncPrimBlockInt2 =
-		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE);
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXSetRenderContextProperty_exit;
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXSetRenderContextPropertyOUT->eError =
+	    PVRSRVRGXSetRenderContextPropertyKM(psRenderContextInt,
+						psRGXSetRenderContextPropertyIN->ui32Property,
+						psRGXSetRenderContextPropertyIN->ui64Input,
+						&psRGXSetRenderContextPropertyOUT->ui64Output);
+
+RGXSetRenderContextProperty_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psRenderContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hRenderContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
 	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	return 0;
+}
+
+static PVRSRV_ERROR _RGXCreateHWRTDataSetpsKmHwRTDataSetIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = RGXDestroyHWRTDataSet((RGX_KM_HW_RT_DATASET *) pvData);
+	return eError;
+}
+
+static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_RTDATA_FREELISTS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_RTDATA_FREELISTS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_GEOMDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_GEOMDATAS must not be larger than IMG_UINT32_MAX");
+static_assert(RGXMKIF_NUM_RTDATAS <= IMG_UINT32_MAX,
+	      "RGXMKIF_NUM_RTDATAS must not be larger than IMG_UINT32_MAX");
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, hClientTAUpdateSyncPrimBlockInt2,
-		     (const void __user *)psRGXKickTA3D2IN->phClientTAUpdateSyncPrimBlock,
-		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+static IMG_INT
+PVRSRVBridgeRGXCreateHWRTDataSet(IMG_UINT32 ui32DispatchTableEntry,
+				 IMG_UINT8 * psRGXCreateHWRTDataSetIN_UI8,
+				 IMG_UINT8 * psRGXCreateHWRTDataSetOUT_UI8,
+				 CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET *psRGXCreateHWRTDataSetIN =
+	    (PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET *) IMG_OFFSET_ADDR(psRGXCreateHWRTDataSetIN_UI8,
+								      0);
+	PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET *psRGXCreateHWRTDataSetOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET *)
+	    IMG_OFFSET_ADDR(psRGXCreateHWRTDataSetOUT_UI8, 0);
 
-			goto RGXKickTA3D2_exit;
-		}
-	}
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
-	{
-		ui32ClientTAUpdateSyncOffsetInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32);
-	}
+	IMG_DEV_VIRTADDR *sVHeapTableDevVAddrInt = NULL;
+	IMG_DEV_VIRTADDR *sPMMlistDevVAddrInt = NULL;
+	RGX_FREELIST **psapsFreeListsInt = NULL;
+	IMG_HANDLE *hapsFreeListsInt2 = NULL;
+	IMG_DEV_VIRTADDR *sTailPtrsDevVAddrInt = NULL;
+	IMG_DEV_VIRTADDR *sMacrotileArrayDevVAddrInt = NULL;
+	IMG_DEV_VIRTADDR *sRgnHeaderDevVAddrInt = NULL;
+	IMG_DEV_VIRTADDR *sRTCDevVAddrInt = NULL;
+	RGX_KM_HW_RT_DATASET **psKmHwRTDataSetInt = NULL;
+	IMG_HANDLE *hKmHwRTDataSetInt2 = NULL;
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, ui32ClientTAUpdateSyncOffsetInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAUpdateSyncOffset,
-		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
-			goto RGXKickTA3D2_exit;
-		}
-	}
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount != 0)
-	{
-		ui32ClientTAUpdateValueInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32);
-	}
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *)) +
+	    ((IMG_UINT64) RGXMKIF_NUM_RTDATAS * sizeof(IMG_HANDLE)) + 0;
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, ui32ClientTAUpdateValueInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32ClientTAUpdateValue,
-		     psRGXKickTA3D2IN->ui32ClientTAUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+	psRGXCreateHWRTDataSetOUT->phKmHwRTDataSet = psRGXCreateHWRTDataSetIN->phKmHwRTDataSet;
 
-			goto RGXKickTA3D2_exit;
-		}
-	}
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
+	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		psClient3DUpdateSyncPrimBlockInt =
-		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psClient3DUpdateSyncPrimBlockInt, 0,
-			       psRGXKickTA3D2IN->ui32Client3DUpdateCount *
-			       sizeof(SYNC_PRIMITIVE_BLOCK *));
-		ui32NextOffset +=
-		    psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(SYNC_PRIMITIVE_BLOCK *);
-		hClient3DUpdateSyncPrimBlockInt2 =
-		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE);
+		psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXCreateHWRTDataSet_exit;
 	}
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, hClient3DUpdateSyncPrimBlockInt2,
-		     (const void __user *)psRGXKickTA3D2IN->phClient3DUpdateSyncPrimBlock,
-		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
-		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
 
-			goto RGXKickTA3D2_exit;
-		}
-	}
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
+	if (ui32BufferSize != 0)
 	{
-		ui32Client3DUpdateSyncOffsetInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32);
-	}
+		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
+		IMG_UINT32 ui32InBufferOffset =
+		    PVR_ALIGN(sizeof(*psRGXCreateHWRTDataSetIN), sizeof(unsigned long));
+		IMG_UINT32 ui32InBufferExcessSize =
+		    ui32InBufferOffset >=
+		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
 
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, ui32Client3DUpdateSyncOffsetInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32Client3DUpdateSyncOffset,
-		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
+		if (bHaveEnoughSpace)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXCreateHWRTDataSetIN;
 
-			goto RGXKickTA3D2_exit;
+			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
 		}
-	}
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount != 0)
-	{
-		ui32Client3DUpdateValueInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32);
-	}
-
-	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32) > 0)
-	{
-		if (OSCopyFromUser
-		    (NULL, ui32Client3DUpdateValueInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32Client3DUpdateValue,
-		     psRGXKickTA3D2IN->ui32Client3DUpdateCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		else
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
 
-			goto RGXKickTA3D2_exit;
+			if (!pArrayArgsBuffer)
+			{
+				psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXCreateHWRTDataSet_exit;
+			}
 		}
 	}
 
 	{
-		uiUpdateFenceNameInt =
-		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+		sVHeapTableDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, uiUpdateFenceNameInt,
-		     (const void __user *)psRGXKickTA3D2IN->puiUpdateFenceName,
-		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		    (NULL, sVHeapTableDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psVHeapTableDevVAddr,
+		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
-		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
-						    1] = '\0';
 	}
 
 	{
-		uiUpdateFenceName3DInt =
-		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+		sPMMlistDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, uiUpdateFenceName3DInt,
-		     (const void __user *)psRGXKickTA3D2IN->puiUpdateFenceName3D,
-		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		    (NULL, sPMMlistDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psPMMlistDevVAddr,
+		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
-		((IMG_CHAR *) uiUpdateFenceName3DInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
-						      1] = '\0';
 	}
-	if (psRGXKickTA3D2IN->ui32TACmdSize != 0)
+
 	{
-		ui8TACmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE);
+		psapsFreeListsInt =
+		    (RGX_FREELIST **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psapsFreeListsInt, 0,
+			       RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *));
+		ui32NextOffset += RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(RGX_FREELIST *);
+		hapsFreeListsInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE) > 0)
+	if (RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui8TACmdInt, (const void __user *)psRGXKickTA3D2IN->pui8TACmd,
-		     psRGXKickTA3D2IN->ui32TACmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		    (NULL, hapsFreeListsInt2,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->phapsFreeLists,
+		     RGXMKIF_NUM_RTDATA_FREELISTS * sizeof(IMG_HANDLE)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
-	if (psRGXKickTA3D2IN->ui323DPRCmdSize != 0)
+
 	{
-		ui83DPRCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE);
+		sTailPtrsDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE) > 0)
+	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui83DPRCmdInt, (const void __user *)psRGXKickTA3D2IN->pui83DPRCmd,
-		     psRGXKickTA3D2IN->ui323DPRCmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		    (NULL, sTailPtrsDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psTailPtrsDevVAddr,
+		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
-	if (psRGXKickTA3D2IN->ui323DCmdSize != 0)
+
 	{
-		ui83DCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE);
+		sMacrotileArrayDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE) > 0)
+	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui83DCmdInt, (const void __user *)psRGXKickTA3D2IN->pui83DCmd,
-		     psRGXKickTA3D2IN->ui323DCmdSize * sizeof(IMG_BYTE)) != PVRSRV_OK)
+		    (NULL, sMacrotileArrayDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psMacrotileArrayDevVAddr,
+		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
-	if (psRGXKickTA3D2IN->ui32SyncPMRCount != 0)
+
 	{
-		ui32SyncPMRFlagsInt =
-		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32);
+		sRgnHeaderDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
+	if (RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, ui32SyncPMRFlagsInt,
-		     (const void __user *)psRGXKickTA3D2IN->pui32SyncPMRFlags,
-		     psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		    (NULL, sRgnHeaderDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psRgnHeaderDevVAddr,
+		     RGXMKIF_NUM_RTDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
-	if (psRGXKickTA3D2IN->ui32SyncPMRCount != 0)
+
 	{
-		psSyncPMRsInt = (PMR **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		OSCachedMemSet(psSyncPMRsInt, 0,
-			       psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *));
-		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(PMR *);
-		hSyncPMRsInt2 = (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
-		ui32NextOffset += psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
+		sRTCDevVAddrInt =
+		    (IMG_DEV_VIRTADDR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR);
 	}
 
 	/* Copy the data over */
-	if (psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
+	if (RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR) > 0)
 	{
 		if (OSCopyFromUser
-		    (NULL, hSyncPMRsInt2, (const void __user *)psRGXKickTA3D2IN->phSyncPMRs,
-		     psRGXKickTA3D2IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		    (NULL, sRTCDevVAddrInt,
+		     (const void __user *)psRGXCreateHWRTDataSetIN->psRTCDevVAddr,
+		     RGXMKIF_NUM_GEOMDATAS * sizeof(IMG_DEV_VIRTADDR)) != PVRSRV_OK)
 		{
-			psRGXKickTA3D2OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
+	if (IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset) != NULL)
+	{
+		psKmHwRTDataSetInt =
+		    (RGX_KM_HW_RT_DATASET **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psKmHwRTDataSetInt, 0,
+			       RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *));
+		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *);
+		hKmHwRTDataSetInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += RGXMKIF_NUM_RTDATAS * sizeof(IMG_HANDLE);
+	}
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
-	/* Look up the address from the handle */
-	psRGXKickTA3D2OUT->eError =
-	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psRenderContextInt,
-				       hRenderContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXKickTA3D2_exit;
-	}
-
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAFenceCount; i++)
+		for (i = 0; i < RGXMKIF_NUM_RTDATA_FREELISTS; i++)
 		{
 			/* Look up the address from the handle */
-			psRGXKickTA3D2OUT->eError =
+			psRGXCreateHWRTDataSetOUT->eError =
 			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-						       (void **)&psClientTAFenceSyncPrimBlockInt[i],
-						       hClientTAFenceSyncPrimBlockInt2[i],
-						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
-						       IMG_TRUE);
-			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+						       (void **)&psapsFreeListsInt[i],
+						       hapsFreeListsInt2[i],
+						       PVRSRV_HANDLE_TYPE_RGX_FREELIST, IMG_TRUE);
+			if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
 			{
 				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickTA3D2_exit;
+				goto RGXCreateHWRTDataSet_exit;
 			}
 		}
 	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXCreateHWRTDataSetOUT->eError =
+	    RGXCreateHWRTDataSet(psConnection, OSGetDevNode(psConnection),
+				 sVHeapTableDevVAddrInt,
+				 sPMMlistDevVAddrInt,
+				 psapsFreeListsInt,
+				 psRGXCreateHWRTDataSetIN->ui32PPPScreen,
+				 psRGXCreateHWRTDataSetIN->ui64MultiSampleCtl,
+				 psRGXCreateHWRTDataSetIN->ui64FlippedMultiSampleCtl,
+				 psRGXCreateHWRTDataSetIN->ui32TPCStride,
+				 sTailPtrsDevVAddrInt,
+				 psRGXCreateHWRTDataSetIN->ui32TPCSize,
+				 psRGXCreateHWRTDataSetIN->ui32TEScreen,
+				 psRGXCreateHWRTDataSetIN->ui32TEAA,
+				 psRGXCreateHWRTDataSetIN->ui32TEMTILE1,
+				 psRGXCreateHWRTDataSetIN->ui32TEMTILE2,
+				 psRGXCreateHWRTDataSetIN->ui32MTileStride,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeLowerX,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeLowerY,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeUpperX,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeUpperY,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeScaleX,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMergeScaleY,
+				 sMacrotileArrayDevVAddrInt,
+				 sRgnHeaderDevVAddrInt,
+				 sRTCDevVAddrInt,
+				 psRGXCreateHWRTDataSetIN->ui32RgnHeaderSize,
+				 psRGXCreateHWRTDataSetIN->ui32ISPMtileSize,
+				 psRGXCreateHWRTDataSetIN->ui16MaxRTs, psKmHwRTDataSetInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
+	{
+		goto RGXCreateHWRTDataSet_exit;
+	}
 
+	/* Lock over handle creation. */
+	LockHandle(psConnection->psHandleBase);
+	if (hKmHwRTDataSetInt2)
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAUpdateCount; i++)
+		for (i = 0; i < RGXMKIF_NUM_RTDATAS; i++)
 		{
-			/* Look up the address from the handle */
-			psRGXKickTA3D2OUT->eError =
-			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-						       (void **)
-						       &psClientTAUpdateSyncPrimBlockInt[i],
-						       hClientTAUpdateSyncPrimBlockInt2[i],
-						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
-						       IMG_TRUE);
-			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+
+			psRGXCreateHWRTDataSetOUT->eError =
+			    PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+						      &hKmHwRTDataSetInt2[i],
+						      (void *)psKmHwRTDataSetInt[i],
+						      PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET,
+						      PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+						      (PFN_HANDLE_RELEASE) &
+						      _RGXCreateHWRTDataSetpsKmHwRTDataSetIntRelease);
+			if (unlikely(psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK))
 			{
+				IMG_UINT32 j;
+				/* Ensure the remaining handles are set to NULL. hKmHwRTDataSetInt2[i] was
+				 * zeroed when calling PVRSRVAllocHandleUnlocked, so we start at the next
+				 * element. If it was the last iteration, the loop doesn't run.
+				 */
+				for (j = i + 1; j < RGXMKIF_NUM_RTDATAS; j++)
+				{
+					hKmHwRTDataSetInt2[j] = NULL;
+				}
 				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickTA3D2_exit;
+				goto RGXCreateHWRTDataSet_exit;
 			}
+
+		}
+	}
+	/* Release now we have created handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	/* If dest ptr is non-null and we have data to copy */
+	if ((hKmHwRTDataSetInt2) && ((RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *)) > 0))
+	{
+		if (unlikely
+		    (OSCopyToUser
+		     (NULL, (void __user *)psRGXCreateHWRTDataSetOUT->phKmHwRTDataSet,
+		      hKmHwRTDataSetInt2,
+		      (RGXMKIF_NUM_RTDATAS * sizeof(RGX_KM_HW_RT_DATASET *))) != PVRSRV_OK))
+		{
+			psRGXCreateHWRTDataSetOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXCreateHWRTDataSet_exit;
 		}
 	}
 
+RGXCreateHWRTDataSet_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	if (hapsFreeListsInt2)
 	{
 		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32Client3DUpdateCount; i++)
+		for (i = 0; i < RGXMKIF_NUM_RTDATA_FREELISTS; i++)
 		{
-			/* Look up the address from the handle */
-			psRGXKickTA3D2OUT->eError =
-			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-						       (void **)
-						       &psClient3DUpdateSyncPrimBlockInt[i],
-						       hClient3DUpdateSyncPrimBlockInt2[i],
-						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
-						       IMG_TRUE);
-			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+
+			/* Unreference the previously looked up handle */
+			if (psapsFreeListsInt && psapsFreeListsInt[i])
 			{
-				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickTA3D2_exit;
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hapsFreeListsInt2[i],
+							    PVRSRV_HANDLE_TYPE_RGX_FREELIST);
+			}
+		}
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	if (psRGXCreateHWRTDataSetOUT->eError != PVRSRV_OK)
+	{
+		if (hKmHwRTDataSetInt2)
+		{
+			PVRSRV_ERROR eError;
+
+			/* Lock over handle creation cleanup. */
+			LockHandle(psConnection->psHandleBase);
+
+			{
+				IMG_UINT32 idx;
+				for (idx = 0; idx < RGXMKIF_NUM_RTDATAS; idx++)
+				{
+					if (hKmHwRTDataSetInt2[idx])
+					{
+
+						eError =
+						    PVRSRVDestroyHandleUnlocked(psConnection->
+										psHandleBase,
+										hKmHwRTDataSetInt2
+										[idx],
+										PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET);
+						if (unlikely
+						    ((eError != PVRSRV_OK)
+						     && (eError != PVRSRV_ERROR_RETRY)))
+						{
+							PVR_DPF((PVR_DBG_ERROR,
+								 "%s: %s",
+								 __func__,
+								 PVRSRVGetErrorString(eError)));
+						}
+						/* Releasing the handle should free/destroy/release the resource.
+						 * This should never fail... */
+						PVR_ASSERT((eError == PVRSRV_OK)
+							   || (eError == PVRSRV_ERROR_RETRY));
+
+					}
+					else if (psKmHwRTDataSetInt[idx])
+					{
+						/* Free/Destroy/Release the resource */
+						RGXDestroyHWRTDataSet(psKmHwRTDataSetInt[idx]);
+					}
+				}
+			}
+
+			/* Release now we have cleaned up creation handles. */
+			UnlockHandle(psConnection->psHandleBase);
+
+		}
+
+		else if (psKmHwRTDataSetInt)
+		{
+			IMG_UINT32 i;
+			for (i = 0; i < RGXMKIF_NUM_RTDATAS; i++)
+			{
+				if (psKmHwRTDataSetInt[i])
+				{
+					RGXDestroyHWRTDataSet(psKmHwRTDataSetInt[i]);
+				}
 			}
 		}
+
 	}
 
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXCreateHWRTDataSetOUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
+	return 0;
+}
+
+static PVRSRV_ERROR _RGXCreateFreeListpsCleanupCookieIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = RGXDestroyFreeList((RGX_FREELIST *) pvData);
+	return eError;
+}
+
+static IMG_INT
+PVRSRVBridgeRGXCreateFreeList(IMG_UINT32 ui32DispatchTableEntry,
+			      IMG_UINT8 * psRGXCreateFreeListIN_UI8,
+			      IMG_UINT8 * psRGXCreateFreeListOUT_UI8,
+			      CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCREATEFREELIST *psRGXCreateFreeListIN =
+	    (PVRSRV_BRIDGE_IN_RGXCREATEFREELIST *) IMG_OFFSET_ADDR(psRGXCreateFreeListIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST *psRGXCreateFreeListOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST *) IMG_OFFSET_ADDR(psRGXCreateFreeListOUT_UI8, 0);
+
+	IMG_HANDLE hMemCtxPrivData = psRGXCreateFreeListIN->hMemCtxPrivData;
+	IMG_HANDLE hMemCtxPrivDataInt = NULL;
+	IMG_HANDLE hsGlobalFreeList = psRGXCreateFreeListIN->hsGlobalFreeList;
+	RGX_FREELIST *pssGlobalFreeListInt = NULL;
+	IMG_HANDLE hFreeListReservation = psRGXCreateFreeListIN->hFreeListReservation;
+	DEVMEMINT_RESERVATION *psFreeListReservationInt = NULL;
+	RGX_FREELIST *psCleanupCookieInt = NULL;
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
 	/* Look up the address from the handle */
-	psRGXKickTA3D2OUT->eError =
+	psRGXCreateFreeListOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psPRFenceUFOSyncPrimBlockInt,
-				       hPRFenceUFOSyncPrimBlock,
-				       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK, IMG_TRUE);
-	if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+				       (void **)&hMemCtxPrivDataInt,
+				       hMemCtxPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA, IMG_TRUE);
+	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXKickTA3D2_exit;
+		goto RGXCreateFreeList_exit;
 	}
 
-	if (psRGXKickTA3D2IN->hKMHWRTDataSet)
+	if (psRGXCreateFreeListIN->hsGlobalFreeList)
 	{
 		/* Look up the address from the handle */
-		psRGXKickTA3D2OUT->eError =
+		psRGXCreateFreeListOUT->eError =
 		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-					       (void **)&psKMHWRTDataSetInt,
-					       hKMHWRTDataSet,
-					       PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET, IMG_TRUE);
-		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
+					       (void **)&pssGlobalFreeListInt,
+					       hsGlobalFreeList,
+					       PVRSRV_HANDLE_TYPE_RGX_FREELIST, IMG_TRUE);
+		if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
 		{
 			UnlockHandle(psConnection->psHandleBase);
-			goto RGXKickTA3D2_exit;
+			goto RGXCreateFreeList_exit;
 		}
 	}
 
-	if (psRGXKickTA3D2IN->hZSBuffer)
+	/* Look up the address from the handle */
+	psRGXCreateFreeListOUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psFreeListReservationInt,
+				       hFreeListReservation,
+				       PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION, IMG_TRUE);
+	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
 	{
-		/* Look up the address from the handle */
-		psRGXKickTA3D2OUT->eError =
-		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-					       (void **)&psZSBufferInt,
-					       hZSBuffer,
-					       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
-		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
-		{
-			UnlockHandle(psConnection->psHandleBase);
-			goto RGXKickTA3D2_exit;
-		}
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateFreeList_exit;
 	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-	if (psRGXKickTA3D2IN->hMSAAScratchBuffer)
+	psRGXCreateFreeListOUT->eError =
+	    RGXCreateFreeList(psConnection, OSGetDevNode(psConnection),
+			      hMemCtxPrivDataInt,
+			      psRGXCreateFreeListIN->ui32MaxFLPages,
+			      psRGXCreateFreeListIN->ui32InitFLPages,
+			      psRGXCreateFreeListIN->ui32GrowFLPages,
+			      psRGXCreateFreeListIN->ui32GrowParamThreshold,
+			      pssGlobalFreeListInt,
+			      psRGXCreateFreeListIN->bbFreeListCheck,
+			      psFreeListReservationInt, &psCleanupCookieInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
 	{
-		/* Look up the address from the handle */
-		psRGXKickTA3D2OUT->eError =
-		    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-					       (void **)&psMSAAScratchBufferInt,
-					       hMSAAScratchBuffer,
-					       PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER, IMG_TRUE);
-		if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
-		{
-			UnlockHandle(psConnection->psHandleBase);
-			goto RGXKickTA3D2_exit;
-		}
+		goto RGXCreateFreeList_exit;
 	}
 
-	{
-		IMG_UINT32 i;
+	/* Lock over handle creation. */
+	LockHandle(psConnection->psHandleBase);
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32SyncPMRCount; i++)
-		{
-			/* Look up the address from the handle */
-			psRGXKickTA3D2OUT->eError =
-			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-						       (void **)&psSyncPMRsInt[i],
-						       hSyncPMRsInt2[i],
-						       PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
-			if (unlikely(psRGXKickTA3D2OUT->eError != PVRSRV_OK))
-			{
-				UnlockHandle(psConnection->psHandleBase);
-				goto RGXKickTA3D2_exit;
-			}
-		}
+	psRGXCreateFreeListOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+								   &psRGXCreateFreeListOUT->
+								   hCleanupCookie,
+								   (void *)psCleanupCookieInt,
+								   PVRSRV_HANDLE_TYPE_RGX_FREELIST,
+								   PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+								   (PFN_HANDLE_RELEASE) &
+								   _RGXCreateFreeListpsCleanupCookieIntRelease);
+	if (unlikely(psRGXCreateFreeListOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateFreeList_exit;
 	}
-	/* Release now we have looked up handles. */
-	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXKickTA3D2OUT->eError =
-	    PVRSRVRGXKickTA3DKM(psRenderContextInt,
-				psRGXKickTA3D2IN->ui32ClientTAFenceCount,
-				psClientTAFenceSyncPrimBlockInt,
-				ui32ClientTAFenceSyncOffsetInt,
-				ui32ClientTAFenceValueInt,
-				psRGXKickTA3D2IN->ui32ClientTAUpdateCount,
-				psClientTAUpdateSyncPrimBlockInt,
-				ui32ClientTAUpdateSyncOffsetInt,
-				ui32ClientTAUpdateValueInt,
-				psRGXKickTA3D2IN->ui32Client3DUpdateCount,
-				psClient3DUpdateSyncPrimBlockInt,
-				ui32Client3DUpdateSyncOffsetInt,
-				ui32Client3DUpdateValueInt,
-				psPRFenceUFOSyncPrimBlockInt,
-				psRGXKickTA3D2IN->ui32PRFenceUFOSyncOffset,
-				psRGXKickTA3D2IN->ui32PRFenceValue,
-				psRGXKickTA3D2IN->hCheckFence,
-				psRGXKickTA3D2IN->hUpdateTimeline,
-				&psRGXKickTA3D2OUT->hUpdateFence,
-				uiUpdateFenceNameInt,
-				psRGXKickTA3D2IN->hCheckFence3D,
-				psRGXKickTA3D2IN->hUpdateTimeline3D,
-				&psRGXKickTA3D2OUT->hUpdateFence3D,
-				uiUpdateFenceName3DInt,
-				psRGXKickTA3D2IN->ui32TACmdSize,
-				ui8TACmdInt,
-				psRGXKickTA3D2IN->ui323DPRCmdSize,
-				ui83DPRCmdInt,
-				psRGXKickTA3D2IN->ui323DCmdSize,
-				ui83DCmdInt,
-				psRGXKickTA3D2IN->ui32ExtJobRef,
-				psRGXKickTA3D2IN->bbKickTA,
-				psRGXKickTA3D2IN->bbKickPR,
-				psRGXKickTA3D2IN->bbKick3D,
-				psRGXKickTA3D2IN->bbAbort,
-				psRGXKickTA3D2IN->ui32PDumpFlags,
-				psKMHWRTDataSetInt,
-				psZSBufferInt,
-				psMSAAScratchBufferInt,
-				psRGXKickTA3D2IN->ui32SyncPMRCount,
-				ui32SyncPMRFlagsInt,
-				psSyncPMRsInt,
-				psRGXKickTA3D2IN->ui32RenderTargetSize,
-				psRGXKickTA3D2IN->ui32NumberOfDrawCalls,
-				psRGXKickTA3D2IN->ui32NumberOfIndices,
-				psRGXKickTA3D2IN->ui32NumberOfMRTs, psRGXKickTA3D2IN->ui64Deadline);
+	/* Release now we have created handles. */
+	UnlockHandle(psConnection->psHandleBase);
 
-RGXKickTA3D2_exit:
+RGXCreateFreeList_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Unreference the previously looked up handle */
-	if (psRenderContextInt)
+	if (hMemCtxPrivDataInt)
 	{
 		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hRenderContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+					    hMemCtxPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA);
 	}
 
-	if (hClientTAFenceSyncPrimBlockInt2)
+	if (psRGXCreateFreeListIN->hsGlobalFreeList)
 	{
-		IMG_UINT32 i;
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAFenceCount; i++)
+		/* Unreference the previously looked up handle */
+		if (pssGlobalFreeListInt)
 		{
+			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+						    hsGlobalFreeList,
+						    PVRSRV_HANDLE_TYPE_RGX_FREELIST);
+		}
+	}
 
-			/* Unreference the previously looked up handle */
-			if (psClientTAFenceSyncPrimBlockInt && psClientTAFenceSyncPrimBlockInt[i])
-			{
-				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-							    hClientTAFenceSyncPrimBlockInt2[i],
-							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
-			}
+	/* Unreference the previously looked up handle */
+	if (psFreeListReservationInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hFreeListReservation,
+					    PVRSRV_HANDLE_TYPE_DEVMEMINT_RESERVATION);
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	if (psRGXCreateFreeListOUT->eError != PVRSRV_OK)
+	{
+		if (psCleanupCookieInt)
+		{
+			RGXDestroyFreeList(psCleanupCookieInt);
 		}
 	}
 
-	if (hClientTAUpdateSyncPrimBlockInt2)
+	return 0;
+}
+
+static PVRSRV_ERROR _RGXCreateRenderContextpsRenderContextIntRelease(void *pvData)
+{
+	PVRSRV_ERROR eError;
+	eError = PVRSRVRGXDestroyRenderContextKM((RGX_SERVER_RENDER_CONTEXT *) pvData);
+	return eError;
+}
+
+static_assert(RGXFWIF_RF_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_RF_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_STATIC_RENDERCONTEXT_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_STATIC_RENDERCONTEXT_SIZE must not be larger than IMG_UINT32_MAX");
+
+static IMG_INT
+PVRSRVBridgeRGXCreateRenderContext(IMG_UINT32 ui32DispatchTableEntry,
+				   IMG_UINT8 * psRGXCreateRenderContextIN_UI8,
+				   IMG_UINT8 * psRGXCreateRenderContextOUT_UI8,
+				   CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT *psRGXCreateRenderContextIN =
+	    (PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT *)
+	    IMG_OFFSET_ADDR(psRGXCreateRenderContextIN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT *psRGXCreateRenderContextOUT =
+	    (PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT *)
+	    IMG_OFFSET_ADDR(psRGXCreateRenderContextOUT_UI8, 0);
+
+	IMG_BYTE *ui8FrameworkCmdInt = NULL;
+	IMG_HANDLE hPrivData = psRGXCreateRenderContextIN->hPrivData;
+	IMG_HANDLE hPrivDataInt = NULL;
+	IMG_BYTE *ui8StaticRenderContextStateInt = NULL;
+	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
+
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
+
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE)) +
+	    ((IMG_UINT64) psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize *
+	     sizeof(IMG_BYTE)) + 0;
+
+	if (unlikely(psRGXCreateRenderContextIN->ui32FrameworkCmdSize > RGXFWIF_RF_CMD_SIZE))
+	{
+		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXCreateRenderContext_exit;
+	}
+
+	if (unlikely
+	    (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize >
+	     RGXFWIF_STATIC_RENDERCONTEXT_SIZE))
+	{
+		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXCreateRenderContext_exit;
+	}
+
+	if (ui64BufferSize > IMG_UINT32_MAX)
 	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < psRGXKickTA3D2IN->ui32ClientTAUpdateCount; i++)
-		{
-
-			/* Unreference the previously looked up handle */
-			if (psClientTAUpdateSyncPrimBlockInt && psClientTAUpdateSyncPrimBlockInt[i])
-			{
-				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-							    hClientTAUpdateSyncPrimBlockInt2[i],
-							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
-			}
-		}
+		psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXCreateRenderContext_exit;
 	}
 
-	if (hClient3DUpdateSyncPrimBlockInt2)
+	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
+
+	if (ui32BufferSize != 0)
 	{
-		IMG_UINT32 i;
+		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
+		IMG_UINT32 ui32InBufferOffset =
+		    PVR_ALIGN(sizeof(*psRGXCreateRenderContextIN), sizeof(unsigned long));
+		IMG_UINT32 ui32InBufferExcessSize =
+		    ui32InBufferOffset >=
+		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
 
-		for (i = 0; i < psRGXKickTA3D2IN->ui32Client3DUpdateCount; i++)
+		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
+		if (bHaveEnoughSpace)
 		{
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXCreateRenderContextIN;
 
-			/* Unreference the previously looked up handle */
-			if (psClient3DUpdateSyncPrimBlockInt && psClient3DUpdateSyncPrimBlockInt[i])
+			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
+		}
+		else
+		{
+			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
+
+			if (!pArrayArgsBuffer)
 			{
-				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-							    hClient3DUpdateSyncPrimBlockInt2[i],
-							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+				psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXCreateRenderContext_exit;
 			}
 		}
 	}
 
-	/* Unreference the previously looked up handle */
-	if (psPRFenceUFOSyncPrimBlockInt)
+	if (psRGXCreateRenderContextIN->ui32FrameworkCmdSize != 0)
 	{
-		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hPRFenceUFOSyncPrimBlock,
-					    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+		ui8FrameworkCmdInt = (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE);
 	}
 
-	if (psRGXKickTA3D2IN->hKMHWRTDataSet)
+	/* Copy the data over */
+	if (psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE) > 0)
 	{
-
-		/* Unreference the previously looked up handle */
-		if (psKMHWRTDataSetInt)
+		if (OSCopyFromUser
+		    (NULL, ui8FrameworkCmdInt,
+		     (const void __user *)psRGXCreateRenderContextIN->pui8FrameworkCmd,
+		     psRGXCreateRenderContextIN->ui32FrameworkCmdSize * sizeof(IMG_BYTE)) !=
+		    PVRSRV_OK)
 		{
-			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-						    hKMHWRTDataSet,
-						    PVRSRV_HANDLE_TYPE_RGX_KM_HW_RT_DATASET);
-		}
-	}
-
-	if (psRGXKickTA3D2IN->hZSBuffer)
-	{
+			psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-		/* Unreference the previously looked up handle */
-		if (psZSBufferInt)
-		{
-			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-						    hZSBuffer,
-						    PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
+			goto RGXCreateRenderContext_exit;
 		}
 	}
-
-	if (psRGXKickTA3D2IN->hMSAAScratchBuffer)
+	if (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize != 0)
 	{
-
-		/* Unreference the previously looked up handle */
-		if (psMSAAScratchBufferInt)
-		{
-			PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-						    hMSAAScratchBuffer,
-						    PVRSRV_HANDLE_TYPE_RGX_FWIF_ZSBUFFER);
-		}
+		ui8StaticRenderContextStateInt =
+		    (IMG_BYTE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize * sizeof(IMG_BYTE);
 	}
 
-	if (hSyncPMRsInt2)
+	/* Copy the data over */
+	if (psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize * sizeof(IMG_BYTE) > 0)
 	{
-		IMG_UINT32 i;
-
-		for (i = 0; i < psRGXKickTA3D2IN->ui32SyncPMRCount; i++)
+		if (OSCopyFromUser
+		    (NULL, ui8StaticRenderContextStateInt,
+		     (const void __user *)psRGXCreateRenderContextIN->pui8StaticRenderContextState,
+		     psRGXCreateRenderContextIN->ui32StaticRenderContextStateSize *
+		     sizeof(IMG_BYTE)) != PVRSRV_OK)
 		{
+			psRGXCreateRenderContextOUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-			/* Unreference the previously looked up handle */
-			if (psSyncPMRsInt && psSyncPMRsInt[i])
-			{
-				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-							    hSyncPMRsInt2[i],
-							    PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
-			}
+			goto RGXCreateRenderContext_exit;
 		}
 	}
-	/* Release now we have cleaned up look up handles. */
-	UnlockHandle(psConnection->psHandleBase);
-
-	/* Allocated space should be equal to the last updated offset */
-#ifdef PVRSRV_NEED_PVR_ASSERT
-	if (psRGXKickTA3D2OUT->eError == PVRSRV_OK)
-		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
-#endif /* PVRSRV_NEED_PVR_ASSERT */
-
-	if (!bHaveEnoughSpace && pArrayArgsBuffer)
-		OSFreeMemNoStats(pArrayArgsBuffer);
-
-	return 0;
-}
-
-static IMG_INT
-PVRSRVBridgeRGXSetRenderContextProperty(IMG_UINT32 ui32DispatchTableEntry,
-					IMG_UINT8 * psRGXSetRenderContextPropertyIN_UI8,
-					IMG_UINT8 * psRGXSetRenderContextPropertyOUT_UI8,
-					CONNECTION_DATA * psConnection)
-{
-	PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPROPERTY *psRGXSetRenderContextPropertyIN =
-	    (PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPROPERTY *)
-	    IMG_OFFSET_ADDR(psRGXSetRenderContextPropertyIN_UI8, 0);
-	PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY *psRGXSetRenderContextPropertyOUT =
-	    (PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY *)
-	    IMG_OFFSET_ADDR(psRGXSetRenderContextPropertyOUT_UI8, 0);
-
-	IMG_HANDLE hRenderContext = psRGXSetRenderContextPropertyIN->hRenderContext;
-	RGX_SERVER_RENDER_CONTEXT *psRenderContextInt = NULL;
 
 	/* Lock over handle lookup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Look up the address from the handle */
-	psRGXSetRenderContextPropertyOUT->eError =
+	psRGXCreateRenderContextOUT->eError =
 	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
-				       (void **)&psRenderContextInt,
-				       hRenderContext,
-				       PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT, IMG_TRUE);
-	if (unlikely(psRGXSetRenderContextPropertyOUT->eError != PVRSRV_OK))
+				       (void **)&hPrivDataInt,
+				       hPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA, IMG_TRUE);
+	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
 	{
 		UnlockHandle(psConnection->psHandleBase);
-		goto RGXSetRenderContextProperty_exit;
+		goto RGXCreateRenderContext_exit;
 	}
 	/* Release now we have looked up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
-	psRGXSetRenderContextPropertyOUT->eError =
-	    PVRSRVRGXSetRenderContextPropertyKM(psRenderContextInt,
-						psRGXSetRenderContextPropertyIN->ui32Property,
-						psRGXSetRenderContextPropertyIN->ui64Input,
-						&psRGXSetRenderContextPropertyOUT->ui64Output);
+	psRGXCreateRenderContextOUT->eError =
+	    PVRSRVRGXCreateRenderContextKM(psConnection, OSGetDevNode(psConnection),
+					   psRGXCreateRenderContextIN->i32Priority,
+					   psRGXCreateRenderContextIN->sVDMCallStackAddr,
+					   psRGXCreateRenderContextIN->ui32ui32CallStackDepth,
+					   psRGXCreateRenderContextIN->ui32FrameworkCmdSize,
+					   ui8FrameworkCmdInt,
+					   hPrivDataInt,
+					   psRGXCreateRenderContextIN->
+					   ui32StaticRenderContextStateSize,
+					   ui8StaticRenderContextStateInt,
+					   psRGXCreateRenderContextIN->ui32PackedCCBSizeU8888,
+					   psRGXCreateRenderContextIN->ui32ContextFlags,
+					   psRGXCreateRenderContextIN->ui64RobustnessAddress,
+					   psRGXCreateRenderContextIN->ui32MaxTADeadlineMS,
+					   psRGXCreateRenderContextIN->ui32Max3DDeadlineMS,
+					   &psRenderContextInt);
+	/* Exit early if bridged call fails */
+	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
+	{
+		goto RGXCreateRenderContext_exit;
+	}
 
-RGXSetRenderContextProperty_exit:
+	/* Lock over handle creation. */
+	LockHandle(psConnection->psHandleBase);
+
+	psRGXCreateRenderContextOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
+									&psRGXCreateRenderContextOUT->
+									hRenderContext,
+									(void *)psRenderContextInt,
+									PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT,
+									PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+									(PFN_HANDLE_RELEASE) &
+									_RGXCreateRenderContextpsRenderContextIntRelease);
+	if (unlikely(psRGXCreateRenderContextOUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXCreateRenderContext_exit;
+	}
+
+	/* Release now we have created handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+RGXCreateRenderContext_exit:
 
 	/* Lock over handle lookup cleanup. */
 	LockHandle(psConnection->psHandleBase);
 
 	/* Unreference the previously looked up handle */
-	if (psRenderContextInt)
+	if (hPrivDataInt)
 	{
 		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
-					    hRenderContext,
-					    PVRSRV_HANDLE_TYPE_RGX_SERVER_RENDER_CONTEXT);
+					    hPrivData, PVRSRV_HANDLE_TYPE_DEV_PRIV_DATA);
 	}
 	/* Release now we have cleaned up look up handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
+	if (psRGXCreateRenderContextOUT->eError != PVRSRV_OK)
+	{
+		if (psRenderContextInt)
+		{
+			PVRSRVRGXDestroyRenderContextKM(psRenderContextInt);
+		}
+	}
+
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXCreateRenderContextOUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
 	return 0;
 }
 
@@ -2353,52 +2408,81 @@ void DeinitRGXTA3DBridge(void);
 PVRSRV_ERROR InitRGXTA3DBridge(void)
 {
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET,
-			      PVRSRVBridgeRGXCreateHWRTDataSet, NULL);
-
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYHWRTDATASET,
-			      PVRSRVBridgeRGXDestroyHWRTDataSet, NULL);
+			      PVRSRVBridgeRGXDestroyHWRTDataSet, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYHWRTDATASET),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYHWRTDATASET));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEZSBUFFER,
-			      PVRSRVBridgeRGXCreateZSBuffer, NULL);
+			      PVRSRVBridgeRGXCreateZSBuffer, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATEZSBUFFER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATEZSBUFFER));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYZSBUFFER,
-			      PVRSRVBridgeRGXDestroyZSBuffer, NULL);
+			      PVRSRVBridgeRGXDestroyZSBuffer, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYZSBUFFER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYZSBUFFER));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXPOPULATEZSBUFFER,
-			      PVRSRVBridgeRGXPopulateZSBuffer, NULL);
+			      PVRSRVBridgeRGXPopulateZSBuffer, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXPOPULATEZSBUFFER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXPOPULATEZSBUFFER));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXUNPOPULATEZSBUFFER,
-			      PVRSRVBridgeRGXUnpopulateZSBuffer, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST,
-			      PVRSRVBridgeRGXCreateFreeList, NULL);
+			      PVRSRVBridgeRGXUnpopulateZSBuffer, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXUNPOPULATEZSBUFFER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXUNPOPULATEZSBUFFER));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYFREELIST,
-			      PVRSRVBridgeRGXDestroyFreeList, NULL);
-
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT,
-			      PVRSRVBridgeRGXCreateRenderContext, NULL);
+			      PVRSRVBridgeRGXDestroyFreeList, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYFREELIST),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYFREELIST));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYRENDERCONTEXT,
-			      PVRSRVBridgeRGXDestroyRenderContext, NULL);
+			      PVRSRVBridgeRGXDestroyRenderContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYRENDERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYRENDERCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXSENDZSSTOREDISABLE,
-			      PVRSRVBridgeRGXSendZSStoreDisable, NULL);
+			      PVRSRVBridgeRGXSendZSStoreDisable, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSENDZSSTOREDISABLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSENDZSSTOREDISABLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
 			      PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPRIORITY,
-			      PVRSRVBridgeRGXSetRenderContextPriority, NULL);
+			      PVRSRVBridgeRGXSetRenderContextPriority, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPRIORITY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPRIORITY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXRENDERCONTEXTSTALLED,
-			      PVRSRVBridgeRGXRenderContextStalled, NULL);
+			      PVRSRVBridgeRGXRenderContextStalled, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXRENDERCONTEXTSTALLED),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXRENDERCONTEXTSTALLED));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXKICKTA3D2,
-			      PVRSRVBridgeRGXKickTA3D2, NULL);
+			      PVRSRVBridgeRGXKickTA3D2, NULL, sizeof(PVRSRV_BRIDGE_IN_RGXKICKTA3D2),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXKICKTA3D2));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
 			      PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPROPERTY,
-			      PVRSRVBridgeRGXSetRenderContextProperty, NULL);
+			      PVRSRVBridgeRGXSetRenderContextProperty, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETRENDERCONTEXTPROPERTY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETRENDERCONTEXTPROPERTY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET,
+			      PVRSRVBridgeRGXCreateHWRTDataSet, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATEHWRTDATASET),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATEHWRTDATASET));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST,
+			      PVRSRVBridgeRGXCreateFreeList, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATEFREELIST),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATEFREELIST));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT,
+			      PVRSRVBridgeRGXCreateRenderContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATERENDERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATERENDERCONTEXT));
 
 	return PVRSRV_OK;
 }
@@ -2409,8 +2493,6 @@ PVRSRV_ERROR InitRGXTA3DBridge(void)
 void DeinitRGXTA3DBridge(void)
 {
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYHWRTDATASET);
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEZSBUFFER);
@@ -2421,13 +2503,8 @@ void DeinitRGXTA3DBridge(void)
 
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXUNPOPULATEZSBUFFER);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYFREELIST);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
-				PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT);
-
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
 				PVRSRV_BRIDGE_RGXTA3D_RGXDESTROYRENDERCONTEXT);
 
@@ -2444,4 +2521,11 @@ void DeinitRGXTA3DBridge(void)
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
 				PVRSRV_BRIDGE_RGXTA3D_RGXSETRENDERCONTEXTPROPERTY);
 
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEHWRTDATASET);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D, PVRSRV_BRIDGE_RGXTA3D_RGXCREATEFREELIST);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTA3D,
+				PVRSRV_BRIDGE_RGXTA3D_RGXCREATERENDERCONTEXT);
+
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxtimerquery_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxtimerquery_bridge.c
index 99e6239cf7a9..4af3cfc35cba 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxtimerquery_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxtimerquery_bridge.c
@@ -136,15 +136,19 @@ PVRSRV_ERROR InitRGXTIMERQUERYBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTIMERQUERY,
 			      PVRSRV_BRIDGE_RGXTIMERQUERY_RGXBEGINTIMERQUERY,
-			      PVRSRVBridgeRGXBeginTimerQuery, NULL);
+			      PVRSRVBridgeRGXBeginTimerQuery, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXBEGINTIMERQUERY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXBEGINTIMERQUERY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTIMERQUERY,
 			      PVRSRV_BRIDGE_RGXTIMERQUERY_RGXENDTIMERQUERY,
-			      PVRSRVBridgeRGXEndTimerQuery, NULL);
+			      PVRSRVBridgeRGXEndTimerQuery, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXENDTIMERQUERY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTIMERQUERY,
 			      PVRSRV_BRIDGE_RGXTIMERQUERY_RGXQUERYTIMER, PVRSRVBridgeRGXQueryTimer,
-			      NULL);
+			      NULL, sizeof(PVRSRV_BRIDGE_IN_RGXQUERYTIMER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXQUERYTIMER));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxtq2_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxtq2_bridge.c
index 6ce59c8049c3..1129b824d850 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxtq2_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxtq2_bridge.c
@@ -210,7 +210,9 @@ PVRSRVBridgeRGXTDMCreateTransferContext(IMG_UINT32 ui32DispatchTableEntry,
 						ui32PackedCCBSizeU88,
 						psRGXTDMCreateTransferContextIN->ui32ContextFlags,
 						psRGXTDMCreateTransferContextIN->
-						ui64RobustnessAddress, &psTransferContextInt);
+						ui64RobustnessAddress,
+						psRGXTDMCreateTransferContextIN->ui32MaxDeadlineMS,
+						&psTransferContextInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psRGXTDMCreateTransferContextOUT->eError != PVRSRV_OK))
 	{
@@ -892,13 +894,6 @@ static PVRSRV_ERROR _RGXTDMGetSharedMemorypsCLIPMRMemIntRelease(void *pvData)
 	return eError;
 }
 
-static PVRSRV_ERROR _RGXTDMGetSharedMemorypsUSCPMRMemIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = PVRSRVRGXTDMReleaseSharedMemoryKM((PMR *) pvData);
-	return eError;
-}
-
 static IMG_INT
 PVRSRVBridgeRGXTDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 				  IMG_UINT8 * psRGXTDMGetSharedMemoryIN_UI8,
@@ -913,7 +908,6 @@ PVRSRVBridgeRGXTDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 	    IMG_OFFSET_ADDR(psRGXTDMGetSharedMemoryOUT_UI8, 0);
 
 	PMR *psCLIPMRMemInt = NULL;
-	PMR *psUSCPMRMemInt = NULL;
 
 	{
 		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
@@ -933,7 +927,7 @@ PVRSRVBridgeRGXTDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 
 	psRGXTDMGetSharedMemoryOUT->eError =
 	    PVRSRVRGXTDMGetSharedMemoryKM(psConnection, OSGetDevNode(psConnection),
-					  &psCLIPMRMemInt, &psUSCPMRMemInt);
+					  &psCLIPMRMemInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psRGXTDMGetSharedMemoryOUT->eError != PVRSRV_OK))
 	{
@@ -957,20 +951,6 @@ PVRSRVBridgeRGXTDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 		goto RGXTDMGetSharedMemory_exit;
 	}
 
-	psRGXTDMGetSharedMemoryOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								       &psRGXTDMGetSharedMemoryOUT->
-								       hUSCPMRMem,
-								       (void *)psUSCPMRMemInt,
-								       PVRSRV_HANDLE_TYPE_PMR_LOCAL_EXPORT_HANDLE,
-								       PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								       (PFN_HANDLE_RELEASE) &
-								       _RGXTDMGetSharedMemorypsUSCPMRMemIntRelease);
-	if (unlikely(psRGXTDMGetSharedMemoryOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXTDMGetSharedMemory_exit;
-	}
-
 	/* Release now we have created handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
@@ -982,10 +962,6 @@ PVRSRVBridgeRGXTDMGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 		{
 			PVRSRVRGXTDMReleaseSharedMemoryKM(psCLIPMRMemInt);
 		}
-		if (psUSCPMRMemInt)
-		{
-			PVRSRVRGXTDMReleaseSharedMemoryKM(psUSCPMRMemInt);
-		}
 	}
 
 	return 0;
@@ -1118,6 +1094,424 @@ PVRSRVBridgeRGXTDMSetTransferContextProperty(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
+	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+
+static IMG_INT
+PVRSRVBridgeRGXTDMSubmitTransfer3(IMG_UINT32 ui32DispatchTableEntry,
+				  IMG_UINT8 * psRGXTDMSubmitTransfer3IN_UI8,
+				  IMG_UINT8 * psRGXTDMSubmitTransfer3OUT_UI8,
+				  CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER3 *psRGXTDMSubmitTransfer3IN =
+	    (PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER3 *)
+	    IMG_OFFSET_ADDR(psRGXTDMSubmitTransfer3IN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER3 *psRGXTDMSubmitTransfer3OUT =
+	    (PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER3 *)
+	    IMG_OFFSET_ADDR(psRGXTDMSubmitTransfer3OUT_UI8, 0);
+
+	IMG_HANDLE hTransferContext = psRGXTDMSubmitTransfer3IN->hTransferContext;
+	RGX_SERVER_TQ_TDM_CONTEXT *psTransferContextInt = NULL;
+	SYNC_PRIMITIVE_BLOCK **psUpdateUFOSyncPrimBlockInt = NULL;
+	IMG_HANDLE *hUpdateUFOSyncPrimBlockInt2 = NULL;
+	IMG_UINT32 *ui32UpdateSyncOffsetInt = NULL;
+	IMG_UINT32 *ui32UpdateValueInt = NULL;
+	IMG_CHAR *uiUpdateFenceNameInt = NULL;
+	IMG_UINT8 *ui8FWCommandInt = NULL;
+	IMG_UINT32 *ui32SyncPMRFlagsInt = NULL;
+	PMR **psSyncPMRsInt = NULL;
+	IMG_HANDLE *hSyncPMRsInt2 = NULL;
+
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
+
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount *
+	     sizeof(SYNC_PRIMITIVE_BLOCK *)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32CommandSize * sizeof(IMG_UINT8)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *)) +
+	    ((IMG_UINT64) psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
+
+	if (unlikely(psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount > PVRSRV_MAX_SYNCS))
+	{
+		psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXTDMSubmitTransfer3_exit;
+	}
+
+	if (unlikely
+	    (psRGXTDMSubmitTransfer3IN->ui32CommandSize > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE))
+	{
+		psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXTDMSubmitTransfer3_exit;
+	}
+
+	if (unlikely(psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
+	{
+		psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXTDMSubmitTransfer3_exit;
+	}
+
+	{
+		PVRSRV_DEVICE_NODE *psDeviceNode = OSGetDevNode(psConnection);
+
+		/* Check that device supports the required feature */
+		if ((psDeviceNode->pfnCheckDeviceFeature) &&
+		    !psDeviceNode->pfnCheckDeviceFeature(psDeviceNode,
+							 RGX_FEATURE_FASTRENDER_DM_BIT_MASK))
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_NOT_SUPPORTED;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+
+	if (ui64BufferSize > IMG_UINT32_MAX)
+	{
+		psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXTDMSubmitTransfer3_exit;
+	}
+
+	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
+
+	if (ui32BufferSize != 0)
+	{
+		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
+		IMG_UINT32 ui32InBufferOffset =
+		    PVR_ALIGN(sizeof(*psRGXTDMSubmitTransfer3IN), sizeof(unsigned long));
+		IMG_UINT32 ui32InBufferExcessSize =
+		    ui32InBufferOffset >=
+		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
+
+		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
+		if (bHaveEnoughSpace)
+		{
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXTDMSubmitTransfer3IN;
+
+			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
+		}
+		else
+		{
+			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
+
+			if (!pArrayArgsBuffer)
+			{
+				psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXTDMSubmitTransfer3_exit;
+			}
+		}
+	}
+
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount != 0)
+	{
+		psUpdateUFOSyncPrimBlockInt =
+		    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psUpdateUFOSyncPrimBlockInt, 0,
+			       psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount *
+			       sizeof(SYNC_PRIMITIVE_BLOCK *));
+		ui32NextOffset +=
+		    psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount *
+		    sizeof(SYNC_PRIMITIVE_BLOCK *);
+		hUpdateUFOSyncPrimBlockInt2 =
+		    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, hUpdateUFOSyncPrimBlockInt2,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->phUpdateUFOSyncPrimBlock,
+		     psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_HANDLE)) !=
+		    PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount != 0)
+	{
+		ui32UpdateSyncOffsetInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32UpdateSyncOffsetInt,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->pui32UpdateSyncOffset,
+		     psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) !=
+		    PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount != 0)
+	{
+		ui32UpdateValueInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32UpdateValueInt,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->pui32UpdateValue,
+		     psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount * sizeof(IMG_UINT32)) !=
+		    PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+
+	{
+		uiUpdateFenceNameInt =
+		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+	}
+
+	/* Copy the data over */
+	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, uiUpdateFenceNameInt,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->puiUpdateFenceName,
+		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
+						    1] = '\0';
+	}
+	if (psRGXTDMSubmitTransfer3IN->ui32CommandSize != 0)
+	{
+		ui8FWCommandInt = (IMG_UINT8 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXTDMSubmitTransfer3IN->ui32CommandSize * sizeof(IMG_UINT8);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32CommandSize * sizeof(IMG_UINT8) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui8FWCommandInt,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->pui8FWCommand,
+		     psRGXTDMSubmitTransfer3IN->ui32CommandSize * sizeof(IMG_UINT8)) != PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount != 0)
+	{
+		ui32SyncPMRFlagsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32SyncPMRFlagsInt,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->pui32SyncPMRFlags,
+		     psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount != 0)
+	{
+		psSyncPMRsInt = (PMR **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psSyncPMRsInt, 0,
+			       psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *));
+		ui32NextOffset += psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *);
+		hSyncPMRsInt2 = (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
+	}
+
+	/* Copy the data over */
+	if (psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, hSyncPMRsInt2,
+		     (const void __user *)psRGXTDMSubmitTransfer3IN->phSyncPMRs,
+		     psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		{
+			psRGXTDMSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXTDMSubmitTransfer3_exit;
+		}
+	}
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXTDMSubmitTransfer3OUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psTransferContextInt,
+				       hTransferContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_TQ_TDM_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXTDMSubmitTransfer3OUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXTDMSubmitTransfer3_exit;
+	}
+
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXTDMSubmitTransfer3OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)&psUpdateUFOSyncPrimBlockInt[i],
+						       hUpdateUFOSyncPrimBlockInt2[i],
+						       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
+						       IMG_TRUE);
+			if (unlikely(psRGXTDMSubmitTransfer3OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXTDMSubmitTransfer3_exit;
+			}
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXTDMSubmitTransfer3OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)&psSyncPMRsInt[i],
+						       hSyncPMRsInt2[i],
+						       PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+			if (unlikely(psRGXTDMSubmitTransfer3OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXTDMSubmitTransfer3_exit;
+			}
+		}
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXTDMSubmitTransfer3OUT->eError =
+	    PVRSRVRGXTDMSubmitTransfer3KM(psTransferContextInt,
+					  psRGXTDMSubmitTransfer3IN->ui32PDumpFlags,
+					  psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount,
+					  psUpdateUFOSyncPrimBlockInt,
+					  ui32UpdateSyncOffsetInt,
+					  ui32UpdateValueInt,
+					  psRGXTDMSubmitTransfer3IN->hCheckFenceFD,
+					  psRGXTDMSubmitTransfer3IN->hUpdateTimeline,
+					  &psRGXTDMSubmitTransfer3OUT->hUpdateFence,
+					  uiUpdateFenceNameInt,
+					  psRGXTDMSubmitTransfer3IN->hExportFenceToSignal,
+					  psRGXTDMSubmitTransfer3IN->ui32CommandSize,
+					  ui8FWCommandInt,
+					  psRGXTDMSubmitTransfer3IN->ui32ExternalJobReference,
+					  psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount,
+					  ui32SyncPMRFlagsInt,
+					  psSyncPMRsInt,
+					  psRGXTDMSubmitTransfer3IN->ui32Characteristic1,
+					  psRGXTDMSubmitTransfer3IN->ui32Characteristic2,
+					  psRGXTDMSubmitTransfer3IN->ui64DeadlineInus);
+
+RGXTDMSubmitTransfer3_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psTransferContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hTransferContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_TQ_TDM_CONTEXT);
+	}
+
+	if (hUpdateUFOSyncPrimBlockInt2)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXTDMSubmitTransfer3IN->ui32ClientUpdateCount; i++)
+		{
+
+			/* Unreference the previously looked up handle */
+			if (psUpdateUFOSyncPrimBlockInt && psUpdateUFOSyncPrimBlockInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hUpdateUFOSyncPrimBlockInt2[i],
+							    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+			}
+		}
+	}
+
+	if (hSyncPMRsInt2)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXTDMSubmitTransfer3IN->ui32SyncPMRCount; i++)
+		{
+
+			/* Unreference the previously looked up handle */
+			if (psSyncPMRsInt && psSyncPMRsInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hSyncPMRsInt2[i],
+							    PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+			}
+		}
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXTDMSubmitTransfer3OUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
+	return 0;
+}
+
 /* ***************************************************************************
  * Server bridge dispatch related glue
  */
@@ -1133,32 +1527,52 @@ PVRSRV_ERROR InitRGXTQ2Bridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 			      PVRSRV_BRIDGE_RGXTQ2_RGXTDMCREATETRANSFERCONTEXT,
-			      PVRSRVBridgeRGXTDMCreateTransferContext, NULL);
+			      PVRSRVBridgeRGXTDMCreateTransferContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMCREATETRANSFERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMCREATETRANSFERCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 			      PVRSRV_BRIDGE_RGXTQ2_RGXTDMDESTROYTRANSFERCONTEXT,
-			      PVRSRVBridgeRGXTDMDestroyTransferContext, NULL);
+			      PVRSRVBridgeRGXTDMDestroyTransferContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMDESTROYTRANSFERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMDESTROYTRANSFERCONTEXT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 			      PVRSRV_BRIDGE_RGXTQ2_RGXTDMSETTRANSFERCONTEXTPRIORITY,
-			      PVRSRVBridgeRGXTDMSetTransferContextPriority, NULL);
+			      PVRSRVBridgeRGXTDMSetTransferContextPriority, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMSETTRANSFERCONTEXTPRIORITY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMSETTRANSFERCONTEXTPRIORITY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 			      PVRSRV_BRIDGE_RGXTQ2_RGXTDMNOTIFYWRITEOFFSETUPDATE,
-			      PVRSRVBridgeRGXTDMNotifyWriteOffsetUpdate, NULL);
+			      PVRSRVBridgeRGXTDMNotifyWriteOffsetUpdate, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMNOTIFYWRITEOFFSETUPDATE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMNOTIFYWRITEOFFSETUPDATE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2, PVRSRV_BRIDGE_RGXTQ2_RGXTDMSUBMITTRANSFER2,
-			      PVRSRVBridgeRGXTDMSubmitTransfer2, NULL);
+			      PVRSRVBridgeRGXTDMSubmitTransfer2, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER2),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER2));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2, PVRSRV_BRIDGE_RGXTQ2_RGXTDMGETSHAREDMEMORY,
-			      PVRSRVBridgeRGXTDMGetSharedMemory, NULL);
+			      PVRSRVBridgeRGXTDMGetSharedMemory, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMGETSHAREDMEMORY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2, PVRSRV_BRIDGE_RGXTQ2_RGXTDMRELEASESHAREDMEMORY,
-			      PVRSRVBridgeRGXTDMReleaseSharedMemory, NULL);
+			      PVRSRVBridgeRGXTDMReleaseSharedMemory, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMRELEASESHAREDMEMORY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMRELEASESHAREDMEMORY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 			      PVRSRV_BRIDGE_RGXTQ2_RGXTDMSETTRANSFERCONTEXTPROPERTY,
-			      PVRSRVBridgeRGXTDMSetTransferContextProperty, NULL);
+			      PVRSRVBridgeRGXTDMSetTransferContextProperty, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMSETTRANSFERCONTEXTPROPERTY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMSETTRANSFERCONTEXTPROPERTY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2, PVRSRV_BRIDGE_RGXTQ2_RGXTDMSUBMITTRANSFER3,
+			      PVRSRVBridgeRGXTDMSubmitTransfer3, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTDMSUBMITTRANSFER3),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTDMSUBMITTRANSFER3));
 
 	return PVRSRV_OK;
 }
@@ -1191,4 +1605,6 @@ void DeinitRGXTQ2Bridge(void)
 	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2,
 				PVRSRV_BRIDGE_RGXTQ2_RGXTDMSETTRANSFERCONTEXTPROPERTY);
 
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ2, PVRSRV_BRIDGE_RGXTQ2_RGXTDMSUBMITTRANSFER3);
+
 }
diff --git a/drivers/gpu/drm/img-rogue/server_rgxtq_bridge.c b/drivers/gpu/drm/img-rogue/server_rgxtq_bridge.c
index 08bbf7bb601e..f50c1184676a 100644
--- a/drivers/gpu/drm/img-rogue/server_rgxtq_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_rgxtq_bridge.c
@@ -1030,13 +1030,6 @@ static PVRSRV_ERROR _RGXTQGetSharedMemorypsCLIPMRMemIntRelease(void *pvData)
 	return eError;
 }
 
-static PVRSRV_ERROR _RGXTQGetSharedMemorypsUSCPMRMemIntRelease(void *pvData)
-{
-	PVRSRV_ERROR eError;
-	eError = PVRSRVRGXTQReleaseSharedMemoryKM((PMR *) pvData);
-	return eError;
-}
-
 static IMG_INT
 PVRSRVBridgeRGXTQGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 				 IMG_UINT8 * psRGXTQGetSharedMemoryIN_UI8,
@@ -1051,13 +1044,11 @@ PVRSRVBridgeRGXTQGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 	    IMG_OFFSET_ADDR(psRGXTQGetSharedMemoryOUT_UI8, 0);
 
 	PMR *psCLIPMRMemInt = NULL;
-	PMR *psUSCPMRMemInt = NULL;
 
 	PVR_UNREFERENCED_PARAMETER(psRGXTQGetSharedMemoryIN);
 
 	psRGXTQGetSharedMemoryOUT->eError =
-	    PVRSRVRGXTQGetSharedMemoryKM(psConnection, OSGetDevNode(psConnection),
-					 &psCLIPMRMemInt, &psUSCPMRMemInt);
+	    PVRSRVRGXTQGetSharedMemoryKM(psConnection, OSGetDevNode(psConnection), &psCLIPMRMemInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psRGXTQGetSharedMemoryOUT->eError != PVRSRV_OK))
 	{
@@ -1081,20 +1072,6 @@ PVRSRVBridgeRGXTQGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 		goto RGXTQGetSharedMemory_exit;
 	}
 
-	psRGXTQGetSharedMemoryOUT->eError = PVRSRVAllocHandleUnlocked(psConnection->psHandleBase,
-								      &psRGXTQGetSharedMemoryOUT->
-								      hUSCPMRMem,
-								      (void *)psUSCPMRMemInt,
-								      PVRSRV_HANDLE_TYPE_PMR_LOCAL_EXPORT_HANDLE,
-								      PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-								      (PFN_HANDLE_RELEASE) &
-								      _RGXTQGetSharedMemorypsUSCPMRMemIntRelease);
-	if (unlikely(psRGXTQGetSharedMemoryOUT->eError != PVRSRV_OK))
-	{
-		UnlockHandle(psConnection->psHandleBase);
-		goto RGXTQGetSharedMemory_exit;
-	}
-
 	/* Release now we have created handles. */
 	UnlockHandle(psConnection->psHandleBase);
 
@@ -1106,10 +1083,6 @@ PVRSRVBridgeRGXTQGetSharedMemory(IMG_UINT32 ui32DispatchTableEntry,
 		{
 			PVRSRVRGXTQReleaseSharedMemoryKM(psCLIPMRMemInt);
 		}
-		if (psUSCPMRMemInt)
-		{
-			PVRSRVRGXTQReleaseSharedMemoryKM(psUSCPMRMemInt);
-		}
 	}
 
 	return 0;
@@ -1211,69 +1184,762 @@ PVRSRVBridgeRGXSetTransferContextProperty(IMG_UINT32 ui32DispatchTableEntry,
 	return 0;
 }
 
-/* ***************************************************************************
- * Server bridge dispatch related glue
- */
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_SYNC_NAME_LENGTH <= IMG_UINT32_MAX,
+	      "PVRSRV_SYNC_NAME_LENGTH must not be larger than IMG_UINT32_MAX");
+static_assert(RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE <= IMG_UINT32_MAX,
+	      "RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE must not be larger than IMG_UINT32_MAX");
+static_assert(PVRSRV_MAX_SYNCS <= IMG_UINT32_MAX,
+	      "PVRSRV_MAX_SYNCS must not be larger than IMG_UINT32_MAX");
 
-#endif /* SUPPORT_RGXTQ_BRIDGE */
+static IMG_INT
+PVRSRVBridgeRGXSubmitTransfer3(IMG_UINT32 ui32DispatchTableEntry,
+			       IMG_UINT8 * psRGXSubmitTransfer3IN_UI8,
+			       IMG_UINT8 * psRGXSubmitTransfer3OUT_UI8,
+			       CONNECTION_DATA * psConnection)
+{
+	PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER3 *psRGXSubmitTransfer3IN =
+	    (PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER3 *) IMG_OFFSET_ADDR(psRGXSubmitTransfer3IN_UI8, 0);
+	PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER3 *psRGXSubmitTransfer3OUT =
+	    (PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER3 *) IMG_OFFSET_ADDR(psRGXSubmitTransfer3OUT_UI8,
+								     0);
 
-#if defined(SUPPORT_RGXTQ_BRIDGE)
-PVRSRV_ERROR InitRGXTQBridge(void);
-void DeinitRGXTQBridge(void);
+	IMG_HANDLE hTransferContext = psRGXSubmitTransfer3IN->hTransferContext;
+	RGX_SERVER_TQ_CONTEXT *psTransferContextInt = NULL;
+	IMG_UINT32 *ui32ClientUpdateCountInt = NULL;
+	SYNC_PRIMITIVE_BLOCK ***psUpdateUFOSyncPrimBlockInt = NULL;
+	IMG_HANDLE **hUpdateUFOSyncPrimBlockInt2 = NULL;
+	IMG_UINT32 **ui32UpdateSyncOffsetInt = NULL;
+	IMG_UINT32 **ui32UpdateValueInt = NULL;
+	IMG_CHAR *uiUpdateFenceNameInt = NULL;
+	IMG_UINT32 *ui32CommandSizeInt = NULL;
+	IMG_UINT8 **ui8FWCommandInt = NULL;
+	IMG_UINT32 *ui32TQPrepareFlagsInt = NULL;
+	IMG_UINT32 *ui32SyncPMRFlagsInt = NULL;
+	PMR **psSyncPMRsInt = NULL;
+	IMG_HANDLE *hSyncPMRsInt2 = NULL;
 
-/*
- * Register all RGXTQ functions with services
- */
-PVRSRV_ERROR InitRGXTQBridge(void)
-{
+	IMG_UINT32 ui32NextOffset = 0;
+	IMG_BYTE *pArrayArgsBuffer = NULL;
+	IMG_BYTE *pArrayArgsBuffer2 = NULL;
+	IMG_BOOL bHaveEnoughSpace = IMG_FALSE;
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXCREATETRANSFERCONTEXT,
-			      PVRSRVBridgeRGXCreateTransferContext, NULL);
+	IMG_UINT32 ui32BufferSize = 0;
+	IMG_UINT64 ui64BufferSize =
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) +
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) +
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *)) +
+	    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) + 0;
+	IMG_UINT32 ui32BufferSize2 = 0;
+	IMG_UINT32 ui32NextOffset2 = 0;
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXDESTROYTRANSFERCONTEXT,
-			      PVRSRVBridgeRGXDestroyTransferContext, NULL);
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
-			      PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPRIORITY,
-			      PVRSRVBridgeRGXSetTransferContextPriority, NULL);
+		ui64BufferSize +=
+		    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount *
+		     sizeof(SYNC_PRIMITIVE_BLOCK **));
+		ui64BufferSize +=
+		    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_HANDLE **));
+		ui64BufferSize +=
+		    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32 *));
+		ui64BufferSize +=
+		    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32 *));
+		ui64BufferSize +=
+		    ((IMG_UINT64) psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT8 *));
+	}
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER2,
-			      PVRSRVBridgeRGXSubmitTransfer2, NULL);
+	if (unlikely(psRGXSubmitTransfer3IN->ui32SyncPMRCount > PVRSRV_MAX_SYNCS))
+	{
+		psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+		goto RGXSubmitTransfer3_exit;
+	}
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQGETSHAREDMEMORY,
-			      PVRSRVBridgeRGXTQGetSharedMemory, NULL);
+	if (ui64BufferSize > IMG_UINT32_MAX)
+	{
+		psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+		goto RGXSubmitTransfer3_exit;
+	}
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQRELEASESHAREDMEMORY,
-			      PVRSRVBridgeRGXTQReleaseSharedMemory, NULL);
+	ui32BufferSize = (IMG_UINT32) ui64BufferSize;
 
-	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
-			      PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPROPERTY,
-			      PVRSRVBridgeRGXSetTransferContextProperty, NULL);
+	if (ui32BufferSize != 0)
+	{
+		/* Try to use remainder of input buffer for copies if possible, word-aligned for safety. */
+		IMG_UINT32 ui32InBufferOffset =
+		    PVR_ALIGN(sizeof(*psRGXSubmitTransfer3IN), sizeof(unsigned long));
+		IMG_UINT32 ui32InBufferExcessSize =
+		    ui32InBufferOffset >=
+		    PVRSRV_MAX_BRIDGE_IN_SIZE ? 0 : PVRSRV_MAX_BRIDGE_IN_SIZE - ui32InBufferOffset;
 
-	return PVRSRV_OK;
-}
+		bHaveEnoughSpace = ui32BufferSize <= ui32InBufferExcessSize;
+		if (bHaveEnoughSpace)
+		{
+			IMG_BYTE *pInputBuffer = (IMG_BYTE *) (void *)psRGXSubmitTransfer3IN;
 
-/*
- * Unregister all rgxtq functions with services
- */
-void DeinitRGXTQBridge(void)
-{
+			pArrayArgsBuffer = &pInputBuffer[ui32InBufferOffset];
+		}
+		else
+		{
+			pArrayArgsBuffer = OSAllocMemNoStats(ui32BufferSize);
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXCREATETRANSFERCONTEXT);
+			if (!pArrayArgsBuffer)
+			{
+				psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto RGXSubmitTransfer3_exit;
+			}
+		}
+	}
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXDESTROYTRANSFERCONTEXT);
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		ui32ClientUpdateCountInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32);
+	}
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
-				PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPRIORITY);
+	/* Copy the data over */
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32ClientUpdateCountInt,
+		     (const void __user *)psRGXSubmitTransfer3IN->pui32ClientUpdateCount,
+		     psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER2);
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		/* Assigning psUpdateUFOSyncPrimBlockInt to the right offset in the pool buffer for first dimension */
+		psUpdateUFOSyncPrimBlockInt =
+		    (SYNC_PRIMITIVE_BLOCK ***) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset +=
+		    psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(SYNC_PRIMITIVE_BLOCK **);
+		/* Assigning hUpdateUFOSyncPrimBlockInt2 to the right offset in the pool buffer for first dimension */
+		hUpdateUFOSyncPrimBlockInt2 =
+		    (IMG_HANDLE **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_HANDLE);
+	}
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQGETSHAREDMEMORY);
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		/* Assigning ui32UpdateSyncOffsetInt to the right offset in the pool buffer for first dimension */
+		ui32UpdateSyncOffsetInt =
+		    (IMG_UINT32 **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32 *);
+	}
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQRELEASESHAREDMEMORY);
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		/* Assigning ui32UpdateValueInt to the right offset in the pool buffer for first dimension */
+		ui32UpdateValueInt =
+		    (IMG_UINT32 **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32 *);
+	}
 
-	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
-				PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPROPERTY);
+	{
+		uiUpdateFenceNameInt =
+		    (IMG_CHAR *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR);
+	}
+
+	/* Copy the data over */
+	if (PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, uiUpdateFenceNameInt,
+		     (const void __user *)psRGXSubmitTransfer3IN->puiUpdateFenceName,
+		     PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXSubmitTransfer3_exit;
+		}
+		((IMG_CHAR *) uiUpdateFenceNameInt)[(PVRSRV_SYNC_NAME_LENGTH * sizeof(IMG_CHAR)) -
+						    1] = '\0';
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		ui32CommandSizeInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32CommandSizeInt,
+		     (const void __user *)psRGXSubmitTransfer3IN->pui32CommandSize,
+		     psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		/* Assigning ui8FWCommandInt to the right offset in the pool buffer for first dimension */
+		ui8FWCommandInt = (IMG_UINT8 **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT8 *);
+	}
+
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		ui32TQPrepareFlagsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32TQPrepareFlagsInt,
+		     (const void __user *)psRGXSubmitTransfer3IN->pui32TQPrepareFlags,
+		     psRGXSubmitTransfer3IN->ui32PrepareCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32SyncPMRCount != 0)
+	{
+		ui32SyncPMRFlagsInt =
+		    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32);
+	}
+
+	/* Copy the data over */
+	if (psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, ui32SyncPMRFlagsInt,
+		     (const void __user *)psRGXSubmitTransfer3IN->pui32SyncPMRFlags,
+		     psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_UINT32)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32SyncPMRCount != 0)
+	{
+		psSyncPMRsInt = (PMR **) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		OSCachedMemSet(psSyncPMRsInt, 0,
+			       psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *));
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(PMR *);
+		hSyncPMRsInt2 = (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer, ui32NextOffset);
+		ui32NextOffset += psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE);
+	}
+
+	/* Copy the data over */
+	if (psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE) > 0)
+	{
+		if (OSCopyFromUser
+		    (NULL, hSyncPMRsInt2, (const void __user *)psRGXSubmitTransfer3IN->phSyncPMRs,
+		     psRGXSubmitTransfer3IN->ui32SyncPMRCount * sizeof(IMG_HANDLE)) != PVRSRV_OK)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		IMG_UINT32 i;
+		ui64BufferSize = 0;
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			ui64BufferSize +=
+			    ((IMG_UINT64) ui32ClientUpdateCountInt[i] *
+			     sizeof(SYNC_PRIMITIVE_BLOCK *));
+			ui64BufferSize +=
+			    ((IMG_UINT64) ui32ClientUpdateCountInt[i] * sizeof(IMG_HANDLE *));
+			ui64BufferSize +=
+			    ((IMG_UINT64) ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32));
+			ui64BufferSize +=
+			    ((IMG_UINT64) ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32));
+			ui64BufferSize += ((IMG_UINT64) ui32CommandSizeInt[i] * sizeof(IMG_UINT8));
+		}
+		if (ui64BufferSize > IMG_UINT32_MAX)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_BRIDGE_BUFFER_TOO_SMALL;
+			goto RGXSubmitTransfer3_exit;
+		}
+		ui32BufferSize2 = (IMG_UINT32) ui64BufferSize;
+	}
+
+	if (ui32BufferSize2 != 0)
+	{
+		pArrayArgsBuffer2 = OSAllocMemNoStats(ui32BufferSize2);
+
+		if (!pArrayArgsBuffer2)
+		{
+			psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+			goto RGXSubmitTransfer3_exit;
+		}
+	}
+
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		IMG_UINT32 i;
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			if (ui32ClientUpdateCountInt[i] > PVRSRV_MAX_SYNCS)
+			{
+				psRGXSubmitTransfer3OUT->eError =
+				    PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Assigning each psUpdateUFOSyncPrimBlockInt to the right offset in the pool buffer (this is the second dimension) */
+			psUpdateUFOSyncPrimBlockInt[i] =
+			    (SYNC_PRIMITIVE_BLOCK **) IMG_OFFSET_ADDR(pArrayArgsBuffer2,
+								      ui32NextOffset2);
+			OSCachedMemSet(psUpdateUFOSyncPrimBlockInt[i], 0,
+				       ui32ClientUpdateCountInt[i] *
+				       sizeof(SYNC_PRIMITIVE_BLOCK *));
+			ui32NextOffset2 +=
+			    ui32ClientUpdateCountInt[i] * sizeof(SYNC_PRIMITIVE_BLOCK *);
+			/* Assigning each hUpdateUFOSyncPrimBlockInt2 to the right offset in the pool buffer (this is the second dimension) */
+			hUpdateUFOSyncPrimBlockInt2[i] =
+			    (IMG_HANDLE *) IMG_OFFSET_ADDR(pArrayArgsBuffer2, ui32NextOffset2);
+			ui32NextOffset2 += ui32ClientUpdateCountInt[i] * sizeof(IMG_HANDLE);
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		IMG_UINT32 i;
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Assigning each ui32UpdateSyncOffsetInt to the right offset in the pool buffer (this is the second dimension) */
+			ui32UpdateSyncOffsetInt[i] =
+			    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer2, ui32NextOffset2);
+			ui32NextOffset2 += ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32);
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		IMG_UINT32 i;
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Assigning each ui32UpdateValueInt to the right offset in the pool buffer (this is the second dimension) */
+			ui32UpdateValueInt[i] =
+			    (IMG_UINT32 *) IMG_OFFSET_ADDR(pArrayArgsBuffer2, ui32NextOffset2);
+			ui32NextOffset2 += ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32);
+		}
+	}
+	if (psRGXSubmitTransfer3IN->ui32PrepareCount != 0)
+	{
+		IMG_UINT32 i;
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			if (ui32CommandSizeInt[i] > RGXFWIF_DM_INDEPENDENT_KICK_CMD_SIZE)
+			{
+				psRGXSubmitTransfer3OUT->eError =
+				    PVRSRV_ERROR_BRIDGE_ARRAY_SIZE_TOO_BIG;
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Assigning each ui8FWCommandInt to the right offset in the pool buffer (this is the second dimension) */
+			ui8FWCommandInt[i] =
+			    (IMG_UINT8 *) IMG_OFFSET_ADDR(pArrayArgsBuffer2, ui32NextOffset2);
+			ui32NextOffset2 += ui32CommandSizeInt[i] * sizeof(IMG_UINT8);
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+		IMG_HANDLE **psPtr;
+
+		/* Loop over all the pointers in the array copying the data into the kernel */
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Copy the pointer over from the client side */
+			if (OSCopyFromUser
+			    (NULL, &psPtr,
+			     (const void __user *)&psRGXSubmitTransfer3IN->
+			     phUpdateUFOSyncPrimBlock[i], sizeof(IMG_HANDLE **)) != PVRSRV_OK)
+			{
+				psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Copy the data over */
+			if ((ui32ClientUpdateCountInt[i] * sizeof(IMG_HANDLE)) > 0)
+			{
+				if (OSCopyFromUser
+				    (NULL, (hUpdateUFOSyncPrimBlockInt2[i]),
+				     (const void __user *)psPtr,
+				     (ui32ClientUpdateCountInt[i] * sizeof(IMG_HANDLE))) !=
+				    PVRSRV_OK)
+				{
+					psRGXSubmitTransfer3OUT->eError =
+					    PVRSRV_ERROR_INVALID_PARAMS;
+
+					goto RGXSubmitTransfer3_exit;
+				}
+			}
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+		IMG_UINT32 **psPtr;
+
+		/* Loop over all the pointers in the array copying the data into the kernel */
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Copy the pointer over from the client side */
+			if (OSCopyFromUser
+			    (NULL, &psPtr,
+			     (const void __user *)&psRGXSubmitTransfer3IN->pui32UpdateSyncOffset[i],
+			     sizeof(IMG_UINT32 **)) != PVRSRV_OK)
+			{
+				psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Copy the data over */
+			if ((ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32)) > 0)
+			{
+				if (OSCopyFromUser
+				    (NULL, (ui32UpdateSyncOffsetInt[i]), (const void __user *)psPtr,
+				     (ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32))) !=
+				    PVRSRV_OK)
+				{
+					psRGXSubmitTransfer3OUT->eError =
+					    PVRSRV_ERROR_INVALID_PARAMS;
+
+					goto RGXSubmitTransfer3_exit;
+				}
+			}
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+		IMG_UINT32 **psPtr;
+
+		/* Loop over all the pointers in the array copying the data into the kernel */
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Copy the pointer over from the client side */
+			if (OSCopyFromUser
+			    (NULL, &psPtr,
+			     (const void __user *)&psRGXSubmitTransfer3IN->pui32UpdateValue[i],
+			     sizeof(IMG_UINT32 **)) != PVRSRV_OK)
+			{
+				psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Copy the data over */
+			if ((ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32)) > 0)
+			{
+				if (OSCopyFromUser
+				    (NULL, (ui32UpdateValueInt[i]), (const void __user *)psPtr,
+				     (ui32ClientUpdateCountInt[i] * sizeof(IMG_UINT32))) !=
+				    PVRSRV_OK)
+				{
+					psRGXSubmitTransfer3OUT->eError =
+					    PVRSRV_ERROR_INVALID_PARAMS;
+
+					goto RGXSubmitTransfer3_exit;
+				}
+			}
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+		IMG_UINT8 **psPtr;
+
+		/* Loop over all the pointers in the array copying the data into the kernel */
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			/* Copy the pointer over from the client side */
+			if (OSCopyFromUser
+			    (NULL, &psPtr,
+			     (const void __user *)&psRGXSubmitTransfer3IN->pui8FWCommand[i],
+			     sizeof(IMG_UINT8 **)) != PVRSRV_OK)
+			{
+				psRGXSubmitTransfer3OUT->eError = PVRSRV_ERROR_INVALID_PARAMS;
+
+				goto RGXSubmitTransfer3_exit;
+			}
+
+			/* Copy the data over */
+			if ((ui32CommandSizeInt[i] * sizeof(IMG_UINT8)) > 0)
+			{
+				if (OSCopyFromUser
+				    (NULL, (ui8FWCommandInt[i]), (const void __user *)psPtr,
+				     (ui32CommandSizeInt[i] * sizeof(IMG_UINT8))) != PVRSRV_OK)
+				{
+					psRGXSubmitTransfer3OUT->eError =
+					    PVRSRV_ERROR_INVALID_PARAMS;
+
+					goto RGXSubmitTransfer3_exit;
+				}
+			}
+		}
+	}
+
+	/* Lock over handle lookup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Look up the address from the handle */
+	psRGXSubmitTransfer3OUT->eError =
+	    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+				       (void **)&psTransferContextInt,
+				       hTransferContext,
+				       PVRSRV_HANDLE_TYPE_RGX_SERVER_TQ_CONTEXT, IMG_TRUE);
+	if (unlikely(psRGXSubmitTransfer3OUT->eError != PVRSRV_OK))
+	{
+		UnlockHandle(psConnection->psHandleBase);
+		goto RGXSubmitTransfer3_exit;
+	}
+
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			IMG_UINT32 j;
+			for (j = 0; j < ui32ClientUpdateCountInt[i]; j++)
+			{
+				/* Look up the address from the handle */
+				psRGXSubmitTransfer3OUT->eError =
+				    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+							       (void **)
+							       &psUpdateUFOSyncPrimBlockInt[i][j],
+							       hUpdateUFOSyncPrimBlockInt2[i][j],
+							       PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK,
+							       IMG_TRUE);
+				if (unlikely(psRGXSubmitTransfer3OUT->eError != PVRSRV_OK))
+				{
+					UnlockHandle(psConnection->psHandleBase);
+					goto RGXSubmitTransfer3_exit;
+				}
+			}
+		}
+	}
+
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32SyncPMRCount; i++)
+		{
+			/* Look up the address from the handle */
+			psRGXSubmitTransfer3OUT->eError =
+			    PVRSRVLookupHandleUnlocked(psConnection->psHandleBase,
+						       (void **)&psSyncPMRsInt[i],
+						       hSyncPMRsInt2[i],
+						       PVRSRV_HANDLE_TYPE_PHYSMEM_PMR, IMG_TRUE);
+			if (unlikely(psRGXSubmitTransfer3OUT->eError != PVRSRV_OK))
+			{
+				UnlockHandle(psConnection->psHandleBase);
+				goto RGXSubmitTransfer3_exit;
+			}
+		}
+	}
+	/* Release now we have looked up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	psRGXSubmitTransfer3OUT->eError =
+	    PVRSRVRGXSubmitTransfer3KM(psTransferContextInt,
+				       psRGXSubmitTransfer3IN->ui32PrepareCount,
+				       ui32ClientUpdateCountInt,
+				       psUpdateUFOSyncPrimBlockInt,
+				       ui32UpdateSyncOffsetInt,
+				       ui32UpdateValueInt,
+				       psRGXSubmitTransfer3IN->hCheckFenceFD,
+				       psRGXSubmitTransfer3IN->h2DUpdateTimeline,
+				       &psRGXSubmitTransfer3OUT->h2DUpdateFence,
+				       psRGXSubmitTransfer3IN->h3DUpdateTimeline,
+				       &psRGXSubmitTransfer3OUT->h3DUpdateFence,
+				       uiUpdateFenceNameInt,
+				       psRGXSubmitTransfer3IN->hExportFenceToSignal,
+				       ui32CommandSizeInt,
+				       ui8FWCommandInt,
+				       ui32TQPrepareFlagsInt,
+				       psRGXSubmitTransfer3IN->ui32ExtJobRef,
+				       psRGXSubmitTransfer3IN->ui32SyncPMRCount,
+				       ui32SyncPMRFlagsInt, psSyncPMRsInt);
+
+RGXSubmitTransfer3_exit:
+
+	/* Lock over handle lookup cleanup. */
+	LockHandle(psConnection->psHandleBase);
+
+	/* Unreference the previously looked up handle */
+	if (psTransferContextInt)
+	{
+		PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+					    hTransferContext,
+					    PVRSRV_HANDLE_TYPE_RGX_SERVER_TQ_CONTEXT);
+	}
+
+	if (hUpdateUFOSyncPrimBlockInt2)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32PrepareCount; i++)
+		{
+			IMG_UINT32 j;
+			for (j = 0; j < ui32ClientUpdateCountInt[i]; j++)
+			{
+
+				/* Unreference the previously looked up handle */
+				if (psUpdateUFOSyncPrimBlockInt && psUpdateUFOSyncPrimBlockInt[i]
+				    && psUpdateUFOSyncPrimBlockInt[i][j])
+				{
+					PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+								    hUpdateUFOSyncPrimBlockInt2[i]
+								    [j],
+								    PVRSRV_HANDLE_TYPE_SYNC_PRIMITIVE_BLOCK);
+				}
+			}
+		}
+	}
+
+	if (hSyncPMRsInt2)
+	{
+		IMG_UINT32 i;
+
+		for (i = 0; i < psRGXSubmitTransfer3IN->ui32SyncPMRCount; i++)
+		{
+
+			/* Unreference the previously looked up handle */
+			if (psSyncPMRsInt && psSyncPMRsInt[i])
+			{
+				PVRSRVReleaseHandleUnlocked(psConnection->psHandleBase,
+							    hSyncPMRsInt2[i],
+							    PVRSRV_HANDLE_TYPE_PHYSMEM_PMR);
+			}
+		}
+	}
+	/* Release now we have cleaned up look up handles. */
+	UnlockHandle(psConnection->psHandleBase);
+
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXSubmitTransfer3OUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize == ui32NextOffset);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (!bHaveEnoughSpace && pArrayArgsBuffer)
+		OSFreeMemNoStats(pArrayArgsBuffer);
+
+	/* Allocated space should be equal to the last updated offset */
+#ifdef PVRSRV_NEED_PVR_ASSERT
+	if (psRGXSubmitTransfer3OUT->eError == PVRSRV_OK)
+		PVR_ASSERT(ui32BufferSize2 == ui32NextOffset2);
+#endif /* PVRSRV_NEED_PVR_ASSERT */
+
+	if (pArrayArgsBuffer2)
+		OSFreeMemNoStats(pArrayArgsBuffer2);
+
+	return 0;
+}
+
+/* ***************************************************************************
+ * Server bridge dispatch related glue
+ */
+
+#endif /* SUPPORT_RGXTQ_BRIDGE */
+
+#if defined(SUPPORT_RGXTQ_BRIDGE)
+PVRSRV_ERROR InitRGXTQBridge(void);
+void DeinitRGXTQBridge(void);
+
+/*
+ * Register all RGXTQ functions with services
+ */
+PVRSRV_ERROR InitRGXTQBridge(void)
+{
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXCREATETRANSFERCONTEXT,
+			      PVRSRVBridgeRGXCreateTransferContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXCREATETRANSFERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXCREATETRANSFERCONTEXT));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXDESTROYTRANSFERCONTEXT,
+			      PVRSRVBridgeRGXDestroyTransferContext, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXDESTROYTRANSFERCONTEXT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXDESTROYTRANSFERCONTEXT));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
+			      PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPRIORITY,
+			      PVRSRVBridgeRGXSetTransferContextPriority, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETTRANSFERCONTEXTPRIORITY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETTRANSFERCONTEXTPRIORITY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER2,
+			      PVRSRVBridgeRGXSubmitTransfer2, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER2),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER2));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQGETSHAREDMEMORY,
+			      PVRSRVBridgeRGXTQGetSharedMemory, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTQGETSHAREDMEMORY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQRELEASESHAREDMEMORY,
+			      PVRSRVBridgeRGXTQReleaseSharedMemory, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXTQRELEASESHAREDMEMORY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXTQRELEASESHAREDMEMORY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
+			      PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPROPERTY,
+			      PVRSRVBridgeRGXSetTransferContextProperty, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSETTRANSFERCONTEXTPROPERTY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSETTRANSFERCONTEXTPROPERTY));
+
+	SetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER3,
+			      PVRSRVBridgeRGXSubmitTransfer3, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RGXSUBMITTRANSFER3),
+			      sizeof(PVRSRV_BRIDGE_OUT_RGXSUBMITTRANSFER3));
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Unregister all rgxtq functions with services
+ */
+void DeinitRGXTQBridge(void)
+{
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXCREATETRANSFERCONTEXT);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXDESTROYTRANSFERCONTEXT);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
+				PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPRIORITY);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER2);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQGETSHAREDMEMORY);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXTQRELEASESHAREDMEMORY);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ,
+				PVRSRV_BRIDGE_RGXTQ_RGXSETTRANSFERCONTEXTPROPERTY);
+
+	UnsetDispatchTableEntry(PVRSRV_BRIDGE_RGXTQ, PVRSRV_BRIDGE_RGXTQ_RGXSUBMITTRANSFER3);
 
 }
 #else /* SUPPORT_RGXTQ_BRIDGE */
diff --git a/drivers/gpu/drm/img-rogue/server_ri_bridge.c b/drivers/gpu/drm/img-rogue/server_ri_bridge.c
index 122c2ac61473..f8a54d70ef0c 100644
--- a/drivers/gpu/drm/img-rogue/server_ri_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_ri_bridge.c
@@ -230,13 +230,13 @@ PVRSRVBridgeRIWriteMEMDESCEntry(IMG_UINT32 ui32DispatchTableEntry,
 	UnlockHandle(psConnection->psHandleBase);
 
 	psRIWriteMEMDESCEntryOUT->eError =
-	    RIWriteMEMDESCEntryKM(psPMRHandleInt,
+	    RIWriteMEMDESCEntryKM(psConnection, OSGetDevNode(psConnection),
+				  psPMRHandleInt,
 				  psRIWriteMEMDESCEntryIN->ui32TextBSize,
 				  uiTextBInt,
 				  psRIWriteMEMDESCEntryIN->ui64Offset,
 				  psRIWriteMEMDESCEntryIN->ui64Size,
-				  psRIWriteMEMDESCEntryIN->bIsImport,
-				  psRIWriteMEMDESCEntryIN->bIsSuballoc, &psRIHandleInt);
+				  psRIWriteMEMDESCEntryIN->ui64Flags, &psRIHandleInt);
 	/* Exit early if bridged call fails */
 	if (unlikely(psRIWriteMEMDESCEntryOUT->eError != PVRSRV_OK))
 	{
@@ -689,31 +689,47 @@ PVRSRV_ERROR InitRIBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIWRITEPMRENTRY,
-			      PVRSRVBridgeRIWritePMREntry, NULL);
+			      PVRSRVBridgeRIWritePMREntry, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIWRITEPMRENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIWRITEPMRENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIWRITEMEMDESCENTRY,
-			      PVRSRVBridgeRIWriteMEMDESCEntry, NULL);
+			      PVRSRVBridgeRIWriteMEMDESCEntry, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIWRITEMEMDESCENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIWRITEMEMDESCENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIWRITEPROCLISTENTRY,
-			      PVRSRVBridgeRIWriteProcListEntry, NULL);
+			      PVRSRVBridgeRIWriteProcListEntry, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIWRITEPROCLISTENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIWRITEPROCLISTENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIUPDATEMEMDESCADDR,
-			      PVRSRVBridgeRIUpdateMEMDESCAddr, NULL);
+			      PVRSRVBridgeRIUpdateMEMDESCAddr, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIUPDATEMEMDESCADDR),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIUPDATEMEMDESCADDR));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIDELETEMEMDESCENTRY,
-			      PVRSRVBridgeRIDeleteMEMDESCEntry, NULL);
+			      PVRSRVBridgeRIDeleteMEMDESCEntry, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIDELETEMEMDESCENTRY),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIDELETEMEMDESCENTRY));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIDUMPLIST, PVRSRVBridgeRIDumpList,
-			      NULL);
+			      NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIDUMPLIST),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIDUMPLIST));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIDUMPALL, PVRSRVBridgeRIDumpAll,
-			      NULL);
+			      NULL, 0, sizeof(PVRSRV_BRIDGE_OUT_RIDUMPALL));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIDUMPPROCESS,
-			      PVRSRVBridgeRIDumpProcess, NULL);
+			      PVRSRVBridgeRIDumpProcess, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIDUMPPROCESS),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIDUMPPROCESS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_RI, PVRSRV_BRIDGE_RI_RIWRITEPMRENTRYWITHOWNER,
-			      PVRSRVBridgeRIWritePMREntryWithOwner, NULL);
+			      PVRSRVBridgeRIWritePMREntryWithOwner, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RIWRITEPMRENTRYWITHOWNER),
+			      sizeof(PVRSRV_BRIDGE_OUT_RIWRITEPMRENTRYWITHOWNER));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_srvcore_bridge.c b/drivers/gpu/drm/img-rogue/server_srvcore_bridge.c
index 708a143c0cb2..350cfa5e8fc1 100644
--- a/drivers/gpu/drm/img-rogue/server_srvcore_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_srvcore_bridge.c
@@ -954,55 +954,82 @@ PVRSRV_ERROR InitSRVCOREBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_CONNECT,
-			      PVRSRVBridgeConnect, NULL);
+			      PVRSRVBridgeConnect, NULL, sizeof(PVRSRV_BRIDGE_IN_CONNECT),
+			      sizeof(PVRSRV_BRIDGE_OUT_CONNECT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_DISCONNECT,
-			      PVRSRVBridgeDisconnect, NULL);
+			      PVRSRVBridgeDisconnect, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_DISCONNECT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_ACQUIREGLOBALEVENTOBJECT,
-			      PVRSRVBridgeAcquireGlobalEventObject, NULL);
+			      PVRSRVBridgeAcquireGlobalEventObject, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_ACQUIREGLOBALEVENTOBJECT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_RELEASEGLOBALEVENTOBJECT,
-			      PVRSRVBridgeReleaseGlobalEventObject, NULL);
+			      PVRSRVBridgeReleaseGlobalEventObject, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RELEASEGLOBALEVENTOBJECT),
+			      sizeof(PVRSRV_BRIDGE_OUT_RELEASEGLOBALEVENTOBJECT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_EVENTOBJECTOPEN,
-			      PVRSRVBridgeEventObjectOpen, NULL);
+			      PVRSRVBridgeEventObjectOpen, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_EVENTOBJECTOPEN),
+			      sizeof(PVRSRV_BRIDGE_OUT_EVENTOBJECTOPEN));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_EVENTOBJECTWAIT,
-			      PVRSRVBridgeEventObjectWait, NULL);
+			      PVRSRVBridgeEventObjectWait, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_EVENTOBJECTWAIT),
+			      sizeof(PVRSRV_BRIDGE_OUT_EVENTOBJECTWAIT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_EVENTOBJECTCLOSE,
-			      PVRSRVBridgeEventObjectClose, NULL);
+			      PVRSRVBridgeEventObjectClose, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_EVENTOBJECTCLOSE),
+			      sizeof(PVRSRV_BRIDGE_OUT_EVENTOBJECTCLOSE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_DUMPDEBUGINFO,
-			      PVRSRVBridgeDumpDebugInfo, NULL);
+			      PVRSRVBridgeDumpDebugInfo, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_DUMPDEBUGINFO),
+			      sizeof(PVRSRV_BRIDGE_OUT_DUMPDEBUGINFO));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_GETDEVCLOCKSPEED,
-			      PVRSRVBridgeGetDevClockSpeed, NULL);
+			      PVRSRVBridgeGetDevClockSpeed, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_GETDEVCLOCKSPEED));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_HWOPTIMEOUT,
-			      PVRSRVBridgeHWOpTimeout, NULL);
+			      PVRSRVBridgeHWOpTimeout, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_HWOPTIMEOUT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_ALIGNMENTCHECK,
-			      PVRSRVBridgeAlignmentCheck, NULL);
+			      PVRSRVBridgeAlignmentCheck, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_ALIGNMENTCHECK),
+			      sizeof(PVRSRV_BRIDGE_OUT_ALIGNMENTCHECK));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_GETDEVICESTATUS,
-			      PVRSRVBridgeGetDeviceStatus, NULL);
+			      PVRSRVBridgeGetDeviceStatus, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_GETDEVICESTATUS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_GETMULTICOREINFO,
-			      PVRSRVBridgeGetMultiCoreInfo, NULL);
+			      PVRSRVBridgeGetMultiCoreInfo, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_GETMULTICOREINFO),
+			      sizeof(PVRSRV_BRIDGE_OUT_GETMULTICOREINFO));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_EVENTOBJECTWAITTIMEOUT,
-			      PVRSRVBridgeEventObjectWaitTimeout, NULL);
+			      PVRSRVBridgeEventObjectWaitTimeout, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_EVENTOBJECTWAITTIMEOUT),
+			      sizeof(PVRSRV_BRIDGE_OUT_EVENTOBJECTWAITTIMEOUT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_FINDPROCESSMEMSTATS,
-			      PVRSRVBridgeFindProcessMemStats, NULL);
+			      PVRSRVBridgeFindProcessMemStats, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_FINDPROCESSMEMSTATS),
+			      sizeof(PVRSRV_BRIDGE_OUT_FINDPROCESSMEMSTATS));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_ACQUIREINFOPAGE,
-			      PVRSRVBridgeAcquireInfoPage, NULL);
+			      PVRSRVBridgeAcquireInfoPage, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_ACQUIREINFOPAGE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SRVCORE, PVRSRV_BRIDGE_SRVCORE_RELEASEINFOPAGE,
-			      PVRSRVBridgeReleaseInfoPage, NULL);
+			      PVRSRVBridgeReleaseInfoPage, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_RELEASEINFOPAGE),
+			      sizeof(PVRSRV_BRIDGE_OUT_RELEASEINFOPAGE));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_sync_bridge.c b/drivers/gpu/drm/img-rogue/server_sync_bridge.c
index 2b48d10f16f1..a0d9210086c9 100644
--- a/drivers/gpu/drm/img-rogue/server_sync_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_sync_bridge.c
@@ -167,17 +167,16 @@ PVRSRVBridgeAllocSyncPrimitiveBlock(IMG_UINT32 ui32DispatchTableEntry,
 			 * This should never fail... */
 			PVR_ASSERT((eError == PVRSRV_OK) || (eError == PVRSRV_ERROR_RETRY));
 
-			/* Avoid freeing/destroying/releasing the resource a second time below */
-			psSyncHandleInt = NULL;
 			/* Release now we have cleaned up creation handles. */
 			UnlockHandle(psConnection->psHandleBase);
 
 		}
 
-		if (psSyncHandleInt)
+		else if (psSyncHandleInt)
 		{
 			PVRSRVFreeSyncPrimitiveBlockKM(psSyncHandleInt);
 		}
+
 	}
 
 	return 0;
@@ -675,35 +674,53 @@ PVRSRV_ERROR InitSYNCBridge(void)
 {
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_ALLOCSYNCPRIMITIVEBLOCK,
-			      PVRSRVBridgeAllocSyncPrimitiveBlock, NULL);
+			      PVRSRVBridgeAllocSyncPrimitiveBlock, NULL, 0,
+			      sizeof(PVRSRV_BRIDGE_OUT_ALLOCSYNCPRIMITIVEBLOCK));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_FREESYNCPRIMITIVEBLOCK,
-			      PVRSRVBridgeFreeSyncPrimitiveBlock, NULL);
+			      PVRSRVBridgeFreeSyncPrimitiveBlock, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_FREESYNCPRIMITIVEBLOCK),
+			      sizeof(PVRSRV_BRIDGE_OUT_FREESYNCPRIMITIVEBLOCK));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCPRIMSET,
-			      PVRSRVBridgeSyncPrimSet, NULL);
+			      PVRSRVBridgeSyncPrimSet, NULL, sizeof(PVRSRV_BRIDGE_IN_SYNCPRIMSET),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCPRIMSET));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCPRIMPDUMP,
-			      PVRSRVBridgeSyncPrimPDump, NULL);
+			      PVRSRVBridgeSyncPrimPDump, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCPRIMPDUMP),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCPRIMPDUMP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCPRIMPDUMPVALUE,
-			      PVRSRVBridgeSyncPrimPDumpValue, NULL);
+			      PVRSRVBridgeSyncPrimPDumpValue, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCPRIMPDUMPVALUE),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCPRIMPDUMPVALUE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCPRIMPDUMPPOL,
-			      PVRSRVBridgeSyncPrimPDumpPol, NULL);
+			      PVRSRVBridgeSyncPrimPDumpPol, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCPRIMPDUMPPOL),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCPRIMPDUMPPOL));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCPRIMPDUMPCBP,
-			      PVRSRVBridgeSyncPrimPDumpCBP, NULL);
+			      PVRSRVBridgeSyncPrimPDumpCBP, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCPRIMPDUMPCBP),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCPRIMPDUMPCBP));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCALLOCEVENT,
-			      PVRSRVBridgeSyncAllocEvent, NULL);
+			      PVRSRVBridgeSyncAllocEvent, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCALLOCEVENT),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCALLOCEVENT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC, PVRSRV_BRIDGE_SYNC_SYNCFREEEVENT,
-			      PVRSRVBridgeSyncFreeEvent, NULL);
+			      PVRSRVBridgeSyncFreeEvent, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCFREEEVENT),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCFREEEVENT));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNC,
 			      PVRSRV_BRIDGE_SYNC_SYNCCHECKPOINTSIGNALLEDPDUMPPOL,
-			      PVRSRVBridgeSyncCheckpointSignalledPDumpPol, NULL);
+			      PVRSRVBridgeSyncCheckpointSignalledPDumpPol, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCCHECKPOINTSIGNALLEDPDUMPPOL),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCCHECKPOINTSIGNALLEDPDUMPPOL));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/server_synctracking_bridge.c b/drivers/gpu/drm/img-rogue/server_synctracking_bridge.c
index 93d674bde379..06757e5ef8d3 100644
--- a/drivers/gpu/drm/img-rogue/server_synctracking_bridge.c
+++ b/drivers/gpu/drm/img-rogue/server_synctracking_bridge.c
@@ -302,10 +302,14 @@ PVRSRV_ERROR InitSYNCTRACKINGBridge(void)
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNCTRACKING,
 			      PVRSRV_BRIDGE_SYNCTRACKING_SYNCRECORDREMOVEBYHANDLE,
-			      PVRSRVBridgeSyncRecordRemoveByHandle, NULL);
+			      PVRSRVBridgeSyncRecordRemoveByHandle, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCRECORDREMOVEBYHANDLE),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCRECORDREMOVEBYHANDLE));
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SYNCTRACKING, PVRSRV_BRIDGE_SYNCTRACKING_SYNCRECORDADD,
-			      PVRSRVBridgeSyncRecordAdd, NULL);
+			      PVRSRVBridgeSyncRecordAdd, NULL,
+			      sizeof(PVRSRV_BRIDGE_IN_SYNCRECORDADD),
+			      sizeof(PVRSRV_BRIDGE_OUT_SYNCRECORDADD));
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/img-rogue/services_kernel_client.h b/drivers/gpu/drm/img-rogue/services_kernel_client.h
index 8b66fcb6dea5..3cfa23116a20 100644
--- a/drivers/gpu/drm/img-rogue/services_kernel_client.h
+++ b/drivers/gpu/drm/img-rogue/services_kernel_client.h
@@ -58,6 +58,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 /* included for the define PVRSRV_LINUX_DEV_INIT_ON_PROBE */
 #include "pvr_drm.h"
 
+#include "pvr_dma_resv.h"
+
 #ifndef __pvrsrv_defined_struct_enum__
 
 /* sync_external.h */
@@ -83,6 +85,7 @@ struct PVRSRV_CLIENT_SYNC_PRIM_OP;
 struct _PMR_;
 struct _PVRSRV_DEVICE_NODE_;
 struct dma_buf;
+struct dma_resv;
 struct SYNC_PRIM_CONTEXT_TAG;
 
 /* pvr_notifier.h */
@@ -140,6 +143,8 @@ enum PVRSRV_ERROR_TAG PVRSRVUnregisterDriverDbgRequestNotify(void *hNotify);
 
 struct dma_buf *PhysmemGetDmaBuf(struct _PMR_ *psPMR);
 
+struct dma_resv *PhysmemGetDmaResv(struct _PMR_ *psPMR);
+
 /* pvrsrv.h */
 
 enum PVRSRV_ERROR_TAG PVRSRVAcquireGlobalEventObjectKM(void **phGlobalEventObject);
@@ -182,6 +187,9 @@ enum PVRSRV_ERROR_TAG PVRSRVCommonDeviceInitialise(
 #ifndef CHECKPOINT_PFNS
 typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_RESOLVE_FN)(PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext, PVRSRV_FENCE fence, u32 *nr_checkpoints, PSYNC_CHECKPOINT **checkpoint_handles, u64 *fence_uid);
 
+typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_EXPORT_FENCE_RESOLVE_FN)(PVRSRV_FENCE export_fence, PSYNC_CHECKPOINT_CONTEXT checkpoint_context, PSYNC_CHECKPOINT *checkpoint_handle);
+typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_EXPORT_FENCE_ROLLBACK_FN)(PVRSRV_FENCE export_fence);
+
 #ifndef CHECKPOINT_PFNS
 typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_CREATE_FN)(
 		struct _PVRSRV_DEVICE_NODE_ *device,
@@ -227,6 +235,7 @@ typedef PVRSRV_ERROR(*PFN_SYNC_CHECKPOINT_FENCE_GETCHECKPOINTS_FN)(PVRSRV_FENCE
  */
 #ifndef CHECKPOINT_PFNS
 typedef void (*PFN_SYNC_CHECKPOINT_NOHW_UPDATE_TIMELINES_FN)(void *private_data);
+typedef void (*PFN_SYNC_CHECKPOINT_NOHW_SIGNAL_EXPORT_FENCE_FN)(PVRSRV_FENCE fence_to_signal);
 typedef void (*PFN_SYNC_CHECKPOINT_FREE_CHECKPOINT_LIST_MEM_FN)(void *mem_ptr);
 
 #define SYNC_CHECKPOINT_IMPL_MAX_STRLEN 20
@@ -237,12 +246,15 @@ typedef struct {
 	PFN_SYNC_CHECKPOINT_FENCE_ROLLBACK_DATA_FN pfnFenceDataRollback;
 	PFN_SYNC_CHECKPOINT_FENCE_FINALISE_FN pfnFenceFinalise;
 	PFN_SYNC_CHECKPOINT_NOHW_UPDATE_TIMELINES_FN pfnNoHWUpdateTimelines;
+	PFN_SYNC_CHECKPOINT_NOHW_SIGNAL_EXPORT_FENCE_FN pfnNoHWSignalExpFence;
 	PFN_SYNC_CHECKPOINT_FREE_CHECKPOINT_LIST_MEM_FN pfnFreeCheckpointListMem;
 	PFN_SYNC_CHECKPOINT_DUMP_INFO_ON_STALLED_UFOS_FN pfnDumpInfoOnStalledUFOs;
 	char pszImplName[SYNC_CHECKPOINT_IMPL_MAX_STRLEN];
 #if defined(PDUMP)
 	PFN_SYNC_CHECKPOINT_FENCE_GETCHECKPOINTS_FN pfnSyncFenceGetCheckpoints;
 #endif
+	PFN_SYNC_CHECKPOINT_EXPORT_FENCE_RESOLVE_FN pfnExportFenceResolve;
+	PFN_SYNC_CHECKPOINT_EXPORT_FENCE_ROLLBACK_FN pfnExportFenceRollback;
 } PFN_SYNC_CHECKPOINT_STRUCT;
 
 enum PVRSRV_ERROR_TAG SyncCheckpointRegisterFunctions(PFN_SYNC_CHECKPOINT_STRUCT *psSyncCheckpointPfns);
diff --git a/drivers/gpu/drm/img-rogue/servicesext.h b/drivers/gpu/drm/img-rogue/servicesext.h
index f2d09b71cf8a..f2887d48aed7 100644
--- a/drivers/gpu/drm/img-rogue/servicesext.h
+++ b/drivers/gpu/drm/img-rogue/servicesext.h
@@ -114,40 +114,6 @@ typedef IMG_UINT32 PVRSRV_POWER_FLAGS;
                                                            transition has been requested.
                                                            Allows system modules to load VRAM */
 
-/* Clock speed handler prototypes */
-
-/*!
-  Typedef for a pointer to a Function that will be called before a transition
-  from one clock speed to another. See also PFN_POST_CLOCKSPEED_CHANGE.
- */
-typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
-												   PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
-
-/*!
-  Typedef for a pointer to a Function that will be called after a transition
-  from one clock speed to another. See also PFN_PRE_CLOCKSPEED_CHANGE.
- */
-typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE				hDevHandle,
-													PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
-
-/*!
-  Typedef for a pointer to a function that will be called to transition the
-  device to a forced idle state. Used in unison with (forced) power requests,
-  DVFS and cluster count changes.
- */
-typedef PVRSRV_ERROR (*PFN_FORCED_IDLE_REQUEST) (IMG_HANDLE		hDevHandle,
-												 IMG_BOOL		bDeviceOffPermitted);
-
-/*!
-  Typedef for a pointer to a function that will be called to cancel a forced
-  idle state and return the firmware back to a state where the hardware can be
-  scheduled.
- */
-typedef PVRSRV_ERROR (*PFN_FORCED_IDLE_CANCEL_REQUEST) (IMG_HANDLE	hDevHandle);
-
-typedef PVRSRV_ERROR (*PFN_GPU_UNITS_POWER_CHANGE) (IMG_HANDLE		hDevHandle,
-													IMG_UINT32		ui32SESPowerState);
-
 /*!
  *****************************************************************************
  * This structure is used for OS independent registry (profile) access
diff --git a/drivers/gpu/drm/img-rogue/spacemit/sysconfig.c b/drivers/gpu/drm/img-rogue/spacemit/sysconfig.c
index 6a3690fb8d87..ca37ba921245 100644
--- a/drivers/gpu/drm/img-rogue/spacemit/sysconfig.c
+++ b/drivers/gpu/drm/img-rogue/spacemit/sysconfig.c
@@ -126,10 +126,10 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 	gsPhysHeapFuncs.pfnCpuPAddrToDevPAddr = UMAPhysHeapCpuPAddrToDevPAddr;
 	gsPhysHeapFuncs.pfnDevPAddrToCpuPAddr = UMAPhysHeapDevPAddrToCpuPAddr;
 
-	gsPhysHeapConfig[0].pszPDumpMemspaceName = "SYSMEM";
+	gsPhysHeapConfig[0].uConfig.sUMA.pszPDumpMemspaceName = "SYSMEM";
 	gsPhysHeapConfig[0].eType = PHYS_HEAP_TYPE_UMA;
-	gsPhysHeapConfig[0].psMemFuncs = &gsPhysHeapFuncs;
-	gsPhysHeapConfig[0].hPrivData = NULL;
+	gsPhysHeapConfig[0].uConfig.sUMA.psMemFuncs = &gsPhysHeapFuncs;
+	gsPhysHeapConfig[0].uConfig.sUMA.hPrivData = NULL;
 	gsPhysHeapConfig[0].ui32UsageFlags = PHYS_HEAP_USAGE_GPU_LOCAL;
 	ui32NextPhysHeapID += 1;
 
@@ -216,10 +216,10 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 #endif
 
 	/* Virtualization support services needs to know which heap ID corresponds to FW */
-	gsPhysHeapConfig[ui32NextPhysHeapID].pszPDumpMemspaceName = "SYSMEM";
+	gsPhysHeapConfig[ui32NextPhysHeapID].uConfig.sUMA.pszPDumpMemspaceName = "SYSMEM";
 	gsPhysHeapConfig[ui32NextPhysHeapID].eType = PHYS_HEAP_TYPE_UMA;
-	gsPhysHeapConfig[ui32NextPhysHeapID].psMemFuncs = &gsPhysHeapFuncs;
-	gsPhysHeapConfig[ui32NextPhysHeapID].hPrivData = NULL;
+	gsPhysHeapConfig[ui32NextPhysHeapID].uConfig.sUMA.psMemFuncs = &gsPhysHeapFuncs;
+	gsPhysHeapConfig[ui32NextPhysHeapID].uConfig.sUMA.hPrivData = NULL;
 	gsPhysHeapConfig[ui32NextPhysHeapID].ui32UsageFlags = PHYS_HEAP_USAGE_FW_SHARED;
 	gsDevices[0].ui32PhysHeapCount = ++ui32NextPhysHeapID;
 
diff --git a/drivers/gpu/drm/img-rogue/spacemit/sysinfo.h b/drivers/gpu/drm/img-rogue/spacemit/sysinfo.h
index 57046a00c203..d5184b21b654 100644
--- a/drivers/gpu/drm/img-rogue/spacemit/sysinfo.h
+++ b/drivers/gpu/drm/img-rogue/spacemit/sysinfo.h
@@ -48,6 +48,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define DEVICES_WATCHDOG_POWER_ON_SLEEP_TIMEOUT  (3000)
 #define DEVICES_WATCHDOG_POWER_OFF_SLEEP_TIMEOUT (3600000)
 #define WAIT_TRY_COUNT                           (10000)
+#define EVENT_OBJECT_TIMEOUT_US                  (100000)
 
 #define SYS_RGX_OF_COMPATIBLE "img,rgx"
 
diff --git a/drivers/gpu/drm/img-rogue/srvcore.c b/drivers/gpu/drm/img-rogue/srvcore.c
index 75624f3bb3ac..203c89adda15 100644
--- a/drivers/gpu/drm/img-rogue/srvcore.c
+++ b/drivers/gpu/drm/img-rogue/srvcore.c
@@ -291,27 +291,6 @@ CopyToUserWrapper(CONNECTION_DATA *psConnection,
 
 	return OSBridgeCopyToUser(psConnection, pvDest, pvSrc, ui32Size);
 }
-#else
-INLINE PVRSRV_ERROR
-CopyFromUserWrapper(CONNECTION_DATA *psConnection,
-					IMG_UINT32 ui32DispatchTableEntry,
-					void *pvDest,
-					void __user *pvSrc,
-					IMG_UINT32 ui32Size)
-{
-	PVR_UNREFERENCED_PARAMETER (ui32DispatchTableEntry);
-	return OSBridgeCopyFromUser(psConnection, pvDest, pvSrc, ui32Size);
-}
-INLINE PVRSRV_ERROR
-CopyToUserWrapper(CONNECTION_DATA *psConnection,
-				  IMG_UINT32 ui32DispatchTableEntry,
-				  void __user *pvDest,
-				  void *pvSrc,
-				  IMG_UINT32 ui32Size)
-{
-	PVR_UNREFERENCED_PARAMETER (ui32DispatchTableEntry);
-	return OSBridgeCopyToUser(psConnection, pvDest, pvSrc, ui32Size);
-}
 #endif
 
 /**************************************************************************/ /*!
@@ -465,11 +444,6 @@ PVRSRVConnectKM(CONNECTION_DATA *psConnection,
 		{
 			*pui32CapabilityFlags |= PVRSRV_CACHE_COHERENT_DEVICE_FLAG;
 		}
-		/*Is the system device cache coherent?*/
-		if (PVRSRVSystemSnoopingOfDeviceCache(psDeviceNode->psDevConfig))
-		{
-			*pui32CapabilityFlags |= PVRSRV_CACHE_COHERENT_CPU_FLAG;
-		}
 	}
 
 	/* Has the system device non-mappable local memory?*/
@@ -504,7 +478,7 @@ PVRSRVConnectKM(CONNECTION_DATA *psConnection,
 	}
 
 	/* Is the system DMA capable? */
-	if (psDeviceNode->bHasSystemDMA)
+	if (psDeviceNode->psDevConfig->bHasDma)
 	{
 		*pui32CapabilityFlags |= PVRSRV_SYSTEM_DMA_USED;
 	}
@@ -734,7 +708,7 @@ PVRSRVConnectKM(CONNECTION_DATA *psConnection,
 		                        PVRSRV_CLIENT_TL_STREAM_SIZE_DEFAULT,
 		                        TL_OPMODE_DROP_NEWER |
 		                        TL_FLAG_ALLOCATE_ON_FIRST_OPEN,
-		                        NULL, NULL, NULL, NULL);
+		                        NULL, NULL, NULL, NULL, NULL, NULL);
 		if (eError != PVRSRV_OK && eError != PVRSRV_ERROR_ALREADY_EXISTS)
 		{
 			PVR_LOG_ERROR(eError, "TLStreamCreate");
@@ -911,6 +885,8 @@ PVRSRVDumpDebugInfoKM(CONNECTION_DATA *psConnection,
 					  PVRSRV_DEVICE_NODE *psDeviceNode,
 					  IMG_UINT32 ui32VerbLevel)
 {
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 	if (ui32VerbLevel > DEBUG_REQUEST_VERBOSITY_MAX)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -949,6 +925,8 @@ PVRSRV_ERROR
 PVRSRVHWOpTimeoutKM(CONNECTION_DATA *psConnection,
 					PVRSRV_DEVICE_NODE *psDeviceNode)
 {
+	PVR_UNREFERENCED_PARAMETER(psConnection);
+
 #if defined(PVRSRV_RESET_ON_HWTIMEOUT)
 	PVR_LOG(("User requested OS reset"));
 	OSPanic();
@@ -1111,6 +1089,10 @@ UnsetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup, IMG_UINT32 ui32Index)
  * @param pszIOCName
  * @param pfFunction
  * @param pszFunctionName
+ * @param hBridgeLock
+ * @param pszBridgeLockName
+ * @param ui32InBufferSize
+ * @param ui32OutBufferSize
  *
  * @return
  ********************************************************************************/
@@ -1121,7 +1103,9 @@ _SetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup,
 					   BridgeWrapperFunction pfFunction,
 					   const IMG_CHAR *pszFunctionName,
 					   POS_LOCK hBridgeLock,
-					   const IMG_CHAR *pszBridgeLockName)
+					   const IMG_CHAR *pszBridgeLockName,
+					   IMG_UINT32 ui32InBufferSize,
+					   IMG_UINT32 ui32OutBufferSize)
 {
 	static IMG_UINT32 ui32PrevIndex = IMG_UINT32_MAX;		/* -1 */
 
@@ -1238,6 +1222,8 @@ _SetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup,
 	{
 		g_BridgeDispatchTable[ui32Index].pfFunction = pfFunction;
 		g_BridgeDispatchTable[ui32Index].hBridgeLock = hBridgeLock;
+		g_BridgeDispatchTable[ui32Index].ui32InBufferSize = ui32InBufferSize;
+		g_BridgeDispatchTable[ui32Index].ui32OutBufferSize = ui32OutBufferSize;
 #if defined(DEBUG_BRIDGE_KM)
 		g_BridgeDispatchTable[ui32Index].pszIOCName = pszIOCName;
 		g_BridgeDispatchTable[ui32Index].pszFunctionName = pszFunctionName;
@@ -1398,18 +1384,26 @@ PVRSRV_ERROR BridgedDispatchKM(CONNECTION_DATA * psConnection,
 #if defined(DEBUG_BRIDGE_KM)
 	BridgeGlobalStatsLock();
 
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: Dispatch table entry index=%d, (bridge module %d, function %d)",
-			__func__,
+	PVR_DPF((PVR_DBG_MESSAGE, "%s: %s idx:%d mod:%d, func:%d",
+			__func__, g_BridgeDispatchTable[ui32DispatchTableEntryIndex].pszIOCName,
 			ui32DispatchTableEntryIndex, psBridgePackageKM->ui32BridgeID, psBridgePackageKM->ui32FunctionID));
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: %s",
-			 __func__,
-			 g_BridgeDispatchTable[ui32DispatchTableEntryIndex].pszIOCName));
 
 	g_BridgeDispatchTable[ui32DispatchTableEntryIndex].ui32CallCount++;
 	g_BridgeGlobalStats.ui32IOCTLCount++;
 	BridgeGlobalStatsUnlock();
 #endif
 
+	if (psBridgePackageKM->ui32InBufferSize != g_BridgeDispatchTable[ui32DispatchTableEntryIndex].ui32InBufferSize ||
+	    psBridgePackageKM->ui32OutBufferSize != g_BridgeDispatchTable[ui32DispatchTableEntryIndex].ui32OutBufferSize)
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Bridge buffer sizes mismatch! "
+		        "In: User(%u), Kernel(%u) - Out: User(%u), Kernel(%u)",
+		        __func__,
+		        psBridgePackageKM->ui32InBufferSize, g_BridgeDispatchTable[ui32DispatchTableEntryIndex].ui32InBufferSize,
+		        psBridgePackageKM->ui32OutBufferSize, g_BridgeDispatchTable[ui32DispatchTableEntryIndex].ui32OutBufferSize));
+		PVR_GOTO_WITH_ERROR(err, PVRSRV_ERROR_BRIDGE_EINVAL, return_error);
+	}
+
 	if (g_BridgeDispatchTable[ui32DispatchTableEntryIndex].hBridgeLock != NULL)
 	{
 		OSLockAcquire(g_BridgeDispatchTable[ui32DispatchTableEntryIndex].hBridgeLock);
@@ -1429,23 +1423,7 @@ PVRSRV_ERROR BridgedDispatchKM(CONNECTION_DATA * psConnection,
 	ui64TimeStart = OSClockns64();
 #endif
 
-	if (psBridgePackageKM->ui32InBufferSize > PVRSRV_MAX_BRIDGE_IN_SIZE)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Bridge input buffer too small "
-		        "(data size %u, buffer size %u)!", __func__,
-		        psBridgePackageKM->ui32InBufferSize, PVRSRV_MAX_BRIDGE_IN_SIZE));
-		PVR_GOTO_WITH_ERROR(err, PVRSRV_ERROR_BRIDGE_ERANGE, unlock_and_return_error);
-	}
-
 #if !defined(INTEGRITY_OS)
-	if (psBridgePackageKM->ui32OutBufferSize > PVRSRV_MAX_BRIDGE_OUT_SIZE)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Bridge output buffer too small "
-		        "(data size %u, buffer size %u)!", __func__,
-		        psBridgePackageKM->ui32OutBufferSize, PVRSRV_MAX_BRIDGE_OUT_SIZE));
-		PVR_GOTO_WITH_ERROR(err, PVRSRV_ERROR_BRIDGE_ERANGE, unlock_and_return_error);
-	}
-
 	if ((CopyFromUserWrapper (psConnection,
 							  ui32DispatchTableEntryIndex,
 							  psBridgeIn,
diff --git a/drivers/gpu/drm/img-rogue/srvcore.h b/drivers/gpu/drm/img-rogue/srvcore.h
index fa261c2645bd..8d1385f618d4 100644
--- a/drivers/gpu/drm/img-rogue/srvcore.h
+++ b/drivers/gpu/drm/img-rogue/srvcore.h
@@ -53,6 +53,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgx_bridge.h"
 #endif
 
+#if defined(DEBUG_BRIDGE_KM)
 PVRSRV_ERROR
 CopyFromUserWrapper(CONNECTION_DATA *psConnection,
                     IMG_UINT32 ui32DispatchTableEntry,
@@ -65,6 +66,28 @@ CopyToUserWrapper(CONNECTION_DATA *psConnection,
                   void __user *pvDest,
                   void *pvSrc,
                   IMG_UINT32 ui32Size);
+#else
+FORCE_INLINE PVRSRV_ERROR
+CopyFromUserWrapper(CONNECTION_DATA *psConnection,
+					IMG_UINT32 ui32DispatchTableEntry,
+					void *pvDest,
+					void __user *pvSrc,
+					IMG_UINT32 ui32Size)
+{
+	PVR_UNREFERENCED_PARAMETER (ui32DispatchTableEntry);
+	return OSBridgeCopyFromUser(psConnection, pvDest, pvSrc, ui32Size);
+}
+FORCE_INLINE PVRSRV_ERROR
+CopyToUserWrapper(CONNECTION_DATA *psConnection,
+				  IMG_UINT32 ui32DispatchTableEntry,
+				  void __user *pvDest,
+				  void *pvSrc,
+				  IMG_UINT32 ui32Size)
+{
+	PVR_UNREFERENCED_PARAMETER (ui32DispatchTableEntry);
+	return OSBridgeCopyToUser(psConnection, pvDest, pvSrc, ui32Size);
+}
+#endif
 
 IMG_INT
 DummyBW(IMG_UINT32 ui32DispatchTableEntry,
@@ -85,6 +108,10 @@ typedef struct _PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
 	                                    arguments before calling into srvkm proper */
 	POS_LOCK hBridgeLock; /*!< The bridge lock which needs to be acquired
                                    before calling the above wrapper */
+
+	IMG_UINT32 ui32InBufferSize; /*!< The expected size of the in buffer given by the client */
+	IMG_UINT32 ui32OutBufferSize; /*!< The expected size of the out buffer given by the client */
+
 #if defined(DEBUG_BRIDGE_KM)
 	const IMG_CHAR *pszIOCName; /*!< Name of the ioctl: e.g. "PVRSRV_BRIDGE_CONNECT_SERVICES" */
 	const IMG_CHAR *pszFunctionName; /*!< Name of the wrapper function: e.g. "PVRSRVConnectBW" */
@@ -118,7 +145,9 @@ _SetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup,
                        BridgeWrapperFunction pfFunction,
                        const IMG_CHAR *pszFunctionName,
                        POS_LOCK hBridgeLock,
-                       const IMG_CHAR* pszBridgeLockName);
+                       const IMG_CHAR* pszBridgeLockName,
+                       IMG_UINT32 ui32InBufferSize,
+                       IMG_UINT32 ui32OutBufferSize);
 void
 UnsetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup,
                         IMG_UINT32 ui32Index);
@@ -126,9 +155,14 @@ UnsetDispatchTableEntry(IMG_UINT32 ui32BridgeGroup,
 
 /* PRQA S 0884,3410 2*/ /* macro relies on the lack of brackets */
 #define SetDispatchTableEntry(ui32BridgeGroup, ui32Index, pfFunction,\
-					hBridgeLock) \
-	_SetDispatchTableEntry(ui32BridgeGroup, ui32Index, #ui32Index, (BridgeWrapperFunction)pfFunction, #pfFunction,\
-							(POS_LOCK)hBridgeLock, #hBridgeLock)
+                              hBridgeLock, ui32InBufferSize, ui32OutBufferSize) \
+	do \
+	{ \
+		static_assert((ui32InBufferSize) <= PVRSRV_MAX_BRIDGE_IN_SIZE, "Bridge input buffer is too small for bridge function: " #pfFunction); \
+		static_assert((ui32OutBufferSize) <= PVRSRV_MAX_BRIDGE_OUT_SIZE, "Bridge output buffer is too small for bridge function: " #pfFunction); \
+		_SetDispatchTableEntry(ui32BridgeGroup, ui32Index, #ui32Index, (BridgeWrapperFunction)pfFunction, #pfFunction,\
+		                       (POS_LOCK)hBridgeLock, #hBridgeLock, ui32InBufferSize, ui32OutBufferSize); \
+	} while (0)
 
 #define DISPATCH_TABLE_GAP_THRESHOLD 5
 
diff --git a/drivers/gpu/drm/img-rogue/srvkm.h b/drivers/gpu/drm/img-rogue/srvkm.h
index ca564763d168..29418764daa5 100644
--- a/drivers/gpu/drm/img-rogue/srvkm.h
+++ b/drivers/gpu/drm/img-rogue/srvkm.h
@@ -110,7 +110,7 @@ exits by its own means (break, return, goto, etc.)
 
 Example of usage:
 
-LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
+LOOP_UNTIL_TIMEOUT_US(MAX_HW_TIME_US)
 {
 	if (psQueueInfo->ui32ReadOffset == psQueueInfo->ui32WriteOffset)
 	{
@@ -119,7 +119,7 @@ LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
 	}
 
 	OSWaitus(MAX_HW_TIME_US/WAIT_TRY_COUNT);
-} END_LOOP_UNTIL_TIMEOUT();
+} END_LOOP_UNTIL_TIMEOUT_US();
 
 -----------------------------------------------------------------------------*/
 
@@ -128,17 +128,17 @@ LOOP_UNTIL_TIMEOUT(MAX_HW_TIME_US)
  * necessary when preemption is enabled.
  */
 /* PRQA S 3411,3431 12 */ /* critical format, leave alone */
-#define LOOP_UNTIL_TIMEOUT(TIMEOUT) \
+#define LOOP_UNTIL_TIMEOUT_US(TIMEOUT_US) \
 {\
 	IMG_UINT32 uiOffset, uiStart, uiCurrent; \
 	IMG_INT32 iNotLastLoop;					 \
 	for (uiOffset = 0, uiStart = OSClockus(), uiCurrent = uiStart + 1, iNotLastLoop = 1;\
-		((uiCurrent - uiStart + uiOffset) < (TIMEOUT)) || iNotLastLoop--;				\
+		((uiCurrent - uiStart + uiOffset) < (TIMEOUT_US)) || iNotLastLoop--;				\
 		uiCurrent = OSClockus(),													\
 		uiOffset = uiCurrent < uiStart ? IMG_UINT32_MAX - uiStart : uiOffset,		\
 		uiStart = uiCurrent < uiStart ? 0 : uiStart)
 
-#define END_LOOP_UNTIL_TIMEOUT() \
+#define END_LOOP_UNTIL_TIMEOUT_US() \
 }
 
 #endif /* SRVKM_H */
diff --git a/drivers/gpu/drm/img-rogue/sync.c b/drivers/gpu/drm/img-rogue/sync.c
index c87d604b0cb2..3b6e8914d446 100644
--- a/drivers/gpu/drm/img-rogue/sync.c
+++ b/drivers/gpu/drm/img-rogue/sync.c
@@ -200,9 +200,7 @@ SyncPrimBlockImport(RA_PERARENA_HANDLE hArena,
                     RA_FLAGS_T uFlags,
                     RA_LENGTH_T uBaseAlignment,
                     const IMG_CHAR *pszAnnotation,
-                    RA_BASE_T *puiBase,
-                    RA_LENGTH_T *puiActualSize,
-                    RA_PERISPAN_HANDLE *phImport)
+                    RA_IMPORT *psImport)
 {
 	SYNC_PRIM_CONTEXT *psContext = hArena;
 	SYNC_PRIM_BLOCK *psSyncBlock = NULL;
@@ -243,9 +241,9 @@ SyncPrimBlockImport(RA_PERARENA_HANDLE hArena,
 	 */
 	PVR_ASSERT(uiSpanSize == psSyncBlock->ui32SyncBlockSize);
 
-	*puiBase = psSyncBlock->uiSpanBase;
-	*puiActualSize = psSyncBlock->ui32SyncBlockSize;
-	*phImport = psSyncBlock;
+	psImport->base = psSyncBlock->uiSpanBase;
+	psImport->uSize = psSyncBlock->ui32SyncBlockSize;
+	psImport->hPriv = psSyncBlock;
 	return PVRSRV_OK;
 
 fail_spanalloc:
@@ -412,7 +410,7 @@ SyncPrimContextCreate(SHARED_DEV_CONNECTION hDevConnection,
 	psContext->psSubAllocRA = RA_Create(psContext->azName,
 	                                    /* Params for imports */
 	                                    _Log2(sizeof(IMG_UINT32)),
-	                                    RA_LOCKCLASS_2,
+	                                    RA_LOCKCLASS_3,
 	                                    SyncPrimBlockImport,
 	                                    SyncPrimBlockUnimport,
 	                                    psContext,
@@ -432,7 +430,7 @@ SyncPrimContextCreate(SHARED_DEV_CONNECTION hDevConnection,
 	psContext->psSpanRA = RA_Create(psContext->azSpanName,
 	                                /* Params for imports */
 	                                0,
-	                                RA_LOCKCLASS_1,
+	                                RA_LOCKCLASS_0,
 	                                NULL,
 	                                NULL,
 	                                NULL,
diff --git a/drivers/gpu/drm/img-rogue/sync_checkpoint.c b/drivers/gpu/drm/img-rogue/sync_checkpoint.c
index 52b8898fa8cc..b04d059662ee 100644
--- a/drivers/gpu/drm/img-rogue/sync_checkpoint.c
+++ b/drivers/gpu/drm/img-rogue/sync_checkpoint.c
@@ -66,9 +66,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "pvrsrv_sync_km.h"
 #include "rgxhwperf.h"
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER)
-#include "rgxsoctimer.h"
-#endif
+
 
 #if defined(PVRSRV_NEED_PVR_DPF)
 
@@ -123,19 +121,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 #define SYNC_CHECKPOINT_POOL_LIMIT	1024
 
-/* The 'sediment' value represents the minimum number of
- * sync checkpoints which must be in the pool before one
- * will be allocated from the pool rather than from memory.
- * This effectively helps avoid re-use of a sync checkpoint
- * just after it has been returned to the pool, making
- * debugging somewhat easier to understand.
- */
-#if defined(PDUMP)
-#define SYNC_CHECKPOINT_POOL_SEDIMENT 20
-#else
-#define SYNC_CHECKPOINT_POOL_SEDIMENT 0
-#endif
-
 #if (SYNC_CHECKPOINT_POOL_LIMIT & (SYNC_CHECKPOINT_POOL_LIMIT - 1)) != 0
 #error "SYNC_CHECKPOINT_POOL_LIMIT must be power of 2."
 #endif
@@ -186,14 +171,18 @@ struct _SYNC_CHECKPOINT_CONTEXT_CTL_
 	/* Lock to protect the checkpoint stats */
 	POS_SPINLOCK							hSyncCheckpointStatsLock;
 #if (SYNC_CHECKPOINT_POOL_LIMIT > 0)
-	IMG_UINT32      ui32SyncCheckpointPoolSize;  /*! Allocated size of the pool */
-	IMG_UINT32      ui32SyncCheckpointPoolCount; /*! Number of checkpoints currently in pool */
-	IMG_UINT32      ui32SyncCheckpointPoolWp;    /*! Pool write pointer */
-	IMG_UINT32      ui32SyncCheckpointPoolRp;    /*! Pool read pointer */
-	POS_SPINLOCK    hSyncCheckpointPoolLock;     /*! Lock to protect access to pool control data */
-	IMG_UINT8       ui8PoolStateFlags;           /*! Flags to indicate state of pool */
+	IMG_UINT32								ui32SyncCheckpointPoolSize;    /*! Allocated size of the pool */
+	IMG_UINT32								ui32SyncCheckpointPoolCount;   /*! Number of checkpoints currently in pool */
+	IMG_UINT32								ui32SyncCheckpointPoolWp;      /*! Pool write pointer */
+	IMG_UINT32								ui32SyncCheckpointPoolRp;      /*! Pool read pointer */
+#if defined(PDUMP)
+	SYNC_CHECKPOINT_BLOCK					*psSyncCheckpointPoolBlock;    /*! Block that all pool checkpoints come from */
+	IMG_BOOL								bAllocateFromCheckpointPool;   /*! PDumps only use the pool once it has allocated all its checkpoints */
+#endif
+	POS_SPINLOCK							hSyncCheckpointPoolLock;       /*! Lock to protect access to pool control data */
+	IMG_UINT8								ui8PoolStateFlags;             /*! Flags to indicate state of pool */
 	/*! Array of SYNC_CHECKPOINTs. Must be last member in structure */
-	SYNC_CHECKPOINT *apsSyncCheckpointPool[1];   /*! The allocated checkpoint pool */
+	SYNC_CHECKPOINT *apsSyncCheckpointPool[IMG_FLEX_ARRAY_MEMBER];   /*! The allocated checkpoint pool */
 #endif
 }; /*_SYNC_CHECKPOINT_CONTEXT_CTL is already typedef-ed in sync_checkpoint_internal.h */
 
@@ -201,7 +190,7 @@ struct SYNC_CHECKPOINT_CONTEXT_TAG
 {
 #if defined(PDUMP)
 	DLLIST_NODE						sSyncCheckpointBlockListHead;          /*!< List head for the sync chkpt blocks in this context*/
-	DLLIST_NODE						sListNode;				/*!< List node for the sync chkpt context list*/
+	DLLIST_NODE						sListNode;				               /*!< List node for the sync chkpt context list*/
 	POS_LOCK						hSyncCheckpointBlockListLock;          /*!< sync chkpt blocks list lock*/
 #endif
 	RA_ARENA						*psSpanRA;                             /*!< RA used for span management of SubAllocRA */
@@ -428,6 +417,7 @@ _AllocSyncCheckpointBlock(_SYNC_CHECKPOINT_CONTEXT *psContext,
 	PVR_LOG_GOTO_IF_INVALID_PARAM(psDevNode, eError, fail_alloc_ufo_block);
 
 	eError = psDevNode->pfnAllocUFOBlock(psDevNode,
+	                                     SYNC_CHECKPOINT_POOL_LIMIT * sizeof(SYNC_CHECKPOINT_FW_OBJ),
 	                                     &psSyncBlk->hMemDesc,
 	                                     &psSyncBlk->ui32FirmwareAddr,
 	                                     &psSyncBlk->ui32SyncBlockSize);
@@ -494,9 +484,7 @@ _SyncCheckpointBlockImport(RA_PERARENA_HANDLE hArena,
                            RA_FLAGS_T uFlags,
                            RA_LENGTH_T uBaseAlignment,
                            const IMG_CHAR *pszAnnotation,
-                           RA_BASE_T *puiBase,
-                           RA_LENGTH_T *puiActualSize,
-                           RA_PERISPAN_HANDLE *phImport)
+                           RA_IMPORT *psImport)
 {
 	_SYNC_CHECKPOINT_CONTEXT *psContext = hArena;
 	SYNC_CHECKPOINT_BLOCK *psSyncBlock = NULL;
@@ -539,9 +527,9 @@ _SyncCheckpointBlockImport(RA_PERARENA_HANDLE hArena,
 	PVR_LOG_IF_FALSE((uiSpanSize == psSyncBlock->ui32SyncBlockSize),
 	                 "uiSpanSize invalid");
 
-	*puiBase = psSyncBlock->uiSpanBase;
-	*puiActualSize = psSyncBlock->ui32SyncBlockSize;
-	*phImport = psSyncBlock;
+	psImport->base = psSyncBlock->uiSpanBase;
+	psImport->uSize = psSyncBlock->ui32SyncBlockSize;
+	psImport->hPriv = psSyncBlock;
 	return PVRSRV_OK;
 
 fail_spanalloc:
@@ -707,6 +695,65 @@ SyncCheckpointResolveFence(PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
 	return eError;
 }
 
+PVRSRV_ERROR
+SyncCheckpointResolveExportFence(PVRSRV_FENCE hExportFence,
+                                 PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
+                                 PSYNC_CHECKPOINT *ppsSyncCheckpoint,
+                                 PDUMP_FLAGS_T ui32PDumpFlags)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (unlikely(!g_psSyncCheckpointPfnStruct || !g_psSyncCheckpointPfnStruct->pfnExportFenceResolve))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: ERROR (eError=PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED)",
+		        __func__));
+		eError = PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED;
+		PVR_LOG_ERROR(eError, "pfnExportFenceResolve is NULL");
+		return eError;
+	}
+
+	if (ppsSyncCheckpoint)
+	{
+		eError = g_psSyncCheckpointPfnStruct->pfnExportFenceResolve(
+		                           hExportFence,
+		                           psSyncCheckpointContext,
+		                           ppsSyncCheckpoint);
+	}
+	else
+	{
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	PVR_LOG_RETURN_IF_ERROR(eError, "g_psSyncCheckpointPfnStruct->pfnExportFenceResolve");
+
+#if (ENABLE_SYNC_CHECKPOINT_FENCE_DEBUG == 1)
+	{
+		PVR_DPF((PVR_DBG_WARNING,
+		        "%s: g_psSyncCheckpointPfnStruct->pfnExportFenceResolve() for fence %d returned the following checkpoint:",
+		        __func__,
+		        hExportFence));
+
+		PVR_DPF((PVR_DBG_WARNING,
+		         "%s:   psSyncCheckpoint:<%p>",
+		         __func__,
+		         (void*)*ppsSyncCheckpoint));
+	}
+#endif
+
+#if defined(PDUMP)
+	if (*ppsSyncCheckpoint)
+	{
+		SYNC_CHECKPOINT *psSyncCheckpoint = (SYNC_CHECKPOINT *)(*ppsSyncCheckpoint);
+		psSyncCheckpoint->ui32PDumpFlags = ui32PDumpFlags;
+	}
+#else
+	PVR_UNREFERENCED_PARAMETER(ui32PDumpFlags);
+#endif
+
+	return eError;
+}
+
 PVRSRV_ERROR
 SyncCheckpointCreateFence(PVRSRV_DEVICE_NODE *psDevNode,
                           const IMG_CHAR *pszFenceName,
@@ -877,7 +924,26 @@ SyncCheckpointNoHWUpdateTimelines(void *pvPrivateData)
 		g_psSyncCheckpointPfnStruct->pfnNoHWUpdateTimelines(pvPrivateData);
 	}
 	return eError;
+}
 
+PVRSRV_ERROR
+SyncCheckpointNoHWSignalExportFence(PVRSRV_FENCE iExportFenceToSignal)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (!g_psSyncCheckpointPfnStruct || !g_psSyncCheckpointPfnStruct->pfnNoHWSignalExpFence)
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+				"%s: ERROR (eError=PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED)",
+				__func__));
+		eError = PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED;
+		PVR_LOG_ERROR(eError, "g_psSyncCheckpointPfnStruct->pfnNoHWSignalExpFence is NULL");
+	}
+	else
+	{
+		g_psSyncCheckpointPfnStruct->pfnNoHWSignalExpFence(iExportFenceToSignal);
+	}
+	return eError;
 }
 
 PVRSRV_ERROR
@@ -1003,6 +1069,13 @@ _PrepopulateSyncCheckpointPool(_SYNC_CHECKPOINT_CONTEXT *psContext,
 		eError = _AllocSyncCheckpoint(psContext, &psNewSyncCheckpoint);
 		PVR_LOG_RETURN_IF_ERROR(eError, "_AllocSyncCheckpoint");
 
+#if defined(PDUMP)
+		if (ui32SyncCheckpoint == 0)
+		{
+			psContext->psContextCtl->psSyncCheckpointPoolBlock = psNewSyncCheckpoint->psSyncCheckpointBlock;
+		}
+#endif
+
 		if (!_PutCheckpointInPool(psNewSyncCheckpoint))
 		{
 			_FreeSyncCheckpoint(psNewSyncCheckpoint);
@@ -1026,13 +1099,10 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	IMG_CHAR azTempName[PVRSRV_SYNC_NAME_LENGTH] = {0};
 #if (SYNC_CHECKPOINT_POOL_LIMIT > 0)
+#if !defined(PDUMP)
 	void *pvAppHintState = NULL;
-	const IMG_UINT32 ui32DefaultMaxPoolLog2Size = 8;
-#if defined(PDUMP)
-	/* Pdumps start with an empty pool to avoid extra work allocating checkpoints which might not be used. */
-	const IMG_UINT32 ui32DefaultInitPoolLog2Size = 0;
-#else
-	const IMG_UINT32 ui32DefaultInitPoolLog2Size = 7;
+	const IMG_UINT32 ui32DefaultMaxPoolLog2Size = PVRSRV_APPHINT_CHECKPOINTPOOLMAXLOG2;
+	const IMG_UINT32 ui32DefaultInitPoolLog2Size = PVRSRV_APPHINT_CHECKPOINTPOOLINITLOG2;
 #endif
 	IMG_UINT32 ui32MaxPoolLog2Size;
 	IMG_UINT32 ui32InitPoolLog2Size;
@@ -1045,6 +1115,20 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	                  PVRSRV_ERROR_INVALID_PARAMS);
 
 #if (SYNC_CHECKPOINT_POOL_LIMIT > 0)
+#if defined(PDUMP)
+	/*
+	   Pdumps use the maximum pool size to limit checkpoint address reuse and start with
+	   a minimum pool to avoid extra work allocating checkpoints which might not be used.
+	   Since during a pdump capture the pool is setup once during the pdump init phase
+	   and not emptied / de-initialised between captures we need to map at least one
+	   checkpoint at creation time, so that the pdump records the CPU mapping of the
+	   pool. Not doing this would lead to errors on subsequent pdump captures because
+	   only the first pdump would contain the mapping.
+	*/
+	ui32MaxPoolLog2Size = 10;
+	ui32InitPoolLog2Size = 0;
+	ui32InitPoolSize = 1;
+#else
 	/* Read AppHints to determine the size of the sync checkpoint pool, if specified */
 	OSCreateAppHintState(&pvAppHintState);
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, SyncCheckpointPoolMaxLog2,
@@ -1052,6 +1136,7 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState, SyncCheckpointPoolInitLog2,
 	                     &ui32DefaultInitPoolLog2Size, &ui32InitPoolLog2Size);
 	OSFreeAppHintState(pvAppHintState);
+#endif
 
 	if (ui32MaxPoolLog2Size > 0)
 	{
@@ -1067,7 +1152,7 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	PVR_LOG_GOTO_IF_NOMEM(psContext, eError, fail_alloc); /* Sets OOM error code */
 
 	/* psContextCtl includes allocation for the sync checkpoint pool) */
-	psContextCtl = OSAllocMem(sizeof(*psContextCtl) + (sizeof(SYNC_CHECKPOINT*) * ui32MaxPoolSize));
+	psContextCtl = OSAllocMem(sizeof(*psContextCtl) + IMG_FLEX_ARRAY_SIZE(sizeof(SYNC_CHECKPOINT*), ui32MaxPoolSize));
 	PVR_LOG_GOTO_IF_NOMEM(psContextCtl, eError, fail_alloc2); /* Sets OOM error code */
 
 	eError = OSSpinLockCreate(&psContextCtl->hDeferredCleanupListLock);
@@ -1083,6 +1168,10 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	psContextCtl->ui32SyncCheckpointPoolCount = 0;
 	psContextCtl->ui32SyncCheckpointPoolWp = 0;
 	psContextCtl->ui32SyncCheckpointPoolRp = 0;
+#if defined(PDUMP)
+	psContextCtl->psSyncCheckpointPoolBlock = NULL;
+	psContextCtl->bAllocateFromCheckpointPool = IMG_FALSE;
+#endif
 	psContextCtl->ui8PoolStateFlags = SYNC_CHECKPOINT_POOL_VALID;
 #endif
 	psContextCtl->psDeviceNode = (SHARED_DEV_CONNECTION)psDevNode;
@@ -1099,7 +1188,7 @@ SyncCheckpointContextCreate(PPVRSRV_DEVICE_NODE psDevNode,
 	psContext->psSubAllocRA = RA_Create(azTempName,
 	                                    /* Params for imports */
 	                                    _Log2(sizeof(IMG_UINT32)),
-	                                    RA_LOCKCLASS_2,
+	                                    RA_LOCKCLASS_3,
 	                                    _SyncCheckpointBlockImport,
 	                                    _SyncCheckpointBlockUnimport,
 	                                    psContext,
@@ -1366,6 +1455,21 @@ SyncCheckpointAlloc(PSYNC_CHECKPOINT_CONTEXT psSyncContext,
 	{
 		eError = _AllocSyncCheckpoint(psSyncContextInt, &psNewSyncCheckpoint);
 		PVR_LOG_GOTO_IF_NOMEM(psNewSyncCheckpoint, eError, fail_alloc); /* Sets OOM error code */
+
+#if (SYNC_CHECKPOINT_POOL_LIMIT > 0) && defined(PDUMP)
+		/* If the pool is not yet enabled and we allocated all the block, then the pool is ready to use. */
+		if (!psSyncContextInt->psContextCtl->bAllocateFromCheckpointPool)
+		{
+			RA_USAGE_STATS  sRAUsageStats;
+
+			RA_Get_Usage_Stats(psSyncContextInt->psSubAllocRA, &sRAUsageStats);
+
+			if (sRAUsageStats.ui64FreeArenaSize < sizeof(SYNC_CHECKPOINT_FW_OBJ))
+			{
+				psSyncContextInt->psContextCtl->bAllocateFromCheckpointPool = IMG_TRUE;
+			}
+		}
+#endif
 	}
 
 	OSSpinLockAcquire(psSyncContextInt->psContextCtl->hSyncCheckpointStatsLock, uiFlags);
@@ -1386,7 +1490,7 @@ SyncCheckpointAlloc(PSYNC_CHECKPOINT_CONTEXT psSyncContext,
 	if (pszCheckpointName)
 	{
 		/* Copy over the checkpoint name annotation */
-		OSStringLCopy(psNewSyncCheckpoint->azName, pszCheckpointName, PVRSRV_SYNC_NAME_LENGTH);
+		OSStringSafeCopy(psNewSyncCheckpoint->azName, pszCheckpointName, PVRSRV_SYNC_NAME_LENGTH);
 	}
 	else
 	{
@@ -1412,7 +1516,7 @@ SyncCheckpointAlloc(PSYNC_CHECKPOINT_CONTEXT psSyncContext,
 	                            hFence,
 	                            psNewSyncCheckpoint->ui32FWAddr,
 	                            psNewSyncCheckpoint->azName,
-	                            sizeof(psNewSyncCheckpoint->azName));
+	                            OSStringLength(psNewSyncCheckpoint->azName));
 
 	if (GetInfoPageDebugFlagsKM() & DEBUG_FEATURE_FULL_SYNC_TRACKING_ENABLED)
 	{
@@ -1421,7 +1525,7 @@ SyncCheckpointAlloc(PSYNC_CHECKPOINT_CONTEXT psSyncContext,
 		if (pszCheckpointName)
 		{
 			/* Copy the checkpoint name annotation into a fixed-size array */
-			OSStringLCopy(szChkptName, pszCheckpointName, PVRSRV_SYNC_NAME_LENGTH);
+			OSStringSafeCopy(szChkptName, pszCheckpointName, PVRSRV_SYNC_NAME_LENGTH);
 		}
 		else
 		{
@@ -1498,12 +1602,14 @@ static void SyncCheckpointUnref(SYNC_CHECKPOINT *psSyncCheckpointInt)
 		if (psSyncCheckpointInt->psSyncCheckpointFwObj->ui32FwRefCount ==
 				(IMG_UINT32)(OSAtomicRead(&psSyncCheckpointInt->hEnqueuedCCBCount)))
 		{
+			PVRSRV_ERROR eError;
+
 #if (ENABLE_SYNC_CHECKPOINT_ALLOC_AND_FREE_DEBUG == 1)
 			PVR_DPF((PVR_DBG_WARNING,
 					"%s No outstanding FW ops and hRef is zero, deleting SyncCheckpoint..",
 					__func__));
 #endif
-			PVRSRV_ERROR eError;
+
 			if ((GetInfoPageDebugFlagsKM() & DEBUG_FEATURE_FULL_SYNC_TRACKING_ENABLED)
 				&& psSyncCheckpointInt->hRecord)
 			{
@@ -2142,6 +2248,34 @@ void SyncCheckpointRollbackFromUFO(PPVRSRV_DEVICE_NODE psDevNode, IMG_UINT32 ui3
 #endif
 }
 
+PVRSRV_ERROR SyncCheckpointRollbackExportFence(PVRSRV_FENCE hExportFence)
+{
+	PVRSRV_ERROR eError = PVRSRV_OK;
+
+	if (unlikely(!g_psSyncCheckpointPfnStruct || !g_psSyncCheckpointPfnStruct->pfnExportFenceRollback))
+	{
+		PVR_DPF((PVR_DBG_ERROR,
+		        "%s: ERROR (eError=PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED)",
+		        __func__));
+		eError = PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED;
+		PVR_LOG_ERROR(eError, "pfnExportFenceRollback is NULL");
+		return eError;
+	}
+
+	if (hExportFence != PVRSRV_NO_FENCE)
+	{
+		eError = g_psSyncCheckpointPfnStruct->pfnExportFenceRollback(hExportFence);
+	}
+	else
+	{
+		eError = PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	PVR_LOG_RETURN_IF_ERROR(eError, "g_psSyncCheckpointPfnStruct->pfnExportFenceRollback");
+
+	return eError;
+}
+
 static void _SyncCheckpointState(PDLLIST_NODE psNode,
 					DUMPDEBUG_PRINTF_FUNC *pfnDumpDebugPrintf,
 					void *pvDumpDebugFile)
@@ -2431,7 +2565,7 @@ _SyncCheckpointRecordAdd(
 		if (ui32ClassNameSize >= PVRSRV_SYNC_NAME_LENGTH)
 			ui32ClassNameSize = PVRSRV_SYNC_NAME_LENGTH;
 		/* Copy over the class name annotation */
-		OSStringLCopy(psSyncRec->szClassName, pszClassName, ui32ClassNameSize);
+		OSStringSafeCopy(psSyncRec->szClassName, pszClassName, ui32ClassNameSize);
 	}
 	else
 	{
@@ -2812,9 +2946,6 @@ PVRSRV_ERROR PVRSRVSyncCheckpointSignalledPDumpPolKM(PVRSRV_FENCE hFence)
 	SYNC_CHECKPOINT *psSyncCheckpoint = NULL;
 	IMG_UINT32 i, uiNumCheckpoints = 0;
 	_SYNC_CHECKPOINT_CONTEXT *psContext;
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER) && defined(NO_HARDWARE) && defined(PDUMP)
-	PVRSRV_RGXDEV_INFO *psDevInfo;
-#endif
 
 	if (hFence != PVRSRV_NO_FENCE)
 	{
@@ -2857,19 +2988,7 @@ PVRSRV_ERROR PVRSRVSyncCheckpointSignalledPDumpPolKM(PVRSRV_FENCE hFence)
 		}
 	}
 
-#if defined(SUPPORT_VALIDATION) && defined(SUPPORT_SOC_TIMER) && defined(NO_HARDWARE) && defined(PDUMP)
-	/* Sampling of USC timers can only be done after synchronisation for a 3D kick is over */
-	if (uiNumCheckpoints)
-	{
-		psSyncCheckpoint = (SYNC_CHECKPOINT *)apsCheckpoints[0];
-		psContext = (_SYNC_CHECKPOINT_CONTEXT*)psSyncCheckpoint->psSyncCheckpointBlock->psContext;
-		psDevInfo = psContext->psContextCtl->psDeviceNode->pvDevice;
-		if (psDevInfo->psRGXFWIfFwSysData->ui32ConfigFlags & RGXFWIF_INICFG_VALIDATE_SOCUSC_TIMER)
-		{
-			RGXValidateSOCUSCTimer(psDevInfo, PDUMP_CONT, 0, 0, NULL);
-		}
-	}
-#endif
+
 
 	/* Free the memory that was allocated for the sync checkpoint list returned */
 	if (apsCheckpoints)
@@ -3047,7 +3166,10 @@ static SYNC_CHECKPOINT *_GetCheckpointFromPool(_SYNC_CHECKPOINT_CONTEXT *psConte
 
 	/* Check if we can allocate from the pool */
 	if (CHECKPOINT_POOL_VALID(psCtxCtl) &&
-	    (psCtxCtl->ui32SyncCheckpointPoolCount > SYNC_CHECKPOINT_POOL_SEDIMENT))
+#if defined(PDUMP)
+	    psCtxCtl->bAllocateFromCheckpointPool &&
+#endif
+	    (psCtxCtl->ui32SyncCheckpointPoolCount > 0))
 	{
 		/* Get the next sync checkpoint from the pool */
 		psSyncCheckpoint = psCtxCtl->apsSyncCheckpointPool[psCtxCtl->ui32SyncCheckpointPoolRp];
@@ -3094,7 +3216,11 @@ static IMG_BOOL _PutCheckpointInPool(SYNC_CHECKPOINT *psSyncCheckpoint)
 	OSSpinLockAcquire(psCtxCtl->hSyncCheckpointPoolLock, uiFlags);
 
 	/* Check if pool has space */
-	if (CHECKPOINT_POOL_VALID(psCtxCtl) && !(CHECKPOINT_POOL_FULL(psCtxCtl)))
+	if (CHECKPOINT_POOL_VALID(psCtxCtl) &&
+#if defined(PDUMP)
+			(psSyncCheckpoint->psSyncCheckpointBlock == psCtxCtl->psSyncCheckpointPoolBlock) &&
+#endif
+			!(CHECKPOINT_POOL_FULL(psCtxCtl)))
 	{
 		/* Put the sync checkpoint into the next write slot in the pool */
 		psCtxCtl->apsSyncCheckpointPool[psCtxCtl->ui32SyncCheckpointPoolWp] = psSyncCheckpoint;
@@ -3105,6 +3231,10 @@ static IMG_BOOL _PutCheckpointInPool(SYNC_CHECKPOINT *psSyncCheckpoint)
 		if (psCtxCtl->ui32SyncCheckpointPoolWp == psCtxCtl->ui32SyncCheckpointPoolRp)
 		{
 			SET_CHECKPOINT_POOL_FULL(psCtxCtl);
+#if defined(PDUMP)
+			/* The pool is now fully allocated and ready to use. */
+			psCtxCtl->bAllocateFromCheckpointPool = IMG_TRUE;
+#endif
 		}
 		bReturnedToPool = IMG_TRUE;
 		psSyncCheckpoint->psSyncCheckpointFwObj->ui32State = PVRSRV_SYNC_CHECKPOINT_UNDEF;
@@ -3135,13 +3265,11 @@ static IMG_UINT32 _CleanCheckpointPool(_SYNC_CHECKPOINT_CONTEXT *psContext)
 	DECLARE_DLLIST(sCleanupList);
 	DLLIST_NODE *psThis, *psNext;
 	OS_SPINLOCK_FLAGS uiFlags;
-	IMG_UINT32 ui32ItemsFreed = 0, ui32NullScpCount = 0, ui32PoolCount;
+	IMG_UINT32 ui32ItemsFreed = 0, ui32NullScpCount = 0;
 
 	/* Acquire sync checkpoint pool lock */
 	OSSpinLockAcquire(psCtxCtl->hSyncCheckpointPoolLock, uiFlags);
 
-	ui32PoolCount = psCtxCtl->ui32SyncCheckpointPoolCount;
-
 	/* While the pool still contains sync checkpoints, free them */
 	while (CHECKPOINT_POOL_VALID(psCtxCtl) && psCtxCtl->ui32SyncCheckpointPoolCount > 0)
 	{
diff --git a/drivers/gpu/drm/img-rogue/sync_checkpoint.h b/drivers/gpu/drm/img-rogue/sync_checkpoint.h
index 33c26f420862..d1f53751dd40 100644
--- a/drivers/gpu/drm/img-rogue/sync_checkpoint.h
+++ b/drivers/gpu/drm/img-rogue/sync_checkpoint.h
@@ -84,6 +84,7 @@ typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_CREATE_FN)(PPVRSRV_DEVICE_NODE
 typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_ROLLBACK_DATA_FN)(PVRSRV_FENCE fence_to_rollback, void *finalise_data);
 typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_FINALISE_FN)(PVRSRV_FENCE fence_to_finalise, void *finalise_data);
 typedef void (*PFN_SYNC_CHECKPOINT_NOHW_UPDATE_TIMELINES_FN)(void *private_data);
+typedef void (*PFN_SYNC_CHECKPOINT_NOHW_SIGNAL_EXPORT_FENCE_FN)(PVRSRV_FENCE fence_to_signal);
 typedef void (*PFN_SYNC_CHECKPOINT_FREE_CHECKPOINT_LIST_MEM_FN)(void *mem_ptr);
 typedef IMG_UINT32 (*PFN_SYNC_CHECKPOINT_DUMP_INFO_ON_STALLED_UFOS_FN)(IMG_UINT32 num_ufos, IMG_UINT32 *vaddrs);
 #if defined(PDUMP)
@@ -91,6 +92,10 @@ typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_FENCE_GETCHECKPOINTS_FN)(PVRSRV_FENCE
 									IMG_UINT32 *puiNumCheckpoints,
 									PSYNC_CHECKPOINT **papsCheckpoints);
 #endif
+typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_EXPORT_FENCE_RESOLVE_FN)(PVRSRV_FENCE iExportFence,
+                                                             PSYNC_CHECKPOINT_CONTEXT checkpoint_context,
+                                                             PSYNC_CHECKPOINT *checkpoint_handle);
+typedef PVRSRV_ERROR (*PFN_SYNC_CHECKPOINT_EXPORT_FENCE_ROLLBACK_FN)(PVRSRV_FENCE iExportFence);
 
 #define SYNC_CHECKPOINT_IMPL_MAX_STRLEN 20
 
@@ -101,12 +106,15 @@ typedef struct
 	PFN_SYNC_CHECKPOINT_FENCE_ROLLBACK_DATA_FN pfnFenceDataRollback;
 	PFN_SYNC_CHECKPOINT_FENCE_FINALISE_FN pfnFenceFinalise;
 	PFN_SYNC_CHECKPOINT_NOHW_UPDATE_TIMELINES_FN pfnNoHWUpdateTimelines;
+	PFN_SYNC_CHECKPOINT_NOHW_SIGNAL_EXPORT_FENCE_FN pfnNoHWSignalExpFence;
 	PFN_SYNC_CHECKPOINT_FREE_CHECKPOINT_LIST_MEM_FN pfnFreeCheckpointListMem;
 	PFN_SYNC_CHECKPOINT_DUMP_INFO_ON_STALLED_UFOS_FN pfnDumpInfoOnStalledUFOs;
 	IMG_CHAR pszImplName[SYNC_CHECKPOINT_IMPL_MAX_STRLEN];
 #if defined(PDUMP)
 	PFN_SYNC_CHECKPOINT_FENCE_GETCHECKPOINTS_FN pfnSyncFenceGetCheckpoints;
 #endif
+	PFN_SYNC_CHECKPOINT_EXPORT_FENCE_RESOLVE_FN pfnExportFenceResolve;
+	PFN_SYNC_CHECKPOINT_EXPORT_FENCE_ROLLBACK_FN pfnExportFenceRollback;
 } PFN_SYNC_CHECKPOINT_STRUCT;
 
 PVRSRV_ERROR SyncCheckpointRegisterFunctions(PFN_SYNC_CHECKPOINT_STRUCT *psSyncCheckpointPfns);
@@ -243,7 +251,7 @@ SyncCheckpointSignal(PSYNC_CHECKPOINT psSyncCheckpoint, IMG_UINT32 ui32FenceSync
 /*************************************************************************/ /*!
 @Function       SyncCheckpointSignalNoHW
 
-@Description    Signal the synchronisation checkpoint in NO_HARWARE build
+@Description    Signal the synchronisation checkpoint in NO_HARDWARE build
 
 @Input          psSyncCheckpoint        The synchronisation checkpoint to signal
 
@@ -425,6 +433,51 @@ SyncCheckpointResolveFence(PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
                            IMG_UINT64 *puiFenceUID,
                            PDUMP_FLAGS_T ui32PDumpFlags);
 
+/*************************************************************************/ /*!
+@Function       SyncCheckpointResolveExportFence
+
+@Description    Resolve an export fence, returning the sync checkpoint
+                that fence contains.
+                This function in turn calls a function provided by the
+                sync implementation.
+
+@Input          hExportFence            The export fence to be resolved
+
+@Input          psSyncCheckpointContext The context in which to create the
+                                        new sync checkpoint for the export fence
+
+@Output         ppsSyncCheckpoint       The sync checkpoint the fence
+                                        contains
+
+@Return         PVRSRV_OK if a valid fence was provided.
+                PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED if the OS native
+                sync has not registered a callback function.
+*/
+/*****************************************************************************/
+PVRSRV_ERROR
+SyncCheckpointResolveExportFence(PVRSRV_FENCE hExportFence,
+                           PSYNC_CHECKPOINT_CONTEXT psSyncCheckpointContext,
+                           PSYNC_CHECKPOINT *ppsSyncCheckpoint,
+                           PDUMP_FLAGS_T ui32PDumpFlags);
+
+/*************************************************************************/ /*!
+@Function       SyncCheckpointRollbackExportFence
+
+@Description    Rollback an export fence, freeing the sync checkpoint
+                that fence was assigned.
+                This function in turn calls a function provided by the
+                sync implementation.
+
+@Input          hExportFence            The export fence to be rolled back
+
+@Return         PVRSRV_OK if a valid fence was provided.
+                PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED if the OS native
+                sync has not registered a callback function.
+*/
+/*****************************************************************************/
+PVRSRV_ERROR
+SyncCheckpointRollbackExportFence(PVRSRV_FENCE hExportFence);
+
 /*************************************************************************/ /*!
 @Function       SyncCheckpointCreateFence
 
@@ -570,6 +623,27 @@ SyncCheckpointFreeCheckpointListMem(void *pvCheckpointListMem);
 PVRSRV_ERROR
 SyncCheckpointNoHWUpdateTimelines(void *pvPrivateData);
 
+/*************************************************************************/ /*!
+@Function       SyncCheckpointNoHWSignalExportFence
+
+@Description    Called by the DDK in a NO_HARDWARE build only.
+                After syncs have been manually signalled by the DDK, this
+                function is called to allow the OS native sync implementation
+                to signal the export fence (as the usual callback notification
+                of signalled checkpoints is not supported for NO_HARDWARE).
+                This function in turn calls a function provided by the
+                OS native sync implementation.
+
+@Input          iExportFenceToSignal     The export fence to signal.
+
+@Return         PVRSRV_ERROR_SYNC_NATIVESYNC_NOT_REGISTERED if the OS native
+                sync has not registered a callback function, otherwise
+                PVRSRV_OK.
+*/
+/*****************************************************************************/
+PVRSRV_ERROR
+SyncCheckpointNoHWSignalExportFence(PVRSRV_FENCE iExportFenceToSignal);
+
 /*************************************************************************/ /*!
 @Function       SyncCheckpointDumpInfoOnStalledUFOs
 
diff --git a/drivers/gpu/drm/img-rogue/sync_checkpoint_internal.h b/drivers/gpu/drm/img-rogue/sync_checkpoint_internal.h
index 49d1b7810a8d..2514ff3b6973 100644
--- a/drivers/gpu/drm/img-rogue/sync_checkpoint_internal.h
+++ b/drivers/gpu/drm/img-rogue/sync_checkpoint_internal.h
@@ -54,7 +54,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "lock.h"
 #include "devicemem.h"
 #include "rgx_fwif_shared.h"
-#include "rgx_fwif_km.h"
 
 struct SYNC_CHECKPOINT_RECORD;
 
diff --git a/drivers/gpu/drm/img-rogue/sync_prim_internal.h b/drivers/gpu/drm/img-rogue/sync_prim_internal.h
index 77164c2356cd..c4dec49e9ca4 100644
--- a/drivers/gpu/drm/img-rogue/sync_prim_internal.h
+++ b/drivers/gpu/drm/img-rogue/sync_prim_internal.h
@@ -71,7 +71,6 @@ typedef struct PVRSRV_CLIENT_SYNC_PRIM_OP_TAG
 {
 	#define PVRSRV_CLIENT_SYNC_PRIM_OP_CHECK	(1U << 0)
 	#define PVRSRV_CLIENT_SYNC_PRIM_OP_UPDATE	(1U << 1)
-	#define PVRSRV_CLIENT_SYNC_PRIM_OP_UNFENCED_UPDATE (PVRSRV_CLIENT_SYNC_PRIM_OP_UPDATE | (1U<<2))
 	uint32_t                    ui32Flags;       /*!< Operation flags: PVRSRV_CLIENT_SYNC_PRIM_OP_XXX */
 	PVRSRV_CLIENT_SYNC_PRIM    *psSync;          /*!< Pointer to the client sync primitive */
 	uint32_t                    ui32FenceValue;  /*!< The Fence value (only used if PVRSRV_CLIENT_SYNC_PRIM_OP_CHECK is set) */
diff --git a/drivers/gpu/drm/img-rogue/sync_server.c b/drivers/gpu/drm/img-rogue/sync_server.c
index 12a7d1ea8d0b..1746d946aca1 100644
--- a/drivers/gpu/drm/img-rogue/sync_server.c
+++ b/drivers/gpu/drm/img-rogue/sync_server.c
@@ -571,7 +571,7 @@ PVRSRVSyncRecordAddKM(CONNECTION_DATA *psConnection,
 		if (ui32ClassNameSize >= PVRSRV_SYNC_NAME_LENGTH)
 			ui32ClassNameSize = PVRSRV_SYNC_NAME_LENGTH;
 		/* Copy over the class name annotation */
-		OSStringLCopy(psSyncRec->szClassName, pszClassName, ui32ClassNameSize);
+		OSStringSafeCopy(psSyncRec->szClassName, pszClassName, ui32ClassNameSize);
 	}
 	else
 	{
@@ -781,6 +781,7 @@ PVRSRVAllocSyncPrimitiveBlockKM(CONNECTION_DATA *psConnection,
 	PDUMPCOMMENTWITHFLAGS(psDevNode, PDUMP_FLAGS_CONTINUOUS, "Allocate UFO block");
 
 	eError = psDevNode->pfnAllocUFOBlock(psDevNode,
+										 sizeof(IMG_UINT32),
 										 &psNewSyncBlk->psMemDesc,
 										 &psNewSyncBlk->uiFWAddr.ui32Addr,
 										 &psNewSyncBlk->ui32BlockSize);
@@ -833,15 +834,23 @@ PVRSRVFreeSyncPrimitiveBlockKM(SYNC_PRIMITIVE_BLOCK *psSyncBlk)
 }
 
 static INLINE IMG_BOOL _CheckSyncIndex(SYNC_PRIMITIVE_BLOCK *psSyncBlk,
-							IMG_UINT32 ui32Index)
+                                       IMG_UINT32 ui32Index)
 {
-	return ((ui32Index * sizeof(IMG_UINT32)) < psSyncBlk->ui32BlockSize);
+	if (psSyncBlk->ui32BlockSize == 0)
+	{
+		return IMG_FALSE;
+	}
+
+	return (ui32Index < psSyncBlk->ui32BlockSize / sizeof(IMG_UINT32));
 }
 
 PVRSRV_ERROR
-PVRSRVSyncPrimSetKM(SYNC_PRIMITIVE_BLOCK *psSyncBlk, IMG_UINT32 ui32Index,
-					IMG_UINT32 ui32Value)
+PVRSRVSyncPrimSetKM(SYNC_PRIMITIVE_BLOCK *psSyncBlk,
+                    IMG_UINT32 ui32Index,
+                    IMG_UINT32 ui32Value)
 {
+	PVR_LOG_RETURN_IF_INVALID_PARAM(psSyncBlk != NULL, "psSyncBlk");
+
 	if (_CheckSyncIndex(psSyncBlk, ui32Index))
 	{
 		psSyncBlk->pui32LinAddr[ui32Index] = ui32Value;
@@ -849,11 +858,12 @@ PVRSRVSyncPrimSetKM(SYNC_PRIMITIVE_BLOCK *psSyncBlk, IMG_UINT32 ui32Index,
 	}
 	else
 	{
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSyncPrimSetKM: Index %u out of range for "
-							"0x%08X byte sync block (value 0x%08X)",
-							ui32Index,
-							psSyncBlk->ui32BlockSize,
-							ui32Value));
+		PVR_DPF((PVR_DBG_ERROR,
+		         "PVRSRVSyncPrimSetKM: Index %u out of range for "
+		         "0x%08X byte sync block (value 0x%08X)",
+		         ui32Index,
+		         psSyncBlk->ui32BlockSize,
+		         ui32Value));
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 }
diff --git a/drivers/gpu/drm/img-rogue/sysconfig_cmn.c b/drivers/gpu/drm/img-rogue/sysconfig_cmn.c
index 68d30527eb3f..d8a09182dc04 100644
--- a/drivers/gpu/drm/img-rogue/sysconfig_cmn.c
+++ b/drivers/gpu/drm/img-rogue/sysconfig_cmn.c
@@ -75,6 +75,8 @@ void SysRGXErrorNotify(IMG_HANDLE hSysData,
 			}
 			case RGX_CONTEXT_RESET_REASON_GPU_ECC_HWR:
 			case RGX_CONTEXT_RESET_REASON_FW_EXEC_ERR:
+			case RGX_CONTEXT_RESET_REASON_GPU_PARITY_HWR:
+			case RGX_CONTEXT_RESET_REASON_GPU_LATENT_HWR:
 			{
 				ui32DgbLvl = PVR_DBG_WARNING;
 				break;
@@ -82,10 +84,13 @@ void SysRGXErrorNotify(IMG_HANDLE hSysData,
 			case RGX_CONTEXT_RESET_REASON_WGP_CHECKSUM:
 			case RGX_CONTEXT_RESET_REASON_TRP_CHECKSUM:
 			case RGX_CONTEXT_RESET_REASON_FW_ECC_ERR:
+			case RGX_CONTEXT_RESET_REASON_FW_PTE_PARITY_ERR:
+			case RGX_CONTEXT_RESET_REASON_FW_PARITY_ERR:
 			case RGX_CONTEXT_RESET_REASON_FW_WATCHDOG:
 			case RGX_CONTEXT_RESET_REASON_FW_PAGEFAULT:
 			case RGX_CONTEXT_RESET_REASON_HOST_WDG_FW_ERR:
 			case RGX_CONTEXT_PVRIC_SIGNATURE_MISMATCH:
+			case RGX_CONTEXT_RESET_REASON_DCLS_ERR:
 			{
 				ui32DgbLvl = PVR_DBG_ERROR;
 				break;
@@ -132,60 +137,12 @@ void SysRGXErrorNotify(IMG_HANDLE hSysData,
 
 IMG_UINT64 SysRestrictGpuLocalPhysheap(IMG_UINT64 uiHeapSize)
 {
-#if defined(SUPPORT_VALIDATION)
-	void *pvAppHintState = NULL;
-	IMG_UINT32 uiCurrentHeapSizeMB = B2MB(uiHeapSize);
-	IMG_UINT32 uiForcedHeapSizeMB = 0;
-	IMG_UINT64 uiForcedHeapSizeBytes = 0;
-
-	OSCreateAppHintState(&pvAppHintState);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState,
-	                     RestrictGpuLocalPhysHeapSizeMB, &uiCurrentHeapSizeMB,
-						 &uiForcedHeapSizeMB);
-	OSFreeAppHintState(pvAppHintState);
-
-	uiForcedHeapSizeBytes = MB2B((IMG_UINT64)uiForcedHeapSizeMB);
-
-	if (uiForcedHeapSizeMB == 0)
-	{
-		/* Apphint wasn't set, just return current heapsize */
-		return uiHeapSize;
-	}
-
-	if (uiForcedHeapSizeBytes > uiHeapSize)
-	{
-		PVR_DPF((PVR_DBG_WARNING,"GPU_LOCAL Forced heap value greater than possible heap size. "
-								 "Given: %llu Available: %llu. Reverting to default.",
-								 uiForcedHeapSizeBytes, uiHeapSize));
-	}
-	else
-	{
-		PVR_LOG(("RestrictGpuLocalPhysHeapSizeMB applied GPU_LOCAL Size Bytes: %llu", uiForcedHeapSizeBytes));
-	}
-
-	return uiForcedHeapSizeBytes;
-#else
 	return uiHeapSize;
-#endif
 }
 
 IMG_BOOL SysRestrictGpuLocalAddPrivateHeap(void)
 {
-#if defined(SUPPORT_VALIDATION)
-	void *pvAppHintState = NULL;
-	IMG_UINT32 uiCurrentHeapSizeMB = 0;
-	IMG_UINT32 uiForcedHeapSizeMB = 0;
-
-	OSCreateAppHintState(&pvAppHintState);
-	OSGetAppHintUINT32(APPHINT_NO_DEVICE, pvAppHintState,
-	                     RestrictGpuLocalPhysHeapSizeMB, &uiCurrentHeapSizeMB,
-						 &uiForcedHeapSizeMB);
-	OSFreeAppHintState(pvAppHintState);
-
-	return uiForcedHeapSizeMB ? IMG_TRUE : IMG_FALSE;
-#else
 	return IMG_FALSE;
-#endif
 }
 
 IMG_BOOL SysDefaultToCpuLocalHeap(void)
diff --git a/drivers/gpu/drm/img-rogue/sysvalidation.h b/drivers/gpu/drm/img-rogue/sysvalidation.h
index 17ad86bbdb00..e3e731e8b810 100644
--- a/drivers/gpu/drm/img-rogue/sysvalidation.h
+++ b/drivers/gpu/drm/img-rogue/sysvalidation.h
@@ -50,9 +50,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "rgxdefs_km.h"
 #include "virt_validation_defs.h"
 
-void SysInitVirtInitialization(IMG_HANDLE hSysData,
-                               IMG_UINT64 aui64OSidMin[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS],
-                               IMG_UINT64 aui64OSidMax[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS]);
+void SysInitFirewall(IMG_HANDLE hSysData,
+                     IMG_UINT64 aui64OSidMin[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS],
+                     IMG_UINT64 aui64OSidMax[GPUVIRT_VALIDATION_NUM_REGIONS][GPUVIRT_VALIDATION_NUM_OS]);
 
 #if defined(EMULATOR)
 void SysSetAxiProtOSid(IMG_HANDLE hSysData, IMG_UINT32 ui32OSid, IMG_BOOL bState);
diff --git a/drivers/gpu/drm/img-rogue/tlclient.c b/drivers/gpu/drm/img-rogue/tlclient.c
index 76983002c4f1..a72f8118483b 100644
--- a/drivers/gpu/drm/img-rogue/tlclient.c
+++ b/drivers/gpu/drm/img-rogue/tlclient.c
@@ -174,7 +174,7 @@ PVRSRV_ERROR TLClientOpenStream(SHARED_DEV_CONNECTION hDevConnection,
 			hTLImportHandle);
 
 	/* Copy stream name */
-	OSStringLCopy(psSD->szName, pszName, PRVSRVTL_MAX_STREAM_NAME_SIZE);
+	OSStringSafeCopy(psSD->szName, pszName, PRVSRVTL_MAX_STREAM_NAME_SIZE);
 
 	/* Return client descriptor handle to caller */
 	*phSD = psSD;
diff --git a/drivers/gpu/drm/img-rogue/tlintern.c b/drivers/gpu/drm/img-rogue/tlintern.c
index 2c84ebf7b194..3bd6b0af1718 100644
--- a/drivers/gpu/drm/img-rogue/tlintern.c
+++ b/drivers/gpu/drm/img-rogue/tlintern.c
@@ -335,7 +335,7 @@ IMG_UINT32 TLDiscoverStreamNodes(const IMG_CHAR *pszNamePattern,
 				break;
 
 			/* all of names are shorter than MAX and null terminated */
-			OSStringLCopy(aaszStreams[ui32Count], psn->psStream->szName,
+			OSStringSafeCopy(aaszStreams[ui32Count], psn->psStream->szName,
 			              PRVSRVTL_MAX_STREAM_NAME_SIZE);
 		}
 
diff --git a/drivers/gpu/drm/img-rogue/tlintern.h b/drivers/gpu/drm/img-rogue/tlintern.h
index c3edce6b8cd1..114f90f98548 100644
--- a/drivers/gpu/drm/img-rogue/tlintern.h
+++ b/drivers/gpu/drm/img-rogue/tlintern.h
@@ -94,6 +94,8 @@ typedef struct _TL_STREAM_
 
 	void                    (*pfOnReaderOpenCallback)(void *pvArg); /*!< Optional on reader connect callback */
 	void                    *pvOnReaderOpenUserData;                /*!< On reader connect user data */
+	void                    (*pfOnReaderCloseCallback)(void *pvArg);/*!< Optional on reader disconnect callback */
+	void                    *pvOnReaderCloseUserData;               /*!< On reader disconnect user data */
 	void                    (*pfProducerCallback)(void);            /*!< Optional producer callback of type TL_STREAM_SOURCECB */
 	void                    *pvProducerUserData;                    /*!< Producer callback user data */
 
diff --git a/drivers/gpu/drm/img-rogue/tlserver.c b/drivers/gpu/drm/img-rogue/tlserver.c
index c250dd3dc618..5c8359271508 100644
--- a/drivers/gpu/drm/img-rogue/tlserver.c
+++ b/drivers/gpu/drm/img-rogue/tlserver.c
@@ -270,6 +270,8 @@ TLServerCloseStreamKM(PTL_STREAM_DESC psSD)
 	IMG_BOOL	bDestroyStream;
 	IMG_BOOL	bIsWriteOnly = psSD->ui32Flags & PVRSRV_STREAM_FLAG_OPEN_WO ?
 	                           IMG_TRUE : IMG_FALSE;
+	IMG_BOOL	bNoOpenCB    = psSD->ui32Flags & PVRSRV_STREAM_FLAG_IGNORE_OPEN_CALLBACK ?
+	                           IMG_TRUE : IMG_FALSE;
 
 	PVR_DPF_ENTERED;
 
@@ -329,6 +331,12 @@ TLServerCloseStreamKM(PTL_STREAM_DESC psSD)
 	PVR_ASSERT(psGD->uiClientCnt > 0);
 	psGD->uiClientCnt--;
 
+	/* This callback is executed only on reader close. */
+	if (!bIsWriteOnly && psStream->pfOnReaderCloseCallback != NULL && !bNoOpenCB)
+	{
+		psStream->pfOnReaderCloseCallback(psStream->pvOnReaderCloseUserData);
+	}
+
 	OSLockRelease (psGD->hTLGDLock);
 
 	/* Destroy the stream if its TL_SNODE was removed from TL_GLOBAL_DATA */
@@ -503,7 +511,7 @@ TLServerDiscoverStreamsKM(const IMG_CHAR *pszNamePattern,
 	                                  ui32Size / PRVSRVTL_MAX_STREAM_NAME_SIZE);
 
 	/* Find "tlctrl" stream and reset it */
-	psNode = TLFindStreamNodeByName(PVRSRV_TL_CTLR_STREAM);
+	psNode = TLFindStreamNodeByName(PVRSRV_TL_CTRL_STREAM);
 	if (psNode != NULL)
 		TLStreamReset(psNode->psStream);
 
@@ -596,7 +604,7 @@ TLServerAcquireDataKM(PTL_STREAM_DESC psSD,
 
 			TL_COUNTER_INC(psSD->ui32NoDataSleep);
 
-			LOOP_UNTIL_TIMEOUT(NO_DATA_WAIT_PERIOD_US)
+			LOOP_UNTIL_TIMEOUT_US(NO_DATA_WAIT_PERIOD_US)
 			{
 				eError = OSEventObjectWaitTimeout(psSD->hReadEvent, ui64WaitInChunksUs);
 				if (eError == PVRSRV_OK)
@@ -625,7 +633,7 @@ TLServerAcquireDataKM(PTL_STREAM_DESC psSD,
 				{ /* Some other system error with event objects */
 					PVR_DPF_RETURN_RC(eError);
 				}
-			} END_LOOP_UNTIL_TIMEOUT();
+			} END_LOOP_UNTIL_TIMEOUT_US();
 
 			if (bDataFound)
 			{
diff --git a/drivers/gpu/drm/img-rogue/tlstream.c b/drivers/gpu/drm/img-rogue/tlstream.c
index b38a5cf56819..3d13ccf6b326 100644
--- a/drivers/gpu/drm/img-rogue/tlstream.c
+++ b/drivers/gpu/drm/img-rogue/tlstream.c
@@ -49,6 +49,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "allocmem.h"
 #include "devicemem.h"
 #include "pvrsrv_error.h"
+#include "sysinfo.h"
 #include "osfunc.h"
 #include "log2.h"
 
@@ -57,7 +58,13 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "pvrsrv.h"
 
-#define EVENT_OBJECT_TIMEOUT_US 1000000ULL
+/* Prefer CMA memory for TL buffers if possible */
+#define TL_USE_CMA 0
+
+#if !defined(EVENT_OBJECT_TIMEOUT_US)
+#error EVENT_OBJECT_TIMEOUT_US should be defined sysinfo.h
+#endif
+
 #define READ_PENDING_TIMEOUT_US 100000ULL
 
 /*! Compute maximum TL packet size for this stream. Max packet size will be
@@ -143,6 +150,7 @@ PVRSRV_ERROR TLAllocSharedMemIfNull(IMG_HANDLE hStream)
 {
 	PTL_STREAM psStream = (PTL_STREAM) hStream;
 	PVRSRV_ERROR eError;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	/* CPU Local memory used as these buffers are not accessed by the device.
 	 * CPU Uncached write combine memory used to improve write performance,
@@ -155,7 +163,24 @@ PVRSRV_ERROR TLAllocSharedMemIfNull(IMG_HANDLE hStream)
 	                                    PVRSRV_MEMALLOCFLAG_GPU_READABLE |
 	                                    PVRSRV_MEMALLOCFLAG_CPU_UNCACHED_WC |
 	                                    PVRSRV_MEMALLOCFLAG_KERNEL_CPU_MAPPABLE |
-	                                    PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(CPU_LOCAL); /* TL for now is only used by host driver, so cpulocal mem suffices */
+	                                    PVRSRV_MEMALLOCFLAG_PHYS_HEAP_HINT(CPU_LOCAL) |  /* TL for now is only used by host driver, so cpulocal mem suffices */
+	                                    PVRSRV_MEMALLOCFLAG_ZERO_ON_ALLOC;
+
+#if TL_USE_CMA
+	/* TL CTRL stream will be allocated as normal memory, os device node might not
+	 * be setup at this point of init and so we cannot allocate CMA.
+	 */
+	if (PVRSRVGetPVRSRVData()->psDeviceNodeList != NULL)
+	{
+
+		uiMemFlags |= PVRSRV_MEMALLOCFLAG_OS_LINUX_PREFER_CMA;
+		psDeviceNode = PVRSRVGetPVRSRVData()->psDeviceNodeList;
+	}
+	else
+#endif
+	{
+		psDeviceNode = PVRSRVGetPVRSRVData()->psHostMemDeviceNode;
+	}
 
 	/* Exit if memory has already been allocated. */
 	if (psStream->pbyBuffer != NULL)
@@ -164,12 +189,7 @@ PVRSRV_ERROR TLAllocSharedMemIfNull(IMG_HANDLE hStream)
 	OSSNPrintf(pszBufferLabel, sizeof(pszBufferLabel), "TLStreamBuf-%s",
 	           psStream->szName);
 
-
-	/* Use HostMemDeviceNode instead of psStream->psDevNode to benefit from faster
-	 * accesses to CPU local memory. When the framework to access CPU_LOCAL device
-	 * memory from GPU is fixed, we'll switch back to use psStream->psDevNode for
-	 * TL buffers */
-	eError = DevmemAllocateExportable((IMG_HANDLE)PVRSRVGetPVRSRVData()->psHostMemDeviceNode,
+	eError = DevmemAllocateExportable((IMG_HANDLE)psDeviceNode,
 	                                  (IMG_DEVMEM_SIZE_T) psStream->ui32Size,
 	                                  (IMG_DEVMEM_ALIGN_T) OSGetPageSize(),
 	                                  ExactLog2(OSGetPageSize()),
@@ -225,6 +245,8 @@ TLStreamCreate(IMG_HANDLE *phStream,
                IMG_UINT32 ui32StreamFlags,
                TL_STREAM_ONREADEROPENCB pfOnReaderOpenCB,
                void *pvOnReaderOpenUD,
+               TL_STREAM_ONREADERCLOSECB pfOnReaderCloseCB,
+               void *pvOnReaderCloseUD,
                TL_STREAM_SOURCECB pfProducerCB,
                void *pvProducerUD)
 {
@@ -273,7 +295,7 @@ TLStreamCreate(IMG_HANDLE *phStream,
 		goto e0;
 	}
 
-	OSStringLCopy(psTmp->szName, szStreamName, PRVSRVTL_MAX_STREAM_NAME_SIZE);
+	OSStringSafeCopy(psTmp->szName, szStreamName, PRVSRVTL_MAX_STREAM_NAME_SIZE);
 
 	if (ui32StreamFlags & TL_FLAG_FORCE_FLUSH)
 	{
@@ -306,6 +328,8 @@ TLStreamCreate(IMG_HANDLE *phStream,
 
 	psTmp->pfOnReaderOpenCallback = pfOnReaderOpenCB;
 	psTmp->pvOnReaderOpenUserData = pvOnReaderOpenUD;
+	psTmp->pfOnReaderCloseCallback = pfOnReaderCloseCB;
+	psTmp->pvOnReaderCloseUserData = pvOnReaderCloseUD;
 	/* Remember producer supplied CB and data for later */
 	psTmp->pfProducerCallback = (void(*)(void))pfProducerCB;
 	psTmp->pvProducerUserData = pvProducerUD;
@@ -394,6 +418,8 @@ TLStreamCreate(IMG_HANDLE *phStream,
 void TLStreamReset(IMG_HANDLE hStream)
 {
 	PTL_STREAM psStream = (PTL_STREAM) hStream;
+	IMG_HANDLE hEventWaitForWriterToComplete;
+	PVRSRV_ERROR eError;
 
 	PVR_ASSERT(psStream != NULL);
 
@@ -401,21 +427,26 @@ void TLStreamReset(IMG_HANDLE hStream)
 
 	while (psStream->ui32Pending != NOTHING_PENDING)
 	{
-		PVRSRV_ERROR eError;
-
 		/* We're in the middle of a write so we cannot reset the stream.
 		 * We are going to wait until the data is committed. Release lock while
 		 * we're here. */
 		OSLockRelease(psStream->hStreamWLock);
 
+		eError = OSEventObjectOpen(psStream->psNode->hReadEventObj,
+		                           &hEventWaitForWriterToComplete);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "OSEventObjectOpen");
+
 		/* Event when psStream->bNoSignalOnCommit is set we can still use
 		 * the timeout capability of event object API (time in us). */
-		eError = OSEventObjectWaitTimeout(psStream->psNode->hReadEventObj, 100);
+		eError = OSEventObjectWaitTimeout(hEventWaitForWriterToComplete, 100);
 		if (eError != PVRSRV_ERROR_TIMEOUT && eError != PVRSRV_OK)
 		{
-			PVR_LOG_RETURN_VOID_IF_ERROR(eError, "OSEventObjectWaitTimeout");
+			PVR_LOG_GOTO_IF_ERROR(eError, "OSEventObjectWaitTimeout", TimeoutError);
 		}
 
+		eError = OSEventObjectClose(hEventWaitForWriterToComplete);
+		PVR_LOG_RETURN_VOID_IF_ERROR(eError, "OSEventObjectClose");
+
 		OSLockAcquire(psStream->hStreamWLock);
 
 		/* Either timeout occurred or the stream has been signalled.
@@ -431,6 +462,12 @@ void TLStreamReset(IMG_HANDLE hStream)
 	/* we know that ui32Pending already has correct value (no need to set) */
 
 	OSLockRelease(psStream->hStreamWLock);
+
+	return;
+
+TimeoutError:
+	eError = OSEventObjectClose(hEventWaitForWriterToComplete);
+	PVR_LOG_IF_ERROR(eError, "OSEventObjectClose");
 }
 
 PVRSRV_ERROR
@@ -1623,3 +1660,43 @@ TLStreamGetBufferPointer(PTL_STREAM psStream)
 
 	PVR_DPF_RETURN_VAL(psStream->psStreamMemDesc);
 }
+
+/*
+ * Determine the maximum transfer size which will fit into the specified
+ * L2 consumer stream.
+ * This is a point-in-time snapshot which compares the given requested transfer
+ * size and returns the minimum of that vs the available buffer space within
+ * the L2 stream. This is the largest amount of data that can be successfully
+ * copied in the stream without truncation occurring.
+ * Worst-case scenario is that we copy fewer bytes than the maximum
+ * actually available, but we will never copy too much data.
+ */
+IMG_UINT32
+TLStreamGetMaxTransfer(IMG_UINT32 uiXferSize, IMG_HANDLE hConsumerStream)
+{
+	PTL_STREAM  psConsumer = (PTL_STREAM)hConsumerStream;
+	IMG_UINT32  ui32MaxTransfer = 0U;
+
+	IMG_UINT32  ui32Xfer;
+
+	/* Local copies */
+	IMG_UINT32	ui32Read = psConsumer->ui32Read;
+	IMG_UINT32	ui32Write = psConsumer->ui32Write;
+
+	if (ui32Write >= ui32Read)
+	{
+		/* Can transfer Write .. End-of-buffer + Read bytes at start */
+		ui32Xfer = psConsumer->ui32Size - ui32Write + ui32Read;
+	}
+	else
+	{
+		/* Can transfer Read - Write bytes maximum */
+		ui32Xfer = ui32Read - ui32Write;
+	}
+
+	PVR_ASSERT(ui32Xfer <= psConsumer->ui32Size);
+
+	ui32MaxTransfer = MIN(ui32Xfer, uiXferSize);
+
+	return ui32MaxTransfer;
+}
diff --git a/drivers/gpu/drm/img-rogue/tlstream.h b/drivers/gpu/drm/img-rogue/tlstream.h
index 911e720e7cdd..aa237bba4d79 100644
--- a/drivers/gpu/drm/img-rogue/tlstream.h
+++ b/drivers/gpu/drm/img-rogue/tlstream.h
@@ -181,6 +181,7 @@ typedef PVRSRV_ERROR (*TL_STREAM_SOURCECB)(IMG_HANDLE hStream,
 		IMG_UINT32 ui32ReqOp, IMG_UINT32* ui32Resp, void* pvUser);
 
 typedef void (*TL_STREAM_ONREADEROPENCB)(void *pvArg);
+typedef void (*TL_STREAM_ONREADERCLOSECB)(void *pvArg);
 
 /*************************************************************************/ /*!
  @Function      TLAllocSharedMemIfNull
@@ -220,6 +221,10 @@ TLFreeSharedMem(IMG_HANDLE hStream);
                                     opens this stream, may be null.
  @Input         pvOnReaderOpenUD    Optional user data for pfOnReaderOpenCB,
                                     may be null.
+ @Input         pfOnReaderCloseCB   Optional callback called when a client
+                                    closes this stream, may be null.
+ @Input         pvOnReaderCloseUD   Optional user data for pfOnReaderCloseCB,
+                                    may be null.
  @Input         pfProducerCB    Optional callback, may be null.
  @Input         pvProducerUD    Optional user data for callback, may be null.
  @Return        PVRSRV_ERROR_INVALID_PARAMS  NULL stream handle or string name
@@ -239,6 +244,8 @@ TLStreamCreate(IMG_HANDLE *phStream,
                IMG_UINT32 ui32StreamFlags,
                TL_STREAM_ONREADEROPENCB pfOnReaderOpenCB,
                void *pvOnReaderOpenUD,
+               TL_STREAM_ONREADERCLOSECB pfOnReaderCloseCB,
+               void *pvOnReaderCloseUD,
                TL_STREAM_SOURCECB pfProducerCB,
                void *pvProducerUD);
 
@@ -584,7 +591,7 @@ IMG_BOOL TLStreamOutOfData(IMG_HANDLE hStream);
  @Function      TLStreamResetProducerByteCount
  @Description   Reset the producer byte counter on the specified stream.
  @Input         hStream         Stream handle.
- @Input         IMG_UINT32      Value to reset counter to, often 0.
+ @Input         ui32Value       Value to reset counter to, often 0.
  @Return        PVRSRV_OK                   Success.
  @Return        PVRSRV_ERROR_STREAM_MISUSE  Success but the read and write
                                             positions did not match,
@@ -594,6 +601,18 @@ IMG_BOOL TLStreamOutOfData(IMG_HANDLE hStream);
 PVRSRV_ERROR
 TLStreamResetProducerByteCount(IMG_HANDLE hStream, IMG_UINT32 ui32Value);
 
+/*************************************************************************/ /*!
+ @Function      TLStreamGetMaxTransfer
+ @Description   Obtain the maximum number of bytes that can be submitted to
+                 a given stream.
+ @Input         uiXferSize         Requested transfer size from producer.
+ @Input         hConsumerStream    Stream handle for consumer.
+ @Return        IMG_UINT32         Amount of data that can be submitted to
+                                    the consumer stream.
+*/ /**************************************************************************/
+IMG_UINT32
+TLStreamGetMaxTransfer(IMG_UINT32 uiXferSize, IMG_HANDLE hConsumerStream);
+
 #endif /* TLSTREAM_H */
 /*****************************************************************************
  End of file (tlstream.h)
diff --git a/drivers/gpu/drm/img-rogue/vmm_impl.h b/drivers/gpu/drm/img-rogue/vmm_impl.h
index 9ac1f50e5d30..928a3f6bc9ac 100644
--- a/drivers/gpu/drm/img-rogue/vmm_impl.h
+++ b/drivers/gpu/drm/img-rogue/vmm_impl.h
@@ -48,6 +48,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "img_types.h"
 #include "pvrsrv_error.h"
+#include "pvrsrv_device.h"
 
 typedef enum _VMM_CONF_PARAM_
 {
@@ -197,7 +198,9 @@ typedef struct _VMM_PVZ_CONNECTION_
                 connection to the host.
  @Return        PVRSRV_OK on success. Otherwise, a PVRSRV error code
 ******************************************************************************/
-PVRSRV_ERROR VMMCreatePvzConnection(VMM_PVZ_CONNECTION **psPvzConnection);
-void VMMDestroyPvzConnection(VMM_PVZ_CONNECTION *psPvzConnection);
+PVRSRV_ERROR VMMCreatePvzConnection(VMM_PVZ_CONNECTION **psPvzConnection,
+									PVRSRV_DEVICE_CONFIG *psDevConfig);
+void VMMDestroyPvzConnection(VMM_PVZ_CONNECTION *psPvzConnection,
+							 PVRSRV_DEVICE_CONFIG *psDevConfig);
 
 #endif /* VMM_IMPL_H */
diff --git a/drivers/gpu/drm/img-rogue/vmm_pvz_server.c b/drivers/gpu/drm/img-rogue/vmm_pvz_server.c
index 995d3051b95f..7e67d397a908 100644
--- a/drivers/gpu/drm/img-rogue/vmm_pvz_server.c
+++ b/drivers/gpu/drm/img-rogue/vmm_pvz_server.c
@@ -55,15 +55,19 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 static inline void
 PvzServerLockAcquire(void)
 {
+#if !defined(FPGA)
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 	OSLockAcquire(psPVRSRVData->hPvzConnectionLock);
+#endif
 }
 
 static inline void
 PvzServerLockRelease(void)
 {
+#if !defined(FPGA)
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 	OSLockRelease(psPVRSRVData->hPvzConnectionLock);
+#endif
 }
 
 #define VALIDATE_DRVID_DEVID(ui32DriverID, ui32DevID) do {							\
@@ -103,7 +107,7 @@ PvzServerMapDevPhysHeap(IMG_UINT32 ui32DriverID,
 						IMG_UINT64 ui64Size,
 						IMG_UINT64 ui64PAddr)
 {
-#if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
+#if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) && !defined(FPGA)
 		/*
 		 * Reject hypercall if called on a system configured at build time to
 		 * preallocate the Guest's firmware heaps from static carveout memory.
@@ -136,6 +140,12 @@ PvzServerMapDevPhysHeap(IMG_UINT32 ui32DriverID,
 		/* Everything is ready for the firmware to start interacting with this OS */
 		eError = RGXFWSetFwOsState(psDeviceNode->pvDevice, ui32DriverID, RGXFWIF_OS_ONLINE);
 	}
+	else
+	{
+		PVR_DPF((PVR_DBG_ERROR, "%s: Paravirtualized request to map Guest%u's Firmware heap"
+								" rejected: Guest not allowed to run.", __func__, ui32DriverID));
+		eError = PVRSRV_ERROR_PVZ_OSID_IS_OFFLINE;
+	}
 e0:
 #endif /* defined(SUPPORT_RGX) */
 	PvzServerLockRelease();
@@ -148,14 +158,14 @@ PVRSRV_ERROR
 PvzServerUnmapDevPhysHeap(IMG_UINT32 ui32DriverID,
 						  IMG_UINT32 ui32DevID)
 {
-#if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS)
+#if defined(RGX_VZ_STATIC_CARVEOUT_FW_HEAPS) && !defined(FPGA)
 		/*
 		 * Reject hypercall if called on a system configured at built time to
 		 * preallocate the Guest's firmware heaps from static carveout memory.
 		 */
 		PVR_DPF((PVR_DBG_ERROR,
-		         "%s: Host PVZ config: Does not match with Guest PVZ config\n"
-		         "    Host preallocates the Guest's FW physheap from static memory carveouts at startup.\n", __func__));
+		         "%s: Host PVZ config: Does not match with Guest PVZ config."
+		         " Host preallocates the Guest's FW physheap from static memory carveouts at startup.", __func__));
 		return PVRSRV_ERROR_INVALID_PVZ_CONFIG;
 #else
 	PVRSRV_ERROR eError = PVRSRV_OK;
diff --git a/drivers/gpu/drm/img-rogue/vmm_type_stub.c b/drivers/gpu/drm/img-rogue/vmm_type_stub.c
index cafe57bbab77..8d03474e4839 100644
--- a/drivers/gpu/drm/img-rogue/vmm_type_stub.c
+++ b/drivers/gpu/drm/img-rogue/vmm_type_stub.c
@@ -94,16 +94,20 @@ static VMM_PVZ_CONNECTION gsStubVmmPvz =
 	}
 };
 
-PVRSRV_ERROR VMMCreatePvzConnection(VMM_PVZ_CONNECTION **psPvzConnection)
+PVRSRV_ERROR VMMCreatePvzConnection(VMM_PVZ_CONNECTION **psPvzConnection,
+									PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
+	PVR_UNREFERENCED_PARAMETER(psDevConfig);
 	PVR_LOG_RETURN_IF_FALSE((NULL != psPvzConnection), "VMMCreatePvzConnection", PVRSRV_ERROR_INVALID_PARAMS);
 	*psPvzConnection = &gsStubVmmPvz;
 	PVR_DPF((PVR_DBG_ERROR, "Using a stub VM manager type, no runtime VZ support"));
 	return PVRSRV_OK;
 }
 
-void VMMDestroyPvzConnection(VMM_PVZ_CONNECTION *psPvzConnection)
+void VMMDestroyPvzConnection(VMM_PVZ_CONNECTION *psPvzConnection,
+							 PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
+	PVR_UNREFERENCED_PARAMETER(psDevConfig);
 	PVR_LOG_IF_FALSE((NULL != psPvzConnection), "VMMDestroyPvzConnection");
 }
 
diff --git a/drivers/gpu/drm/img-rogue/vz_vmm_pvz.c b/drivers/gpu/drm/img-rogue/vz_vmm_pvz.c
index 5e0121950580..bb7c8f6426c6 100644
--- a/drivers/gpu/drm/img-rogue/vz_vmm_pvz.c
+++ b/drivers/gpu/drm/img-rogue/vz_vmm_pvz.c
@@ -63,8 +63,7 @@ PvzConnectionValidate(void)
 	if (psVmmPvz == NULL)
 	{
 		PVR_DPF((PVR_DBG_ERROR,
-				"%s: %s PVZ config: Unable to acquire PVZ connection",
-				__func__, PVRSRV_VZ_MODE_IS(GUEST) ? "Guest" : "Host"));
+				"%s: Unable to acquire PVZ connection", __func__));
 		eError = PVRSRV_ERROR_INVALID_PVZ_CONFIG;
 		goto e0;
 	}
@@ -96,14 +95,6 @@ PvzConnectionValidate(void)
 	 *  firmware state.
 	 */
 	PVR_LOG(("Using dynamic PVZ bootstrap setup"));
-
-	if (!PVRSRV_VZ_MODE_IS(GUEST)           &&
-			 (psVmmPvz->sServerFuncTab.pfnMapDevPhysHeap      == NULL ||
-			  psVmmPvz->sServerFuncTab.pfnUnmapDevPhysHeap    == NULL))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "%s: Host PVZ config: Functions for mapping a Guest's heaps not implemented\n", __func__));
-		eError = PVRSRV_ERROR_INVALID_PVZ_CONFIG;
-	}
 #endif
 
 	PvzConnectionRelease(psVmmPvz);
@@ -112,21 +103,17 @@ PvzConnectionValidate(void)
 }
 #endif /* (RGX_NUM_DRIVERS_SUPPORTED > 1) */
 
-PVRSRV_ERROR PvzConnectionInit(void)
+PVRSRV_ERROR PvzConnectionInit(PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
 	PVRSRV_ERROR eError;
-	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 
 #if (RGX_NUM_DRIVERS_SUPPORTED == 1)
-#if !defined(PVRSRV_NEED_PVR_DPF)
-	PVR_UNREFERENCED_PARAMETER(psPVRSRVData);
-# endif
+	PVR_UNREFERENCED_PARAMETER(psDevConfig);
 	PVR_DPF((PVR_DBG_ERROR, "This kernel driver does not support virtualization. Please rebuild with RGX_NUM_DRIVERS_SUPPORTED > 1"));
-	PVR_DPF((PVR_DBG_ERROR,	"Halting initialisation, cannot transition to %s mode",
-			psPVRSRVData->eDriverMode == DRIVER_MODE_HOST ? "host" : "guest"));
 	eError = PVRSRV_ERROR_NOT_SUPPORTED;
 	goto e0;
 #else
+	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
 
 	if ((psPVRSRVData->hPvzConnection != NULL) &&
 		(psPVRSRVData->hPvzConnectionLock != NULL))
@@ -141,7 +128,7 @@ PVRSRV_ERROR PvzConnectionInit(void)
 	PVR_LOG_GOTO_IF_ERROR(eError, "OSLockCreate", e0);
 
 	/* Create VM manager para-virtualization connection */
-	eError = VMMCreatePvzConnection((VMM_PVZ_CONNECTION **)&psPVRSRVData->hPvzConnection);
+	eError = VMMCreatePvzConnection((VMM_PVZ_CONNECTION **)&psPVRSRVData->hPvzConnection, psDevConfig);
 	if (eError != PVRSRV_OK)
 	{
 		OSLockDestroy(psPVRSRVData->hPvzConnectionLock);
@@ -159,22 +146,40 @@ PVRSRV_ERROR PvzConnectionInit(void)
 	return eError;
 }
 
-void PvzConnectionDeInit(void)
+void PvzConnectionDeInit(PVRSRV_DEVICE_CONFIG *psDevConfig)
 {
 	PVRSRV_DATA *psPVRSRVData = PVRSRVGetPVRSRVData();
+	PVRSRV_DEVICE_NODE *psDN;
+	IMG_BOOL bCanDestroyPvzData = IMG_TRUE;
 
-	if ((psPVRSRVData->hPvzConnection == NULL) &&
-		(psPVRSRVData->hPvzConnectionLock == NULL))
+	OSWRLockAcquireRead(psPVRSRVData->hDeviceNodeListLock);
+	for (psDN = psPVRSRVData->psDeviceNodeList; psDN != NULL; psDN = psDN->psNext)
 	{
-		PVR_DPF((PVR_DBG_MESSAGE, "PVzConnection already deinitialised."));
-		return;
+		if ((psDN->psDevConfig != psDevConfig) &&
+			(!PVRSRV_VZ_MODE_IS(NATIVE, DEVNODE, psDN)))
+		{
+			/* if any other virtual devices are present keep the pvz data */
+			bCanDestroyPvzData = IMG_FALSE;
+			break;
+		}
 	}
+	OSWRLockReleaseRead(psPVRSRVData->hDeviceNodeListLock);
 
-	VMMDestroyPvzConnection(psPVRSRVData->hPvzConnection);
-	psPVRSRVData->hPvzConnection = NULL;
+	if (bCanDestroyPvzData)
+	{
+		if ((psPVRSRVData->hPvzConnection == NULL) &&
+			(psPVRSRVData->hPvzConnectionLock == NULL))
+		{
+			PVR_DPF((PVR_DBG_MESSAGE, "PVzConnection already deinitialised."));
+			return;
+		}
+
+		VMMDestroyPvzConnection(psPVRSRVData->hPvzConnection, psDevConfig);
+		psPVRSRVData->hPvzConnection = NULL;
 
-	OSLockDestroy(psPVRSRVData->hPvzConnectionLock);
-	psPVRSRVData->hPvzConnectionLock = NULL;
+		OSLockDestroy(psPVRSRVData->hPvzConnectionLock);
+		psPVRSRVData->hPvzConnectionLock = NULL;
+	}
 }
 
 VMM_PVZ_CONNECTION* PvzConnectionAcquire(void)
diff --git a/drivers/gpu/drm/img-rogue/vz_vmm_pvz.h b/drivers/gpu/drm/img-rogue/vz_vmm_pvz.h
index a35461915866..03d5525936b8 100644
--- a/drivers/gpu/drm/img-rogue/vz_vmm_pvz.h
+++ b/drivers/gpu/drm/img-rogue/vz_vmm_pvz.h
@@ -56,8 +56,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                 be a hyper-call or cross-VM call
  @Return        PVRSRV_OK on success. Otherwise, a PVRSRV error code
 ******************************************************************************/
-PVRSRV_ERROR PvzConnectionInit(void);
-void PvzConnectionDeInit(void);
+PVRSRV_ERROR PvzConnectionInit(PVRSRV_DEVICE_CONFIG *psDevConfig);
+void PvzConnectionDeInit(PVRSRV_DEVICE_CONFIG *psDevConfig);
 
 /*!
 *******************************************************************************
diff --git a/drivers/gpu/drm/img-rogue/vz_vmm_vm.c b/drivers/gpu/drm/img-rogue/vz_vmm_vm.c
index 7e3a695dbb02..bc737f5acd81 100644
--- a/drivers/gpu/drm/img-rogue/vz_vmm_vm.c
+++ b/drivers/gpu/drm/img-rogue/vz_vmm_vm.c
@@ -247,11 +247,11 @@ PVRSRV_ERROR PvzVMMConfigure(VMM_CONF_PARAM eVMMParamType,
 		case VMM_CONF_TIME_SLICE_DRV7:
 		{
 			IMG_UINT32 ui32DriverID = eVMMParamType - VMM_CONF_TIME_SLICE_DRV0;
-			IMG_UINT32 ui32TimeSlice = ui32ParamValue;
+			IMG_UINT32 ui32TSPercentage = ui32ParamValue;
 
 			if (ui32DriverID < RGX_NUM_DRIVERS_SUPPORTED)
 			{
-				eError = PVRSRVRGXFWDebugSetDriverTimeSliceKM(NULL, psDevNode, ui32DriverID, ui32TimeSlice);
+				eError = PVRSRVRGXFWDebugSetDriverTimeSliceKM(NULL, psDevNode, ui32DriverID, ui32TSPercentage);
 			}
 			else
 			{
@@ -261,9 +261,9 @@ PVRSRV_ERROR PvzVMMConfigure(VMM_CONF_PARAM eVMMParamType,
 		}
 		case VMM_CONF_TIME_SLICE_INTERVAL:
 		{
-			IMG_UINT32 ui32TimeSliceInterval = ui32ParamValue;
+			IMG_UINT32 ui32TSIntervalMs = ui32ParamValue;
 
-			eError = PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(NULL, psDevNode, ui32TimeSliceInterval);
+			eError = PVRSRVRGXFWDebugSetDriverTimeSliceIntervalKM(NULL, psDevNode, ui32TSIntervalMs);
 			break;
 		}
 		case VMM_CONF_VZ_CONNECTION_COOLDOWN_PERIOD:
diff --git a/drivers/gpu/drm/spacemit/spacemit_dpu.c b/drivers/gpu/drm/spacemit/spacemit_dpu.c
index 752e26eab725..1bb85aefa055 100644
--- a/drivers/gpu/drm/spacemit/spacemit_dpu.c
+++ b/drivers/gpu/drm/spacemit/spacemit_dpu.c
@@ -299,6 +299,17 @@ static void spacemit_crtc_atomic_enable(struct drm_crtc *crtc,
 	DRM_INFO("%s(power on)\n", __func__);
 	trace_spacemit_crtc_atomic_enable(dpu->dev_id);
 
+	if (dpu->logo_booton && dpu->type == DSI) {
+		pm_runtime_enable(dpu->dev);
+
+		pm_runtime_get_sync(dpu->dev);
+		dpu_pm_resume(dpu->dev);
+		dpu_pm_suspend(dpu->dev);
+		pm_runtime_put_sync(dpu->dev);
+		dpu->logo_booton = false;
+		msleep(10);
+	}
+
 	pm_runtime_get_sync(dpu->dev);
 	dpu_pm_resume(dpu->dev);
 
@@ -952,13 +963,15 @@ static int spacemit_dpu_probe(struct platform_device *pdev)
 	}
 
 	dpu_num++;
-	pm_runtime_enable(&pdev->dev);
+
 	/*
 	 * To keep bootloader logo on, below operations must be
 	 * done in probe func as power domain framework will turn
 	 * on/off lcd power domain before/after probe func.
 	 */
-	if (dpu->logo_booton) {
+	if (dpu->logo_booton && dpu->type == HDMI) {
+		pm_runtime_enable(&pdev->dev);
+
 		pm_runtime_get_sync(&pdev->dev);
 		dpu_pm_resume(&pdev->dev);
 		dpu_pm_suspend(&pdev->dev);
diff --git a/drivers/input/misc/spacemit-pwrkey.c b/drivers/input/misc/spacemit-pwrkey.c
index ab8616dc2c56..9a33629f909b 100644
--- a/drivers/input/misc/spacemit-pwrkey.c
+++ b/drivers/input/misc/spacemit-pwrkey.c
@@ -30,7 +30,7 @@ static irqreturn_t pwrkey_fall_irq(int irq, void *_pwr)
 		fall_triggered = 1;
 	}
 
-	pm_stay_awake(pwr->dev.parent);
+	pm_wakeup_event(pwr->dev.parent, 0);
 
 	spin_unlock_irqrestore(&pm_lock, flags);
 
@@ -50,7 +50,7 @@ static irqreturn_t pwrkey_rise_irq(int irq, void *_pwr)
 		fall_triggered = 0;
 	}
 
-	pm_relax(pwr->dev.parent);
+	pm_wakeup_event(pwr->dev.parent, 0);
 
 	spin_unlock_irqrestore(&pm_lock, flags);
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 7b03cf22159f..40254f91a58a 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1424,4 +1424,5 @@ config TOUCHSCREEN_CHSC5XXX
 	  Say Y here if you have a touchscreen using Chsc5xxx.
 
 source "drivers/input/touchscreen/chsc5xxx/Kconfig"
+source "drivers/input/touchscreen/focaltech_touch/Kconfig"
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index c02712cad9d1..9bcb898d1ec8 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -123,3 +123,4 @@ obj-$(CONFIG_TOUCHSCREEN_HIMAX_HX83112B)	+= himax_hx83112b.o
 
 obj-$(CONFIG_TOUCHSCREEN_CHIPONE_TDDI)	+= chipone-tddi/
 obj-y += chsc5xxx/
+obj-y += focaltech_touch/
diff --git a/drivers/input/touchscreen/focaltech_touch/Kconfig b/drivers/input/touchscreen/focaltech_touch/Kconfig
new file mode 100755
index 000000000000..9d34d7437b75
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/Kconfig
@@ -0,0 +1,10 @@
+#
+# Focaltech Touchscreen driver configuration
+#
+
+config TOUCHSCREEN_FTS
+    tristate "Focaltech Touchscreen"
+    default m
+    help
+      Say Y here if you have Focaltech touch panel.
+      If unsure, say N.
diff --git a/drivers/input/touchscreen/focaltech_touch/Makefile b/drivers/input/touchscreen/focaltech_touch/Makefile
new file mode 100755
index 000000000000..8920bbe99576
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/Makefile
@@ -0,0 +1,22 @@
+# Makefile for the focaltech touchscreen drivers.
+
+obj-$(CONFIG_TOUCHSCREEN_FTS) += focaltech_tp.o
+focaltech_tp-y := focaltech_core.o \
+		focaltech_ex_fun.o \
+		focaltech_ex_mode.o \
+		focaltech_gesture.o \
+		focaltech_esdcheck.o \
+		focaltech_point_report_check.o \
+		focaltech_proximity.o
+
+
+
+focaltech_tp-y += focaltech_i2c.o
+
+
+
+
+
+
+focaltech_tp-y += focaltech_flash.o
+focaltech_tp-y += focaltech_flash/focaltech_upgrade_ft8201p.o
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_common.h b/drivers/input/touchscreen/focaltech_touch/focaltech_common.h
new file mode 100755
index 000000000000..a079d14ecf28
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_common.h
@@ -0,0 +1,193 @@
+/*
+ *
+ * FocalTech fts TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*****************************************************************************
+*
+* File Name: focaltech_common.h
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-16
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+#ifndef __LINUX_FOCALTECH_COMMON_H__
+#define __LINUX_FOCALTECH_COMMON_H__
+
+#include "focaltech_config.h"
+
+/*****************************************************************************
+* Macro definitions using #define
+*****************************************************************************/
+#define FTS_DRIVER_VERSION                  "FocalTech V4.2 20240407"
+
+#define BYTE_OFF_0(x)           (u8)((x) & 0xFF)
+#define BYTE_OFF_8(x)           (u8)(((x) >> 8) & 0xFF)
+#define BYTE_OFF_16(x)          (u8)(((x) >> 16) & 0xFF)
+#define BYTE_OFF_24(x)          (u8)(((x) >> 24) & 0xFF)
+#define FLAGBIT(x)              (0x00000001 << (x))
+#define FLAGBITS(x, y)          ((0xFFFFFFFF >> (32 - (y) - 1)) & (0xFFFFFFFF << (x)))
+
+#define FLAG_ICSERIALS_LEN      8
+#define FLAG_HID_BIT            10
+#define FLAG_IDC_BIT            11
+#define INTERVAL_READ_REG       200  /* unit:ms */
+#define TIMEOUT_READ_REG        1000 /* unit:ms */
+
+#define FTS_DELAY_RESUME_RESET  50  /* unit:ms */
+
+#define IC_SERIALS              (FTS_CHIP_TYPE & FLAGBITS(0, FLAG_ICSERIALS_LEN-1))
+#define IC_TO_SERIALS(x)        ((x) & FLAGBITS(0, FLAG_ICSERIALS_LEN-1))
+#define FTS_CHIP_IDC            ((FTS_CHIP_TYPE & FLAGBIT(FLAG_IDC_BIT)) == FLAGBIT(FLAG_IDC_BIT))
+#define FTS_HID_SUPPORTTED      ((FTS_CHIP_TYPE & FLAGBIT(FLAG_HID_BIT)) == FLAGBIT(FLAG_HID_BIT))
+
+#define FTS_MAX_CHIP_IDS        8
+
+#define FTS_CHIP_TYPE_MAPPING {{0x2C, 0x82, 0xC5, 0x82, 0xC5, 0x82, 0xD5, 0x82, 0xE5}}
+
+
+#define FILE_NAME_LENGTH                    128
+#define ENABLE                              1
+#define DISABLE                             0
+#define VALID                               1
+#define INVALID                             0
+#define FTS_CMD_START1                      0x55
+#define FTS_CMD_START2                      0xAA
+#define FTS_CMD_START_DELAY                 12
+#define FTS_CMD_READ_ID                     0x90
+#define FTS_CMD_READ_ID_LEN                 4
+#define FTS_CMD_READ_ID_LEN_INCELL          1
+#define FTS_CMD_READ_BOOT_STATE             0xD0
+#define FTS_CMD_READ_INFO                   0x5E
+
+/*register address*/
+#define FTS_REG_INT_CNT                     0x8F
+#define FTS_REG_FLOW_WORK_CNT               0x91
+#define FTS_REG_WORKMODE                    0x00
+#define FTS_REG_WORKMODE_FACTORY_VALUE      0x40
+#define FTS_REG_WORKMODE_WORK_VALUE         0x00
+#define FTS_REG_ESDCHECK_DISABLE            0x8D
+#define FTS_REG_CHIP_ID                     0xA3
+#define FTS_REG_CHIP_ID2                    0x9F
+#define FTS_REG_POWER_MODE                  0xA5
+#define FTS_REG_POWER_MODE_SLEEP            0x03
+#define FTS_REG_FW_VER                      0xA6
+#define FTS_REG_VENDOR_ID                   0xA8
+#define FTS_REG_LCD_BUSY_NUM                0xAB
+#define FTS_REG_FACE_DEC_MODE_EN            0xB0
+#define FTS_REG_FW_MODE                     0xB4
+#define FTS_REG_FACE_DEC_MODE_STATUS        0x01
+#define FTS_REG_IDE_PARA_VER_ID             0xB5
+#define FTS_REG_IDE_PARA_STATUS             0xB6
+#define FTS_REG_CHARGER_MODE_EN             0x8B
+#define FTS_REG_EDGEPALM_MODE_EN            0x8C
+#define FTS_REG_GLOVE_MODE_EN               0xC0
+#define FTS_REG_COVER_MODE_EN               0xC1
+#define FTS_REG_EARPHONE_MODE_EN            0xC3
+#define FTS_REG_GESTURE_EN                  0xD0
+#define FTS_REG_GESTURE_OUTPUT_ADDRESS      0xD3
+#define FTS_REG_PANEL_ID                    0xE3
+#define FTS_REG_LIC_VER                     0xE4
+#define FTS_REG_ESD_SATURATE                0xED
+#define FTS_REG_FOD_MODE_EN                 0xCF
+#define FTS_VAL_FOD_ENABLE                  0x02
+#define FTS_REG_FOD_DATA                    0xE1
+#define FTS_REG_TPINFO                      0x96
+#define FTS_REG_TPCFG                       0x9D
+#define FTS_MAX_RETRIES_READID              10
+#define FTS_MAX_RETRIES_READID_RESUME       5
+#define FTS_MAX_RETRIES_READ_BOOTID         5
+#define FTS_MAX_RETRIES_WRITEREG            5
+
+#define FTS_SYSFS_ECHO_ON(buf)      (buf[0] == '1')
+#define FTS_SYSFS_ECHO_OFF(buf)     (buf[0] == '0')
+
+#define kfree_safe(pbuf) do {\
+    if (pbuf) {\
+        kfree(pbuf);\
+        pbuf = NULL;\
+    }\
+} while(0)
+
+/*****************************************************************************
+*  Alternative mode (When something goes wrong, the modules may be able to solve the problem.)
+*****************************************************************************/
+/*
+ * point report check
+ * default: disable
+ */
+#define FTS_POINT_REPORT_CHECK_EN               0
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+struct ft_chip_t {
+    u16 type;
+    u8 chip_idh;
+    u8 chip_idl;
+    u8 rom_idh;
+    u8 rom_idl;
+    u8 pb_idh;
+    u8 pb_idl;
+    u8 bl_idh;
+    u8 bl_idl;
+};
+
+struct ft_chip_id_t {
+    u16 type;
+    u16 chip_ids[FTS_MAX_CHIP_IDS];
+};
+
+struct ts_ic_info {
+    bool is_incell;
+    bool hid_supported;
+    struct ft_chip_t ids;
+    struct ft_chip_id_t cid;
+};
+
+/*****************************************************************************
+* DEBUG function define here
+*****************************************************************************/
+#if FTS_DEBUG_EN
+#define FTS_DEBUG(fmt, args...) do { \
+    pr_debug(KERN_DEBUG "[FTS_TS]%s:"fmt"\n", __func__, ##args); \
+} while (0)
+
+#define FTS_FUNC_ENTER() do { \
+    pr_debug(KERN_DEBUG "[FTS_TS]%s: Enter\n", __func__); \
+} while (0)
+
+#define FTS_FUNC_EXIT() do { \
+    pr_debug(KERN_DEBUG "[FTS_TS]%s: Exit(%d)\n", __func__, __LINE__); \
+} while (0)
+#else /* #if FTS_DEBUG_EN*/
+#define FTS_DEBUG(fmt, args...)
+#define FTS_FUNC_ENTER()
+#define FTS_FUNC_EXIT()
+#endif
+
+#define FTS_INFO(fmt, args...) do { \
+    pr_info(KERN_INFO "[FTS_TS/I]%s:"fmt"\n", __func__, ##args); \
+} while (0)
+
+#define FTS_ERROR(fmt, args...) do { \
+    pr_err(KERN_ERR "[FTS_TS/E]%s:"fmt"\n", __func__, ##args); \
+} while (0)
+#endif /* __LINUX_FOCALTECH_COMMON_H__ */
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_config.h b/drivers/input/touchscreen/focaltech_touch/focaltech_config.h
new file mode 100755
index 000000000000..0ac5ca6ac35c
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_config.h
@@ -0,0 +1,362 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/************************************************************************
+*
+* File Name: focaltech_config.h
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract: global configurations
+*
+* Version: v1.0
+*
+************************************************************************/
+#ifndef _LINUX_FOCLATECH_CONFIG_H_
+#define _LINUX_FOCLATECH_CONFIG_H_
+
+/**************************************************/
+/****** G: A, I: B, S: C, U: D  ******************/
+/****** chip type defines, do not modify *********/
+#define _FT8716             0x87160805
+#define _FT8736             0x87360806
+#define _FT8607             0x86070809
+#define _FT8006U            0x8006D80B
+#define _FT8006S            0x8006A80B
+#define _FT8613             0x8613080C
+#define _FT8719             0x8719080D
+#define _FT8739             0x8739080E
+#define _FT8615             0x8615080F
+#define _FT8201             0x82010810
+#define _FT8201AA           0x8201A810
+#define _FT8006P            0x86220811
+#define _FT8613S            0x8613C814
+#define _FT8756             0x87560815
+#define _FT8656             0x86560815
+#define _FT8756M            0x8756A815
+#define _FT8302             0x83020816
+#define _FT8009             0x80090817
+#define _FT8006S_AA         0x86320819
+#define _FT7250             0x7250081A
+#define _FT7120             0x7120081B
+#define _FT8720             0x8720081C
+#define _FT8726             0x8726081C
+#define _FT8720H            0x8720E81C
+#define _FT8720M            0x8720F81C
+#define _FT8016             0x8016081D
+#define _FT8006S_AB         0x8642081F
+#define _FT8722             0x87220820
+#define _FT8201AB           0x8201B821
+#define _FT8203             0x82030821
+#define _FT8201M            0x8201C821
+#define _FT8006S_AN         0x8006B822
+#define _FT7131             0x71310823
+#define _FT7250AB           0x7250B824
+#define _FT7130             0x71300825
+#define _FT8205             0x82050826
+#define _FT2389             0x23890827
+#define _FT8057             0x80570828
+#define _FT8057S            0x8057C828
+#define _FT8725             0x87250829
+#define _FT7135             0x71350829
+#define _FT8206             0x8206082A
+#define _FT8057P            0x8057082B
+#define _FT7133             0x7133082B
+#define _FT8205P            0x8205082C
+#define _FT8201P            0x8201082C
+#define _FT8201S            0x8201C82C
+#define _FT7250P            0x7250082C
+
+
+#define _FT5426             0x54260402
+#define _FT5436             0x54360402
+#define _FT5526             0x55260402
+#define _FT5446             0x54460402
+#define _FT5346             0x53460402
+#define _FT7661             0x76610402
+#define _FT7511             0x75110402
+#define _FT7421             0x74210402
+#define _FT7681             0x76810402
+#define _FT3417             0x34170402
+#define _FT3517             0x35170402
+#define _FT3327             0x33270402
+#define _FT3427             0x34270402
+#define _FT7311             0x73110402
+#define _FT5526_V00         0x5526C402
+
+#define _FT5726             0x57260401
+#define _FT5826S            0x5826C401
+#define _FT7811             0x78110401
+#define _FT3617             0x36170401
+#define _FT3717             0x37170401
+
+#define _FT6236U            0x6236D003
+#define _FT6336G            0x6336A003
+#define _FT6336U            0x6336D003
+#define _FT6436U            0x6436D003
+#define _FT6436T            0x6436E003
+
+#define _FT3267             0x32670004
+#define _FT3367             0x33670004
+
+#define _FT5446_Q03         0x5446C482
+#define _FT5446_P03         0x5446A481
+#define _FT5446_N03         0x5446A489
+#define _FT5426_003         0x5426D482
+#define _FT5526_003         0x5526D482
+#define _FT3437_003         0x34370482
+
+#define _FT3518             0x35180481
+#define _FT3518U            0x3518D481
+#define _FT3558             0x35580481
+#define _FT3528             0x35280481
+#define _FT5536             0x55360481
+#define _FT3418             0x34180481
+#define _FT5536G            0x5536A481
+
+#define _FT5446U            0x5446D083
+#define _FT5456U            0x5456D083
+#define _FT5426U            0x5426D083
+
+#define _FT7302             0x73020084
+#define _FT7202             0x72020084
+#define _FT3308             0x33080084
+#define _FT6446             0x64460084
+
+#define _FT6346U            0x6346D085
+#define _FT6346G            0x6346A085
+#define _FT3067             0x30670085
+#define _FT3068             0x30680085
+#define _FT3168             0x31680085
+#define _FT3268             0x32680085
+#define _FT6146             0x61460085
+#define _FT3168G            0x3168A085
+#define _FT6347             0x63470085
+
+#define _FT5726_003         0x5726D486
+#define _FT5726_V03         0x5726C486
+#define _FT3617_003         0x3617D486
+
+#define _FT3618             0x36180487
+#define _FT5646             0x56460487
+#define _FT3A58             0x3A580487
+#define _FT3B58             0x3B580487
+#define _FT3D58             0x3D580487
+#define _FT3D59             0x3D590487
+#define _FT5936             0x59360487
+#define _FT5A36             0x5A360487
+#define _FT5B36             0x5B360487
+#define _FT5D36             0x5D360487
+#define _FT5946             0x59460487
+#define _FT5A46             0x5A460487
+#define _FT5B46             0x5B460487
+#define _FT5D46             0x5D460487
+
+#define _FT3658U            0x3658D488
+#define _FT3658G            0x3658A488
+
+#define _FT3519             0x35190489
+#define _FT3519T            0x3519E489
+#define _FT3519U            0x3519D489
+#define _FT3419             0x34190489
+#define _FT5536U_003        0x5536D489
+#define _FT5426G            0x5426A489
+#define _FT3437_N03         0x34370489
+#define _FT7411             0x74110489
+#define _FT7411A            0x7411A489
+#define _FT7511A            0x7511A489
+#define _FT7511U            0x7511D489
+
+#define _FT3680             0x3680008A
+#define _FT368A             0x368A008A
+#define _FT3681             0x3681008A
+#define _FT3881             0x3881008A
+
+#define _FT3169             0x3169008B
+#define _FT3269             0x3269008B
+
+#define _FT3658S            0x3658C48C
+
+#define _FT3A81             0x3A81048D
+#define _FT3B81             0x3B81048D
+#define _FT3D81             0x3D81048D
+
+#define _FT5B36U            0x5B36D48E
+
+#define _FT3682             0x3682008F
+#define _FT3C82             0x3C82008F
+
+#define _FT3683G            0x56720090
+#define _FT3683U            0x3683D090
+#define _FT7510             0x75100090
+#define _FT7512             0x75120090
+#define _FT3683             0x36830092
+
+#define _FT3D81_003         0x3D81B491
+
+#define _FT3510             0x35100093
+#define _FT3610             0x36100093
+#define _FT3383             0x33830093
+
+
+
+/*************************************************/
+
+/*
+ * choose your ic chip type of focaltech
+ */
+#define FTS_CHIP_TYPE   _FT8201P
+
+/******************* Enables *********************/
+/*********** 1 to enable, 0 to disable ***********/
+
+/*
+ * show debug log info
+ * enable it for debug, disable it for release
+ */
+#define FTS_DEBUG_EN                            1
+
+/*
+ * Linux MultiTouch Protocol
+ * 1: Protocol B(default), 0: Protocol A
+ */
+#define FTS_MT_PROTOCOL_B_EN                    1
+
+/*
+ * Report Pressure in multitouch
+ * 1:enable(default),0:disable
+*/
+#define FTS_REPORT_PRESSURE_EN                  0
+
+/*
+ * Stylus PEN enable
+ * 1:enable(default),0:disable
+*/
+#define FTS_PEN_EN                              0
+
+/*
+ * Proximity function enable
+ * default: disable
+ */
+#define FTS_PSENSOR_EN                          0
+
+/*
+ * FOD function enable
+ * default: disable
+ */
+#define FTS_FOD_EN                              0
+
+/*
+ * ESD check & protection
+ * default: disable
+ */
+#define FTS_ESDCHECK_EN                         0
+
+/*
+ * Pinctrl enable
+ * default: disable
+ */
+#define FTS_PINCTRL_EN                          0
+
+/* power policy:
+ * FTS_POWER_SOURCE_CUST_EN,FTS_POWER_SUSPEND_OFF_EN
+ *  0,0:typically for IDC chip,not control power when probing and suspending.
+ *  0,1:only for IDC,LCD driver sets IDC power to off when suspending,so need
+ *      set tp_rst pin to low in tp driver.
+ *  1,0:typically for OLED touch chip, not set power to off when suspending.
+ *  1,1:typically for touch chip,control power when probing and suspending.
+ */
+/*
+ * Customer power enable
+ * enable it when customer need control TP power
+ * default: disable
+ */
+#define FTS_POWER_SOURCE_CUST_EN                0
+
+/* Set power to off state when entering into suspend
+ * default:disable
+ */
+#define FTS_POWER_SUSPEND_OFF_EN                0
+
+
+/****************************************************/
+
+/********************** Upgrade ****************************/
+/*
+ * auto upgrade
+ */
+#define FTS_AUTO_UPGRADE_EN                     0
+
+/* for none flash project, set it to be the using FW number */
+#define FTS_MULTI_FW_NUM                        0
+
+/*
+ * auto upgrade for lcd cfg
+ */
+#define FTS_AUTO_LIC_UPGRADE_EN                 0
+
+/*
+ * Numbers of modules support
+ */
+#define FTS_GET_MODULE_NUM                      0
+
+/*
+ * module_id: mean vendor_id generally, also maybe gpio or lcm_id...
+ * If means vendor_id, the FTS_MODULE_ID = PANEL_ID << 8 + VENDOR_ID
+ * FTS_GET_MODULE_NUM == 0/1, no check module id, you may ignore them
+ * FTS_GET_MODULE_NUM >= 2, compatible with FTS_MODULE2_ID
+ * FTS_GET_MODULE_NUM >= 3, compatible with FTS_MODULE3_ID
+ */
+#define FTS_MODULE_ID                           0x0000
+#define FTS_MODULE2_ID                          0x0000
+#define FTS_MODULE3_ID                          0x0000
+
+/*
+ * Need set the following when get firmware via firmware_request()
+ * For example: if module'vendor is tianma,
+ * #define FTS_MODULE_NAME                        "tianma"
+ * then file_name will be "focaltech_ts_fw_tianma"
+ * You should rename fw to "focaltech_ts_fw_tianma", and push it into
+ * etc/firmware or by customers
+ */
+#define FTS_MODULE_NAME                         ""
+#define FTS_MODULE2_NAME                        ""
+#define FTS_MODULE3_NAME                        ""
+
+/*
+ * FW.i file for auto upgrade, you must replace it with your own
+ * define your own fw_file, the sample one to be replaced is invalid
+ * NOTE: if FTS_GET_MODULE_NUM > 1, it's the fw corresponding with FTS_MODULE_ID
+ */
+#define FTS_UPGRADE_FW_FILE                     "include/firmware/fw_sample.bin"
+
+/*
+ * if FTS_GET_MODULE_NUM >= 2, fw corrsponding with FTS_MODULE2_ID
+ * define your own fw_file, the sample one is invalid
+ */
+#define FTS_UPGRADE_FW2_FILE                    "include/firmware/fw_sample.bin"
+
+/*
+ * if FTS_GET_MODULE_NUM >= 3, fw corrsponding with FTS_MODULE3_ID
+ * define your own fw_file, the sample one is invalid
+ */
+#define FTS_UPGRADE_FW3_FILE                    "include/firmware/fw_sample.bin"
+
+/*********************************************************/
+
+#endif /* _LINUX_FOCLATECH_CONFIG_H_ */
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_core.c b/drivers/input/touchscreen/focaltech_touch/focaltech_core.c
new file mode 100755
index 000000000000..4a86fbbade2e
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_core.c
@@ -0,0 +1,2592 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*****************************************************************************
+*
+* File Name: focaltech_core.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract: entrance for focaltech ts driver
+*
+* Version: V1.0
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+#include <soc/spacemit/spacemit_panel.h>
+#endif
+
+#if IS_ENABLED(CONFIG_DRM)
+#if IS_ENABLED(CONFIG_DRM_PANEL)
+#include <drm/drm_panel.h>
+#else
+#include <linux/msm_drm_notify.h>
+#endif //CONFIG_DRM_PANEL
+
+#elif IS_ENABLED(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif //CONFIG_DRM
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_DRIVER_PEN_NAME                 "fts_ts,pen"
+
+#if FTS_POWER_SOURCE_CUST_EN
+#define FTS_VTG_MIN_UV                      2800000
+#define FTS_VTG_MAX_UV                      3300000
+#define FTS_IOVCC_VTG_MIN_UV                1800000
+#define FTS_IOVCC_VTG_MAX_UV                1800000
+#endif
+
+#define FTS_WAKELOCK_TIMEOUT                5000
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+struct fts_ts_data *fts_data;
+
+#if FTS_FOD_EN
+static int fts_fod_recovery(struct fts_ts_data *ts_data);
+#endif
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+void fts_msleep(unsigned long msecs)
+{
+    if (msecs > 20) {
+        msleep(msecs);
+    } else if (msecs > 0) {
+        usleep_range(msecs * 1000, (msecs + 2) * 1000);
+    }
+}
+
+int fts_check_cid(struct fts_ts_data *ts_data, u8 id_h)
+{
+    int i = 0;
+    struct ft_chip_id_t *cid = &ts_data->ic_info.cid;
+    u8 cid_h = 0x0;
+
+    if (cid->type == 0)
+        return -ENODATA;
+
+    for (i = 0; i < FTS_MAX_CHIP_IDS; i++) {
+        cid_h = ((cid->chip_ids[i] >> 8) & 0x00FF);
+        if (cid_h && (id_h == cid_h)) {
+            return 0;
+        }
+    }
+
+    return -ENODATA;
+}
+
+/*****************************************************************************
+*  Name: fts_wait_tp_to_valid
+*  Brief: Read chip id until TP FW become valid(Timeout: TIMEOUT_READ_REG),
+*         need call when reset/power on/resume...
+*  Input:
+*  Output:
+*  Return: return 0 if tp valid, otherwise return error code
+*****************************************************************************/
+int fts_wait_tp_to_valid(void)
+{
+    int ret = 0;
+    int i = 0;
+    u8 idh = 0xFF;
+    struct fts_ts_data *ts_data = fts_data;
+    u8 chip_idh = ts_data->ic_info.ids.chip_idh;
+
+    for (i = 0; i < FTS_MAX_RETRIES_READID; i++) {
+        ret = fts_read_reg(FTS_REG_CHIP_ID, &idh);
+        if ((idh == chip_idh) || (fts_check_cid(ts_data, idh) == 0)) {
+            FTS_INFO("TP Ready,Device ID:0x%02x", idh);
+            return 0;
+        }
+        if ((i + 1) < FTS_MAX_RETRIES_READID) fts_msleep((i + 1) * 20);
+    }
+
+    FTS_ERROR("TP Not Ready,ReadData:0x%02x,ret:%d", idh, ret);
+    return -EIO;
+}
+
+/*****************************************************************************
+*  Name: fts_tp_state_recovery
+*  Brief: Need execute this function when reset
+*  Input:
+*  Output:
+*  Return:
+*****************************************************************************/
+void fts_tp_state_recovery(struct fts_ts_data *ts_data)
+{
+    fts_wait_tp_to_valid();
+    fts_ex_mode_recovery(ts_data);
+#if FTS_PSENSOR_EN
+    if (ts_data->proximity_mode) {
+        fts_proximity_recovery(ts_data);
+        return;
+    }
+#endif
+#if FTS_FOD_EN
+    fts_fod_recovery(ts_data);
+#endif
+    fts_gesture_recovery(ts_data);
+}
+
+static int fts_reset_pre(struct fts_ts_data *ts_data, int value)
+{
+    u16 ic_type = ts_data->ic_info.ids.type;
+    if (!value) {
+        if ((ic_type == 0x90) || (ic_type == 0x92) || (ic_type == 0x93)) {
+            if (!ts_data->power_disabled) {
+                FTS_DEBUG("write regb6");
+                fts_write_reg(0xB6, 1);
+                fts_msleep(20);
+            }
+        }
+    }
+    return 0;
+}
+
+static int fts_reset_post(struct fts_ts_data *ts_data, int value)
+{
+
+    return 0;
+}
+
+int fts_set_reset(struct fts_ts_data *ts_data, int value)
+{
+    int ret = 0;
+
+    FTS_INFO("set reset to %d", !!value);
+    fts_reset_pre(ts_data, value);
+    ret = gpio_direction_output(ts_data->pdata->reset_gpio, !!value);
+    if (ret) {
+        FTS_ERROR("[GPIO]set reset gpio to %d failed", !!value);
+        return ret;
+    }
+    fts_reset_post(ts_data, value);
+    return 0;
+}
+
+int fts_reset_proc(struct fts_ts_data *ts_data, int force, int hdelayms)
+{
+    if (force || (!ts_data->fw_loading)) {
+        fts_set_reset(ts_data, 0);
+        fts_msleep(2);
+        fts_set_reset(ts_data, 1);
+        if (hdelayms) fts_msleep(hdelayms);
+    } else {
+        FTS_INFO("fw upgrade in process, no reset");
+    }
+
+    return 0;
+}
+
+void fts_irq_disable(void)
+{
+    unsigned long irqflags;
+
+    FTS_FUNC_ENTER();
+    spin_lock_irqsave(&fts_data->irq_lock, irqflags);
+
+    if (!fts_data->irq_disabled) {
+        disable_irq_nosync(fts_data->irq);
+        fts_data->irq_disabled = true;
+    }
+
+    spin_unlock_irqrestore(&fts_data->irq_lock, irqflags);
+    FTS_FUNC_EXIT();
+}
+
+void fts_irq_enable(void)
+{
+    unsigned long irqflags = 0;
+
+    FTS_FUNC_ENTER();
+    spin_lock_irqsave(&fts_data->irq_lock, irqflags);
+
+    if (fts_data->irq_disabled) {
+        enable_irq(fts_data->irq);
+        fts_data->irq_disabled = false;
+    }
+
+    spin_unlock_irqrestore(&fts_data->irq_lock, irqflags);
+    FTS_FUNC_EXIT();
+}
+
+int fts_hid2std(int mode)
+{
+    int ret = 0;
+    u8 buf[3] = {0xEB, 0xAA, 0x09};
+    u8 val[3] = { 0 };
+
+    if (fts_data->bus_type != BUS_TYPE_I2C)
+        return 0;
+
+    if (mode == 1) {
+        /* Don't need delay */
+        ret = fts_read(buf, 3, val, 3);
+        if (ret < 0) {
+            FTS_ERROR("send hid2std cmd failed");
+            return ret;
+        }
+    } else {
+        ret = fts_write(buf, 3);
+        if (ret < 0) {
+            FTS_ERROR("hid2std cmd write fail");
+            return ret;
+        }
+
+        fts_msleep(10);
+        ret = fts_read(NULL, 0, val, 3);
+        if (ret < 0) {
+            FTS_ERROR("hid2std cmd read fail");
+            return ret;
+        }
+    }
+
+    if ((0xEB == val[0]) && (0xAA == val[1]) && (0x08 == val[2])) {
+        FTS_INFO("hidi2c change to stdi2c successful");
+    } else {
+        FTS_INFO("hidi2c change to stdi2c not support or fail");
+    }
+    return 0;
+}
+
+static int fts_match_cid(struct fts_ts_data *ts_data,
+                         u16 type, u8 id_h, u8 id_l, bool force)
+{
+#ifdef FTS_CHIP_ID_MAPPING
+    u32 i = 0;
+    u32 j = 0;
+    struct ft_chip_id_t chip_id_list[] = FTS_CHIP_ID_MAPPING;
+    u32 cid_entries = sizeof(chip_id_list) / sizeof(struct ft_chip_id_t);
+    u16 id = (id_h << 8) + id_l;
+
+    memset(&ts_data->ic_info.cid, 0, sizeof(struct ft_chip_id_t));
+    for (i = 0; i < cid_entries; i++) {
+        if (!force && (type == chip_id_list[i].type)) {
+            break;
+        } else if (force && (type == chip_id_list[i].type)) {
+            FTS_INFO("match cid,type:0x%x", (int)chip_id_list[i].type);
+            ts_data->ic_info.cid = chip_id_list[i];
+            return 0;
+        }
+    }
+
+    if (i >= cid_entries) {
+        return -ENODATA;
+    }
+
+    for (j = 0; j < FTS_MAX_CHIP_IDS; j++) {
+        if (id == chip_id_list[i].chip_ids[j]) {
+            FTS_DEBUG("cid:%x==%x", id, chip_id_list[i].chip_ids[j]);
+            FTS_INFO("match cid,type:0x%x", (int)chip_id_list[i].type);
+            ts_data->ic_info.cid = chip_id_list[i];
+            return 0;
+        }
+    }
+
+    return -ENODATA;
+#else
+    return -EINVAL;
+#endif
+}
+
+
+static int fts_get_chip_types(
+    struct fts_ts_data *ts_data,
+    u8 id_h, u8 id_l, bool fw_valid)
+{
+    u32 i = 0;
+    struct ft_chip_t ctype[] = FTS_CHIP_TYPE_MAPPING;
+    u32 ctype_entries = sizeof(ctype) / sizeof(struct ft_chip_t);
+
+    if ((0x0 == id_h) || (0x0 == id_l)) {
+        FTS_ERROR("id_h/id_l is 0");
+        return -EINVAL;
+    }
+
+    FTS_INFO("verify id:0x%02x%02x", id_h, id_l);
+    for (i = 0; i < ctype_entries; i++) {
+        if (VALID == fw_valid) {
+            if (((id_h == ctype[i].chip_idh) && (id_l == ctype[i].chip_idl))
+                || (!fts_match_cid(ts_data, ctype[i].type, id_h, id_l, 0)))
+                break;
+        } else {
+            if (((id_h == ctype[i].rom_idh) && (id_l == ctype[i].rom_idl))
+                || ((id_h == ctype[i].pb_idh) && (id_l == ctype[i].pb_idl))
+                || ((id_h == ctype[i].bl_idh) && (id_l == ctype[i].bl_idl))) {
+                break;
+            }
+        }
+    }
+
+    if (i >= ctype_entries) {
+        return -ENODATA;
+    }
+
+    fts_match_cid(ts_data, ctype[i].type, id_h, id_l, 1);
+    ts_data->ic_info.ids = ctype[i];
+    return 0;
+}
+
+static int fts_read_bootid(struct fts_ts_data *ts_data, u8 *id)
+{
+    int ret = 0;
+    u8 chip_id[2] = { 0 };
+    u8 id_cmd[4] = { 0 };
+    u32 id_cmd_len = 0;
+
+    id_cmd[0] = FTS_CMD_START1;
+    id_cmd[1] = FTS_CMD_START2;
+    ret = fts_write(id_cmd, 2);
+    if (ret < 0) {
+        FTS_ERROR("start cmd write fail");
+        return ret;
+    }
+
+    fts_msleep(FTS_CMD_START_DELAY);
+    id_cmd[0] = FTS_CMD_READ_ID;
+    id_cmd[1] = id_cmd[2] = id_cmd[3] = 0x00;
+    if (ts_data->ic_info.is_incell)
+        id_cmd_len = FTS_CMD_READ_ID_LEN_INCELL;
+    else
+        id_cmd_len = FTS_CMD_READ_ID_LEN;
+    ret = fts_read(id_cmd, id_cmd_len, chip_id, 2);
+    if ((ret < 0) || (0x0 == chip_id[0]) || (0x0 == chip_id[1])) {
+        FTS_ERROR("read boot id fail,read:0x%02x%02x", chip_id[0], chip_id[1]);
+        return -EIO;
+    }
+
+    id[0] = chip_id[0];
+    id[1] = chip_id[1];
+    return 0;
+}
+
+/*****************************************************************************
+* Name: fts_get_ic_information
+* Brief: read chip id to get ic information, after run the function, driver w-
+*        ill know which IC is it.
+*        If cant get the ic information, maybe not focaltech's touch IC, need
+*        unregister the driver
+* Input:
+* Output:
+* Return: return 0 if get correct ic information, otherwise return error code
+*****************************************************************************/
+static int fts_get_ic_information(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    int cnt = 0;
+    u8 chip_id[2] = { 0 };
+
+    ts_data->ic_info.is_incell = FTS_CHIP_IDC;
+    ts_data->ic_info.hid_supported = FTS_HID_SUPPORTTED;
+
+
+    do {
+        ret = fts_read_reg(FTS_REG_CHIP_ID, &chip_id[0]);
+        ret = fts_read_reg(FTS_REG_CHIP_ID2, &chip_id[1]);
+        if ((ret < 0) || (0x0 == chip_id[0]) || (0x0 == chip_id[1])) {
+            FTS_INFO("chip id read invalid, read:0x%02x%02x",
+                     chip_id[0], chip_id[1]);
+        } else {
+            ret = fts_get_chip_types(ts_data, chip_id[0], chip_id[1], VALID);
+            if (!ret)
+                break;
+            else
+                FTS_INFO("TP not ready, read:0x%02x%02x",
+                         chip_id[0], chip_id[1]);
+        }
+
+        cnt++;
+        fts_msleep(INTERVAL_READ_REG);
+    } while ((cnt * INTERVAL_READ_REG) < TIMEOUT_READ_REG);
+
+    if ((cnt * INTERVAL_READ_REG) >= TIMEOUT_READ_REG) {
+        FTS_INFO("fw is invalid, need read boot id");
+        for (cnt = 0; cnt < FTS_MAX_RETRIES_READ_BOOTID; cnt++) {
+            if (cnt < 2) {
+                if (ts_data->ic_info.hid_supported) fts_hid2std(0);
+            } else {
+                fts_reset_proc(ts_data, true, 0);
+                mdelay(FTS_CMD_START_DELAY + (cnt - 2) * 8);
+                if (ts_data->ic_info.hid_supported) {
+                    fts_hid2std(1);
+                    fts_write_reg(0x55, 0xAA);
+                    fts_msleep(FTS_CMD_START_DELAY);
+                    fts_hid2std(1);
+                }
+            }
+
+            ret = fts_read_bootid(ts_data, &chip_id[0]);
+            if (ret <  0) {
+                FTS_ERROR("read boot id fail");
+                continue;
+            }
+
+            ret = fts_get_chip_types(ts_data, chip_id[0], chip_id[1], INVALID);
+            if (ret < 0) {
+                FTS_ERROR("can't get ic informaton");
+                continue;
+            }
+            break;
+        }
+    }
+
+    FTS_INFO("get ic information, chip id = 0x%02x%02x(cid type=0x%x)",
+             ts_data->ic_info.ids.chip_idh, ts_data->ic_info.ids.chip_idl,
+             ts_data->ic_info.cid.type);
+
+    return ret;
+}
+
+#if FTS_READ_CUSTOMER_INFO
+static int fts_read_customer_information(struct fts_ts_data *ts_data)
+{
+    /* If some customer's code had written to touch chip, please do the followings:
+     *  Step 1: read customer information here.
+     *  Step 2: save customer information to ts_data->customer_info variable, maximum 32.
+     *  Step 3: return ts_data->customer_info to APP via sysfs node.
+     *
+     * Warning: please check the information is read from FW or not, if from FW, please
+     *          take care that FW maybe isn't valid.
+     */
+
+
+    FTS_INFO("customer info:%s", ts_data->customer_info);
+    return 0;
+}
+#endif
+
+#if FTS_FOD_EN
+static void fts_fod_set_reg(int value)
+{
+    int i = 0;
+    u8 fod_val = value ? FTS_VAL_FOD_ENABLE : DISABLE;
+    u8 regval = 0xFF;
+
+    for (i = 0; i < FTS_MAX_RETRIES_WRITEREG; i++) {
+        fts_read_reg(FTS_REG_FOD_MODE_EN, &regval);
+        if (regval == fod_val)
+            break;
+        fts_write_reg(FTS_REG_FOD_MODE_EN, fod_val);
+        fts_msleep(1);
+    }
+
+    if (i >= FTS_MAX_RETRIES_WRITEREG)
+        FTS_ERROR("set fod mode to %x failed,reg_val:%x", fod_val, regval);
+    else if (i > 0)
+        FTS_INFO("set fod mode to %x successfully", fod_val);
+}
+
+void fts_fod_enable(int enable)
+{
+    struct fts_ts_data *ts_data = fts_data;
+
+    ts_data->fod_fp_down = false;
+    if (enable) {
+        FTS_INFO("Fod enable");
+        ts_data->fod_mode = ENABLE;
+        fts_fod_set_reg(FTS_VAL_FOD_ENABLE);
+    } else {
+        FTS_INFO("Fod disable");
+        ts_data->fod_mode = DISABLE;
+        fts_fod_set_reg(DISABLE);
+    }
+}
+
+/*****************************************************************************
+* Name: fts_fod_readdata
+* Brief: read fod value from TP, check whether having FOD event or not,
+*        and report the state to host if need.
+*
+* Input: ts_data
+* Output:
+* Return: return negative code if error occurs,return 0 or 1 if success.
+*         return 0 if continue report finger touches.
+*         return 1(FTS_RETVAL_IGNORE_TOUCHES) if you want to ingore this
+*         finger reporting, As default, the following situation will report 1:
+*               a.System in suspend state, now not handle gesture.
+*****************************************************************************/
+static int fts_fod_readdata(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    int fod_x = 0;
+    int fod_y = 0;
+    int fod_pointid = 0;
+    int fod_down = 0;
+    u8 fod_val[FTS_FOD_BUF_LEN] = { 0 };
+    u8 fod_cmd = FTS_REG_FOD_DATA;
+
+    ret = fts_read(&fod_cmd, 1, fod_val, FTS_FOD_BUF_LEN);
+    if (ret < 0) {
+        FTS_ERROR("read fod data failed,ret=%d", ret);
+        return ret;
+    }
+
+    if (fod_val[1] == 0x26) {
+        fod_pointid = fod_val[0];
+        fod_x = (fod_val[4] << 8) + fod_val[5];
+        fod_y = (fod_val[6] << 8) + fod_val[7];
+        fod_down = (fod_val[8] == 0) ? 1 : 0;
+        FTS_DEBUG("FOD data:%x %x %x %x[%x,%x][%x]", fod_val[0], fod_val[1],
+                  fod_val[2], fod_val[3], fod_x, fod_x, fod_val[8]);
+        if (fod_down) {
+            /* FOD down, need do something to tell host */
+            ts_data->fod_fp_down = true;
+        } else {
+            /* FOD up, need do something to tell host */
+            ts_data->fod_fp_down = false;
+        }
+
+        ret = (ts_data->suspended) ? FTS_RETVAL_IGNORE_TOUCHES : 0;
+    } else {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static int fts_fod_recovery(struct fts_ts_data *ts_data)
+{
+    if (ts_data->fod_mode) {
+        fts_fod_set_reg(FTS_VAL_FOD_ENABLE);
+    }
+    return 0;
+}
+
+/*****************************************************************************
+* Name: fts_fod_checkdown
+* Brief: check fod down event is triggered, it's used to reset TP or not when
+*        resuming.
+*
+* Input: ts_data
+* Output:
+* Return: return 1 if having fod down event, or else return 0
+*****************************************************************************/
+static int fts_fod_checkdown(struct fts_ts_data *ts_data)
+{
+    return (ts_data->fod_mode && ts_data->fod_fp_down);
+}
+
+static int fts_fod_suspend(struct fts_ts_data *ts_data)
+{
+    ts_data->fod_fp_down = false;
+    fts_fod_set_reg(FTS_VAL_FOD_ENABLE);
+    return 0;
+}
+
+static int fts_fod_resume(struct fts_ts_data *ts_data)
+{
+    if (!fts_fod_checkdown(ts_data)) fts_fod_set_reg(FTS_VAL_FOD_ENABLE);
+    ts_data->fod_fp_down = false;
+    return 0;
+}
+#endif
+
+/*****************************************************************************
+*  Reprot related
+*****************************************************************************/
+static void fts_show_touch_buffer(u8 *data, u32 datalen)
+{
+    u32 i = 0;
+    u32 count = 0;
+    char *tmpbuf = NULL;
+
+    tmpbuf = kzalloc(1024, GFP_KERNEL);
+    if (!tmpbuf) {
+        FTS_ERROR("tmpbuf zalloc fail");
+        return;
+    }
+
+    for (i = 0; i < datalen; i++) {
+        count += snprintf(tmpbuf + count, 1024 - count, "%02X,", data[i]);
+        if (count >= 1024)
+            break;
+    }
+    FTS_DEBUG("touch_buf:%s", tmpbuf);
+
+    if (tmpbuf) {
+        kfree(tmpbuf);
+        tmpbuf = NULL;
+    }
+}
+
+void fts_release_all_finger(void)
+{
+    struct fts_ts_data *ts_data = fts_data;
+    struct input_dev *input_dev = ts_data->input_dev;
+#if FTS_MT_PROTOCOL_B_EN
+    u32 finger_count = 0;
+    u32 max_touches = ts_data->pdata->max_touch_number;
+#endif
+
+    mutex_lock(&ts_data->report_mutex);
+#if FTS_MT_PROTOCOL_B_EN
+    for (finger_count = 0; finger_count < max_touches; finger_count++) {
+        input_mt_slot(input_dev, finger_count);
+        input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+    }
+#else
+    input_mt_sync(input_dev);
+#endif
+    input_report_key(input_dev, BTN_TOUCH, 0);
+    input_sync(input_dev);
+
+#if FTS_PEN_EN
+    input_report_key(ts_data->pen_dev, BTN_TOOL_PEN, 0);
+    input_report_key(ts_data->pen_dev, BTN_TOUCH, 0);
+    input_sync(ts_data->pen_dev);
+#endif
+
+    ts_data->touch_points = 0;
+    ts_data->key_state = 0;
+    mutex_unlock(&ts_data->report_mutex);
+}
+
+/*****************************************************************************
+* Name: fts_input_report_key
+* Brief: process key events,need report key-event if key enable.
+*        if point's coordinate is in (x_dim-50,y_dim-50) ~ (x_dim+50,y_dim+50),
+*        need report it to key event.
+*        x_dim: parse from dts, means key x_coordinate, dimension:+-50
+*        y_dim: parse from dts, means key y_coordinate, dimension:+-50
+* Input:
+* Output:
+* Return: return 0 if it's key event, otherwise return error code
+*****************************************************************************/
+static int fts_input_report_key(struct fts_ts_data *ts_data, struct ts_event *kevent)
+{
+    int i = 0;
+    int x = kevent->x;
+    int y = kevent->y;
+    int *x_dim = &ts_data->pdata->key_x_coords[0];
+    int *y_dim = &ts_data->pdata->key_y_coords[0];
+
+    if (!ts_data->pdata->have_key) {
+        return -EINVAL;
+    }
+    for (i = 0; i < ts_data->pdata->key_number; i++) {
+        if ((x >= x_dim[i] - FTS_KEY_DIM) && (x <= x_dim[i] + FTS_KEY_DIM) &&
+            (y >= y_dim[i] - FTS_KEY_DIM) && (y <= y_dim[i] + FTS_KEY_DIM)) {
+            if (EVENT_DOWN(kevent->flag)
+                && !(ts_data->key_state & (1 << i))) {
+                input_report_key(ts_data->input_dev, ts_data->pdata->keys[i], 1);
+                ts_data->key_state |= (1 << i);
+                FTS_DEBUG("Key%d(%d,%d) DOWN!", i, x, y);
+            } else if (EVENT_UP(kevent->flag)
+                       && (ts_data->key_state & (1 << i))) {
+                input_report_key(ts_data->input_dev, ts_data->pdata->keys[i], 0);
+                ts_data->key_state &= ~(1 << i);
+                FTS_DEBUG("Key%d(%d,%d) Up!", i, x, y);
+            }
+            return 0;
+        }
+    }
+    return -EINVAL;
+}
+
+#if FTS_MT_PROTOCOL_B_EN
+static int fts_input_report_b(struct fts_ts_data *ts_data, struct ts_event *events)
+{
+    int i = 0;
+    int touch_down_point_cur = 0;
+    int touch_point_pre = ts_data->touch_points;
+    u32 max_touch_num = ts_data->pdata->max_touch_number;
+    bool touch_event_coordinate = false;
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    for (i = 0; i < ts_data->touch_event_num; i++) {
+        if (fts_input_report_key(ts_data, &events[i]) == 0) {
+            continue;
+        }
+
+        touch_event_coordinate = true;
+        if (EVENT_DOWN(events[i].flag)) {
+            input_mt_slot(input_dev, events[i].id);
+            input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+#if FTS_REPORT_PRESSURE_EN
+            input_report_abs(input_dev, ABS_MT_PRESSURE, events[i].p);
+#endif
+            input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, events[i].area);
+            input_report_abs(input_dev, ABS_MT_TOUCH_MINOR, events[i].minor);
+
+            input_report_abs(input_dev, ABS_MT_POSITION_X, events[i].x);
+            input_report_abs(input_dev, ABS_MT_POSITION_Y, events[i].y);
+
+            touch_down_point_cur |= (1 << events[i].id);
+            touch_point_pre |= (1 << events[i].id);
+
+            if ((ts_data->log_level >= 2) ||
+                ((1 == ts_data->log_level) && (FTS_TOUCH_DOWN == events[i].flag))) {
+                FTS_DEBUG("[B]P%d(%d, %d)[p:%d,tm:%d] DOWN!",
+                          events[i].id, events[i].x, events[i].y,
+                          events[i].p, events[i].area);
+            }
+        } else {
+            input_mt_slot(input_dev, events[i].id);
+            input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+            touch_point_pre &= ~(1 << events[i].id);
+            if (ts_data->log_level >= 1) FTS_DEBUG("[B]P%d UP!", events[i].id);
+        }
+    }
+
+    if (unlikely(touch_point_pre ^ touch_down_point_cur)) {
+        for (i = 0; i < max_touch_num; i++)  {
+            if ((1 << i) & (touch_point_pre ^ touch_down_point_cur)) {
+                if (ts_data->log_level >= 1) FTS_DEBUG("[B]P%d UP!", i);
+                input_mt_slot(input_dev, i);
+                input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+            }
+        }
+    }
+
+    if (touch_down_point_cur)
+        input_report_key(input_dev, BTN_TOUCH, 1);
+    else if (touch_event_coordinate || ts_data->touch_points) {
+        if (ts_data->touch_points && (ts_data->log_level >= 1))
+            FTS_DEBUG("[B]Points All Up!");
+        input_report_key(input_dev, BTN_TOUCH, 0);
+    }
+
+    ts_data->touch_points = touch_down_point_cur;
+    input_sync(input_dev);
+    return 0;
+}
+#else
+static int fts_input_report_a(struct fts_ts_data *ts_data, struct ts_event *events)
+{
+    int i = 0;
+    int touch_down_point_num_cur = 0;
+    bool touch_event_coordinate = false;
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    for (i = 0; i < ts_data->touch_event_num; i++) {
+        if (fts_input_report_key(ts_data, &events[i]) == 0) {
+            continue;
+        }
+
+        touch_event_coordinate = true;
+        if (EVENT_DOWN(events[i].flag)) {
+            input_report_abs(input_dev, ABS_MT_TRACKING_ID, events[i].id);
+#if FTS_REPORT_PRESSURE_EN
+            input_report_abs(input_dev, ABS_MT_PRESSURE, events[i].p);
+#endif
+            input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, events[i].area);
+            input_report_abs(input_dev, ABS_MT_TOUCH_MINOR, events[i].minor);
+
+            input_report_abs(input_dev, ABS_MT_POSITION_X, events[i].x);
+            input_report_abs(input_dev, ABS_MT_POSITION_Y, events[i].y);
+            input_mt_sync(input_dev);
+
+            touch_down_point_num_cur++;
+            if ((ts_data->log_level >= 2) ||
+                ((1 == ts_data->log_level) && (FTS_TOUCH_DOWN == events[i].flag))) {
+                FTS_DEBUG("[A]P%d(%d, %d)[p:%d,tm:%d] DOWN!",
+                          events[i].id, events[i].x, events[i].y,
+                          events[i].p, events[i].area);
+            }
+        }
+    }
+
+    if (touch_down_point_num_cur)
+        input_report_key(input_dev, BTN_TOUCH, 1);
+    else if (touch_event_coordinate || ts_data->touch_points) {
+        if (ts_data->touch_points && (ts_data->log_level >= 1))
+            FTS_DEBUG("[A]Points All Up!");
+        input_report_key(input_dev, BTN_TOUCH, 0);
+        input_mt_sync(input_dev);
+    }
+
+    ts_data->touch_points = touch_down_point_num_cur;
+    input_sync(input_dev);
+    return 0;
+}
+#endif
+
+#if FTS_PEN_EN
+static int fts_input_pen_report(struct fts_ts_data *ts_data, u8 *pen_buf)
+{
+    struct input_dev *pen_dev = ts_data->pen_dev;
+    struct pen_event *pevt = &ts_data->pevent;
+
+    /*get information of stylus*/
+    pevt->inrange = (pen_buf[2] & 0x20) ? 1 : 0;
+    pevt->tip = (pen_buf[2] & 0x01) ? 1 : 0;
+    pevt->flag = pen_buf[3] >> 6;
+#if FTS_PEN_HIRES_EN
+    pevt->id = 0;
+    pevt->x = ((u32)((pen_buf[3] & 0x0F) << 12) + (pen_buf[4] << 4) + ((pen_buf[5] >> 4) & 0x0F));
+    pevt->y = ((u32)((pen_buf[5] & 0x0F) << 12) + (pen_buf[6] << 4) + ((pen_buf[7] >> 4) & 0x0F));
+    pevt->x = (pevt->x * FTS_PEN_HIRES_X ) / FTS_HI_RES_X_MAX;
+    pevt->y = (pevt->y * FTS_PEN_HIRES_X ) / FTS_HI_RES_X_MAX;
+#else
+    pevt->id = pen_buf[5] >> 4;
+    pevt->x = ((pen_buf[3] & 0x0F) << 8) + pen_buf[4];
+    pevt->y = ((pen_buf[5] & 0x0F) << 8) + pen_buf[6];
+#endif
+    pevt->p = ((pen_buf[7] & 0x0F) << 8) + pen_buf[8];
+    pevt->tilt_x = (short)((pen_buf[9] << 8) + pen_buf[10]);
+    pevt->tilt_y = (short)((pen_buf[11] << 8) + pen_buf[12]);
+    pevt->azimuth = ((pen_buf[13] << 8) + pen_buf[14]);
+    pevt->tool_type = BTN_TOOL_PEN;
+
+    input_report_key(pen_dev, BTN_STYLUS, !!(pen_buf[2] & 0x02));
+    input_report_key(pen_dev, BTN_STYLUS2, !!(pen_buf[2] & 0x08));
+
+    switch (ts_data->pen_etype) {
+    case STYLUS_DEFAULT:
+        if (pevt->tip && pevt->p) {
+            if ((ts_data->log_level >= 2) || (!pevt->down))
+                FTS_DEBUG("[PEN]x:%d,y:%d,p:%d,tip:%d,flag:%d,tilt:%d,%d DOWN",
+                          pevt->x, pevt->y, pevt->p, pevt->tip, pevt->flag,
+                          pevt->tilt_x, pevt->tilt_y);
+            input_report_abs(pen_dev, ABS_X, pevt->x);
+            input_report_abs(pen_dev, ABS_Y, pevt->y);
+            input_report_abs(pen_dev, ABS_PRESSURE, pevt->p);
+            input_report_abs(pen_dev, ABS_TILT_X, pevt->tilt_x);
+            input_report_abs(pen_dev, ABS_TILT_Y, pevt->tilt_y);
+            input_report_key(pen_dev, BTN_TOUCH, 1);
+            input_report_key(pen_dev, BTN_TOOL_PEN, 1);
+            pevt->down = 1;
+        } else if (!pevt->tip && pevt->down) {
+            FTS_DEBUG("[PEN]x:%d,y:%d,p:%d,tip:%d,flag:%d,tilt:%d,%d UP",
+                      pevt->x, pevt->y, pevt->p, pevt->tip, pevt->flag,
+                      pevt->tilt_x, pevt->tilt_y);
+            input_report_abs(pen_dev, ABS_X, pevt->x);
+            input_report_abs(pen_dev, ABS_Y, pevt->y);
+            input_report_abs(pen_dev, ABS_PRESSURE, pevt->p);
+            input_report_key(pen_dev, BTN_TOUCH, 0);
+            input_report_key(pen_dev, BTN_TOOL_PEN, 0);
+            pevt->down = 0;
+        }
+        input_sync(pen_dev);
+        break;
+    case STYLUS_HOVER:
+        if (ts_data->log_level >= 1)
+            FTS_DEBUG("[PEN][%02X]x:%d,y:%d,p:%d,tip:%d,flag:%d,tilt:%d,%d,%d",
+                      pen_buf[2], pevt->x, pevt->y, pevt->p, pevt->tip,
+                      pevt->flag, pevt->tilt_x, pevt->tilt_y, pevt->azimuth);
+        input_report_abs(pen_dev, ABS_X, pevt->x);
+        input_report_abs(pen_dev, ABS_Y, pevt->y);
+        input_report_abs(pen_dev, ABS_Z, pevt->azimuth);
+        input_report_abs(pen_dev, ABS_PRESSURE, pevt->p);
+        input_report_abs(pen_dev, ABS_TILT_X, pevt->tilt_x);
+        input_report_abs(pen_dev, ABS_TILT_Y, pevt->tilt_y);
+        input_report_key(pen_dev, BTN_TOOL_PEN, EVENT_DOWN(pevt->flag));
+        input_report_key(pen_dev, BTN_TOUCH, pevt->tip);
+        input_sync(pen_dev);
+        break;
+    default:
+        FTS_ERROR("Unknown stylus event");
+        break;
+    }
+
+    return 0;
+}
+#endif
+
+static int fts_input_report_touch(struct fts_ts_data *ts_data, u8 *touch_buf)
+{
+    int i = 0;
+    int event_num = 0;
+    int finger_num = 0;
+    int pointid = 0;
+    int base = 0;
+    int max_touch_num = ts_data->pdata->max_touch_number;
+    struct ts_event *events = ts_data->events;
+
+    finger_num = touch_buf[FTS_TOUCH_E_NUM] & 0x0F;
+    if (finger_num > max_touch_num) {
+        FTS_ERROR("invalid point_num(%d)", finger_num);
+        return -EIO;
+    }
+
+    for (i = 0; i < max_touch_num; i++) {
+        base = FTS_ONE_TCH_LEN * i + 2;
+        pointid = (touch_buf[FTS_TOUCH_OFF_ID_YH + base]) >> 4;
+        if (pointid >= FTS_MAX_ID)
+            break;
+        else if (pointid >= max_touch_num) {
+            FTS_ERROR("ID(%d) beyond max_touch_number", pointid);
+            return -EINVAL;
+        }
+
+        events[i].id = pointid;
+        events[i].flag = touch_buf[FTS_TOUCH_OFF_E_XH + base] >> 6;
+#if FTS_TOUCH_HIRES_EN
+        events[i].x = ((touch_buf[FTS_TOUCH_OFF_E_XH + base] & 0x0F) << 12) \
+                      + ((touch_buf[FTS_TOUCH_OFF_XL + base] & 0xFF) << 4) \
+                      + ((touch_buf[FTS_TOUCH_OFF_PRE + base] >> 4) & 0x0F);
+        events[i].y = ((touch_buf[FTS_TOUCH_OFF_ID_YH + base] & 0x0F) << 12) \
+                      + ((touch_buf[FTS_TOUCH_OFF_YL + base] & 0xFF) << 4) \
+                      + (touch_buf[FTS_TOUCH_OFF_PRE + base] & 0x0F);
+        events[i].x = (events[i].x * FTS_TOUCH_HIRES_X ) / FTS_HI_RES_X_MAX;
+        events[i].y = (events[i].y * FTS_TOUCH_HIRES_X ) / FTS_HI_RES_X_MAX;
+        events[i].p = 0x3F;
+#if FTS_REPORT_PRESSURE_EN
+        FTS_ERROR("high solution project doesn't support pressure property");
+#endif
+#else
+        events[i].x = ((touch_buf[FTS_TOUCH_OFF_E_XH + base] & 0x0F) << 8) \
+                      + (touch_buf[FTS_TOUCH_OFF_XL + base] & 0xFF);
+        events[i].y = ((touch_buf[FTS_TOUCH_OFF_ID_YH + base] & 0x0F) << 8) \
+                      + (touch_buf[FTS_TOUCH_OFF_YL + base] & 0xFF);
+        events[i].p =  touch_buf[FTS_TOUCH_OFF_PRE + base];
+        if (events[i].p <= 0) events[i].p = 0x3F;
+#endif
+        events[i].area = touch_buf[FTS_TOUCH_OFF_AREA + base];
+        if (events[i].area <= 0) events[i].area = 0x09;
+        events[i].minor = events[i].area;
+
+        event_num++;
+        if (EVENT_DOWN(events[i].flag) && (finger_num == 0)) {
+            FTS_INFO("abnormal touch data from fw");
+            return -EIO;
+        }
+    }
+
+    if (event_num == 0) {
+        FTS_INFO("no touch point information(%02x)", touch_buf[2]);
+        return -EIO;
+    }
+    ts_data->touch_event_num = event_num;
+
+    mutex_lock(&ts_data->report_mutex);
+#if FTS_MT_PROTOCOL_B_EN
+    fts_input_report_b(ts_data, events);
+#else
+    fts_input_report_a(ts_data, events);
+#endif
+    mutex_unlock(&ts_data->report_mutex);
+    return 0;
+}
+
+static int fts_input_report_touch_pv2(struct fts_ts_data *ts_data, u8 *touch_buf)
+{
+    int i = 0;
+    int event_num = 0;
+    int pointid = 0;
+    int base = 0;
+    int max_touch_num = ts_data->pdata->max_touch_number;
+    struct ts_event *events = ts_data->events;
+
+    event_num = touch_buf[FTS_TOUCH_E_NUM] & 0x0F;
+    if (!event_num || (event_num > max_touch_num)) {
+        FTS_ERROR("invalid touch event num(%d)", event_num);
+        return -EIO;
+    }
+
+    ts_data->touch_event_num = event_num;
+    for (i = 0; i < event_num; i++) {
+        base = FTS_ONE_TCH_LEN_V2 * i + 4;
+        pointid = (touch_buf[FTS_TOUCH_OFF_ID_YH + base]) >> 4;
+        if (pointid >= max_touch_num) {
+            FTS_ERROR("touch point ID(%d) beyond max_touch_number(%d)",
+                      pointid, max_touch_num);
+            return -EINVAL;
+        }
+
+        events[i].id = pointid;
+        events[i].flag = touch_buf[FTS_TOUCH_OFF_E_XH + base] >> 6;
+
+        events[i].x = ((touch_buf[FTS_TOUCH_OFF_E_XH + base] & 0x0F) << 12) \
+                      + ((touch_buf[FTS_TOUCH_OFF_XL + base] & 0xFF) << 4) \
+                      + ((touch_buf[FTS_TOUCH_OFF_PRE + base] >> 4) & 0x0F);
+
+        events[i].y = ((touch_buf[FTS_TOUCH_OFF_ID_YH + base] & 0x0F) << 12) \
+                      + ((touch_buf[FTS_TOUCH_OFF_YL + base] & 0xFF) << 4) \
+                      + (touch_buf[FTS_TOUCH_OFF_PRE + base] & 0x0F);
+#if FTS_TOUCH_HIRES_EN
+        events[i].x = (events[i].x * FTS_TOUCH_HIRES_X ) / FTS_HI_RES_X_MAX;
+        events[i].y = (events[i].y * FTS_TOUCH_HIRES_X ) / FTS_HI_RES_X_MAX;
+#else
+        events[i].x = events[i].x  / FTS_HI_RES_X_MAX;
+        events[i].y = events[i].y  / FTS_HI_RES_X_MAX;
+#endif
+        events[i].area = touch_buf[FTS_TOUCH_OFF_AREA + base];
+        events[i].minor = touch_buf[FTS_TOUCH_OFF_MINOR + base];
+        events[i].p = 0x3F;
+#if FTS_REPORT_PRESSURE_EN
+        FTS_ERROR("The pressure property isn't supported");
+#endif
+        if (events[i].area <= 0) events[i].area = 0x09;
+        if (events[i].minor <= 0) events[i].minor = 0x09;
+    }
+
+    mutex_lock(&ts_data->report_mutex);
+#if FTS_MT_PROTOCOL_B_EN
+    fts_input_report_b(ts_data, events);
+#else
+    fts_input_report_a(ts_data, events);
+#endif
+    mutex_unlock(&ts_data->report_mutex);
+    return 0;
+}
+
+int fts_input_report_buffer(struct fts_ts_data *ts_data, u8 *report_buf)
+{
+    int ret = 0;
+    int touch_etype = 0;
+
+    if (!ts_data || !report_buf) {
+        FTS_ERROR("ts_data/report_buf is null");
+        return -EINVAL;
+    }
+
+    touch_etype = ((report_buf[FTS_TOUCH_E_NUM] >> 4) & 0x0F);
+    switch (touch_etype) {
+    case TOUCH_DEFAULT:
+        ret = fts_input_report_touch(ts_data, report_buf);
+        break;
+
+    case TOUCH_PROTOCOL_v2:
+        ret = fts_input_report_touch_pv2(ts_data, report_buf);
+        break;
+
+#if FTS_PEN_EN
+    case TOUCH_PEN:
+        mutex_lock(&ts_data->report_mutex);
+        ret = fts_input_pen_report(ts_data, report_buf);
+        mutex_unlock(&ts_data->report_mutex);
+        break;
+#endif
+
+    default:
+        FTS_INFO("unknown touch event(%d)", touch_etype);
+        break;
+    }
+
+    return ret;
+}
+
+static int fts_read_touchdata_spi(struct fts_ts_data *ts_data, u8 *buf)
+{
+    int ret = 0;
+
+    ts_data->touch_addr = 0x01;
+    ret = fts_read(&ts_data->touch_addr, 1, buf, ts_data->touch_size);
+
+
+    if (ret < 0) {
+        FTS_ERROR("touch data(%x) abnormal,ret:%d", buf[1], ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_read_touchdata_i2c(struct fts_ts_data *ts_data, u8 *buf)
+{
+    int ret = 0;
+    u32 touch_max_size = 0;
+    u32 max_touch_num = ts_data->pdata->max_touch_number;
+    u8 event = 0xFF;
+
+    ts_data->touch_addr = 0x01;
+    ret = fts_read(&ts_data->touch_addr, 1, buf, ts_data->touch_size);
+    if (ret < 0) {
+        FTS_ERROR("read touchdata fails,ret:%d", ret);
+        return ret;
+    }
+
+    event = (buf[FTS_TOUCH_E_NUM] >> 4) & 0x0F;
+    if (event == TOUCH_DEFAULT) {
+        if (buf[ts_data->touch_size - 1] != 0xFF)
+            touch_max_size = max_touch_num * FTS_ONE_TCH_LEN + 2;
+    } else if (event == TOUCH_PROTOCOL_v2) {
+        touch_max_size = (buf[FTS_TOUCH_E_NUM] & 0x0F) * FTS_ONE_TCH_LEN_V2 + 4;
+    }
+#if FTS_PEN_EN
+    else if (event == TOUCH_PEN) {
+        touch_max_size = FTS_SIZE_PEN;
+        if (touch_max_size > ts_data->touch_size) {
+            FTS_INFO("read next touch message of pen,size:%d-%d",
+                     touch_max_size, ts_data->touch_size);
+        }
+    }
+#endif
+
+    if (touch_max_size > ts_data->touch_size) {
+        ts_data->ta_size = touch_max_size;
+        ts_data->touch_addr += ts_data->touch_size;
+        ret = fts_read(&ts_data->touch_addr, 1, buf + ts_data->touch_size, \
+                       touch_max_size - ts_data->touch_size);
+        if (ret < 0) {
+            FTS_ERROR("read touchdata2 fails,ret:%d", ret);
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static int fts_read_parse_touchdata(struct fts_ts_data *ts_data, u8 *touch_buf)
+{
+    int ret = 0;
+
+    memset(touch_buf, 0xFF, FTS_MAX_TOUCH_BUF);
+    ts_data->ta_size = ts_data->touch_size;
+
+    /*read touch data*/
+    if (ts_data->bus_type == BUS_TYPE_SPI)
+        ret = fts_read_touchdata_spi(ts_data, touch_buf);
+    else if (ts_data->bus_type == BUS_TYPE_I2C)
+        ret = fts_read_touchdata_i2c(ts_data, touch_buf);
+    else FTS_ERROR("unknown bus type:%d", ts_data->bus_type);
+    if (ret < 0) {
+        FTS_ERROR("unknown BUS type");
+        return TOUCH_ERROR;
+    }
+
+    if (ts_data->log_level >= 3)
+        fts_show_touch_buffer(touch_buf, ts_data->ta_size);
+
+    if (ret)
+        return TOUCH_IGNORE;
+
+    if ((touch_buf[1] == 0xFF) && (touch_buf[2] == 0xFF)
+        && (touch_buf[3] == 0xFF) && (touch_buf[4] == 0xFF)) {
+        FTS_INFO("touch buff is 0xff, FW initialized");
+        return TOUCH_FW_INIT;
+    }
+
+#if FTS_PSENSOR_EN
+    if (ts_data->proximity_mode) {
+        if (fts_proximity_readdata(ts_data) == FTS_RETVAL_IGNORE_TOUCHES)
+            return TOUCH_IGNORE;
+    }
+#endif
+
+#if FTS_FOD_EN
+    if (ts_data->fod_mode) {
+        if (fts_fod_readdata(ts_data) == FTS_RETVAL_IGNORE_TOUCHES)
+            return TOUCH_IGNORE;
+    }
+#endif
+
+    if (ts_data->suspended && ts_data->gesture_support) {
+        if (fts_gesture_readdata(ts_data, touch_buf) == FTS_RETVAL_IGNORE_TOUCHES)
+            return TOUCH_IGNORE;
+    }
+
+    if (ts_data->suspended) {
+        FTS_INFO("In suspend state, not report touch points");
+        return TOUCH_IGNORE;
+    }
+
+    return ((touch_buf[FTS_TOUCH_E_NUM] >> 4) & 0x0F);
+}
+
+static int fts_irq_read_report(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    int touch_etype = 0;
+    u8 *touch_buf = ts_data->touch_buf;
+
+    touch_etype = fts_read_parse_touchdata(ts_data, touch_buf);
+    switch (touch_etype) {
+    case TOUCH_DEFAULT:
+        ret = fts_input_report_touch(ts_data, touch_buf);
+        break;
+
+    case TOUCH_PROTOCOL_v2:
+        ret = fts_input_report_touch_pv2(ts_data, touch_buf);
+        break;
+
+#if FTS_PEN_EN
+    case TOUCH_PEN:
+        mutex_lock(&ts_data->report_mutex);
+        ret = fts_input_pen_report(ts_data, touch_buf);
+        mutex_unlock(&ts_data->report_mutex);
+        break;
+#endif
+
+    case TOUCH_FW_INIT:
+        fts_release_all_finger();
+        fts_tp_state_recovery(ts_data);
+        break;
+
+    case TOUCH_IGNORE:
+    case TOUCH_ERROR:
+    case TOUCH_FWDBG:
+        break;
+
+    default:
+        FTS_INFO("unknown touch event(%d)", touch_etype);
+        break;
+    }
+
+    return ret;
+}
+
+static irqreturn_t fts_irq_handler(int irq, void *data)
+{
+    struct fts_ts_data *ts_data = fts_data;
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+    int ret = 0;
+
+    if ((ts_data->suspended) && (ts_data->pm_suspend)) {
+        ret = wait_for_completion_timeout(
+                  &ts_data->pm_completion,
+                  msecs_to_jiffies(FTS_TIMEOUT_COMERR_PM));
+        if (!ret) {
+            FTS_ERROR("Bus don't resume from pm(deep),timeout,skip irq");
+            return IRQ_HANDLED;
+        }
+    }
+#endif
+
+    if (ts_data->suspended)
+        __pm_wakeup_event(ts_data->p_ws, jiffies_to_msecs(FTS_WAKELOCK_TIMEOUT));
+
+
+    ts_data->intr_jiffies = jiffies;
+    fts_prc_queue_work(ts_data);
+    fts_irq_read_report(ts_data);
+    if (ts_data->touch_analysis_support && ts_data->ta_flag) {
+        ts_data->ta_flag = 0;
+        if (ts_data->ta_buf && ts_data->ta_size)
+            memcpy(ts_data->ta_buf, ts_data->touch_buf, ts_data->ta_size);
+        wake_up_interruptible(&ts_data->ts_waitqueue);
+    }
+
+    return IRQ_HANDLED;
+}
+
+static int fts_irq_registration(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fts_ts_platform_data *pdata = ts_data->pdata;
+
+    ts_data->irq = gpio_to_irq(pdata->irq_gpio);
+    pdata->irq_gpio_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+    FTS_INFO("irq:%d, flag:%x", ts_data->irq, pdata->irq_gpio_flags);
+    ret = request_threaded_irq(ts_data->irq, NULL, fts_irq_handler,
+                               pdata->irq_gpio_flags,
+                               FTS_DRIVER_NAME, ts_data);
+
+    return ret;
+}
+
+#if FTS_PEN_EN
+static int fts_input_pen_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct input_dev *pen_dev;
+    struct fts_ts_platform_data *pdata = ts_data->pdata;
+    u32 pen_x_max = pdata->x_max;
+    u32 pen_y_max = pdata->y_max;
+
+    FTS_FUNC_ENTER();
+    pen_dev = input_allocate_device();
+    if (!pen_dev) {
+        FTS_ERROR("Failed to allocate memory for input_pen device");
+        return -ENOMEM;
+    }
+
+#if FTS_PEN_HIRES_EN
+    pen_x_max = (pdata->x_max + 1) * FTS_PEN_HIRES_X - 1;
+    pen_y_max = (pdata->y_max + 1) * FTS_PEN_HIRES_X - 1;
+#endif
+    pen_dev->dev.parent = ts_data->dev;
+    pen_dev->name = FTS_DRIVER_PEN_NAME;
+    pen_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+    __set_bit(ABS_X, pen_dev->absbit);
+    __set_bit(ABS_Y, pen_dev->absbit);
+    __set_bit(BTN_STYLUS, pen_dev->keybit);
+    __set_bit(BTN_STYLUS2, pen_dev->keybit);
+    __set_bit(BTN_TOUCH, pen_dev->keybit);
+    __set_bit(BTN_TOOL_PEN, pen_dev->keybit);
+    __set_bit(INPUT_PROP_DIRECT, pen_dev->propbit);
+    input_set_abs_params(pen_dev, ABS_X, pdata->x_min, pen_x_max, 0, 0);
+    input_set_abs_params(pen_dev, ABS_Y, pdata->y_min, pen_y_max, 0, 0);
+    input_set_abs_params(pen_dev, ABS_PRESSURE, 0, 4096, 0, 0);
+    input_set_abs_params(pen_dev, ABS_TILT_X, -9000, 9000, 0, 0);
+    input_set_abs_params(pen_dev, ABS_TILT_Y, -9000, 9000, 0, 0);
+    input_set_abs_params(pen_dev, ABS_Z, 0, 36000, 0, 0);
+
+    ret = input_register_device(pen_dev);
+    if (ret) {
+        FTS_ERROR("Input device registration failed");
+        input_free_device(pen_dev);
+        pen_dev = NULL;
+        return ret;
+    }
+
+    ts_data->pen_dev = pen_dev;
+    ts_data->pen_etype = STYLUS_DEFAULT;
+    FTS_FUNC_EXIT();
+    return 0;
+}
+#endif
+
+static int fts_input_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    int key_num = 0;
+    struct fts_ts_platform_data *pdata = ts_data->pdata;
+    struct input_dev *input_dev;
+    u32 touch_x_max = pdata->x_max;
+    u32 touch_y_max = pdata->y_max;
+
+    FTS_FUNC_ENTER();
+    input_dev = input_allocate_device();
+    if (!input_dev) {
+        FTS_ERROR("Failed to allocate memory for input device");
+        return -ENOMEM;
+    }
+
+    /* Init and register Input device */
+    input_dev->name = FTS_DRIVER_NAME;
+    if (ts_data->bus_type == BUS_TYPE_I2C)
+        input_dev->id.bustype = BUS_I2C;
+    else
+        input_dev->id.bustype = BUS_SPI;
+    input_dev->dev.parent = ts_data->dev;
+
+    input_set_drvdata(input_dev, ts_data);
+
+    __set_bit(EV_SYN, input_dev->evbit);
+    __set_bit(EV_ABS, input_dev->evbit);
+    __set_bit(EV_KEY, input_dev->evbit);
+    __set_bit(BTN_TOUCH, input_dev->keybit);
+    __set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+
+    if (pdata->have_key) {
+        FTS_INFO("set key capabilities");
+        for (key_num = 0; key_num < pdata->key_number; key_num++)
+            input_set_capability(input_dev, EV_KEY, pdata->keys[key_num]);
+    }
+
+#if FTS_TOUCH_HIRES_EN
+    touch_x_max = (pdata->x_max + 1) * FTS_TOUCH_HIRES_X - 1;
+    touch_y_max = (pdata->y_max + 1) * FTS_TOUCH_HIRES_X - 1;
+#endif
+
+#if FTS_MT_PROTOCOL_B_EN
+    input_mt_init_slots(input_dev, pdata->max_touch_number, INPUT_MT_DIRECT);
+#else
+    input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, 0x0F, 0, 0);
+#endif
+    input_set_abs_params(input_dev, ABS_MT_POSITION_X, pdata->x_min, touch_x_max, 0, 0);
+    input_set_abs_params(input_dev, ABS_MT_POSITION_Y, pdata->y_min, touch_y_max, 0, 0);
+    input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 0xFF, 0, 0);
+#if FTS_REPORT_PRESSURE_EN
+    input_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 0xFF, 0, 0);
+#endif
+
+    ret = input_register_device(input_dev);
+    if (ret) {
+        FTS_ERROR("Input device registration failed");
+        input_set_drvdata(input_dev, NULL);
+        input_free_device(input_dev);
+        input_dev = NULL;
+        return ret;
+    }
+
+#if FTS_PEN_EN
+    ret = fts_input_pen_init(ts_data);
+    if (ret) {
+        FTS_ERROR("Input-pen device registration failed");
+        input_set_drvdata(input_dev, NULL);
+        input_free_device(input_dev);
+        input_dev = NULL;
+        return ret;
+    }
+#endif
+
+    ts_data->input_dev = input_dev;
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_buffer_init(struct fts_ts_data *ts_data)
+{
+    ts_data->touch_buf = (u8 *)kzalloc(FTS_MAX_TOUCH_BUF, GFP_KERNEL);
+    if (!ts_data->touch_buf) {
+        FTS_ERROR("failed to alloc memory for touch buf");
+        return -ENOMEM;
+    }
+
+    if (ts_data->bus_type == BUS_TYPE_SPI)
+        ts_data->touch_size = FTS_TOUCH_DATA_LEN_V2;
+    else if (ts_data->bus_type == BUS_TYPE_I2C)
+        ts_data->touch_size = FTS_SIZE_DEFAULT_V2;
+    else FTS_ERROR("unknown bus type:%d", ts_data->bus_type);
+
+    ts_data->touch_analysis_support = 0;
+    ts_data->ta_flag = 0;
+    ts_data->ta_size = 0;
+
+    return 0;
+}
+
+#if FTS_PINCTRL_EN
+static int fts_pinctrl_init(struct fts_ts_data *ts)
+{
+    int ret = 0;
+
+    ts->pinctrl = devm_pinctrl_get(ts->dev);
+    if (IS_ERR_OR_NULL(ts->pinctrl)) {
+        FTS_ERROR("Failed to get pinctrl, please check dts");
+        ret = PTR_ERR(ts->pinctrl);
+        goto err_pinctrl_get;
+    }
+
+    ts->pins_active = pinctrl_lookup_state(ts->pinctrl, "pmx_ts_active");
+    if (IS_ERR_OR_NULL(ts->pins_active)) {
+        FTS_ERROR("Pin state[active] not found");
+        ret = PTR_ERR(ts->pins_active);
+        goto err_pinctrl_lookup;
+    }
+
+    ts->pins_suspend = pinctrl_lookup_state(ts->pinctrl, "pmx_ts_suspend");
+    if (IS_ERR_OR_NULL(ts->pins_suspend)) {
+        FTS_ERROR("Pin state[suspend] not found");
+        ret = PTR_ERR(ts->pins_suspend);
+        goto err_pinctrl_lookup;
+    }
+
+    ts->pins_release = pinctrl_lookup_state(ts->pinctrl, "pmx_ts_release");
+    if (IS_ERR_OR_NULL(ts->pins_release)) {
+        FTS_ERROR("Pin state[release] not found");
+        ret = PTR_ERR(ts->pins_release);
+    }
+
+    return 0;
+err_pinctrl_lookup:
+    if (ts->pinctrl) {
+        devm_pinctrl_put(ts->pinctrl);
+    }
+err_pinctrl_get:
+    ts->pinctrl = NULL;
+    ts->pins_release = NULL;
+    ts->pins_suspend = NULL;
+    ts->pins_active = NULL;
+    return ret;
+}
+#endif /* FTS_PINCTRL_EN */
+
+#if FTS_POWER_SOURCE_CUST_EN
+/*****************************************************************************
+* Power Control
+*****************************************************************************/
+static int fts_power_source_ctrl(struct fts_ts_data *ts_data, int enable)
+{
+    int ret = 0;
+
+    if (IS_ERR_OR_NULL(ts_data->vdd)) {
+        FTS_ERROR("vdd is invalid");
+        return -EINVAL;
+    }
+
+    FTS_FUNC_ENTER();
+    if (enable) {
+        if (ts_data->power_disabled) {
+            fts_set_reset(ts_data, 0);
+            fts_msleep(2);
+            FTS_INFO("set power to on");
+            ret = regulator_enable(ts_data->vdd);
+            if (ret) {
+                FTS_ERROR("enable vdd regulator failed,ret=%d", ret);
+            }
+
+            if (!IS_ERR_OR_NULL(ts_data->iovcc)) {
+                ret = regulator_enable(ts_data->iovcc);
+                if (ret) {
+                    FTS_ERROR("enable iovcc regulator failed,ret=%d", ret);
+                }
+            }
+            fts_msleep(2);
+            fts_set_reset(ts_data, 1);
+            ts_data->power_disabled = false;
+        }
+    } else {
+        if (!ts_data->power_disabled) {
+            fts_set_reset(ts_data, 0);
+            fts_msleep(2);
+            FTS_INFO("set power to off");
+            if (!IS_ERR_OR_NULL(ts_data->iovcc)) {
+                ret = regulator_disable(ts_data->iovcc);
+                if (ret) {
+                    FTS_ERROR("disable iovcc regulator failed,ret=%d", ret);
+                }
+            }
+            ret = regulator_disable(ts_data->vdd);
+            if (ret) {
+                FTS_ERROR("disable vdd regulator failed,ret=%d", ret);
+            }
+            ts_data->power_disabled = true;
+        }
+    }
+
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+/*****************************************************************************
+* Name: fts_power_source_init
+* Brief: Init regulator power:vdd/vcc_io(if have), generally, no vcc_io
+*        vdd---->vdd-supply in dts, kernel will auto add "-supply" to parse
+*        Must be call after fts_gpio_configure() execute,because this function
+*        will operate reset-gpio which request gpio in fts_gpio_configure()
+* Input:
+* Output:
+* Return: return 0 if init power successfully, otherwise return error code
+*****************************************************************************/
+static int fts_power_source_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    ts_data->vdd = regulator_get(ts_data->dev, "vdd");
+    if (IS_ERR_OR_NULL(ts_data->vdd)) {
+        ret = PTR_ERR(ts_data->vdd);
+        FTS_ERROR("get vdd regulator failed,ret=%d", ret);
+        return ret;
+    }
+
+    if (regulator_count_voltages(ts_data->vdd) > 0) {
+        ret = regulator_set_voltage(ts_data->vdd, FTS_VTG_MIN_UV,
+                                    FTS_VTG_MAX_UV);
+        if (ret) {
+            FTS_ERROR("vdd regulator set_vtg failed ret=%d", ret);
+            regulator_put(ts_data->vdd);
+            return ret;
+        }
+    }
+
+    ts_data->iovcc = regulator_get(ts_data->dev, "iovcc");
+    if (!IS_ERR_OR_NULL(ts_data->iovcc)) {
+        if (regulator_count_voltages(ts_data->iovcc) > 0) {
+            ret = regulator_set_voltage(ts_data->iovcc,
+                                        FTS_IOVCC_VTG_MIN_UV,
+                                        FTS_IOVCC_VTG_MAX_UV);
+            if (ret) {
+                FTS_ERROR("iovcc regulator set_vtg failed,ret=%d", ret);
+                regulator_put(ts_data->iovcc);
+            }
+        }
+    }
+
+    ret = fts_power_source_ctrl(ts_data, ENABLE);
+    if (ret) {
+        FTS_ERROR("fail to enable power(regulator)");
+    }
+
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static int fts_power_source_exit(struct fts_ts_data *ts_data)
+{
+    fts_power_source_ctrl(ts_data, DISABLE);
+
+    if (!IS_ERR_OR_NULL(ts_data->vdd)) {
+        if (regulator_count_voltages(ts_data->vdd) > 0)
+            regulator_set_voltage(ts_data->vdd, 0, FTS_VTG_MAX_UV);
+        regulator_put(ts_data->vdd);
+    }
+
+    if (!IS_ERR_OR_NULL(ts_data->iovcc)) {
+        if (regulator_count_voltages(ts_data->iovcc) > 0)
+            regulator_set_voltage(ts_data->iovcc, 0, FTS_IOVCC_VTG_MAX_UV);
+        regulator_put(ts_data->iovcc);
+    }
+
+    return 0;
+}
+#endif /* FTS_POWER_SOURCE_CUST_EN */
+
+static int fts_power_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    ts_data->power_disabled = true;
+#if FTS_POWER_SOURCE_CUST_EN
+    ret = fts_power_source_init(ts_data);
+    if (ret) {
+        FTS_ERROR("fail to get power(regulator)");
+        return ret;
+    }
+#else
+#if (!FTS_CHIP_IDC)
+    ret = fts_set_reset(ts_data, 0);
+    if (ret) return ret;
+#endif
+    fts_msleep(2);
+    ret = fts_set_reset(ts_data, 1);
+    if (ret) return ret;
+#endif /* FTS_POWER_SOURCE_CUST_EN */
+
+    /* Init BUS pins(SPI/I2C) after powring on if enabling FTS_PINCTRL_EN*/
+#if FTS_PINCTRL_EN
+    fts_pinctrl_init(ts_data);
+    if (ts_data->pinctrl && ts_data->pins_active) {
+        ret = pinctrl_select_state(ts_data->pinctrl, ts_data->pins_active);
+        if (ret < 0) {
+            FTS_ERROR("Set bus pins to active state failed,ret=%d", ret);
+        }
+    }
+#endif
+
+    fts_msleep(200);
+    return 0;
+}
+
+static int fts_power_suspend(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    FTS_INFO("make TP enter into sleep mode");
+    ret = fts_write_reg(FTS_REG_POWER_MODE, FTS_REG_POWER_MODE_SLEEP);
+    if (ret < 0) {
+        FTS_ERROR("set TP to sleep mode failed, ret=%d", ret);
+    }
+
+#if FTS_POWER_SUSPEND_OFF_EN
+#if FTS_PINCTRL_EN
+    if (ts_data->pinctrl && ts_data->pins_suspend) {
+        if (pinctrl_select_state(ts_data->pinctrl, ts_data->pins_suspend)) {
+            FTS_ERROR("Set bus pins to suspend state failed");
+        }
+    }
+#endif /* FTS_PINCTRL_EN */
+
+#if FTS_POWER_SOURCE_CUST_EN
+    if (fts_power_source_ctrl(ts_data, DISABLE)) {
+        FTS_ERROR("set power to off failed");
+    }
+#else
+    FTS_ERROR("FTS_POWER_SOURCE_CUST_EN=0,FTS_POWER_SUSPEND_OFF_EN=1");
+#endif /* FTS_POWER_SOURCE_CUST_EN */
+#endif /* FTS_POWER_SUSPEND_OFF_EN */
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_power_resume(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+#if FTS_POWER_SUSPEND_OFF_EN
+#if FTS_POWER_SOURCE_CUST_EN
+    if (fts_power_source_ctrl(ts_data, ENABLE)) {
+        FTS_ERROR("set power to on failed");
+    }
+    fts_msleep(FTS_DELAY_RESUME_RESET);
+#else
+    FTS_ERROR("FTS_POWER_SOURCE_CUST_EN=0,FTS_POWER_SUSPEND_OFF_EN=1");
+#endif /* FTS_POWER_SOURCE_CUST_EN */
+
+#if FTS_PINCTRL_EN
+    if (ts_data->pinctrl && ts_data->pins_active) {
+        if (pinctrl_select_state(ts_data->pinctrl, ts_data->pins_active)) {
+            FTS_ERROR("Set bus pins to active state failed");
+        }
+    }
+#endif /* FTS_PINCTRL_EN */
+
+#else /* else FTS_POWER_SUSPEND_OFF_EN */
+    if (!ts_data->ic_info.is_incell) {
+        fts_reset_proc(ts_data, false, FTS_DELAY_RESUME_RESET);
+    }
+#endif /* FTS_POWER_SUSPEND_OFF_EN */
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_gpio_configure(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    /* request irq gpio */
+    if (gpio_is_valid(ts_data->pdata->irq_gpio)) {
+        ret = gpio_request(ts_data->pdata->irq_gpio, "fts_irq_gpio");
+        if (ret) {
+            FTS_ERROR("[GPIO]irq gpio request failed");
+            goto err_irq_gpio_req;
+        }
+
+        ret = gpio_direction_input(ts_data->pdata->irq_gpio);
+        if (ret) {
+            FTS_ERROR("[GPIO]set_direction for irq gpio failed");
+            goto err_irq_gpio_dir;
+        }
+    }
+
+    /* request reset gpio */
+    if (gpio_is_valid(ts_data->pdata->reset_gpio)) {
+        ret = gpio_request(ts_data->pdata->reset_gpio, "fts_reset_gpio");
+        if (ret) {
+            FTS_ERROR("[GPIO]reset gpio request failed");
+            goto err_irq_gpio_dir;
+        }
+    }
+
+    FTS_FUNC_EXIT();
+    return 0;
+
+err_irq_gpio_dir:
+    if (gpio_is_valid(ts_data->pdata->irq_gpio))
+        gpio_free(ts_data->pdata->irq_gpio);
+err_irq_gpio_req:
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static int fts_bus_init(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    ts_data->bus_tx_buf = kzalloc(FTS_MAX_BUS_BUF, GFP_KERNEL);
+    if (NULL == ts_data->bus_tx_buf) {
+        FTS_ERROR("failed to allocate memory for bus_tx_buf");
+        return -ENOMEM;
+    }
+
+    ts_data->bus_rx_buf = kzalloc(FTS_MAX_BUS_BUF, GFP_KERNEL);
+    if (NULL == ts_data->bus_rx_buf) {
+        FTS_ERROR("failed to allocate memory for bus_rx_buf");
+        return -ENOMEM;
+    }
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_get_dt_coords(struct device *dev, char *name,
+                             struct fts_ts_platform_data *pdata)
+{
+    int ret = 0;
+    u32 coords[FTS_COORDS_ARR_SIZE] = { 0 };
+    struct property *prop;
+    struct device_node *np = dev->of_node;
+    int coords_size;
+
+    prop = of_find_property(np, name, NULL);
+    if (!prop)
+        return -EINVAL;
+    if (!prop->value)
+        return -ENODATA;
+
+    coords_size = prop->length / sizeof(u32);
+    if (coords_size != FTS_COORDS_ARR_SIZE) {
+        FTS_ERROR("invalid:%s, size:%d", name, coords_size);
+        return -EINVAL;
+    }
+
+    ret = of_property_read_u32_array(np, name, coords, coords_size);
+    if (ret < 0) {
+        FTS_ERROR("Unable to read %s, please check dts", name);
+        pdata->x_min = FTS_X_MIN_DISPLAY_DEFAULT;
+        pdata->y_min = FTS_Y_MIN_DISPLAY_DEFAULT;
+        pdata->x_max = FTS_X_MAX_DISPLAY_DEFAULT;
+        pdata->y_max = FTS_Y_MAX_DISPLAY_DEFAULT;
+        return -ENODATA;
+    } else {
+        pdata->x_min = coords[0];
+        pdata->y_min = coords[1];
+        pdata->x_max = coords[2];
+        pdata->y_max = coords[3];
+    }
+
+    FTS_INFO("display x(%d %d) y(%d %d)", pdata->x_min, pdata->x_max,
+             pdata->y_min, pdata->y_max);
+    return 0;
+}
+
+static int fts_parse_dt(struct device *dev, struct fts_ts_platform_data *pdata)
+{
+    int ret = 0;
+    struct device_node *np = dev->of_node;
+    u32 temp_val = 0;
+
+    FTS_FUNC_ENTER();
+    if (!np || !pdata) {
+        FTS_ERROR("np/pdata is null");
+        return -EINVAL;
+    }
+
+    ret = fts_get_dt_coords(dev, "focaltech,display-coords", pdata);
+    if (ret < 0)
+        FTS_ERROR("Unable to get display-coords");
+
+    /* key */
+    pdata->have_key = of_property_read_bool(np, "focaltech,have-key");
+    if (pdata->have_key) {
+        ret = of_property_read_u32(np, "focaltech,key-number", &pdata->key_number);
+        if (ret < 0)
+            FTS_ERROR("Key number undefined!");
+
+        ret = of_property_read_u32_array(np, "focaltech,keys",
+                                         pdata->keys, pdata->key_number);
+        if (ret < 0)
+            FTS_ERROR("Keys undefined!");
+        else if (pdata->key_number > FTS_MAX_KEYS)
+            pdata->key_number = FTS_MAX_KEYS;
+
+        ret = of_property_read_u32_array(np, "focaltech,key-x-coords",
+                                         pdata->key_x_coords,
+                                         pdata->key_number);
+        if (ret < 0)
+            FTS_ERROR("Key Y Coords undefined!");
+
+        ret = of_property_read_u32_array(np, "focaltech,key-y-coords",
+                                         pdata->key_y_coords,
+                                         pdata->key_number);
+        if (ret < 0)
+            FTS_ERROR("Key X Coords undefined!");
+
+        FTS_INFO("VK Number:%d, key:(%d,%d,%d), "
+                 "coords:(%d,%d),(%d,%d),(%d,%d)",
+                 pdata->key_number,
+                 pdata->keys[0], pdata->keys[1], pdata->keys[2],
+                 pdata->key_x_coords[0], pdata->key_y_coords[0],
+                 pdata->key_x_coords[1], pdata->key_y_coords[1],
+                 pdata->key_x_coords[2], pdata->key_y_coords[2]);
+    }
+
+    /* reset, irq gpio info */
+    pdata->reset_gpio = of_get_named_gpio(np, "focaltech,reset-gpio", 0);
+    if (pdata->reset_gpio < 0)
+        FTS_ERROR("Unable to get reset_gpio");
+
+    pdata->irq_gpio = of_get_named_gpio(np, "focaltech,irq-gpio", 0);
+    if (pdata->irq_gpio < 0)
+        FTS_ERROR("Unable to get irq_gpio");
+
+    ret = of_property_read_u32(np, "focaltech,max-touch-number", &temp_val);
+    if (ret < 0) {
+        FTS_ERROR("Unable to get max-touch-number, please check dts");
+        pdata->max_touch_number = FTS_MAX_POINTS_SUPPORT;
+    } else {
+        if (temp_val < 2)
+            pdata->max_touch_number = 2; /* max_touch_number must >= 2 */
+        else if (temp_val > FTS_MAX_POINTS_SUPPORT)
+            pdata->max_touch_number = FTS_MAX_POINTS_SUPPORT;
+        else
+            pdata->max_touch_number = temp_val;
+    }
+
+    FTS_INFO("max touch number:%d, irq gpio:%d, reset gpio:%d",
+             pdata->max_touch_number, pdata->irq_gpio, pdata->reset_gpio);
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_ts_suspend(struct device *dev)
+{
+    struct fts_ts_data *ts_data = fts_data;
+
+    FTS_FUNC_ENTER();
+    if (ts_data->suspended) {
+        FTS_INFO("Already in suspend state");
+        return 0;
+    }
+
+    if (ts_data->fw_loading) {
+        FTS_INFO("fw upgrade in process, can't suspend");
+        return 0;
+    }
+
+    ts_data->need_work_in_suspend = false;
+    fts_esdcheck_suspend(ts_data);
+#if FTS_PSENSOR_EN
+    if (ts_data->proximity_mode) {
+        fts_proximity_suspend(ts_data);
+        ts_data->need_work_in_suspend = true;
+        fts_release_all_finger();
+        ts_data->suspended = true;
+        return 0;
+    }
+#endif
+
+#if FTS_FOD_EN
+    if (ts_data->fod_mode) {
+        fts_fod_suspend(ts_data);
+        ts_data->need_work_in_suspend = true;
+    }
+#endif
+
+    if (ts_data->gesture_support) {
+        fts_gesture_suspend(ts_data);
+        ts_data->need_work_in_suspend = true;
+    }
+
+    if (ts_data->need_work_in_suspend) {
+        if (enable_irq_wake(ts_data->irq)) {
+            FTS_ERROR("enable_irq_wake(irq:%d) fail", ts_data->irq);
+        }
+    } else {
+        fts_irq_disable();
+        fts_power_suspend(ts_data);
+    }
+
+    fts_release_all_finger();
+    ts_data->suspended = true;
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fts_ts_resume(struct device *dev)
+{
+    struct fts_ts_data *ts_data = fts_data;
+
+    FTS_FUNC_ENTER();
+    if (!ts_data->suspended) {
+        FTS_DEBUG("Already in awake state");
+        return 0;
+    }
+
+    if (ts_data->fw_loading) {
+        FTS_INFO("fw upgrade in process, don't resume");
+        return 0;
+    }
+
+    ts_data->suspended = false;
+    fts_release_all_finger();
+#if FTS_PSENSOR_EN
+    if (ts_data->proximity_mode) {
+        fts_wait_tp_to_valid();
+        fts_proximity_resume(ts_data);
+        fts_esdcheck_resume(ts_data);
+        if (ts_data->gesture_support) fts_gesture_resume(ts_data);
+        return 0;
+    }
+#endif
+
+    if (ts_data->need_work_in_suspend) {
+#if FTS_FOD_EN
+        if ((!ts_data->ic_info.is_incell) && (!fts_fod_checkdown(ts_data))) {
+            fts_reset_proc(ts_data, false, FTS_DELAY_RESUME_RESET);
+        }
+#else
+        if (!ts_data->ic_info.is_incell) {
+            fts_reset_proc(ts_data, false, FTS_DELAY_RESUME_RESET);
+        }
+#endif
+    } else {
+        fts_power_resume(ts_data);
+    }
+
+    fts_enter_normal_fw();
+    if (ts_data->gesture_support) {
+        fts_gesture_resume(ts_data);
+    }
+#if FTS_FOD_EN
+    if (ts_data->fod_mode) {
+        fts_fod_resume(ts_data);
+    }
+#endif
+    fts_ex_mode_recovery(ts_data);
+    fts_esdcheck_resume(ts_data);
+
+    if (ts_data->need_work_in_suspend) {
+        if (disable_irq_wake(ts_data->irq)) {
+            FTS_ERROR("disable_irq_wake(irq:%d) fail", ts_data->irq);
+        }
+    } else {
+        fts_irq_enable();
+    }
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static void fts_resume_work(struct work_struct *work)
+{
+    struct fts_ts_data *ts_data = container_of(work, struct fts_ts_data, resume_work);
+    fts_ts_resume(ts_data->dev);
+}
+
+
+#if IS_ENABLED(CONFIG_DRM)
+#if IS_ENABLED(CONFIG_DRM_PANEL)
+static struct drm_panel *active_panel;
+
+static int drm_check_dt(struct fts_ts_data *ts_data)
+{
+    int i = 0;
+    int count = 0;
+    struct device_node *node = NULL;
+    struct drm_panel *panel = NULL;
+    struct device_node *np = NULL;
+
+    if (ts_data && ts_data->dev && ts_data->dev->of_node) {
+        np = ts_data->dev->of_node;
+        count = of_count_phandle_with_args(np, "panel", NULL);
+        if (count <= 0) {
+            FTS_ERROR("find drm_panel count(%d) fail", count);
+            return -ENODEV;
+        }
+
+        for (i = 0; i < count; i++) {
+            node = of_parse_phandle(np, "panel", i);
+            panel = of_drm_find_panel(node);
+            of_node_put(node);
+            if (!IS_ERR(panel)) {
+                FTS_INFO("find drm_panel successfully");
+                active_panel = panel;
+                return 0;
+            }
+        }
+    }
+
+    FTS_ERROR("no find drm_panel");
+    return -ENODEV;
+}
+#endif //CONFIG_DRM_PANEL
+#endif //CONFIG_DRM
+
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+static int spacemit_fts_hw_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    ret = fts_bus_init(ts_data);
+    if (ret) {
+        FTS_ERROR("bus initialize fail");
+        goto err_bus_init;
+    }
+
+    ret = fts_buffer_init(ts_data);
+    if (ret) {
+        FTS_ERROR("buffer init fail");
+        goto err_bus_init;
+    }
+
+    ret = fts_gpio_configure(ts_data);
+    if (ret) {
+        FTS_ERROR("configure the gpios fail");
+        goto err_gpio_config;
+    }
+
+    ret = fts_power_init(ts_data);
+    if (ret) {
+        FTS_ERROR("fail to init power");
+        goto err_power_init;
+    }
+
+    ret = fts_get_ic_information(ts_data);
+    if (ret) {
+        FTS_ERROR("not focal IC, unregister driver");
+        goto err_power_init;
+    }
+
+    ret = fts_input_init(ts_data);
+    if (ret) {
+        FTS_ERROR("input initialize fail");
+        goto err_power_init;
+    }
+
+#if FTS_READ_CUSTOMER_INFO
+    ret = fts_read_customer_information(ts_data);
+    if (ret) {
+        FTS_ERROR("read customer information fail");
+    }
+#endif
+
+    ret = fts_create_apk_debug_channel(ts_data);
+    if (ret) {
+        FTS_ERROR("create apk debug node fail");
+    }
+
+    ret = fts_create_sysfs(ts_data);
+    if (ret) {
+        FTS_ERROR("create sysfs node fail");
+    }
+
+    ret = fts_point_report_check_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init point report check fail");
+    }
+
+    ret = fts_ex_mode_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init glove/cover/charger fail");
+    }
+
+    ret = fts_gesture_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init gesture fail");
+    }
+
+#if FTS_PSENSOR_EN
+    ret = fts_proximity_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init proximity fail");
+    }
+#endif
+
+    ret = fts_esdcheck_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init esd check fail");
+    }
+
+    ret = fts_irq_registration(ts_data);
+    if (ret) {
+        FTS_ERROR("request irq failed");
+        goto err_irq_req;
+    }
+
+    ret = fts_fwupg_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init fw upgrade fail");
+    }
+
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+    init_completion(&ts_data->pm_completion);
+    ts_data->pm_suspend = false;
+#endif
+    FTS_FUNC_EXIT();
+    return 0;
+
+err_irq_req:
+    fts_esdcheck_exit(ts_data);
+#if FTS_PSENSOR_EN
+    fts_proximity_exit(ts_data);
+#endif
+    fts_gesture_exit(ts_data);
+    fts_ex_mode_exit(ts_data);
+    fts_point_report_check_exit(ts_data);
+    fts_remove_sysfs(ts_data);
+    fts_release_apk_debug_channel(ts_data);
+    input_unregister_device(ts_data->input_dev);
+#if FTS_PEN_EN
+    input_unregister_device(ts_data->pen_dev);
+#endif
+err_power_init:
+#if FTS_PINCTRL_EN
+    if (ts_data->pinctrl) {
+        if (ts_data->pins_release) {
+            pinctrl_select_state(ts_data->pinctrl, ts_data->pins_release);
+        }
+        devm_pinctrl_put(ts_data->pinctrl);
+        ts_data->pinctrl = NULL;
+    }
+#endif
+#if FTS_POWER_SOURCE_CUST_EN
+    fts_power_source_exit(ts_data);
+#endif
+    if (gpio_is_valid(ts_data->pdata->reset_gpio))
+        gpio_free(ts_data->pdata->reset_gpio);
+    if (gpio_is_valid(ts_data->pdata->irq_gpio))
+        gpio_free(ts_data->pdata->irq_gpio);
+err_gpio_config:
+    kfree_safe(ts_data->touch_buf);
+err_bus_init:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+    wakeup_source_trash(&ts_data->ws);
+    ts_data->p_ws = NULL;
+#else
+    wakeup_source_unregister(ts_data->p_ws);
+#endif
+    cancel_work_sync(&ts_data->resume_work);
+    if (ts_data->ts_workqueue) destroy_workqueue(ts_data->ts_workqueue);
+    kfree_safe(ts_data->bus_tx_buf);
+    kfree_safe(ts_data->bus_rx_buf);
+    kfree_safe(ts_data->pdata);
+
+    FTS_FUNC_EXIT();
+    return ret;
+}
+#endif
+static int callback_times = 0;
+static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *v)
+{
+    struct fts_ts_data *ts_data = container_of(self, struct fts_ts_data, fb_notif);
+    FTS_FUNC_ENTER();
+    if (ts_data && v) {
+#if IS_ENABLED(CONFIG_DRM)
+
+#if IS_ENABLED(CONFIG_DRM_PANEL)
+#ifdef CONFIG_SOC_SPACEMIT_K1
+	const unsigned long event_enum[2] = {DRM_PANEL_EARLY_EVENT_BLANK, DRM_PANEL_EVENT_BLANK};
+#else //CONFIG_SOC_SPACEMIT_K1
+        int blank_value = *((int *)(((struct drm_panel_notifier *)v)->data));
+        const unsigned long event_enum[2] = {DRM_PANEL_EARLY_EVENT_BLANK, DRM_PANEL_EVENT_BLANK};
+        const int blank_enum[2] = {DRM_PANEL_BLANK_POWERDOWN, DRM_PANEL_BLANK_UNBLANK};
+#endif //CONFIG_SOC_SPACEMIT_K1
+#else //CONFIG_DRM_PANEL
+        int blank_value = *((int *)(((struct msm_drm_notifier *)v)->data));
+        const unsigned long event_enum[2] = {MSM_DRM_EARLY_EVENT_BLANK, MSM_DRM_EVENT_BLANK};
+        const int blank_enum[2] = {MSM_DRM_BLANK_POWERDOWN, MSM_DRM_BLANK_UNBLANK};
+#endif //CONFIG_DRM_PANEL
+
+#elif IS_ENABLED(CONFIG_FB)
+        const unsigned long event_enum[2] = {FB_EARLY_EVENT_BLANK, FB_EVENT_BLANK};
+        const int blank_enum[2] = {FB_BLANK_POWERDOWN, FB_BLANK_UNBLANK};
+        int blank_value = *((int *)(((struct fb_event *)v)->data));
+#endif //CONFIG_DRM
+#ifdef CONFIG_SOC_SPACEMIT_K1
+	FTS_INFO("notifier,event:%lu", event);
+	if(callback_times == 0)
+	    spacemit_fts_hw_init(ts_data);
+	else {
+            if (event_enum[1] == event) {
+                queue_work(fts_data->ts_workqueue, &fts_data->resume_work);
+            } else if (event_enum[0] == event) {
+                cancel_work_sync(&fts_data->resume_work);
+                fts_ts_suspend(ts_data->dev);
+            } else {
+                FTS_DEBUG("notifier,event:%lu, not care", event);
+            }
+	}
+#else
+        FTS_INFO("notifier,event:%lu,blank:%d", event, blank_value);
+        if ((blank_enum[1] == blank_value) && (event_enum[1] == event)) {
+            queue_work(fts_data->ts_workqueue, &fts_data->resume_work);
+        } else if ((blank_enum[0] == blank_value) && (event_enum[0] == event)) {
+            cancel_work_sync(&fts_data->resume_work);
+            fts_ts_suspend(ts_data->dev);
+        } else {
+            FTS_DEBUG("notifier,event:%lu,blank:%d, not care", event, blank_value);
+        }
+#endif
+    } else {
+        FTS_ERROR("ts_data/v is null");
+        return -EINVAL;
+    }
+    FTS_FUNC_EXIT();
+    callback_times++;
+    return 0;
+}
+
+static int fts_notifier_callback_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    FTS_FUNC_ENTER();
+#if IS_ENABLED(CONFIG_DRM)
+    ts_data->fb_notif.notifier_call = fb_notifier_callback;
+#if IS_ENABLED(CONFIG_DRM_PANEL)
+    ret = drm_check_dt(ts_data);
+    if (ret) FTS_ERROR("parse drm-panel fail");
+    FTS_INFO("init notifier with drm_panel_notifier_register");
+#ifdef CONFIG_SOC_SPACEMIT_K1
+    spacemit_drm_register_client(&ts_data->fb_notif);
+    FTS_FUNC_EXIT();
+    return 0;
+#else
+    if (active_panel) {
+        ret = drm_panel_notifier_register(active_panel, &ts_data->fb_notif);
+        if (ret) FTS_ERROR("[DRM]drm_panel_notifier_register fail: %d", ret);
+    }
+#endif
+#else
+    FTS_INFO("init notifier with msm_drm_register_client");
+    ret = msm_drm_register_client(&ts_data->fb_notif);
+    if (ret) FTS_ERROR("[DRM]msm_drm_register_client fail: %d", ret);
+#endif //CONFIG_DRM_PANEL
+
+#elif IS_ENABLED(CONFIG_FB)
+    FTS_INFO("init notifier with fb_register_client");
+    ts_data->fb_notif.notifier_call = fb_notifier_callback;
+    ret = fb_register_client(&ts_data->fb_notif);
+    if (ret) {
+        FTS_ERROR("[FB]Unable to register fb_notifier: %d", ret);
+    }
+
+#endif //CONFIG_DRM
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static int fts_notifier_callback_exit(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+#if IS_ENABLED(CONFIG_DRM)
+#if IS_ENABLED(CONFIG_DRM_PANEL)
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+    spacemit_drm_unregister_client(&ts_data->fb_notif);
+#else
+    if (active_panel)
+        drm_panel_notifier_unregister(active_panel, &ts_data->fb_notif);
+#endif
+#else
+    if (msm_drm_unregister_client(&ts_data->fb_notif))
+        FTS_ERROR("[DRM]Error occurred while unregistering fb_notifier.");
+#endif
+
+#elif IS_ENABLED(CONFIG_FB)
+    if (fb_unregister_client(&ts_data->fb_notif))
+        FTS_ERROR("[FB]Error occurred while unregistering fb_notifier.");
+#endif //CONFIG_DRM
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+
+int fts_ts_probe_entry(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    FTS_INFO("%s", FTS_DRIVER_VERSION);
+    fts_data = ts_data;
+    ts_data->pdata = kzalloc(sizeof(struct fts_ts_platform_data), GFP_KERNEL);
+    if (!ts_data->pdata) {
+        FTS_ERROR("allocate memory for platform_data fail");
+        return -ENOMEM;
+    }
+
+    ret = fts_parse_dt(ts_data->dev, ts_data->pdata);
+    if (ret) {
+        FTS_ERROR("device-tree parse fail");
+    }
+
+    ts_data->ts_workqueue = create_singlethread_workqueue("fts_wq");
+    if (!ts_data->ts_workqueue) {
+        FTS_ERROR("create fts workqueue fail");
+    } else {
+        INIT_WORK(&ts_data->resume_work, fts_resume_work);
+    }
+    spin_lock_init(&ts_data->irq_lock);
+    mutex_init(&ts_data->report_mutex);
+    mutex_init(&ts_data->bus_lock);
+    init_waitqueue_head(&ts_data->ts_waitqueue);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+    wakeup_source_init(&ts_data->ws, "fts_ws");
+    ts_data->p_ws = &ts_data->ws;
+#else
+    ts_data->p_ws = wakeup_source_register(ts_data->dev, "fts_ws");
+#endif
+#ifndef CONFIG_SOC_SPACEMIT_K1X
+    ret = fts_bus_init(ts_data);
+    if (ret) {
+        FTS_ERROR("bus initialize fail");
+        goto err_bus_init;
+    }
+
+    ret = fts_buffer_init(ts_data);
+    if (ret) {
+        FTS_ERROR("buffer init fail");
+        goto err_bus_init;
+    }
+
+    ret = fts_gpio_configure(ts_data);
+    if (ret) {
+        FTS_ERROR("configure the gpios fail");
+        goto err_gpio_config;
+    }
+
+    ret = fts_power_init(ts_data);
+    if (ret) {
+        FTS_ERROR("fail to init power");
+        goto err_power_init;
+    }
+
+    ret = fts_get_ic_information(ts_data);
+    if (ret) {
+        FTS_ERROR("not focal IC, unregister driver");
+        goto err_power_init;
+    }
+
+    ret = fts_input_init(ts_data);
+    if (ret) {
+        FTS_ERROR("input initialize fail");
+        goto err_power_init;
+    }
+
+#if FTS_READ_CUSTOMER_INFO
+    ret = fts_read_customer_information(ts_data);
+    if (ret) {
+        FTS_ERROR("read customer information fail");
+    }
+#endif
+
+    ret = fts_create_apk_debug_channel(ts_data);
+    if (ret) {
+        FTS_ERROR("create apk debug node fail");
+    }
+
+    ret = fts_create_sysfs(ts_data);
+    if (ret) {
+        FTS_ERROR("create sysfs node fail");
+    }
+
+    ret = fts_point_report_check_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init point report check fail");
+    }
+
+    ret = fts_ex_mode_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init glove/cover/charger fail");
+    }
+
+    ret = fts_gesture_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init gesture fail");
+    }
+
+#if FTS_PSENSOR_EN
+    ret = fts_proximity_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init proximity fail");
+    }
+#endif
+
+    ret = fts_esdcheck_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init esd check fail");
+    }
+
+    ret = fts_irq_registration(ts_data);
+    if (ret) {
+        FTS_ERROR("request irq failed");
+        goto err_irq_req;
+    }
+
+    ret = fts_fwupg_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init fw upgrade fail");
+    }
+
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+    init_completion(&ts_data->pm_completion);
+    ts_data->pm_suspend = false;
+#endif
+#endif
+    ret = fts_notifier_callback_init(ts_data);
+    if (ret) {
+        FTS_ERROR("init notifier callback fail");
+    }
+
+    FTS_FUNC_EXIT();
+    return ret;
+#ifndef CONFIG_SOC_SPACEMIT_K1X
+err_irq_req:
+    fts_esdcheck_exit(ts_data);
+#if FTS_PSENSOR_EN
+    fts_proximity_exit(ts_data);
+#endif
+    fts_gesture_exit(ts_data);
+    fts_ex_mode_exit(ts_data);
+    fts_point_report_check_exit(ts_data);
+    fts_remove_sysfs(ts_data);
+    fts_release_apk_debug_channel(ts_data);
+    input_unregister_device(ts_data->input_dev);
+#if FTS_PEN_EN
+    input_unregister_device(ts_data->pen_dev);
+#endif
+err_power_init:
+#if FTS_PINCTRL_EN
+    if (ts_data->pinctrl) {
+        if (ts_data->pins_release) {
+            pinctrl_select_state(ts_data->pinctrl, ts_data->pins_release);
+        }
+        devm_pinctrl_put(ts_data->pinctrl);
+        ts_data->pinctrl = NULL;
+    }
+#endif
+#if FTS_POWER_SOURCE_CUST_EN
+    fts_power_source_exit(ts_data);
+#endif
+    if (gpio_is_valid(ts_data->pdata->reset_gpio))
+        gpio_free(ts_data->pdata->reset_gpio);
+    if (gpio_is_valid(ts_data->pdata->irq_gpio))
+        gpio_free(ts_data->pdata->irq_gpio);
+err_gpio_config:
+    kfree_safe(ts_data->touch_buf);
+err_bus_init:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+    wakeup_source_trash(&ts_data->ws);
+    ts_data->p_ws = NULL;
+#else
+    wakeup_source_unregister(ts_data->p_ws);
+#endif
+    cancel_work_sync(&ts_data->resume_work);
+    if (ts_data->ts_workqueue) destroy_workqueue(ts_data->ts_workqueue);
+    kfree_safe(ts_data->bus_tx_buf);
+    kfree_safe(ts_data->bus_rx_buf);
+    kfree_safe(ts_data->pdata);
+
+    FTS_FUNC_EXIT();
+    return ret;
+#endif
+}
+
+int fts_ts_remove_entry(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    cancel_work_sync(&ts_data->resume_work);
+    fts_notifier_callback_exit(ts_data);
+    free_irq(ts_data->irq, ts_data);
+    fts_fwupg_exit(ts_data);
+    fts_esdcheck_exit(ts_data);
+#if FTS_PSENSOR_EN
+    fts_proximity_exit(ts_data);
+#endif
+    fts_gesture_exit(ts_data);
+    fts_ex_mode_exit(ts_data);
+    fts_point_report_check_exit(ts_data);
+    fts_remove_sysfs(ts_data);
+    fts_release_apk_debug_channel(ts_data);
+    input_unregister_device(ts_data->input_dev);
+#if FTS_PEN_EN
+    input_unregister_device(ts_data->pen_dev);
+#endif
+    if (ts_data->ts_workqueue) destroy_workqueue(ts_data->ts_workqueue);
+    if (gpio_is_valid(ts_data->pdata->reset_gpio))
+        gpio_free(ts_data->pdata->reset_gpio);
+    if (gpio_is_valid(ts_data->pdata->irq_gpio))
+        gpio_free(ts_data->pdata->irq_gpio);
+
+#if FTS_PINCTRL_EN
+    if (ts_data->pinctrl) {
+        if (ts_data->pins_release) {
+            pinctrl_select_state(ts_data->pinctrl, ts_data->pins_release);
+        }
+        devm_pinctrl_put(ts_data->pinctrl);
+        ts_data->pinctrl = NULL;
+    }
+#endif
+
+#if FTS_POWER_SOURCE_CUST_EN
+    fts_power_source_exit(ts_data);
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+    wakeup_source_trash(&ts_data->ws);
+    ts_data->p_ws = NULL;
+#else
+    wakeup_source_unregister(ts_data->p_ws);
+#endif
+    kfree_safe(ts_data->touch_buf);
+    kfree_safe(ts_data->bus_tx_buf);
+    kfree_safe(ts_data->bus_rx_buf);
+    kfree_safe(ts_data->pdata);
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_core.h b/drivers/input/touchscreen/focaltech_touch/focaltech_core.h
new file mode 100755
index 000000000000..4b2caaf5532b
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_core.h
@@ -0,0 +1,426 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*****************************************************************************
+*
+* File Name: focaltech_core.h
+
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+#ifndef __LINUX_FOCALTECH_CORE_H__
+#define __LINUX_FOCALTECH_CORE_H__
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+#include <linux/debugfs.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/jiffies.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/dma-mapping.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+#include <linux/ktime.h>
+#include <linux/timekeeping.h>
+#endif
+#include "focaltech_common.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_DRIVER_NAME                     "fts_ts"
+
+#define FTS_MAX_POINTS_SUPPORT              10 /* constant value, can't be changed */
+#define FTS_MAX_KEYS                        4
+#define FTS_KEY_DIM                         10
+#define FTS_COORDS_ARR_SIZE                 4
+#define FTS_ONE_TCH_LEN                     6
+#define FTS_ONE_TCH_LEN_V2                  8
+#define FTS_TOUCH_DATA_LEN_V2  (FTS_MAX_POINTS_SUPPORT * FTS_ONE_TCH_LEN_V2 + 4)
+
+
+#define FTS_TOUCH_DATA_LEN  (FTS_MAX_POINTS_SUPPORT * FTS_ONE_TCH_LEN + 2)
+
+#define FTS_GESTURE_POINTS_MAX              6
+#define FTS_GESTURE_DATA_LEN               (FTS_GESTURE_POINTS_MAX * 4 + 4)
+
+#define FTS_SIZE_PEN                        15
+#define FTS_SIZE_DEFAULT                    15
+#define FTS_SIZE_DEFAULT_V2                 21
+
+
+#define FTS_MAX_ID                          0x0A
+#define FTS_TOUCH_OFF_E_XH                  0
+#define FTS_TOUCH_OFF_XL                    1
+#define FTS_TOUCH_OFF_ID_YH                 2
+#define FTS_TOUCH_OFF_YL                    3
+#define FTS_TOUCH_OFF_PRE                   4
+#define FTS_TOUCH_OFF_AREA                  5
+#define FTS_TOUCH_OFF_MINOR                 6
+
+#define FTS_TOUCH_E_NUM                     1
+#define FTS_X_MIN_DISPLAY_DEFAULT           0
+#define FTS_Y_MIN_DISPLAY_DEFAULT           0
+#define FTS_X_MAX_DISPLAY_DEFAULT           (720 - 1)
+#define FTS_Y_MAX_DISPLAY_DEFAULT           (1280 - 1)
+
+#define FTS_TOUCH_DOWN                      0
+#define FTS_TOUCH_UP                        1
+#define FTS_TOUCH_CONTACT                   2
+#define EVENT_DOWN(flag)                    ((FTS_TOUCH_DOWN == flag) || (FTS_TOUCH_CONTACT == flag))
+#define EVENT_UP(flag)                      (FTS_TOUCH_UP == flag)
+
+#define FTS_MAX_COMPATIBLE_TYPE             8
+#define FTS_MAX_COMMMAND_LENGTH             16
+
+#define FTS_MAX_TOUCH_BUF                   4096
+#define FTS_MAX_BUS_BUF                     4096
+
+#define FTS_MAX_CUSTOMER_INFO               32
+#define FTS_FOD_BUF_LEN                     9
+
+#define FTS_RETVAL_IGNORE_TOUCHES           1
+
+
+/*****************************************************************************
+*  Alternative mode (When something goes wrong, the modules may be able to solve the problem.)
+*****************************************************************************/
+/*
+ * For commnication error in PM(deep sleep) state
+ */
+#define FTS_PATCH_COMERR_PM                 0
+#define FTS_TIMEOUT_COMERR_PM               700
+
+/*
+ * For high resolution
+ * Set FTS_TOUCH_HIRES_EN to 1 to support high resolution reporting of touch finger.
+ * Set FTS_PEN_HIRES_EN to 1 to support high resolution reporting of stylus pen.
+ *
+ * FTS_XXX_HIRES_X, a multiple relative to the original resolution
+ * FTS_HI_RES_X_MAX, const value, can't be modified
+ */
+#define FTS_TOUCH_HIRES_EN                  0
+#define FTS_TOUCH_HIRES_X                   10
+
+#define FTS_PEN_HIRES_EN                    1
+#define FTS_PEN_HIRES_X                     10
+
+
+#define FTS_HI_RES_X_MAX                    16
+
+
+/* If need read customer info when probing, max:FTS_MAX_CUSTOMER_INFO */
+#define FTS_READ_CUSTOMER_INFO              0
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+struct ftxxxx_proc {
+    struct proc_dir_entry *proc_entry;
+    u8 opmode;
+    u8 cmd_len;
+    u8 cmd[FTS_MAX_COMMMAND_LENGTH];
+};
+
+struct fts_ts_platform_data {
+    u32 irq_gpio;
+    u32 irq_gpio_flags;
+    u32 reset_gpio;
+    u32 reset_gpio_flags;
+    bool have_key;
+    u32 key_number;
+    u32 keys[FTS_MAX_KEYS];
+    u32 key_y_coords[FTS_MAX_KEYS];
+    u32 key_x_coords[FTS_MAX_KEYS];
+    u32 x_max;
+    u32 y_max;
+    u32 x_min;
+    u32 y_min;
+    u32 max_touch_number;
+};
+
+struct ts_event {
+    int x;      /*x coordinate */
+    int y;      /*y coordinate */
+    int p;      /* pressure */
+    int flag;   /* touch event flag: 0 -- down; 1-- up; 2 -- contact */
+    int id;     /*touch ID */
+    int area;
+    int minor;
+};
+
+struct pen_event {
+    int down;
+    int inrange;
+    int tip;
+    int x;      /*x coordinate */
+    int y;      /*y coordinate */
+    int p;      /* pressure */
+    int flag;   /* touch event flag: 0 -- down; 1-- up; 2 -- contact */
+    int id;     /*touch ID */
+    int tilt_x;
+    int tilt_y;
+    int azimuth;
+    int tool_type;
+};
+
+struct fts_ts_data {
+    struct i2c_client *client;
+    struct spi_device *spi;
+    u32 spi_speed;
+    struct device *dev;
+    struct input_dev *input_dev;
+    struct input_dev *pen_dev;
+    struct fts_ts_platform_data *pdata;
+    struct ts_ic_info ic_info;
+    struct workqueue_struct *ts_workqueue;
+    struct work_struct resume_work;
+    struct delayed_work esdcheck_work;
+    struct delayed_work prc_work;
+    struct delayed_work fwdbg_work;
+    wait_queue_head_t ts_waitqueue;
+    struct ftxxxx_proc proc;
+    struct ftxxxx_proc proc_ta;
+    spinlock_t irq_lock;
+    struct mutex report_mutex;
+    struct mutex bus_lock;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+    struct wakeup_source ws;
+#endif
+    struct wakeup_source *p_ws;
+    unsigned long intr_jiffies;
+    int irq;
+    int log_level;
+    int fw_is_running;      /* confirm fw is running when using spi:default 0 */
+    int dummy_byte;
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+    struct completion pm_completion;
+    bool pm_suspend;
+#endif
+    bool suspended;
+    bool need_work_in_suspend;
+    bool fw_loading;
+    bool irq_disabled;
+    bool power_disabled;
+    bool glove_mode;
+    bool cover_mode;
+    bool charger_mode;
+    bool earphone_mode;
+    bool edgepalm_mode;
+    bool touch_analysis_support;
+    bool prc_support;
+    bool prc_mode;
+    bool esd_support;
+    bool fod_mode;
+    bool proximity_mode;
+    bool fhp_mode;
+
+    bool fwdbg_support;
+    bool gesture_support;   /* gesture enable or disable, default: disable */
+    u8 gesture_bmode;       /*gesture buffer mode*/
+
+    int fod_fp_down;
+    int edgepalm_value;
+    int fwdbg_value;
+
+    u8 pen_etype;
+    struct pen_event pevent;
+    struct ts_event events[FTS_MAX_POINTS_SUPPORT];    /* multi-touch */
+    u8 touch_addr;
+    u32 touch_size;
+    u8 *touch_buf;
+    int touch_event_num;
+    int touch_points;
+    int key_state;
+    int ta_flag;
+    u32 ta_size;
+    u8 *ta_buf;
+
+    u8 *bus_tx_buf;
+    u8 *bus_rx_buf;
+    int bus_type;
+    int bus_ver;
+    char customer_info[FTS_MAX_CUSTOMER_INFO];
+    struct regulator *vdd;
+    struct regulator *iovcc;
+#if FTS_PINCTRL_EN
+    struct pinctrl *pinctrl;
+    struct pinctrl_state *pins_active;
+    struct pinctrl_state *pins_suspend;
+    struct pinctrl_state *pins_release;
+#endif
+    struct notifier_block fb_notif;
+};
+
+enum _FTS_BUS_TYPE {
+    BUS_TYPE_NONE,
+    BUS_TYPE_I2C,
+    BUS_TYPE_SPI,
+};
+
+enum _FTS_BUS_VER {
+    BUS_VER_DEFAULT = 1,
+    BUS_VER_V2,
+};
+
+enum _FTS_TOUCH_ETYPE {
+    TOUCH_DEFAULT = 0x00,
+    TOUCH_PROTOCOL_v2 = 0x02,
+    TOUCH_PEN = 0x0B,
+    TOUCH_FW_INIT = 0x81,
+    TOUCH_IGNORE = 0xFE,
+    TOUCH_FWDBG = 0x0E,
+    TOUCH_ERROR = 0xFF,
+};
+
+enum _FTS_STYLUS_ETYPE {
+    STYLUS_DEFAULT,
+    STYLUS_HOVER,
+};
+
+enum _FTS_GESTURE_BMODE {
+    GESTURE_BM_REG,
+    GESTURE_BM_TOUCH,
+};
+
+enum _FTS_FW_MODE {
+    FW_MODE_NORMAL = 0xAA,
+    FW_MODE_FACTORY = 0x55,
+    FW_MODE_GESTURE = 0x66,
+};
+
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+extern struct fts_ts_data *fts_data;
+
+
+/* communication interface */
+int fts_read(u8 *cmd, u32 cmdlen, u8 *data, u32 datalen);
+int fts_read_reg(u8 addr, u8 *value);
+int fts_write(u8 *writebuf, u32 writelen);
+int fts_write_reg(u8 addr, u8 value);
+int fts_bus_configure(struct fts_ts_data *ts_data, u8 *buf, u32 size);
+int fts_bus_transfer_direct(u8 *writebuf, u32 writelen, u8 *readbuf, u32 readlen);
+int fts_bus_set_speed(struct fts_ts_data *ts_data, u32 speed);
+int fts_hid2std(int mode);
+int fts_ts_probe_entry(struct fts_ts_data *ts_data);
+int fts_ts_remove_entry(struct fts_ts_data *ts_data);
+
+/* Gesture functions */
+int fts_gesture_init(struct fts_ts_data *ts_data);
+int fts_gesture_exit(struct fts_ts_data *ts_data);
+void fts_gesture_recovery(struct fts_ts_data *ts_data);
+int fts_gesture_readdata(struct fts_ts_data *ts_data, u8 *data);
+int fts_gesture_suspend(struct fts_ts_data *ts_data);
+int fts_gesture_resume(struct fts_ts_data *ts_data);
+
+#if FTS_FOD_EN
+void fts_fod_enable(int enable);
+#endif
+
+/* Apk and functions */
+int fts_create_apk_debug_channel(struct fts_ts_data *);
+void fts_release_apk_debug_channel(struct fts_ts_data *);
+
+/* ADB functions */
+int fts_create_sysfs(struct fts_ts_data *ts_data);
+int fts_remove_sysfs(struct fts_ts_data *ts_data);
+
+/* ESD */
+int fts_esdcheck_init(struct fts_ts_data *ts_data);
+int fts_esdcheck_exit(struct fts_ts_data *ts_data);
+void fts_esdcheck_switch(struct fts_ts_data *ts_data, bool enable);
+void fts_esdcheck_proc_busy(struct fts_ts_data *ts_data, bool proc_debug);
+void fts_esdcheck_suspend(struct fts_ts_data *ts_data);
+void fts_esdcheck_resume(struct fts_ts_data *ts_data);
+bool fts_esdcheck_is_running(struct fts_ts_data *ts_data);
+
+
+/* Host test */
+
+/* Point Report Check*/
+int fts_point_report_check_init(struct fts_ts_data *ts_data);
+int fts_point_report_check_exit(struct fts_ts_data *ts_data);
+void fts_prc_queue_work(struct fts_ts_data *ts_data);
+
+/* FW upgrade */
+int fts_fwupg_init(struct fts_ts_data *ts_data);
+int fts_fwupg_exit(struct fts_ts_data *ts_data);
+int fts_upgrade_bin(char *fw_name, bool force);
+int fts_enter_test_environment(bool test_state);
+int fts_enter_normal_fw(void);
+
+/* Other */
+void fts_msleep(unsigned long msecs);
+int fts_set_reset(struct fts_ts_data *ts_data, int value);
+int fts_reset_proc(struct fts_ts_data *ts_data, int force, int hdelayms);
+int fts_check_cid(struct fts_ts_data *ts_data, u8 id_h);
+int fts_wait_tp_to_valid(void);
+void fts_release_all_finger(void);
+void fts_tp_state_recovery(struct fts_ts_data *ts_data);
+int fts_ex_mode_init(struct fts_ts_data *ts_data);
+int fts_ex_mode_exit(struct fts_ts_data *ts_data);
+int fts_ex_mode_recovery(struct fts_ts_data *ts_data);
+int fts_input_report_buffer(struct fts_ts_data *ts_data, u8 *touch_buf);
+
+void fts_irq_disable(void);
+void fts_irq_enable(void);
+
+#if FTS_PSENSOR_EN
+int fts_proximity_init(struct fts_ts_data *ts_data);
+int fts_proximity_exit(struct fts_ts_data *ts_data);
+int fts_proximity_readdata(struct fts_ts_data *ts_data);
+int fts_proximity_suspend(struct fts_ts_data *ts_data);
+int fts_proximity_resume(struct fts_ts_data *ts_data);
+int fts_proximity_recovery(struct fts_ts_data *ts_data);
+#endif
+
+
+#endif /* __LINUX_FOCALTECH_CORE_H__ */
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_debug.c b/drivers/input/touchscreen/focaltech_touch/focaltech_debug.c
new file mode 100755
index 000000000000..1f0c0856a37d
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_debug.c
@@ -0,0 +1,963 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*****************************************************************************
+*
+* File Name: focaltech_debug.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2023-12-01
+*
+* Abstract: Fw Debug
+*
+* Version: V1.0
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_REG_FW_DEBUG_EN                 0x9E
+#define FTS_REG_TPINFO                      0x96
+#define FTS_REG_DBGCFG                      0x9D
+
+#define DEFAULT_VAL_REG01                   0xFFFF
+#define DEFAULT_MAX_FRAME_NUM               10000
+#define MAX_SIZE_TP_INFO                    8
+#define MAX_SIZE_DBG_CFG                    16
+#define MAX_COUNT_READ_REGFB                3
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+typedef enum {
+    FRAME_WAITQ_DEFAULT,
+    FRAME_WAITQ_WAIT,
+    FRAME_WAITQ_WAKEUP,
+} FRAME_WAITQ_FLAG;
+
+struct fwdbg_frame {
+    u64 tv;
+    unsigned char value[0];
+};
+
+struct fwdbg_queue {
+    int head;
+    int tail;
+    int count;
+    int max_count;
+    int elem_size;
+    u8 *buffer;
+    struct mutex mutexq;
+};
+
+struct fwdbg_config {
+    int total_len;
+    int dbgoff;
+    int dbghdr_len;
+    int diff_len;
+    int addinfo_len;
+    int regfa_len;
+    int regfb_len;
+    int tx;
+    int rx;
+};
+
+struct fts_fwdbg {
+    struct fts_ts_data *ts_data;
+    struct proc_dir_entry *proc_fwdbg;
+    struct mutex mutex;
+    wait_queue_head_t frame_waitq;
+    struct fwdbg_queue q;
+    struct fwdbg_config cfg;
+    int max_frame_num; //maximum frame number kept in memory
+    int frame_size; // is equal to size of one frame
+    int touch_size_bak;
+    int proc_ppos;
+    int frame_waitq_flag;
+    int reg01_val;
+    char *proc_frame; /* save a frame value comes from queue */
+    unsigned char *regfb_val;
+    unsigned char *regfa_val;
+
+    bool queue_stop;
+    bool frame_logging;
+    bool frame_block;
+};
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+static struct fts_fwdbg *fts_fwdbg_data;
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+static u64 fwdbg_get_timestamp(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+    ktime_t tv;
+    tv = ktime_get_real() / 1000;
+    return (u64)tv;
+#else
+    struct timeval tv;
+    do_gettimeofday(&tv);
+    return (u64)(((u64)tv.tv_sec * 1000000) + tv.tv_usec);
+#endif
+}
+
+static int dbgq_open(struct fwdbg_queue *q, int max_framenum, int frame_size)
+{
+    if (!q || !max_framenum || !frame_size) {
+        FTS_ERROR("q is null/max_framenum(%d)/frame_size(%d) is invalid", max_framenum, frame_size);
+        return -EINVAL;
+    }
+
+    if (q->buffer) {
+        vfree(q->buffer);
+        q->buffer = NULL;
+    }
+
+    if (!q->buffer) {
+        q->head = q->tail = q->count = 0;
+        q->max_count = max_framenum;
+        q->elem_size = frame_size;
+        FTS_INFO("queque,max_count=%d,elem_size=%d", q->max_count, q->elem_size);
+        q->buffer = vmalloc(q->max_count * q->elem_size);
+        if (!q->buffer) {
+            FTS_ERROR("malloc queue buffer failed");
+            return -ENOMEM;
+        }
+        memset(q->buffer, 0, q->max_count * q->elem_size);
+    }
+    return 0;
+}
+
+static bool dbgq_full(struct fwdbg_queue *q)
+{
+    return q->count == q->max_count;
+}
+
+static bool dbgq_empty(struct fwdbg_queue *q)
+{
+    return q->count == 0;
+}
+
+static int dbgq_enqueue(struct fwdbg_queue *q, u8 *val, u64 timestamp)
+{
+    struct fwdbg_frame *tail_elem = NULL;
+
+    if (!q || !val || !q->buffer) {
+        FTS_ERROR("q/val/buffer is null");
+        return -EINVAL;
+    }
+
+    mutex_lock(&(q->mutexq));
+    tail_elem = (struct fwdbg_frame *)&q->buffer[q->tail * q->elem_size];
+    tail_elem->tv = timestamp;
+    memcpy(tail_elem->value, val, q->elem_size);
+    q->tail = (q->tail + 1) % q->max_count;
+    if (dbgq_full(q)) {
+        q->head = (q->head + 1) % q->max_count;
+    } else {
+        q->count++;
+    }
+    mutex_unlock(&(q->mutexq));
+    return 0;
+}
+
+static int dbgq_dequeue(struct fwdbg_queue *q, u8 *val)
+{
+    if (!q || !val || !q->buffer) {
+        FTS_ERROR("q/val/buffer is null");
+        return -EINVAL;
+    }
+
+    mutex_lock(&(q->mutexq));
+    if (dbgq_empty(q)) {
+        mutex_unlock(&(q->mutexq));
+        return 1;
+    }
+    memcpy(val, &q->buffer[q->head * q->elem_size], q->elem_size);
+    q->head = (q->head + 1) % q->max_count;
+    q->count--;
+    mutex_unlock(&(q->mutexq));
+    return 0;
+}
+
+/*****************************************************************************
+*  Name: dbgq_dequeue_to_proc
+*  Brief: dequeue frames from queue, and send it to proc read buffer.
+*  Input: @q
+*         @buff_maxcount, the maximum frame count
+*  Output:@buff, address of user space buffer
+*  Return:size that send to the buff, or 0 if queue is null, or error code
+*****************************************************************************/
+static int dbgq_dequeue_to_proc(struct fwdbg_queue *q, char __user *buff, int buff_maxcount)
+{
+    int valid_count = 0;
+    int i = 0;
+    char *head_elem = NULL;
+    if (!q || !buff || !q->buffer || !buff_maxcount) {
+        FTS_ERROR("q/buff/buffer is null/buff_maxcount is 0");
+        return -EINVAL;
+    }
+
+    mutex_lock(&(q->mutexq));
+    if (dbgq_empty(q)) {
+        mutex_unlock(&(q->mutexq));
+        return 0;
+    }
+    valid_count = (buff_maxcount > q->count) ? q->count : buff_maxcount;
+    for (i = 0; i < valid_count; i++) {
+        head_elem = (char *)&q->buffer[q->head * q->elem_size];
+        if (copy_to_user(buff + i * q->elem_size, head_elem, q->elem_size)) {
+            FTS_ERROR("copy debug frame(%d) to user failed", i);
+            mutex_unlock(&(q->mutexq));
+            return i * q->elem_size;
+        }
+        q->head = (q->head + 1) % q->max_count;
+        q->count--;
+    }
+    mutex_unlock(&(q->mutexq));
+    return valid_count * q->elem_size;
+}
+
+static int dbgq_release(struct fwdbg_queue *q)
+{
+    q->head = q->tail = q->count = 0;
+    q->max_count = q->elem_size = 0;
+    if (q && q->buffer) {
+        vfree(q->buffer);
+        q->buffer = NULL;
+    }
+    return 0;
+}
+
+/*****************************************************************************
+*  Name: proc_get_one_frame
+*  Brief: Get a frame, and send the frame data to proc read buffer.
+*  Input: @dbg
+*         @buff_maxsize, the maximum size of buff
+*  Output:@buff, address of user space buffer
+*  Return:size that send to the buff, or 0 if queue is null, or error code
+*****************************************************************************/
+static int proc_get_one_frame(struct fts_fwdbg *dbg, char __user *buff, int buff_maxsize)
+{
+    int ret = 0;
+    int frame_remaining_size = 0;
+    int valid_size = 0;
+
+    if (!dbg || !buff || !dbg->proc_frame || !buff_maxsize) {
+        FTS_ERROR("dbg/buff/proc_frame is null/buff_maxsize is 0");
+        return -EINVAL;
+    }
+
+    if (dbg->proc_ppos == 0) {
+        ret = dbgq_dequeue(&dbg->q, dbg->proc_frame);
+        if (ret < 0) {
+            FTS_ERROR("get a frame from queue failed");
+            return ret;
+        } else if (ret == 1) {
+            /* queque is null */
+            return 0;
+        }
+    }
+
+    frame_remaining_size = dbg->frame_size - dbg->proc_ppos;
+    valid_size = (frame_remaining_size > buff_maxsize) ? buff_maxsize : frame_remaining_size;
+    if (copy_to_user(buff, &dbg->proc_frame[dbg->proc_ppos], valid_size)) {
+        FTS_ERROR("copy debug frame to user failed");
+        return -EFAULT;
+    }
+    dbg->proc_ppos = (dbg->proc_ppos + valid_size) % dbg->frame_size;
+
+    return valid_size;
+}
+
+static int fts_fwdbg_get_cfg(struct fts_fwdbg *dbg)
+{
+    int ret = 0;
+    u8 cmd = 0;
+    u8 tp_info[MAX_SIZE_TP_INFO] = { 0 };
+    u8 dbg_cfg[MAX_SIZE_DBG_CFG] = { 0 };
+    cmd = FTS_REG_TPINFO;
+    ret = fts_read(&cmd, 1, tp_info, MAX_SIZE_TP_INFO);
+    if (ret < 0) {
+        FTS_ERROR("read tp info failed");
+        return ret;
+    }
+    cmd = FTS_REG_DBGCFG;
+    ret = fts_read(&cmd, 1, dbg_cfg, MAX_SIZE_DBG_CFG);
+    if (ret < 0) {
+        FTS_ERROR("read debug config failed");
+        return ret;
+    }
+
+    dbg->cfg.total_len = (dbg_cfg[2] << 8) + dbg_cfg[3];
+    dbg->cfg.dbgoff = dbg_cfg[4];
+    dbg->cfg.dbghdr_len = dbg_cfg[5];
+    dbg->cfg.diff_len = (dbg_cfg[6] << 8) + dbg_cfg[7];
+    dbg->cfg.addinfo_len = (dbg_cfg[8] << 8) + dbg_cfg[9];
+    dbg->cfg.regfb_len = (dbg_cfg[10] << 8) + dbg_cfg[11];
+    dbg->cfg.regfa_len = (dbg_cfg[12] << 8) + dbg_cfg[13];
+    dbg->cfg.tx = tp_info[2];
+    dbg->cfg.rx = tp_info[3];
+    return 0;
+}
+
+static int fts_fwdbg_enable(struct fts_fwdbg *dbg, int value)
+{
+    int ret = 0;
+    if (!dbg || !dbg->ts_data || !value) {
+        FTS_ERROR("fwdbg/ts_data is null/value(%d) is invalid", value);
+        return -EINVAL;
+    }
+
+    ret = fts_fwdbg_get_cfg(dbg);
+    if (ret < 0) {
+        FTS_ERROR("get cfg from tp failed");
+        return ret;
+    }
+
+    if ((dbg->cfg.total_len < FTS_TOUCH_DATA_LEN_V2) || (dbg->cfg.total_len > FTS_MAX_TOUCH_BUF)) {
+        FTS_ERROR("report buffer length(%d),not in[%d,%d]", dbg->cfg.total_len,
+                  FTS_TOUCH_DATA_LEN_V2, FTS_MAX_TOUCH_BUF);
+        return -EIO;
+    }
+
+    dbg->frame_size = dbg->cfg.total_len + sizeof(struct fwdbg_frame);
+    FTS_INFO("FwDebug enable,max_frame_num=%d,frame_size=%d", dbg->max_frame_num, dbg->frame_size);
+    if (!dbg->frame_logging) {
+        ret = dbgq_open(&dbg->q, dbg->max_frame_num, dbg->frame_size);
+        if (ret < 0) {
+            FTS_ERROR("dbgq_open failed");
+            goto dbgen_err;
+        }
+    }
+
+    if (dbg->cfg.regfb_len) {
+        if (dbg->regfb_val) {
+            vfree(dbg->regfb_val);
+            dbg->regfb_val = NULL;
+        }
+        dbg->regfb_val = vmalloc(dbg->cfg.regfb_len);
+        if (!dbg->regfb_val) {
+            ret = -ENOMEM;
+            goto dbgen_err;
+        }
+    }
+
+    if (dbg->cfg.regfa_len) {
+        if (dbg->regfa_val) {
+            vfree(dbg->regfa_val);
+            dbg->regfa_val = NULL;
+        }
+        dbg->regfa_val = vmalloc(dbg->cfg.regfa_len);
+        if (!dbg->regfa_val) {
+            ret = -ENOMEM;
+            goto dbgen_err;
+        }
+    }
+
+    dbg->touch_size_bak = dbg->ts_data->touch_size;
+    dbg->ts_data->touch_size = dbg->cfg.total_len;
+    ret = fts_write_reg(FTS_REG_FW_DEBUG_EN, value);
+    if (ret < 0) {
+        FTS_ERROR("write FwDebug to enable failed");
+        goto dbgen_err;
+    }
+
+    return 0;
+
+dbgen_err:
+    if (dbg->regfa_val) {
+        vfree(dbg->regfa_val);
+        dbg->regfa_val = NULL;
+    }
+    if (dbg->regfb_val) {
+        vfree(dbg->regfb_val);
+        dbg->regfb_val = NULL;
+    }
+    dbgq_release(&dbg->q);
+    dbg->ts_data->touch_size = dbg->touch_size_bak;
+    fts_write_reg(FTS_REG_FW_DEBUG_EN, 0);
+    return ret;
+}
+
+static int fts_fwdbg_disable(struct fts_fwdbg *dbg)
+{
+    int ret = 0;
+    if (!dbg || !dbg->ts_data) {
+        FTS_ERROR("fwdbg/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (!dbg->frame_logging) {
+        dbgq_release(&dbg->q);
+    }
+
+    if (dbg->regfa_val) {
+        vfree(dbg->regfa_val);
+        dbg->regfa_val = NULL;
+    }
+    if (dbg->regfb_val) {
+        vfree(dbg->regfb_val);
+        dbg->regfb_val = NULL;
+    }
+
+    dbg->ts_data->touch_size = dbg->touch_size_bak;
+    ret = fts_write_reg(FTS_REG_FW_DEBUG_EN, 0);
+    if (ret < 0) {
+        FTS_ERROR("write FwDebug to disable failed");
+    }
+    return ret;
+}
+
+static void fts_logging_frame(struct fwdbg_config *cfg, u8 *frame_buf, u64 timestamp)
+{
+    int i = 0;
+    int n = 0;
+    int index = 0;
+    char logbuf[512] = { 0 };
+    if (!cfg | !frame_buf)
+        return ;
+
+    FTS_DEBUG("logging a frame,timestamp=%lld", timestamp);
+    for (i = 0; i < cfg->dbgoff; i++) {
+        n += snprintf(logbuf + n, 512 - n, "%02x,", frame_buf[i]);
+        if (n >= 512) break;
+    }
+    FTS_DEBUG("%s", logbuf);
+
+    /**/
+    n = 0;
+    index = cfg->dbgoff;
+    for (i = 0; i < cfg->dbghdr_len; i++) {
+        n += snprintf(logbuf + n, 512 - n, "%02x,", frame_buf[index + i]);
+        if (n >= 512) break;
+    }
+    FTS_DEBUG("%s", logbuf);
+
+
+    index = cfg->dbgoff + cfg->dbghdr_len;
+    FTS_DEBUG("%d", frame_buf[index]);
+    n = 0;
+    index = cfg->dbgoff + cfg->dbghdr_len + 1;
+    for (i = 0; i < cfg->diff_len; i += 2) {
+        n += snprintf(logbuf + n, 512 - n, "%d,", (short)((frame_buf[index + i] << 8) + frame_buf[index + i + 1]));
+        if (n >= 512) break;
+        else if (((i + 1) % cfg->rx) == 0) {
+            FTS_DEBUG("%s", logbuf);
+            n = 0;
+        }
+    }
+
+    n = 0;
+    index = cfg->dbgoff + cfg->dbghdr_len + cfg->diff_len;
+    for (i = 0; i < cfg->addinfo_len; i += 2) {
+        n += snprintf(logbuf + n, 512 - n, "%d,", (short)((frame_buf[index + i] << 8) + frame_buf[index + i + 1]));
+        if (n >= 512) break;
+        else if (((i + 1) % cfg->rx) == 0) {
+            FTS_DEBUG("%s", logbuf);
+            n = 0;
+        }
+    }
+}
+
+static void fts_logging_regfb(struct fts_fwdbg *dbg, u64 timestamp)
+{
+    int ret = 0;
+    int i = 0;
+    int n = 0;
+    u8 cmd = 0xFB;
+    char logbuf[512] = { 0 };
+
+    if (!dbg || ! dbg->regfb_val || !dbg->cfg.regfb_len || !dbg->cfg.rx) {
+        FTS_ERROR("dbg/regfb_val/regfb_len(%d)/rx(%d) is invalid", dbg->cfg.regfb_len, dbg->cfg.rx);
+        return ;
+    }
+
+    ret = fts_read(&cmd, 1, dbg->regfb_val, dbg->cfg.regfb_len);
+    if (ret < 0) {
+        FTS_ERROR("read regfb failed,ret=%d", ret);
+        return ;
+    }
+
+    FTS_DEBUG("logging regfb,timestamp=%lld", timestamp);
+    for (i = 0; i < dbg->cfg.regfb_len; i += 2) {
+        n += snprintf(logbuf + n, 512 - n, "%d,", (short)((dbg->regfb_val[i] << 8) + dbg->regfb_val[i + 1]));
+        if (n >= 512) break;
+        else if (((i + 1) % dbg->cfg.rx) == 0) {
+            FTS_DEBUG("%s", logbuf);
+            n = 0;
+        }
+    }
+}
+
+static void fts_logging_regfa(struct fts_fwdbg *dbg, u64 timestamp)
+{
+    int ret = 0;
+    int i = 0;
+    int n = 0;
+    u8 cmd = 0xFA;
+    int line_count = 0;
+    char logbuf[512] = { 0 };
+
+    if (!dbg || ! dbg->regfa_val || !dbg->cfg.regfa_len || !dbg->cfg.rx) {
+        FTS_ERROR("dbg/regfa_val/regfa_len(%d)/rx(%d) is invalid", dbg->cfg.regfa_len, dbg->cfg.rx);
+        return ;
+    }
+
+    ret = fts_read(&cmd, 1, dbg->regfa_val, dbg->cfg.regfa_len);
+    if (ret < 0) {
+        FTS_ERROR("read regfa failed,ret=%d", ret);
+        return ;
+    }
+
+    FTS_DEBUG("logging regfa,timestamp=%lld", timestamp);
+    line_count = dbg->cfg.rx * 2;
+    for (i = 0; i < dbg->cfg.regfa_len; i++) {
+        n += snprintf(logbuf + n, 512 - n, "%02X,", dbg->regfa_val[i]);
+        if (n >= 512) break;
+        else if (((i + 1) % line_count) == 0) {
+            FTS_DEBUG("%s", logbuf);
+            n = 0;
+        }
+    }
+}
+
+
+int fts_fwdbg_readdata(struct fts_ts_data *ts_data, u8 *buf)
+{
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    u64 timestamp = 0;
+    if (!ts_data || !buf || !dbg) {
+        FTS_ERROR("ts_data/buf/dbg is null");
+        return -EINVAL;
+    }
+
+    if (!ts_data->fwdbg_support)
+        return 0;
+
+    timestamp = fwdbg_get_timestamp();
+    if (dbg->frame_logging) {
+        fts_logging_frame(&dbg->cfg, buf, timestamp);
+    } else if (!dbg->queue_stop) {
+        dbgq_enqueue(&dbg->q, buf, timestamp);
+        if (dbg->frame_waitq_flag == FRAME_WAITQ_WAIT) {
+            dbg->frame_waitq_flag = FRAME_WAITQ_WAKEUP;
+            wake_up_interruptible(&dbg->frame_waitq);
+        }
+    }
+
+    if (dbg->reg01_val == DEFAULT_VAL_REG01)
+        dbg->reg01_val = buf[0];
+    else if (buf[0] != dbg->reg01_val) {
+        if (!dbg->frame_logging) fts_logging_frame(&dbg->cfg, buf, timestamp);
+        if (dbg->cfg.regfb_len) fts_logging_regfb(dbg, timestamp);
+        dbg->reg01_val = buf[0];
+    }
+    return 0;
+}
+
+/* proc node:fts_fwdbg */
+static ssize_t fts_fwdbg_read(struct file *filp, char __user *buff, size_t count, loff_t *ppos)
+{
+    int read_byte_num = (int)count;
+    int cnt = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_fwdbg *dbg = pde_data(file_inode(filp));
+#else
+    struct fts_fwdbg *dbg = PDE_DATA(file_inode(filp));
+#endif
+    if (!dbg || !dbg->ts_data || !dbg->ts_data->fwdbg_support) {
+        FTS_ERROR("dbg/ts_data is null/fwdbg isn't support");
+        return -EINVAL;
+    }
+
+    if (dbg->frame_logging) {
+        FTS_ERROR("frame logging is null,not return frame data");
+        return -EINVAL;
+    }
+
+    if ((dbg->frame_block) && (read_byte_num < dbg->frame_size)) {
+        FTS_ERROR("in block mode, proc count(%d) < frame size(%d)", read_byte_num, dbg->frame_size);
+        return -EINVAL;
+    }
+
+    if (dbgq_empty(&dbg->q) && dbg->frame_block) {
+        dbg->queue_stop = false;
+        dbg->frame_waitq_flag = FRAME_WAITQ_WAIT;
+        wait_event_interruptible(dbg->frame_waitq, dbg->frame_waitq_flag == FRAME_WAITQ_WAKEUP);
+    }
+
+    if (read_byte_num >= dbg->frame_size)
+        cnt = dbgq_dequeue_to_proc(&dbg->q, buff, read_byte_num / dbg->frame_size);
+    else
+        cnt = proc_get_one_frame(dbg, buff, read_byte_num);
+
+    FTS_DEBUG("cnt=%d", cnt);
+    return cnt;
+}
+
+static int fts_fwdbg_open(struct inode *inode, struct file *file)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_fwdbg *dbg = pde_data(inode);
+#else
+    struct fts_fwdbg *dbg = PDE_DATA(inode);
+#endif
+    if (!dbg || !dbg->ts_data || !dbg->ts_data->fwdbg_support) {
+        FTS_ERROR("dbg/ts_data is null");
+        return -EINVAL;
+    }
+
+    FTS_DEBUG("frame,block=%d,logging=%d,size=%d,macount=%d,queuecount=%d", dbg->frame_block,
+              dbg->frame_logging, dbg->frame_size, dbg->max_frame_num, dbg->q.count);
+    if ((!dbg->frame_logging) && (dbg->q.elem_size != dbg->frame_size)) {
+        FTS_ERROR("elem_size(%d) != frame_size(%d)", dbg->q.elem_size, dbg->frame_size);
+        return -EINVAL;
+    }
+
+    dbg->proc_ppos = 0;
+    dbg->queue_stop = false;
+    if (!dbg->frame_block) {
+        dbg->queue_stop = true;
+        /* get fa/fb info */
+        if (dbg->cfg.regfb_len) fts_logging_regfb(dbg, fwdbg_get_timestamp());
+        if (dbg->cfg.regfa_len) fts_logging_regfa(dbg, fwdbg_get_timestamp());
+
+        if (dbg->proc_frame) {
+            vfree(dbg->proc_frame);
+            dbg->proc_frame = NULL;
+        }
+        dbg->proc_frame = vmalloc(dbg->frame_size);
+    }
+
+    return 0;
+}
+
+static int fts_fwdbg_release(struct inode *inode, struct file *file)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_fwdbg *dbg = pde_data(inode);
+#else
+    struct fts_fwdbg *dbg = PDE_DATA(inode);
+#endif
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return -EINVAL;
+    }
+
+    if (dbg->proc_frame) {
+        vfree(dbg->proc_frame);
+        dbg->proc_frame = NULL;
+    }
+    dbg->proc_ppos = 0;
+    dbg->queue_stop = false;
+    return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+static const struct proc_ops fts_fwdbg_fops = {
+    .proc_open = fts_fwdbg_open,
+    .proc_read = fts_fwdbg_read,
+    .proc_release = fts_fwdbg_release,
+};
+#else
+static const struct file_operations fts_fwdbg_fops = {
+    .open = fts_fwdbg_open,
+    .read = fts_fwdbg_read,
+    .release = fts_fwdbg_release,
+};
+#endif
+
+
+/* sysfs node:fts_fwdbg_mode */
+static ssize_t fts_fwdbg_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg || !ts_data) {
+        FTS_ERROR("dbg/ts_data is null");
+        return count;
+    }
+    mutex_lock(&dbg->mutex);
+    fts_read_reg(FTS_REG_FW_DEBUG_EN, &val);
+    count = snprintf(buf, PAGE_SIZE, "FwDebug support:%d,value:0x%x\n", ts_data->fwdbg_support, ts_data->fwdbg_value);
+    count += snprintf(buf + count, PAGE_SIZE, "Reg(0x9E)=0x%x\n", val);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+static ssize_t fts_fwdbg_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int n = 0;
+    int value = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg || !ts_data) {
+        FTS_ERROR("dbg/ts_data is null");
+        return count;
+    }
+
+    mutex_lock(&dbg->mutex);
+    n = sscanf(buf, "%d", &value);
+    if ((n == 1) && (!!value ^ ts_data->fwdbg_support)) {
+        if (value) {
+            if (0 == fts_fwdbg_enable(dbg, value)) {
+                ts_data->fwdbg_value = (u8)value;
+                ts_data->fwdbg_support = ENABLE;
+            }
+        } else {
+            ts_data->fwdbg_support = DISABLE;
+            fts_fwdbg_disable(dbg);
+        }
+    } else FTS_INFO("n(%d)!=/value(%d)==fwdbg_support(%d)", n, !!value, ts_data->fwdbg_support);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+/* sysfs node:fts_fwdbg_maxcount */
+static ssize_t fts_fwdbg_maxcount_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+    mutex_lock(&dbg->mutex);
+    count = snprintf(buf, PAGE_SIZE, "FwDebug,maximum frame count:%d\n", dbg->max_frame_num);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+static ssize_t fts_fwdbg_maxcount_store(
+    struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int n = 0;
+    int value = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg || !dbg->ts_data) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+
+    mutex_lock(&dbg->mutex);
+    n = sscanf(buf, "%d", &value);
+    if ((n == 1) && (value > 0) && !dbg->ts_data->fwdbg_support) {
+        FTS_INFO("maximum frame count: %d->%d", dbg->max_frame_num, value);
+        dbg->max_frame_num = value;
+    } else FTS_INFO("n(%d)!=1/value(%d)=0/fwdbg_support(%d)!=0", n, value, dbg->ts_data->fwdbg_support);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+/* sysfs node:fts_fwdbg_logging */
+static ssize_t fts_fwdbg_logging_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+    mutex_lock(&dbg->mutex);
+    count = snprintf(buf, PAGE_SIZE, "FwDebug,frame logging:%d\n", dbg->frame_logging);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+static ssize_t fts_fwdbg_logging_store(
+    struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int n = 0;
+    int value = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+
+    mutex_lock(&dbg->mutex);
+    n = sscanf(buf, "%d", &value);
+    if ((n == 1) && !dbg->ts_data->fwdbg_support) {
+        FTS_INFO("frame logging: %d->%d", dbg->frame_logging, !!value);
+        dbg->frame_logging = !!value;
+    } else FTS_INFO("n(%d)!=1/fwdbg_support(%d)!=0", n, dbg->ts_data->fwdbg_support);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+/* sysfs node:fts_fwdbg_block */
+static ssize_t fts_fwdbg_block_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+    mutex_lock(&dbg->mutex);
+    count = snprintf(buf, PAGE_SIZE, "frame block:%d\n", dbg->frame_block);
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+static ssize_t fts_fwdbg_block_store(
+    struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int n = 0;
+    int value = 0;
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (!dbg) {
+        FTS_ERROR("dbg is null");
+        return count;
+    }
+
+    mutex_lock(&dbg->mutex);
+    n = sscanf(buf, "%d", &value);
+    if (n == 1) {
+        FTS_INFO("frame block: %d->%d", dbg->frame_block, !!value);
+        dbg->frame_block = !!value;
+    }
+    mutex_unlock(&dbg->mutex);
+    return count;
+}
+
+static DEVICE_ATTR(fts_fwdbg_mode, S_IRUGO | S_IWUSR, fts_fwdbg_mode_show, fts_fwdbg_mode_store);
+static DEVICE_ATTR(fts_fwdbg_maxcount, S_IRUGO | S_IWUSR, fts_fwdbg_maxcount_show, fts_fwdbg_maxcount_store);
+static DEVICE_ATTR(fts_fwdbg_logging, S_IRUGO | S_IWUSR, fts_fwdbg_logging_show, fts_fwdbg_logging_store);
+static DEVICE_ATTR(fts_fwdbg_block, S_IRUGO | S_IWUSR, fts_fwdbg_block_show, fts_fwdbg_block_store);
+static struct attribute *fts_fwdbg_attrs[] = {
+    &dev_attr_fts_fwdbg_mode.attr,
+    &dev_attr_fts_fwdbg_maxcount.attr,
+    &dev_attr_fts_fwdbg_logging.attr,
+    &dev_attr_fts_fwdbg_block.attr,
+    NULL,
+};
+static struct attribute_group fts_fwdbg_group = {.attrs = fts_fwdbg_attrs,};
+
+static void fts_fwdbg_work_func(struct work_struct *work)
+{
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    struct fts_ts_data *ts_data = container_of(work, struct fts_ts_data, fwdbg_work.work);
+    if (ts_data && ts_data->fwdbg_support && dbg) {
+        if (dbg->cfg.regfb_len) {
+            fts_logging_regfb(dbg, fwdbg_get_timestamp());
+            fts_logging_regfb(dbg, fwdbg_get_timestamp());
+            fts_logging_regfb(dbg, fwdbg_get_timestamp());
+        }
+
+        if (dbg->cfg.regfa_len) fts_logging_regfa(dbg, fwdbg_get_timestamp());
+
+    }
+}
+
+void fts_fwdbg_handle_reset(struct fts_ts_data *ts_data)
+{
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    if (ts_data && ts_data->ts_workqueue && ts_data->fwdbg_support && dbg) {
+        dbg->reg01_val = DEFAULT_VAL_REG01;
+        if (dbg->cfg.regfb_len || dbg->cfg.regfa_len)
+            queue_delayed_work(ts_data->ts_workqueue, &ts_data->fwdbg_work, msecs_to_jiffies(200));
+    }
+}
+
+int fts_fwdbg_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fts_fwdbg *dbg = NULL;
+
+    FTS_FUNC_ENTER();
+    dbg = kzalloc(sizeof(struct fts_fwdbg), GFP_KERNEL);
+    if (!dbg) {
+        FTS_ERROR("allocate memory for fwdbg failed");
+        return -ENOMEM;
+    }
+    fts_fwdbg_data = dbg;
+    dbg->ts_data = ts_data;
+    dbg->max_frame_num = DEFAULT_MAX_FRAME_NUM;
+    dbg->frame_block = false;
+    dbg->frame_logging = false;
+    dbg->frame_waitq_flag = FRAME_WAITQ_DEFAULT;
+    dbg->reg01_val = DEFAULT_VAL_REG01;
+    mutex_init(&dbg->mutex);
+    mutex_init(&dbg->q.mutexq);
+    init_waitqueue_head(&dbg->frame_waitq);
+
+    dbg->proc_fwdbg = proc_create_data("fts_fwdbg", 0777, NULL, &fts_fwdbg_fops, dbg);
+    if (NULL == dbg->proc_fwdbg) {
+        FTS_ERROR("create proc_fwdbg entry failed");
+    }
+
+    ret = sysfs_create_group(&ts_data->dev->kobj, &fts_fwdbg_group);
+    if (ret) {
+        FTS_ERROR("create fwdebug sysfs node failed");
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_fwdbg_group);
+    }
+
+    if (ts_data->ts_workqueue) INIT_DELAYED_WORK(&ts_data->fwdbg_work, fts_fwdbg_work_func);
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_fwdbg_exit(struct fts_ts_data *ts_data)
+{
+    struct fts_fwdbg *dbg = fts_fwdbg_data;
+    FTS_FUNC_ENTER();
+    if (dbg) {
+        if (dbg->proc_fwdbg) proc_remove(dbg->proc_fwdbg);
+        if (dbg->regfa_val) {
+            vfree(dbg->regfa_val);
+            dbg->regfa_val = NULL;
+        }
+
+        if (dbg->regfb_val) {
+            vfree(dbg->regfb_val);
+            dbg->regfb_val = NULL;
+        }
+
+        if (dbg->q.buffer) {
+            vfree(dbg->q.buffer);
+            dbg->q.buffer = NULL;
+        }
+
+        if (dbg->proc_frame) {
+            vfree(dbg->proc_frame);
+            dbg->proc_frame = NULL;
+        }
+
+        kfree_safe(dbg);
+    }
+
+    if (ts_data) {
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_fwdbg_group);
+        cancel_delayed_work_sync(&ts_data->fwdbg_work);
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_esdcheck.c b/drivers/input/touchscreen/focaltech_touch/focaltech_esdcheck.c
new file mode 100755
index 000000000000..5394f0d1aa36
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_esdcheck.c
@@ -0,0 +1,442 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_esdcheck.c
+*
+*    Author: Focaltech Driver Team
+*
+*   Created: 2016-08-03
+*
+*  Abstract: ESD check function
+*
+*   Version: v1.0
+*
+* Revision History:
+*        v1.0:
+*            First release. By luougojin 2016-08-03
+*        v1.1: By luougojin 2017-02-15
+*            1. Add LCD_ESD_PATCH to control idc_esdcheck_lcderror
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define ESDCHECK_WAIT_TIME              1000    /* ms */
+#define LCD_ESD_PATCH                   0
+#define ESDCHECK_INTRCNT_MAX            2
+#define ESD_INTR_INTERVALS              200    /* unit:ms */
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+struct fts_esdcheck_st {
+    u8      mode                : 1;    /* 1- esd check is running 0- esd check is stop */
+    u8      suspend             : 1;
+    u8      proc_debug          : 1;    /* apk or adb use */
+    u8      intr                : 1;    /* 1- Interrupt trigger */
+    u8      unused              : 4;
+    u8      intr_cnt;
+    u8      flow_work_hold_cnt;         /* Flow Work Cnt(reg0x91) keep a same value for x times. >=5 times is ESD, need reset */
+    u8      flow_work_cnt_last;         /* Save Flow Work Cnt(reg0x91) value */
+    u32     hardware_reset_cnt;
+    u32     nack_cnt;
+    u32     dataerror_cnt;
+};
+
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+static struct fts_esdcheck_st fts_esdcheck_data;
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+
+/*****************************************************************************
+* functions body
+*****************************************************************************/
+#if LCD_ESD_PATCH
+int lcd_need_reset;
+static int tp_need_recovery; /* LCD reset cause Tp reset */
+int idc_esdcheck_lcderror(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    u8 val = 0;
+
+    FTS_DEBUG("check LCD ESD");
+    if ( (tp_need_recovery == 1) && (lcd_need_reset == 0) ) {
+        tp_need_recovery = 0;
+        /* LCD reset, need recover TP state */
+        fts_release_all_finger();
+        fts_tp_state_recovery(ts_data);
+    }
+
+    ret = fts_read_reg(FTS_REG_ESD_SATURATE, &val);
+    if ( ret < 0) {
+        FTS_ERROR("read reg0xED fail,ret:%d", ret);
+        return -EIO;
+    }
+
+    if (val == 0xAA) {
+        /*
+        * 1. Set flag lcd_need_reset = 1;
+        * 2. LCD driver need reset(recovery) LCD and set lcd_need_reset to 0
+        * 3. recover TP state
+        */
+        FTS_INFO("LCD ESD, need execute LCD reset");
+        lcd_need_reset = 1;
+        tp_need_recovery = 1;
+    }
+
+    return 0;
+}
+#endif
+
+static int fts_esdcheck_tp_reset(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+
+    fts_esdcheck_data.flow_work_hold_cnt = 0;
+    fts_esdcheck_data.hardware_reset_cnt++;
+
+    fts_reset_proc(ts_data, false, 200);
+    fts_release_all_finger();
+    fts_tp_state_recovery(ts_data);
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static bool get_chip_id(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    int i = 0;
+    u8 idh = 0;
+    u8 chip_id = ts_data->ic_info.ids.chip_idh;
+
+    for (i = 0; i < 3; i++) {
+        ret = fts_read_reg(FTS_REG_CHIP_ID, &idh);
+        if (ret < 0) {
+            FTS_ERROR("read chip id fail,ret:%d", ret);
+            fts_esdcheck_data.nack_cnt++;
+        } else {
+            if ((idh == chip_id) || (fts_check_cid(ts_data, idh) == 0)) {
+                break;
+            } else {
+                FTS_DEBUG("read chip_id:%x,retry:%d", idh, i);
+                fts_esdcheck_data.dataerror_cnt++;
+            }
+        }
+        fts_msleep(10);
+    }
+
+    /* if can't get correct data in 3 times, then need hardware reset */
+    if (i >= 3) {
+        FTS_ERROR("read chip id 3 times fail, need execute TP reset");
+        return true;
+    }
+
+    return false;
+}
+
+/*****************************************************************************
+*  Name: get_flow_cnt
+*  Brief: Read flow cnt(0x91)
+*  Input:
+*  Output:
+*  Return:  1(true) - Reg 0x91(flow cnt) abnormal: hold a value for 5 times
+*           0(false) - Reg 0x91(flow cnt) normal
+*****************************************************************************/
+static bool get_flow_cnt(struct fts_ts_data *ts_data)
+{
+    int     ret = 0;
+    u8      reg_value = 0;
+    u8      reg_addr = 0;
+
+    reg_addr = FTS_REG_FLOW_WORK_CNT;
+    ret = fts_read(&reg_addr, 1, &reg_value, 1);
+    if (ret < 0) {
+        FTS_ERROR("read reg0x91 fail,ret:%d", ret);
+        fts_esdcheck_data.nack_cnt++;
+    } else {
+        if ( reg_value == fts_esdcheck_data.flow_work_cnt_last ) {
+            FTS_DEBUG("reg0x91,val:%x,last:%x", reg_value,
+                      fts_esdcheck_data.flow_work_cnt_last);
+            fts_esdcheck_data.flow_work_hold_cnt++;
+        } else {
+            fts_esdcheck_data.flow_work_hold_cnt = 0;
+        }
+
+        fts_esdcheck_data.flow_work_cnt_last = reg_value;
+    }
+
+    /* Flow Work Cnt keep a value for 5 times, need execute TP reset */
+    if (fts_esdcheck_data.flow_work_hold_cnt >= 5) {
+        FTS_DEBUG("reg0x91 keep a value for 5 times, need execute TP reset");
+        return true;
+    }
+
+    return false;
+}
+
+static int esdcheck_algorithm(struct fts_ts_data *ts_data)
+{
+    int     ret = 0;
+    u8      reg_value = 0;
+    u8      reg_addr = 0;
+    bool    hardware_reset = 0;
+    unsigned long intr_timeout = msecs_to_jiffies(ESD_INTR_INTERVALS);
+
+    /* 1. esdcheck is interrupt, then return */
+    intr_timeout += ts_data->intr_jiffies;
+    if (time_before(jiffies, intr_timeout)) {
+        return 0;
+    }
+
+    /* 2. check power state, if suspend, no need check esd */
+    if (fts_esdcheck_data.suspend == 1) {
+        FTS_DEBUG("In suspend, not check esd");
+        /* because in suspend state, adb can be used, when upgrade FW, will
+         * active ESD check(active = 1); But in suspend, then will don't
+         * queue_delayed_work, when resume, don't check ESD again
+         */
+        return 0;
+    }
+
+    /* 3. check fts_esdcheck_data.proc_debug state, if 1-proc busy, no need check esd*/
+    if (fts_esdcheck_data.proc_debug == 1) {
+        FTS_INFO("In apk/adb command mode, not check esd");
+        return 0;
+    }
+
+    /* 4. In factory mode, can't check esd */
+    reg_addr = FTS_REG_WORKMODE;
+    ret = fts_read_reg(reg_addr, &reg_value);
+    if ( ret < 0 ) {
+        fts_esdcheck_data.nack_cnt++;
+    } else if ( (reg_value & 0x70) ==  FTS_REG_WORKMODE_FACTORY_VALUE) {
+        FTS_DEBUG("in factory mode(%x), no check esd", reg_value);
+        return 0;
+    }
+
+    /* 5. Get Chip ID */
+    hardware_reset = get_chip_id(ts_data);
+
+    /* 6. get Flow work cnt: 0x91 If no change for 5 times, then ESD and reset */
+    if (!hardware_reset) {
+        hardware_reset = get_flow_cnt(ts_data);
+    }
+
+    /* 7. If need hardware reset, then handle it here */
+    if (hardware_reset == 1) {
+        FTS_DEBUG("NoACK=%d, Error Data=%d, Hardware Reset=%d",
+                  fts_esdcheck_data.nack_cnt,
+                  fts_esdcheck_data.dataerror_cnt,
+                  fts_esdcheck_data.hardware_reset_cnt);
+        fts_esdcheck_tp_reset(ts_data);
+    }
+
+    return 0;
+}
+
+static void esdcheck_func(struct work_struct *work)
+{
+    struct fts_ts_data *ts_data = container_of(work,
+                                  struct fts_ts_data, esdcheck_work.work);
+
+    if (ts_data->esd_support) {
+#if LCD_ESD_PATCH
+        idc_esdcheck_lcderror(ts_data);
+#endif
+        esdcheck_algorithm(ts_data);
+        queue_delayed_work(ts_data->ts_workqueue, &ts_data->esdcheck_work,
+                           msecs_to_jiffies(ESDCHECK_WAIT_TIME));
+    }
+}
+
+/*****************************************************************************
+*  Name: fts_esdcheck_proc_busy
+*  Brief: When APK or ADB command access TP via driver, then need set proc_debug,
+*         then will not check ESD.
+*  Input:
+*  Output:
+*  Return:
+*****************************************************************************/
+void fts_esdcheck_proc_busy(struct fts_ts_data *ts_data, bool proc_debug)
+{
+    if (ts_data->esd_support) {
+        fts_esdcheck_data.proc_debug = proc_debug;
+    }
+}
+
+/*****************************************************************************
+*  Name: fts_esdcheck_switch
+*  Brief: FTS esd check function switch.
+*  Input:   enable:  1 - Enable esd check
+*                    0 - Disable esd check
+*  Output:
+*  Return:
+*****************************************************************************/
+void fts_esdcheck_switch(struct fts_ts_data *ts_data, bool enable)
+{
+    if (ts_data->esd_support) {
+        if (fts_esdcheck_data.mode ^ enable) {
+            if (enable) {
+                FTS_INFO("ESD check start");
+                fts_esdcheck_data.flow_work_hold_cnt = 0;
+                fts_esdcheck_data.flow_work_cnt_last = 0;
+                fts_esdcheck_data.intr = 0;
+                fts_esdcheck_data.intr_cnt = 0;
+                fts_esdcheck_data.mode = ENABLE;
+                queue_delayed_work(ts_data->ts_workqueue,
+                                   &ts_data->esdcheck_work,
+                                   msecs_to_jiffies(ESDCHECK_WAIT_TIME));
+            } else {
+                FTS_INFO("ESD check stop");
+                cancel_delayed_work_sync(&ts_data->esdcheck_work);
+                fts_esdcheck_data.mode = DISABLE;
+            }
+        }
+    }
+}
+
+void fts_esdcheck_suspend(struct fts_ts_data *ts_data)
+{
+    if (ts_data->esd_support) {
+        FTS_FUNC_ENTER();
+        fts_esdcheck_switch(ts_data, DISABLE);
+        fts_esdcheck_data.suspend = 1;
+        fts_esdcheck_data.intr = 0;
+        fts_esdcheck_data.intr_cnt = 0;
+        FTS_FUNC_EXIT();
+    }
+}
+
+void fts_esdcheck_resume(struct fts_ts_data *ts_data)
+{
+    if (ts_data->esd_support) {
+        FTS_FUNC_ENTER();
+        fts_esdcheck_switch(ts_data, ENABLE);
+        fts_esdcheck_data.suspend = 0;
+        fts_esdcheck_data.intr = 0;
+        fts_esdcheck_data.intr_cnt = 0;
+        FTS_FUNC_EXIT();
+    }
+}
+
+static ssize_t fts_esdcheck_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_INFO("enable esdcheck");
+        ts_data->esd_support = ENABLE;
+        if (!ts_data->suspended) fts_esdcheck_switch(ts_data, ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_INFO("disable esdcheck");
+        fts_esdcheck_switch(ts_data, DISABLE);
+        ts_data->esd_support = DISABLE;
+    }
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_esdcheck_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count = snprintf(buf, PAGE_SIZE, "Esd check: %s\n", \
+                     ts_data->esd_support ? "On" : "Off");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+/* sysfs esd node
+ *   read example: cat  fts_esd_mode        ---read esd mode
+ *   write example:echo 01 > fts_esd_mode   ---make esdcheck enable
+ *
+ */
+static DEVICE_ATTR (fts_esd_mode, S_IRUGO | S_IWUSR, fts_esdcheck_show, fts_esdcheck_store);
+
+static struct attribute *fts_esd_mode_attrs[] = {
+
+    &dev_attr_fts_esd_mode.attr,
+    NULL,
+};
+
+static struct attribute_group fts_esdcheck_group = {
+    .attrs = fts_esd_mode_attrs,
+};
+
+bool fts_esdcheck_is_running(struct fts_ts_data *ts_data)
+{
+    return fts_esdcheck_data.mode;
+}
+
+int fts_esdcheck_init(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+
+    if (ts_data->ts_workqueue) {
+        INIT_DELAYED_WORK(&ts_data->esdcheck_work, esdcheck_func);
+    } else {
+        FTS_ERROR("fts workqueue is NULL, can't run esd check function");
+        return -EINVAL;
+    }
+
+    memset((u8 *)&fts_esdcheck_data, 0, sizeof(struct fts_esdcheck_st));
+    fts_esdcheck_data.mode = DISABLE;
+    ts_data->esd_support = FTS_ESDCHECK_EN;
+    if (sysfs_create_group(&ts_data->dev->kobj, &fts_esdcheck_group)) {
+        FTS_ERROR("fts_create_esd_sysfs(sysfs) create fail");
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_esdcheck_group);
+    }
+    fts_esdcheck_switch(ts_data, ENABLE);
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_esdcheck_exit(struct fts_ts_data *ts_data)
+{
+    fts_esdcheck_data.mode = DISABLE;
+    ts_data->esd_support = DISABLE;
+    cancel_delayed_work_sync(&ts_data->esdcheck_work);
+    sysfs_remove_group(&ts_data->dev->kobj, &fts_esdcheck_group);
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_ex_fun.c b/drivers/input/touchscreen/focaltech_touch/focaltech_ex_fun.c
new file mode 100755
index 000000000000..224a34ea3341
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_ex_fun.c
@@ -0,0 +1,1269 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: Focaltech_ex_fun.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define PROC_UPGRADE                            0
+#define PROC_READ_REGISTER                      1
+#define PROC_WRITE_REGISTER                     2
+#define PROC_AUTOCLB                            4
+#define PROC_UPGRADE_INFO                       5
+#define PROC_WRITE_DATA                         6
+#define PROC_READ_DATA                          7
+#define PROC_SET_TEST_FLAG                      8
+#define PROC_SET_SLAVE_ADDR                     10
+#define PROC_HW_RESET                           11
+#define PROC_READ_STATUS                        12
+#define PROC_SET_BOOT_MODE                      13
+#define PROC_ENTER_TEST_ENVIRONMENT             14
+#define PROC_WRITE_DATA_DIRECT                  16
+#define PROC_READ_DATA_DIRECT                   17
+#define PROC_CONFIGURE                          18
+#define PROC_CONFIGURE_INTR                     20
+#define PROC_GET_DRIVER_INFO                    21
+#define PROC_NAME                               "ftxxxx-debug"
+#define PROC_BUF_SIZE                           256
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+enum {
+    RWREG_OP_READ = 0,
+    RWREG_OP_WRITE = 1,
+};
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+static struct rwreg_operation_t {
+    int type;           /*  0: read, 1: write */
+    int reg;            /*  register */
+    int len;            /*  read/write length */
+    int val;            /*  length = 1; read: return value, write: op return */
+    int res;            /*  0: success, otherwise: fail */
+    char *opbuf;        /*  length >= 1, read return value, write: op return */
+} rw_op;
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+static ssize_t fts_debug_write(
+    struct file *filp, const char __user *buff, size_t count, loff_t *ppos)
+{
+    u8 *writebuf = NULL;
+    u8 tmpbuf[PROC_BUF_SIZE] = { 0 };
+    int buflen = count;
+    int writelen = 0;
+    int ret = 0;
+    char tmp[PROC_BUF_SIZE];
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_ts_data *ts_data = pde_data(file_inode(filp));
+#else
+    struct fts_ts_data *ts_data = PDE_DATA(file_inode(filp));
+#endif
+    struct ftxxxx_proc *proc = &ts_data->proc;
+
+    if (buflen < 1) {
+        FTS_ERROR("apk proc count(%d) fail", buflen);
+        return -EINVAL;
+    }
+
+    if (buflen > PROC_BUF_SIZE) {
+        writebuf = (u8 *)kzalloc(buflen * sizeof(u8), GFP_KERNEL);
+        if (NULL == writebuf) {
+            FTS_ERROR("apk proc wirte buf zalloc fail");
+            return -ENOMEM;
+        }
+    } else {
+        writebuf = tmpbuf;
+    }
+
+    if (copy_from_user(writebuf, buff, buflen)) {
+        FTS_ERROR("[APK]: copy from user error!!");
+        ret = -EFAULT;
+        goto proc_write_err;
+    }
+
+    proc->opmode = writebuf[0];
+    if (buflen == 1) {
+        ret = buflen;
+        goto proc_write_err;
+    }
+
+    switch (proc->opmode) {
+    case PROC_SET_TEST_FLAG:
+        FTS_DEBUG("[APK]: PROC_SET_TEST_FLAG = %x", writebuf[1]);
+        if (writebuf[1] == 0) {
+            if (!ts_data->suspended) fts_esdcheck_switch(ts_data, ENABLE);
+        } else {
+            fts_esdcheck_switch(ts_data, DISABLE);
+        }
+        break;
+
+    case PROC_READ_REGISTER:
+        proc->cmd[0] = writebuf[1];
+        break;
+
+    case PROC_WRITE_REGISTER:
+        ret = fts_write_reg(writebuf[1], writebuf[2]);
+        if (ret < 0) {
+            FTS_ERROR("PROC_WRITE_REGISTER write error");
+            goto proc_write_err;
+        }
+        break;
+
+    case PROC_READ_DATA:
+        writelen = buflen - 1;
+        if (writelen >= FTS_MAX_COMMMAND_LENGTH) {
+            FTS_ERROR("cmd(PROC_READ_DATA) length(%d) fail", writelen);
+            goto proc_write_err;
+        }
+        memcpy(proc->cmd, writebuf + 1, writelen);
+        proc->cmd_len = writelen;
+        if (ts_data->bus_type == BUS_TYPE_I2C) {
+            ret = fts_write(writebuf + 1, writelen);
+            if (ret < 0) {
+                FTS_ERROR("PROC_READ_DATA write error");
+                goto proc_write_err;
+            }
+        }
+        break;
+
+    case PROC_WRITE_DATA:
+        writelen = buflen - 1;
+        ret = fts_write(writebuf + 1, writelen);
+        if (ret < 0) {
+            FTS_ERROR("PROC_WRITE_DATA write error");
+            goto proc_write_err;
+        }
+        break;
+
+    case PROC_SET_SLAVE_ADDR:
+        if (ts_data->bus_type == BUS_TYPE_I2C) {
+            fts_bus_configure(ts_data, &writebuf[1], buflen - 1);
+        }
+        break;
+
+    case PROC_HW_RESET:
+        if (buflen < PROC_BUF_SIZE) {
+            memcpy(tmp, writebuf + 1, buflen - 1);
+            tmp[buflen - 1] = '\0';
+            if (strncmp(tmp, "focal_driver", 12) == 0) {
+                FTS_INFO("APK execute HW Reset");
+                fts_reset_proc(ts_data, false, 0);
+            }
+        }
+        break;
+
+    case PROC_SET_BOOT_MODE:
+        FTS_DEBUG("[APK]: PROC_SET_BOOT_MODE = %x", writebuf[1]);
+        if (0 == writebuf[1]) {
+            ts_data->fw_is_running = true;
+        } else {
+            ts_data->fw_is_running = false;
+        }
+        break;
+
+    case PROC_ENTER_TEST_ENVIRONMENT:
+        FTS_DEBUG("[APK]: PROC_ENTER_TEST_ENVIRONMENT = %x", writebuf[1]);
+        if (0 == writebuf[1]) {
+            fts_enter_test_environment(0);
+        } else {
+            fts_enter_test_environment(1);
+        }
+        break;
+
+    case PROC_READ_DATA_DIRECT:
+        writelen = buflen - 1;
+        if (writelen >= FTS_MAX_COMMMAND_LENGTH) {
+            FTS_ERROR("cmd(PROC_READ_DATA_DIRECT) length(%d) fail", writelen);
+            goto proc_write_err;
+        }
+        memcpy(proc->cmd, writebuf + 1, writelen);
+        proc->cmd_len = writelen;
+        break;
+
+    case PROC_WRITE_DATA_DIRECT:
+        writelen = buflen - 1;
+        ret = fts_bus_transfer_direct(writebuf + 1, writelen, NULL, 0);
+        if (ret < 0) {
+            FTS_ERROR("PROC_WRITE_DATA_DIRECT write error");
+            goto proc_write_err;
+        }
+        break;
+
+    case PROC_CONFIGURE:
+        if (ts_data->bus_type == BUS_TYPE_SPI) {
+            fts_bus_configure(ts_data, &writebuf[1], buflen - 1);
+        }
+        break;
+
+    case PROC_CONFIGURE_INTR:
+        if (writebuf[1] == 0)
+            fts_irq_disable();
+        else
+            fts_irq_enable();
+        break;
+
+    default:
+        break;
+    }
+
+    ret = buflen;
+proc_write_err:
+    if ((buflen > PROC_BUF_SIZE) && writebuf) {
+        kfree(writebuf);
+        writebuf = NULL;
+    }
+    return ret;
+}
+
+static ssize_t fts_debug_read(
+    struct file *filp, char __user *buff, size_t count, loff_t *ppos)
+{
+    int ret = 0;
+    int num_read_chars = 0;
+    int buflen = count;
+    u8 *readbuf = NULL;
+    u8 tmpbuf[PROC_BUF_SIZE] = { 0 };
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_ts_data *ts_data = pde_data(file_inode(filp));
+#else
+    struct fts_ts_data *ts_data = PDE_DATA(file_inode(filp));
+#endif
+    struct ftxxxx_proc *proc = &ts_data->proc;
+
+    if (buflen <= 0) {
+        FTS_ERROR("apk proc read count(%d) fail", buflen);
+        return -EINVAL;
+    }
+
+    if (buflen > PROC_BUF_SIZE) {
+        readbuf = (u8 *)kzalloc(buflen * sizeof(u8), GFP_KERNEL);
+        if (NULL == readbuf) {
+            FTS_ERROR("apk proc buf zalloc fail");
+            return -ENOMEM;
+        }
+    } else {
+        readbuf = tmpbuf;
+    }
+
+    switch (proc->opmode) {
+    case PROC_READ_REGISTER:
+        num_read_chars = 1;
+        ret = fts_read_reg(proc->cmd[0], &readbuf[0]);
+        if (ret < 0) {
+            FTS_ERROR("PROC_READ_REGISTER read error");
+            goto proc_read_err;
+        }
+        break;
+
+    case PROC_READ_DATA:
+        num_read_chars = buflen;
+        if (ts_data->bus_type == BUS_TYPE_SPI)
+            ret = fts_read(proc->cmd, proc->cmd_len, readbuf, num_read_chars);
+        else if (ts_data->bus_type == BUS_TYPE_I2C)
+            ret = fts_read(NULL, 0, readbuf, num_read_chars);
+        else FTS_ERROR("unknown bus type:%d", ts_data->bus_type);
+        if (ret < 0) {
+            FTS_ERROR("PROC_READ_DATA read error");
+            goto proc_read_err;
+        }
+        break;
+
+    case PROC_READ_DATA_DIRECT:
+        num_read_chars = buflen;
+        ret = fts_bus_transfer_direct(proc->cmd, proc->cmd_len, readbuf, num_read_chars);
+        if (ret < 0) {
+            FTS_ERROR("PROC_READ_DATA_DIRECT read error");
+            goto proc_read_err;
+        }
+        break;
+
+    case PROC_GET_DRIVER_INFO:
+        if (buflen >= 64) {
+            num_read_chars = buflen;
+            readbuf[0] = ts_data->bus_type;
+            snprintf(&readbuf[32], buflen - 32, "%s", FTS_DRIVER_VERSION);
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    ret = num_read_chars;
+proc_read_err:
+    if ((num_read_chars > 0) && copy_to_user(buff, readbuf, num_read_chars)) {
+        FTS_ERROR("copy to user error");
+        ret = -EFAULT;
+    }
+
+    if ((buflen > PROC_BUF_SIZE) && readbuf) {
+        kfree(readbuf);
+        readbuf = NULL;
+    }
+    return ret;
+}
+
+/*/proc/fts_ta*/
+static int fts_ta_open(struct inode *inode, struct file *file)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_ts_data *ts_data = pde_data(inode);
+#else
+    struct fts_ts_data *ts_data = PDE_DATA(inode);
+#endif
+
+    if (ts_data->touch_analysis_support) {
+        FTS_INFO("fts_ta open");
+        ts_data->ta_buf = kzalloc(FTS_MAX_TOUCH_BUF, GFP_KERNEL);
+        if (!ts_data->ta_buf) {
+            FTS_ERROR("kzalloc for ta_buf fails");
+            return -ENOMEM;
+        }
+    }
+    return 0;
+}
+
+static int fts_ta_release(struct inode *inode, struct file *file)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_ts_data *ts_data = pde_data(inode);
+#else
+    struct fts_ts_data *ts_data = PDE_DATA(inode);
+#endif
+
+    if (ts_data->touch_analysis_support) {
+        FTS_INFO("fts_ta close");
+        ts_data->ta_flag = 0;
+        if (ts_data->ta_buf) {
+            kfree(ts_data->ta_buf);
+            ts_data->ta_buf = NULL;
+        }
+    }
+    return 0;
+}
+
+static ssize_t fts_ta_read(
+    struct file *filp, char __user *buff, size_t count, loff_t *ppos)
+{
+    int read_num = (int)count;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0))
+    struct fts_ts_data *ts_data = pde_data(file_inode(filp));
+#else
+    struct fts_ts_data *ts_data = PDE_DATA(file_inode(filp));
+#endif
+
+    if (!ts_data->touch_analysis_support || !ts_data->ta_buf) {
+        FTS_ERROR("touch_analysis is disabled, or ta_buf is NULL");
+        return -EINVAL;
+    }
+
+    if (!(filp->f_flags & O_NONBLOCK)) {
+        ts_data->ta_flag = 1;
+        wait_event_interruptible(ts_data->ts_waitqueue, !ts_data->ta_flag);
+    }
+
+    read_num = (ts_data->ta_size < read_num) ? ts_data->ta_size : read_num;
+    if ((read_num > 0) && (copy_to_user(buff, ts_data->ta_buf, read_num))) {
+        FTS_ERROR("copy to user error");
+        return -EFAULT;
+    }
+
+    return read_num;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+static const struct proc_ops fts_proc_fops = {
+    .proc_read   = fts_debug_read,
+    .proc_write  = fts_debug_write,
+};
+
+static const struct proc_ops fts_procta_fops = {
+    .proc_open = fts_ta_open,
+    .proc_release = fts_ta_release,
+    .proc_read = fts_ta_read,
+};
+#else
+static const struct file_operations fts_proc_fops = {
+    .owner  = THIS_MODULE,
+    .read   = fts_debug_read,
+    .write  = fts_debug_write,
+};
+
+static const struct file_operations fts_procta_fops = {
+    .open = fts_ta_open,
+    .release = fts_ta_release,
+    .read = fts_ta_read,
+};
+#endif
+
+int fts_create_apk_debug_channel(struct fts_ts_data *ts_data)
+{
+    struct ftxxxx_proc *proc = &ts_data->proc;
+    proc->proc_entry = proc_create_data(PROC_NAME, 0777, NULL, &fts_proc_fops, ts_data);
+    if (NULL == proc->proc_entry) {
+        FTS_ERROR("create proc entry fail");
+        return -ENOMEM;
+    }
+
+    ts_data->proc_ta.proc_entry = proc_create_data("fts_ta", 0777, NULL, \
+                                  &fts_procta_fops, ts_data);
+    if (!ts_data->proc_ta.proc_entry) {
+        FTS_ERROR("create proc_ta entry fail");
+        return -ENOMEM;
+    }
+
+    FTS_INFO("Create proc entry success!");
+    return 0;
+}
+
+void fts_release_apk_debug_channel(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    if (ts_data->proc.proc_entry)
+        proc_remove(ts_data->proc.proc_entry);
+    if (ts_data->proc_ta.proc_entry)
+        proc_remove(ts_data->proc_ta.proc_entry);
+    FTS_FUNC_EXIT();
+}
+
+/************************************************************************
+ * sysfs interface
+ ***********************************************************************/
+/* fts_hw_reset interface */
+static ssize_t fts_hw_reset_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+    ssize_t count = 0;
+
+    mutex_lock(&input_dev->mutex);
+    fts_reset_proc(ts_data, false, 0);
+    count = snprintf(buf, PAGE_SIZE, "hw reset executed\n");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_hw_reset_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+/* fts_irq interface */
+static ssize_t fts_irq_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    ssize_t count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct irq_desc *desc = irq_to_desc(ts_data->irq);
+
+    count = snprintf(buf, PAGE_SIZE, "irq_depth:%d\n", desc->depth);
+
+    return count;
+}
+
+static ssize_t fts_irq_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_INFO("enable irq");
+        fts_irq_enable();
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_INFO("disable irq");
+        fts_irq_disable();
+    }
+    mutex_unlock(&input_dev->mutex);
+    return count;
+}
+
+/* fts_boot_mode interface */
+static ssize_t fts_bootmode_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_INFO("[EX-FUN]set to boot mode");
+        ts_data->fw_is_running = false;
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_INFO("[EX-FUN]set to fw mode");
+        ts_data->fw_is_running = true;
+    }
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+static ssize_t fts_bootmode_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    ssize_t count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    if (true == ts_data->fw_is_running) {
+        count = snprintf(buf, PAGE_SIZE, "tp is in fw mode\n");
+    } else {
+        count = snprintf(buf, PAGE_SIZE, "tp is in boot mode\n");
+    }
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+/* fts_tpfwver interface */
+static ssize_t fts_tpfwver_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int ret = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+    ssize_t num_read_chars = 0;
+    u8 fwver = 0;
+
+    mutex_lock(&input_dev->mutex);
+
+    ret = fts_read_reg(FTS_REG_FW_VER, &fwver);
+    if ((ret < 0) || (fwver == 0xFF) || (fwver == 0x00))
+        num_read_chars = snprintf(buf, PAGE_SIZE, "get tp fw version fail!\n");
+    else
+        num_read_chars = snprintf(buf, PAGE_SIZE, "%02x\n", fwver);
+
+    mutex_unlock(&input_dev->mutex);
+    return num_read_chars;
+}
+
+static ssize_t fts_tpfwver_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+/* fts_rw_reg */
+static ssize_t fts_tprwreg_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count;
+    int i;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+
+    if (rw_op.len < 0) {
+        count = snprintf(buf, PAGE_SIZE, "Invalid cmd line\n");
+    } else if (rw_op.len == 1) {
+        if (RWREG_OP_READ == rw_op.type) {
+            if (rw_op.res == 0) {
+                count = snprintf(buf, PAGE_SIZE, "Read %02X: %02X\n", rw_op.reg, rw_op.val);
+            } else {
+                count = snprintf(buf, PAGE_SIZE, "Read %02X failed, ret: %d\n", rw_op.reg,  rw_op.res);
+            }
+        } else {
+            if (rw_op.res == 0) {
+                count = snprintf(buf, PAGE_SIZE, "Write %02X, %02X success\n", rw_op.reg,  rw_op.val);
+            } else {
+                count = snprintf(buf, PAGE_SIZE, "Write %02X failed, ret: %d\n", rw_op.reg,  rw_op.res);
+            }
+        }
+    } else {
+        if (RWREG_OP_READ == rw_op.type) {
+            count = snprintf(buf, PAGE_SIZE, "Read Reg: [%02X]-[%02X]\n", rw_op.reg, rw_op.reg + rw_op.len);
+            count += snprintf(buf + count, PAGE_SIZE, "Result: ");
+            if (rw_op.res) {
+                count += snprintf(buf + count, PAGE_SIZE, "failed, ret: %d\n", rw_op.res);
+            } else {
+                if (rw_op.opbuf) {
+                    for (i = 0; i < rw_op.len; i++) {
+                        count += snprintf(buf + count, PAGE_SIZE, "%02X ", rw_op.opbuf[i]);
+                    }
+                    count += snprintf(buf + count, PAGE_SIZE, "\n");
+                }
+            }
+        } else {
+            ;
+            count = snprintf(buf, PAGE_SIZE, "Write Reg: [%02X]-[%02X]\n", rw_op.reg, rw_op.reg + rw_op.len - 1);
+            count += snprintf(buf + count, PAGE_SIZE, "Write Data: ");
+            if (rw_op.opbuf) {
+                for (i = 1; i < rw_op.len; i++) {
+                    count += snprintf(buf + count, PAGE_SIZE, "%02X ", rw_op.opbuf[i]);
+                }
+                count += snprintf(buf + count, PAGE_SIZE, "\n");
+            }
+            if (rw_op.res) {
+                count += snprintf(buf + count, PAGE_SIZE, "Result: failed, ret: %d\n", rw_op.res);
+            } else {
+                count += snprintf(buf + count, PAGE_SIZE, "Result: success\n");
+            }
+        }
+        /*if (rw_op.opbuf) {
+            kfree(rw_op.opbuf);
+            rw_op.opbuf = NULL;
+        }*/
+    }
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static int shex_to_int(const char *hex_buf, int size)
+{
+    int i;
+    int base = 1;
+    int value = 0;
+    char single;
+
+    for (i = size - 1; i >= 0; i--) {
+        single = hex_buf[i];
+
+        if ((single >= '0') && (single <= '9')) {
+            value += (single - '0') * base;
+        } else if ((single >= 'a') && (single <= 'z')) {
+            value += (single - 'a' + 10) * base;
+        } else if ((single >= 'A') && (single <= 'Z')) {
+            value += (single - 'A' + 10) * base;
+        } else {
+            return -EINVAL;
+        }
+
+        base *= 16;
+    }
+
+    return value;
+}
+
+
+static u8 shex_to_u8(const char *hex_buf, int size)
+{
+    return (u8)shex_to_int(hex_buf, size);
+}
+/*
+ * Format buf:
+ * [0]: '0' write, '1' read(reserved)
+ * [1-2]: addr, hex
+ * [3-4]: length, hex
+ * [5-6]...[n-(n+1)]: data, hex
+ */
+static int fts_parse_buf(const char *buf, size_t cmd_len)
+{
+    int length;
+    int i;
+    char *tmpbuf;
+
+    rw_op.reg = shex_to_u8(buf + 1, 2);
+    length = shex_to_int(buf + 3, 2);
+
+    if (buf[0] == '1') {
+        rw_op.len = length;
+        rw_op.type = RWREG_OP_READ;
+        FTS_DEBUG("read %02X, %d bytes", rw_op.reg, rw_op.len);
+    } else {
+        if (cmd_len < (length * 2 + 5)) {
+            pr_err("data invalided!\n");
+            return -EINVAL;
+        }
+        FTS_DEBUG("write %02X, %d bytes", rw_op.reg, length);
+
+        /* first byte is the register addr */
+        rw_op.type = RWREG_OP_WRITE;
+        rw_op.len = length + 1;
+    }
+
+    if (rw_op.len > 0) {
+        tmpbuf = (char *)kzalloc(rw_op.len, GFP_KERNEL);
+        if (!tmpbuf) {
+            FTS_ERROR("allocate memory failed!\n");
+            return -ENOMEM;
+        }
+
+        if (RWREG_OP_WRITE == rw_op.type) {
+            tmpbuf[0] = rw_op.reg & 0xFF;
+            FTS_DEBUG("write buffer: ");
+            for (i = 1; i < rw_op.len; i++) {
+                tmpbuf[i] = shex_to_u8(buf + 5 + i * 2 - 2, 2);
+                FTS_DEBUG("buf[%d]: %02X", i, tmpbuf[i] & 0xFF);
+            }
+        }
+        rw_op.opbuf = tmpbuf;
+    }
+
+    return rw_op.len;
+}
+
+static ssize_t fts_tprwreg_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+    ssize_t cmd_length = 0;
+
+    mutex_lock(&input_dev->mutex);
+    cmd_length = count - 1; //remove "\n"
+
+    if (rw_op.opbuf) {
+        kfree(rw_op.opbuf);
+        rw_op.opbuf = NULL;
+    }
+
+    FTS_DEBUG("cmd len: %d, buf: %s", (int)cmd_length, buf);
+    /* compatible old ops */
+    if (2 == cmd_length) {
+        rw_op.type = RWREG_OP_READ;
+        rw_op.len = 1;
+        rw_op.reg = shex_to_int(buf, 2);
+    } else if (4 == cmd_length) {
+        rw_op.type = RWREG_OP_WRITE;
+        rw_op.len = 1;
+        rw_op.reg = shex_to_int(buf, 2);
+        rw_op.val = shex_to_int(buf + 2, 2);
+    } else if (cmd_length < 5) {
+        FTS_ERROR("Invalid cmd buffer");
+        mutex_unlock(&input_dev->mutex);
+        return -EINVAL;
+    } else {
+        rw_op.len = fts_parse_buf(buf, cmd_length);
+    }
+
+    if (rw_op.len < 0) {
+        FTS_ERROR("cmd buffer error!");
+
+    } else {
+        if (RWREG_OP_READ == rw_op.type) {
+            if (rw_op.len == 1) {
+                u8 reg, val;
+                reg = rw_op.reg & 0xFF;
+                rw_op.res = fts_read_reg(reg, &val);
+                rw_op.val = val;
+            } else {
+                char reg;
+                reg = rw_op.reg & 0xFF;
+
+                rw_op.res = fts_read(&reg, 1, rw_op.opbuf, rw_op.len);
+            }
+
+            if (rw_op.res < 0) {
+                FTS_ERROR("Could not read 0x%02x", rw_op.reg);
+            } else {
+                FTS_INFO("read 0x%02x, %d bytes successful", rw_op.reg, rw_op.len);
+                rw_op.res = 0;
+            }
+
+        } else {
+            if (rw_op.len == 1) {
+                u8 reg, val;
+                reg = rw_op.reg & 0xFF;
+                val = rw_op.val & 0xFF;
+                rw_op.res = fts_write_reg(reg, val);
+            } else {
+                rw_op.res = fts_write(rw_op.opbuf, rw_op.len);
+            }
+            if (rw_op.res < 0) {
+                FTS_ERROR("Could not write 0x%02x", rw_op.reg);
+
+            } else {
+                FTS_INFO("Write 0x%02x, %d bytes successful", rw_op.val, rw_op.len);
+                rw_op.res = 0;
+            }
+        }
+    }
+
+    mutex_unlock(&input_dev->mutex);
+    return count;
+}
+
+/* fts_upgrade_bin interface */
+static ssize_t fts_fwupgradebin_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return -EPERM;
+}
+
+static ssize_t fts_fwupgradebin_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    if ((count <= 1) || (count >= FILE_NAME_LENGTH - 32)) {
+        FTS_ERROR("fw bin name's length(%d) fail", (int)count);
+        return -EINVAL;
+    }
+    memset(fwname, 0, sizeof(fwname));
+    snprintf(fwname, FILE_NAME_LENGTH, "%s", buf);
+    fwname[count - 1] = '\0';
+
+    FTS_INFO("upgrade with bin file through sysfs node");
+    mutex_lock(&input_dev->mutex);
+    fts_upgrade_bin(fwname, 0);
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+/* fts_force_upgrade interface */
+static ssize_t fts_fwforceupg_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return -EPERM;
+}
+
+static ssize_t fts_fwforceupg_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    char fwname[FILE_NAME_LENGTH];
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    if ((count <= 1) || (count >= FILE_NAME_LENGTH - 32)) {
+        FTS_ERROR("fw bin name's length(%d) fail", (int)count);
+        return -EINVAL;
+    }
+    memset(fwname, 0, sizeof(fwname));
+    snprintf(fwname, FILE_NAME_LENGTH, "%s", buf);
+    fwname[count - 1] = '\0';
+
+    FTS_INFO("force upgrade through sysfs node");
+    mutex_lock(&input_dev->mutex);
+    fts_upgrade_bin(fwname, 1);
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+/* fts_driver_info interface */
+static ssize_t fts_driverinfo_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct fts_ts_platform_data *pdata = ts_data->pdata;
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "Driver Ver:%s\n",
+                      FTS_DRIVER_VERSION);
+
+    count += snprintf(buf + count, PAGE_SIZE, "Resolution:(%d,%d)~(%d,%d)\n",
+                      pdata->x_min, pdata->y_min, pdata->x_max, pdata->y_max);
+
+    count += snprintf(buf + count, PAGE_SIZE, "Max Touchs:%d\n",
+                      pdata->max_touch_number);
+
+    count += snprintf(buf + count, PAGE_SIZE,
+                      "reset gpio:%d,int gpio:%d,irq:%d\n",
+                      pdata->reset_gpio, pdata->irq_gpio, ts_data->irq);
+
+    count += snprintf(buf + count, PAGE_SIZE, "IC ID:0x%02x%02x\n",
+                      ts_data->ic_info.ids.chip_idh,
+                      ts_data->ic_info.ids.chip_idl);
+    mutex_unlock(&input_dev->mutex);
+    return count;
+}
+
+static ssize_t fts_driverinfo_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+/* fts_dump_reg interface */
+static ssize_t fts_dumpreg_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+
+    fts_read_reg(FTS_REG_POWER_MODE, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "Power Mode:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_FW_VER, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "FW Ver:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_LIC_VER, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "LCD Initcode Ver:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_IDE_PARA_VER_ID, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "Param Ver:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_IDE_PARA_STATUS, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "Param status:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_VENDOR_ID, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "Vendor ID:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_GESTURE_EN, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "Gesture Mode:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_CHARGER_MODE_EN, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "charge stat:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_INT_CNT, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "INT count:0x%02x\n", val);
+
+    fts_read_reg(FTS_REG_FLOW_WORK_CNT, &val);
+    count += snprintf(buf + count, PAGE_SIZE, "ESD count:0x%02x\n", val);
+
+    mutex_unlock(&input_dev->mutex);
+    return count;
+}
+
+static ssize_t fts_dumpreg_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+/* fts_dump_reg interface */
+static ssize_t fts_tpbuf_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "touch point buffer:\n");
+    for (i = 0; i < FTS_TOUCH_DATA_LEN; i++) {
+        count += snprintf(buf + count, PAGE_SIZE, "%02x ", ts_data->touch_buf[i]);
+    }
+    count += snprintf(buf + count, PAGE_SIZE, "\n");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_tpbuf_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+/* fts_log_level node */
+static ssize_t fts_log_level_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "log level:%d\n",
+                      ts_data->log_level);
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_log_level_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    sscanf(buf, "%d", &value);
+    FTS_DEBUG("log level:%d->%d", ts_data->log_level, value);
+    ts_data->log_level = value;
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+/* fts_pen node */
+static ssize_t fts_pen_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "pen event:%s\n",
+                      ts_data->pen_etype ? "hover" : "default");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_pen_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    sscanf(buf, "%d", &value);
+    FTS_DEBUG("pen event:%d->%d", ts_data->pen_etype, value);
+    ts_data->pen_etype = value;
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+/* fts_touch_size node */
+static ssize_t fts_touchsize_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "touch size:%d\n", ts_data->touch_size);
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_touchsize_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    sscanf(buf, "%d", &value);
+    if ((value > 2) && (value < FTS_MAX_TOUCH_BUF)) {
+        FTS_DEBUG("touch size:%d->%d", ts_data->touch_size, value);
+        ts_data->touch_size = value;
+    } else
+        FTS_DEBUG("touch size:%d invalid", value);
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+/* fts_ta_mode node */
+static ssize_t fts_tamode_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count += snprintf(buf + count, PAGE_SIZE, "touch analysis:%s\n", \
+                      ts_data->touch_analysis_support ? "Enable" : "Disable");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_tamode_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&input_dev->mutex);
+    sscanf(buf, "%d", &value);
+    ts_data->touch_analysis_support = !!value;
+    FTS_DEBUG("set touch analysis:%d", ts_data->touch_analysis_support);
+    mutex_unlock(&input_dev->mutex);
+    FTS_FUNC_EXIT();
+
+    return count;
+}
+
+#if FTS_FOD_EN
+/* fts_fod_mode node */
+static ssize_t fts_fod_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(FTS_REG_FOD_MODE_EN, &val);
+    count = snprintf(buf, PAGE_SIZE, "FOD Mode:%s\n", ts_data->fod_mode ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Reg(0xCF)=%d\n", val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_fod_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        fts_fod_enable(ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        fts_fod_enable(DISABLE);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+#endif
+
+/* get the fw version  example:cat fw_version */
+static DEVICE_ATTR(fts_fw_version, S_IRUGO | S_IWUSR, fts_tpfwver_show, fts_tpfwver_store);
+
+/* read and write register(s)
+*   All data type is **HEX**
+*   Single Byte:
+*       read:   echo 88 > rw_reg ---read register 0x88
+*       write:  echo 8807 > rw_reg ---write 0x07 into register 0x88
+*   Multi-bytes:
+*       [0:rw-flag][1-2: reg addr, hex][3-4: length, hex][5-6...n-n+1: write data, hex]
+*       rw-flag: 0, write; 1, read
+*       read:  echo 10005           > rw_reg ---read reg 0x00-0x05
+*       write: echo 000050102030405 > rw_reg ---write reg 0x00-0x05 as 01,02,03,04,05
+*  Get result:
+*       cat rw_reg
+*/
+static DEVICE_ATTR(fts_rw_reg, S_IRUGO | S_IWUSR, fts_tprwreg_show, fts_tprwreg_store);
+/*  upgrade from fw bin file   example:echo "*.bin" > fts_upgrade_bin */
+static DEVICE_ATTR(fts_upgrade_bin, S_IRUGO | S_IWUSR, fts_fwupgradebin_show, fts_fwupgradebin_store);
+static DEVICE_ATTR(fts_force_upgrade, S_IRUGO | S_IWUSR, fts_fwforceupg_show, fts_fwforceupg_store);
+static DEVICE_ATTR(fts_driver_info, S_IRUGO | S_IWUSR, fts_driverinfo_show, fts_driverinfo_store);
+static DEVICE_ATTR(fts_dump_reg, S_IRUGO | S_IWUSR, fts_dumpreg_show, fts_dumpreg_store);
+static DEVICE_ATTR(fts_hw_reset, S_IRUGO | S_IWUSR, fts_hw_reset_show, fts_hw_reset_store);
+static DEVICE_ATTR(fts_irq, S_IRUGO | S_IWUSR, fts_irq_show, fts_irq_store);
+static DEVICE_ATTR(fts_boot_mode, S_IRUGO | S_IWUSR, fts_bootmode_show, fts_bootmode_store);
+static DEVICE_ATTR(fts_touch_point, S_IRUGO | S_IWUSR, fts_tpbuf_show, fts_tpbuf_store);
+static DEVICE_ATTR(fts_log_level, S_IRUGO | S_IWUSR, fts_log_level_show, fts_log_level_store);
+static DEVICE_ATTR(fts_pen, S_IRUGO | S_IWUSR, fts_pen_show, fts_pen_store);
+static DEVICE_ATTR(fts_touch_size, S_IRUGO | S_IWUSR, fts_touchsize_show, fts_touchsize_store);
+static DEVICE_ATTR(fts_ta_mode, S_IRUGO | S_IWUSR, fts_tamode_show, fts_tamode_store);
+#if FTS_FOD_EN
+static DEVICE_ATTR(fts_fod_mode, S_IRUGO | S_IWUSR, fts_fod_show, fts_fod_store);
+#endif
+
+/* add your attr in here*/
+static struct attribute *fts_attributes[] = {
+    &dev_attr_fts_fw_version.attr,
+    &dev_attr_fts_rw_reg.attr,
+    &dev_attr_fts_dump_reg.attr,
+    &dev_attr_fts_upgrade_bin.attr,
+    &dev_attr_fts_force_upgrade.attr,
+    &dev_attr_fts_driver_info.attr,
+    &dev_attr_fts_hw_reset.attr,
+    &dev_attr_fts_irq.attr,
+    &dev_attr_fts_boot_mode.attr,
+    &dev_attr_fts_touch_point.attr,
+    &dev_attr_fts_log_level.attr,
+    &dev_attr_fts_pen.attr,
+    &dev_attr_fts_touch_size.attr,
+    &dev_attr_fts_ta_mode.attr,
+#if FTS_FOD_EN
+    &dev_attr_fts_fod_mode.attr,
+#endif
+    NULL
+};
+
+static struct attribute_group fts_attribute_group = {
+    .attrs = fts_attributes
+};
+
+int fts_create_sysfs(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    ret = sysfs_create_group(&ts_data->dev->kobj, &fts_attribute_group);
+    if (ret) {
+        FTS_ERROR("[EX]: sysfs_create_group() failed!!");
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_attribute_group);
+        return -ENOMEM;
+    } else {
+        FTS_INFO("[EX]: sysfs_create_group() succeeded!!");
+    }
+
+    return ret;
+}
+
+int fts_remove_sysfs(struct fts_ts_data *ts_data)
+{
+    sysfs_remove_group(&ts_data->dev->kobj, &fts_attribute_group);
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_ex_mode.c b/drivers/input/touchscreen/focaltech_touch/focaltech_ex_mode.c
new file mode 100755
index 000000000000..1abd6e1dd1fc
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_ex_mode.c
@@ -0,0 +1,390 @@
+/*
+ *
+ * FocalTech ftxxxx TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_ex_mode.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-31
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* 2.Private constant and macro definitions using #define
+*****************************************************************************/
+
+/*****************************************************************************
+* 3.Private enumerations, structures and unions using typedef
+*****************************************************************************/
+enum _ex_mode {
+    MODE_GLOVE = 0,
+    MODE_COVER,
+    MODE_CHARGER,
+    MODE_EARPHONE,
+    MODE_EDGEPALM
+};
+
+/*****************************************************************************
+* 4.Static variables
+*****************************************************************************/
+
+/*****************************************************************************
+* 5.Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* 6.Static function prototypes
+*******************************************************************************/
+static int fts_ex_mode_set_reg(u8 mode_regaddr, u8 mode_regval)
+{
+    int i = 0;
+    u8 val = 0xFF;
+
+    for (i = 0; i < FTS_MAX_RETRIES_WRITEREG; i++) {
+        fts_read_reg(mode_regaddr, &val);
+        if (val == mode_regval)
+            break;
+        fts_write_reg(mode_regaddr, mode_regval);
+        fts_msleep(1);
+    }
+
+    if (i >= FTS_MAX_RETRIES_WRITEREG) {
+        FTS_ERROR("set mode(%x) to %x failed,read val:%x", mode_regaddr, mode_regval, val);
+        return -EIO;
+    } else if (i > 0) {
+        FTS_INFO("set mode(%x) to %x successfully", mode_regaddr, mode_regval);
+    }
+    return 0;
+}
+
+static int fts_ex_mode_switch(enum _ex_mode mode, int value)
+{
+    int ret = 0;
+
+    switch (mode) {
+    case MODE_GLOVE:
+        ret = fts_ex_mode_set_reg(FTS_REG_GLOVE_MODE_EN, (value ? 0x01 : 0x00));
+        if (ret) FTS_ERROR("Set MODE_GLOVE to %d failed", value);
+        break;
+    case MODE_COVER:
+        ret = fts_ex_mode_set_reg(FTS_REG_COVER_MODE_EN, (value ? 0x01 : 0x00));
+        if (ret) FTS_ERROR("Set MODE_COVER to %d failed", value);
+        break;
+    case MODE_CHARGER:
+        ret = fts_ex_mode_set_reg(FTS_REG_CHARGER_MODE_EN, (value ? 0x01 : 0x00));
+        if (ret) FTS_ERROR("Set MODE_CHARGER to %d failed", value);
+        break;
+    case MODE_EARPHONE:
+        ret = fts_ex_mode_set_reg(FTS_REG_EARPHONE_MODE_EN, (value ? 0x01 : 0x00));
+        if (ret) FTS_ERROR("Set MODE_EARPHONE to %d failed", value);
+        break;
+    case MODE_EDGEPALM:
+        /* FW defines the following values: 0:vertical, 1:horizontal, USB on the right,
+         *                                  2:horizontal, USB on the left
+         * If host set the value not defined above, you should have a transition.
+         */
+        ret = fts_ex_mode_set_reg(FTS_REG_EDGEPALM_MODE_EN, (u8)value);
+        if (ret) FTS_ERROR("Set MODE_EDGEPALM to %d failed", value);
+        break;
+    default:
+        FTS_ERROR("mode(%d) unsupport", mode);
+        ret = -EINVAL;
+        break;
+    }
+
+    return ret;
+}
+
+static ssize_t fts_glove_mode_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 reg_addr = FTS_REG_GLOVE_MODE_EN;
+    u8 reg_val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(reg_addr, &reg_val);
+    count = snprintf(buf + count, PAGE_SIZE, "Glove Mode:%s\n",
+                     ts_data->glove_mode ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Glove Reg:0x%02x,val:%d\n", reg_addr, reg_val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_glove_mode_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enter glove mode");
+        ts_data->glove_mode = ENABLE;
+        fts_ex_mode_switch(MODE_GLOVE, ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("exit glove mode");
+        ts_data->glove_mode = DISABLE;
+        fts_ex_mode_switch(MODE_GLOVE, DISABLE);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+    return count;
+}
+
+
+static ssize_t fts_cover_mode_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 reg_addr = FTS_REG_COVER_MODE_EN;
+    u8 reg_val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(reg_addr, &reg_val);
+    count = snprintf(buf + count, PAGE_SIZE, "Cover Mode:%s\n",
+                     ts_data->cover_mode ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Cover Reg:0x%02x,val:%d\n", reg_addr, reg_val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_cover_mode_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enter cover mode");
+        ts_data->cover_mode = ENABLE;
+        fts_ex_mode_switch(MODE_COVER, ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("exit cover mode");
+        ts_data->cover_mode = DISABLE;
+        fts_ex_mode_switch(MODE_COVER, DISABLE);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+    return count;
+}
+
+static ssize_t fts_charger_mode_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 reg_addr = FTS_REG_CHARGER_MODE_EN;
+    u8 reg_val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(reg_addr, &reg_val);
+    count = snprintf(buf + count, PAGE_SIZE, "Charger Mode:%s\n",
+                     ts_data->charger_mode ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Charger Reg:0x%02x,val:%d\n", reg_addr, reg_val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_charger_mode_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enter charger mode");
+        ts_data->charger_mode = ENABLE;
+        fts_ex_mode_switch(MODE_CHARGER, ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("exit charger mode");
+        ts_data->charger_mode = DISABLE;
+        fts_ex_mode_switch(MODE_CHARGER, DISABLE);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+    return count;
+}
+
+/* sysfs node: fts_earphone_mode */
+static ssize_t fts_earphone_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 reg_addr = FTS_REG_EARPHONE_MODE_EN;
+    u8 reg_val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(reg_addr, &reg_val);
+    count = snprintf(buf + count, PAGE_SIZE, "Earphone Mode:%s\n",
+                     ts_data->earphone_mode ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Earphone Reg:0x%02x,val:%d\n", reg_addr, reg_val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_earphone_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enter earphone mode");
+        ts_data->earphone_mode = ENABLE;
+        fts_ex_mode_switch(MODE_EARPHONE, ENABLE);
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("exit earphone mode");
+        ts_data->earphone_mode = DISABLE;
+        fts_ex_mode_switch(MODE_EARPHONE, DISABLE);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+    return count;
+}
+
+/* sysfs node: fts_edgepalm_mode */
+static ssize_t fts_edgepalm_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 reg_addr = FTS_REG_EDGEPALM_MODE_EN;
+    u8 reg_val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(reg_addr, &reg_val);
+    count = snprintf(buf + count, PAGE_SIZE, "Edgepalm Mode:%s,value:%d\n",
+                     ts_data->edgepalm_mode ? "On" : "Off", ts_data->edgepalm_value);
+    count += snprintf(buf + count, PAGE_SIZE, "Edgepalm Reg:0x%02x,val:%d\n", reg_addr, reg_val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_edgepalm_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    int value = 0;
+    int n = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    n = sscanf(buf, "%d", &value);
+    if (n == 1) {
+        ts_data->edgepalm_value = value;
+        ts_data->edgepalm_mode = !!value;
+        fts_ex_mode_switch(MODE_EDGEPALM, value);
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+    return count;
+}
+
+
+/* read and write charger mode
+ * read example: cat fts_glove_mode        ---read  glove mode
+ * write example:echo 1 > fts_glove_mode   ---write glove mode to 01
+ */
+static DEVICE_ATTR(fts_glove_mode, S_IRUGO | S_IWUSR, fts_glove_mode_show, fts_glove_mode_store);
+static DEVICE_ATTR(fts_cover_mode, S_IRUGO | S_IWUSR, fts_cover_mode_show, fts_cover_mode_store);
+static DEVICE_ATTR(fts_charger_mode, S_IRUGO | S_IWUSR, fts_charger_mode_show, fts_charger_mode_store);
+static DEVICE_ATTR(fts_earphone_mode, S_IRUGO | S_IWUSR, fts_earphone_show, fts_earphone_store);
+static DEVICE_ATTR(fts_edgepalm_mode, S_IRUGO | S_IWUSR, fts_edgepalm_show, fts_edgepalm_store);
+
+static struct attribute *fts_touch_mode_attrs[] = {
+    &dev_attr_fts_glove_mode.attr,
+    &dev_attr_fts_cover_mode.attr,
+    &dev_attr_fts_charger_mode.attr,
+    &dev_attr_fts_earphone_mode.attr,
+    &dev_attr_fts_edgepalm_mode.attr,
+    NULL,
+};
+
+static struct attribute_group fts_touch_mode_group = {
+    .attrs = fts_touch_mode_attrs,
+};
+
+int fts_ex_mode_recovery(struct fts_ts_data *ts_data)
+{
+    if (ts_data->glove_mode) {
+        fts_ex_mode_switch(MODE_GLOVE, ENABLE);
+    }
+
+    if (ts_data->cover_mode) {
+        fts_ex_mode_switch(MODE_COVER, ENABLE);
+    }
+
+    if (ts_data->charger_mode) {
+        fts_ex_mode_switch(MODE_CHARGER, ENABLE);
+    }
+
+    if (ts_data->earphone_mode) {
+        fts_ex_mode_switch(MODE_EARPHONE, ENABLE);
+    }
+
+    if (ts_data->edgepalm_mode) {
+        fts_ex_mode_switch(MODE_EDGEPALM, ts_data->edgepalm_value);
+    }
+
+    return 0;
+}
+
+int fts_ex_mode_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    ts_data->glove_mode = DISABLE;
+    ts_data->cover_mode = DISABLE;
+    ts_data->charger_mode = DISABLE;
+    ts_data->earphone_mode = DISABLE;
+    ts_data->edgepalm_mode = DISABLE;
+
+    ret = sysfs_create_group(&ts_data->dev->kobj, &fts_touch_mode_group);
+    if (ret < 0) {
+        FTS_ERROR("create sysfs(ex_mode) fail");
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_touch_mode_group);
+        return ret;
+    } else {
+        FTS_DEBUG("create sysfs(ex_mode) successfully");
+    }
+
+    return 0;
+}
+
+int fts_ex_mode_exit(struct fts_ts_data *ts_data)
+{
+    sysfs_remove_group(&ts_data->dev->kobj, &fts_touch_mode_group);
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_flash.c b/drivers/input/touchscreen/focaltech_touch/focaltech_flash.c
new file mode 100755
index 000000000000..3b3e74066e02
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_flash.c
@@ -0,0 +1,2273 @@
+/*
+ *
+ * FocalTech fts TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_flash.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+#include "focaltech_flash.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_FW_REQUEST_SUPPORT                      1
+/* Example: focaltech_ts_fw_tianma.bin */
+#define FTS_FW_NAME_PREX_WITH_REQUEST               "focaltech_ts_fw_"
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+u8 fw_file[] = {
+#include FTS_UPGRADE_FW_FILE
+};
+
+u8 fw_file2[] = {
+#include FTS_UPGRADE_FW2_FILE
+};
+
+u8 fw_file3[] = {
+#include FTS_UPGRADE_FW3_FILE
+};
+
+struct upgrade_module module_list[] = {
+    {FTS_MODULE_ID, FTS_MODULE_NAME, fw_file, sizeof(fw_file)},
+    {FTS_MODULE2_ID, FTS_MODULE2_NAME, fw_file2, sizeof(fw_file2)},
+    {FTS_MODULE3_ID, FTS_MODULE3_NAME, fw_file3, sizeof(fw_file3)},
+};
+
+struct upgrade_func *upgrade_func_list[] = {
+    &upgrade_func_ft8205p,
+};
+
+struct fts_upgrade *fwupgrade;
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+static bool fts_fwupg_check_state(
+    struct fts_upgrade *upg, enum FW_STATUS rstate);
+
+/************************************************************************
+* Name: fts_fwupg_get_boot_state
+* Brief: read boot id(rom/pram/bootloader), confirm boot environment
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+static int fts_fwupg_get_boot_state(
+    struct fts_upgrade *upg,
+    enum FW_STATUS *fw_sts)
+{
+    int ret = 0;
+    u8 cmd[4] = { 0 };
+    u32 cmd_len = 0;
+    u8 val[2] = { 0 };
+    struct ft_chip_t *ids = NULL;
+
+    FTS_INFO("**********read boot id**********");
+    if ((!upg) || (!upg->func) || (!upg->ts_data) || (!fw_sts)) {
+        FTS_ERROR("upg/func/ts_data/fw_sts is null");
+        return -EINVAL;
+    }
+
+    if (upg->func->hid_supported)
+        fts_hid2std(0);
+
+    cmd[0] = FTS_CMD_START1;
+    cmd[1] = FTS_CMD_START2;
+    if (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)
+        cmd_len = 1;
+    else
+        cmd_len = 2;
+    ret = fts_write(cmd, cmd_len);
+    if (ret < 0) {
+        FTS_ERROR("write 55 cmd fail");
+        return ret;
+    }
+
+    fts_msleep(FTS_CMD_START_DELAY);
+    cmd[0] = FTS_CMD_READ_ID;
+    cmd[1] = cmd[2] = cmd[3] = 0x00;
+    if (upg->ts_data->ic_info.is_incell ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0))
+        cmd_len = FTS_CMD_READ_ID_LEN_INCELL;
+    else
+        cmd_len = FTS_CMD_READ_ID_LEN;
+    ret = fts_read(cmd, cmd_len, val, 2);
+    if (ret < 0) {
+        FTS_ERROR("write 90 cmd fail");
+        return ret;
+    }
+    FTS_INFO("read boot id:0x%02x%02x", val[0], val[1]);
+
+    ids = &upg->ts_data->ic_info.ids;
+    if ((val[0] == ids->rom_idh) && (val[1] == ids->rom_idl)) {
+        FTS_INFO("tp run in romboot");
+        *fw_sts = FTS_RUN_IN_ROM;
+    } else if ((val[0] == ids->pb_idh) && (val[1] == ids->pb_idl)) {
+        FTS_INFO("tp run in pramboot");
+        *fw_sts = FTS_RUN_IN_PRAM;
+    } else if ((val[0] == ids->bl_idh) && (val[1] == ids->bl_idl)) {
+        FTS_INFO("tp run in bootloader");
+        *fw_sts = FTS_RUN_IN_BOOTLOADER;
+    }
+
+    return 0;
+}
+
+static int fts_fwupg_reset_to_boot(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    u8 reg = FTS_REG_UPGRADE;
+
+    FTS_INFO("send 0xAA and 0x55 to FW, reset to boot environment");
+    if (upg && upg->func && upg->func->is_reset_register_BC) {
+        reg = FTS_REG_UPGRADE2;
+    }
+
+    ret = fts_write_reg(reg, FTS_UPGRADE_AA);
+    if (ret < 0) {
+        FTS_ERROR("write FC=0xAA fail");
+        return ret;
+    }
+    fts_msleep(FTS_DELAY_UPGRADE_AA);
+
+    ret = fts_write_reg(reg, FTS_UPGRADE_55);
+    if (ret < 0) {
+        FTS_ERROR("write FC=0x55 fail");
+        return ret;
+    }
+
+    fts_msleep(FTS_DELAY_UPGRADE_RESET);
+    return 0;
+}
+
+/************************************************************************
+* Name: fts_fwupg_reset_to_romboot
+* Brief: reset to romboot, to load pramboot
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+static int fts_fwupg_reset_to_romboot(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    int i = 0;
+    u8 cmd = FTS_CMD_RESET;
+    enum FW_STATUS state = FTS_RUN_IN_ERROR;
+
+    ret = fts_write(&cmd, 1);
+    if (ret < 0) {
+        FTS_ERROR("pram/rom/bootloader reset cmd write fail");
+        return ret;
+    }
+    mdelay(10);
+
+    for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+        ret = fts_fwupg_get_boot_state(upg, &state);
+        if (FTS_RUN_IN_ROM == state)
+            break;
+        fts_msleep(5);
+    }
+    if (i >= FTS_UPGRADE_LOOP) {
+        FTS_ERROR("reset to romboot fail");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static u16 fts_crc16_calc_host(u8 *pbuf, u32 length)
+{
+    u16 ecc = 0;
+    u32 i = 0;
+    u32 j = 0;
+
+    for ( i = 0; i < length; i += 2 ) {
+        ecc ^= ((pbuf[i] << 8) | (pbuf[i + 1]));
+        for (j = 0; j < 16; j ++) {
+            if (ecc & 0x01)
+                ecc = (u16)((ecc >> 1) ^ AL2_FCS_COEF);
+            else
+                ecc >>= 1;
+        }
+    }
+
+    return ecc;
+}
+
+static u16 fts_pram_ecc_calc_host(u8 *pbuf, u32 length)
+{
+    return fts_crc16_calc_host(pbuf, length);
+}
+
+static int fts_pram_ecc_cal_algo(
+    struct fts_upgrade *upg,
+    u32 start_addr,
+    u32 ecc_length)
+{
+    int ret = 0;
+    int i = 0;
+    int ecc = 0;
+    u8 val[2] = { 0 };
+    u8 tmp = 0;
+    u8 cmd[FTS_ROMBOOT_CMD_ECC_NEW_LEN] = { 0 };
+
+    FTS_INFO("read out pramboot checksum");
+    if ((!upg) || (!upg->func)) {
+        FTS_ERROR("upg/func is null");
+        return -EINVAL;
+    }
+
+    cmd[0] = FTS_ROMBOOT_CMD_ECC;
+    cmd[1] = BYTE_OFF_16(start_addr);
+    cmd[2] = BYTE_OFF_8(start_addr);
+    cmd[3] = BYTE_OFF_0(start_addr);
+    cmd[4] = BYTE_OFF_16(ecc_length);
+    cmd[5] = BYTE_OFF_8(ecc_length);
+    cmd[6] = BYTE_OFF_0(ecc_length);
+    ret = fts_write(cmd, FTS_ROMBOOT_CMD_ECC_NEW_LEN);
+    if (ret < 0) {
+        FTS_ERROR("write pramboot ecc cal cmd fail");
+        return ret;
+    }
+
+    cmd[0] = FTS_ROMBOOT_CMD_ECC_FINISH;
+    for (i = 0; i < FTS_ECC_FINISH_TIMEOUT; i++) {
+        fts_msleep(1);
+        ret = fts_read(cmd, 1, val, 1);
+        if (ret < 0) {
+            FTS_ERROR("ecc_finish read cmd fail");
+            return ret;
+        }
+        if (upg->func->new_return_value_from_ic ||
+            (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+            tmp = FTS_ROMBOOT_CMD_ECC_FINISH_OK_A5;
+        } else {
+            tmp = FTS_ROMBOOT_CMD_ECC_FINISH_OK_00;
+        }
+        if (tmp == val[0])
+            break;
+    }
+    if (i >= FTS_ECC_FINISH_TIMEOUT) {
+        FTS_ERROR("wait ecc finish fail");
+        return -EIO;
+    }
+
+    cmd[0] = FTS_ROMBOOT_CMD_ECC_READ;
+    ret = fts_read(cmd, 1, val, 2);
+    if (ret < 0) {
+        FTS_ERROR("read pramboot ecc fail");
+        return ret;
+    }
+
+    ecc = ((u16)(val[0] << 8) + val[1]) & 0x0000FFFF;
+    return ecc;
+}
+
+static int fts_pram_ecc_cal_xor(void)
+{
+    int ret = 0;
+    u8 reg_val = 0;
+
+    FTS_INFO("read out pramboot checksum");
+
+    ret = fts_read_reg(FTS_ROMBOOT_CMD_ECC, &reg_val);
+    if (ret < 0) {
+        FTS_ERROR("read pramboot ecc fail");
+        return ret;
+    }
+
+    return (int)reg_val;
+}
+
+static int fts_pram_ecc_cal(struct fts_upgrade *upg, u32 saddr, u32 len)
+{
+    if ((!upg) || (!upg->func)) {
+        FTS_ERROR("upg/func is null");
+        return -EINVAL;
+    }
+
+    if ((ECC_CHECK_MODE_CRC16 == upg->func->pram_ecc_check_mode) ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+        return fts_pram_ecc_cal_algo(upg, saddr, len);
+    } else {
+        return fts_pram_ecc_cal_xor();
+    }
+}
+
+static int fts_pram_write_buf(struct fts_upgrade *upg, u8 *buf, u32 len)
+{
+    int ret = 0;
+    u32 i = 0;
+    u32 j = 0;
+    u32 offset = 0;
+    u32 remainder = 0;
+    u32 packet_number;
+    u32 packet_len = 0;
+    u8 packet_buf[FTS_FLASH_PACKET_LENGTH + FTS_CMD_WRITE_LEN] = { 0 };
+    u8 ecc_tmp = 0;
+    int ecc_in_host = 0;
+    u32 cmdlen = 0;
+
+    FTS_INFO("write pramboot to pram");
+    if ((!upg) || (!upg->func) || !buf) {
+        FTS_ERROR("upg/func/buf is null");
+        return -EINVAL;
+    }
+
+    FTS_INFO("pramboot len=%d", len);
+    if ((len < PRAMBOOT_MIN_SIZE) || (len > PRAMBOOT_MAX_SIZE)) {
+        FTS_ERROR("pramboot length(%d) fail", len);
+        return -EINVAL;
+    }
+
+    packet_number = len / FTS_FLASH_PACKET_LENGTH;
+    remainder = len % FTS_FLASH_PACKET_LENGTH;
+    if (remainder > 0)
+        packet_number++;
+    packet_len = FTS_FLASH_PACKET_LENGTH;
+
+    for (i = 0; i < packet_number; i++) {
+        offset = i * FTS_FLASH_PACKET_LENGTH;
+        /* last packet */
+        if ((i == (packet_number - 1)) && remainder)
+            packet_len = remainder;
+
+        if ((upg->ts_data->bus_type == BUS_TYPE_SPI) && (upg->ts_data->bus_ver == BUS_VER_V2)) {
+            packet_buf[0] = FTS_ROMBOOT_CMD_SET_PRAM_ADDR;
+            packet_buf[1] = BYTE_OFF_16(offset);
+            packet_buf[2] = BYTE_OFF_8(offset);
+            packet_buf[3] = BYTE_OFF_0(offset);
+
+            ret = fts_write(packet_buf, FTS_ROMBOOT_CMD_SET_PRAM_ADDR_LEN);
+            if (ret < 0) {
+                FTS_ERROR("pramboot set write address(%d) fail", i);
+                return ret;
+            }
+
+            packet_buf[0] = FTS_ROMBOOT_CMD_WRITE;
+            cmdlen = 1;
+        } else {
+            packet_buf[0] = FTS_ROMBOOT_CMD_WRITE;
+            packet_buf[1] = BYTE_OFF_16(offset);
+            packet_buf[2] = BYTE_OFF_8(offset);
+            packet_buf[3] = BYTE_OFF_0(offset);
+
+            packet_buf[4] = BYTE_OFF_8(packet_len);
+            packet_buf[5] = BYTE_OFF_0(packet_len);
+            cmdlen = 6;
+        }
+
+        for (j = 0; j < packet_len; j++) {
+            packet_buf[cmdlen + j] = buf[offset + j];
+            if (ECC_CHECK_MODE_XOR == upg->func->pram_ecc_check_mode) {
+                ecc_tmp ^= packet_buf[cmdlen + j];
+            }
+        }
+
+        ret = fts_write(packet_buf, packet_len + cmdlen);
+        if (ret < 0) {
+            FTS_ERROR("pramboot write data(%d) fail", i);
+            return ret;
+        }
+    }
+
+    if ((ECC_CHECK_MODE_CRC16 == upg->func->pram_ecc_check_mode) ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+        ecc_in_host = (int)fts_pram_ecc_calc_host(buf, len);
+    } else {
+        ecc_in_host = (int)ecc_tmp;
+    }
+
+    return ecc_in_host;
+}
+
+static int fts_pram_start(void)
+{
+    u8 cmd = FTS_ROMBOOT_CMD_START_APP;
+    int ret = 0;
+
+    FTS_INFO("remap to start pramboot");
+
+    ret = fts_write(&cmd, 1);
+    if (ret < 0) {
+        FTS_ERROR("write start pram cmd fail");
+        return ret;
+    }
+    fts_msleep(FTS_DELAY_PRAMBOOT_START);
+
+    return 0;
+}
+
+static int fts_pram_write_remap(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    int ecc_in_host = 0;
+    int ecc_in_tp = 0;
+    u8 *pb_buf = NULL;
+    u32 pb_len = 0;
+
+    FTS_INFO("write pram and remap");
+    if (!upg || !upg->func || !upg->func->pramboot) {
+        FTS_ERROR("upg/func/pramboot is null");
+        return -EINVAL;
+    }
+
+    if (upg->func->pb_length < FTS_MIN_LEN) {
+        FTS_ERROR("pramboot length(%d) fail", upg->func->pb_length);
+        return -EINVAL;
+    }
+
+    pb_buf = upg->func->pramboot;
+    pb_len = upg->func->pb_length;
+
+    /* write pramboot to pram */
+    ecc_in_host = fts_pram_write_buf(upg, pb_buf, pb_len);
+    if (ecc_in_host < 0) {
+        FTS_ERROR( "write pramboot fail");
+        return ecc_in_host;
+    }
+
+    /* read out checksum */
+    ecc_in_tp = fts_pram_ecc_cal(upg, 0, pb_len);
+    if (ecc_in_tp < 0) {
+        FTS_ERROR( "read pramboot ecc fail");
+        return ecc_in_tp;
+    }
+
+    FTS_INFO("pram ecc in tp:%x, host:%x", ecc_in_tp, ecc_in_host);
+    /*  pramboot checksum != fw checksum, upgrade fail */
+    if (ecc_in_host != ecc_in_tp) {
+        FTS_ERROR("pramboot ecc check fail");
+        return -EIO;
+    }
+
+    /*start pram*/
+    ret = fts_pram_start();
+    if (ret < 0) {
+        FTS_ERROR("pram start fail");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_pram_init(void)
+{
+    int ret = 0;
+    u8 reg_val = 0;
+    u8 wbuf[3] = { 0 };
+
+    FTS_INFO("pramboot initialization");
+
+    /* read flash ID */
+    wbuf[0] = FTS_CMD_FLASH_TYPE;
+    ret = fts_read(wbuf, 1, &reg_val, 1);
+    if (ret < 0) {
+        FTS_ERROR("read flash type fail");
+        return ret;
+    }
+
+    /* set flash clk */
+    wbuf[0] = FTS_CMD_FLASH_TYPE;
+    wbuf[1] = reg_val;
+    wbuf[2] = 0x00;
+    ret = fts_write(wbuf, 3);
+    if (ret < 0) {
+        FTS_ERROR("write flash type fail");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_pram_write_init(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool state = 0;
+    enum FW_STATUS status = FTS_RUN_IN_ERROR;
+
+    FTS_INFO("**********pram write and init**********");
+    if ((NULL == upg) || (NULL == upg->func)) {
+        FTS_ERROR("upgrade/func is null");
+        return -EINVAL;
+    }
+
+    if (!upg->func->pramboot_supported) {
+        FTS_ERROR("ic not support pram");
+        return -EINVAL;
+    }
+
+    FTS_DEBUG("check whether tp is in romboot or not ");
+    /* need reset to romboot when non-romboot state */
+    ret = fts_fwupg_get_boot_state(upg, &status);
+    if (status != FTS_RUN_IN_ROM) {
+        if (FTS_RUN_IN_PRAM == status) {
+            FTS_INFO("tp is in pramboot, need send reset cmd before upgrade");
+            ret = fts_pram_init();
+            if (ret < 0) {
+                FTS_ERROR("pramboot(before) init fail");
+                return ret;
+            }
+        }
+
+        FTS_INFO("tp isn't in romboot, need send reset to romboot");
+        ret = fts_fwupg_reset_to_romboot(upg);
+        if (ret < 0) {
+            FTS_ERROR("reset to romboot fail");
+            return ret;
+        }
+    }
+
+    /* check the length of the pramboot */
+    ret = fts_pram_write_remap(upg);
+    if (ret < 0) {
+        FTS_ERROR("pram write fail, ret=%d", ret);
+        return ret;
+    }
+
+    FTS_DEBUG("after write pramboot, confirm run in pramboot");
+    state = fts_fwupg_check_state(upg, FTS_RUN_IN_PRAM);
+    if (!state) {
+        FTS_ERROR("not in pramboot");
+        return -EIO;
+    }
+
+    ret = fts_pram_init();
+    if (ret < 0) {
+        FTS_ERROR("pramboot init fail");
+        return ret;
+    }
+
+    return 0;
+}
+
+static bool fts_fwupg_check_fw_valid(void)
+{
+    int ret = 0;
+
+    ret = fts_wait_tp_to_valid();
+    if (ret < 0) {
+        FTS_INFO("tp fw invaild");
+        return false;
+    }
+
+    FTS_INFO("tp fw vaild");
+    return true;
+}
+
+/************************************************************************
+* Name: fts_fwupg_check_state
+* Brief: confirm tp run in which mode: romboot/pramboot/bootloader
+* Input:
+* Output:
+* Return: return true if state is match, otherwise return false
+***********************************************************************/
+static bool fts_fwupg_check_state(
+    struct fts_upgrade *upg, enum FW_STATUS rstate)
+{
+    int ret = 0;
+    int i = 0;
+    enum FW_STATUS cstate = FTS_RUN_IN_ERROR;
+
+    for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+        ret = fts_fwupg_get_boot_state(upg, &cstate);
+        /* FTS_DEBUG("fw state=%d, retries=%d", cstate, i); */
+        if (cstate == rstate)
+            return true;
+        fts_msleep(FTS_DELAY_READ_ID);
+
+        /* try to hardware reset to boot mode */
+        if ((rstate == FTS_RUN_IN_BOOTLOADER) || (rstate == FTS_RUN_IN_ROM)) {
+            if (i >= FTS_UPGRADE_RESET_LOOP) {
+                fts_reset_proc(upg->ts_data, true, 0);
+                mdelay(FTS_CMD_START_DELAY + ((i - FTS_UPGRADE_RESET_LOOP) * 4));
+                if (upg->func->hid_supported) {
+                    fts_hid2std(1);
+                    fts_write_reg(0x55, 0xAA);
+                    fts_msleep(FTS_CMD_START_DELAY);
+                    fts_hid2std(1);
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+/************************************************************************
+* Name: fts_fwupg_reset_in_boot
+* Brief: RST CMD(07), reset to romboot(bootloader) in boot environment
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+int fts_fwupg_reset_in_boot(void)
+{
+    int ret = 0;
+    u8 cmd = FTS_CMD_RESET;
+
+    FTS_INFO("reset in boot environment");
+    ret = fts_write(&cmd, 1);
+    if (ret < 0) {
+        FTS_ERROR("pram/rom/bootloader reset cmd write fail");
+        return ret;
+    }
+
+    fts_msleep(FTS_DELAY_UPGRADE_RESET);
+    return 0;
+}
+
+/************************************************************************
+* Name: fts_fwupg_enter_into_boot
+* Brief: enter into boot environment, ready for upgrade
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+int fts_fwupg_enter_into_boot(void)
+{
+    int ret = 0;
+    bool fwvalid = false;
+    bool state = false;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("***********enter into pramboot/bootloader***********");
+    if ((!upg) || (NULL == upg->func)) {
+        FTS_ERROR("upgrade/func is null");
+        return -EINVAL;
+    }
+
+    fwvalid = fts_fwupg_check_fw_valid();
+    if (fwvalid) {
+        ret = fts_fwupg_reset_to_boot(upg);
+        if (ret < 0) {
+            FTS_ERROR("enter into romboot/bootloader fail");
+            return ret;
+        }
+    } else if (upg->func->read_boot_id_need_reset) {
+        ret = fts_fwupg_reset_in_boot();
+        if (ret < 0) {
+            FTS_ERROR("reset before read boot id when fw invalid fail");
+            return ret;
+        }
+    }
+
+    if (upg->func->pramboot_supported) {
+        FTS_INFO("pram supported, write pramboot and init");
+        /* pramboot */
+        if (upg->func->write_pramboot_private)
+            ret = upg->func->write_pramboot_private();
+        else
+            ret = fts_pram_write_init(upg);
+        if (ret < 0) {
+            FTS_ERROR("pram write_init fail");
+            return ret;
+        }
+    } else {
+        FTS_DEBUG("pram not supported, confirm in bootloader");
+        /* bootloader */
+        state = fts_fwupg_check_state(upg, FTS_RUN_IN_BOOTLOADER);
+        if (!state) {
+            FTS_ERROR("fw not in bootloader, fail");
+            return -EIO;
+        }
+    }
+
+    return 0;
+}
+
+/************************************************************************
+* Name: fts_fwupg_hwrst_to_boot
+* Brief: Hardware reset to enter into boot environment, ready for upgrade
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+int fts_fwupg_hwrst_to_boot(void)
+{
+    int ret = 0;
+    int i = 0;
+    bool state = false;
+    enum FW_STATUS cstate = FTS_RUN_IN_ERROR;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("***********enter into pramboot/bootloader***********");
+    if ((!upg) || (!upg->func) || (!upg->ts_data)) {
+        FTS_ERROR("upgrade/func/ts_data is null");
+        return -EINVAL;
+    }
+
+    FTS_INFO("enter into boot environment");
+    for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+        /* hardware tp reset to boot */
+        fts_reset_proc(upg->ts_data, true, 0);
+        mdelay(FTS_CMD_START_DELAY + i * 2);
+        fts_fwupg_get_boot_state(upg, &cstate);
+        if (cstate != FTS_RUN_IN_ERROR) {
+            FTS_INFO("get boot state:%d", cstate);
+            break;
+        }
+    }
+
+    if (upg->func->pramboot_supported) {
+        FTS_INFO("pram supported, write pramboot and init");
+        /* pramboot */
+        if (upg->func->write_pramboot_private)
+            ret = upg->func->write_pramboot_private();
+        else
+            ret = fts_pram_write_init(upg);
+        if (ret < 0) {
+            FTS_ERROR("pram write_init fail");
+            return ret;
+        }
+    } else {
+        FTS_DEBUG("pram not supported, confirm in bootloader");
+        /* bootloader */
+        state = fts_fwupg_check_state(upg, FTS_RUN_IN_BOOTLOADER);
+        if (!state) {
+            FTS_ERROR("fw not in bootloader, fail");
+            return -EIO;
+        }
+    }
+
+    return 0;
+}
+
+/************************************************************************
+ * Name: fts_fwupg_check_flash_status
+ * Brief: read status from tp
+ * Input: flash_status: correct value from tp
+ *        retries: read retry times
+ *        retries_delay: retry delay
+ * Output:
+ * Return: return true if flash status check pass, otherwise return false
+***********************************************************************/
+static bool fts_fwupg_check_flash_status(
+    u16 flash_status,
+    int retries,
+    int retries_delay)
+{
+    int ret = 0;
+    int i = 0;
+    u8 cmd = 0;
+    u8 val[FTS_CMD_FLASH_STATUS_LEN] = { 0 };
+    u16 read_status = 0;
+
+    for (i = 0; i < retries; i++) {
+        cmd = FTS_CMD_FLASH_STATUS;
+        ret = fts_read(&cmd , 1, val, FTS_CMD_FLASH_STATUS_LEN);
+        read_status = (((u16)val[0]) << 8) + val[1];
+        if (flash_status == read_status) {
+            /* FTS_DEBUG("[UPGRADE]flash status ok"); */
+            return true;
+        }
+        /* FTS_DEBUG("flash status fail,ok:%04x read:%04x, retries:%d", flash_status, read_status, i); */
+        fts_msleep(retries_delay);
+    }
+
+    FTS_ERROR("flash status fail,ok:%04x,read:%04x,retries:%d",
+              flash_status, read_status, i);
+    return false;
+}
+
+/************************************************************************
+ * Name: fts_fwupg_erase
+ * Brief: erase flash area
+ * Input: delay - delay after erase
+ * Output:
+ * Return: return 0 if success, otherwise return error code
+ ***********************************************************************/
+int fts_fwupg_erase(u32 delay)
+{
+    int ret = 0;
+    u8 cmd = 0;
+    bool flag = false;
+
+    FTS_INFO("**********erase now**********");
+
+    /*send to erase flash*/
+    cmd = FTS_CMD_ERASE_APP;
+    ret = fts_write(&cmd, 1);
+    if (ret < 0) {
+        FTS_ERROR("erase cmd fail");
+        return ret;
+    }
+    fts_msleep(delay);
+
+    /* read status 0xF0AA: success */
+    flag = fts_fwupg_check_flash_status(FTS_CMD_FLASH_STATUS_ERASE_OK,
+                                        FTS_RETRIES_REASE,
+                                        FTS_RETRIES_DELAY_REASE);
+    if (!flag) {
+        FTS_ERROR("ecc flash status check fail");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/************************************************************************
+ * Name: fts_fwupg_ecc_cal
+ * Brief: calculate and get ecc from tp
+ * Input: saddr - start address need calculate ecc
+ *        len - length need calculate ecc
+ * Output:
+ * Return: return data ecc of tp if success, otherwise return error code
+ ***********************************************************************/
+int fts_fwupg_ecc_cal(u32 saddr, u32 len)
+{
+    int ret = 0;
+    u32 i = 0;
+    u32 cmdlen = FTS_CMD_ECC_CAL_LEN;
+    u8 wbuf[FTS_CMD_ECC_CAL_LEN] = { 0 };
+    u8 val[FTS_CMD_FLASH_STATUS_LEN] = { 0 };
+    int ecc = 0;
+    int ecc_len = 0;
+    u32 packet_num = 0;
+    u32 packet_len = 0;
+    u32 remainder = 0;
+    u32 addr = 0;
+    u32 offset = 0;
+    bool bflag = false;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO( "**********read out checksum**********");
+    if ((NULL == upg) || (NULL == upg->func)) {
+        FTS_ERROR("upgrade/func is null");
+        return -EINVAL;
+    }
+
+    /* check sum init */
+    wbuf[0] = FTS_CMD_ECC_INIT;
+    ret = fts_write(wbuf, 1);
+    if (ret < 0) {
+        FTS_ERROR("ecc init cmd write fail");
+        return ret;
+    }
+
+    if (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0) {
+        packet_num = 1;
+        remainder = 0;
+        packet_len = len;
+    } else {
+        packet_num = len / FTS_MAX_LEN_ECC_CALC;
+        remainder = len % FTS_MAX_LEN_ECC_CALC;
+        if (remainder)
+            packet_num++;
+        packet_len = FTS_MAX_LEN_ECC_CALC;
+    }
+    FTS_INFO("ecc calc num:%d, remainder:%d", packet_num, remainder);
+
+    /* send commond to start checksum */
+    wbuf[0] = FTS_CMD_ECC_CAL;
+    for (i = 0; i < packet_num; i++) {
+        offset = FTS_MAX_LEN_ECC_CALC * i;
+        addr = saddr + offset;
+        wbuf[1] = BYTE_OFF_16(addr);
+        wbuf[2] = BYTE_OFF_8(addr);
+        wbuf[3] = BYTE_OFF_0(addr);
+
+        if ((upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+            wbuf[4] = BYTE_OFF_16(packet_len);
+            wbuf[5] = BYTE_OFF_8(packet_len);
+            wbuf[6] = BYTE_OFF_0(packet_len);
+            cmdlen = FTS_CMD_ECC_CAL_LEN;
+        } else {
+            if ((i == (packet_num - 1)) && remainder)
+                packet_len = remainder;
+            wbuf[4] = BYTE_OFF_8(packet_len);
+            wbuf[5] = BYTE_OFF_0(packet_len);
+            cmdlen = FTS_CMD_ECC_CAL_LEN - 1;
+        }
+
+        FTS_DEBUG("ecc calc startaddr:0x%04x, len:%d", addr, packet_len);
+        ret = fts_write(wbuf, cmdlen);
+        if (ret < 0) {
+            FTS_ERROR("ecc calc cmd write fail");
+            return ret;
+        }
+
+        fts_msleep(packet_len / 256);
+
+        /* read status if check sum is finished */
+        bflag = fts_fwupg_check_flash_status(FTS_CMD_FLASH_STATUS_ECC_OK,
+                                             FTS_RETRIES_ECC_CAL,
+                                             FTS_RETRIES_DELAY_ECC_CAL);
+        if (!bflag) {
+            FTS_ERROR("ecc flash status read fail");
+            return -EIO;
+        }
+    }
+
+    ecc_len = 1;
+    if ((ECC_CHECK_MODE_CRC16 == upg->func->fw_ecc_check_mode) ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+        ecc_len = 2;
+    }
+
+    /* read out check sum */
+    wbuf[0] = FTS_CMD_ECC_READ;
+    ret = fts_read(wbuf, 1, val, ecc_len);
+    if (ret < 0) {
+        FTS_ERROR( "ecc read cmd write fail");
+        return ret;
+    }
+
+    if ((ECC_CHECK_MODE_CRC16 == upg->func->fw_ecc_check_mode) ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+        ecc = (int)((u16)(val[0] << 8) + val[1]);
+    } else {
+        ecc = (int)val[0];
+    }
+
+    return ecc;
+}
+
+/************************************************************************
+ * Name: fts_flash_write_buf
+ * Brief: write buf data to flash address
+ * Input: saddr - start address data write to flash
+ *        buf - data buffer
+ *        len - data length
+ *        delay - delay after write
+ * Output:
+ * Return: return data ecc of host if success, otherwise return error code
+ ***********************************************************************/
+int fts_flash_write_buf(
+    u32 saddr,
+    u8 *buf,
+    u32 len,
+    u32 delay)
+{
+    int ret = 0;
+    u32 i = 0;
+    u32 j = 0;
+    u32 packet_number = 0;
+    u32 packet_len = 0;
+    u32 addr = 0;
+    u32 offset = 0;
+    u32 remainder = 0;
+    u32 cmdlen = 0;
+    u8 packet_buf[FTS_FLASH_PACKET_LENGTH + FTS_CMD_WRITE_LEN] = { 0 };
+    u8 ecc_tmp = 0;
+    int ecc_in_host = 0;
+    u8 cmd = 0;
+    u8 val[FTS_CMD_FLASH_STATUS_LEN] = { 0 };
+    u16 read_status = 0;
+    u16 wr_ok = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO( "**********write data to flash**********");
+    if ((!upg) || (!upg->func || !buf || !len)) {
+        FTS_ERROR("upgrade/func/buf/len is invalid");
+        return -EINVAL;
+    }
+
+    FTS_INFO("data buf start addr=0x%x, len=0x%x", saddr, len);
+    packet_number = len / FTS_FLASH_PACKET_LENGTH;
+    remainder = len % FTS_FLASH_PACKET_LENGTH;
+    if (remainder > 0)
+        packet_number++;
+    packet_len = FTS_FLASH_PACKET_LENGTH;
+    FTS_INFO("write data, num:%d remainder:%d", packet_number, remainder);
+
+    for (i = 0; i < packet_number; i++) {
+        offset = i * FTS_FLASH_PACKET_LENGTH;
+        addr = saddr + offset;
+
+        /* last packet */
+        if ((i == (packet_number - 1)) && remainder)
+            packet_len = remainder;
+
+        if ((upg->ts_data->bus_type == BUS_TYPE_SPI) && (upg->ts_data->bus_ver == BUS_VER_V2)) {
+            packet_buf[0] = FTS_CMD_SET_WFLASH_ADDR;
+            packet_buf[1] = BYTE_OFF_16(addr);
+            packet_buf[2] = BYTE_OFF_8(addr);
+            packet_buf[3] = BYTE_OFF_0(addr);
+            ret = fts_write(packet_buf, FTS_LEN_SET_ADDR);
+            if (ret < 0) {
+                FTS_ERROR("set flash address fail");
+                return ret;
+            }
+
+            packet_buf[0] = FTS_CMD_WRITE;
+            cmdlen = 1;
+        } else {
+            packet_buf[0] = FTS_CMD_WRITE;
+            packet_buf[1] = BYTE_OFF_16(addr);
+            packet_buf[2] = BYTE_OFF_8(addr);
+            packet_buf[3] = BYTE_OFF_0(addr);
+            packet_buf[4] = BYTE_OFF_8(packet_len);
+            packet_buf[5] = BYTE_OFF_0(packet_len);
+            cmdlen = 6;
+        }
+
+        for (j = 0; j < packet_len; j++) {
+            packet_buf[cmdlen + j] = buf[offset + j];
+            ecc_tmp ^= packet_buf[cmdlen + j];
+        }
+
+        ret = fts_write(packet_buf, packet_len + cmdlen);
+        if (ret < 0) {
+            FTS_ERROR("app write fail");
+            return ret;
+        }
+        mdelay(delay);
+
+        /* read status */
+        wr_ok = FTS_CMD_FLASH_STATUS_WRITE_OK + addr / packet_len;
+        for (j = 0; j < FTS_RETRIES_WRITE; j++) {
+            cmd = FTS_CMD_FLASH_STATUS;
+            ret = fts_read(&cmd , 1, val, FTS_CMD_FLASH_STATUS_LEN);
+            read_status = (((u16)val[0]) << 8) + val[1];
+            /*  FTS_INFO("%x %x", wr_ok, read_status); */
+            if (wr_ok == read_status) {
+                break;
+            }
+            mdelay(FTS_RETRIES_DELAY_WRITE);
+        }
+    }
+
+    ecc_in_host = (int)ecc_tmp;
+    if ((ECC_CHECK_MODE_CRC16 == upg->func->fw_ecc_check_mode) ||
+        (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_0)) {
+        ecc_in_host = (int)fts_crc16_calc_host(buf, len);
+    }
+
+    return ecc_in_host;
+}
+
+/************************************************************************
+ * Name: fts_flash_read_buf
+ * Brief: read data from flash
+ * Input: saddr - start address data write to flash
+ *        buf - buffer to store data read from flash
+ *        len - read length
+ * Output:
+ * Return: return 0 if success, otherwise return error code
+ *
+ * Warning: can't call this function directly, need call in boot environment
+ ***********************************************************************/
+int fts_flash_read_buf(u32 saddr, u8 *buf, u32 len)
+{
+    int ret = 0;
+    u32 i = 0;
+    u32 packet_number = 0;
+    u32 packet_len = 0;
+    u32 addr = 0;
+    u32 offset = 0;
+    u32 remainder = 0;
+    u8 wbuf[FTS_CMD_READ_LEN_SPI] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+
+    if (!upg || !buf || !len) {
+        FTS_ERROR("upgrade/buf is NULL or len is 0");
+        return -EINVAL;
+    }
+
+    packet_number = len / FTS_FLASH_PACKET_LENGTH;
+    remainder = len % FTS_FLASH_PACKET_LENGTH;
+    if (remainder > 0) {
+        packet_number++;
+    }
+    packet_len = FTS_FLASH_PACKET_LENGTH;
+    FTS_INFO("read packet_number:%d, remainder:%d", packet_number, remainder);
+
+
+    for (i = 0; i < packet_number; i++) {
+        offset = i * FTS_FLASH_PACKET_LENGTH;
+        addr = saddr + offset;
+        /* last packet */
+        if ((i == (packet_number - 1)) && remainder)
+            packet_len = remainder;
+
+        if (upg->ts_data->bus_type == BUS_TYPE_I2C) {
+            wbuf[0] = FTS_CMD_READ;
+            wbuf[1] = BYTE_OFF_16(addr);
+            wbuf[2] = BYTE_OFF_8(addr);
+            wbuf[3] = BYTE_OFF_0(addr);
+            ret = fts_write(wbuf, FTS_CMD_READ_LEN);
+            if (ret < 0) {
+                FTS_ERROR("pram/bootloader write 03 command fail");
+                return ret;
+            }
+
+            fts_msleep(FTS_CMD_READ_DELAY); /* must wait, otherwise read wrong data */
+            ret = fts_read(NULL, 0, buf + offset, packet_len);
+            if (ret < 0) {
+                FTS_ERROR("pram/bootloader read 03 command fail");
+                return ret;
+            }
+        } else if (upg->ts_data->bus_type == BUS_TYPE_SPI) {
+            FTS_INFO("bus ver:%d", upg->ts_data->bus_ver);
+            if (upg->ts_data->bus_ver == BUS_VER_V2) {
+                wbuf[0] = FTS_CMD_SET_RFLASH_ADDR;
+                wbuf[1] = BYTE_OFF_16(addr);
+                wbuf[2] = BYTE_OFF_8(addr);
+                wbuf[3] = BYTE_OFF_0(addr);
+                ret = fts_write(wbuf, FTS_LEN_SET_ADDR);
+                if (ret < 0) {
+                    FTS_ERROR("set flash address fail");
+                    return ret;
+                }
+
+                fts_msleep(FTS_CMD_READ_DELAY);
+                wbuf[0] = FTS_CMD_READ;
+                ret = fts_read(wbuf, 1, buf + offset, packet_len);
+                if (ret < 0) {
+                    FTS_ERROR("pram/bootloader read 03(SPI_V2) command fail");
+                    return ret;
+                }
+            } else if (upg->ts_data->bus_ver == BUS_VER_DEFAULT) {
+                wbuf[0] = FTS_CMD_READ;
+                wbuf[1] = BYTE_OFF_16(addr);
+                wbuf[2] = BYTE_OFF_8(addr);
+                wbuf[3] = BYTE_OFF_0(addr);
+                wbuf[4] = BYTE_OFF_8(packet_len);
+                wbuf[5] = BYTE_OFF_0(packet_len);
+                ret = fts_read(wbuf, FTS_CMD_READ_LEN_SPI, \
+                               buf + offset, packet_len);
+                if (ret < 0) {
+                    FTS_ERROR("pram/bootloader read 03(SPI) command fail");
+                    return ret;
+                }
+            }
+        } else FTS_ERROR("unknown bus type:%d", upg->ts_data->bus_type);
+    }
+
+    return 0;
+}
+
+/************************************************************************
+ * Name: fts_flash_read
+ * Brief:
+ * Input:  addr  - address of flash
+ *         len   - length of read
+ * Output: buf   - data read from flash
+ * Return: return 0 if success, otherwise return error code
+ ***********************************************************************/
+static int fts_flash_read(u32 addr, u8 *buf, u32 len)
+{
+    int ret = 0;
+
+    FTS_INFO("***********read flash***********");
+    if ((NULL == buf) || (0 == len)) {
+        FTS_ERROR("buf is NULL or len is 0");
+        return -EINVAL;
+    }
+
+    ret = fts_fwupg_enter_into_boot();
+    if (ret < 0) {
+        FTS_ERROR("enter into pramboot/bootloader fail");
+        goto read_flash_err;
+    }
+
+    ret = fts_flash_read_buf(addr, buf, len);
+    if (ret < 0) {
+        FTS_ERROR("read flash fail");
+        goto read_flash_err;
+    }
+
+read_flash_err:
+    /* reset to normal boot */
+    ret = fts_fwupg_reset_in_boot();
+    if (ret < 0) {
+        FTS_ERROR("reset to normal boot fail");
+    }
+    return ret;
+}
+
+static int fts_read_file_default(char *file_name, u8 **file_buf)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
+    int ret = 0;
+    char file_path[FILE_NAME_LENGTH] = { 0 };
+    struct file *filp = NULL;
+    struct inode *inode;
+    mm_segment_t old_fs;
+    loff_t pos;
+    loff_t file_len = 0;
+
+    if ((NULL == file_name) || (NULL == file_buf)) {
+        FTS_ERROR("filename/filebuf is NULL");
+        return -EINVAL;
+    }
+
+    snprintf(file_path, FILE_NAME_LENGTH, "%s%s", FTS_FW_BIN_FILEPATH, file_name);
+    filp = filp_open(file_path, O_RDONLY, 0);
+    if (IS_ERR(filp)) {
+        FTS_ERROR("open %s file fail", file_path);
+        return -ENOENT;
+    }
+
+#if 1
+    inode = filp->f_inode;
+#else
+    /* reserved for linux earlier verion */
+    inode = filp->f_dentry->d_inode;
+#endif
+
+    file_len = inode->i_size;
+    *file_buf = (u8 *)vmalloc(file_len);
+    if (NULL == *file_buf) {
+        FTS_ERROR("file buf malloc fail");
+        filp_close(filp, NULL);
+        return -ENOMEM;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    pos = 0;
+    ret = vfs_read(filp, *file_buf, file_len , &pos);
+    if (ret < 0)
+        FTS_ERROR("read file fail");
+    FTS_INFO("file len:%d read len:%d pos:%d", (u32)file_len, ret, (u32)pos);
+    filp_close(filp, NULL);
+    set_fs(old_fs);
+    return ret;
+#else
+    FTS_INFO("not support vfs_read to get fw file");
+    return -EINVAL;
+#endif
+}
+
+static int fts_read_file_request_firmware(char *file_name, u8 **file_buf)
+{
+#if FTS_FW_REQUEST_SUPPORT
+    int ret = 0;
+    const struct firmware *fw = NULL;
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+
+    snprintf(fwname, FILE_NAME_LENGTH, "%s", file_name);
+    ret = request_firmware(&fw, fwname, upg->ts_data->dev);
+    if (0 == ret) {
+        FTS_INFO("firmware(%s) request successfully", fwname);
+        *file_buf = vmalloc(fw->size);
+        if (NULL == *file_buf) {
+            FTS_ERROR("fw buffer vmalloc fail");
+            ret = -ENOMEM;
+        } else {
+            memcpy(*file_buf, fw->data, fw->size);
+            ret = fw->size;
+        }
+    } else {
+        FTS_INFO("firmware(%s) request fail,ret=%d", fwname, ret);
+        ret = -EIO;
+    }
+
+    if (fw != NULL) {
+        release_firmware(fw);
+        fw = NULL;
+    }
+
+    return ret;
+#else
+    FTS_INFO("not support request_firmware to get fw file");
+    return -EINVAL;
+#endif
+}
+
+static int fts_read_file(char *file_name, u8 **file_buf)
+{
+    int ret = 0;
+
+    ret = fts_read_file_request_firmware(file_name, file_buf);
+    if (ret < 0) {
+        ret = fts_read_file_default(file_name, file_buf);
+        if (ret < 0) {
+            FTS_INFO("get fw file(default) abnormal");
+            return ret;
+        }
+    }
+
+    return ret;
+}
+
+int fts_upgrade_bin(char *fw_name, bool force)
+{
+    int ret = 0;
+    int irq_need_recovery = false;
+    int esd_need_recovery = false;
+    u32 fw_file_len = 0;
+    u8 *fw_file_buf = NULL;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("start upgrade with fw bin");
+    if ((!upg) || (!upg->func) || !upg->ts_data) {
+        FTS_ERROR("upgrade/func/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    upg->ts_data->fw_loading = 1;
+    if (!upg->ts_data->irq_disabled) {
+        fts_irq_disable();
+        irq_need_recovery = true;
+    }
+    if (fts_esdcheck_is_running(upg->ts_data)) {
+        fts_esdcheck_switch(upg->ts_data, DISABLE);
+        esd_need_recovery = true;
+    }
+
+    ret = fts_read_file(fw_name, &fw_file_buf);
+    if ((ret < 0) || (ret < FTS_MIN_LEN)) {
+        FTS_ERROR("read fw bin file(%s) fail, len:%d", fw_name, ret);
+        goto err_bin;
+    }
+
+    fw_file_len = ret;
+    FTS_INFO("fw bin file len:%d", fw_file_len);
+    if (force) {
+        if (upg->func->force_upgrade) {
+            ret = upg->func->force_upgrade(fw_file_buf, fw_file_len);
+        } else {
+            FTS_INFO("force_upgrade function is null, no upgrade");
+            goto err_bin;
+        }
+    } else {
+#if FTS_AUTO_LIC_UPGRADE_EN
+        if (upg->func->lic_upgrade) {
+            ret = upg->func->lic_upgrade(fw_file_buf, fw_file_len);
+        } else {
+            FTS_INFO("lic_upgrade function is null, no upgrade");
+        }
+#endif
+        if (upg->func->upgrade) {
+            ret = upg->func->upgrade(fw_file_buf, fw_file_len);
+        } else {
+            FTS_INFO("upgrade function is null, no upgrade");
+        }
+    }
+
+    if (ret < 0) {
+        FTS_ERROR("upgrade fw bin failed");
+        fts_fwupg_reset_in_boot();
+        goto err_bin;
+    }
+
+    FTS_INFO("upgrade fw bin success");
+    if (esd_need_recovery) fts_esdcheck_switch(upg->ts_data, ENABLE);
+    ret = 0;
+
+err_bin:
+    if (irq_need_recovery) fts_irq_enable();
+    upg->ts_data->fw_loading = 0;
+
+    if (fw_file_buf) {
+        vfree(fw_file_buf);
+        fw_file_buf = NULL;
+    }
+    return ret;
+}
+
+int fts_enter_test_environment(bool test_state)
+{
+    return 0;
+}
+#if FTS_AUTO_LIC_UPGRADE_EN
+static int fts_lic_get_vid_in_tp(u16 *vid)
+{
+    int ret = 0;
+    u8 val[2] = { 0 };
+
+    if (NULL == vid) {
+        FTS_ERROR("vid is NULL");
+        return -EINVAL;
+    }
+
+    ret = fts_read_reg(FTS_REG_VENDOR_ID, &val[0]);
+    if (fts_data->ic_info.is_incell)
+        ret = fts_read_reg(FTS_REG_PANEL_ID, &val[1]);
+    if (ret < 0) {
+        FTS_ERROR("read vid from tp fail");
+        return ret;
+    }
+
+    *vid = *(u16 *)val;
+    return 0;
+}
+
+static int fts_lic_get_vid_in_host(struct fts_upgrade *upg, u16 *vid)
+{
+    u8 val[2] = { 0 };
+    u8 *licbuf = NULL;
+    u32 conf_saddr = 0;
+
+    if (!upg || !upg->func || !upg->ts_data || !upg->lic || !vid) {
+        FTS_ERROR("upgrade/func/ts_data/get_hlic_ver/lic/vid is null");
+        return -EINVAL;
+    }
+
+    if (upg->lic_length < FTS_MAX_LEN_SECTOR) {
+        FTS_ERROR("lic length(%x) fail", upg->lic_length);
+        return -EINVAL;
+    }
+
+    licbuf  = upg->lic;
+    conf_saddr = upg->func->fwcfgoff;
+    val[0] = licbuf[conf_saddr + FTS_CONIFG_VENDORID_OFF];
+    if (upg->ts_data->ic_info.is_incell)
+        val[1] = licbuf[conf_saddr + FTS_CONIFG_PANELID_OFF];
+
+    *vid = *(u16 *)val;
+    return 0;
+}
+
+static int fts_lic_get_ver_in_tp(u8 *ver)
+{
+    int ret = 0;
+
+    if (NULL == ver) {
+        FTS_ERROR("ver is NULL");
+        return -EINVAL;
+    }
+
+    ret = fts_read_reg(FTS_REG_LIC_VER, ver);
+    if (ret < 0) {
+        FTS_ERROR("read lcd initcode ver from tp fail");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_lic_get_ver_in_host(struct fts_upgrade *upg, u8 *ver)
+{
+    int ret = 0;
+
+    if (!upg || !upg->func || !upg->func->get_hlic_ver || !upg->lic) {
+        FTS_ERROR("upgrade/func/get_hlic_ver/lic is null");
+        return -EINVAL;
+    }
+
+    ret = upg->func->get_hlic_ver(upg->lic);
+    if (ret < 0) {
+        FTS_ERROR("get host lcd initial code version fail");
+        return ret;
+    }
+
+    *ver = (u8)ret;
+    return ret;
+}
+
+static bool fts_lic_need_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    u8 initcode_ver_in_tp = 0;
+    u8 initcode_ver_in_host = 0;
+    u16 vid_in_tp = 0;
+    u16 vid_in_host = 0;
+    bool fwvalid = false;
+
+    fwvalid = fts_fwupg_check_fw_valid();
+    if ( !fwvalid) {
+        FTS_INFO("fw is invalid, no upgrade lcd init code");
+        return false;
+    }
+
+    ret = fts_lic_get_vid_in_host(upg, &vid_in_host);
+    if (ret < 0) {
+        FTS_ERROR("vendor id in host invalid");
+        return false;
+    }
+
+    ret = fts_lic_get_vid_in_tp(&vid_in_tp);
+    if (ret < 0) {
+        FTS_ERROR("vendor id in tp invalid");
+        return false;
+    }
+
+    FTS_DEBUG("vid in tp:0x%04x, host:0x%04x", vid_in_tp, vid_in_host);
+    if (vid_in_tp != vid_in_host) {
+        FTS_INFO("vendor id in tp&host are different, no upgrade lic");
+        return false;
+    }
+
+    ret = fts_lic_get_ver_in_host(upg, &initcode_ver_in_host);
+    if (ret < 0) {
+        FTS_ERROR("init code in host invalid");
+        return false;
+    }
+
+    ret = fts_lic_get_ver_in_tp(&initcode_ver_in_tp);
+    if (ret < 0) {
+        FTS_ERROR("read reg0xE4 fail");
+        return false;
+    }
+
+    FTS_DEBUG("lcd initial code version in tp:%x, host:%x",
+              initcode_ver_in_tp, initcode_ver_in_host);
+    if (0xA5 == initcode_ver_in_tp) {
+        FTS_INFO("lcd init code ver is 0xA5, don't upgade init code");
+        return false;
+    } else if (0xFF == initcode_ver_in_tp) {
+        FTS_DEBUG("lcd init code in tp is invalid, need upgrade init code");
+        return true;
+    } else if (initcode_ver_in_tp < initcode_ver_in_host)
+        return true;
+    else
+        return false;
+}
+
+static int fts_lic_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool hlic_upgrade = false;
+    int upgrade_count = 0;
+    u8 ver = 0;
+
+    FTS_INFO("lcd initial code auto upgrade function");
+    if ((!upg) || (!upg->func) || (!upg->func->lic_upgrade)) {
+        FTS_ERROR("lcd upgrade function is null");
+        return -EINVAL;
+    }
+
+    hlic_upgrade = fts_lic_need_upgrade(upg);
+    FTS_INFO("lcd init code upgrade flag:%d", hlic_upgrade);
+    if (hlic_upgrade) {
+        FTS_INFO("lcd initial code need upgrade, upgrade begin...");
+        do {
+            FTS_INFO("lcd initial code upgrade times:%d", upgrade_count);
+            upgrade_count++;
+
+            ret = upg->func->lic_upgrade(upg->lic, upg->lic_length);
+            if (ret < 0) {
+                fts_fwupg_reset_in_boot();
+            } else {
+                fts_lic_get_ver_in_tp(&ver);
+                FTS_INFO("success upgrade to lcd initcode ver:%02x", ver);
+                break;
+            }
+        } while (upgrade_count < 2);
+    } else {
+        FTS_INFO("lcd initial code don't need upgrade");
+    }
+
+    return ret;
+}
+#endif /* FTS_AUTO_LIC_UPGRADE_EN */
+
+
+static int fts_param_get_ver_in_tp(u8 *ver)
+{
+    int ret = 0;
+
+    if (NULL == ver) {
+        FTS_ERROR("ver is NULL");
+        return -EINVAL;
+    }
+
+    ret = fts_read_reg(FTS_REG_IDE_PARA_VER_ID, ver);
+    if (ret < 0) {
+        FTS_ERROR("read fw param ver from tp fail");
+        return ret;
+    }
+
+    if ((0x00 == *ver) || (0xFF == *ver)) {
+        FTS_INFO("param version in tp invalid");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int fts_param_get_ver_in_host(struct fts_upgrade *upg, u8 *ver)
+{
+    if ((!upg) || (!upg->func) || (!upg->fw) || (!ver)) {
+        FTS_ERROR("upgrade/func/fw/ver is NULL");
+        return -EINVAL;
+    }
+
+    if (upg->fw_length < upg->func->paramcfgveroff) {
+        FTS_ERROR("fw len(%x) < paramcfg ver offset(%x)",
+                  upg->fw_length, upg->func->paramcfgveroff);
+        return -EINVAL;
+    }
+
+    FTS_INFO("fw paramcfg version offset:%x", upg->func->paramcfgveroff);
+    *ver = upg->fw[upg->func->paramcfgveroff];
+
+    if ((0x00 == *ver) || (0xFF == *ver)) {
+        FTS_INFO("param version in host invalid");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/*
+ * return: < 0 : error
+ *         == 0: no ide
+ *         == 1: ide
+ */
+static int fts_param_ide_in_host(struct fts_upgrade *upg)
+{
+    u32 off = 0;
+
+    if ((!upg) || (!upg->func) || (!upg->fw)) {
+        FTS_ERROR("upgrade/func/fw is NULL");
+        return -EINVAL;
+    }
+
+    if (upg->fw_length < upg->func->paramcfgoff + FTS_FW_IDE_SIG_LEN) {
+        FTS_INFO("fw len(%x) < paramcfg offset(%x), no IDE",
+                 upg->fw_length, upg->func->paramcfgoff + FTS_FW_IDE_SIG_LEN);
+        return 0;
+    }
+
+    off = upg->func->paramcfgoff;
+    if (0 == memcmp(&upg->fw[off], FTS_FW_IDE_SIG, FTS_FW_IDE_SIG_LEN)) {
+        FTS_INFO("fw in host is IDE version");
+        return 1;
+    }
+
+    FTS_INFO("fw in host isn't IDE version");
+    return 0;
+}
+
+/*
+ * return: < 0 : error
+ *         0   : no ide
+ *         1   : ide
+ */
+static int fts_param_ide_in_tp(u8 *val)
+{
+    int ret = 0;
+
+    ret = fts_read_reg(FTS_REG_IDE_PARA_STATUS, val);
+    if (ret < 0) {
+        FTS_ERROR("read IDE PARAM STATUS in tp fail");
+        return ret;
+    }
+
+    if ((*val != 0xFF) && ((*val & 0x80) == 0x80)) {
+        FTS_INFO("fw in tp is IDE version");
+        return 1;
+    }
+
+    FTS_INFO("fw in tp isn't IDE version");
+    return 0;
+}
+
+/************************************************************************
+ * fts_param_need_upgrade - check fw paramcfg need upgrade or not
+ *
+ * Return:  < 0 : error if paramcfg need upgrade
+ *          0   : no need upgrade
+ *          1   : need upgrade app + param
+ *          2   : need upgrade param
+ ***********************************************************************/
+static int fts_param_need_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    u8 val = 0;
+    int ide_in_host = 0;
+    int ide_in_tp = 0;
+    u8 ver_in_host = 0;
+    u8 ver_in_tp = 0;
+    bool fwvalid = false;
+
+    fwvalid = fts_fwupg_check_fw_valid();
+    if ( !fwvalid) {
+        FTS_INFO("fw is invalid, upgrade app+param");
+        return 1;
+    }
+
+    ide_in_host = fts_param_ide_in_host(upg);
+    if (ide_in_host < 0) {
+        FTS_INFO("fts_param_ide_in_host fail");
+        return ide_in_host;
+    }
+
+    ide_in_tp = fts_param_ide_in_tp(&val);
+    if (ide_in_tp < 0) {
+        FTS_INFO("fts_param_ide_in_tp fail");
+        return ide_in_tp;
+    }
+
+    if ((0 == ide_in_host) && (0 == ide_in_tp)) {
+        FTS_INFO("fw in host&tp are both no ide");
+        return 0;
+    } else if (ide_in_host != ide_in_tp) {
+        FTS_INFO("fw in host&tp not equal, need upgrade app+param");
+        return 1;
+    } else if ((1 == ide_in_host) && (1 == ide_in_tp)) {
+        FTS_INFO("fw in host&tp are both ide");
+        if ((val & 0x7F) != 0x00) {
+            FTS_INFO("param invalid, need upgrade param");
+            return 2;
+        }
+
+        ret = fts_param_get_ver_in_host(upg, &ver_in_host);
+        if (ret < 0) {
+            FTS_ERROR("param version in host invalid");
+            return ret;
+        }
+
+        ret = fts_param_get_ver_in_tp(&ver_in_tp);
+        if (ret < 0) {
+            FTS_ERROR("get IDE param ver in tp fail");
+            return ret;
+        }
+
+        FTS_INFO("fw paramcfg version in tp:%x, host:%x",
+                 ver_in_tp, ver_in_host);
+        if (ver_in_tp != ver_in_host) {
+            return 2;
+        }
+    }
+
+    return 0;
+}
+
+static int fts_fwupg_get_ver_in_tp(u8 *ver)
+{
+    int ret = 0;
+
+    if (NULL == ver) {
+        FTS_ERROR("ver is NULL");
+        return -EINVAL;
+    }
+
+    ret = fts_read_reg(FTS_REG_FW_VER, ver);
+    if (ret < 0) {
+        FTS_ERROR("read fw ver from tp fail");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_fwupg_get_ver_in_host(struct fts_upgrade *upg, u8 *ver)
+{
+    if ((!upg) || (!upg->func) || (!upg->fw) || (!ver)) {
+        FTS_ERROR("upgrade/func/fw/ver is NULL");
+        return -EINVAL;
+    }
+
+    if (upg->fw_length < upg->func->fwveroff) {
+        FTS_ERROR("fw len(0x%0x) < fw ver offset(0x%x)",
+                  upg->fw_length, upg->func->fwveroff);
+        return -EINVAL;
+    }
+
+    FTS_INFO("fw version offset:0x%x", upg->func->fwveroff);
+    *ver = upg->fw[upg->func->fwveroff];
+    return 0;
+}
+
+static bool fts_fwupg_need_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool fwvalid = false;
+    u8 fw_ver_in_host = 0;
+    u8 fw_ver_in_tp = 0;
+
+    fwvalid = fts_fwupg_check_fw_valid();
+    if (fwvalid) {
+        ret = fts_fwupg_get_ver_in_host(upg, &fw_ver_in_host);
+        if (ret < 0) {
+            FTS_ERROR("get fw ver in host fail");
+            return false;
+        }
+
+        ret = fts_fwupg_get_ver_in_tp(&fw_ver_in_tp);
+        if (ret < 0) {
+            FTS_ERROR("get fw ver in tp fail");
+            return false;
+        }
+
+        FTS_INFO("fw version in tp:%x, host:%x", fw_ver_in_tp, fw_ver_in_host);
+        if (fw_ver_in_tp != fw_ver_in_host) {
+            return true;
+        }
+    } else {
+        FTS_INFO("fw invalid, need upgrade fw");
+        return true;
+    }
+
+    return false;
+}
+
+/************************************************************************
+ * Name: fts_fw_upgrade
+ * Brief: fw upgrade main entry, run in following steps
+ *        1. check fw version(A6), not equal, will upgrade app(+param)
+ *        2. if fw version equal, will check ide, will upgrade app(+param)
+ *        in the follow situation
+ *          a. host&tp IDE's type are not equal, will upgrade app+param
+ *          b. host&tp are both IDE's type, and param's version are not
+ *          equal, will upgrade param
+ * Input:
+ * Output:
+ * Return: return 0 if success, otherwise return error code
+ ***********************************************************************/
+int fts_fwupg_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool upgrade_flag = false;
+    int upgrade_count = 0;
+    u8 ver = 0;
+
+    FTS_INFO("fw auto upgrade function");
+    if ((NULL == upg) || (NULL == upg->func)) {
+        FTS_ERROR("upg/upg->func is null");
+        return -EINVAL;
+    }
+
+    upgrade_flag = fts_fwupg_need_upgrade(upg);
+    FTS_INFO("fw upgrade flag:%d", upgrade_flag);
+    do {
+        upgrade_count++;
+        if (upgrade_flag) {
+            FTS_INFO("upgrade fw app(times:%d)", upgrade_count);
+            if (upg->func->upgrade) {
+                ret = upg->func->upgrade(upg->fw, upg->fw_length);
+                if (ret < 0) {
+                    fts_fwupg_reset_in_boot();
+                } else {
+                    fts_fwupg_get_ver_in_tp(&ver);
+                    FTS_INFO("success upgrade to fw version %02x", ver);
+                    break;
+                }
+            } else {
+                FTS_ERROR("upgrade func/upgrade is null, return immediately");
+                ret = -ENODATA;
+                break;
+            }
+        } else {
+            if (upg->func->param_upgrade) {
+                ret = fts_param_need_upgrade(upg);
+                if (ret <= 0) {
+                    FTS_INFO("param don't need upgrade");
+                    break;
+                } else if (1 == ret) {
+                    FTS_INFO("force upgrade fw app(times:%d)", upgrade_count);
+                    if (upg->func->upgrade) {
+                        ret = upg->func->upgrade(upg->fw, upg->fw_length);
+                        if (ret < 0) {
+                            fts_fwupg_reset_in_boot();
+                        } else {
+                            break;
+                        }
+                    }
+                } else if (2 == ret) {
+                    FTS_INFO("upgrade param area(times:%d)", upgrade_count);
+                    ret = upg->func->param_upgrade(upg->fw, upg->fw_length);
+                    if (ret < 0) {
+                        fts_fwupg_reset_in_boot();
+                    } else {
+                        fts_param_get_ver_in_tp(&ver);
+                        FTS_INFO("success upgrade to fw param version %02x", ver);
+                        break;
+                    }
+                } else
+                    break;
+            } else {
+                break;
+            }
+        }
+    } while (upgrade_count < 2);
+
+    return ret;
+}
+
+/************************************************************************
+ * fts_fwupg_auto_upgrade - upgrade main entry
+ ***********************************************************************/
+static int fts_fwupg_auto_upgrade(struct fts_upgrade *upg)
+{
+    int ret = 0;
+
+    FTS_INFO("********************FTS enter upgrade********************");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    ret = fts_fwupg_upgrade(upg);
+    if (ret < 0)
+        FTS_ERROR("**********tp fw(app/param) upgrade failed**********");
+    else
+        FTS_INFO("**********tp fw(app/param) no upgrade/upgrade success**********");
+
+#if FTS_AUTO_LIC_UPGRADE_EN
+    ret = fts_lic_upgrade(upg);
+    if (ret < 0)
+        FTS_ERROR("**********lcd init code upgrade failed**********");
+    else
+        FTS_INFO("**********lcd init code no upgrade/upgrade success**********");
+#endif
+
+    FTS_INFO("********************FTS exit upgrade********************");
+    return ret;
+}
+
+static int fts_fwupg_get_moduleid(struct fts_upgrade *upg, int *module_id)
+{
+    int ret = 0;
+    bool fwvalid = false;
+    u8 vendor_id = 0;
+    u8 panel_id = 0;
+    u8 cmd = FTS_CMD_READ_FWCFG;
+    u32 fwcfg_addr = 0;
+    u8 cfgbuf[FTS_HEADER_LEN] = { 0 };
+
+    FTS_INFO("read module id from tp");
+    if ((!upg) || (!upg->func) || (!upg->ts_data) || (!module_id)) {
+        FTS_ERROR("upgrade/func/ts_data/vid is null");
+        return -EINVAL;
+    }
+
+    fwvalid = fts_fwupg_check_fw_valid();
+    if (fwvalid) {
+        ret = fts_read_reg(FTS_REG_VENDOR_ID, &vendor_id);
+        if (upg->ts_data->ic_info.is_incell)
+            ret = fts_read_reg(FTS_REG_PANEL_ID, &panel_id);
+    } else {
+        if (upg->func->upgspec_version >= UPGRADE_SPEC_V_1_1) {
+            ret = fts_read(&cmd, 1, cfgbuf, FTS_HEADER_LEN);
+        } else {
+            fwcfg_addr =  upg->func->fwcfgoff;
+            ret = fts_flash_read(fwcfg_addr, cfgbuf, FTS_HEADER_LEN);
+        }
+
+        if ((cfgbuf[FTS_CONIFG_VENDORID_OFF] +
+             cfgbuf[FTS_CONIFG_VENDORID_OFF + 1]) == 0xFF)
+            vendor_id = cfgbuf[FTS_CONIFG_VENDORID_OFF];
+        if (upg->ts_data->ic_info.is_incell) {
+            if ((cfgbuf[FTS_CONIFG_PANELID_OFF] +
+                 cfgbuf[FTS_CONIFG_PANELID_OFF + 1]) == 0xFF)
+                panel_id = cfgbuf[FTS_CONIFG_PANELID_OFF];
+        }
+    }
+
+    if (ret < 0) {
+        FTS_ERROR("fail to get module id from tp");
+        return ret;
+    }
+
+    *module_id = (int)((panel_id << 8) + vendor_id);
+    return 0;
+}
+
+
+int fts_enter_normal_fw(void)
+{
+
+    fts_wait_tp_to_valid();
+    return 0;
+}
+
+static int fts_fwupg_get_module_info(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    int i = 0;
+    struct upgrade_module *info = &module_list[0];
+
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (FTS_GET_MODULE_NUM > 1) {
+        /* support multi modules, must read correct module id */
+        ret = fts_fwupg_get_moduleid(upg, &upg->module_id);
+        if (ret < 0) {
+            FTS_ERROR("get module id failed");
+            return ret;
+        }
+        FTS_INFO("module id:%04x", upg->module_id);
+        for (i = 0; i < FTS_GET_MODULE_NUM; i++) {
+            info = &module_list[i];
+            if (upg->module_id == info->id) {
+                FTS_INFO("module id match, get module info pass");
+                break;
+            }
+        }
+        if (i >= FTS_GET_MODULE_NUM) {
+            FTS_ERROR("no module id match, don't get file");
+            return -ENODATA;
+        }
+    }
+
+    upg->module_info = info;
+    return 0;
+}
+
+static int fts_get_fw_file_via_request_firmware(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    const struct firmware *fw = NULL;
+    u8 *tmpbuf = NULL;
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+
+    if (!upg || !upg->ts_data || !upg->ts_data->dev) {
+        FTS_ERROR("upg/ts_data/dev is null");
+        return -EINVAL;
+    }
+
+    snprintf(fwname, FILE_NAME_LENGTH, "%s%s.bin", \
+             FTS_FW_NAME_PREX_WITH_REQUEST, \
+             upg->module_info->vendor_name);
+
+    ret = request_firmware(&fw, fwname, upg->ts_data->dev);
+    if (0 == ret) {
+        FTS_INFO("firmware(%s) request successfully", fwname);
+        tmpbuf = vmalloc(fw->size);
+        if (NULL == tmpbuf) {
+            FTS_ERROR("fw buffer vmalloc fail");
+            ret = -ENOMEM;
+        } else {
+            memcpy(tmpbuf, fw->data, fw->size);
+            upg->fw = tmpbuf;
+            upg->fw_length = fw->size;
+            upg->fw_from_request = 1;
+        }
+    } else {
+        FTS_INFO("firmware(%s) request fail,ret=%d", fwname, ret);
+    }
+
+    if (fw != NULL) {
+        release_firmware(fw);
+        fw = NULL;
+    }
+
+    return ret;
+}
+
+static int fts_get_fw_file_via_i(struct fts_upgrade *upg)
+{
+    upg->fw = upg->module_info->fw_file;
+    upg->fw_length = upg->module_info->fw_len;
+    upg->fw_from_request = 0;
+
+    return 0;
+}
+
+/*****************************************************************************
+ *  Name: fts_fwupg_get_fw_file
+ *  Brief: get fw image/file,
+ *         If support muitl modules, please set FTS_GET_MODULE_NUM, and FTS_-
+ *         MODULE_ID/FTS_MODULE_NAME;
+ *         If get fw via .i file, please set FTS_FW_REQUEST_SUPPORT=0, and F-
+ *         TS_MODULE_ID; will use module id to distingwish different modules;
+ *         If get fw via reques_firmware(), please set FTS_FW_REQUEST_SUPPORT
+ *         =1, and FTS_MODULE_NAME; fw file name will be composed of "focalt-
+ *         ech_ts_fw_" & FTS_MODULE_NAME;
+ *
+ *         If have flash, module_id=vendor_id, If non-flash,module_id need
+ *         transfer from LCD driver(gpio or lcm_id or ...);
+ *  Input:
+ *  Output:
+ *  Return: return 0 if success, otherwise return error code
+ *****************************************************************************/
+static int fts_fwupg_get_fw_file(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool get_fw_i_flag = false;
+
+    FTS_DEBUG("get upgrade fw file");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    ret = fts_fwupg_get_module_info(upg);
+    if ((ret < 0) || (!upg->module_info)) {
+        FTS_ERROR("get module info fail");
+        return ret;
+    }
+
+    if (FTS_FW_REQUEST_SUPPORT) {
+        ret = fts_get_fw_file_via_request_firmware(upg);
+        if (ret != 0) {
+            get_fw_i_flag = true;
+        }
+    } else {
+        get_fw_i_flag = true;
+    }
+
+    if (get_fw_i_flag) {
+        ret = fts_get_fw_file_via_i(upg);
+    }
+
+    upg->lic = upg->fw;
+    upg->lic_length = upg->fw_length;
+
+    FTS_INFO("upgrade fw file len:%d", upg->fw_length);
+    if (upg->fw_length < FTS_MIN_LEN) {
+        FTS_ERROR("fw file len(%d) fail", upg->fw_length);
+        return -ENODATA;
+    }
+
+    return ret;
+}
+
+static void fts_fwupg_init_ic_detail(struct fts_upgrade *upg)
+{
+    if (upg && upg->func && upg->func->init) {
+        upg->func->init(upg->fw, upg->fw_length);
+    }
+}
+
+/*****************************************************************************
+ *  Name: fts_fwupg_work
+ *  Brief: 1. get fw image/file
+ *         2. ic init if have
+ *         3. call upgrade main function(fts_fwupg_auto_upgrade)
+ *  Input:
+ *  Output:
+ *  Return:
+ *****************************************************************************/
+static void fts_fwupg_work(struct work_struct *work)
+{
+    int ret = 0;
+    int irq_need_recovery = false;
+    struct fts_upgrade *upg = fwupgrade;
+
+#if !FTS_AUTO_UPGRADE_EN
+    FTS_INFO("FTS_AUTO_UPGRADE_EN is disabled, not upgrade when power on");
+    return ;
+#endif
+
+    FTS_INFO("fw upgrade work function");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return ;
+    }
+
+    upg->ts_data->fw_loading = 1;
+    if (!upg->ts_data->irq_disabled) {
+        fts_irq_disable();
+        irq_need_recovery = true;
+    }
+    if (fts_esdcheck_is_running(upg->ts_data)) {
+        fts_esdcheck_switch(upg->ts_data, DISABLE);
+    }
+
+    /* get fw */
+    ret = fts_fwupg_get_fw_file(upg);
+    if (ret < 0) {
+        FTS_ERROR("get file fail, can't upgrade");
+    } else {
+        /* ic init if have */
+        fts_fwupg_init_ic_detail(upg);
+        /* run auto upgrade */
+        ret = fts_fwupg_auto_upgrade(upg);
+    }
+
+    if (ret >= 0)
+        fts_esdcheck_switch(upg->ts_data, ENABLE);
+    if (irq_need_recovery)
+        fts_irq_enable();
+    upg->ts_data->fw_loading = 0;
+}
+
+int fts_fwupg_init(struct fts_ts_data *ts_data)
+{
+    int i = 0;
+    int j = 0;
+    u16 ic_stype = 0;
+    struct upgrade_func *func = upgrade_func_list[0];
+    int func_count = sizeof(upgrade_func_list) / sizeof(upgrade_func_list[0]);
+
+    FTS_INFO("fw upgrade init function");
+
+    if (!ts_data || !ts_data->ts_workqueue) {
+        FTS_ERROR("ts_data/workqueue is NULL, can't run upgrade function");
+        return -EINVAL;
+    }
+
+    if (0 == func_count) {
+        FTS_ERROR("no upgrade function in tp driver");
+        return -ENODATA;
+    }
+
+    fwupgrade = (struct fts_upgrade *)kzalloc(sizeof(*fwupgrade), GFP_KERNEL);
+    if (NULL == fwupgrade) {
+        FTS_ERROR("malloc memory for upgrade fail");
+        return -ENOMEM;
+    }
+
+    ic_stype = ts_data->ic_info.ids.type;
+    if (1 == func_count) {
+        fwupgrade->func = func;
+    } else {
+        for (i = 0; i < func_count; i++) {
+            func = upgrade_func_list[i];
+            for (j = 0; j < FTS_MAX_COMPATIBLE_TYPE; j++) {
+                if (0 == func->ctype[j])
+                    break;
+                else if (func->ctype[j] == ic_stype) {
+                    FTS_INFO("match upgrade function,type:%x", (int)func->ctype[j]);
+                    fwupgrade->func = func;
+                }
+            }
+        }
+    }
+
+    if (NULL == fwupgrade->func) {
+        FTS_ERROR("no upgrade function match, can't upgrade");
+        kfree(fwupgrade);
+        fwupgrade = NULL;
+        return -ENODATA;
+    }
+
+    fwupgrade->ts_data = ts_data;
+    INIT_WORK(&fwupgrade->fwupg_work, fts_fwupg_work);
+    queue_work(ts_data->ts_workqueue, &fwupgrade->fwupg_work);
+
+    return 0;
+}
+
+int fts_fwupg_exit(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    if (fwupgrade) {
+        cancel_work_sync(&fwupgrade->fwupg_work);
+        if (fwupgrade->fw_from_request) {
+            vfree(fwupgrade->fw);
+            fwupgrade->fw = NULL;
+        }
+
+        kfree(fwupgrade);
+        fwupgrade = NULL;
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_flash.h b/drivers/input/touchscreen/focaltech_touch/focaltech_flash.h
new file mode 100755
index 000000000000..36fcdc926ccc
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_flash.h
@@ -0,0 +1,235 @@
+/************************************************************************
+* Copyright (c) 2012-2020, Focaltech Systems (R) All Rights Reserved.
+*
+* File Name: focaltech_flash.h
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-07
+*
+* Abstract:
+*
+************************************************************************/
+#ifndef __LINUX_FOCALTECH_FLASH_H__
+#define __LINUX_FOCALTECH_FLASH_H__
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_CMD_RESET                               0x07
+#define FTS_ROMBOOT_CMD_SET_PRAM_ADDR               0xAD
+#define FTS_ROMBOOT_CMD_SET_PRAM_ADDR_LEN           4
+#define FTS_ROMBOOT_CMD_WRITE                       0xAE
+#define FTS_ROMBOOT_CMD_START_APP                   0x08
+#define FTS_DELAY_PRAMBOOT_START                    100
+#define FTS_ROMBOOT_CMD_ECC                         0xCC
+#define FTS_PRAM_SADDR                              0x000000
+#define FTS_DRAM_SADDR                              0xD00000
+
+#define FTS_CMD_READ_FWCFG                          0xA8
+
+#define FTS_CMD_READ                                0x03
+#define FTS_CMD_READ_DELAY                          1
+#define FTS_CMD_READ_LEN                            4
+#define FTS_CMD_READ_LEN_SPI                        6
+#define FTS_CMD_FLASH_TYPE                          0x05
+#define FTS_CMD_FLASH_MODE                          0x09
+#define FLASH_MODE_WRITE_FLASH_VALUE                0x0A
+#define FLASH_MODE_UPGRADE_VALUE                    0x0B
+#define FLASH_MODE_LIC_VALUE                        0x0C
+#define FLASH_MODE_PARAM_VALUE                      0x0D
+#define FTS_CMD_ERASE_APP                           0x61
+#define FTS_REASE_APP_DELAY                         1350
+#define FTS_ERASE_SECTOR_DELAY                      60
+#define FTS_RETRIES_REASE                           50
+#define FTS_RETRIES_DELAY_REASE                     400
+#define FTS_CMD_FLASH_STATUS                        0x6A
+#define FTS_CMD_FLASH_STATUS_LEN                    2
+#define FTS_CMD_FLASH_STATUS_NOP                    0x0000
+#define FTS_CMD_FLASH_STATUS_ECC_OK                 0xF055
+#define FTS_CMD_FLASH_STATUS_ERASE_OK               0xF0AA
+#define FTS_CMD_FLASH_STATUS_WRITE_OK               0x1000
+#define FTS_CMD_ECC_INIT                            0x64
+#define FTS_CMD_ECC_CAL                             0x65
+#define FTS_CMD_ECC_CAL_LEN                         7
+#define FTS_RETRIES_ECC_CAL                         10
+#define FTS_RETRIES_DELAY_ECC_CAL                   50
+#define FTS_CMD_ECC_READ                            0x66
+#define FTS_CMD_DATA_LEN                            0xB0
+#define FTS_CMD_APP_DATA_LEN_INCELL                 0x7A
+#define FTS_CMD_DATA_LEN_LEN                        4
+#define FTS_CMD_SET_WFLASH_ADDR                     0xAB
+#define FTS_CMD_SET_RFLASH_ADDR                     0xAC
+#define FTS_LEN_SET_ADDR                            4
+#define FTS_CMD_WRITE                               0xBF
+#define FTS_RETRIES_WRITE                           100
+#define FTS_RETRIES_DELAY_WRITE                     1
+#define FTS_CMD_WRITE_LEN                           6
+#define FTS_DELAY_READ_ID                           20
+#define FTS_DELAY_UPGRADE_RESET                     80
+#define PRAMBOOT_MIN_SIZE                           0x120
+#define PRAMBOOT_MAX_SIZE                           (64*1024)
+#define FTS_FLASH_PACKET_LENGTH                     32     /* max=128 */
+#define FTS_MAX_LEN_ECC_CALC                        0xFFFE /* must be even */
+#define FTS_MIN_LEN                                 0x120
+#define FTS_MAX_LEN_FILE                            (256 * 1024)
+#define FTS_MAX_LEN_APP                             (64 * 1024)
+#define FTS_MAX_LEN_SECTOR                          (4 * 1024)
+#define FTS_CONIFG_VENDORID_OFF                     0x04
+#define FTS_CONIFG_PANELID_OFF                      0x1E
+#define FTS_CONIFG_PROJECTID_OFF                    0x20
+#define FTS_APPINFO_OFF                             0x100
+#define FTS_APPINFO_APPLEN_OFF                      0x00
+#define FTS_APPINFO_APPLEN2_OFF                     0x12
+#define FTS_REG_UPGRADE                             0xFC
+#define FTS_REG_UPGRADE2                            0xBC
+#define FTS_UPGRADE_AA                              0xAA
+#define FTS_UPGRADE_55                              0x55
+#define FTS_DELAY_UPGRADE_AA                        10
+#define FTS_UPGRADE_LOOP                            30
+#define FTS_UPGRADE_RESET_LOOP                      20
+#define FTS_HEADER_LEN                              32
+#define FTS_FW_BIN_FILEPATH                         "/sdcard/"
+#define FTS_FW_IDE_SIG                              "IDE_"
+#define FTS_FW_IDE_SIG_LEN                          4
+#define MAX_MODULE_VENDOR_NAME_LEN                  16
+
+#define FTS_ROMBOOT_CMD_ECC_NEW_LEN                 7
+#define FTS_ECC_FINISH_TIMEOUT                      100
+#define FTS_ROMBOOT_CMD_ECC_FINISH                  0xCE
+#define FTS_ROMBOOT_CMD_ECC_FINISH_OK_A5            0xA5
+#define FTS_ROMBOOT_CMD_ECC_FINISH_OK_00            0x00
+#define FTS_ROMBOOT_CMD_ECC_READ                    0xCD
+#define AL2_FCS_COEF                ((1 << 15) + (1 << 10) + (1 << 3))
+
+#define FTS_APP_INFO_OFFSET                         0x100
+
+enum FW_STATUS {
+    FTS_RUN_IN_ERROR,
+    FTS_RUN_IN_APP,
+    FTS_RUN_IN_ROM,
+    FTS_RUN_IN_PRAM,
+    FTS_RUN_IN_BOOTLOADER,
+};
+
+enum FW_FLASH_MODE {
+    FLASH_MODE_APP,
+    FLASH_MODE_LIC,
+    FLASH_MODE_PARAM,
+    FLASH_MODE_ALL,
+};
+
+enum ECC_CHECK_MODE {
+    ECC_CHECK_MODE_XOR,
+    ECC_CHECK_MODE_CRC16,
+};
+
+enum UPGRADE_SPEC {
+    UPGRADE_SPEC_V_1_0 = 0x0100,
+    UPGRADE_SPEC_V_1_1 = 0x0101,
+    UPGRADE_SPEC_V_1_2 = 0x0102,
+};
+
+
+enum FW_TYPE {
+    FW_AUTO,
+    FW_GESTURE,
+    FW_NORMAL,
+};
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+/* IC info */
+struct upgrade_func {
+    u16 ctype[FTS_MAX_COMPATIBLE_TYPE];
+    u32 fwveroff;
+    u32 fwcfgoff;
+    u32 appoff;
+    u32 licoff;
+    u32 paramcfgoff;
+    u32 paramcfgveroff;
+    u32 paramcfg2off;
+    int pram_ecc_check_mode;
+    int fw_ecc_check_mode;
+    int upgspec_version;
+    bool new_return_value_from_ic;
+    bool appoff_handle_in_ic;
+    bool is_reset_register_BC;
+    bool read_boot_id_need_reset;
+    bool hid_supported;
+    bool pramboot_supported;
+    u8 *pramboot;
+    u32 pb_length;
+    int (*init)(u8 *, u32);
+    int (*write_pramboot_private)(void);
+    int (*upgrade)(u8 *, u32);
+    int (*get_hlic_ver)(u8 *);
+    int (*lic_upgrade)(u8 *, u32);
+    int (*param_upgrade)(u8 *, u32);
+    int (*force_upgrade)(u8 *, u32);
+};
+
+struct upgrade_setting_nf {
+    u8 rom_idh;
+    u8 rom_idl;
+    u16 reserved;
+    u32 app2_offset;
+    u32 ecclen_max;
+    u8 eccok_val;
+    u8 upgsts_boot;
+    u8 delay_init;
+    u8 spi_pe;
+    u8 length_coefficient;
+    u8 fd_check;
+    u8 drwr_support;
+    u8 ecc_delay;
+};
+
+struct upgrade_module {
+    int id;
+    char vendor_name[MAX_MODULE_VENDOR_NAME_LEN];
+    u8 *fw_file;
+    u32 fw_len;
+};
+
+struct fts_upgrade {
+    struct fts_ts_data *ts_data;
+    struct upgrade_module *module_info;
+    struct upgrade_func *func;
+    struct upgrade_setting_nf *setting_nf;
+    struct work_struct fwupg_work;
+    struct work_struct fwload_work;
+    struct work_struct fwrecover_work;
+    int module_id;
+    bool fw_from_request;
+    u8 *fw;
+    u32 fw_length;
+    u8 *lic;
+    u32 lic_length;
+};
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+extern struct upgrade_func upgrade_func_ft8205p;
+
+
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+int fts_fwupg_reset_in_boot(void);
+int fts_fwupg_enter_into_boot(void);
+int fts_fwupg_hwrst_to_boot(void);
+int fts_fwupg_erase(u32 delay);
+int fts_fwupg_ecc_cal(u32 saddr, u32 len);
+int fts_flash_write_buf(u32 saddr, u8 *buf, u32 len, u32 delay);
+int fts_flash_read_buf(u32 saddr, u8 *buf, u32 len);
+int fts_fwupg_upgrade(struct fts_upgrade *upg);
+#endif
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_flash/focaltech_upgrade_ft8201p.c b/drivers/input/touchscreen/focaltech_touch/focaltech_flash/focaltech_upgrade_ft8201p.c
new file mode 100755
index 000000000000..c0ceee5b423a
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_flash/focaltech_upgrade_ft8201p.c
@@ -0,0 +1,331 @@
+/*
+ *
+ * FocalTech fts TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_upgrade_ft8205p.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2020-11-06
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "../focaltech_flash.h"
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+u8 pb_file_ft8205p[] = {
+#include "../include/pramboot/FT8205P_Pramboot_V1.0_20231226.bin"
+};
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define LIC_FS_H_OFF                2
+#define LIC_FS_L_OFF                3
+#define LIC_CHECKSUM_H_OFF          0
+#define LIC_CHECKSUM_L_OFF          1
+
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+/* calculate lcd init code checksum */
+static u16 cal_lcdinitcode_checksum(u8 *ptr , int length)
+{
+    /* CRC16 */
+    u16 cfcs = 0;
+    int i = 0;
+    int j = 0;
+
+    if (length % 2) {
+        return 0xFFFF;
+    }
+
+    for (i = 0; i < length; i += 2) {
+        cfcs ^= (((u16)ptr[i] << 8) + ptr[i + 1]);
+        for (j = 0; j < 16; j++) {
+            if (cfcs & 1) {
+                cfcs = (u16)((cfcs >> 1) ^ ((1 << 15) + (1 << 10) + (1 << 3)));
+            } else {
+                cfcs >>= 1;
+            }
+        }
+    }
+    return cfcs;
+}
+
+/*
+ * check_initial_code_valid - check initial code valid or not
+ */
+static int check_initial_code_valid(u8 *buf)
+{
+    u16 initcode_checksum = 0;
+    u16 buf_checksum = 0;
+    u16 hlic_len = 0;
+
+    hlic_len = (u16)(((u16)buf[LIC_FS_H_OFF]) << 8) + buf[LIC_FS_L_OFF] + 2;
+    FTS_INFO("host lcd init code len:0x%x", hlic_len);
+    if ((hlic_len >= FTS_MAX_LEN_SECTOR) || (hlic_len <= 0)) {
+        FTS_ERROR("host lcd init code len(0x%x) invalid", hlic_len);
+        return -EINVAL;
+    }
+    initcode_checksum = cal_lcdinitcode_checksum(buf + 2, hlic_len - 2);
+    buf_checksum =
+        ((u16)((u16)buf[LIC_CHECKSUM_H_OFF] << 8) + buf[LIC_CHECKSUM_L_OFF]);
+    FTS_INFO("lcd init code calc checksum:0x%04x,0x%04x",
+             initcode_checksum, buf_checksum);
+    if (initcode_checksum != buf_checksum) {
+        FTS_ERROR("Initial Code checksum fail");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int fts_ft8205p_get_hlic_ver(u8 *initcode)
+{
+    u8 *hlic_buf = initcode;
+    u16 hlic_len = 0;
+    u8 hlic_ver[2] = { 0 };
+
+    hlic_len =
+        (u16)(((u16)hlic_buf[LIC_FS_H_OFF]) << 8) + hlic_buf[LIC_FS_L_OFF] + 2;
+    FTS_INFO("host lcd init code len:0x%x", hlic_len);
+    if ((hlic_len >= FTS_MAX_LEN_SECTOR) || (hlic_len <= 0)) {
+        FTS_ERROR("host lcd init code len(0x%x) invalid", hlic_len);
+        return -EINVAL;
+    }
+
+    hlic_ver[0] = hlic_buf[hlic_len];
+    hlic_ver[1] = hlic_buf[hlic_len + 1];
+
+    FTS_INFO("host lcd init code ver:0x%x 0x%x", hlic_ver[0], hlic_ver[1]);
+    if (0xFF != (hlic_ver[0] + hlic_ver[1])) {
+        FTS_ERROR("host lcd init code version check fail");
+        return -EINVAL;
+    }
+
+    return hlic_ver[0];
+}
+
+static int fts_ft8205p_upgrade_mode(enum FW_FLASH_MODE mode, u8 *buf, u32 len)
+{
+    int ret = 0;
+    u32 start_addr = 0;
+    u8 cmd[4] = { 0 };
+    u32 delay = 0;
+    int ecc_in_host = 0;
+    int ecc_in_tp = 0;
+
+    if ((NULL == buf) || (len < FTS_MIN_LEN)) {
+        FTS_ERROR("buffer/len(%x) is invalid", len);
+        return -EINVAL;
+    }
+
+    /* enter into upgrade environment */
+    ret = fts_fwupg_enter_into_boot();
+    if (ret < 0) {
+        FTS_ERROR("enter into pramboot/bootloader fail,ret=%d", ret);
+        goto fw_reset;
+    }
+
+    cmd[0] = FTS_CMD_FLASH_MODE;
+    cmd[1] = FLASH_MODE_UPGRADE_VALUE;
+    if (upgrade_func_ft8205p.appoff_handle_in_ic) {
+        start_addr = 0; /* offset handle in pramboot */
+    } else {
+        start_addr = upgrade_func_ft8205p.appoff;
+    }
+    if (FLASH_MODE_LIC == mode) {
+        /* lcd initial code upgrade */
+        cmd[1] = FLASH_MODE_LIC_VALUE;
+    } else if (FLASH_MODE_PARAM == mode) {
+        cmd[1] = FLASH_MODE_PARAM_VALUE;
+    }
+    FTS_INFO("flash mode:0x%02x, start addr=0x%04x", cmd[1], start_addr);
+
+    ret = fts_write(cmd, 2);
+    if (ret < 0) {
+        FTS_ERROR("upgrade mode(09) cmd write fail");
+        goto fw_reset;
+    }
+
+    cmd[0] = FTS_CMD_APP_DATA_LEN_INCELL;
+    cmd[1] = BYTE_OFF_16(len);
+    cmd[2] = BYTE_OFF_8(len);
+    cmd[3] = BYTE_OFF_0(len);
+    ret = fts_write(cmd, FTS_CMD_DATA_LEN_LEN);
+    if (ret < 0) {
+        FTS_ERROR("data len cmd write fail");
+        goto fw_reset;
+    }
+
+    delay = FTS_ERASE_SECTOR_DELAY * (len / FTS_MAX_LEN_SECTOR);
+    ret = fts_fwupg_erase(delay);
+    if (ret < 0) {
+        FTS_ERROR("erase cmd write fail");
+        goto fw_reset;
+    }
+
+    /* write app */
+    ecc_in_host = fts_flash_write_buf(start_addr, buf, len, 1);
+    if (ecc_in_host < 0 ) {
+        FTS_ERROR("flash write fail");
+        goto fw_reset;
+    }
+
+    /* ecc */
+    ecc_in_tp = fts_fwupg_ecc_cal(start_addr, len);
+    if (ecc_in_tp < 0 ) {
+        FTS_ERROR("ecc read fail");
+        goto fw_reset;
+    }
+
+    FTS_INFO("ecc in tp:%x, host:%x", ecc_in_tp, ecc_in_host);
+    if (ecc_in_tp != ecc_in_host) {
+        FTS_ERROR("ecc check fail");
+        goto fw_reset;
+    }
+
+    FTS_INFO("upgrade success, reset to normal boot");
+    ret = fts_fwupg_reset_in_boot();
+    if (ret < 0) {
+        FTS_ERROR("reset to normal boot fail");
+    }
+
+    fts_msleep(400);
+    return 0;
+
+fw_reset:
+    return -EIO;
+}
+
+/************************************************************************
+* Name: fts_ft8205p_upgrade
+* Brief:
+* Input:
+* Output:
+* Return: return 0 if success, otherwise return error code
+***********************************************************************/
+static int fts_ft8205p_upgrade(u8 *buf, u32 len)
+{
+    int ret = 0;
+    u8 *tmpbuf = NULL;
+    u32 app_len = 0;
+
+    FTS_INFO("fw app upgrade...");
+    if (NULL == buf) {
+        FTS_ERROR("fw buf is null");
+        return -EINVAL;
+    }
+
+    if ((len < FTS_MIN_LEN) || (len > FTS_MAX_LEN_FILE)) {
+        FTS_ERROR("fw buffer len(%x) fail", len);
+        return -EINVAL;
+    }
+
+    app_len = len - upgrade_func_ft8205p.appoff;
+    tmpbuf = buf + upgrade_func_ft8205p.appoff;
+    ret = fts_ft8205p_upgrade_mode(FLASH_MODE_APP, tmpbuf, app_len);
+    if (ret < 0) {
+        FTS_INFO("fw upgrade fail,reset to normal boot");
+        if (fts_fwupg_reset_in_boot() < 0) {
+            FTS_ERROR("reset to normal boot fail");
+        }
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fts_ft8205p_lic_upgrade(u8 *buf, u32 len)
+{
+    int ret = 0;
+    u8 *tmpbuf = NULL;
+    u32 lic_len = 0;
+
+    FTS_INFO("lcd initial code upgrade...");
+    if (NULL == buf) {
+        FTS_ERROR("lcd initial code buffer is null");
+        return -EINVAL;
+    }
+
+    if ((len < FTS_MIN_LEN) || (len > FTS_MAX_LEN_FILE)) {
+        FTS_ERROR("lcd initial code buffer len(%x) fail", len);
+        return -EINVAL;
+    }
+
+    ret = check_initial_code_valid(buf);
+    if (ret < 0) {
+        FTS_ERROR("initial code invalid, not upgrade lcd init code");
+        return -EINVAL;
+    }
+
+    /* remalloc memory for initcode, need change content of initcode afterwise */
+    lic_len = FTS_MAX_LEN_SECTOR;
+    tmpbuf = kzalloc(lic_len, GFP_KERNEL);
+    if (NULL == tmpbuf) {
+        FTS_ERROR("initial code buf malloc fail");
+        return -EINVAL;
+    }
+    memcpy(tmpbuf, buf, lic_len);
+
+    ret = fts_ft8205p_upgrade_mode(FLASH_MODE_LIC, tmpbuf, lic_len);
+    if (ret < 0) {
+        FTS_INFO("lcd initial code upgrade fail,reset to normal boot");
+        if (fts_fwupg_reset_in_boot() < 0) {
+            FTS_ERROR("reset to normal boot fail");
+        }
+        if (tmpbuf) {
+            kfree(tmpbuf);
+            tmpbuf = NULL;
+        }
+        return ret;
+    }
+
+    if (tmpbuf) {
+        kfree(tmpbuf);
+        tmpbuf = NULL;
+    }
+    return 0;
+}
+
+struct upgrade_func upgrade_func_ft8205p = {
+    .ctype = {0x2C},
+    .fwveroff = 0x110E,
+    .fwcfgoff = 0x0F80,
+    .appoff = 0x1000,
+    .appoff_handle_in_ic = true,
+    .upgspec_version = UPGRADE_SPEC_V_1_0,
+    .pramboot_supported = true,
+    .pramboot = pb_file_ft8205p,
+    .pb_length = sizeof(pb_file_ft8205p),
+    .upgrade = fts_ft8205p_upgrade,
+    .get_hlic_ver = fts_ft8205p_get_hlic_ver,
+    .lic_upgrade = fts_ft8205p_lic_upgrade,
+};
+
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_flash_spi.c b/drivers/input/touchscreen/focaltech_touch/focaltech_flash_spi.c
new file mode 100755
index 000000000000..b69ffec50051
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_flash_spi.c
@@ -0,0 +1,1427 @@
+/*
+ *
+ * FocalTech fts TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_flash.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2017-12-06
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+#include "focaltech_flash.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_FW_REQUEST_SUPPORT                      1
+/* Example: focaltech_ts_fw_tianma.bin */
+#define FTS_FW_NAME_PREX_WITH_REQUEST               "focaltech_ts_fw_"
+#define FTS_READ_BOOT_ID_TIMEOUT                    3
+#define FTS_FLASH_PACKET_LENGTH_SPI_LOW             (4 * 1024 - 4)
+#define FTS_FLASH_PACKET_LENGTH_SPI                 (32 * 1024 - 16)
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+u8 fw_file[] = {
+#include FTS_UPGRADE_FW_FILE
+};
+
+u8 fw_file2[] = {
+#include FTS_UPGRADE_FW2_FILE
+};
+
+u8 fw_file3[] = {
+#include FTS_UPGRADE_FW3_FILE
+};
+
+struct upgrade_module module_list[] = {
+    {FTS_MODULE_ID, FTS_MODULE_NAME, fw_file, sizeof(fw_file)},
+    {FTS_MODULE2_ID, FTS_MODULE2_NAME, fw_file2, sizeof(fw_file2)},
+    {FTS_MODULE3_ID, FTS_MODULE3_NAME, fw_file3, sizeof(fw_file3)},
+};
+
+struct upgrade_setting_nf upgrade_setting_list[] = {
+    {0x87, 0x19, 0, (64 * 1024),  (128 * 1024), 0x00, 0x02, 8,  1, 1, 1, 0, 0},
+    {0x86, 0x22, 0, (64 * 1024),  (128 * 1024), 0x00, 0x02, 8,  1, 1, 0, 0, 0},
+    {0x87, 0x56, 0, (88 * 1024),  32766,        0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x80, 0x09, 0, (88 * 1024),  32766,        0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x86, 0x32, 0, (64 * 1024),  (128 * 1024), 0xA5, 0x01, 12, 0, 1, 0, 0, 0},
+    {0x86, 0x42, 0, (64 * 1024),  (128 * 1024), 0xA5, 0x01, 12, 0, 1, 0, 0, 0},
+    {0x87, 0x20, 0, (88 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x87, 0x22, 0, (88 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x82, 0x01, 0, (96 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 0, 0},
+    {0xF0, 0xC6, 0, (84 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x56, 0x62, 0, (128 * 1024), (128 * 1024), 0xA5, 0x01, 8,  0, 4, 0, 0, 5},
+    {0x82, 0x05, 0, (120 * 1024), (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 0, 0},
+    {0x80, 0x57, 0, (84 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x80, 0xC7, 0, (84 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x23, 0x89, 0, (88 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x87, 0x25, 0, (88 * 1024),  (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 1, 0},
+    {0x82, 0x06, 0, (128 * 1024), (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 0, 0},
+    {0x82, 0xC5, 0, (128 * 1024), (128 * 1024), 0xA5, 0x01, 8,  0, 2, 0, 0, 0},
+};
+
+struct fts_upgrade *fwupgrade;
+
+static int fts_check_bootid(void)
+{
+    int ret = 0;
+    u8 cmd = 0;
+    u8 id[2] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+    struct ft_chip_t *chip_id;
+
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    chip_id = &upg->ts_data->ic_info.ids;
+
+    cmd = FTS_CMD_READ_ID;
+    ret = fts_read(&cmd, 1, id, 2);
+    if (ret < 0) {
+        FTS_ERROR("read boot id(0x%02x 0x%02x) fail", id[0], id[1]);
+        return ret;
+    }
+
+    FTS_INFO("read boot id:0x%02x 0x%02x", id[0], id[1]);
+    if ((chip_id->rom_idh == id[0]) && (chip_id->rom_idl == id[1])) {
+        return 0;
+    }
+
+    return -EIO;
+}
+
+static int fts_enter_into_boot(void)
+{
+    int ret = 0;
+    int i = 0;
+    int j = 0;
+    u8 cmd[2] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    FTS_INFO("enter into boot environment");
+    for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+        /* hardware tp reset to boot */
+        fts_reset_proc(upg->ts_data, true, 0);
+        mdelay(upg->setting_nf->delay_init + i * 2);
+        /* enter into boot & check boot id*/
+        for (j = 0; j < FTS_READ_BOOT_ID_TIMEOUT; j++) {
+            cmd[0] = FTS_CMD_START1;
+            ret = fts_write(cmd, 1);
+            if (ret >= 0) {
+                fts_msleep(upg->setting_nf->delay_init);
+                ret = fts_check_bootid();
+                if (0 == ret) {
+                    FTS_INFO("boot id check pass, retry=%d", i);
+                    return 0;
+                }
+            }
+        }
+    }
+
+    return -EIO;
+}
+
+static bool fts_check_fast_download(void)
+{
+    int ret = 0;
+    u8 cmd[6] = {0xF2, 0x00, 0x78, 0x0A, 0x00, 0x02};
+    u8 value = 0;
+    u8 value2[2] = { 0 };
+
+    ret = fts_read_reg(0xdb, &value);
+    if (ret < 0) {
+        FTS_ERROR("read 0xdb fail");
+        goto read_err;
+    }
+
+    ret = fts_read(cmd, 6, value2, 2);
+    if (ret < 0) {
+        FTS_ERROR("read f2 fail");
+        goto read_err;
+    }
+
+    FTS_INFO("0xdb = 0x%x, 0xF2 = 0x%x", value, value2[0]);
+    if ((value >= 0x18) && (value2[0] == 0x55)) {
+        FTS_INFO("IC support fast-download");
+        return true;
+    }
+
+read_err:
+    FTS_INFO("IC not support fast-download");
+    return false;
+}
+
+static int fts_dpram_write_pe(u32 saddr, const u8 *buf, u32 len, bool wpram)
+{
+    int ret = 0;
+    int i = 0;
+    int j = 0;
+    u8 *cmd = NULL;
+    u32 addr = 0;
+    u32 offset = 0;
+    u32 remainder = 0;
+    u32 packet_number = 0;
+    u32 packet_len = 0;
+    u32 packet_size = FTS_FLASH_PACKET_LENGTH_SPI;
+    bool fd_support = true;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("dpram write");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (!buf) {
+        FTS_ERROR("fw buf is null");
+        return -EINVAL;
+    }
+
+    if ((len < FTS_MIN_LEN) || (len > upg->setting_nf->app2_offset)) {
+        FTS_ERROR("fw length(%d) fail", len);
+        return -EINVAL;
+    }
+
+    if (upg->setting_nf->fd_check) {
+        fd_support = fts_check_fast_download();
+        if (!fd_support)
+            packet_size = FTS_FLASH_PACKET_LENGTH_SPI_LOW;
+    }
+
+    cmd = vmalloc(packet_size + FTS_CMD_WRITE_LEN + 1);
+    if (NULL == cmd) {
+        FTS_ERROR("malloc memory for pram write buffer fail");
+        return -ENOMEM;
+    }
+    memset(cmd, 0, packet_size + FTS_CMD_WRITE_LEN + 1);
+
+    packet_number = len / packet_size;
+    remainder = len % packet_size;
+    if (remainder > 0)
+        packet_number++;
+    packet_len = packet_size;
+    FTS_INFO("write data, num:%d remainder:%d", packet_number, remainder);
+
+    cmd[0] = FTS_ROMBOOT_CMD_WRITE;
+    for (i = 0; i < packet_number; i++) {
+        offset = i * packet_size;
+        addr = saddr + offset;
+        cmd[1] = BYTE_OFF_16(addr);
+        cmd[2] = BYTE_OFF_8(addr);
+        cmd[3] = BYTE_OFF_0(addr);
+
+        /* last packet */
+        if ((i == (packet_number - 1)) && remainder)
+            packet_len = remainder;
+        cmd[4] = BYTE_OFF_8(packet_len);
+        cmd[5] = BYTE_OFF_0(packet_len);
+
+        for (j = 0; j < packet_len; j++) {
+            cmd[FTS_CMD_WRITE_LEN + j] = buf[offset + j];
+        }
+
+        ret = fts_write(&cmd[0], FTS_CMD_WRITE_LEN + packet_len);
+        if (ret < 0) {
+            FTS_ERROR("write fw to pram(%d) fail", i);
+            goto write_pram_err;
+        }
+
+        if (!fd_support)
+            fts_msleep(3);
+    }
+
+write_pram_err:
+    if (cmd) {
+        vfree(cmd);
+        cmd = NULL;
+    }
+    return ret;
+}
+
+static int fts_dpram_write(u32 saddr, const u8 *buf, u32 len, bool wpram)
+{
+    int ret = 0;
+    int i = 0;
+    int j = 0;
+    u8 *cmd = NULL;
+    u32 addr = 0;
+    u32 baseaddr = wpram ? FTS_PRAM_SADDR : FTS_DRAM_SADDR;
+    u32 offset = 0;
+    u32 remainder = 0;
+    u32 packet_number = 0;
+    u32 packet_len = 0;
+    u32 packet_size = FTS_FLASH_PACKET_LENGTH_SPI;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("dpram write");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (!buf) {
+        FTS_ERROR("fw buf is null");
+        return -EINVAL;
+    }
+
+    if ((len < FTS_MIN_LEN) || (len > upg->setting_nf->app2_offset)) {
+        FTS_ERROR("fw length(%d) fail", len);
+        return -EINVAL;
+    }
+
+    cmd = vmalloc(packet_size + FTS_CMD_WRITE_LEN + 1);
+    if (NULL == cmd) {
+        FTS_ERROR("malloc memory for pram write buffer fail");
+        return -ENOMEM;
+    }
+    memset(cmd, 0, packet_size + FTS_CMD_WRITE_LEN + 1);
+
+    packet_number = len / packet_size;
+    remainder = len % packet_size;
+    if (remainder > 0)
+        packet_number++;
+    packet_len = packet_size;
+    FTS_INFO("write data, num:%d remainder:%d", packet_number, remainder);
+
+    for (i = 0; i < packet_number; i++) {
+        offset = i * packet_size;
+        addr = saddr + offset + baseaddr;
+        /* last packet */
+        if ((i == (packet_number - 1)) && remainder)
+            packet_len = remainder;
+
+        /* set pram address */
+        cmd[0] = FTS_ROMBOOT_CMD_SET_PRAM_ADDR;
+        cmd[1] = BYTE_OFF_16(addr);
+        cmd[2] = BYTE_OFF_8(addr);
+        cmd[3] = BYTE_OFF_0(addr);
+        ret = fts_write(&cmd[0], FTS_ROMBOOT_CMD_SET_PRAM_ADDR_LEN);
+        if (ret < 0) {
+            FTS_ERROR("set pram(%d) addr(%d) fail", i, addr);
+            goto write_pram_err;
+        }
+
+        /* write pram data */
+        cmd[0] = FTS_ROMBOOT_CMD_WRITE;
+        for (j = 0; j < packet_len; j++) {
+            cmd[1 + j] = buf[offset + j];
+        }
+        ret = fts_write(&cmd[0], 1 + packet_len);
+        if (ret < 0) {
+            FTS_ERROR("write fw to pram(%d) fail", i);
+            goto write_pram_err;
+        }
+    }
+
+write_pram_err:
+    if (cmd) {
+        vfree(cmd);
+        cmd = NULL;
+    }
+    return ret;
+}
+
+static int fts_ecc_cal_tp(u32 ecc_saddr, u32 ecc_len, u16 *ecc_value)
+{
+    int ret = 0;
+    int i = 0;
+    u8 cmd[FTS_ROMBOOT_CMD_ECC_NEW_LEN] = { 0 };
+    u8 value[2] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("ecc calc in tp");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    cmd[0] = FTS_ROMBOOT_CMD_ECC;
+    cmd[1] = BYTE_OFF_16(ecc_saddr);
+    cmd[2] = BYTE_OFF_8(ecc_saddr);
+    cmd[3] = BYTE_OFF_0(ecc_saddr);
+    cmd[4] = BYTE_OFF_16(ecc_len);
+    cmd[5] = BYTE_OFF_8(ecc_len);
+    cmd[6] = BYTE_OFF_0(ecc_len);
+
+    /* make boot to calculate ecc in pram */
+    ret = fts_write(cmd, FTS_ROMBOOT_CMD_ECC_NEW_LEN);
+    if (ret < 0) {
+        FTS_ERROR("ecc calc cmd fail");
+        return ret;
+    }
+    fts_msleep(2);
+
+    /* wait boot calculate ecc finish */
+    if (upg->setting_nf->ecc_delay) {
+        fts_msleep(upg->setting_nf->ecc_delay);
+    } else {
+        cmd[0] = FTS_ROMBOOT_CMD_ECC_FINISH;
+        for (i = 0; i < FTS_ECC_FINISH_TIMEOUT; i++) {
+            ret = fts_read(cmd, 1, value, 1);
+            if (ret < 0) {
+                FTS_ERROR("ecc finish cmd fail");
+                return ret;
+            }
+            if (upg->setting_nf->eccok_val == value[0])
+                break;
+            fts_msleep(1);
+        }
+        if (i >= FTS_ECC_FINISH_TIMEOUT) {
+            FTS_ERROR("wait ecc finish timeout,ecc_finish=%x", value[0]);
+            return -EIO;
+        }
+    }
+
+    /* get ecc value calculate in boot */
+    cmd[0] = FTS_ROMBOOT_CMD_ECC_READ;
+    ret = fts_read(cmd, 1, value, 2);
+    if (ret < 0) {
+        FTS_ERROR("ecc read cmd fail");
+        return ret;
+    }
+
+    *ecc_value = ((u16)(value[0] << 8) + value[1]) & 0x0000FFFF;
+    return 0;
+}
+
+static int fts_ecc_cal_host(const u8 *data, u32 data_len, u16 *ecc_value)
+{
+    u16 ecc = 0;
+    u32 i = 0;
+    u32 j = 0;
+    u16 al2_fcs_coef = AL2_FCS_COEF;
+
+    for (i = 0; i < data_len; i += 2 ) {
+        ecc ^= ((data[i] << 8) | (data[i + 1]));
+        for (j = 0; j < 16; j ++) {
+            if (ecc & 0x01)
+                ecc = (u16)((ecc >> 1) ^ al2_fcs_coef);
+            else
+                ecc >>= 1;
+        }
+    }
+
+    *ecc_value = ecc & 0x0000FFFF;
+    return 0;
+}
+
+static int fts_ecc_check(const u8 *buf, u32 len, u32 ecc_saddr)
+{
+    int ret = 0;
+    int i = 0;
+    u16 ecc_in_host = 0;
+    u16 ecc_in_tp = 0;
+    int packet_length = 0;
+    int packet_number = 0;
+    int packet_remainder = 0;
+    int offset = 0;
+    u32 packet_size = FTS_MAX_LEN_FILE;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("ecc check");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (upg->setting_nf->ecclen_max) {
+        packet_size = upg->setting_nf->ecclen_max;
+    }
+
+    packet_number = len / packet_size;
+    packet_remainder = len % packet_size;
+    if (packet_remainder)
+        packet_number++;
+    packet_length = packet_size;
+
+    for (i = 0; i < packet_number; i++) {
+        /* last packet */
+        if ((i == (packet_number - 1)) && packet_remainder)
+            packet_length = packet_remainder;
+
+        ret = fts_ecc_cal_host(buf + offset, packet_length, &ecc_in_host);
+        if (ret < 0) {
+            FTS_ERROR("ecc in host calc fail");
+            return ret;
+        }
+
+        ret = fts_ecc_cal_tp(ecc_saddr + offset, packet_length, &ecc_in_tp);
+        if (ret < 0) {
+            FTS_ERROR("ecc in tp calc fail");
+            return ret;
+        }
+
+        FTS_DEBUG("ecc in tp:%04x,host:%04x,i:%d", ecc_in_tp, ecc_in_host, i);
+        if (ecc_in_tp != ecc_in_host) {
+            FTS_ERROR("ecc_in_tp(%x) != ecc_in_host(%x), ecc check fail",
+                      ecc_in_tp, ecc_in_host);
+            return -EIO;
+        }
+
+        offset += packet_length;
+    }
+
+    return 0;
+}
+
+static int fts_pram_write_ecc(const u8 *buf, u32 len)
+{
+    int ret = 0;
+    u32 pram_app_size = 0;
+    u16 code_len = 0;
+    u16 code_len_n = 0;
+    u32 pram_start_addr = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("begin to write pram app(bin len:%d)", len);
+    if (!upg || !upg->setting_nf) {
+        FTS_ERROR("upgrade/setting_nf is null");
+        return -EINVAL;
+    }
+
+    /* get pram app length */
+    code_len = ((u16)buf[FTS_APP_INFO_OFFSET + 0] << 8)
+               + buf[FTS_APP_INFO_OFFSET + 1];
+    code_len_n = ((u16)buf[FTS_APP_INFO_OFFSET + 2] << 8)
+                 + buf[FTS_APP_INFO_OFFSET + 3];
+    if ((code_len + code_len_n) != 0xFFFF) {
+        FTS_ERROR("pram code len(%x %x) fail", code_len, code_len_n);
+        return -EINVAL;
+    }
+
+    pram_app_size = ((u32)code_len) * upg->setting_nf->length_coefficient;
+    FTS_INFO("pram app length in fact:%d", pram_app_size);
+
+    /* write pram */
+    if (upg->setting_nf->spi_pe)
+        ret = fts_dpram_write_pe(pram_start_addr, buf, pram_app_size, true);
+    else
+        ret = fts_dpram_write(pram_start_addr, buf, pram_app_size, true);
+    if (ret < 0) {
+        FTS_ERROR("write pram fail");
+        return ret;
+    }
+
+    /* check ecc */
+    ret = fts_ecc_check(buf, pram_app_size, pram_start_addr);
+    if (ret < 0) {
+        FTS_ERROR("pram ecc check fail");
+        return ret;
+    }
+
+    FTS_INFO("pram app write successfully");
+    return 0;
+}
+
+static int fts_dram_write_ecc(const u8 *buf, u32 len)
+{
+    int ret = 0;
+    u32 dram_size = 0;
+    u32 pram_app_size = 0;
+    u32 dram_start_addr = 0;
+    u16 const_len = 0;
+    u16 const_len_n = 0;
+    const u8 *dram_buf = NULL;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("begin to write dram data(bin len:%d)", len);
+    if (!upg || !upg->setting_nf) {
+        FTS_ERROR("upgrade/setting_nf is null");
+        return -EINVAL;
+    }
+
+    /* get dram data length */
+    const_len = ((u16)buf[FTS_APP_INFO_OFFSET + 0x8] << 8)
+                + buf[FTS_APP_INFO_OFFSET + 0x9];
+    const_len_n = ((u16)buf[FTS_APP_INFO_OFFSET + 0x0A] << 8)
+                  + buf[FTS_APP_INFO_OFFSET + 0x0B];
+    if (((const_len + const_len_n) != 0xFFFF) || (const_len == 0)) {
+        FTS_INFO("no support dram,const len(%x %x)", const_len, const_len_n);
+        return 0;
+    }
+
+    dram_size = ((u32)const_len) * upg->setting_nf->length_coefficient;
+    pram_app_size = ((u32)(((u16)buf[FTS_APP_INFO_OFFSET + 0] << 8)
+                           + buf[FTS_APP_INFO_OFFSET + 1]));
+    pram_app_size = pram_app_size * upg->setting_nf->length_coefficient;
+
+    dram_buf = buf + pram_app_size;
+    FTS_INFO("dram buf length in fact:%d,offset:%d", dram_size, pram_app_size);
+    /* write pram */
+    ret = fts_dpram_write(dram_start_addr, dram_buf, dram_size, false);
+    if (ret < 0) {
+        FTS_ERROR("write dram fail");
+        return ret;
+    }
+
+    /* check ecc */
+    ret = fts_ecc_check(dram_buf, dram_size, dram_start_addr);
+    if (ret < 0) {
+        FTS_ERROR("dram ecc check fail");
+        return ret;
+    }
+
+    FTS_INFO("dram data write successfully");
+    return 0;
+}
+
+static int fts_pram_start(void)
+{
+    int ret = 0;
+    u8 cmd = FTS_ROMBOOT_CMD_START_APP;
+
+    FTS_INFO("remap to start pram");
+    ret = fts_write(&cmd, 1);
+    if (ret < 0) {
+        FTS_ERROR("write start pram cmd fail");
+        return ret;
+    }
+
+    fts_msleep(10);
+    return 0;
+}
+
+/*
+ * description: download fw to IC and run
+ *
+ * param - buf: const, fw data buffer
+ *         len: length of fw
+ *
+ * return 0 if success, otherwise return error code
+ */
+static int fts_fw_write_start(const u8 *buf, u32 len, bool need_reset)
+{
+    int ret = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("begin to write and start fw(bin len:%d)", len);
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    upg->ts_data->fw_is_running = false;
+
+    if (need_reset) {
+        /* enter into boot environment */
+        ret = fts_enter_into_boot();
+        if (ret < 0) {
+            FTS_ERROR("enter into boot environment fail");
+            return ret;
+        }
+    }
+
+    /* write pram */
+    ret = fts_pram_write_ecc(buf, len);
+    if (ret < 0) {
+        FTS_ERROR("write pram fail");
+        return ret;
+    }
+
+    if (upg->setting_nf->drwr_support) {
+        /* write dram */
+        ret = fts_dram_write_ecc(buf, len);
+        if (ret < 0) {
+            FTS_ERROR("write dram fail");
+            return ret;
+        }
+    }
+
+    /* remap pram and run fw */
+    ret = fts_pram_start();
+    if (ret < 0) {
+        FTS_ERROR("pram start fail");
+        return ret;
+    }
+
+    upg->ts_data->fw_is_running = true;
+    FTS_INFO("fw download successfully");
+    return 0;
+}
+
+static int fts_fw_download(const u8 *buf, u32 len, bool need_reset)
+{
+    int ret = 0;
+    int i = 0;
+    int irq_need_recovery = false;
+    int esd_need_recovery = false;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("fw upgrade download function");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (!buf || (len < FTS_MIN_LEN)) {
+        FTS_ERROR("fw/len(%d) is invalid", len);
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    upg->ts_data->fw_loading = 1;
+    if (!upg->ts_data->irq_disabled) {
+        fts_irq_disable();
+        irq_need_recovery = true;
+    }
+    if (fts_esdcheck_is_running(upg->ts_data)) {
+        fts_esdcheck_switch(upg->ts_data, DISABLE);
+        esd_need_recovery = true;
+    }
+
+    for (i = 0; i < 3; i++) {
+        FTS_INFO("fw download times:%d", i + 1);
+        ret = fts_fw_write_start(buf, len, need_reset);
+        if (0 == ret)
+            break;
+    }
+    if (i >= 3) {
+        FTS_ERROR("fw download fail");
+        ret = -EIO;
+        goto err_fw_download;
+    }
+
+    if (esd_need_recovery) fts_esdcheck_switch(upg->ts_data, ENABLE);
+    ret = 0;
+err_fw_download:
+    if (irq_need_recovery) fts_irq_enable();
+    upg->ts_data->fw_loading = 0;
+
+    return ret;
+}
+
+
+static int fts_read_file_default(char *file_name, u8 **file_buf)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
+    int ret = 0;
+    char file_path[FILE_NAME_LENGTH] = { 0 };
+    struct file *filp = NULL;
+    struct inode *inode;
+    mm_segment_t old_fs;
+    loff_t pos;
+    loff_t file_len = 0;
+
+    if ((NULL == file_name) || (NULL == file_buf)) {
+        FTS_ERROR("filename/filebuf is NULL");
+        return -EINVAL;
+    }
+
+    snprintf(file_path, FILE_NAME_LENGTH, "%s%s", FTS_FW_BIN_FILEPATH, file_name);
+    filp = filp_open(file_path, O_RDONLY, 0);
+    if (IS_ERR(filp)) {
+        FTS_ERROR("open %s file fail", file_path);
+        return -ENOENT;
+    }
+
+#if 1
+    inode = filp->f_inode;
+#else
+    /* reserved for linux earlier verion */
+    inode = filp->f_dentry->d_inode;
+#endif
+
+    file_len = inode->i_size;
+    *file_buf = (u8 *)vmalloc(file_len);
+    if (NULL == *file_buf) {
+        FTS_ERROR("file buf malloc fail");
+        filp_close(filp, NULL);
+        return -ENOMEM;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    pos = 0;
+    ret = vfs_read(filp, *file_buf, file_len , &pos);
+    if (ret < 0)
+        FTS_ERROR("read file fail");
+    FTS_INFO("file len:%d read len:%d pos:%d", (u32)file_len, ret, (u32)pos);
+    filp_close(filp, NULL);
+    set_fs(old_fs);
+    return ret;
+#else
+    FTS_INFO("not support vfs_read to get fw file");
+    return -EINVAL;
+#endif
+}
+
+static int fts_read_file_request_firmware(char *file_name, u8 **file_buf)
+{
+#if FTS_FW_REQUEST_SUPPORT
+    int ret = 0;
+    const struct firmware *fw = NULL;
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+    struct fts_upgrade *upg = fwupgrade;
+
+    snprintf(fwname, FILE_NAME_LENGTH, "%s", file_name);
+    ret = request_firmware(&fw, fwname, upg->ts_data->dev);
+    if (0 == ret) {
+        FTS_INFO("firmware(%s) request successfully", fwname);
+        *file_buf = vmalloc(fw->size);
+        if (NULL == *file_buf) {
+            FTS_ERROR("fw buffer vmalloc fail");
+            ret = -ENOMEM;
+        } else {
+            memcpy(*file_buf, fw->data, fw->size);
+            ret = fw->size;
+        }
+    } else {
+        FTS_INFO("firmware(%s) request fail,ret=%d", fwname, ret);
+        ret = -EIO;
+    }
+
+    if (fw != NULL) {
+        release_firmware(fw);
+        fw = NULL;
+    }
+
+    return ret;
+#else
+    FTS_INFO("not support request_firmware to get fw file");
+    return -EINVAL;
+#endif
+}
+
+static int fts_read_file(char *file_name, u8 **file_buf)
+{
+    int ret = 0;
+
+    ret = fts_read_file_request_firmware(file_name, file_buf);
+    if (ret < 0) {
+        ret = fts_read_file_default(file_name, file_buf);
+        if (ret < 0) {
+            FTS_INFO("get fw file(default) abnormal");
+            return ret;
+        }
+    }
+
+    return ret;
+}
+
+int fts_upgrade_bin(char *fw_name, bool force)
+{
+    int ret = 0;
+    u32 fw_file_len = 0;
+    u8 *fw_file_buf = NULL;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("start upgrade with fw bin");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    ret = fts_read_file(fw_name, &fw_file_buf);
+    if ((ret < 0) || (ret < FTS_MIN_LEN)) {
+        FTS_ERROR("read fw bin file(%s) fail, len:%d", fw_name, ret);
+        goto err_bin;
+    }
+
+    fw_file_len = ret;
+    FTS_INFO("fw bin file len:%d", fw_file_len);
+    ret = fts_fw_download(fw_file_buf, fw_file_len, true);
+    if (ret < 0) {
+        FTS_ERROR("upgrade fw bin failed");
+        goto err_bin;
+    }
+
+    FTS_INFO("upgrade fw bin success");
+
+err_bin:
+    if (fw_file_buf) {
+        vfree(fw_file_buf);
+        fw_file_buf = NULL;
+    }
+    return ret;
+}
+
+
+int fts_enter_test_environment(bool test_state)
+{
+    int ret = 0;
+    u8 detach_flag = 0;
+    u32 app_offset = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("fw test download function");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upgrade/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    if (!upg->fw || (upg->fw_length <= upg->setting_nf->app2_offset)) {
+        FTS_INFO("not multi-app");
+        return 0;
+    }
+
+    if (test_state) {
+        app_offset = upg->setting_nf->app2_offset;
+    }
+
+    /*download firmware*/
+    ret = fts_fw_download(upg->fw + app_offset, upg->fw_length, true);
+    if (ret < 0) {
+        FTS_ERROR("upgrade test FW failed");
+        return ret;
+    }
+
+    fts_msleep(50);
+    ret = fts_read_reg(FTS_REG_FW_MODE, &detach_flag);
+    FTS_INFO("regb4:0x%02x", detach_flag);
+    return 0;
+}
+
+
+static int fts_fw_resume(bool need_reset, enum FW_TYPE fw_type)
+{
+    int ret = 0;
+    struct fts_upgrade *upg = fwupgrade;
+    const struct firmware *fw = NULL;
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+    bool get_fw_i_flag = true;
+    const u8 *fw_buf = NULL;
+    u32 fwlen = 0;
+    u32 app_off = 0;
+
+    FTS_INFO("fw upgrade resume function");
+#if !FTS_AUTO_UPGRADE_EN
+    FTS_INFO("FTS_AUTO_UPGRADE_EN is disabled, not upgrade");
+    return 0;
+#endif
+
+    if (!upg || !upg->fw) {
+        FTS_ERROR("upg/fw is null");
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    if (FTS_FW_REQUEST_SUPPORT) {
+        snprintf(fwname, FILE_NAME_LENGTH, "%s%s.bin", \
+                 FTS_FW_NAME_PREX_WITH_REQUEST, upg->module_info->vendor_name);
+        ret = request_firmware(&fw, fwname, upg->ts_data->dev);
+        if (ret == 0) {
+            FTS_INFO("firmware(%s) request successfully", fwname);
+            fw_buf = fw->data;
+            fwlen = fw->size;
+            get_fw_i_flag = false;
+        } else {
+            FTS_ERROR("%s:firmware(%s) request fail,ret=%d\n",
+                      __func__, fwname, ret);
+        }
+    }
+
+    if (get_fw_i_flag) {
+        FTS_INFO("download fw from bootimage");
+        fw_buf = upg->fw;
+        fwlen = upg->fw_length;
+    }
+
+    if (!fw_buf || (fwlen < FTS_MIN_LEN)) {
+        FTS_ERROR("fw/len(%d) is invalid", fwlen);
+        return -EINVAL;
+    }
+
+    if ((fw_type == FW_GESTURE) ||
+        ((fw_type == FW_AUTO) && upg->ts_data->gesture_support && upg->ts_data->suspended)) {
+        /*Need download gesture firmware*/
+        if (fwlen <= (upg->setting_nf->app2_offset * 2)) {
+            FTS_INFO("not support gesture-app");
+            ret = 0;
+            goto _release_firmware;
+        }
+        FTS_INFO("get gesture-app");
+        app_off = upg->setting_nf->app2_offset * 2;
+    }
+
+    ret = fts_fw_download(fw_buf + app_off, fwlen - app_off, need_reset);
+    if (ret < 0) {
+        FTS_ERROR("upgrade fw(resume) failed");
+        goto _release_firmware;
+    }
+
+    ret = 0;
+_release_firmware:
+    if (FTS_FW_REQUEST_SUPPORT) {
+        if (fw != NULL) {
+            release_firmware(fw);
+            fw = NULL;
+        }
+    }
+
+    return ret;
+}
+
+/* true:fw is normal fw*/
+static bool fts_check_fw_normal(void)
+{
+    int i = 0;
+    int max_retries = FTS_MAX_RETRIES_READID_RESUME;
+    u8 val = 0;
+    u8 boot_state = 0;
+    struct fts_upgrade *upg = fwupgrade;
+    struct ft_chip_t *chip_id = &upg->ts_data->ic_info.ids;
+
+    for (i = 0; i < max_retries; i++) {
+        fts_read_reg(FTS_REG_CHIP_ID, &val);
+        if ((val == chip_id->chip_idh) || (fts_check_cid(upg->ts_data, val) == 0)) {
+            FTS_INFO("TP Ready,Read ID=0x%02x", val);
+#if (FTS_MULTI_FW_NUM > 1)
+            fts_read_reg(FTS_REG_FW_MODE, &val);
+            if ((FW_MODE_FACTORY == val) || (FW_MODE_GESTURE == val)) {
+                FTS_INFO("FW(%x) need upgrade", val);
+                return false;
+            }
+#endif
+            return true;
+        } else {
+            upg->ts_data->fw_is_running = false;
+            fts_read_reg(FTS_CMD_READ_BOOT_STATE, &boot_state);
+            FTS_INFO("Read BOOT state=0x%02x", boot_state);
+            if ((boot_state == upg->setting_nf->upgsts_boot) && (0 == fts_check_bootid())) {
+                FTS_INFO("boot state:0x%x,need upgrade", boot_state);
+                upg->ts_data->fw_is_running = true;
+                return false;
+            }
+            upg->ts_data->fw_is_running = true;
+        }
+
+        if ((i + 1) < max_retries) fts_msleep((i + 1) * 20);
+    }
+
+    return false;
+}
+
+int fts_enter_gesture_fw(void)
+{
+    u8 fw_mode = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_FUNC_ENTER();
+    if (fts_fw_resume(true, FW_GESTURE) == 0) {
+        fts_tp_state_recovery(upg->ts_data);
+        fts_read_reg(FTS_REG_FW_MODE, &fw_mode);
+        FTS_INFO("FW Mode:0x%02x", fw_mode);
+    } else {
+        FTS_ERROR("download gesture firmware failed");
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_enter_normal_fw(void)
+{
+    FTS_FUNC_ENTER();
+    if (fts_check_fw_normal()) {
+        FTS_INFO("FW works normally");
+    } else {
+        if (fts_fw_resume(true, FW_NORMAL) == 0) {
+            fts_wait_tp_to_valid();
+        } else {
+            FTS_ERROR("download normal firmware failed");
+        }
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+/* work thread for TP driver to recover FW when TP FW is lost */
+static void fts_fwrecover_work(struct work_struct *work)
+{
+    u8 boot_state = 0;
+    struct fts_upgrade *upg = container_of(work, struct fts_upgrade, fwrecover_work);
+
+    FTS_FUNC_ENTER();
+    upg->ts_data->fw_is_running = false;
+    fts_read_reg(FTS_CMD_READ_BOOT_STATE, &boot_state);
+    if ((boot_state == upg->setting_nf->upgsts_boot) && (0 == fts_check_bootid())) {
+        FTS_INFO("abnormal situation,to download fw");
+        fts_fw_resume(false, FW_AUTO);
+        fts_tp_state_recovery(upg->ts_data);
+        FTS_INFO("FW recovery pass");
+    }
+    upg->ts_data->fw_is_running = true;
+    FTS_FUNC_EXIT();
+}
+
+int fts_fw_recovery(void)
+{
+    int ret = 0;
+    u8 boot_state = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("check if boot recovery");
+    if (!upg || !upg->ts_data || !upg->setting_nf) {
+        FTS_ERROR("upg/ts_data/setting_nf is null");
+        return -EINVAL;
+    }
+
+    if (!upg->ts_data->ts_workqueue || !upg->fwrecover_work.func) {
+        FTS_ERROR("ts_workqueue/work.func is NULL");
+        return -EINVAL;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return -EINVAL;
+    }
+
+    upg->ts_data->fw_is_running = false;
+    ret = fts_check_bootid();
+    if (ret < 0) {
+        FTS_ERROR("check boot id fail");
+        upg->ts_data->fw_is_running = true;
+        return ret;
+    }
+
+    ret = fts_read_reg(FTS_CMD_READ_BOOT_STATE, &boot_state);
+    if (ret < 0) {
+        FTS_ERROR("read boot state failed, ret=%d", ret);
+        upg->ts_data->fw_is_running = true;
+        return ret;
+    }
+
+    if (boot_state != upg->setting_nf->upgsts_boot) {
+        FTS_INFO("not in boot mode(0x%x),exit", boot_state);
+        upg->ts_data->fw_is_running = true;
+        return -EIO;
+    }
+
+    FTS_INFO("abnormal situation,need download fw");
+    queue_work(upg->ts_data->ts_workqueue, &upg->fwrecover_work);
+    return 0;
+}
+
+/* work thread for LCD driver to call fw loading of TP driver */
+static void fts_fwload_work(struct work_struct *work)
+{
+    u8 chip_id = 0xFF;
+
+    FTS_FUNC_ENTER();
+    fts_fw_resume(true, FW_NORMAL);
+    fts_read_reg(FTS_REG_CHIP_ID, &chip_id);
+    FTS_INFO("read chip id:0x%02x", chip_id);
+    FTS_FUNC_EXIT();
+}
+
+#ifdef IDC_LOADFW_IN_LCD_DRIVER
+/* Only for LCD driver to call, only for IDC chip */
+int fts_load_fw_init(void)
+{
+    struct fts_upgrade *upg = fwupgrade;
+
+    FTS_INFO("LCD driver calls FW loading function of TP driver.");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (!upg->ts_data->ts_workqueue || !upg->fwload_work.func) {
+        FTS_ERROR("ts_workqueue/work.func is NULL, can't upgrade");
+        return -EINVAL;
+    }
+
+    queue_work(upg->ts_data->ts_workqueue, &upg->fwload_work);
+    return 0;
+}
+EXPORT_SYMBOL(fts_load_fw_init);
+#endif
+
+static int fts_fwupg_get_module_info(struct fts_upgrade *upg)
+{
+    int i = 0;
+    struct upgrade_module *info = &module_list[0];
+
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (FTS_GET_MODULE_NUM > 1) {
+        FTS_INFO("module id:%04x", upg->module_id);
+        for (i = 0; i < FTS_GET_MODULE_NUM; i++) {
+            info = &module_list[i];
+            if (upg->module_id == info->id) {
+                FTS_INFO("module id match, get fw file successfully");
+                break;
+            }
+        }
+        if (i >= FTS_GET_MODULE_NUM) {
+            FTS_ERROR("no module id match, don't get file");
+            return -ENODATA;
+        }
+    }
+
+    upg->module_info = info;
+    return 0;
+}
+
+static int fts_get_fw_file_via_request_firmware(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    const struct firmware *fw = NULL;
+    u8 *tmpbuf = NULL;
+    char fwname[FILE_NAME_LENGTH] = { 0 };
+
+    snprintf(fwname, FILE_NAME_LENGTH, "%s%s.bin", \
+             FTS_FW_NAME_PREX_WITH_REQUEST, \
+             upg->module_info->vendor_name);
+
+    ret = request_firmware(&fw, fwname, upg->ts_data->dev);
+    if (0 == ret) {
+        FTS_INFO("firmware(%s) request successfully", fwname);
+        tmpbuf = vmalloc(fw->size);
+        if (NULL == tmpbuf) {
+            FTS_ERROR("fw buffer vmalloc fail");
+            ret = -ENOMEM;
+        } else {
+            memcpy(tmpbuf, fw->data, fw->size);
+            upg->fw = tmpbuf;
+            upg->fw_length = fw->size;
+            upg->fw_from_request = 1;
+        }
+    } else {
+        FTS_INFO("firmware(%s) request fail,ret=%d", fwname, ret);
+    }
+
+    if (fw != NULL) {
+        release_firmware(fw);
+        fw = NULL;
+    }
+
+    return ret;
+}
+
+static int fts_get_fw_file_via_i(struct fts_upgrade *upg)
+{
+    upg->fw = upg->module_info->fw_file;
+    upg->fw_length = upg->module_info->fw_len;
+    upg->fw_from_request = 0;
+
+    return 0;
+}
+
+/*****************************************************************************
+ *  Name: fts_fwupg_get_fw_file
+ *  Brief: get fw image/file,
+ *         If support muitl modules, please set FTS_GET_MODULE_NUM, and FTS_-
+ *         MODULE_ID/FTS_MODULE_NAME;
+ *         If get fw via .i file, please set FTS_FW_REQUEST_SUPPORT=0, and F-
+ *         TS_MODULE_ID; will use module id to distingwish different modules;
+ *         If get fw via reques_firmware(), please set FTS_FW_REQUEST_SUPPORT
+ *         =1, and FTS_MODULE_NAME; fw file name will be composed of "focalt-
+ *         ech_ts_fw_" & FTS_MODULE_NAME;
+ *
+ *         If have flash, module_id=vendor_id, If non-flash,module_id need
+ *         transfer from LCD driver(gpio or lcm_id or ...);
+ *  Input:
+ *  Output:
+ *  Return: return 0 if success, otherwise return error code
+ *****************************************************************************/
+static int fts_fwupg_get_fw_file(struct fts_upgrade *upg)
+{
+    int ret = 0;
+    bool get_fw_i_flag = false;
+
+    FTS_DEBUG("get upgrade fw file");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return -EINVAL;
+    }
+
+    ret = fts_fwupg_get_module_info(upg);
+    if ((ret < 0) || (!upg->module_info)) {
+        FTS_ERROR("get module info fail");
+        return ret;
+    }
+
+    if (FTS_FW_REQUEST_SUPPORT) {
+        fts_msleep(500);
+        ret = fts_get_fw_file_via_request_firmware(upg);
+        if (ret != 0) {
+            get_fw_i_flag = true;
+        }
+    } else {
+        get_fw_i_flag = true;
+    }
+
+    if (get_fw_i_flag) {
+        ret = fts_get_fw_file_via_i(upg);
+    }
+
+    FTS_INFO("upgrade fw file len:%d", upg->fw_length);
+    if (upg->fw_length < FTS_MIN_LEN) {
+        FTS_ERROR("fw file len(%d) fail", upg->fw_length);
+        return -ENODATA;
+    }
+
+    return ret;
+}
+
+static void fts_fwupg_work(struct work_struct *work)
+{
+    int ret = 0;
+    u8 chip_id = 0;
+    struct fts_upgrade *upg = fwupgrade;
+
+#if !FTS_AUTO_UPGRADE_EN
+    FTS_INFO("FTS_AUTO_UPGRADE_EN is disabled, not upgrade when power on");
+    return ;
+#endif
+
+    FTS_INFO("fw upgrade work function");
+    if (!upg || !upg->ts_data) {
+        FTS_ERROR("upg/ts_data is null");
+        return ;
+    }
+
+    /* get fw */
+    ret = fts_fwupg_get_fw_file(upg);
+    if (ret < 0) {
+        FTS_ERROR("get file fail, can't upgrade");
+        return ;
+    }
+
+    if (upg->ts_data->fw_loading) {
+        FTS_INFO("fw is loading, not download again");
+        return ;
+    }
+
+    ret = fts_fw_download(upg->fw, upg->fw_length, true);
+    if (ret < 0) {
+        FTS_ERROR("fw auto download failed");
+    } else {
+        fts_msleep(50);
+        ret = fts_read_reg(FTS_REG_CHIP_ID, &chip_id);
+        FTS_INFO("read chip id:0x%02x", chip_id);
+        fts_esdcheck_switch(upg->ts_data, ENABLE);
+    }
+}
+
+int fts_fwupg_init(struct fts_ts_data *ts_data)
+{
+    int i = 0;
+    struct upgrade_setting_nf *setting = &upgrade_setting_list[0];
+    int setting_count =
+        sizeof(upgrade_setting_list) / sizeof(upgrade_setting_list[0]);
+
+    FTS_INFO("fw upgrade init function");
+    if (!ts_data || !ts_data->ts_workqueue) {
+        FTS_ERROR("ts_data/workqueue is NULL, can't run upgrade function");
+        return -EINVAL;
+    }
+
+    if (0 == setting_count) {
+        FTS_ERROR("no upgrade settings in tp driver, init fail");
+        return -ENODATA;
+    }
+
+    fwupgrade = (struct fts_upgrade *)kzalloc(sizeof(*fwupgrade), GFP_KERNEL);
+    if (NULL == fwupgrade) {
+        FTS_ERROR("malloc memory for upgrade fail");
+        return -ENOMEM;
+    }
+
+    if (1 == setting_count) {
+        fwupgrade->setting_nf = setting;
+    } else {
+        for (i = 0; i < setting_count; i++) {
+            setting = &upgrade_setting_list[i];
+            if ((setting->rom_idh == ts_data->ic_info.ids.rom_idh)
+                && (setting->rom_idl == ts_data->ic_info.ids.rom_idl)) {
+                FTS_INFO("match upgrade setting,type(ID):0x%02x%02x",
+                         setting->rom_idh, setting->rom_idl);
+                fwupgrade->setting_nf = setting;
+            }
+        }
+    }
+
+    if (NULL == fwupgrade->setting_nf) {
+        FTS_ERROR("no upgrade settings match, can't upgrade");
+        kfree(fwupgrade);
+        fwupgrade = NULL;
+        return -ENODATA;
+    }
+
+    fts_esdcheck_switch(ts_data, DISABLE);
+    fwupgrade->ts_data = ts_data;
+    INIT_WORK(&fwupgrade->fwupg_work, fts_fwupg_work);
+    INIT_WORK(&fwupgrade->fwrecover_work, fts_fwrecover_work);
+    INIT_WORK(&fwupgrade->fwload_work, fts_fwload_work);
+    queue_work(ts_data->ts_workqueue, &fwupgrade->fwupg_work);
+
+    return 0;
+}
+
+int fts_fwupg_exit(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    if (fwupgrade) {
+        cancel_work_sync(&fwupgrade->fwupg_work);
+        cancel_work_sync(&fwupgrade->fwrecover_work);
+        cancel_work_sync(&fwupgrade->fwload_work);
+        if (fwupgrade->fw_from_request) {
+            vfree(fwupgrade->fw);
+            fwupgrade->fw = NULL;
+        }
+
+        kfree(fwupgrade);
+        fwupgrade = NULL;
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_gesture.c b/drivers/input/touchscreen/focaltech_touch/focaltech_gesture.c
new file mode 100755
index 000000000000..019752c8fec8
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_gesture.c
@@ -0,0 +1,511 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, Focaltech Ltd. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_gestrue.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-08
+*
+* Abstract:
+*
+* Reference:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* 1.Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/******************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define KEY_GESTURE_U                           KEY_U
+#define KEY_GESTURE_UP                          KEY_UP
+#define KEY_GESTURE_DOWN                        KEY_DOWN
+#define KEY_GESTURE_LEFT                        KEY_LEFT
+#define KEY_GESTURE_RIGHT                       KEY_RIGHT
+#define KEY_GESTURE_O                           KEY_O
+#define KEY_GESTURE_E                           KEY_E
+#define KEY_GESTURE_M                           KEY_M
+#define KEY_GESTURE_L                           KEY_L
+#define KEY_GESTURE_W                           KEY_W
+#define KEY_GESTURE_S                           KEY_S
+#define KEY_GESTURE_V                           KEY_V
+#define KEY_GESTURE_C                           KEY_C
+#define KEY_GESTURE_Z                           KEY_Z
+
+#define GESTURE_LEFT                            0x20
+#define GESTURE_RIGHT                           0x21
+#define GESTURE_UP                              0x22
+#define GESTURE_DOWN                            0x23
+#define GESTURE_DOUBLECLICK                     0x24
+#define GESTURE_O                               0x30
+#define GESTURE_W                               0x31
+#define GESTURE_M                               0x32
+#define GESTURE_E                               0x33
+#define GESTURE_L                               0x44
+#define GESTURE_S                               0x46
+#define GESTURE_V                               0x54
+#define GESTURE_Z                               0x41
+#define GESTURE_C                               0x34
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+/*
+* gesture_id    - mean which gesture is recognised
+* point_num     - points number of this gesture
+* coordinate_x  - All gesture point x coordinate
+* coordinate_y  - All gesture point y coordinate
+* mode          - gesture enable/disable, need enable by host
+*               - 1:enable gesture function(default)  0:disable
+* active        - gesture work flag,
+*                 always set 1 when suspend, set 0 when resume
+*/
+struct fts_gesture_st {
+    u8 gesture_id;
+    u8 point_num;
+    u16 coordinate_x[FTS_GESTURE_POINTS_MAX];
+    u16 coordinate_y[FTS_GESTURE_POINTS_MAX];
+};
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+static struct fts_gesture_st fts_gesture_data;
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+static ssize_t fts_gesture_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    fts_read_reg(FTS_REG_GESTURE_EN, &val);
+    count = snprintf(buf, PAGE_SIZE, "Gesture Mode:%s\n",
+                     ts_data->gesture_support ? "On" : "Off");
+    count += snprintf(buf + count, PAGE_SIZE, "Reg(0xD0)=%d\n", val);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_gesture_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    if (ts_data->suspended) {
+        FTS_INFO("In suspend,not operation gesture mode!");
+        return count;
+    }
+    mutex_lock(&ts_data->input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enable gesture");
+        ts_data->gesture_support = ENABLE;
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("disable gesture");
+        ts_data->gesture_support = DISABLE;
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_gesture_buf_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+    struct fts_gesture_st *gesture = &fts_gesture_data;
+
+    mutex_lock(&input_dev->mutex);
+    count = snprintf(buf, PAGE_SIZE, "Gesture ID:%d\n", gesture->gesture_id);
+    count += snprintf(buf + count, PAGE_SIZE, "Gesture PointNum:%d\n",
+                      gesture->point_num);
+    count += snprintf(buf + count, PAGE_SIZE, "Gesture Points Buffer:\n");
+
+    /* save point data,max:6 */
+    for (i = 0; i < FTS_GESTURE_POINTS_MAX; i++) {
+        count += snprintf(buf + count, PAGE_SIZE, "%3d(%4d,%4d) ", i,
+                          gesture->coordinate_x[i], gesture->coordinate_y[i]);
+        if ((i + 1) % 4 == 0)
+            count += snprintf(buf + count, PAGE_SIZE, "\n");
+    }
+    count += snprintf(buf + count, PAGE_SIZE, "\n");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_gesture_buf_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+static ssize_t fts_gesture_bm_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    count = snprintf(buf, PAGE_SIZE, "gesture bmode:%d\n",
+                     ts_data->gesture_bmode);
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_gesture_bm_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    int value = 0xFF;
+    int ret = 0;
+
+    mutex_lock(&ts_data->input_dev->mutex);
+    ret = sscanf(buf, "%d", &value);
+    if (ret == 1) {
+        FTS_DEBUG("gesture bmode:%d->%d", ts_data->gesture_bmode, value);
+        ts_data->gesture_bmode = value;
+    }
+    mutex_unlock(&ts_data->input_dev->mutex);
+
+    return count;
+}
+
+/* sysfs gesture node
+ *   read example: cat  fts_gesture_mode       ---read gesture mode
+ *   write example:echo 1 > fts_gesture_mode   --- write gesture mode to 1
+ *
+ */
+static DEVICE_ATTR(fts_gesture_mode, S_IRUGO | S_IWUSR, fts_gesture_show,
+                   fts_gesture_store);
+/*
+ *   read example: cat fts_gesture_buf        --- read gesture buf
+ */
+static DEVICE_ATTR(fts_gesture_buf, S_IRUGO | S_IWUSR,
+                   fts_gesture_buf_show, fts_gesture_buf_store);
+
+static DEVICE_ATTR(fts_gesture_bm, S_IRUGO | S_IWUSR,
+                   fts_gesture_bm_show, fts_gesture_bm_store);
+
+static struct attribute *fts_gesture_mode_attrs[] = {
+    &dev_attr_fts_gesture_mode.attr,
+    &dev_attr_fts_gesture_buf.attr,
+    &dev_attr_fts_gesture_bm.attr,
+    NULL,
+};
+
+static struct attribute_group fts_gesture_group = {
+    .attrs = fts_gesture_mode_attrs,
+};
+
+static int fts_create_gesture_sysfs(struct device *dev)
+{
+    int ret = 0;
+
+    ret = sysfs_create_group(&dev->kobj, &fts_gesture_group);
+    if (ret) {
+        FTS_ERROR("gesture sys node create fail");
+        sysfs_remove_group(&dev->kobj, &fts_gesture_group);
+        return ret;
+    }
+
+    return 0;
+}
+
+static void fts_gesture_report(struct input_dev *input_dev, int gesture_id)
+{
+    int gesture;
+
+    FTS_DEBUG("gesture_id:0x%x", gesture_id);
+    switch (gesture_id) {
+    case GESTURE_LEFT:
+        gesture = KEY_GESTURE_LEFT;
+        break;
+    case GESTURE_RIGHT:
+        gesture = KEY_GESTURE_RIGHT;
+        break;
+    case GESTURE_UP:
+        gesture = KEY_GESTURE_UP;
+        break;
+    case GESTURE_DOWN:
+        gesture = KEY_GESTURE_DOWN;
+        break;
+    case GESTURE_DOUBLECLICK:
+        gesture = KEY_GESTURE_U;
+        break;
+    case GESTURE_O:
+        gesture = KEY_GESTURE_O;
+        break;
+    case GESTURE_W:
+        gesture = KEY_GESTURE_W;
+        break;
+    case GESTURE_M:
+        gesture = KEY_GESTURE_M;
+        break;
+    case GESTURE_E:
+        gesture = KEY_GESTURE_E;
+        break;
+    case GESTURE_L:
+        gesture = KEY_GESTURE_L;
+        break;
+    case GESTURE_S:
+        gesture = KEY_GESTURE_S;
+        break;
+    case GESTURE_V:
+        gesture = KEY_GESTURE_V;
+        break;
+    case GESTURE_Z:
+        gesture = KEY_GESTURE_Z;
+        break;
+    case  GESTURE_C:
+        gesture = KEY_GESTURE_C;
+        break;
+    default:
+        gesture = -1;
+        break;
+    }
+    /* report event key */
+    if (gesture != -1) {
+        FTS_DEBUG("Gesture Code=%d", gesture);
+        input_report_key(input_dev, gesture, 1);
+        input_sync(input_dev);
+        input_report_key(input_dev, gesture, 0);
+        input_sync(input_dev);
+    }
+}
+
+/*****************************************************************************
+* Name: fts_gesture_readdata
+* Brief: Read information about gesture: enable flag/gesture points..., if ges-
+*        ture enable, save gesture points' information, and report to OS.
+*        It will be called this function every intrrupt when gesture is supported.
+*
+*        gesture data length: 1(enable) + 1(reserve) + 2(header) + 6 * 4
+* Input: ts_data - global struct data
+*        data    - gesture data buffer
+* Output:
+* Return: 0 - read gesture data successfully, the report data is gesture data
+*         1 - tp not in suspend/gesture not enable in TP FW
+*         -Exx - error
+*****************************************************************************/
+int fts_gesture_readdata(struct fts_ts_data *ts_data, u8 *touch_buf)
+{
+    int ret = 0;
+    int i = 0;
+    int index = 0;
+    u8 buf[FTS_GESTURE_DATA_LEN] = { 0 };
+    u8 gesture_en = 0xFF;
+    struct input_dev *input_dev = ts_data->input_dev;
+    struct fts_gesture_st *gesture = &fts_gesture_data;
+
+    ret = fts_read_reg(FTS_REG_GESTURE_EN, &gesture_en);
+    if (gesture_en != ENABLE) {
+        FTS_DEBUG("gesture not enable in fw, don't process gesture");
+        return 0;
+    }
+
+    if ((ts_data->gesture_bmode == GESTURE_BM_TOUCH) && touch_buf &&
+        (TOUCH_DEFAULT == ((touch_buf[FTS_TOUCH_E_NUM] >> 4) & 0x0F))) {
+        memcpy(buf, touch_buf + FTS_TOUCH_DATA_LEN, FTS_GESTURE_DATA_LEN);
+    } else {
+        buf[2] = FTS_REG_GESTURE_OUTPUT_ADDRESS;
+        ret = fts_read(&buf[2], 1, &buf[2], FTS_GESTURE_DATA_LEN - 2);
+        if (ret < 0) {
+            FTS_ERROR("read gesture header data fail");
+            return ret;
+        }
+    }
+
+    /* init variable before read gesture point */
+    memset(gesture->coordinate_x, 0, FTS_GESTURE_POINTS_MAX * sizeof(u16));
+    memset(gesture->coordinate_y, 0, FTS_GESTURE_POINTS_MAX * sizeof(u16));
+    gesture->gesture_id = buf[2];
+    gesture->point_num = buf[3];
+    FTS_DEBUG("gesture_id=%d, point_num=%d",
+              gesture->gesture_id, gesture->point_num);
+
+    /* save point data,max:6 */
+    for (i = 0; i < FTS_GESTURE_POINTS_MAX; i++) {
+        index = 4 * i + 4;
+        gesture->coordinate_x[i] = (u16)(((buf[0 + index] & 0x0F) << 8)
+                                         + buf[1 + index]);
+        gesture->coordinate_y[i] = (u16)(((buf[2 + index] & 0x0F) << 8)
+                                         + buf[3 + index]);
+    }
+
+    /* report gesture to OS */
+    fts_gesture_report(input_dev, gesture->gesture_id);
+    return FTS_RETVAL_IGNORE_TOUCHES;
+}
+
+void fts_gesture_recovery(struct fts_ts_data *ts_data)
+{
+    u8 state = 0xFF;
+    if (ts_data->gesture_support && ts_data->suspended) {
+        fts_write_reg(0xD1, 0xFF);
+        fts_write_reg(0xD2, 0xFF);
+        fts_write_reg(0xD5, 0xFF);
+        fts_write_reg(0xD6, 0xFF);
+        fts_write_reg(0xD7, 0xFF);
+        fts_write_reg(0xD8, 0xFF);
+        fts_write_reg(FTS_REG_GESTURE_EN, ENABLE);
+        fts_msleep(1);
+        fts_read_reg(FTS_REG_GESTURE_EN, &state);
+        if (state != ENABLE) {
+            FTS_ERROR("set gesture mode failed");
+        }
+    }
+}
+
+int fts_gesture_suspend(struct fts_ts_data *ts_data)
+{
+    int i = 0;
+    u8 state = 0xFF;
+
+    FTS_FUNC_ENTER();
+
+    for (i = 0; i < FTS_MAX_RETRIES_WRITEREG; i++) {
+        fts_write_reg(0xD1, 0xFF);
+        fts_write_reg(0xD2, 0xFF);
+        fts_write_reg(0xD5, 0xFF);
+        fts_write_reg(0xD6, 0xFF);
+        fts_write_reg(0xD7, 0xFF);
+        fts_write_reg(0xD8, 0xFF);
+        fts_write_reg(FTS_REG_GESTURE_EN, ENABLE);
+        fts_msleep(1);
+        fts_read_reg(FTS_REG_GESTURE_EN, &state);
+        if (state == ENABLE)
+            break;
+    }
+
+    if (i >= FTS_MAX_RETRIES_WRITEREG)
+        FTS_ERROR("make IC enter into gesture(suspend) fail,state:%x", state);
+    else
+        FTS_INFO("Enter into gesture(suspend) successfully");
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_gesture_resume(struct fts_ts_data *ts_data)
+{
+    int i = 0;
+    u8 state = 0xFF;
+
+    FTS_FUNC_ENTER();
+    for (i = 0; i < FTS_MAX_RETRIES_WRITEREG; i++) {
+        fts_write_reg(FTS_REG_GESTURE_EN, DISABLE);
+        fts_msleep(1);
+        fts_read_reg(FTS_REG_GESTURE_EN, &state);
+        if (state == DISABLE)
+            break;
+    }
+
+    if (i >= FTS_MAX_RETRIES_WRITEREG)
+        FTS_ERROR("make IC exit gesture(resume) fail,state:%x", state);
+    else
+        FTS_INFO("resume from gesture successfully");
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_gesture_init(struct fts_ts_data *ts_data)
+{
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    FTS_FUNC_ENTER();
+    input_set_capability(input_dev, EV_KEY, KEY_POWER);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_U);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_UP);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_DOWN);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_LEFT);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_RIGHT);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_O);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_E);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_M);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_L);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_W);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_S);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_V);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_Z);
+    input_set_capability(input_dev, EV_KEY, KEY_GESTURE_C);
+
+    __set_bit(KEY_GESTURE_RIGHT, input_dev->keybit);
+    __set_bit(KEY_GESTURE_LEFT, input_dev->keybit);
+    __set_bit(KEY_GESTURE_UP, input_dev->keybit);
+    __set_bit(KEY_GESTURE_DOWN, input_dev->keybit);
+    __set_bit(KEY_GESTURE_U, input_dev->keybit);
+    __set_bit(KEY_GESTURE_O, input_dev->keybit);
+    __set_bit(KEY_GESTURE_E, input_dev->keybit);
+    __set_bit(KEY_GESTURE_M, input_dev->keybit);
+    __set_bit(KEY_GESTURE_W, input_dev->keybit);
+    __set_bit(KEY_GESTURE_L, input_dev->keybit);
+    __set_bit(KEY_GESTURE_S, input_dev->keybit);
+    __set_bit(KEY_GESTURE_V, input_dev->keybit);
+    __set_bit(KEY_GESTURE_C, input_dev->keybit);
+    __set_bit(KEY_GESTURE_Z, input_dev->keybit);
+
+    fts_create_gesture_sysfs(ts_data->dev);
+
+    memset(&fts_gesture_data, 0, sizeof(struct fts_gesture_st));
+    ts_data->gesture_bmode = GESTURE_BM_REG;
+    ts_data->gesture_support = DISABLE;
+
+    if (ts_data->bus_type == BUS_TYPE_SPI) {
+        if ((ts_data->ic_info.ids.type <= 0x25)
+            || (ts_data->ic_info.ids.type == 0x87)
+            || (ts_data->ic_info.ids.type == 0x88)) {
+            FTS_INFO("ic type:0x%02x,GESTURE_BM_TOUCH", ts_data->ic_info.ids.type);
+            ts_data->touch_size += FTS_GESTURE_DATA_LEN;
+            ts_data->gesture_bmode = GESTURE_BM_TOUCH;
+        }
+    }
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_gesture_exit(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    sysfs_remove_group(&ts_data->dev->kobj, &fts_gesture_group);
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_hp.c b/drivers/input/touchscreen/focaltech_touch/focaltech_hp.c
new file mode 100755
index 000000000000..cba13d4f1699
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_hp.c
@@ -0,0 +1,888 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*****************************************************************************
+*
+* File Name: focaltech_hp.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2023-12-12
+*
+* Abstract: Host Processing
+*
+* Version: V1.0
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define FTS_FHP_NAME                        "fhp_ft"
+#define FTS_FHPI_DEV_NAME                   "fhp_input"
+
+#define DEFAULT_IOCTL_SPI_BUFSIZE           256
+#define MAX_QUEUE_BUFSIZE                   (32768)
+
+#define FHP_CMD_GET_FRAME                   0x01
+
+struct fhp_spi_sync_data {
+    char *tx;
+    char *rx;
+    unsigned int size;
+};
+
+struct fhp_input_report_data {
+    char *buffer;
+    unsigned int size;
+};
+
+#define FHP_IOCTL_DEVICE                    0xC5
+#define FHP_IOCTL_RESET                     _IOW(FHP_IOCTL_DEVICE, 0x01, long)
+#define FHP_IOCTL_SPI_SYNC                  _IOWR(FHP_IOCTL_DEVICE, 0x02, struct fhp_spi_sync_data)
+#define FHP_IOCTL_SET_IRQ                   _IOW(FHP_IOCTL_DEVICE, 0x03, long)
+#define FHP_IOCTL_SET_RAW_SIZE              _IOW(FHP_IOCTL_DEVICE, 0x04, long)
+#define FHP_IOCTL_SET_SPI_SPEED             _IOW(FHP_IOCTL_DEVICE, 0x05, long)
+#define FHP_IOCTL_GET_CHIP_INIT_DONE        _IOR(FHP_IOCTL_DEVICE, 0x06, long)
+#define FHP_IOCTL_GET_FRAME                 _IOR(FHP_IOCTL_DEVICE, 0x07, void *)
+#define FHP_IOCTL_CLEAR_FRAME               _IOW(FHP_IOCTL_DEVICE, 0x08, long)
+#define FHP_IOCTL_SET_TIMEOUT               _IOW(FHP_IOCTL_DEVICE, 0x09, long)
+#define FHP_IOCTL_REPORT                    _IOW(FHP_IOCTL_DEVICE, 0x0A, struct fhp_input_report_data)
+
+#define FHP_INPUT_IOCTL_DEVICE              0xC6
+#define FHP_INPUT_IOCTL_REPORT              _IOW(FHP_INPUT_IOCTL_DEVICE, 0x01, struct fhp_input_report_data)
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+typedef enum {
+    FHP_FRAME_WAITQ_DEFAULT,
+    FHP_FRAME_WAITQ_WAIT,
+    FHP_FRAME_WAITQ_WAIT_POLL,
+    FHP_FRAME_WAITQ_WAKEUP,
+} FHP_FRAME_WAITQ_FLAG;
+
+struct fhp_frame {
+    u64 tv;
+    unsigned char value[0];
+};
+
+struct fhp_queue {
+    int head;
+    int tail;
+    int count;
+    int max_count;
+    int elem_size;
+    u8 *buffer;
+    struct mutex mutexq;
+};
+
+struct fhp_core_data {
+    struct fts_ts_data *ts_data;
+    struct miscdevice fhp_dev;
+    struct miscdevice fhpi_dev;
+    wait_queue_head_t frame_waitq;
+    struct fhp_queue q;
+    int fhp_dev_open_cnt;
+    int timeout; /*0:no wait, <0 wait infinitely, >0 wait timeout*/
+    int frame_waitq_flag;
+    int touch_size_bak;
+};
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+static struct fhp_core_data *fts_fhp_data;
+static long fhp_input_report(struct fhp_core_data *fhp_data, unsigned long arg);
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+static u64 fhp_get_timestamp(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
+    ktime_t tv;
+    tv = ktime_get_real() / 1000;
+    return (u64)tv;
+#else
+    struct timeval tv;
+    do_gettimeofday(&tv);
+    return (u64)(((u64)tv.tv_sec * 1000000) + tv.tv_usec);
+#endif
+}
+
+static int fhp_spi_sync(struct fhp_core_data *fhp_data, u8 *tx_buf, u8 *rx_buf, u32 len)
+{
+    int ret = 0;
+    u8 *tbuf = NULL;
+    u8 *rbuf = NULL;
+    struct spi_message msg;
+    struct spi_transfer xfer = { 0 };
+
+    if (!fhp_data || !fhp_data->ts_data || !fhp_data->ts_data->spi) {
+        FTS_ERROR("fhp/ts data/spi is null");
+        return -EINVAL;
+    }
+
+    if (!fhp_data->ts_data->bus_tx_buf || !fhp_data->ts_data->bus_rx_buf || !tx_buf || !rx_buf || !len) {
+        FTS_ERROR("tx_buf/rx_buf is null/len(%d) invalid", len);
+        return -EINVAL;
+    }
+
+    mutex_lock(&fhp_data->ts_data->bus_lock);
+    if (len > FTS_MAX_BUS_BUF) {
+        tbuf = kzalloc(len, GFP_KERNEL);
+        if (NULL == tbuf) {
+            FTS_ERROR("txbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_spi_sync;
+        }
+
+        rbuf = kzalloc(len, GFP_KERNEL);
+        if (NULL == rbuf) {
+            FTS_ERROR("rxbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_spi_sync;
+        }
+    } else {
+        tbuf = fhp_data->ts_data->bus_tx_buf;
+        rbuf = fhp_data->ts_data->bus_rx_buf;
+        memset(tbuf, 0x0, FTS_MAX_BUS_BUF);
+        memset(rbuf, 0x0, FTS_MAX_BUS_BUF);
+    }
+
+    memcpy(tbuf, tx_buf, len);
+    xfer.tx_buf = tbuf;
+    xfer.rx_buf = rbuf;
+    xfer.len = len;
+    spi_message_init(&msg);
+    spi_message_add_tail(&xfer, &msg);
+    ret = spi_sync(fhp_data->ts_data->spi, &msg);
+    memcpy(rx_buf, rbuf, len);
+    if (ret) {
+        FTS_ERROR("spi_sync fail,addr:%x,status:%x,ret:%d", tbuf[0], rbuf[3], ret);
+        goto err_spi_sync;
+    }
+
+    ret = 0;
+err_spi_sync:
+    if (len > FTS_MAX_BUS_BUF) {
+        if (tbuf) {
+            kfree(tbuf);
+            tbuf = NULL;
+        }
+
+        if (rbuf) {
+            kfree(rbuf);
+            rbuf = NULL;
+        }
+    }
+
+    mutex_unlock(&fhp_data->ts_data->bus_lock);
+    return ret;
+}
+
+static int fhpq_open(struct fhp_queue *q)
+{
+    if (!q) {
+        FTS_ERROR("q is null");
+        return -EINVAL;
+    }
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&(q->mutexq));
+    q->head = q->tail = q->count = 0;
+    q->buffer = kzalloc(MAX_QUEUE_BUFSIZE, GFP_KERNEL);
+    if (!q->buffer) {
+        FTS_ERROR("malloc queue buffer failed");
+        mutex_unlock(&(q->mutexq));
+        return -ENOMEM;
+    }
+    mutex_unlock(&(q->mutexq));
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fhpq_set_element_size(struct fhp_queue *q, int elem_size)
+{
+    int max_size = FTS_MAX_TOUCH_BUF - sizeof(struct fhp_frame);
+    if (!q || !elem_size || (elem_size > max_size)) {
+        FTS_ERROR("q is null/elem_size(%d) is invalid", elem_size);
+        return -EINVAL;
+    }
+
+    FTS_FUNC_ENTER();
+    mutex_lock(&(q->mutexq));
+    q->elem_size = elem_size;
+    q->max_count = MAX_QUEUE_BUFSIZE / elem_size;
+    FTS_INFO("set queue elem_size=%d,max_count=%d", q->elem_size, q->max_count);
+    mutex_unlock(&(q->mutexq));
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static bool fhpq_full(struct fhp_queue *q)
+{
+    return q->count == q->max_count;
+}
+
+static bool fhpq_empty(struct fhp_queue *q)
+{
+    return q->count == 0;
+}
+
+static void fhpq_clear(struct fhp_queue *q)
+{
+    mutex_lock(&(q->mutexq));
+    q->head = q->tail = q->count = 0;
+    mutex_unlock(&(q->mutexq));
+}
+
+static int fhpq_enqueue(struct fhp_queue *q, u8 *val, u64 timestamp)
+{
+    struct fhp_frame *tail_elem = NULL;
+
+    if (!q || !val || !q->buffer || !q->elem_size || !q->max_count) {
+        FTS_ERROR("q/val/buffer is null/size is 0");
+        return -EINVAL;
+    }
+
+    mutex_lock(&(q->mutexq));
+    tail_elem = (struct fhp_frame *)&q->buffer[q->tail * q->elem_size];
+    tail_elem->tv = timestamp;
+    memcpy(tail_elem->value, val, q->elem_size);
+    q->tail = (q->tail + 1) % q->max_count;
+    if (fhpq_full(q)) {
+        q->head = (q->head + 1) % q->max_count;
+    } else {
+        q->count++;
+    }
+    mutex_unlock(&(q->mutexq));
+    return 0;
+}
+
+static int fhpq_dequeue_userspace(struct fhp_queue *q, void __user *buff)
+{
+    if (!q || !buff || !q->buffer) {
+        FTS_ERROR("q/buff/buffer is null");
+        return -EINVAL;
+    }
+
+    mutex_lock(&(q->mutexq));
+    if (fhpq_empty(q)) {
+        mutex_unlock(&(q->mutexq));
+        return -ENODATA;
+    }
+    if (copy_to_user(buff, &q->buffer[q->head * q->elem_size], q->elem_size)) {
+        FTS_ERROR("copy frame data to user failed");
+        mutex_unlock(&(q->mutexq));
+        return -EFAULT;
+    }
+    q->head = (q->head + 1) % q->max_count;
+    q->count--;
+    mutex_unlock(&(q->mutexq));
+    return 0;
+}
+
+static int fhpq_release(struct fhp_queue *q)
+{
+    if (q) {
+        mutex_lock(&(q->mutexq));
+        q->head = q->tail = q->count = 0;
+        q->max_count = q->elem_size = 0;
+        if (q->buffer) {
+            kfree(q->buffer);
+            q->buffer = NULL;
+        }
+        mutex_unlock(&(q->mutexq));
+    }
+    return 0;
+}
+
+
+static int fhp_ioctl_reset(struct fhp_core_data *fhp_data, unsigned long high)
+{
+    if (!fhp_data || !fhp_data->ts_data) {
+        FTS_ERROR("fhp/ts data is null");
+        return -EINVAL;
+    }
+    return fts_set_reset(fhp_data->ts_data, (int)high);
+}
+
+static int fhp_ioctl_set_irq(struct fhp_core_data *fhp_data, unsigned long enable)
+{
+    if (!fhp_data || !fhp_data->ts_data) {
+        FTS_ERROR("fhp/ts data is null");
+        return -EINVAL;
+    }
+
+    FTS_INFO("set irq to %s", enable ? "enable" : "disable");
+    if (enable)
+        fts_irq_enable();
+    else
+        fts_irq_disable();
+    return 0;
+}
+
+static int fhp_ioctl_spi_sync(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    int ret = 0;
+    struct fhp_spi_sync_data spi_data;
+    u8 txbuf_temp[DEFAULT_IOCTL_SPI_BUFSIZE] = { 0 };
+    u8 rxbuf_temp[DEFAULT_IOCTL_SPI_BUFSIZE] = { 0 };
+    u8 *txbuf = txbuf_temp;
+    u8 *rxbuf = rxbuf_temp;
+
+    if (!fhp_data || !fhp_data->ts_data) {
+        FTS_ERROR("fhp/ts data is null");
+        return -EINVAL;
+    }
+
+    if (copy_from_user(&spi_data, (void *)arg, sizeof(struct fhp_spi_sync_data))) {
+        FTS_ERROR("copy spi_sync data from userspace fail");
+        return -EFAULT;
+    }
+
+    if (!spi_data.tx || !spi_data.rx || !spi_data.size) {
+        FTS_ERROR("tx/rx/size(%d) from userspace are invalid", spi_data.size);
+        return -EINVAL;
+    }
+
+    if (spi_data.size > DEFAULT_IOCTL_SPI_BUFSIZE) {
+        txbuf = kmalloc(spi_data.size, GFP_KERNEL);
+        rxbuf = kmalloc(spi_data.size, GFP_KERNEL);
+        if (!txbuf || !rxbuf) {
+            FTS_ERROR("kzalloc memory(size:%d) for spi tx/rx buffer fail", spi_data.size);
+            ret = -ENOMEM;
+            goto spi_sync_err;
+        }
+    }
+    memset(txbuf, 0, spi_data.size);
+    memset(rxbuf, 0, spi_data.size);
+
+    if (copy_from_user(txbuf, spi_data.tx, spi_data.size)) {
+        FTS_ERROR("copy spi tx data from userspace fail");
+        ret = -EFAULT;
+        goto spi_sync_err;
+    }
+
+    ret = fhp_spi_sync(fhp_data, txbuf, rxbuf, spi_data.size);
+    if (ret) {
+        FTS_ERROR("spi sync fail");
+        ret = -EIO;
+        goto spi_sync_err;
+    }
+
+    if (copy_to_user(spi_data.rx, rxbuf, spi_data.size)) {
+        FTS_ERROR("copy spi rx data to userspace fail");
+        ret = -EFAULT;
+        goto spi_sync_err;
+    }
+
+    return 0;
+spi_sync_err:
+    if (spi_data.size > DEFAULT_IOCTL_SPI_BUFSIZE) {
+        kfree(txbuf);
+        kfree(rxbuf);
+    }
+    return ret;
+}
+
+static int fhp_ioctl_set_frame_size(struct fhp_core_data *fhp_data, unsigned long size)
+{
+    int ret = 0;
+    int chip_frame_size = (int)size;
+    int frame_size = 0;
+    int max_size = FTS_MAX_TOUCH_BUF - sizeof(struct fhp_frame);
+
+    if (!fhp_data || !fhp_data->ts_data || (chip_frame_size <= 0) || (chip_frame_size > max_size)) {
+        FTS_ERROR("fhp/ts data is null/size(%d) is invalid", chip_frame_size);
+        return -EINVAL;
+    }
+
+    FTS_INFO("set frame size to %d", chip_frame_size);
+    frame_size = chip_frame_size + sizeof(struct fhp_frame);
+    ret = fhpq_set_element_size(&fhp_data->q, frame_size);
+    if (ret) {
+        FTS_ERROR("set queue element size failed,ret=%d", ret);
+        return ret;
+    }
+    fhp_data->touch_size_bak = fhp_data->ts_data->touch_size;
+    fhp_data->ts_data->touch_size = chip_frame_size;
+    return 0;
+}
+
+static int fhp_ioctl_set_spi_speed(struct fhp_core_data *fhp_data, unsigned long speed)
+{
+    int ret = 0;
+    if (!fhp_data || !fhp_data->ts_data || !fhp_data->ts_data->spi) {
+        FTS_ERROR("fhp/ts data/spi is null");
+        return -EINVAL;
+    }
+
+    if (fhp_data->ts_data->spi->max_speed_hz == speed) {
+        FTS_INFO("spi speed == max_speed_hz");
+        return 0;
+    }
+
+    FTS_INFO("set spi speed to %ld", speed);
+    mutex_lock(&fhp_data->ts_data->bus_lock);
+    fhp_data->ts_data->spi->max_speed_hz = speed;
+    ret = spi_setup(fhp_data->ts_data->spi);
+    if (ret < 0) {
+        FTS_ERROR("spi setup fail,ret:%d", ret);
+    }
+    mutex_unlock(&fhp_data->ts_data->bus_lock);
+    return ret;
+}
+
+static int fhp_ioctl_get_chip_init_done(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    int ret = 0;
+    u8 status = 0;
+    if (!fhp_data || !fhp_data->ts_data) {
+        FTS_ERROR("fhp/ts data is null");
+        return -EINVAL;
+    }
+
+    /* 1:init done, 0:not done, others:reserved */
+    status = fhp_data->ts_data->fw_loading ? 0 : 1;
+    FTS_INFO("chip init flag:%d", status);
+    if (copy_to_user((void *)arg, (u8 *)&status, sizeof(u8))) {
+        FTS_ERROR("copy chip_init_done flag data to userspace fail");
+        ret = -EFAULT;
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fhp_ioctl_get_frame(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    int ret = 0;
+    if (!fhp_data || !fhp_data->ts_data || !fhp_data->ts_data->touch_buf) {
+        FTS_ERROR("fhp/ts data is null");
+        return -EINVAL;
+    }
+
+    if (fhpq_empty(&fhp_data->q) && (fhp_data->frame_waitq_flag != FHP_FRAME_WAITQ_WAIT_POLL)) {
+        fhp_data->frame_waitq_flag = FHP_FRAME_WAITQ_WAIT;
+        if (fhp_data->timeout == 0) {
+            FTS_INFO("No frame data, and not wait");
+            return -ENODATA;
+        } else if (fhp_data->timeout < 0) {
+            wait_event_interruptible(fhp_data->frame_waitq,
+                                     fhp_data->frame_waitq_flag == FHP_FRAME_WAITQ_WAKEUP);
+        } else if (fhp_data->timeout > 0) {
+            ret = wait_event_interruptible_timeout(fhp_data->frame_waitq,
+                                                   fhp_data->frame_waitq_flag == FHP_FRAME_WAITQ_WAKEUP,
+                                                   msecs_to_jiffies(fhp_data->timeout));
+            if (ret == 0) return -ETIMEDOUT;
+        }
+    }
+
+    ret = fhpq_dequeue_userspace(&fhp_data->q, (void *)arg);
+    if (ret < 0) {
+        FTS_ERROR("dequeue frame failed");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int fhp_ioctl_clear_frame(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    if (fhp_data) {
+        FTS_INFO("clear queue frame");
+        fhpq_clear(&fhp_data->q);
+    }
+    return 0;
+}
+
+static int fhp_ioctl_set_timeout(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    int timeout = (int)arg;
+    if (!fhp_data) {
+        FTS_ERROR("fhp data is null");
+        return -EINVAL;
+    }
+
+    if (fhp_data->timeout != timeout) {
+        FTS_INFO("set timeout:%d->%d", fhp_data->timeout, timeout);
+        fhp_data->timeout = timeout;
+    }
+    return 0;
+}
+
+static int fhp_open(struct inode *inode, struct file *file)
+{
+    int ret = 0;
+    struct fhp_core_data *fhp_data = container_of(file->private_data, struct fhp_core_data, fhp_dev);
+    FTS_FUNC_ENTER();
+    if (!fhp_data && !fhp_data->ts_data) {
+        FTS_ERROR("fhp_data/ts_data is null");
+        return -ENODATA;
+    }
+
+    if (fhp_data->fhp_dev_open_cnt >= 1) {
+        FTS_ERROR("open fail(cnt:%d)", fhp_data->fhp_dev_open_cnt);
+        return -EBUSY;
+    }
+
+    fts_irq_disable();
+    ret = fhpq_open(&fhp_data->q);
+    if (ret) {
+        FTS_ERROR("queue open failed");
+        return ret;
+    }
+
+    fhp_data->frame_waitq_flag = FHP_FRAME_WAITQ_DEFAULT;
+    fhp_data->timeout = 0;
+    fhp_data->fhp_dev_open_cnt++;
+    fhp_data->ts_data->fhp_mode = ENABLE;
+    FTS_INFO("open successfully(cnt:%d)", fhp_data->fhp_dev_open_cnt);
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int fhp_close(struct inode *inode, struct file *file)
+{
+    struct fhp_core_data *fhp_data = container_of(file->private_data, struct fhp_core_data, fhp_dev);
+
+    FTS_FUNC_ENTER();
+    if (!fhp_data && !fhp_data->ts_data) {
+        FTS_ERROR("fhp_data/ts_data is null");
+        return -ENODATA;
+    }
+    fhpq_release(&fhp_data->q);
+    fhp_data->fhp_dev_open_cnt--;
+    fhp_data->ts_data->fhp_mode = DISABLE;
+    fhp_data->ts_data->touch_size = fhp_data->touch_size_bak;
+    fts_irq_enable();
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static long fhp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct fhp_core_data *fhp_data = container_of(filp->private_data, struct fhp_core_data, fhp_dev);
+
+    if (!fhp_data) {
+        FTS_ERROR("fhp_data is null");
+        return -ENODATA;
+    }
+
+    //FTS_DEBUG("ioctl cmd:%x,arg:%lx", cmd, arg);
+    switch (cmd) {
+    case FHP_IOCTL_GET_FRAME:
+        ret = fhp_ioctl_get_frame(fhp_data, arg);
+        break;
+    case FHP_IOCTL_SPI_SYNC:
+        ret = fhp_ioctl_spi_sync(fhp_data, arg);
+        break;
+    case FHP_IOCTL_RESET:
+        ret = fhp_ioctl_reset(fhp_data, arg);
+        break;
+    case FHP_IOCTL_SET_IRQ:
+        ret = fhp_ioctl_set_irq(fhp_data, arg);
+        break;
+    case FHP_IOCTL_SET_RAW_SIZE:
+        fhp_ioctl_set_frame_size(fhp_data, arg);
+        break;
+    case FHP_IOCTL_SET_SPI_SPEED:
+        ret = fhp_ioctl_set_spi_speed(fhp_data, arg);
+        break;
+    case FHP_IOCTL_GET_CHIP_INIT_DONE:
+        ret = fhp_ioctl_get_chip_init_done(fhp_data, arg);
+        break;
+    case FHP_IOCTL_CLEAR_FRAME:
+        ret = fhp_ioctl_clear_frame(fhp_data, arg);
+        break;
+    case FHP_IOCTL_SET_TIMEOUT:
+        ret = fhp_ioctl_set_timeout(fhp_data, arg);
+        break;
+    case FHP_IOCTL_REPORT:
+        ret = fhp_input_report(fhp_data, arg);
+        break;
+    default:
+        FTS_ERROR("unkown ioctl cmd(0x%x)", (int)cmd);
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static unsigned int fhp_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+    struct fhp_core_data *fhp_data = container_of(filp->private_data, struct fhp_core_data, fhp_dev);
+
+    if (!fhp_data) {
+        FTS_ERROR("fhp_data is null");
+        return -ENODATA;
+    }
+
+    poll_wait(filp, &fhp_data->frame_waitq, wait);
+    if (fhp_data->frame_waitq_flag == FHP_FRAME_WAITQ_WAKEUP)
+        mask |= POLLIN | POLLRDNORM;
+
+    fhp_data->frame_waitq_flag = FHP_FRAME_WAITQ_WAIT_POLL;
+    return mask;
+}
+
+static struct file_operations fhp_fops = {
+    .open = fhp_open,
+    .release = fhp_close,
+    .unlocked_ioctl = fhp_ioctl,
+    .poll = fhp_poll,
+};
+
+static int fhp_miscdev_init(struct fhp_core_data *fhp_data)
+{
+    int ret = 0;
+
+    fhp_data->fhp_dev.minor = MISC_DYNAMIC_MINOR;
+    fhp_data->fhp_dev.name = FTS_FHP_NAME;
+    fhp_data->fhp_dev.fops = &fhp_fops;
+    ret = misc_register(&fhp_data->fhp_dev);
+    if (ret) {
+        FTS_ERROR("misc_register(fhp_dev) fail");
+        return ret;
+    }
+
+    FTS_INFO("misc_register(fhp_dev) success");
+    return 0;
+}
+
+static long fhp_input_report(struct fhp_core_data *fhp_data, unsigned long arg)
+{
+    int ret = 0;
+    u8 report_buf[FTS_TOUCH_DATA_LEN_V2] = { 0 };
+    struct fhp_input_report_data report;
+
+    if (!fhp_data || !fhp_data->ts_data) {
+        FTS_ERROR("fhp_data/ts_data is null");
+        return -EINVAL;
+    }
+
+    if (copy_from_user(&report, (void *)arg, sizeof(struct fhp_input_report_data))) {
+        FTS_ERROR("copy input touch report data from userspace fail");
+        return -EFAULT;
+    }
+
+    if ((report.size <= 0) || (report.size > FTS_TOUCH_DATA_LEN_V2)) {
+        FTS_ERROR("report size(%d) is invalid", report.size);
+        return -EINVAL;
+    }
+
+    memset(report_buf, 0xFF, FTS_TOUCH_DATA_LEN_V2);
+    if (copy_from_user(report_buf, report.buffer , report.size)) {
+        FTS_ERROR("copy input touch report buffer from userspace fail");
+        return -EFAULT;
+    }
+
+    if ((report_buf[1] == 0xFF) && (report_buf[2] == 0xFF) && (report_buf[3] == 0xFF) && (report_buf[4] == 0xFF)) {
+        fts_release_all_finger();
+        fts_tp_state_recovery(fhp_data->ts_data);
+        return 0;
+    }
+
+    ret = fts_input_report_buffer(fhp_data->ts_data, report_buf);
+    if (ret < 0) {
+        FTS_ERROR("report buffer failed");
+        return ret;
+    }
+    return 0;
+}
+
+static int fhp_input_open(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int fhp_input_close(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static long fhp_input_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct fhp_core_data *fhp_data = container_of(filp->private_data, struct fhp_core_data, fhpi_dev);
+
+    if (!fhp_data) {
+        FTS_ERROR("fhp_data is null");
+        return -ENODATA;
+    }
+
+    switch (cmd) {
+    case FHP_INPUT_IOCTL_REPORT:
+        ret = fhp_input_report(fhp_data, arg);
+        break;
+    default:
+        FTS_ERROR("unkown ioctl cmd(0x%x)", (int)cmd);
+        return -EINVAL;
+    }
+
+    return ret;
+}
+/*
+* On certain platforms, it is necessary to initialize the open function in order to initialize the private_data of the current device.
+* Otherwise, there may be a situation where using container_of to retrieve the device fails.
+*/
+static struct file_operations fhp_input_fops = {
+    .open = fhp_input_open,
+    .release = fhp_input_close,
+    .unlocked_ioctl = fhp_input_ioctl,
+};
+
+static int fhp_input_miscdev_init(struct fhp_core_data *fhp_data)
+{
+    int ret = 0;
+
+    fhp_data->fhpi_dev.minor = MISC_DYNAMIC_MINOR;
+    fhp_data->fhpi_dev.name = FTS_FHPI_DEV_NAME;
+    fhp_data->fhpi_dev.fops = &fhp_input_fops;
+    ret = misc_register(&fhp_data->fhpi_dev);
+    if (ret) {
+        FTS_ERROR("misc_register(input misc device) fail");
+        return ret;
+    }
+
+    FTS_INFO("misc_register(input misc device) success");
+    return 0;
+}
+
+static int fhp_get_frame(u8 *touch_buf, u32 touch_size)
+{
+    struct fhp_core_data *fhp_data = fts_fhp_data;
+    if (!touch_buf || !touch_size) {
+        FTS_ERROR("touch_buf is null/touch_size is 0");
+        return -EINVAL;
+    }
+
+    if (fhp_data->q.elem_size != (sizeof(struct fhp_frame) + touch_size)) {
+        FTS_ERROR("touch size(%u,%d,%lu) is invalid", touch_size, fhp_data->q.elem_size, sizeof(struct fhp_frame));
+        return -EINVAL;
+    }
+
+    fhpq_enqueue(&fhp_data->q, touch_buf, fhp_get_timestamp());
+
+    if ((fhp_data->frame_waitq_flag == FHP_FRAME_WAITQ_WAIT)
+        || (fhp_data->frame_waitq_flag == FHP_FRAME_WAITQ_WAIT_POLL)) {
+        fhp_data->frame_waitq_flag = FHP_FRAME_WAITQ_WAKEUP;
+        wake_up_interruptible(&fhp_data->frame_waitq);
+    }
+
+    return 0;
+}
+
+int fts_fhp_irq_handler(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    u8 cmd = FHP_CMD_GET_FRAME;
+
+    if (!ts_data || !ts_data->touch_buf) {
+        FTS_ERROR("ts_data/touch_buf is null");
+        return -EINVAL;
+    }
+
+    if (!ts_data->touch_size || (ts_data->touch_size > FTS_MAX_TOUCH_BUF)) {
+        FTS_ERROR("touch_size(%d) is invalid", ts_data->touch_size);
+        return -EINVAL;
+    }
+
+    if (ts_data->suspended && ts_data->gesture_support) {
+        fts_gesture_readdata(ts_data, NULL);
+        return 0;
+    }
+
+    ret = fts_read(&cmd, 1, ts_data->touch_buf, ts_data->touch_size);
+    if (ret < 0) {
+        FTS_ERROR("read frame data failed");
+        return ret;
+    }
+
+    ret = fhp_get_frame(ts_data->touch_buf, ts_data->touch_size);
+    if (ret < 0) {
+        FTS_ERROR("get frame failed");
+        return ret;
+    }
+
+    return 0;
+}
+
+int fts_fhp_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fhp_core_data *fhp_data = NULL;
+
+    FTS_FUNC_ENTER();
+    fhp_data = kzalloc(sizeof(struct fhp_core_data), GFP_KERNEL);
+    if (!fhp_data) {
+        FTS_ERROR("allocate memory for fhp_data failed");
+        return -ENOMEM;
+    }
+
+    fts_fhp_data = fhp_data;
+    fhp_data->ts_data = ts_data;
+    fhp_data->fhp_dev_open_cnt = 0;
+    fhp_data->frame_waitq_flag = FHP_FRAME_WAITQ_DEFAULT;
+    init_waitqueue_head(&fhp_data->frame_waitq);
+    mutex_init(&fhp_data->q.mutexq);
+
+    /*register /dev/fhp_ft*/
+    ret = fhp_miscdev_init(fhp_data);
+    if (ret) {
+        FTS_ERROR("fhp_dev miscdev register fail");
+        goto err_miscdev_init;
+    }
+
+    ret = fhp_input_miscdev_init(fhp_data);
+    if (ret) {
+        FTS_ERROR("input misc device register fail");
+        goto err_input_miscdev_init;
+    }
+
+    FTS_FUNC_EXIT();
+    return 0;
+
+err_input_miscdev_init:
+    misc_deregister(&fhp_data->fhp_dev);
+err_miscdev_init:
+    kfree(fhp_data);
+    fhp_data = NULL;
+    return ret;
+}
+
+void fts_fhp_exit(struct fts_ts_data *ts_data)
+{
+    struct fhp_core_data *fhp_data = fts_fhp_data;
+    FTS_FUNC_ENTER();
+    if (fhp_data) {
+        misc_deregister(&fhp_data->fhpi_dev);
+        misc_deregister(&fhp_data->fhp_dev);
+        kfree(fhp_data);
+        fhp_data = NULL;
+    }
+    FTS_FUNC_EXIT();
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_i2c.c b/drivers/input/touchscreen/focaltech_touch/focaltech_i2c.c
new file mode 100755
index 000000000000..0604433a835f
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_i2c.c
@@ -0,0 +1,335 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/************************************************************************
+*
+* File Name: focaltech_i2c.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-08-04
+*
+* Abstract: i2c communication with TP
+*
+* Version: v2.0
+*
+* Revision History:
+*
+************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define I2C_RETRY_NUMBER                    3
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+
+/*****************************************************************************
+* functions body
+*****************************************************************************/
+int fts_read(u8 *cmd, u32 cmdlen, u8 *data, u32 datalen)
+{
+    int ret = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = fts_data;
+    struct i2c_msg msg_list[2];
+    struct i2c_msg *msg = NULL;
+    int msg_num = 0;
+
+    /* must have data when read */
+    if (!ts_data || !ts_data->client || !data || !datalen
+        || (datalen > FTS_MAX_BUS_BUF) || (cmdlen > FTS_MAX_BUS_BUF)) {
+        FTS_ERROR("fts_data/client/cmdlen(%d)/data/datalen(%d) is invalid",
+                  cmdlen, datalen);
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+    memset(&msg_list[0], 0, sizeof(struct i2c_msg));
+    memset(&msg_list[1], 0, sizeof(struct i2c_msg));
+    memcpy(ts_data->bus_tx_buf, cmd, cmdlen);
+    msg_list[0].addr = ts_data->client->addr;
+    msg_list[0].flags = 0;
+    msg_list[0].len = cmdlen;
+    msg_list[0].buf = ts_data->bus_tx_buf;
+    msg_list[1].addr = ts_data->client->addr;
+    msg_list[1].flags = I2C_M_RD;
+    msg_list[1].len = datalen;
+    msg_list[1].buf = ts_data->bus_rx_buf;
+    if (cmd && cmdlen) {
+        msg = &msg_list[0];
+        msg_num = 2;
+    } else {
+        msg = &msg_list[1];
+        msg_num = 1;
+    }
+
+    for (i = 0; i < I2C_RETRY_NUMBER; i++) {
+        ret = i2c_transfer(ts_data->client->adapter, msg, msg_num);
+        if (ret < 0) {
+            FTS_ERROR("i2c_transfer(read) fail,ret:%d", ret);
+        } else {
+            memcpy(data, ts_data->bus_rx_buf, datalen);
+            break;
+        }
+    }
+
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+int fts_write(u8 *writebuf, u32 writelen)
+{
+    int ret = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = fts_data;
+    struct i2c_msg msgs;
+
+    if (!ts_data || !ts_data->client || !writebuf || !writelen
+        || (writelen > FTS_MAX_BUS_BUF)) {
+        FTS_ERROR("fts_data/client/data/datalen(%d) is invalid", writelen);
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+    memset(&msgs, 0, sizeof(struct i2c_msg));
+    memcpy(ts_data->bus_tx_buf, writebuf, writelen);
+    msgs.addr = ts_data->client->addr;
+    msgs.flags = 0;
+    msgs.len = writelen;
+    msgs.buf = ts_data->bus_tx_buf;
+    for (i = 0; i < I2C_RETRY_NUMBER; i++) {
+        ret = i2c_transfer(ts_data->client->adapter, &msgs, 1);
+        if (ret < 0) {
+            FTS_ERROR("i2c_transfer(write) fail,ret:%d", ret);
+        } else {
+            break;
+        }
+    }
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+int fts_read_reg(u8 addr, u8 *value)
+{
+    return fts_read(&addr, 1, value, 1);
+}
+
+int fts_write_reg(u8 addr, u8 value)
+{
+    u8 buf[2] = { 0 };
+
+    buf[0] = addr;
+    buf[1] = value;
+    return fts_write(buf, sizeof(buf));
+}
+
+int fts_bus_transfer_direct(u8 *writebuf, u32 writelen, u8 *readbuf, u32 readlen)
+{
+    return 0;
+}
+
+int fts_bus_configure(struct fts_ts_data *ts_data, u8 *buf, u32 size)
+{
+    FTS_FUNC_ENTER();
+    if (ts_data->client && buf && size && (buf[0] != ts_data->client->addr)) {
+        ts_data->client->addr = buf[0];
+        FTS_INFO("Change i2c addr 0x%x to 0x%x", (ts_data->client->addr << 1), (buf[0] << 1));
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_bus_set_speed(struct fts_ts_data *ts_data, u32 speed)
+{
+    return 0;
+}
+
+
+/*****************************************************************************
+* TP Driver
+*****************************************************************************/
+static int fts_ts_probe(struct i2c_client *client)
+{
+    int ret = 0;
+    struct fts_ts_data *ts_data = NULL;
+
+    FTS_INFO("Touch Screen(I2C BUS) driver prboe...");
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        FTS_ERROR("I2C not supported");
+        return -ENODEV;
+    }
+
+    /* malloc memory for global struct variable */
+    ts_data = (struct fts_ts_data *)kzalloc(sizeof(*ts_data), GFP_KERNEL);
+    if (!ts_data) {
+        FTS_ERROR("allocate memory for fts_data fail");
+        return -ENOMEM;
+    }
+
+    ts_data->client = client;
+    ts_data->dev = &client->dev;
+    ts_data->log_level = 1;
+    ts_data->fw_is_running = 0;
+    ts_data->bus_type = BUS_TYPE_I2C;
+    ts_data->bus_ver = BUS_VER_DEFAULT;
+    i2c_set_clientdata(client, ts_data);
+
+    ret = fts_ts_probe_entry(ts_data);
+    if (ret) {
+        FTS_ERROR("Touch Screen(I2C BUS) driver probe fail");
+        i2c_set_clientdata(client, NULL);
+        kfree_safe(ts_data);
+        return ret;
+    }
+
+    FTS_INFO("Touch Screen(I2C BUS) driver prboe successfully");
+    return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+static void fts_ts_remove(struct i2c_client *client)
+{
+    struct fts_ts_data *ts_data = i2c_get_clientdata(client);
+    FTS_INFO("Touch Screen(I2C BUS) driver remove...");
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        i2c_set_clientdata(client, NULL);
+        kfree_safe(ts_data);
+    }
+}
+#else
+static int fts_ts_remove(struct i2c_client *client)
+{
+    struct fts_ts_data *ts_data = i2c_get_clientdata(client);
+    FTS_INFO("Touch Screen(I2C BUS) driver remove...");
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        i2c_set_clientdata(client, NULL);
+        kfree_safe(ts_data);
+    }
+    return 0;
+}
+#endif
+
+static void fts_ts_shutdown(struct i2c_client *client)
+{
+    struct fts_ts_data *ts_data = i2c_get_clientdata(client);
+    FTS_FUNC_ENTER();
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        i2c_set_clientdata(client, NULL);
+        kfree_safe(ts_data);
+    }
+    FTS_FUNC_EXIT();
+}
+
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+static int fts_pm_suspend(struct device *dev)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    FTS_INFO("system enters into pm_suspend");
+    ts_data->pm_suspend = true;
+    reinit_completion(&ts_data->pm_completion);
+    return 0;
+}
+
+static int fts_pm_resume(struct device *dev)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    FTS_INFO("system resumes from pm_suspend");
+    ts_data->pm_suspend = false;
+    complete(&ts_data->pm_completion);
+    return 0;
+}
+
+static const struct dev_pm_ops fts_dev_pm_ops = {
+    .suspend = fts_pm_suspend,
+    .resume = fts_pm_resume,
+};
+#endif
+
+static const struct i2c_device_id fts_ts_id[] = {
+    {FTS_DRIVER_NAME, 0},
+    {},
+};
+static const struct of_device_id fts_dt_match[] = {
+    {.compatible = "focaltech,fts", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, fts_dt_match);
+
+static struct i2c_driver fts_ts_i2c_driver = {
+    .probe = fts_ts_probe,
+    .remove = fts_ts_remove,
+    .shutdown = fts_ts_shutdown,
+    .driver = {
+        .name = FTS_DRIVER_NAME,
+        .owner = THIS_MODULE,
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+        .pm = &fts_dev_pm_ops,
+#endif
+        .of_match_table = of_match_ptr(fts_dt_match),
+    },
+    .id_table = fts_ts_id,
+};
+
+static int __init fts_ts_i2c_init(void)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    ret = i2c_add_driver(&fts_ts_i2c_driver);
+    if ( ret != 0 ) {
+        FTS_ERROR("Focaltech touch screen driver(I2C) init failed!");
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static void __exit fts_ts_i2c_exit(void)
+{
+    i2c_del_driver(&fts_ts_i2c_driver);
+}
+
+module_init(fts_ts_i2c_init);
+module_exit(fts_ts_i2c_exit);
+
+MODULE_AUTHOR("FocalTech Driver Team");
+MODULE_DESCRIPTION("FocalTech Touchscreen Driver(I2C)");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_point_report_check.c b/drivers/input/touchscreen/focaltech_touch/focaltech_point_report_check.c
new file mode 100755
index 000000000000..8b117a8bb431
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_point_report_check.c
@@ -0,0 +1,185 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_point_report_check.c
+*
+* Author: Focaltech Driver Team
+*
+* Created: 2016-11-16
+*
+* Abstract: point report check function
+*
+* Version: v1.0
+*
+* Revision History:
+*
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define POINT_REPORT_CHECK_WAIT_TIME                200    /* unit:ms */
+#define PRC_INTR_INTERVALS                          100    /* unit:ms */
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+
+/*****************************************************************************
+* functions body
+*****************************************************************************/
+/*****************************************************************************
+*  Name: fts_prc_func
+*  Brief: fts point report check work func, report whole up of points
+*  Input:
+*  Output:
+*  Return:
+*****************************************************************************/
+static void fts_prc_func(struct work_struct *work)
+{
+    struct fts_ts_data *ts_data = container_of(work,
+                                  struct fts_ts_data, prc_work.work);
+    unsigned long cur_jiffies = jiffies;
+    unsigned long intr_timeout = msecs_to_jiffies(PRC_INTR_INTERVALS);
+
+    if (ts_data->prc_support && !ts_data->suspended) {
+        intr_timeout += ts_data->intr_jiffies;
+        if (time_after(cur_jiffies, intr_timeout)) {
+            if (ts_data->touch_points) {
+                fts_release_all_finger();
+                if (ts_data->log_level >= 3)
+                    FTS_DEBUG("prc trigger interval:%dms",
+                              jiffies_to_msecs(cur_jiffies - ts_data->intr_jiffies));
+            }
+            ts_data->prc_mode = 0;
+        } else {
+            queue_delayed_work(ts_data->ts_workqueue, &ts_data->prc_work,
+                               msecs_to_jiffies(POINT_REPORT_CHECK_WAIT_TIME));
+            ts_data->prc_mode = 1;
+        }
+    } else {
+        ts_data->prc_mode = 0;
+    }
+}
+
+/*****************************************************************************
+*  Name: fts_prc_queue_work
+*  Brief: fts point report check queue work, call it when interrupt comes
+*  Input:
+*  Output:
+*  Return:
+*****************************************************************************/
+void fts_prc_queue_work(struct fts_ts_data *ts_data)
+{
+    if (ts_data->prc_support && !ts_data->prc_mode && !ts_data->suspended) {
+        queue_delayed_work(ts_data->ts_workqueue, &ts_data->prc_work,
+                           msecs_to_jiffies(POINT_REPORT_CHECK_WAIT_TIME));
+        ts_data->prc_mode = 1;
+    }
+}
+
+
+static ssize_t fts_prc_store(
+    struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        FTS_DEBUG("enable prc");
+        ts_data->prc_support = ENABLE;
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("disable prc");
+        cancel_delayed_work_sync(&ts_data->prc_work);
+        ts_data->prc_support = DISABLE;
+    }
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static ssize_t fts_prc_show(
+    struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct input_dev *input_dev = ts_data->input_dev;
+
+    mutex_lock(&input_dev->mutex);
+    count = snprintf(buf, PAGE_SIZE, "PRC: %s\n", \
+                     ts_data->prc_support ? "Enable" : "Disable");
+    mutex_unlock(&input_dev->mutex);
+
+    return count;
+}
+
+static DEVICE_ATTR(fts_prc, S_IRUGO | S_IWUSR, fts_prc_show, fts_prc_store);
+
+/*****************************************************************************
+*  Name: fts_point_report_check_init
+*  Brief:
+*  Input:
+*  Output:
+*  Return: < 0: Fail to create esd check queue
+*****************************************************************************/
+int fts_point_report_check_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+
+    if (ts_data->ts_workqueue) {
+        INIT_DELAYED_WORK(&ts_data->prc_work, fts_prc_func);
+    } else {
+        FTS_ERROR("fts workqueue is NULL, can't run point report check function");
+        return -EINVAL;
+    }
+
+    ret = sysfs_create_file(&ts_data->dev->kobj, &dev_attr_fts_prc.attr);
+    if ( ret < 0) {
+        FTS_ERROR("create prc sysfs fail");
+    }
+
+    ts_data->prc_support = FTS_POINT_REPORT_CHECK_EN;
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+/*****************************************************************************
+*  Name: fts_point_report_check_exit
+*  Brief:
+*  Input:
+*  Output:
+*  Return:
+*****************************************************************************/
+int fts_point_report_check_exit(struct fts_ts_data *ts_data)
+{
+    FTS_FUNC_ENTER();
+    cancel_delayed_work_sync(&ts_data->prc_work);
+    sysfs_remove_file(&ts_data->dev->kobj, &dev_attr_fts_prc.attr);
+    FTS_FUNC_EXIT();
+    return 0;
+}
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_proximity.c b/drivers/input/touchscreen/focaltech_touch/focaltech_proximity.c
new file mode 100755
index 000000000000..b656e0abcb9c
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_proximity.c
@@ -0,0 +1,827 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*****************************************************************************
+*
+* File Name: focaltech_proximity.c
+*
+*    Author: Focaltech Driver Team
+*
+*   Created: 2016-09-19
+*
+*  Abstract: close proximity function
+*
+*   Version: v1.0
+*
+* Revision History:
+*        v1.0:
+*            First release based on xiaguobin's solution. By luougojin 2016-08-19
+*****************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+#include "focaltech_common.h"
+
+#if FTS_PSENSOR_EN
+/*****************************************************************************
+ * Private constant and macro definitions using #define
+ *****************************************************************************/
+/* proximity register address*/
+#define FTS_REG_PSENSOR_ENABLE                  0xB0
+#define FTS_REG_PSENSOR_STATUS                  0xB5
+#define FTS_REG_PSENSOR_CLEAR_STATUS            0xB6
+
+/* proximity register value read from TP */
+#define PROXIMITY_TP_VAL_NEAR                   0xC0
+#define PROXIMITY_TP_VAL_FAR                    0xE0
+#define PROXIMITY_TP_VAL_ERROR                  0xEE
+#define PROXIMITY_TP_VAL_DEFAULT                0xFF
+
+/* host state : far or near */
+#define PROXIMITY_HOST_STATE_NEAR               0
+#define PROXIMITY_HOST_STATE_FAR                1
+#define PROXIMITY_HOST_STATE_DEFAULT            PROXIMITY_HOST_STATE_FAR
+
+/* proximity solutions */
+#define PROXIMITY_SOLUTION_SAMPLE               0
+#define PROXIMITY_SOLUTION_QCOM                 1
+#define PROXIMITY_SOLUTION_MTK                  2
+#define PROXIMITY_SOLUTION_SAMPLE_1             3
+#define PROXIMITY_SOLUTION                      PROXIMITY_SOLUTION_SAMPLE
+
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+struct fts_proximity_ops;
+
+/*
+ * @tp_val, proximity value read from TP register, the value is:
+ *          PROXIMITY_TP_VAL_NEAR/PROXIMITY_TP_VAL_FAR and so on.
+ *
+ * @tp_val_last, the backup proximity value
+ * @host_state, the proximity state of host, tp driver will report the
+ *      value to Android, the value is:
+ *          PROXIMITY_HOST_STATE_NEAR
+ *          PROXIMITY_HOST_STATE_FAR
+ */
+struct fts_proximity {
+    struct fts_ts_data *ts_data;
+    struct input_dev *proximity_input_dev;
+    struct fts_proximity_ops *ops;
+    u8 tp_val;
+    u8 tp_val_last;
+    int host_state;
+};
+
+struct fts_proximity_ops {
+    int (*init)(struct fts_proximity *proximity_data);
+    int (*exit)(struct fts_proximity *proximity_data);
+    int (*report)(struct fts_proximity *proximity_data);
+};
+
+/*****************************************************************************
+* variables or functions
+*****************************************************************************/
+static struct fts_proximity fts_proximity_data;
+
+
+static void fts_proximity_set_reg(int value)
+{
+    int i = 0;
+    u8 enable_value = value ? 0x01 : 0x00;
+    u8 regval = 0xFF;
+
+    for (i = 0; i < FTS_MAX_RETRIES_WRITEREG; i++) {
+        fts_read_reg(FTS_REG_PSENSOR_ENABLE, &regval);
+        if (regval == enable_value)
+            break;
+        fts_write_reg(FTS_REG_PSENSOR_ENABLE, enable_value);
+        fts_msleep(1);
+    }
+
+    if (i >= FTS_MAX_RETRIES_WRITEREG)
+        FTS_ERROR("set proximity mode to %x failed,reg_val:%x", enable_value, regval);
+    else if (i > 0)
+        FTS_INFO("set proximity mode to %x successfully", value);
+}
+
+/************************************************************************
+* Name: fts_proximity_enable
+* Brief:  enable or disable proximity function, set variable and write it
+*         to TP FW.
+*
+* Input:  proximity_data, global structure variable.
+*         @enable, 0 is to disable proximity, 1 to enable.
+* Output:
+*
+* Return: 0 for success
+***********************************************************************/
+static int fts_proximity_enable(struct fts_proximity *proximity_data, int enable)
+{
+    int ret = 0;
+    if (!proximity_data || !proximity_data->ts_data || !proximity_data->proximity_input_dev) {
+        FTS_ERROR("proximity/ts/input is null");
+        return -EINVAL;
+    }
+
+    FTS_INFO("set proximity mode to %s", !!enable ? "enable" : "disable");
+    mutex_lock(&proximity_data->proximity_input_dev->mutex);
+    proximity_data->ts_data->proximity_mode = !!enable;
+    fts_proximity_set_reg(enable);
+    proximity_data->tp_val = PROXIMITY_TP_VAL_DEFAULT;
+    proximity_data->tp_val_last = PROXIMITY_TP_VAL_DEFAULT;
+    proximity_data->host_state = PROXIMITY_HOST_STATE_DEFAULT;
+    mutex_unlock(&proximity_data->proximity_input_dev->mutex);
+    return ret;
+}
+
+
+
+
+#if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_MTK)
+#include <hwmsensor.h>
+#include <sensors_io.h>
+#include <alsps.h>
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+/*
+ * FTS_ALSPS_SUPPORT is choose structure hwmsen_object or control_path, data_path
+ * FTS_ALSPS_SUPPORT = 1, is control_path, data_path
+ * FTS_ALSPS_SUPPORT = 0, hwmsen_object
+ */
+#define FTS_ALSPS_SUPPORT            1
+/*
+ * FTS_OPEN_DATA_HAL_SUPPORT is choose structure ps_control_path or batch, flush
+ * FTS_ALSPS_SUPPORT = 1, is batch, flush
+ * FTS_ALSPS_SUPPORT = 0, NULL
+ */
+#define FTS_OPEN_DATA_HAL_SUPPORT    1
+
+#if !FTS_ALSPS_SUPPORT
+#include <hwmsen_dev.h>
+#endif
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+
+#if FTS_ALSPS_SUPPORT
+/* if use  this typ of enable , Gsensor should report inputEvent(x, y, z ,stats, div) to HAL */
+static int ps_open_report_data(int open)
+{
+    /* should queue work to report event if  is_report_input_direct=true */
+    return 0;
+}
+
+/* if use  this type of enable , Psensor only enabled but not report inputEvent to HAL */
+static int ps_enable_nodata(int en)
+{
+    int ret = 0;
+    FTS_DEBUG("[PROXIMITY]SENSOR_ENABLE value = %d", en);
+    /* Enable proximity */
+    ret = fts_proximity_enable(fts_proximity_data, en);
+    return ret;
+}
+
+static int ps_set_delay(u64 ns)
+{
+    return 0;
+}
+
+#if FTS_OPEN_DATA_HAL_SUPPORT
+static int ps_batch(int flag, int64_t sampling_period_ns, int64_t max_batch_report_ns)
+{
+    return 0;
+}
+
+static int ps_flush(void)
+{
+    return 0;
+}
+#endif
+
+static int ps_get_data(int *value, int *status)
+{
+    *value = (int)fts_proximity_data.host_state;
+    FTS_DEBUG("proximity status = %d\n", *value);
+    *status = SENSOR_STATUS_ACCURACY_MEDIUM;
+    return 0;
+}
+
+static int ps_local_init(void)
+{
+    int err = 0;
+    struct ps_control_path ps_ctl = { 0 };
+    struct ps_data_path ps_data = { 0 };
+
+    ps_ctl.is_use_common_factory = false;
+    ps_ctl.open_report_data = ps_open_report_data;
+    ps_ctl.enable_nodata = ps_enable_nodata;
+    ps_ctl.set_delay = ps_set_delay;
+#if FTS_OPEN_DATA_HAL_SUPPORT
+    ps_ctl.batch = ps_batch;
+    ps_ctl.flush = ps_flush;
+#endif
+    ps_ctl.is_report_input_direct = false;
+    ps_ctl.is_support_batch = false;
+
+    err = ps_register_control_path(&ps_ctl);
+    if (err) {
+        FTS_ERROR("register fail = %d\n", err);
+    }
+    ps_data.get_data = ps_get_data;
+    ps_data.vender_div = 100;
+    err = ps_register_data_path(&ps_data);
+    if (err) {
+        FTS_ERROR("tregister fail = %d\n", err);
+    }
+
+    return err;
+}
+int ps_local_uninit(void)
+{
+    return 0;
+}
+
+struct alsps_init_info ps_init_info = {
+    .name = "fts_ts",
+    .init = ps_local_init,
+    .uninit = ps_local_uninit,
+};
+
+#else
+
+static int mtk_ps_operate(void *self, uint32_t command, void *buff_in,
+                          int size_in, void *buff_out, int size_out, int *actualout)
+{
+    int err = 0;
+    int value;
+    struct hwm_sensor_data *sensor_data;
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+
+    if (!proximity_data || !proximity_data->ts_data) {
+        FTS_ERROR("proximity_data/ts_data" is null);
+        return -EINVAL;
+    }
+
+    FTS_DEBUG("[PROXIMITY]COMMAND = %d", command);
+    switch (command) {
+    case SENSOR_DELAY:
+        if ((buff_in == NULL) || (size_in < sizeof(int))) {
+            FTS_ERROR("[PROXIMITY]Set delay parameter error!");
+            err = -EINVAL;
+        }
+        break;
+
+    case SENSOR_ENABLE:
+        if ((buff_in == NULL) || (size_in < sizeof(int))) {
+            FTS_ERROR("[PROXIMITY]Enable sensor parameter error!");
+            err = -EINVAL;
+        } else {
+            value = *(int *)buff_in;
+            FTS_DEBUG("[PROXIMITY]SENSOR_ENABLE value = %d", value);
+            /* Enable proximity */
+            err = fts_proximity_enable(proximity_data, value);
+        }
+        break;
+
+    case SENSOR_GET_DATA:
+        if ((buff_out == NULL) || (size_out < sizeof(struct hwm_sensor_data))) {
+            FTS_ERROR("[PROXIMITY]get sensor data parameter error!");
+            err = -EINVAL;
+        } else {
+            sensor_data = (struct hwm_sensor_data *)buff_out;
+            sensor_data->values[0] = (int)proximity_data->host_state;
+            FTS_DEBUG("sensor_data->values[0] = %d", sensor_data->values[0]);
+            sensor_data->value_divide = 1;
+            sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
+        }
+        break;
+    default:
+        FTS_ERROR("[PROXIMITY]ps has no operate function:%d!", command);
+        err = -EPERM;
+        break;
+    }
+
+    return err;
+}
+#endif
+
+
+static int mtk_proximity_report(struct fts_proximity *proximity_data)
+{
+    int ret = 0;
+    int proximity_state = PROXIMITY_HOST_STATE_DEFAULT;
+#if !FTS_ALSPS_SUPPORT
+    struct hwm_sensor_data sensor_data;
+#endif
+
+    if (proximity_data->tp_val == PROXIMITY_TP_VAL_NEAR) {
+        /* close. need lcd off */
+        proximity_state = PROXIMITY_HOST_STATE_NEAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_FAR) {
+        /* far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_ERROR) {
+        /* error, need report far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    }
+
+    if (proximity_state != proximity_data->host_state) {
+        FTS_INFO("report proximity state:%s", proximity_state ? "AWAY" : "NEAR");
+        proximity_data->host_state = proximity_state;
+#if FTS_ALSPS_SUPPORT
+        ret = ps_report_interrupt_data(proximity_state);
+#else
+        sensor_data.values[0] = proximity_state;
+        sensor_data.value_divide = 1;
+        sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+        ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
+        if (ret) {
+            FTS_ERROR("[PROXIMITY] Call hwmsen_get_interrupt_data failed, ret=%d", ret);
+            return ret;
+        }
+#endif
+        return FTS_RETVAL_IGNORE_TOUCHES;
+    }
+
+    return 0;
+}
+
+static int mtk_proximity_init(struct fts_proximity *proximity_data)
+{
+#if !FTS_ALSPS_SUPPORT
+    int err = 0;
+    struct hwmsen_object obj_ps;
+#endif
+
+    FTS_FUNC_ENTER();
+#if FTS_ALSPS_SUPPORT
+    alsps_driver_add(&ps_init_info);
+#else
+    obj_ps.polling = 0; /* interrupt mode */
+    obj_ps.sensor_operate = mtk_ps_operate;
+    err = hwmsen_attach(ID_PROXIMITY, &obj_ps);
+    if (err)
+        FTS_ERROR("[PROXIMITY]fts proximity attach fail = %d!", err);
+    else
+        FTS_INFO("[PROXIMITY]fts proximity attach ok = %d\n", err);
+#endif
+
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+struct fts_proximity_ops mtk_proximity_ops = {
+    .init = mtk_proximity_init,
+    .report = mtk_proximity_report,
+};
+#endif
+
+#if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_QCOM)
+#include <linux/sensors.h>
+
+struct qcom_proximity {
+    struct fts_proximity *proximity_data;
+    struct sensors_classdev ps_cdev;
+};
+
+static struct qcom_proximity qcom_proximity_data;
+
+static struct sensors_classdev __maybe_unused qcom_proximity_cdev = {
+    .name = "fts-proximity",
+    .vendor = "FocalTech",
+    .version = 1,
+    .handle = SENSORS_PROXIMITY_HANDLE,
+    .type = SENSOR_TYPE_PROXIMITY,
+    .max_range = "5.0",
+    .resolution = "5.0",
+    .sensor_power = "0.1",
+    .min_delay = 0,
+    .fifo_reserved_event_count = 0,
+    .fifo_max_event_count = 0,
+    .enabled = 0,
+    .delay_msec = 200,
+    .sensors_enable = NULL,
+    .sensors_poll_delay = NULL,
+};
+
+static int qcom_proximity_enable(struct sensors_classdev *sensors_cdev, unsigned int enable)
+{
+    struct qcom_proximity *qps = container_of(sensors_cdev, struct qcom_proximity, ps_cdev);
+    if (qps && qps->proximity_data) {
+        fts_proximity_enable(qps->proximity_data, enable);
+    }
+    return enable;
+}
+
+static int qcom_proximity_report(struct fts_proximity *proximity_data)
+{
+    int proximity_state = PROXIMITY_HOST_STATE_DEFAULT;
+
+    if (!proximity_data || !proximity_data->proximity_input_dev) {
+        FTS_ERROR("proximity/input is null");
+        return -EINVAL;
+    }
+
+    if (proximity_data->tp_val == PROXIMITY_TP_VAL_NEAR) {
+        /* close. need lcd off */
+        proximity_state = PROXIMITY_HOST_STATE_NEAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_FAR) {
+        /* far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_ERROR) {
+        /* error, need report far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    }
+
+    if (proximity_state != proximity_data->host_state) {
+        FTS_INFO("report proximity state:%s", proximity_state ? "AWAY" : "NEAR");
+        proximity_data->host_state = proximity_state;
+        input_report_abs(proximity_data->proximity_input_dev, ABS_DISTANCE,
+                         (proximity_state == PROXIMITY_HOST_STATE_NEAR) ? 0 : 1;
+                         input_sync(proximity_data->proximity_input_dev);
+                         return FTS_RETVAL_IGNORE_TOUCHES;
+    }
+
+    return 0;
+}
+
+static int qcom_proximity_init(struct fts_proximity *proximity_data)
+{
+    int ret = 0;
+    struct qcom_proximity *qps = &qcom_proximity_data;
+    FTS_FUNC_ENTER();
+    if (proximity_data && proximity_data->ts_data && proximity_data->ts_data->dev) {
+        memset(qps, 0, sizeof(struct qcom_proximity));
+        qps->proximity_data = proximity_data;
+        qps->ps_cdev = qcom_proximity_cdev;
+        qps->ps_cdev.sensors_enable = qcom_proximity_enable;
+        ret = sensors_classdev_register(proximity_data->ts_data->dev, &qps->ps_cdev);
+        if (ret) FTS_ERROR("sensors_classdev_register failed,ret=%d", ret);
+    } else {
+        FTS_ERROR("proximity/ts/device is null");
+        ret = -EINVAL;
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static int qcom_proximity_exit(struct fts_proximity *proximity_data)
+{
+    FTS_FUNC_ENTER();
+    sensors_classdev_unregister(qcom_proximity_data.ps_cdev);
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+struct fts_proximity_ops qcom_proximity_ops = {
+    .init = qcom_proximity_init,
+    .exit = qcom_proximity_exit,
+    .report = qcom_proximity_report,
+};
+#endif // #if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_QCOM)
+
+
+#if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE_1)
+static int sample_1_proximity_report(struct fts_proximity *proximity_data)
+{
+    u8 clear_status_value = 0xFF;
+    int proximity_state = PROXIMITY_HOST_STATE_DEFAULT;
+
+    if (!proximity_data || !proximity_data->proximity_input_dev) {
+        FTS_ERROR("proximity/input is null");
+        return -EINVAL;
+    }
+
+    if ((proximity_data->tp_val > 0x00) && (proximity_data->tp_val < 0x04)) {
+        /* close. need lcd off */
+        proximity_state = PROXIMITY_HOST_STATE_NEAR;
+        clear_status_value = 1;
+    } else if (proximity_data->tp_val == 0x00) {
+        /* far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+        clear_status_value = 0;
+    } else {
+        /* error, need report far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+        clear_status_value = 0xEE;
+    }
+
+    if (proximity_data->tp_val != proximity_data->tp_val_last) {
+        FTS_DEBUG("tp proximity status:%x->%x", proximity_data->tp_val_last, proximity_data->tp_val);
+        tpd_notifier_call_chain(proximity_data->host_state, NULL);
+        fts_write_reg(FTS_REG_PSENSOR_CLEAR_STATUS, clear_status_value);
+    }
+
+    if (proximity_state != proximity_data->host_state) {
+        FTS_INFO("report proximity state:%s", proximity_state ? "AWAY" : "NEAR");
+        proximity_data->host_state = proximity_state;
+        return FTS_RETVAL_IGNORE_TOUCHES;
+    }
+
+    return 0;
+}
+
+static struct fts_proximity_ops sample_1_proximity_ops = {
+    .report = sample_1_proximity_report,
+};
+#endif // #if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE_1)
+
+
+#if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE)
+static int sample_proximity_report(struct fts_proximity *proximity_data)
+{
+    int proximity_state = PROXIMITY_HOST_STATE_DEFAULT;
+    if (!proximity_data || !proximity_data->proximity_input_dev) {
+        FTS_ERROR("proximity/input is null");
+        return -EINVAL;
+    }
+
+    if (proximity_data->tp_val == PROXIMITY_TP_VAL_NEAR) {
+        /* close. need lcd off */
+        proximity_state = PROXIMITY_HOST_STATE_NEAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_FAR) {
+        /* far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    } else if (proximity_data->tp_val == PROXIMITY_TP_VAL_ERROR) {
+        /* error, need report far away */
+        proximity_state = PROXIMITY_HOST_STATE_FAR;
+    }
+
+    if (proximity_data->ts_data->log_level >= 3) {
+        FTS_DEBUG("tp proximity status, now:%x,before:%x", proximity_data->tp_val, proximity_data->tp_val_last);
+        FTS_DEBUG("proximity state, now:%x,before:%d", proximity_state, proximity_data->host_state);
+    }
+    if (proximity_state != proximity_data->host_state) {
+        FTS_INFO("report proximity state:%s", proximity_state ? "AWAY" : "NEAR");
+        proximity_data->host_state = proximity_state;
+        /* TODO: Report proximity state to host */
+
+
+        return FTS_RETVAL_IGNORE_TOUCHES;
+    }
+
+    return 0;
+}
+
+static int sample_proximity_init(struct fts_proximity *proximity_data)
+{
+    FTS_FUNC_ENTER();
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static int sample_proximity_exit(struct fts_proximity *proximity_data)
+{
+    FTS_FUNC_ENTER();
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+static struct fts_proximity_ops sample_proximity_ops = {
+    .init = sample_proximity_init,
+    .exit = sample_proximity_exit,
+    .report = sample_proximity_report,
+};
+#endif // #if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE)
+
+
+static ssize_t fts_proximity_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    u8 val = 0;
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+
+    if (proximity_data->proximity_input_dev) {
+        mutex_lock(&proximity_data->proximity_input_dev->mutex);
+        fts_read_reg(FTS_REG_PSENSOR_ENABLE, &val);
+        count = snprintf(buf, PAGE_SIZE, "Proximity Mode:%s\n", ts_data->proximity_mode ? "On" : "Off");
+        count += snprintf(buf + count, PAGE_SIZE, "Reg(0xB0)=%d\n", val);
+        mutex_unlock(&proximity_data->proximity_input_dev->mutex);
+    }
+
+    return count;
+}
+
+static ssize_t fts_proximity_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+
+    if (FTS_SYSFS_ECHO_ON(buf)) {
+        if (ts_data->suspended) {
+            FTS_INFO("In suspend,not allowed to enable proximity mode");
+        } else {
+            FTS_DEBUG("enable proximity");
+            fts_proximity_enable(proximity_data, ENABLE);
+        }
+    } else if (FTS_SYSFS_ECHO_OFF(buf)) {
+        FTS_DEBUG("disable proximity");
+        fts_proximity_enable(proximity_data, DISABLE);
+    }
+
+    return count;
+}
+
+/* sysfs node of proximity_mode, maybe not used */
+static DEVICE_ATTR(fts_proximity_mode, S_IRUGO | S_IWUSR, fts_proximity_show, fts_proximity_store);
+static struct attribute *fts_proximity_mode_attrs[] = { &dev_attr_fts_proximity_mode.attr, NULL, };
+static struct attribute_group fts_proximity_group = {.attrs = fts_proximity_mode_attrs,};
+
+
+static fts_proximity_input_init(struct fts_proximity *proximity_data)
+{
+    int ret = 0;
+    struct input_dev *proximity_input_dev;
+
+    FTS_FUNC_ENTER();
+    if (!proximity_data || !proximity_data->ts_data || !proximity_data->ts_data->dev) {
+        FTS_ERROR("proximity_data/ts_data/device is null");
+        return -EINVAL;
+    }
+
+    proximity_input_dev = input_allocate_device();
+    if (!proximity_input_dev) {
+        FTS_ERROR("Failed to allocate memory for input_proximity device");
+        return -ENOMEM;
+    }
+
+    proximity_input_dev->dev.parent = proximity_data->ts_data->dev;
+    proximity_input_dev->name = "proximity";
+    __set_bit(EV_ABS, proximity_input_dev->evbit);
+    input_set_abs_params(proximity_input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+    ret = input_register_device(proximity_input_dev);
+    if (ret) {
+        FTS_ERROR("proximity input device registration failed");
+        input_free_device(proximity_input_dev);
+        proximity_input_dev = NULL;
+        return ret;
+    }
+
+    proximity_data->proximity_input_dev = proximity_input_dev;
+    FTS_FUNC_EXIT();
+    return 0;
+}
+
+int fts_proximity_recovery(struct fts_ts_data *ts_data)
+{
+    if (ts_data->proximity_mode) {
+        fts_proximity_set_reg(ENABLE);
+    }
+    return 0;
+}
+
+/*****************************************************************************
+* Name: fts_proximity_readdata
+* Brief: read proximity value from TP, check whether tp is near or far away,
+*        and report the state to host if need.
+*
+* Input: ts_data
+* Output:
+* Return: return negative code if error occurs,return 0 or 1 if success.
+*         return 0 if continue report finger touches.
+*         return 1(FTS_RETVAL_IGNORE_TOUCHES) if you want to ingore this
+*         finger reporting, As default, the following situation will report 1:
+*               a.proximity state changed
+*               b.System in suspend state
+*****************************************************************************/
+int fts_proximity_readdata(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+    u8 psensor_status = 0xFF;
+    u8 psensor_enable = 0xFF;
+
+    ret = fts_read_reg(FTS_REG_PSENSOR_ENABLE, &psensor_enable);
+    if (psensor_enable != ENABLE) {
+        FTS_DEBUG("proximity not enable in FW, don't process proximity");
+        return 0;
+    }
+
+    ret = fts_read_reg(FTS_REG_PSENSOR_STATUS, &psensor_status);
+    if (ret < 0) {
+        FTS_ERROR("read proximity value failed,ret=%d", ret);
+        proximity_data->tp_val = PROXIMITY_TP_VAL_ERROR;
+    } else {
+        if (ts_data->log_level >= 3)
+            FTS_INFO("read proximity status:0x%x", psensor_status);
+        else if (proximity_data->tp_val != psensor_status)
+            FTS_INFO("read proximity status:0x%x[%x]", psensor_status, proximity_data->tp_val);
+        proximity_data->tp_val = psensor_status;
+    }
+
+    if (proximity_data->ops->report) {
+        ret = proximity_data->ops->report(proximity_data);
+    }
+
+    proximity_data->tp_val_last = proximity_data->tp_val;
+    if (ts_data->suspended) ret = FTS_RETVAL_IGNORE_TOUCHES;
+    return ret;
+}
+
+int fts_proximity_suspend(struct fts_ts_data *ts_data)
+{
+    if (enable_irq_wake(ts_data->irq)) {
+        FTS_ERROR("enable_irq_wake(irq:%d) fail", ts_data->irq);
+    }
+    FTS_INFO("proximity mode in suspend.");
+    return 0;
+}
+
+int fts_proximity_resume(struct fts_ts_data *ts_data)
+{
+    if (disable_irq_wake(ts_data->irq)) {
+        FTS_ERROR("disable_irq_wake(irq:%d) fail", ts_data->irq);
+    }
+    fts_proximity_recovery(ts_data);
+    return 0;
+}
+
+int fts_proximity_init(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+
+    FTS_FUNC_ENTER();
+    memset((u8 *)proximity_data, 0, sizeof(struct fts_proximity));
+    proximity_data->ts_data = ts_data;
+    proximity_data->tp_val = PROXIMITY_TP_VAL_DEFAULT;
+    proximity_data->tp_val_last = PROXIMITY_TP_VAL_DEFAULT;
+    proximity_data->host_state = PROXIMITY_HOST_STATE_DEFAULT;
+
+    /* TODO: initialize following platform implementation  */
+#if (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE)
+    proximity_data->ops = &sample_proximity_ops;
+#elif (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_QCOM)
+    proximity_data->ops = &qcom_proximity_ops;
+#elif (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_MTK)
+    proximity_data->ops = &mtk_proximity_ops;
+#elif (PROXIMITY_SOLUTION == PROXIMITY_SOLUTION_SAMPLE_1)
+    proximity_data->ops = &sample_1_proximity_ops;
+#endif
+
+    ret = fts_proximity_input_init(proximity_data);
+    if (ret) {
+        FTS_ERROR("proximity input init failed");
+        return ret;
+    }
+
+    ret = sysfs_create_group(&ts_data->dev->kobj, &fts_proximity_group);
+    if (ret) {
+        FTS_ERROR("proximity sys node create failed");
+        sysfs_remove_group(&ts_data->dev->kobj, &fts_proximity_group);
+    }
+
+    if (proximity_data->ops && proximity_data->ops->init) {
+        ret = proximity_data->ops->init(proximity_data);
+        if (ret) FTS_ERROR("proximity init failed,ret=%d", ret);
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+int fts_proximity_exit(struct fts_ts_data *ts_data)
+{
+    int ret = 0;
+    struct fts_proximity *proximity_data = &fts_proximity_data;
+    FTS_FUNC_ENTER();
+    sysfs_remove_group(&ts_data->dev->kobj, &fts_proximity_group);
+    input_unregister_device(proximity_data->proximity_input_dev);
+    if (proximity_data->ops && proximity_data->ops->exit) {
+        ret = proximity_data->ops->exit(proximity_data);
+        if (ret) FTS_ERROR("proximity exit failed,ret=%d", ret);
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+#endif  /* FTS_PSENSOR_EN */
+
+
diff --git a/drivers/input/touchscreen/focaltech_touch/focaltech_spi_v2.c b/drivers/input/touchscreen/focaltech_touch/focaltech_spi_v2.c
new file mode 100755
index 000000000000..1aaf15d59fd9
--- /dev/null
+++ b/drivers/input/touchscreen/focaltech_touch/focaltech_spi_v2.c
@@ -0,0 +1,621 @@
+/*
+ *
+ * FocalTech TouchScreen driver.
+ *
+ * Copyright (c) 2012-2020, FocalTech Systems, Ltd., all rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/************************************************************************
+*
+* File Name: focaltech_spi.c
+*
+*    Author: FocalTech Driver Team
+*
+*   Created: 2019-03-21
+*
+*  Abstract: new spi protocol communication with TP
+*
+*   Version: v2.0
+*
+* Revision History:
+*
+************************************************************************/
+
+/*****************************************************************************
+* Included header files
+*****************************************************************************/
+#include "focaltech_core.h"
+
+/*****************************************************************************
+* Private constant and macro definitions using #define
+*****************************************************************************/
+#define SPI_RETRY_NUMBER            3
+#define CS_HIGH_DELAY               150 /* unit: us */
+
+#define DATA_CRC_EN                 0x20
+#define WRITE_CMD                   0x00
+#define READ_CMD                    (0x80 | DATA_CRC_EN)
+
+#define SPI_DUMMY_BYTE              3
+#define SPI_HEADER_LENGTH           6   /*CRC*/
+/*****************************************************************************
+* Private enumerations, structures and unions using typedef
+*****************************************************************************/
+
+/*****************************************************************************
+* Static variables
+*****************************************************************************/
+
+/*****************************************************************************
+* Global variable or extern global variabls/functions
+*****************************************************************************/
+
+/*****************************************************************************
+* Static function prototypes
+*****************************************************************************/
+
+/*****************************************************************************
+* functions body
+*****************************************************************************/
+/* spi interface */
+static int fts_spi_transfer(u8 *tx_buf, u8 *rx_buf, u32 len)
+{
+    int ret = 0;
+    struct spi_device *spi = fts_data->spi;
+    struct spi_message msg;
+    struct spi_transfer xfer = {
+        .tx_buf = tx_buf,
+        .rx_buf = rx_buf,
+        .len    = len,
+    };
+
+    spi_message_init(&msg);
+    spi_message_add_tail(&xfer, &msg);
+
+    ret = spi_sync(spi, &msg);
+    if (ret) {
+        FTS_ERROR("spi_sync fail,ret:%d", ret);
+        return ret;
+    }
+
+    return ret;
+}
+
+static void fts_spi_buf_show(u8 *data, int datalen)
+{
+    int i = 0;
+    int count = 0;
+    int size = 0;
+    char *tmpbuf = NULL;
+
+    if (!data || (datalen <= 0)) {
+        FTS_ERROR("data/datalen is invalid");
+        return;
+    }
+
+    size = (datalen > 256) ? 256 : datalen;
+    tmpbuf = kzalloc(1024, GFP_KERNEL);
+    if (!tmpbuf) {
+        FTS_ERROR("tmpbuf zalloc fail");
+        return;
+    }
+
+    for (i = 0; i < size; i++)
+        count += snprintf(tmpbuf + count, 1024 - count, "%02X ", data[i]);
+
+    FTS_DEBUG("%s", tmpbuf);
+    if (tmpbuf) {
+        kfree(tmpbuf);
+        tmpbuf = NULL;
+    }
+}
+
+static void crckermit(u8 *data, u32 len, u16 *crc_out)
+{
+    u32 i = 0;
+    u32 j = 0;
+    u16 crc = 0xFFFF;
+
+    for ( i = 0; i < len; i++) {
+        crc ^= data[i];
+        for (j = 0; j < 8; j++) {
+            if (crc & 0x01)
+                crc = (crc >> 1) ^ 0x8408;
+            else
+                crc = (crc >> 1);
+        }
+    }
+
+    *crc_out = crc;
+}
+
+static int rdata_check(u8 *rdata, u32 rlen)
+{
+    u16 crc_calc = 0;
+    u16 crc_read = 0;
+
+    crckermit(rdata, rlen - 2, &crc_calc);
+    crc_read = (u16)(rdata[rlen - 1] << 8) + rdata[rlen - 2];
+    if (crc_calc != crc_read) {
+        fts_spi_buf_show(rdata, rlen);
+        return -EIO;
+    }
+
+    return 0;
+}
+
+int fts_write(u8 *writebuf, u32 writelen)
+{
+    int ret = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = fts_data;
+    u8 *txbuf = NULL;
+    u8 *rxbuf = NULL;
+    u32 txlen = 0;
+    u32 txlen_need = writelen + SPI_HEADER_LENGTH + ts_data->dummy_byte;
+    u32 datalen = writelen - 1;
+
+    if (!writebuf || !writelen) {
+        FTS_ERROR("writebuf/len is invalid");
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+    if (txlen_need > FTS_MAX_BUS_BUF) {
+        txbuf = kzalloc(txlen_need, GFP_KERNEL);
+        if (NULL == txbuf) {
+            FTS_ERROR("txbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_write;
+        }
+
+        rxbuf = kzalloc(txlen_need, GFP_KERNEL);
+        if (NULL == rxbuf) {
+            FTS_ERROR("rxbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_write;
+        }
+    } else {
+        txbuf = ts_data->bus_tx_buf;
+        rxbuf = ts_data->bus_rx_buf;
+        memset(txbuf, 0x0, FTS_MAX_BUS_BUF);
+        memset(rxbuf, 0x0, FTS_MAX_BUS_BUF);
+    }
+
+    txbuf[txlen++] = writebuf[0];
+    txbuf[txlen++] = WRITE_CMD;
+    txbuf[txlen++] = (datalen >> 8) & 0xFF;
+    txbuf[txlen++] = datalen & 0xFF;
+    if (datalen > 0) {
+        txlen = txlen + SPI_DUMMY_BYTE;
+        memcpy(&txbuf[txlen], &writebuf[1], datalen);
+        txlen = txlen + datalen;
+    }
+
+    for (i = 0; i < SPI_RETRY_NUMBER; i++) {
+        ret = fts_spi_transfer(txbuf, rxbuf, txlen);
+        if ((0 == ret) && ((rxbuf[3] & 0xA0) == 0)) {
+            break;
+        } else {
+            FTS_DEBUG("data write(addr:%x),status:%x,retry:%d,ret:%d",
+                      writebuf[0], rxbuf[3], i, ret);
+            ret = -EIO;
+            udelay(CS_HIGH_DELAY);
+        }
+    }
+    if (ret < 0) {
+        FTS_ERROR("data write(addr:%x) fail,status:%x,ret:%d",
+                  writebuf[0], rxbuf[3], ret);
+    }
+
+err_write:
+    if (txlen_need > FTS_MAX_BUS_BUF) {
+        if (txbuf) {
+            kfree(txbuf);
+            txbuf = NULL;
+        }
+
+        if (rxbuf) {
+            kfree(rxbuf);
+            rxbuf = NULL;
+        }
+    }
+
+    udelay(CS_HIGH_DELAY);
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+int fts_write_reg(u8 addr, u8 value)
+{
+    u8 writebuf[2] = { 0 };
+
+    writebuf[0] = addr;
+    writebuf[1] = value;
+    return fts_write(writebuf, 2);
+}
+
+int fts_read(u8 *cmd, u32 cmdlen, u8 *data, u32 datalen)
+{
+    int ret = 0;
+    int i = 0;
+    struct fts_ts_data *ts_data = fts_data;
+    u8 *txbuf = NULL;
+    u8 *rxbuf = NULL;
+    u32 txlen = 0;
+    u32 txlen_need = datalen + SPI_HEADER_LENGTH + ts_data->dummy_byte;
+    u8 ctrl = READ_CMD;
+    u32 dp = 0;
+
+    if (!cmd || !cmdlen || !data || !datalen) {
+        FTS_ERROR("cmd/cmdlen/data/datalen is invalid");
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+    if (txlen_need > FTS_MAX_BUS_BUF) {
+        txbuf = kzalloc(txlen_need, GFP_KERNEL);
+        if (NULL == txbuf) {
+            FTS_ERROR("txbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_read;
+        }
+
+        rxbuf = kzalloc(txlen_need, GFP_KERNEL);
+        if (NULL == rxbuf) {
+            FTS_ERROR("rxbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_read;
+        }
+    } else {
+        txbuf = ts_data->bus_tx_buf;
+        rxbuf = ts_data->bus_rx_buf;
+        memset(txbuf, 0x0, FTS_MAX_BUS_BUF);
+        memset(rxbuf, 0x0, FTS_MAX_BUS_BUF);
+    }
+
+    txbuf[txlen++] = cmd[0];
+    txbuf[txlen++] = ctrl;
+    txbuf[txlen++] = (datalen >> 8) & 0xFF;
+    txbuf[txlen++] = datalen & 0xFF;
+    dp = txlen + SPI_DUMMY_BYTE;
+    txlen = dp + datalen;
+    if (ctrl & DATA_CRC_EN) {
+        txlen = txlen + 2;
+    }
+
+    for (i = 0; i < SPI_RETRY_NUMBER; i++) {
+        ret = fts_spi_transfer(txbuf, rxbuf, txlen);
+        if ((0 == ret) && ((rxbuf[3] & 0xA0) == 0)) {
+            memcpy(data, &rxbuf[dp], datalen);
+            /* crc check */
+            if (ctrl & DATA_CRC_EN) {
+                ret = rdata_check(&rxbuf[dp], txlen - dp);
+                if (ret < 0) {
+                    FTS_DEBUG("data read(addr:%x) crc abnormal,retry:%d",
+                              cmd[0], i);
+                    udelay(CS_HIGH_DELAY);
+                    continue;
+                }
+            }
+            break;
+        } else {
+            FTS_DEBUG("data read(addr:%x) status:%x,retry:%d,ret:%d",
+                      cmd[0], rxbuf[3], i, ret);
+            ret = -EIO;
+            udelay(CS_HIGH_DELAY);
+        }
+    }
+
+    if (ret < 0) {
+        FTS_ERROR("data read(addr:%x) %s,status:%x,ret:%d", cmd[0],
+                  (i >= SPI_RETRY_NUMBER) ? "crc abnormal" : "fail",
+                  rxbuf[3], ret);
+    }
+
+err_read:
+    if (txlen_need > FTS_MAX_BUS_BUF) {
+        if (txbuf) {
+            kfree(txbuf);
+            txbuf = NULL;
+        }
+
+        if (rxbuf) {
+            kfree(rxbuf);
+            rxbuf = NULL;
+        }
+    }
+
+    udelay(CS_HIGH_DELAY);
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+int fts_read_reg(u8 addr, u8 *value)
+{
+    return fts_read(&addr, 1, value, 1);
+}
+
+
+int fts_bus_transfer_direct(u8 *writebuf, u32 writelen, u8 *readbuf, u32 readlen)
+{
+    int ret = 0;
+    struct fts_ts_data *ts_data = fts_data;
+    u8 *txbuf = NULL;
+    u8 *rxbuf = NULL;
+    bool read_cmd = (readbuf && readlen) ? 1 : 0;
+    u32 txlen = (read_cmd) ? readlen : writelen;
+
+    if (!writebuf || !writelen) {
+        FTS_ERROR("writebuf/len is invalid");
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+    if (txlen > FTS_MAX_BUS_BUF) {
+        txbuf = kzalloc(txlen, GFP_KERNEL);
+        if (NULL == txbuf) {
+            FTS_ERROR("txbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_spi_dir;
+        }
+
+        rxbuf = kzalloc(txlen, GFP_KERNEL);
+        if (NULL == rxbuf) {
+            FTS_ERROR("rxbuf malloc fail");
+            ret = -ENOMEM;
+            goto err_spi_dir;
+        }
+    } else {
+        txbuf = ts_data->bus_tx_buf;
+        rxbuf = ts_data->bus_rx_buf;
+        memset(txbuf, 0x0, FTS_MAX_BUS_BUF);
+        memset(rxbuf, 0x0, FTS_MAX_BUS_BUF);
+    }
+
+    memcpy(txbuf, writebuf, writelen);
+    ret = fts_spi_transfer(txbuf, rxbuf, txlen);
+    if (ret < 0) {
+        FTS_ERROR("data read(addr:%x) fail,status:%x,ret:%d", txbuf[0], rxbuf[3], ret);
+        goto err_spi_dir;
+    }
+
+    if (read_cmd) {
+        memcpy(readbuf, rxbuf, txlen);
+    }
+
+    ret = 0;
+err_spi_dir:
+    if (txlen > FTS_MAX_BUS_BUF) {
+        if (txbuf) {
+            kfree(txbuf);
+            txbuf = NULL;
+        }
+
+        if (rxbuf) {
+            kfree(rxbuf);
+            rxbuf = NULL;
+        }
+    }
+
+    udelay(CS_HIGH_DELAY);
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+int fts_bus_configure(struct fts_ts_data *ts_data, u8 *buf, u32 size)
+{
+    int ret = 0;
+    FTS_FUNC_ENTER();
+    if (ts_data->spi && buf && size) {
+        ts_data->spi->mode = buf[0];
+        ts_data->spi->bits_per_word = buf[1];
+        ts_data->spi->max_speed_hz = *(u32 *)(buf + 3);
+        FTS_INFO("spi,mode=%d,bits=%d,speed=%d", ts_data->spi->mode,
+                 ts_data->spi->bits_per_word, ts_data->spi->max_speed_hz);
+        ret = spi_setup(ts_data->spi);
+        if (ret < 0) {
+            FTS_ERROR("spi setup fail,ret:%d", ret);
+        }
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+int fts_bus_set_speed(struct fts_ts_data *ts_data, u32 speed)
+{
+    int ret = 0;
+
+    if (!ts_data) {
+        FTS_ERROR("ts_data is null");
+        return -EINVAL;
+    }
+
+    mutex_lock(&ts_data->bus_lock);
+
+    if (speed > 0) {
+        ts_data->spi->max_speed_hz = speed;
+    } else {
+        ts_data->spi->max_speed_hz = ts_data->spi_speed;
+    }
+
+    ret = spi_setup(ts_data->spi);
+    if (ret < 0) {
+        FTS_ERROR("spi speed set fail,ret:%d", ret);
+    }
+
+    mutex_unlock(&ts_data->bus_lock);
+    return ret;
+}
+
+
+/*****************************************************************************
+* TP Driver
+*****************************************************************************/
+static int fts_ts_probe(struct spi_device *spi)
+{
+    int ret = 0;
+    struct fts_ts_data *ts_data = NULL;
+
+    FTS_INFO("Touch Screen(SPI-2 BUS) driver prboe...");
+    spi->mode = SPI_MODE_0;
+    spi->bits_per_word = 8;
+    ret = spi_setup(spi);
+    if (ret < 0) {
+        FTS_ERROR("spi setup fail");
+        return ret;
+    }
+
+    /* malloc memory for global struct variable */
+    ts_data = (struct fts_ts_data *)kzalloc(sizeof(*ts_data), GFP_KERNEL);
+    if (!ts_data) {
+        FTS_ERROR("allocate memory for fts_data fail");
+        return -ENOMEM;
+    }
+
+    ts_data->spi = spi;
+    ts_data->dev = &spi->dev;
+    ts_data->log_level = 1;
+    ts_data->bus_type = BUS_TYPE_SPI;
+    ts_data->bus_ver = BUS_VER_V2;
+    ts_data->dummy_byte = SPI_DUMMY_BYTE;
+    spi_set_drvdata(spi, ts_data);
+    ts_data->spi_speed = spi->max_speed_hz;
+
+    ret = fts_ts_probe_entry(ts_data);
+    if (ret) {
+        FTS_ERROR("Touch Screen(SPI BUS) driver probe fail");
+        spi_set_drvdata(spi, NULL);
+        kfree_safe(ts_data);
+        return ret;
+    }
+
+    FTS_INFO("Touch Screen(SPI BUS) driver prboe successfully");
+    return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0))
+static void fts_ts_remove(struct spi_device *spi)
+{
+    struct fts_ts_data *ts_data = spi_get_drvdata(spi);
+    FTS_FUNC_ENTER();
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        spi_set_drvdata(spi, NULL);
+        kfree_safe(ts_data);
+    }
+    FTS_FUNC_EXIT();
+}
+#else
+static int fts_ts_remove(struct spi_device *spi)
+{
+    struct fts_ts_data *ts_data = spi_get_drvdata(spi);
+    FTS_FUNC_ENTER();
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        spi_set_drvdata(spi, NULL);
+        kfree_safe(ts_data);
+    }
+    FTS_FUNC_EXIT();
+    return 0;
+}
+#endif
+
+static void fts_ts_shutdown(struct spi_device *spi)
+{
+    struct fts_ts_data *ts_data = spi_get_drvdata(spi);
+    FTS_FUNC_ENTER();
+    if (ts_data) {
+        fts_ts_remove_entry(ts_data);
+        spi_set_drvdata(spi, NULL);
+        kfree_safe(ts_data);
+    }
+    FTS_FUNC_EXIT();
+}
+
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+static int fts_pm_suspend(struct device *dev)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    FTS_INFO("system enters into pm_suspend");
+    ts_data->pm_suspend = true;
+    reinit_completion(&ts_data->pm_completion);
+    return 0;
+}
+
+static int fts_pm_resume(struct device *dev)
+{
+    struct fts_ts_data *ts_data = dev_get_drvdata(dev);
+
+    FTS_INFO("system resumes from pm_suspend");
+    ts_data->pm_suspend = false;
+    complete(&ts_data->pm_completion);
+    return 0;
+}
+
+static const struct dev_pm_ops fts_dev_pm_ops = {
+    .suspend = fts_pm_suspend,
+    .resume = fts_pm_resume,
+};
+#endif
+
+static const struct spi_device_id fts_ts_id[] = {
+    {FTS_DRIVER_NAME, 0},
+    {},
+};
+static const struct of_device_id fts_dt_match[] = {
+    {.compatible = "focaltech,fts", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, fts_dt_match);
+
+static struct spi_driver fts_ts_spi_driver = {
+    .probe = fts_ts_probe,
+    .remove = fts_ts_remove,
+    .shutdown = fts_ts_shutdown,
+    .driver = {
+        .name = FTS_DRIVER_NAME,
+        .owner = THIS_MODULE,
+#if IS_ENABLED(CONFIG_PM) && FTS_PATCH_COMERR_PM
+        .pm = &fts_dev_pm_ops,
+#endif
+        .of_match_table = of_match_ptr(fts_dt_match),
+    },
+    .id_table = fts_ts_id,
+};
+
+static int __init fts_ts_spi_init(void)
+{
+    int ret = 0;
+
+    FTS_FUNC_ENTER();
+    ret = spi_register_driver(&fts_ts_spi_driver);
+    if ( ret < 0 ) {
+        FTS_ERROR("Focaltech touch screen driver init failed!");
+    }
+    FTS_FUNC_EXIT();
+    return ret;
+}
+
+static void __exit fts_ts_spi_exit(void)
+{
+    spi_unregister_driver(&fts_ts_spi_driver);
+}
+
+module_init(fts_ts_spi_init);
+module_exit(fts_ts_spi_exit);
+
+MODULE_AUTHOR("FocalTech Driver Team");
+MODULE_DESCRIPTION("FocalTech Touchscreen Driver(SPI)");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/spacemit/Kconfig b/drivers/media/platform/spacemit/Kconfig
index 21b4f5f6d388..7e0a4f8cfe4b 100644
--- a/drivers/media/platform/spacemit/Kconfig
+++ b/drivers/media/platform/spacemit/Kconfig
@@ -4,4 +4,5 @@ comment "Spacemit media platform drivers"
 
 source "drivers/media/platform/spacemit/vpu_k1x/Kconfig"
 source "drivers/media/platform/spacemit/camera/Kconfig"
+source "drivers/media/platform/spacemit/virtual_camera/Kconfig"
 
diff --git a/drivers/media/platform/spacemit/Makefile b/drivers/media/platform/spacemit/Makefile
index 16c63023baba..3d0b00b85f6a 100644
--- a/drivers/media/platform/spacemit/Makefile
+++ b/drivers/media/platform/spacemit/Makefile
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-y += vpu_k1x/
 obj-y += camera/
+obj-y += virtual_camera/
diff --git a/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c b/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
index a1bd81c30ee5..c34f8b624278 100644
--- a/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
+++ b/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
@@ -5035,13 +5035,20 @@ static void fe_isp_dma_bh_handler(struct isp_dma_work_struct *isp_dma_work)
 	struct spm_camera_vnode *sc_vnode = dma_ctx->vnode;
 	//struct isp_context *isp_ctx = dma_ctx->isp_ctx;
 	struct spm_camera_pipeline *sc_pipeline = NULL;
-	struct media_pipeline *pipe = media_entity_pipeline(&sc_vnode->vnode.entity);
+	struct media_pipeline *pipe = NULL;
 	struct spm_camera_vbuffer *n = NULL, *pos = NULL;
 	unsigned int *hw_err_code = NULL;
 	unsigned int irq_status = isp_dma_work->irq_status;
 	LIST_HEAD(export_list);
 	unsigned long flags = 0;
 
+	if (!sc_vnode) {
+		cam_dbg("a[%d] debug 0", dma_ctx->id);
+		goto dma_tasklet_finish;
+	}
+
+	pipe = media_entity_pipeline(&sc_vnode->vnode.entity);
+
 	if (!sc_vnode || !pipe) {
 		cam_dbg("a[%d] debug 1", dma_ctx->id);
 		goto dma_tasklet_finish;
diff --git a/drivers/media/platform/spacemit/virtual_camera/Kconfig b/drivers/media/platform/spacemit/virtual_camera/Kconfig
new file mode 100644
index 000000000000..b92eb07e70ea
--- /dev/null
+++ b/drivers/media/platform/spacemit/virtual_camera/Kconfig
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# SPACEMIT K1X camera configuration
+#
+
+comment "SPACEMIT K1X Virtual Camera Driver"
+
+menuconfig SPACEMIT_K1X_VIR_CAMERA
+    tristate "SPACEMIT K1X virtual camera support"
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+    help
+	  Say Y here to enable selecting the video adapters for
+	  SPACEMIT K1X virtual camera and video v2
+
+config SPACEMIT_K1X_VIR_CAMERA
+    tristate "SPACEMIT K1X VIRTUAL CAMERA support"
+    select VIDEOBUF2_CORE
+    select VIDEOBUF2_V4L2
+    select VIDEOBUF2_DMA_CONTIG
+    select VIDEOBUF2_DMA_SG
+    select SPACEMIT_K1X_CCIC_V2
+    depends on SPACEMIT_K1X_CAMERA_V2
+    help
+      Enable support for spacemit virtual camera
diff --git a/drivers/media/platform/spacemit/virtual_camera/Makefile b/drivers/media/platform/spacemit/virtual_camera/Makefile
new file mode 100644
index 000000000000..3c05a76ac821
--- /dev/null
+++ b/drivers/media/platform/spacemit/virtual_camera/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_SPACEMIT_K1X_VIR_CAMERA) += svivi.o
+obj-$(CONFIG_SPACEMIT_K1X_VIR_CAMERA) += vcam_dbg.o
+
+
+
diff --git a/drivers/media/platform/spacemit/virtual_camera/svivi.c b/drivers/media/platform/spacemit/virtual_camera/svivi.c
new file mode 100644
index 000000000000..c3bf21e017fe
--- /dev/null
+++ b/drivers/media/platform/spacemit/virtual_camera/svivi.c
@@ -0,0 +1,1056 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-v4l2.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/kmod.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+
+#include "vcam_dbg.h"
+
+/* The minimum image width/height */
+#define MIN_WIDTH  48
+#define MIN_HEIGHT 32
+
+#define MAX_WIDTH 1920
+#define MAX_HEIGHT 1200
+#define SVIVI_MAX_PLANES			3
+#define SVIVI_MIN_WIDTH				480U
+#define SVIVI_MIN_HEIGHT			288U
+#define SVIVI_DEF_COLOR_SPACE		V4L2_COLORSPACE_SRGB
+#define SVIVI_DEF_YCBCR_ENC		V4L2_YCBCR_ENC_601
+#define SVIVI_DEF_QUANTIZATION	V4L2_QUANTIZATION_LIM_RANGE
+#define SVIVI_DEF_XFER_FUNC		V4L2_XFER_FUNC_SRGB
+
+#define SVIVI_NETLINK    17
+enum V4L2_PIPE_SEQ_ID {
+    START_INIT = 0,
+    FINISH_INIT,
+    START_OPEN,
+    FINISH_OPEN,
+    START_QUERYCAP,
+    FINISH_QUERYCAP,
+    START_S_FMT,
+    FINISH_S_FMT,
+    START_S_PARM,
+    FINISH_S_PARM,
+    START_REQBUFS,
+    FINISH_REQBUFS,
+    START_QUERYBUF,
+    FINISH_QUERYBUF,
+    START_MMAP,
+    FINISH_MMAP,
+    START_QBUF,
+    FINISH_QBUF,
+    START_STREAMON,
+    FINISH_STREAMON,
+    START_POLL,
+    FINISH_POLL,
+    START_DQBUF,
+    FINISH_DQBUF,
+    START_STREAMOFF,
+    FINISH_STREAMOFF,
+    START_CLOSE,
+    FINISH_CLOSE,
+    MAX_SEQ_SIZE,
+};
+struct v4l2_vinit {
+	int 			ret;
+};
+struct v4l2_vformat {
+	int 			ret;
+	int 			v4l2_buf_type;
+	unsigned int	width;
+	unsigned int	height;
+	unsigned int	pixelformat;
+};
+struct v4l2_vrequestbuffers {
+	int 			ret;
+	unsigned int	count;
+};
+struct v4l2_vbuffer {
+	int 			ret;
+	int             index;
+	unsigned int	length;
+	unsigned int	m_offset;
+	int 			m_fd;
+};
+struct v4l2_vstream {
+	int 			ret;
+};
+struct v4l2_vpoll {
+	int 			ret;
+};
+struct vcam_header {
+	unsigned int	kpos;
+	unsigned int	upos;
+	unsigned int	user_pid;
+
+	struct v4l2_vinit vinit;
+	struct v4l2_vformat vfmt;
+	struct v4l2_vrequestbuffers vreq_buf;
+	struct v4l2_vbuffer vbuf;
+	struct v4l2_vstream vstream;
+	struct v4l2_vpoll vpoll;
+
+	char pbuf[64];
+};
+
+struct recevice_message {
+	struct completion 		complete;
+	struct vcam_header 		rcv_vheader;
+};
+static struct recevice_message recv_msg;
+static int in_use = false;
+
+struct send_message {
+	struct vcam_header  	snd_vheader;
+};
+static struct send_message   snd_msg;
+
+struct svivi_fmt_info {
+	u32	mbus_code;
+	u32	fourcc;
+	// enum mxc_isi_video_type type;
+	// u32	isi_in_format;
+	// u32	isi_out_format;
+	u8	mem_planes;
+	u8	color_planes;
+	u8	depth[SVIVI_MAX_PLANES];
+	u8	hsub;
+	u8	vsub;
+};
+
+struct svivi_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct list_head	list;
+};
+
+struct vivi {
+	struct v4l2_device 		v4l2_dev;
+	struct video_device 	vid_cap_dev;
+	struct vb2_queue 		vb_vid_cap_q;
+
+	struct v4l2_pix_format_mplane	pix;
+	u32 					vid_cap_caps;
+	struct mutex 			mutex;
+
+	struct v4l2_rect		fmt_cap_rect;
+
+	int 					streaming;
+	struct sock 			*netlinkfd;
+	u32 					memory;
+};
+
+static const struct svivi_fmt_info svivi_formats[] = {
+	/* YUV formats */
+	{
+		.mbus_code	= MEDIA_BUS_FMT_YUV8_1X24,
+		.fourcc		= V4L2_PIX_FMT_NV12,
+		.color_planes	= 2,
+		.mem_planes	= 1,
+		.depth		= { 8, 16 },
+		.hsub		= 2,
+		.vsub		= 2,
+	},
+	/* RGB formats */
+	{
+		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
+		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.mem_planes	= 1,
+		.color_planes	= 1,
+		.depth		= { 16 },
+	}, {
+		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
+		.fourcc		= V4L2_PIX_FMT_BGR24,
+		.mem_planes	= 1,
+		.color_planes	= 1,
+		.depth		= { 24 },
+	},
+
+};
+
+int send_to_user(struct sock *netlinkfd, void *data, unsigned int len, unsigned int pid, unsigned int seq)
+{
+    struct sk_buff *nl_skb;
+    struct nlmsghdr *nlh;
+    int ret;
+
+    nl_skb = nlmsg_new(len, GFP_ATOMIC);
+    if (!nl_skb) {
+        vcam_err("netlink alloc failure\n");
+        return -1;
+    }
+
+    nlh = nlmsg_put(nl_skb, 0, seq, SVIVI_NETLINK, len, 0);
+    if (nlh == NULL) {
+        vcam_err("nlmsg_put failaure \n");
+        nlmsg_free(nl_skb);
+        return -1;
+    }
+
+    memcpy(nlmsg_data(nlh), data, len);
+	vcam_info("send to user len:%d, seq:%d\n", nlh->nlmsg_len, nlh->nlmsg_seq);
+	ret = netlink_unicast(netlinkfd, nl_skb, pid, MSG_DONTWAIT);
+	if (ret < 0) {
+		vcam_err("send to user error:%d, len:%d, seq:%d\n", ret, nlh->nlmsg_len, nlh->nlmsg_seq);
+	} else {
+		// vcam_info("send to user ret:%d, len:%d, seq:%d\n", ret, nlh->nlmsg_len, nlh->nlmsg_seq);
+	}
+
+    return ret;
+}
+int fill_recv_msg_by_nlmsg_data (struct nlmsghdr *nlh)
+{
+    char *data = NULL;
+
+	if (in_use == false) {
+		vcam_warn("other pid:%d != %d, don't respond netlink:%d\n",
+			 recv_msg.rcv_vheader.user_pid, nlh->nlmsg_pid, SVIVI_NETLINK);
+		return -1;
+	}
+
+	if (recv_msg.rcv_vheader.user_pid != 0) {
+		if (recv_msg.rcv_vheader.user_pid != nlh->nlmsg_pid) {
+			vcam_warn("recv other pid:%d != %d!!\n", recv_msg.rcv_vheader.user_pid, nlh->nlmsg_pid);
+			return -1;
+		}
+	}
+
+	data = NLMSG_DATA(nlh);
+	if (data) {
+		if (nlh->nlmsg_seq - 1 != snd_msg.snd_vheader.kpos) {
+			vcam_warn("user seq %d - 1 != kernel seq %d\n", nlh->nlmsg_seq, snd_msg.snd_vheader.kpos);
+			return -1;
+		}
+
+		recv_msg.rcv_vheader.user_pid = nlh->nlmsg_pid;
+		recv_msg.rcv_vheader.upos = nlh->nlmsg_seq;
+		switch (recv_msg.rcv_vheader.upos) {
+			case FINISH_INIT:
+				memcpy(&recv_msg.rcv_vheader.vinit, data, sizeof(struct v4l2_vinit));
+			break;
+			case FINISH_S_FMT:
+				memcpy(&recv_msg.rcv_vheader.vfmt, data, sizeof(struct v4l2_vformat));
+			break;
+			case FINISH_REQBUFS:
+				memcpy(&recv_msg.rcv_vheader.vreq_buf, data, sizeof(struct v4l2_vrequestbuffers));
+			break;
+			case FINISH_QUERYBUF:
+				memcpy(&recv_msg.rcv_vheader.vbuf, data, sizeof(struct v4l2_vbuffer));
+			break;
+			case FINISH_QBUF:
+				memcpy(&recv_msg.rcv_vheader.vbuf, data, sizeof(struct v4l2_vbuffer));
+			break;
+			case FINISH_DQBUF:
+				memcpy(&recv_msg.rcv_vheader.vbuf, data, sizeof(struct v4l2_vbuffer));
+			break;
+			case FINISH_STREAMON:
+				memcpy(&recv_msg.rcv_vheader.vstream, data, sizeof(struct v4l2_vstream));
+			break;
+			case FINISH_POLL:
+				memcpy(&recv_msg.rcv_vheader.vpoll, data, sizeof(struct v4l2_vpoll));
+			break;
+			case FINISH_STREAMOFF:
+				memcpy(&recv_msg.rcv_vheader.vstream, data, sizeof(struct v4l2_vstream));
+			break;
+			default:
+				vcam_warn("user seq %d - 1 != kernel seq %d\n", nlh->nlmsg_seq, snd_msg.snd_vheader.kpos);
+				return -1;
+		}
+		vcam_info("recv from user pid %d, upos %d\n", recv_msg.rcv_vheader.user_pid, recv_msg.rcv_vheader.upos);
+		return 0;
+	}
+
+	return -1;
+}
+static void netlink_rcv_msg(struct sk_buff *skb)
+{
+    struct nlmsghdr *nlh = NULL;
+    char *data = NULL;
+	int ret;
+
+    nlh = nlmsg_hdr(skb);
+
+    if(skb->len >= NLMSG_SPACE(0)) {
+        data = NLMSG_DATA(nlh);
+        if (data) {
+			ret = fill_recv_msg_by_nlmsg_data (nlh);
+			if (ret < 0) {
+				vcam_warn("unexpected resv happen!\n");
+				return;
+			}
+			complete(&recv_msg.complete);
+        }
+    } else {
+        vcam_err("error skb, length:%d\n", skb->len);
+    }
+}
+
+static int wait_for_recv_complete(int seq, int timeout) {
+	int ret = 0;
+
+	if (!wait_for_completion_timeout(&recv_msg.complete, msecs_to_jiffies(timeout))) {
+		vcam_err("timeout!! recv user ack failed, seq:%d", seq);
+		return -EAGAIN;
+	}
+	if (recv_msg.rcv_vheader.upos != seq) {
+		vcam_err("recv user ack state error, seq %d != %d", recv_msg.rcv_vheader.upos, seq);
+		return -EINVAL;
+	}
+
+	switch (recv_msg.rcv_vheader.upos) {
+		case FINISH_INIT:
+			ret = recv_msg.rcv_vheader.vinit.ret;
+		break;
+		case FINISH_S_FMT:
+			ret = recv_msg.rcv_vheader.vfmt.ret;
+		break;
+		case FINISH_REQBUFS:
+			ret = recv_msg.rcv_vheader.vreq_buf.ret;
+		break;
+		case FINISH_QUERYBUF:
+			ret = recv_msg.rcv_vheader.vbuf.ret;
+		break;
+		case FINISH_QBUF:
+			ret = recv_msg.rcv_vheader.vbuf.ret;
+		break;
+		case FINISH_DQBUF:
+			ret = recv_msg.rcv_vheader.vbuf.ret;
+		break;
+		case FINISH_STREAMON:
+			ret = recv_msg.rcv_vheader.vstream.ret;
+		break;
+		case FINISH_POLL:
+			ret = recv_msg.rcv_vheader.vpoll.ret;
+		break;
+		case FINISH_STREAMOFF:
+			ret = recv_msg.rcv_vheader.vstream.ret;
+		break;
+		default:
+			vcam_warn("unexpected resv happen!\n");
+			return -1;
+	}
+
+	if (ret)
+		vcam_err("user ack but run failed, ret:%d, seq:%d\n", ret, recv_msg.rcv_vheader.upos);
+	reinit_completion(&recv_msg.complete);
+
+	return ret;
+}
+
+static struct netlink_kernel_cfg cfg = {
+    .input  = netlink_rcv_msg,
+    .groups = 0,
+    .flags = 0,
+    .cb_mutex = NULL,
+    .bind = NULL,
+};
+
+static int call_cam_script(void)
+{
+	int ret = 0;
+	static char cmd_path[] = "/bin/bash";
+	static char *cmd_argv[] = {
+		cmd_path,
+		"-c",
+		"/usr/bin/cam-test /root/svivi_cam.json > /tmp/svivi_cam.log 2>&1",
+		NULL,
+	};
+	static char *cmd_envp[] = {
+		"HOME=/root",
+		"PATH=/sbin:/bin:/usr/sbin:/usr/bin",
+		NULL,
+	};
+
+	ret = call_usermodehelper(cmd_path, cmd_argv, cmd_envp, UMH_NO_WAIT);
+
+	vcam_info("call cam-test! call_usermodehelper ret: %d\n", ret);
+
+	return ret;
+}
+
+static int svivi_querycap(struct file *file,void *priv,
+					struct v4l2_capability *cap) {
+	struct vivi *vind = video_drvdata(file);
+
+	strcpy(cap->driver, "spacemit vivi");
+	strcpy(cap->card, "spacemit vivi");
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+			"platform:%s", vind->v4l2_dev.name);
+
+	cap->capabilities = vind->vid_cap_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int svivi_enum_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_fmtdesc *f){
+	const struct svivi_fmt_info *fmt;
+
+	vcam_info("f->index=%d, pid:%d", f->index, recv_msg.rcv_vheader.user_pid);
+
+	if (f->index >= ARRAY_SIZE(svivi_formats))
+		return -EINVAL;
+
+	fmt = &svivi_formats[f->index];
+
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int svivi_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct vivi *vind = video_drvdata(file);
+
+	vcam_info("----------- in");
+
+	f->fmt.pix_mp = vind->pix;
+
+	// vcam_info("width=%d,height=%d,pixelformat=%c%c%c%c,field=%d,colorspace=%d,bytesperline=%d,sizeimage=%d\n",
+	// 		pix->width,pix->height,pix->pixelformat&0xff,(pix->pixelformat>>8)&0xff,
+	// 		(pix->pixelformat>>16)&0xff,(pix->pixelformat>>24)&0xff, pix->field, pix->colorspace, pix->bytesperline, pix->sizeimage
+	// );
+
+	return 0;
+}
+
+static const struct svivi_fmt_info *svivi_format_by_fourcc(u32 fourcc)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(svivi_formats); i++) {
+		const struct svivi_fmt_info *fmt = &svivi_formats[i];
+
+		if (fmt->fourcc == fourcc)
+			return fmt;
+	}
+
+	return NULL;
+}
+
+const struct svivi_fmt_info *svivi_format_try(struct v4l2_pix_format_mplane *pix)
+{
+	const struct svivi_fmt_info *fmt;
+	unsigned int i;
+
+	fmt = svivi_format_by_fourcc(pix->pixelformat);
+	if (!fmt)
+		fmt = &svivi_formats[0];
+
+	pix->width = clamp(pix->width, SVIVI_MIN_WIDTH, 1920);
+	pix->height = clamp(pix->height, SVIVI_MIN_HEIGHT, 1080);
+	pix->pixelformat = fmt->fourcc;
+	pix->field = V4L2_FIELD_NONE;
+
+	if (pix->colorspace == V4L2_COLORSPACE_DEFAULT) {
+		pix->colorspace = SVIVI_DEF_COLOR_SPACE;
+		pix->ycbcr_enc = SVIVI_DEF_YCBCR_ENC;
+		pix->quantization = SVIVI_DEF_QUANTIZATION;
+		pix->xfer_func = SVIVI_DEF_XFER_FUNC;
+	}
+	if (pix->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)
+		pix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
+	if (pix->quantization == V4L2_QUANTIZATION_DEFAULT) {
+		bool is_rgb = 0;
+
+		pix->quantization =
+			V4L2_MAP_QUANTIZATION_DEFAULT(is_rgb, pix->colorspace,
+						      pix->ycbcr_enc);
+	}
+	if (pix->xfer_func == V4L2_XFER_FUNC_DEFAULT)
+		pix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);
+	if (pix->quantization == V4L2_QUANTIZATION_DEFAULT) {
+		bool is_rgb = 0;
+
+		pix->quantization =
+			V4L2_MAP_QUANTIZATION_DEFAULT(is_rgb, pix->colorspace,
+						      pix->ycbcr_enc);
+	}
+	if (pix->xfer_func == V4L2_XFER_FUNC_DEFAULT)
+		pix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);
+
+	pix->num_planes = fmt->color_planes;
+	for (i = 0; i < fmt->color_planes; ++i) {
+		struct v4l2_plane_pix_format *plane = &pix->plane_fmt[i];
+		unsigned int bpl;
+
+		/* The pitch must be identical for all planes. */
+		if (i == 0)
+			bpl = clamp(plane->bytesperline,
+				    pix->width * fmt->depth[0] / 8,
+				    65535U);
+		else
+			bpl = pix->plane_fmt[0].bytesperline;
+
+		plane->bytesperline = bpl;
+
+		plane->sizeimage = plane->bytesperline * pix->height;
+		if (i >= 1)
+			plane->sizeimage /= fmt->vsub;
+	}
+
+	return fmt;
+}
+
+static int svivi_try_fmt_vid_cap(struct file *file,void *priv,
+			struct v4l2_format *f) {
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+
+	vcam_info("----- in");
+
+	svivi_format_try(pix);
+
+	return 0;
+}
+
+//refer to mxc_isi_video_s_fmt
+static int svivi_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f) {
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret = 0;
+
+	vcam_info("-------------- in\n");
+
+	//todo: check streaming capture is active?
+
+	call_cam_script();
+
+	ret = wait_for_recv_complete(FINISH_INIT, 1000);
+	if (ret)
+		return ret;
+
+	svivi_format_try(pix);
+
+	// char *kmsg = "start to set fmt !!!";
+
+	// memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_S_FMT;
+	snd_vheader->vfmt.width = pix->width;
+	snd_vheader->vfmt.height = pix->height;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+
+	send_to_user(vind->netlinkfd, &snd_vheader->vfmt, sizeof(struct v4l2_vformat), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_S_FMT, 1000);
+	if (ret)
+		return ret;
+
+	vind->pix = *pix;
+
+
+	vind->fmt_cap_rect.width = pix->width;
+	vind->fmt_cap_rect.height = pix->height;
+
+	return 0;
+}
+
+static int svivi_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *a)
+{
+	return 0;
+}
+
+static int svivi_s_fbuf(struct file *file, void *fh, const struct v4l2_framebuffer *a)
+{
+	return 0;
+}
+static int svivi_reqbufs(struct file *file, void *priv,
+                          struct v4l2_requestbuffers *p){
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret;
+
+	vcam_info("------------ in");
+
+	if (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		return -EINVAL;
+	}
+
+	if (p->memory == V4L2_MEMORY_MMAP || p->memory == V4L2_MEMORY_DMABUF)
+		vind->memory = p->memory;
+	else
+		return -EINVAL;
+
+	if (p->count != 0) {
+		vcam_info("reqbufs buf type: %d, memory: %d", p->type, p->memory);
+
+		// char *kmsg = "start to reqbufs !!!";
+
+		// //need to get user ready msg and send kernel msg
+		// memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+		snd_vheader->kpos = START_REQBUFS;
+		snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+		snd_vheader->vreq_buf.count = 4;
+		send_to_user(vind->netlinkfd, &snd_vheader->vreq_buf, sizeof(struct v4l2_vrequestbuffers), snd_vheader->user_pid, snd_vheader->kpos);
+
+		ret = wait_for_recv_complete(FINISH_REQBUFS, 1000);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+	// return vb2_ioctl_reqbufs(file, priv, p);
+}
+static int svivi_expbuf(struct file *file, void *fh, struct v4l2_exportbuffer *e)
+{
+	int ret = 0;
+	vcam_info(" ------------ in");
+
+	return ret;
+}
+//refer to __fill_v4l2_buffer
+static int svivi_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret, plane = 0;
+
+	vcam_info("dequeue buf type: %d, memory: %d, %d", p->type, p->memory, vind->pix.plane_fmt[plane].sizeimage);
+
+	// char *kmsg = "start to dequeue !!!";
+
+	// memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_DQBUF;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+	send_to_user(vind->netlinkfd, &snd_vheader->vbuf, sizeof(struct v4l2_vbuffer), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_DQBUF, 2000);
+	if (ret)
+		return ret;
+
+	//fill v4l2 buffer
+	p->index = recv_msg.rcv_vheader.vbuf.index;
+	p->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	p->memory = vind->memory;
+	p->flags = V4L2_BUF_FLAG_DONE;;	//TODO
+	p->length = vind->pix.num_planes;
+	for (plane = 0; plane < vind->pix.num_planes; ++plane) {
+		struct v4l2_plane *pdst = &p->m.planes[plane];
+		// struct vb2_plane *psrc = &vb->planes[plane];
+
+		pdst->bytesused = vind->pix.plane_fmt[plane].sizeimage;
+		pdst->length = vind->pix.plane_fmt[plane].sizeimage;
+		if (p->memory == V4L2_MEMORY_MMAP)
+			pdst->m.mem_offset = 0;	//allocBuffer 
+		else if (p->memory == V4L2_MEMORY_DMABUF)
+			pdst->m.fd = recv_msg.rcv_vheader.vbuf.m_fd;
+		pdst->data_offset = 0; //todo
+		if (plane == 1)
+			pdst->data_offset = vind->pix.plane_fmt[0].sizeimage;
+		memset(pdst->reserved, 0, sizeof(pdst->reserved));
+	}
+
+	return 0;
+}
+static int svivi_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret;
+
+	vcam_info("queue buf%d type:%d, memory:%d, fd:%d,%d", p->index, p->type, p->memory, p->m.planes[0].m.fd, p->m.planes[1].m.fd);
+
+	// char *kmsg = "start to queue !!!";
+
+	// memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_QBUF;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+	send_to_user(vind->netlinkfd, &snd_vheader->vbuf, sizeof(struct v4l2_vbuffer), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_QBUF, 1000);
+	if (ret)
+		return ret;
+
+	return 0;
+	// return vb2_ioctl_qbuf(file, priv, p);
+}
+
+//refer to __fill_v4l2_buffer and _fill_dmx_buffer
+static int svivi_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret;
+    // char *kmsg = "start to querybuf !!!";
+
+	vcam_info("------------ in");
+
+    // memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_QUERYBUF;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+	send_to_user(vind->netlinkfd, &snd_vheader->vbuf, sizeof(struct v4l2_vbuffer), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_QUERYBUF, 1000);
+	if (ret)
+		return ret;
+
+	//todo: check buffer index out of range and check __verify_planes_array
+
+	// struct v4l2_buffer *b = pb;
+	// struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	// struct vb2_queue *q = vb->vb2_queue;
+	unsigned int plane;
+
+	/* Copy back data such as timestamp, flags, etc. */
+	// b->index = vb->index;
+	p->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	p->memory = vind->memory;
+	p->bytesused = 0;
+
+	p->flags = 0; 	// refer to print
+	p->field = vind->pix.field;
+	// v4l2_buffer_set_timestamp(b, vb->timestamp);
+	// p->timecode = vbuf->timecode;
+	// p->sequence = vbuf->sequence;
+	p->reserved2 = 0;
+	p->request_fd = 0;
+
+	/*
+	* Fill in plane-related data if userspace provided an array
+	* for it. The caller has already verified memory and size.
+	*/
+	p->length = vind->pix.num_planes;
+	for (plane = 0; plane < vind->pix.num_planes; ++plane) {
+		struct v4l2_plane *pdst = &p->m.planes[plane];
+		// struct vb2_plane *psrc = &vb->planes[plane];
+
+		pdst->bytesused = vind->pix.plane_fmt[plane].sizeimage;	//__prepare_mmap -> mxc_isi_video_buffer_prepare -> vb2_set_plane_payload
+		pdst->length = vind->pix.plane_fmt[plane].sizeimage;	//vb2_core_reqbufs -> __vb2_queue_alloc -> mxc_isi_video_queue_setup
+		if (p->memory == V4L2_MEMORY_MMAP)
+			pdst->m.mem_offset = 0;	//allocBuffer 
+		else if (p->memory == V4L2_MEMORY_DMABUF)
+			pdst->m.fd = recv_msg.rcv_vheader.vbuf.m_fd;
+		pdst->data_offset = 0; //todo
+		if (plane == 1)
+			pdst->data_offset = vind->pix.plane_fmt[0].sizeimage;
+		memset(pdst->reserved, 0, sizeof(pdst->reserved));
+	}
+
+	vcam_info("querybuff exit, index:%d %d fd:%d", p->index, recv_msg.rcv_vheader.vbuf.index, recv_msg.rcv_vheader.vbuf.m_fd);
+
+	// return vb2_ioctl_querybuf(file, priv, p);
+	return 0;
+}
+static int svivi_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret;
+    // char *kmsg = "start to stream on !!!";
+
+    // memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_STREAMON;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+
+	send_to_user(vind->netlinkfd, &snd_vheader->vstream, sizeof(struct v4l2_vstream), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_STREAMON, 1000);
+	if (ret)
+		return ret;
+
+	vind->streaming = 1;
+
+	return 0;
+}
+static int svivi_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	int ret = 0;
+    // char *kmsg = "start to stream off !!!";
+    // memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_STREAMOFF;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+
+	send_to_user(vind->netlinkfd, &snd_vheader->vstream, sizeof(struct v4l2_vstream), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_STREAMOFF, 1000);
+
+	vind->streaming = 0;
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops svivi_ioctl_ops = {
+	.vidioc_querycap = svivi_querycap,
+
+	.vidioc_enum_fmt_vid_cap 	= svivi_enum_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap_mplane	= svivi_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap_mplane	= svivi_s_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap_mplane	= svivi_g_fmt_vid_cap,
+	// .vidioc_g_fmt_vid_cap 		= svivi_g_fmt_vid_cap,
+	// .vidioc_try_fmt_vid_cap 	= svivi_try_fmt_vid_cap,
+	// .vidioc_s_fmt_vid_cap 		= svivi_s_fmt_vid_cap,
+
+	//.vidioc_enum_framesizes		= vidioc_enum_framesizes,
+	.vidioc_g_fbuf			= svivi_g_fbuf,
+	.vidioc_s_fbuf			= svivi_s_fbuf,
+
+	.vidioc_reqbufs 			= svivi_reqbufs,
+	.vidioc_querybuf 			= svivi_querybuf,
+	.vidioc_expbuf				= svivi_expbuf,
+	.vidioc_qbuf 				= svivi_qbuf,
+	.vidioc_dqbuf 				= svivi_dqbuf,
+
+	.vidioc_streamon 			= svivi_streamon,
+	.vidioc_streamoff 			= svivi_streamoff,
+};
+
+static int svivi_release(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+
+	in_use = false;
+
+	memset(&recv_msg, 0, sizeof(recv_msg));
+	memset(&snd_msg, 0, sizeof(snd_msg));
+	init_completion(&recv_msg.complete);
+
+	if (vdev->queue)
+		return vb2_fop_release(file);
+	return v4l2_fh_release(file);
+}
+static int svivi_open(struct file *filp)
+{
+	in_use = true;
+
+	return v4l2_fh_open(filp);
+}
+static __poll_t svivi_poll(struct file *file, poll_table *wait)
+{
+	int ret;
+	struct vivi *vind = video_drvdata(file);
+	struct vcam_header *snd_vheader = &snd_msg.snd_vheader;
+	// char *kmsg = "start to poll !!!";
+
+	vcam_info("start to poll ...");
+
+	// memcpy(snd_vheader->pbuf, kmsg, strlen(kmsg) + 1);
+	snd_vheader->kpos = START_POLL;
+	snd_vheader->user_pid = recv_msg.rcv_vheader.user_pid;
+	send_to_user(vind->netlinkfd, &snd_vheader->vpoll, sizeof(struct v4l2_vpoll), snd_vheader->user_pid, snd_vheader->kpos);
+
+	ret = wait_for_recv_complete(FINISH_POLL, 2000);
+
+	return POLLIN | POLLRDNORM;
+	// return vb2_fop_poll(file, wait);
+}
+static int svivi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return 0;
+	// return vb2_fop_mmap(file, vma);
+}
+
+static const struct v4l2_file_operations svivi_fops = {
+	.owner			= THIS_MODULE,
+	.open           = svivi_open,
+	.release        = svivi_release,
+	.poll			= svivi_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = svivi_mmap,
+};
+
+static int vid_cap_queue_setup(struct vb2_queue *vq,
+		       unsigned *nbuffers, unsigned *nplanes,
+		       unsigned sizes[], struct device *alloc_devs[]){
+
+	return 0;
+}
+
+static int vid_cap_buf_prepare(struct vb2_buffer *vb){
+
+	return 0;
+}
+
+static void vid_cap_buf_finish(struct vb2_buffer *vb) {
+
+}
+
+static void vid_cap_buf_queue(struct vb2_buffer *vb) {
+
+}
+
+static int vid_cap_start_streaming(struct vb2_queue *vq, unsigned count) {
+
+	return 0;
+}
+
+static void vid_cap_stop_streaming(struct vb2_queue *vq) {
+
+}
+
+const struct vb2_ops svivi_vid_cap_qops = {
+	.queue_setup		= vid_cap_queue_setup,
+	.buf_prepare		= vid_cap_buf_prepare,
+	.buf_finish			= vid_cap_buf_finish,
+	.buf_queue			= vid_cap_buf_queue,
+	.start_streaming	= vid_cap_start_streaming,
+	.stop_streaming		= vid_cap_stop_streaming,
+};
+
+static void svivi_dev_release(struct v4l2_device *v4l2_dev)
+{
+	struct vivi *vind = container_of(v4l2_dev, struct vivi, v4l2_dev);
+
+	v4l2_device_unregister(&vind->v4l2_dev);
+	kfree(vind);
+}
+
+void svivi_video_device_release_empty(struct video_device *vdev) {
+
+}
+
+static int svivi_probe(struct platform_device *pdev) {
+	int ret = -1;
+	struct vb2_queue *q;
+	struct video_device *vfd;
+	struct vivi *svivi;
+
+	svivi = kzalloc(sizeof(*svivi), GFP_KERNEL);
+	if (!svivi)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, svivi);
+
+	snprintf(svivi->v4l2_dev.name, sizeof(svivi->v4l2_dev.name),
+			"%s-00", "spacemit vivi");
+	ret = v4l2_device_register(&pdev->dev,&svivi->v4l2_dev);
+	if (ret < 0) {
+		vcam_err("Failed to register v4l2_device: %d", ret);
+		goto v4l2_dev_err;
+	}
+	svivi->v4l2_dev.release = svivi_dev_release;
+
+	svivi->vid_cap_caps = 	V4L2_CAP_VIDEO_CAPTURE_MPLANE | \
+							V4L2_CAP_STREAMING;
+
+	mutex_init(&svivi->mutex);
+
+	/* initialize vid_cap queue */
+	q = &svivi->vb_vid_cap_q;
+	q->type = V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;
+	q->drv_priv = svivi;
+	q->buf_struct_size = sizeof(struct svivi_buffer);
+	q->ops = &svivi_vid_cap_qops;
+	q->mem_ops = &vb2_vmalloc_memops;
+	q->lock = &svivi->mutex;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->dev = svivi->v4l2_dev.dev;
+	ret = vb2_queue_init(q);
+	if (ret)
+		goto unreg_dev;
+
+	vfd = &svivi->vid_cap_dev;
+	snprintf(vfd->name, sizeof(vfd->name), "svivi-00-vid-cap");
+	vfd->fops = &svivi_fops;
+	vfd->ioctl_ops = &svivi_ioctl_ops;
+	vfd->device_caps = svivi->vid_cap_caps;
+	vfd->release = svivi_video_device_release_empty;
+	vfd->v4l2_dev = &svivi->v4l2_dev;
+	vfd->queue = &svivi->vb_vid_cap_q;
+	vfd->lock = &svivi->mutex;
+	video_set_drvdata(vfd, svivi);
+	ret = video_register_device(vfd, VFL_TYPE_VIDEO, 50);
+	if (ret < 0)
+		goto unreg_dev;
+
+	memset(&recv_msg, 0, sizeof(recv_msg));
+	memset(&snd_msg, 0, sizeof(snd_msg));
+	init_completion(&recv_msg.complete);
+
+    svivi->netlinkfd = (struct sock *)netlink_kernel_create(&init_net, SVIVI_NETLINK, &cfg);
+    if (svivi->netlinkfd == NULL) {
+        vcam_err("can not create a netlink socket");
+        goto unreg_dev;
+    }
+
+	svivi->streaming = 0;
+	vcam_info("svivi probe ok.");
+
+	return ret;
+
+unreg_dev:
+	v4l2_device_put(&svivi->v4l2_dev);
+v4l2_dev_err:
+	kfree(svivi);
+	vcam_info("svivi probe fail!");
+
+	return -1;
+}
+
+static int svivi_remove(struct platform_device *pdev){
+	struct vivi *vind;
+
+	vind = platform_get_drvdata(pdev);
+	if (!vind) {
+		dev_err(&pdev->dev, "vind is NULL");
+		return 0;
+	}
+	vcam_info("--------- in");
+
+	video_unregister_device(&vind->vid_cap_dev);
+	v4l2_device_put(&vind->v4l2_dev);
+	//kfree(svivi);
+
+    if (vind->netlinkfd) {
+        netlink_kernel_release(vind->netlinkfd);
+        vind->netlinkfd = NULL;
+    }
+    vcam_info("test_netlink_exit!!");
+
+	return 0;
+}
+
+static void svivi_pdev_release(struct device *dev)
+{
+}
+
+static struct platform_device svivi_pdev = {
+	.name			= "spacemit vivi",
+	.dev.release	= svivi_pdev_release,
+};
+
+static struct platform_driver svivi_pdrv = {
+	.probe		= svivi_probe,
+	.remove		= svivi_remove,
+	.driver		= {
+		.name	= "spacemit vivi",
+	},
+};
+
+static int __init svivi_init(void)
+{
+	int ret;
+
+	ret = platform_device_register(&svivi_pdev);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&svivi_pdrv);
+	if (ret)
+		platform_device_unregister(&svivi_pdev);
+
+	return ret;
+}
+
+static void __exit svivi_exit(void)
+{
+	platform_driver_unregister(&svivi_pdrv);
+	platform_device_unregister(&svivi_pdev);
+}
+
+module_init(svivi_init);
+module_exit(svivi_exit);
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.c b/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.c
new file mode 100644
index 000000000000..4c3fd9cd6f09
--- /dev/null
+++ b/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * vcam_dbg.c - vcamera debug utility
+ *
+ * Copyright(C) 2023 SPACEMIT Micro Limited
+ */
+#define DEBUG			/* for pr_debug() */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include "vcam_dbg.h"
+
+static uint debug_mdl = 0x0; /* disable all modules at default */
+//static uint debug_mdl = 0x1FF; /* enable all modules for debug */
+
+void vcam_printk(int module_tag, const char *vcam_level, const char *kern_level,
+		const char *func, int line, const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	printk("%s" "%s: %s %d: %pV\n", kern_level, vcam_level, func, line, &vaf);
+	va_end(args);
+}
+
+EXPORT_SYMBOL(vcam_printk);
+
+void vcam_printk_ratelimited(int module_tag, const char *vcam_level,
+			    const char *kern_level, const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	printk_ratelimited("%s" "%s: %pV\n", kern_level, vcam_level, &vaf);
+	va_end(args);
+}
+
+EXPORT_SYMBOL(vcam_printk_ratelimited);
+
+void vcam_debug(int module_tag, const char *vcam_level, const char *func, int line, const char *format, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	if (!debug_mdl)
+		return;
+
+	va_start(args, format);
+
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	pr_debug("%s: %s %d: %pV\n", vcam_level, func, line, &vaf);
+	va_end(args);
+}
+
+EXPORT_SYMBOL(vcam_debug);
+
+// MODULE_PARM_DESC(debug_mdl, "Enable debug output, where each bit enables a module.\n"
+// 				 "\t\tBit 0 (0x01)  will enable VI messages\n"
+// 				 "\t\tBit 1 (0x02)  will enable ISP messages\n"
+// 				 "\t\tBit 2 (0x04)  will enable CPP messages\n"
+// 				 "\t\tBit 3 (0x08)  will enable VBE messages\n"
+// 				 "\t\tBit 4 (0x10)  will enable SENSOR messages\n"
+// 				 "\t\tBit 5 (0x20)  will enable IRCUT messages\n"
+// 				 "\t\tBit 8 (0x100) will enable COMMON messages");
+module_param(debug_mdl, uint, 0644);
+
diff --git a/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.h b/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.h
new file mode 100644
index 000000000000..149fb3ee8fc7
--- /dev/null
+++ b/drivers/media/platform/spacemit/virtual_camera/vcam_dbg.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * vcam_dbg.h - vcamera debug utility
+ *
+ * Copyright(C) 2023 SPACEMIT Micro Limited
+ */
+#ifndef __VCAM_DBG_H__
+#define __VCAM_DBG_H__
+
+#include <linux/printk.h>
+
+// enum dbg_module_tag {
+// 	VCAM_MDL_VI = 0,
+// 	VCAM_MDL_ISP = 1,
+// 	VCAM_MDL_CPP = 2,
+// 	VCAM_MDL_VBE = 3,
+// 	VCAM_MDL_SNR = 4,
+// 	VCAM_MDL_IRCUT = 5,
+// 	VCAM_MDL_COMMON = 8,
+// };
+
+#ifndef VCAM_MODULE_TAG
+// #define VCAM_MODULE_TAG VCAM_MDL_COMMON
+#define VCAM_MODULE_TAG 8
+#endif
+
+__printf(6, 7)
+void vcam_printk(int module_tag, const char *vcam_level, const char *kern_level,
+		const char *func, int line, const char *format, ...);
+
+__printf(4, 5)
+void vcam_printk_ratelimited(int module_tag, const char *vcam_level,
+			    const char *kern_level, const char *format, ...);
+
+__printf(5, 6)
+void vcam_debug(int module_tag, const char *vcam_level, const char *func, int line, const char *format, ...);
+
+/**
+ * vcamera error output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_err(format, ...)                                       \
+	vcam_printk(VCAM_MODULE_TAG, "vcam_err", KERN_ERR,                \
+			 __func__, __LINE__, format, ##__VA_ARGS__)
+
+/**
+ * vcamera error output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_err_ratelimited(format, ...)                        \
+	vcam_printk_ratelimited(VCAM_MODULE_TAG, "vcam_err", KERN_ERR, \
+			 format, ##__VA_ARGS__)
+
+/**
+ * vcamera warning output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_warn(format, ...)                                  \
+	vcam_printk(VCAM_MODULE_TAG, "vcam_wrn", KERN_WARNING,        \
+			 __func__, __LINE__, format, ##__VA_ARGS__)
+
+/**
+ * vcamera notice output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_not(format, ...)                                    \
+	vcam_printk(VCAM_MODULE_TAG, "vcam_not", KERN_NOTICE,          \
+			 __func__, __LINE__, format, ##__VA_ARGS__)
+
+/**
+ * vcamera information output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_info(format, ...)                                     \
+	vcam_printk(VCAM_MODULE_TAG, "vcam_inf", KERN_INFO,              \
+			 __func__, __LINE__, format, ##__VA_ARGS__)
+
+/**
+ * vcamera debug output.
+ *
+ * @format: printf() like format string.
+ */
+#define vcam_dbg(format, ...)                                      \
+	vcam_debug(VCAM_MODULE_TAG, "vcam_dbg", __func__, __LINE__, format, ##__VA_ARGS__)
+
+#define VCAM_DBG_TRACE
+#ifdef VCAM_DBG_TRACE
+#define vcam_trace(f, args...)	trace_printk(f, ##args)
+#else
+#define vcam_trace(f, args...)	no_printk(f, ##args)
+#endif
+#endif /* ifndef __VCAM_DBG_H__ */
+
diff --git a/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
index b48ab0177f76..a19d94d8b6a3 100644
--- a/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
+++ b/drivers/media/platform/spacemit/vpu_k1x/if/v4l2/mvx_v4l2_session.c
@@ -303,7 +303,7 @@ static void handle_event(struct mvx_session *session,
 		 * If the FW later returns a buffer to us, we could silently
 		 * skip it.
 		 */
-		if (vb->state != VB2_BUF_STATE_DEQUEUED) {
+		if (vb->state != VB2_BUF_STATE_DEQUEUED && vb->state != VB2_BUF_STATE_DONE) {
 			enum vb2_buffer_state state =
 				mvx_v4l2_buffer_update(vbuf);
 
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 81dabf98902f..97028ce88daf 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -569,6 +569,13 @@ config SPACEMIT_TCM
 	help
 	  This driver allows you to alloc tcm for userspace.
 
+config OCP2138
+	tristate "Driver for ocp2138"
+	default y
+
+	help
+	  Support for ocp2138.
+
 config ICM42607
         tristate "ICM42607 sensor support"
         depends on I2C
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f24f4abdf4c9..af9c1df50acc 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -68,4 +68,5 @@ obj-$(CONFIG_TMR_INJECT)	+= xilinx_tmr_inject.o
 obj-$(CONFIG_TPS6594_ESM)	+= tps6594-esm.o
 obj-$(CONFIG_TPS6594_PFSM)	+= tps6594-pfsm.o
 obj-$(CONFIG_SPACEMIT_TCM)	+= tcm.o
+obj-$(CONFIG_OCP2138)	+= ocp2138.o
 obj-$(CONFIG_ICM42607)		+= icm42607.o input-polldev.o
diff --git a/drivers/misc/ocp2138.c b/drivers/misc/ocp2138.c
new file mode 100644
index 000000000000..d645ef2b3026
--- /dev/null
+++ b/drivers/misc/ocp2138.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 Spacemit Co., Ltd.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/regmap.h>
+
+struct ocp2138_dev {
+	struct device *dev;
+	struct regmap *regmap;
+	struct i2c_client *client;
+};
+
+static const struct regmap_config ocp2138_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xff,
+};
+
+static int ocp2138_probe(struct i2c_client *client)
+{
+	struct ocp2138_dev *ocp2138;
+	unsigned int value;
+
+	dev_info(&client->dev, "%s()\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "Failed check I2C functionality");
+		return -ENODEV;
+	}
+
+	ocp2138 = devm_kzalloc(&client->dev, sizeof(*ocp2138), GFP_KERNEL);
+	if (!ocp2138)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, ocp2138);
+	ocp2138->dev = &client->dev;
+	ocp2138->client = client;
+
+	ocp2138->regmap = devm_regmap_init_i2c(client, &ocp2138_regmap_config);
+	if (IS_ERR(ocp2138->regmap)) {
+		dev_err(ocp2138->dev, "regmap i2c init failed\n");
+		return PTR_ERR(ocp2138->regmap);
+	}
+
+	regmap_write(ocp2138->regmap, 0x00, 0x14);
+	regmap_write(ocp2138->regmap, 0x01, 0x14);
+	regmap_write(ocp2138->regmap, 0xff, 0x80);
+
+	regmap_read(ocp2138->regmap, 0x00, &value);
+	dev_info(ocp2138->dev, "%s() 0x00 %d\n", __func__, value);
+	regmap_read(ocp2138->regmap, 0x01, &value);
+	dev_info(ocp2138->dev, "%s() 0x01 %d\n", __func__, value);
+	regmap_read(ocp2138->regmap, 0xff, &value);
+	dev_info(ocp2138->dev, "%s() 0xff %d\n", __func__, value);
+
+	return 0;
+}
+
+static void ocp2138_remove(struct i2c_client *client)
+{
+	dev_info(&client->dev, "%s()\n", __func__);
+}
+
+static const struct i2c_device_id ocp2138_ids[] = {
+	{ "ocp2138", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ocp2138_ids);
+
+static const struct of_device_id ocp2138_of_match[] = {
+	{ .compatible = "spacemit,lcd_bias_ocp2138", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ocp2138_of_match);
+
+static struct i2c_driver ocp2138_i2c_driver = {
+	.driver = {
+		.name = "ocp2138",
+		.of_match_table = ocp2138_of_match,
+	},
+	.probe = ocp2138_probe,
+	.remove = ocp2138_remove,
+	.id_table = ocp2138_ids,
+};
+module_i2c_driver(ocp2138_i2c_driver);
+
+MODULE_DESCRIPTION("OCP2138 I2C Driver");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/drivers/net/ethernet/spacemit/k1x-emac.c b/drivers/net/ethernet/spacemit/k1x-emac.c
index 8932171243b4..935b7267a0a5 100644
--- a/drivers/net/ethernet/spacemit/k1x-emac.c
+++ b/drivers/net/ethernet/spacemit/k1x-emac.c
@@ -2875,6 +2875,9 @@ static struct platform_driver emac_driver = {
 		.name = DRIVER_NAME,
 		.of_match_table = of_match_ptr(emac_of_match),
 		.pm     = &k1x_emac_pm_qos,
+#ifdef CONFIG_SPACEMIT_PARALLEL_BOOTING
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+#endif
 	},
 };
 
diff --git a/drivers/net/wireless/realtek/rtw89/rtw8852be.c b/drivers/net/wireless/realtek/rtw89/rtw8852be.c
index ecf39d2d9f81..efec0df06549 100644
--- a/drivers/net/wireless/realtek/rtw89/rtw8852be.c
+++ b/drivers/net/wireless/realtek/rtw89/rtw8852be.c
@@ -83,7 +83,24 @@ static struct pci_driver rtw89_8852be_driver = {
 	.remove		= rtw89_pci_remove,
 	.driver.pm	= &rtw89_pm_ops,
 };
+
+#if defined(CONFIG_SOC_SPACEMIT_K1X)
+extern int spacemit_wlan_set_power(int on);
+static int __init rtw89_8852be_driver_init(void)
+{
+	spacemit_wlan_set_power(1);
+	return pci_register_driver(&rtw89_8852be_driver);
+}
+module_init(rtw89_8852be_driver_init);
+static void __exit rtw89_8852be_driver_exit(void)
+{
+	pci_unregister_driver(&rtw89_8852be_driver);
+	spacemit_wlan_set_power(0);
+}
+module_exit(rtw89_8852be_driver_exit);
+#elif
 module_pci_driver(rtw89_8852be_driver);
+#endif
 
 MODULE_AUTHOR("Realtek Corporation");
 MODULE_DESCRIPTION("Realtek 802.11ax wireless 8852BE driver");
diff --git a/drivers/pci/controller/dwc/pcie-k1x.c b/drivers/pci/controller/dwc/pcie-k1x.c
index fe1281ad2629..3427a454e60c 100644
--- a/drivers/pci/controller/dwc/pcie-k1x.c
+++ b/drivers/pci/controller/dwc/pcie-k1x.c
@@ -1861,6 +1861,7 @@ static const struct dev_pm_ops k1x_pcie_pm_ops = {
 };
 
 static struct platform_driver k1x_pcie_driver = {
+	.probe = k1x_pcie_probe,
 	.driver = {
 		.name	= "k1x-dwc-pcie",
 		.of_match_table = of_k1x_pcie_match,
@@ -1868,4 +1869,4 @@ static struct platform_driver k1x_pcie_driver = {
 		.pm	= &k1x_pcie_pm_ops,
 	},
 };
-builtin_platform_driver_probe(k1x_pcie_driver, k1x_pcie_probe);
+module_platform_driver(k1x_pcie_driver);
diff --git a/drivers/power/supply/sgm4154x_charger.c b/drivers/power/supply/sgm4154x_charger.c
index 47586366abab..beb560de834a 100644
--- a/drivers/power/supply/sgm4154x_charger.c
+++ b/drivers/power/supply/sgm4154x_charger.c
@@ -711,7 +711,7 @@ static int sgm4154x_get_state(struct sgm4154x_device *sgm,
 	state->therm_stat = !!(chrg_stat & SGM4154x_THERM_STAT);
 	state->vsys_stat = !!(chrg_stat & SGM4154x_VSYS_STAT);
 
-	pr_debug("%s chrg_stat =%d,vbus_status =%d online = %d\n",__func__,chrg_stat,state->vbus_status,state->online);
+	pr_debug("%s chrg_stat =%d,vbus_status =%d online = %d\n",__func__,chrg_stat,state->chrg_type,state->online);
 
 
 	ret = regmap_read(sgm->regmap, SGM4154x_CHRG_FAULT, &fault);
@@ -1152,13 +1152,8 @@ static void charger_monitor_work_func(struct work_struct *work)
 	sgm->state = state;
 	mutex_unlock(&sgm->lock);
 
-	if (!sgm->state.vbus_status) {
-		pr_err("%s not present vbus_status \n",__func__);
-		goto OUT;
-	}
 	sgm4154x_dump_register(sgm);
 	pr_debug("%s\n",__func__);
-OUT:
 	schedule_delayed_work(&sgm->charge_monitor_work, 10*HZ);
 }
 
diff --git a/drivers/power/supply/sgm4154x_charger.h b/drivers/power/supply/sgm4154x_charger.h
index 48130723d4f9..e0c1eeacea4d 100644
--- a/drivers/power/supply/sgm4154x_charger.h
+++ b/drivers/power/supply/sgm4154x_charger.h
@@ -251,7 +251,6 @@ struct sgm4154x_state {
 	bool therm_stat;
 	bool online;
 	u8 chrg_stat;
-	u8 vbus_status;
 
 	bool chrg_en;
 	bool hiz_en;
diff --git a/drivers/soc/spacemit/ddr-bw/spacemit_ddrbw.h b/drivers/soc/spacemit/ddr-bw/spacemit_ddrbw.h
index ed376df7d821..6640828ed193 100644
--- a/drivers/soc/spacemit/ddr-bw/spacemit_ddrbw.h
+++ b/drivers/soc/spacemit/ddr-bw/spacemit_ddrbw.h
@@ -299,8 +299,7 @@ struct spacemit_ddrbw_status {
 #define IDMON_CTRL_EN		24
 #define IDMON_CLK_EN		16
 
-#define is_mon_valid(mon)	((mon < (SPACEMIT_MON_CTRL_NUM + \
-		SPACEMIT_ID_MASTER_NUM + 1)) ? 0 : -EINVAL)
+#define is_mon_valid(mon)	((mon < (SPACEMIT_MON_CTRL_NUM + SPACEMIT_ID_MASTER_NUM + 1)) ? 0 : -EINVAL)
 
 #define PERF_SYS_NODE_LEN	20
 
@@ -316,10 +315,13 @@ struct spacemit_ddrbw_status {
  */
 /* Monitor bandwidth by default. */
 int mon_evt_id[SPACEMIT_MON_EVT_NUM] = {16, 18, 1, 9, 17, 19};
+
 /* need to enable/disable monitor for max rd/wr latency data */
 int mon_lat_id[SPACEMIT_MON_LAT_NUM];
-/* we will just use evnet 5 and event 13 on dove z1 */
+
+/* we will just use evnet 5 and event 13 */
 int mon_lat_id_z1[SPACEMIT_MON_LAT_NUM] = {5, 13, 5, 13};
+
 /*
  * latency for a0:
  * event 0x14: max rd
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
index f9bb8130088c..350b06001b70 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
@@ -31,6 +31,7 @@ struct wlan_pwrseq {
 	u32 power_on_delay_ms;
 
 	struct gpio_desc *regon;
+	struct gpio_desc *hostwake;
 	int irq;
 
 	struct mutex wlan_mutex;
@@ -107,6 +108,19 @@ static int spacemit_wlan_on(struct wlan_pwrseq *pwrseq, bool on_off)
 	return 0;
 }
 
+static void spacemit_get_gpio_irq(struct wlan_pwrseq *pwrseq)
+{
+	pwrseq->hostwake = devm_gpiod_get(pwrseq->dev, "hostwake", GPIOD_IN);
+	if (IS_ERR_OR_NULL(pwrseq->hostwake)) {
+		dev_err(pwrseq->dev, "no interrupt gpio property\n");
+		return;
+	}
+
+	pwrseq->irq = gpiod_to_irq(pwrseq->hostwake);
+	if (pwrseq->irq < 0)
+		dev_err(pwrseq->dev, "failed to get GPIO IRQ\n");
+}
+
 static int spacemit_wlan_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -128,10 +142,14 @@ static int spacemit_wlan_probe(struct platform_device *pdev)
 	}
 
 	pwrseq->irq = platform_get_irq(pdev, 0);
-	if (pwrseq->irq < 0){
-		dev_err(pwrseq->dev, "get hostwake irq failed, ignore wow\n");
+	if (pwrseq->irq < 0) {
+		dev_info(pwrseq->dev, "get platform irq failed, try to get gpio irq\n");
+		spacemit_get_gpio_irq(pwrseq);
 	}
 
+	if (pwrseq->irq < 0)
+		dev_err(pwrseq->dev, "get hostwake irq failed, ignore wow\n");
+
 	if(device_property_read_u32(dev, "power-on-delay-ms",
 				 &pwrseq->power_on_delay_ms))
 		pwrseq->power_on_delay_ms = 10;
diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index c265a1f62fc1..022cbdcd6915 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -2728,7 +2728,12 @@ static void _fsg_common_free_buffers(struct fsg_buffhd *buffhds, unsigned n)
 	if (buffhds) {
 		struct fsg_buffhd *bh = buffhds;
 		while (n--) {
+#if defined(CONFIG_SOC_SPACEMIT_K1X)
+			put_page(bh->page);
+			bh->page = NULL;
+#else
 			kfree(bh->buf);
+#endif
 			++bh;
 		}
 		kfree(buffhds);
@@ -2752,7 +2757,13 @@ int fsg_common_set_num_buffers(struct fsg_common *common, unsigned int n)
 		bh->next = bh + 1;
 		++bh;
 buffhds_first_it:
+#if defined(CONFIG_SOC_SPACEMIT_K1X)
+		bh->page = alloc_pages(GFP_KERNEL | __GFP_COMP | __GFP_NOWARN | GFP_DMA32,
+			get_order(FSG_BUFLEN));
+		bh->buf = page_address(bh->page);
+#else
 		bh->buf = kmalloc(FSG_BUFLEN, GFP_KERNEL);
+#endif
 		if (unlikely(!bh->buf))
 			goto error_release;
 	} while (--i);
diff --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
index 0a544a82cbf8..81cb567ca30e 100644
--- a/drivers/usb/gadget/function/storage_common.h
+++ b/drivers/usb/gadget/function/storage_common.h
@@ -141,6 +141,9 @@ enum fsg_buffer_state {
 };
 
 struct fsg_buffhd {
+#if defined(CONFIG_SOC_SPACEMIT_K1X)
+	struct page			*page;
+#endif
 	void				*buf;
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
diff --git a/drivers/usb/phy/phy-k1x-ci-otg.c b/drivers/usb/phy/phy-k1x-ci-otg.c
index 522135bef288..5235e71f1ba6 100644
--- a/drivers/usb/phy/phy-k1x-ci-otg.c
+++ b/drivers/usb/phy/phy-k1x-ci-otg.c
@@ -775,7 +775,7 @@ static int mv_otg_probe(struct platform_device *pdev)
 	mvotg->host_remote_wakeup =
 		!device_property_read_bool(&pdev->dev, "spacemit,reset-on-resume");
 
-	mv_otg_run_state_machine(mvotg, 2 * HZ);
+	mv_otg_run_state_machine(mvotg, msecs_to_jiffies(200));
 
 	dev_info(&pdev->dev, "successful probe OTG device.\n");
 
diff --git a/drivers/usb/typec/husb239.c b/drivers/usb/typec/husb239.c
index 340f50855b2c..b2b89d9da49d 100644
--- a/drivers/usb/typec/husb239.c
+++ b/drivers/usb/typec/husb239.c
@@ -18,6 +18,7 @@
 #include <linux/usb/typec_mux.h>
 #include <linux/delay.h>
 #include <linux/power_supply.h>
+#include <linux/pm_wakeirq.h>
 #include "mux.h"
 #include <soc/spacemit/spacemit_panel.h>
 
@@ -441,10 +442,41 @@ static int husb239_register_partner(struct husb239 *husb239,
 	return 0;
 }
 
+static int husb239_usbpd_detect(struct husb239 *husb239)
+{
+	int ret, status, status0;
+	int count = 10;
+
+	while(--count) {
+		ret = regmap_read(husb239->regmap, HUSB239_REG_CONTRACT_STATUS0, &status0);
+		if (ret)
+			return ret;
+
+		dev_dbg(husb239->dev, "husb239 detect pd, contract status0: %x\n", status0);
+		if (((status0 & HUSB239_PD_CONTRACT_MASK) >> HUSB239_PD_CONTRACT_SHIFT) == SNKCAP_5V)
+			break;
+
+		/* check attach status */
+		ret = regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status);
+		if (ret)
+			return ret;
+
+		if (!(status & HUSB239_REG_STATUS_ATTACH))
+			return -ENODEV;
+
+		msleep(50);
+	}
+
+	if (count == 0)
+		return -EINVAL;
+
+	return 0;
+}
+
 static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 {
 	struct typec_info *info = &husb239->info;
-	unsigned int src_pdo;
+	unsigned int src_pdo, type, status;
 	int ret, snk_sel;
 	int count = 10;
 
@@ -485,6 +517,14 @@ static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 		if (src_pdo & HUSB239_REG_SRC_DETECT)
 			break;
 
+		/* check attach status */
+		ret = regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status);
+		if (ret)
+			return ret;
+
+		if (!(status & HUSB239_REG_STATUS_ATTACH))
+			return -ENODEV;
+
 		msleep(100);
 	}
 
@@ -497,7 +537,26 @@ static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 	if (ret)
 		return ret;
 
-	msleep(100);
+	count = 20;
+	while(--count) {
+		ret = regmap_read(husb239->regmap, HUSB239_REG_TYPE, &type);
+		if (ret)
+			return ret;
+
+		dev_dbg(husb239->dev, "husb239_attach type: %x\n", type);
+		if (!(type & HUSB239_REG_TYPE_CC_RX_ACTIVE))
+			break;
+
+		/* check attach status */
+		ret = regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status);
+		if (ret)
+			return ret;
+
+		if (!(status & HUSB239_REG_STATUS_ATTACH))
+			return -ENODEV;
+
+		msleep(100);
+	}
 
 	ret = regmap_write_bits(husb239->regmap, HUSB239_REG_GO_COMMAND,
 				HUSB239_REG_GO_COMMAND_MASK, HUSB239_REG_GO_PDO_SELECT);
@@ -557,8 +616,10 @@ static int husb239_attach(struct husb239 *husb239)
 	/* pd contract,  try max voltage */
 	if (type & HUSB239_REG_TYPE_SINK) {
 		husb239_update_operating_status(husb239);
-		husb239->req_voltage = info->sink_voltage / 1000;/* mv */
-		husb239_usbpd_request_voltage(husb239);
+		if (!husb239_usbpd_detect(husb239)) {
+			husb239->req_voltage = info->sink_voltage / 1000;/* mv */
+			husb239_usbpd_request_voltage(husb239);
+		}
 	}
 
 	return ret;
@@ -744,6 +805,7 @@ static irqreturn_t husb239_irq_handler(int irq, void *data)
 	struct husb239 *husb239 = (struct husb239 *)data;
 
 	disable_irq_nosync(husb239->gpio_irq);
+	pm_wakeup_event(husb239->dev, 0);
 	queue_work(husb239->workqueue, &husb239->work);
 
 	return IRQ_HANDLED;
@@ -773,7 +835,7 @@ static int husb239_irq_init(struct husb239 *husb239)
 
 	ret = devm_request_threaded_irq(husb239->dev, husb239->gpio_irq, NULL,
 				husb239_irq_handler,
-				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_NO_SUSPEND,
 				"husb239", husb239);
 	if (ret){
 		dev_err(husb239->dev, "failed to request threaded irq\n");
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index a3f51b671beb..958ed7e89b30 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -188,7 +188,6 @@ struct request {
 	 */
 	rq_end_io_fn *end_io;
 	void *end_io_data;
-	int request_debug_flags;
 };
 
 static inline enum req_op req_op(const struct request *req)
diff --git a/lib/raid6/algos.c b/lib/raid6/algos.c
index 0ec534faf019..2c60e3e21754 100644
--- a/lib/raid6/algos.c
+++ b/lib/raid6/algos.c
@@ -18,6 +18,9 @@
 #else
 #include <linux/module.h>
 #include <linux/gfp.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/async.h>
 /* In .bss so it's zeroed */
 const char raid6_empty_zero_page[PAGE_SIZE] __attribute__((aligned(256)));
 EXPORT_SYMBOL(raid6_empty_zero_page);
@@ -289,7 +292,18 @@ static void raid6_exit(void)
 	do { } while (0);
 }
 
-subsys_initcall(raid6_select_algo);
+static void raid6_select_algo_wrapper(void *data, long long unsigned int arg)
+{
+	raid6_select_algo();
+}
+
+static int __init raid6_select_algo_async_init(void)
+{
+	async_schedule(raid6_select_algo_wrapper, NULL);
+	return 0;
+}
+
+subsys_initcall(raid6_select_algo_async_init);
 module_exit(raid6_exit);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("RAID6 Q-syndrome calculations");
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index f336b2ddf972..29dac6af2efa 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -2078,7 +2078,7 @@ static int __init inet_init(void)
 	goto out;
 }
 
-fs_initcall(inet_init);
+subsys_initcall(inet_init);
 
 /* ------------------------------------------------------------------------ */
 
diff --git a/sound/soc/codecs/es8326.c b/sound/soc/codecs/es8326.c
index 560b230953f2..8c64a4b574fd 100644
--- a/sound/soc/codecs/es8326.c
+++ b/sound/soc/codecs/es8326.c
@@ -1171,6 +1171,8 @@ static int es8326_suspend(struct device *dev)
 	struct es8326_priv *es8326 = dev_get_drvdata(dev);
 
 	cancel_delayed_work_sync(&es8326->jack_detect_work);
+	snd_soc_jack_report(es8326->jack, 0, SND_JACK_HEADSET);
+	es8326_enable_spk(es8326, false);
 	es8326->calibrated = false;
 	regmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_OFF);
 	regcache_cache_only(es8326->regmap, true);
diff --git a/sound/soc/spacemit/spacemit-snd-sspa.c b/sound/soc/spacemit/spacemit-snd-sspa.c
index 17d81e22dcfa..e61fd5cc8e20 100644
--- a/sound/soc/spacemit/spacemit-snd-sspa.c
+++ b/sound/soc/spacemit/spacemit-snd-sspa.c
@@ -21,6 +21,7 @@
 #include <sound/soc.h>
 #include <sound/pxa2xx-lib.h>
 #include <sound/dmaengine_pcm.h>
+#include <linux/suspend.h>
 #include "spacemit-snd-sspa.h"
 
 #include <linux/notifier.h>
@@ -255,8 +256,8 @@ static int spacemit_sspa_suspend(struct device *dev)
 {
 	struct sspa_priv *priv = dev_get_drvdata(dev);
 
-	spacemit_hdmi_unregister_client(&hdmi_connect_notifier);
 	reset_control_assert(priv->rst);
+
 	return 0;
 }
 
@@ -270,7 +271,6 @@ static int spacemit_sspa_resume(struct device *dev)
 	value |= BIT(0);
 	writel(value, priv->base_hdmi + SPACEMIT_HDMI_AUDIO_EN);
 	reset_control_deassert(priv->rst);
-	spacemit_hdmi_register_client(&hdmi_connect_notifier);
 
 	if (spacemit_sspa_get_hdmi_status()) {
 		ret = devm_snd_soc_register_component(dev, &spacemit_snd_sspa_component,
@@ -278,8 +278,6 @@ static int spacemit_sspa_resume(struct device *dev)
 		if (ret != 0) {
 			dev_err(dev, "failed to register DAI\n");
 		}
-	} else {
-		snd_soc_unregister_component(dev);
 	}
 
 	return 0;
@@ -290,6 +288,43 @@ const struct dev_pm_ops spacemit_snd_sspa_pm_ops = {
 	.resume = spacemit_sspa_resume,
 };
 
+static int sspa_pm_suspend_notifier(struct notifier_block *nb,
+				unsigned long event,
+				void *dummy)
+{
+	int ret;
+
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+	case PM_HIBERNATION_PREPARE:
+		spacemit_hdmi_unregister_client(&hdmi_connect_notifier);
+		snd_soc_unregister_component(&sspa_platdev->dev);
+		return NOTIFY_DONE;
+
+	case PM_POST_SUSPEND:
+	case PM_POST_HIBERNATION:
+		if (spacemit_sspa_get_hdmi_status()) {
+			ret = devm_snd_soc_register_component(&sspa_platdev->dev, &spacemit_snd_sspa_component,
+				spacemit_snd_sspa_dai, ARRAY_SIZE(spacemit_snd_sspa_dai));
+			if (ret != 0) {
+				dev_err(&sspa_platdev->dev, "failed to register DAI\n");
+			}
+		} else {
+			snd_soc_unregister_component(&sspa_platdev->dev);
+		}
+
+		spacemit_hdmi_register_client(&hdmi_connect_notifier);
+		return NOTIFY_OK;
+
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct notifier_block sspa_pm_notif_block = {
+	.notifier_call = sspa_pm_suspend_notifier,
+};
+
 static int spacemit_snd_sspa_pdev_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -351,6 +386,7 @@ static int spacemit_snd_sspa_pdev_probe(struct platform_device *pdev)
 	}
 
 	spacemit_hdmi_register_client(&hdmi_connect_notifier);
+	ret = register_pm_notifier(&sspa_pm_notif_block);
 
 	return 0;
 }
-- 
2.47.0

