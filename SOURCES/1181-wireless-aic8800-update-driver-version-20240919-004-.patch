From 3cfa680abb2799290eea1ab5149d653447102a61 Mon Sep 17 00:00:00 2001
From: wanlong <long.wan@spacemit.com>
Date: Thu, 17 Oct 2024 11:32:04 +0800
Subject: [PATCH 1181/1448] wireless: aic8800: update driver, version:
 20240919-004-6.4.3.0

Change-Id: I522a9d532b1c70969523e07af04c21ee228ffb03
---
 .../aic8800/aic8800_bsp/aic_bsp_8800d.c       |  91 +-
 .../aic8800/aic8800_bsp/aic_bsp_8800d80.c     | 212 +++--
 .../aic8800/aic8800_bsp/aic_bsp_8800dc.c      | 132 ++-
 .../aic8800/aic8800_bsp/aic_bsp_driver.c      |  32 +-
 .../aic8800/aic8800_bsp/aic_bsp_driver.h      |   2 +-
 .../aic8800/aic8800_bsp/aic_bsp_export.h      |   6 +-
 .../aic8800/aic8800_bsp/aic_bsp_main.c        |   2 +-
 .../net/wireless/aic8800/aic8800_bsp/aicusb.c |  46 +-
 .../net/wireless/aic8800/aic8800_bsp/aicusb.h |  16 +-
 .../aic8800/aic8800_btusb/aic_btusb.c         |   7 +-
 .../aic8800/aic8800_btusb/aic_btusb.h         |  13 +
 .../wireless/aic8800/aic8800_fdrv/Makefile    |  17 +-
 .../aic8800/aic8800_fdrv/aic_vendor.c         |   6 +-
 .../aic8800/aic8800_fdrv/aicwf_sdio.c         |   4 +-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       | 361 +++++++-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.h       |  16 +
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c | 803 ++++++++++++++++--
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |  71 +-
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |   2 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |  12 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.c  |   6 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.h  |   6 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c | 110 ++-
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |  24 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |  89 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        |  10 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |  28 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |   1 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |  12 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.h   |   3 +
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |   2 +-
 31 files changed, 1697 insertions(+), 445 deletions(-)

diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
index ff099f1c5a49..83f47de2e414 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
@@ -169,47 +169,42 @@ static u32 rf_tbl_masked[][3] = {
 	{0x40344058, 0x00800000, 0x00000000},// pll trx
 };
 
-static u32 sys_reboot_tbl[][2] = {
-	{0x50017000, 0x0001ffff},
-	{0x50017008, 0x00000002},
-};
-
 #if defined(AICWF_SDIO_SUPPORT)
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw.bin",
-		.wl_table      = "aic/fmacfw_patch.bin"
+		.bt_adid       = "aic/sdio/fw_adid.bin",
+		.bt_patch      = "aic/sdio/fw_patch.bin",
+		.bt_table      = "aic/sdio/fw_patch_table.bin",
+		.wl_fw         = "aic/sdio/fmacfw.bin",
+		.wl_table      = "aic/sdio/fmacfw_patch.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw_rf.bin"
+		.bt_adid       = "aic/sdio/fw_adid.bin",
+		.bt_patch      = "aic/sdio/fw_patch.bin",
+		.bt_table      = "aic/sdio/fw_patch_table.bin",
+		.wl_fw         = "aic/sdio/fmacfw_rf.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u03[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw.bin",
-		.wl_table      = "aic/fmacfw_patch.bin"
+		.bt_adid       = "aic/sdio/fw_adid_u03.bin",
+		.bt_patch      = "aic/sdio/fw_patch_u03.bin",
+		.bt_table      = "aic/sdio/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/sdio/fmacfw.bin",
+		.wl_table      = "aic/sdio/fmacfw_patch.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw_rf.bin"
+		.bt_adid       = "aic/sdio/fw_adid_u03.bin",
+		.bt_patch      = "aic/sdio/fw_patch_u03.bin",
+		.bt_table      = "aic/sdio/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/sdio/fmacfw_rf.bin"
 	},
 };
 
@@ -218,36 +213,36 @@ static const struct aicbsp_firmware fw_u03[] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw_usb.bin"
+		.bt_adid       = "aic/usb/fw_adid.bin",
+		.bt_patch      = "aic/usb/fw_patch.bin",
+		.bt_table      = "aic/usb/fw_patch_table.bin",
+		.wl_fw         = "aic/usb/fmacfw.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/usb/fw_adid.bin",
+		.bt_patch      = "aic/usb/fw_patch.bin",
+		.bt_table      = "aic/usb/fw_patch_table.bin",
+		.wl_fw         = "aic/usb/fmacfw_rf.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u03[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw_usb.bin"
+		.bt_adid       = "aic/usb/fw_adid_u03.bin",
+		.bt_patch      = "aic/usb/fw_patch_u03.bin",
+		.bt_table      = "aic/usb/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/usb/fmacfw.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/usb/fw_adid_u03.bin",
+		.bt_patch      = "aic/usb/fw_patch_u03.bin",
+		.bt_table      = "aic/usb/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/usb/fmacfw_rf.bin"
 	},
 };
 #endif
@@ -443,12 +438,14 @@ static int aicwifi_init(struct priv_dev *aicdev)
 		return -1;
 	}
 
+#if defined(AICWF_SDIO_SUPPORT)
 	if (aicbsp_info.cpmode == AICBSP_CPMODE_WORK) {
 		if (rwnx_plat_bin_fw_upload_android(aicdev, RAM_FMAC_FW_PATCH_ADDR, aicbsp_firmware_list[aicbsp_info.cpmode].wl_table)) {
 			printk("download wifi fw patch fail\n");
 			return -1;
 		}
 	}
+#endif
 
 	if (aicwifi_patch_config(aicdev)) {
 		printk("aicwifi_patch_config fail\n");
@@ -500,22 +497,6 @@ static int aicbsp_system_config(struct priv_dev *aicdev)
 	return 0;
 }
 
-int aicbsp_8800d_system_reboot(struct priv_dev *aicdev)
-{
-	int syscfg_num;
-	int ret, cnt;
-
-	syscfg_num = sizeof(sys_reboot_tbl) / sizeof(u32) / 2;
-	for (cnt = 0; cnt < syscfg_num; cnt++) {
-		ret = rwnx_send_dbg_mem_write_req(aicdev, sys_reboot_tbl[cnt][0], sys_reboot_tbl[cnt][1]);
-		if (ret) {
-			printk("%x write fail: %d\n", sys_reboot_tbl[cnt][0], ret);
-			return ret;
-		}
-	}
-	return 0;
-}
-
 int aicbsp_8800d_fw_init(struct priv_dev *aicdev)
 {
 	const u32 mem_addr = 0x40500000;
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
index ba8c63186633..79113ce97ca9 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
@@ -16,11 +16,7 @@
 #include "aic_bsp_driver.h"
 #include <linux/mmc/sdio_func.h>
 
-#ifdef CONFIG_AIC_INTF_SDIO
 #define RAM_FMAC_FW_ADDR                    0x00120000
-#else
-#define RAM_FMAC_FW_ADDR                    0x00110000
-#endif
 #define FW_RAM_ADID_BASE_ADDR_8800D80       0x002017E0
 #define FW_RAM_PATCH_BASE_ADDR_8800D80      0x0020B2B0
 #define FW_RAM_ADID_BASE_ADDR_8800D80_U02   0x00201940
@@ -62,33 +58,56 @@ static u32 adaptivity_patch_tbl_8800d80[][2] = {
 	{0x0168, 0x00010000}, //tx_adaptivity_en
 };
 
+static u32 rf_tbl_masked[][3] = {
+/*
+	{0x40344058, 0x00800000, 0x00000000},// pll trx
+*/
+};
 #elif defined(AICWF_USB_SUPPORT)
+#define USER_PWROFST_COVER_CALIB_FLAG	0x01U
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+#define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
+
+#define CFG_PWROFST_COVER_CALIB     1
+#define CFG_USER_CHAN_MAX_TXPWR_EN  0
+#define CFG_USER_TX_USE_ANA_F       0
+
+#define CFG_USER_EXT_FLAGS_EN   (CFG_PWROFST_COVER_CALIB || CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
 
 static u32 patch_tbl[][2] = {
+	{0x00b4, 0xf3010001},
+	{0x0170, 0x00010001},//rx aggr counter
+
+	#if CFG_USER_EXT_FLAGS_EN
+	{0x0188, 0x00000000
+	#if CFG_PWROFST_COVER_CALIB
+	| USER_PWROFST_COVER_CALIB_FLAG
+	#endif
+		#if CFG_USER_CHAN_MAX_TXPWR_EN
+		| USER_CHAN_MAX_TXPWR_EN_FLAG
+		#endif
+		#if CFG_USER_TX_USE_ANA_F
+		| USER_TX_USE_ANA_F_FLAG
+		#endif
+	}, // user_ext_flags
+	#endif
 };
 
 static u32 aicbsp_syscfg_tbl[][2] = {
-	// Common Settings
-	{0x40500014, 0x00000101}, // 1)
-	{0x40500018, 0x0000010d}, // 2)
-	{0x40500004, 0x00000010}, // 3) the order should not be changed
-	// CONFIG_PMIC_SETTING
-	{0x50000000, 0x03220204}, // 2) pmic interface init
-	{0x50019150, 0x00000002},
-	{0x50017008, 0x00000000}, // 4) stop wdg
-
-	// U02 bootrom only
-	{0x40040000, 0x00001AC8}, // 1) fix panic
-	{0x40040084, 0x00011580},
-	{0x40040080, 0x00000001},
-	{0x40100058, 0x00000000},
+//#ifdef CONFIG_PMIC_SETTING
+//	{0x70001408, 0x00000000}, // stop wdg
+//#endif /* CONFIG_PMIC_SETTING */
 };
 
 //adap test
 static u32 adaptivity_patch_tbl_8800d80[][2] = {
 	{0x000C, 0x0000320A}, //linkloss_thd
 	{0x009C, 0x00000000}, //ac_param_conf
-	{0x0154, 0x00010000}, //tx_adaptivity_en
+	{0x0168, 0x00010000}, //tx_adaptivity_en
+};
+
+static u32 rf_tbl_masked[][3] = {
+	{0x40344058, 0x00800000, 0x00000000},// pll trx
 };
 #endif
 
@@ -98,12 +117,6 @@ static __attribute__((unused)) u32 syscfg_tbl_masked[][3] = {
 */
 };
 
-static u32 rf_tbl_masked[][3] = {
-/*
-	{0x40344058, 0x00800000, 0x00000000},// pll trx
-*/
-};
-
 #ifdef CONFIG_OOB
 // for 8800d40/d80     map data1 isr to gpiob1
 u32 gpio_cfg_tbl_8800d40d80[][2] = {
@@ -120,92 +133,110 @@ u32 gpio_cfg_tbl_8800d40d80[][2] = {
 static const struct aicbsp_firmware fw_u01[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u01)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80.bin",
-		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/fmacfw_8800d80.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u01)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80.bin",
-		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/lmacfw_rf_8800d80.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80_u02.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/fmacfw_8800d80_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80_u02.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_h_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80_h_u02.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/fmacfw_8800d80_h_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80_u02.bin"
+		.bt_adid       = "aic/sdio/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/sdio/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
 #elif defined(AICWF_USB_SUPPORT)
 
+static const struct aicbsp_firmware fw_u01[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(usb u01)",
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/usb/aic8800d80/fmacfw_8800d80.bin"
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(usb u01)",
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/usb/aic8800d80/lmacfw_rf_8800d80.bin"
+	},
+};
+
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw_usb.bin"
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/usb/aic8800d80/fmacfw_8800d80_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u02)",
-		.bt_adid       = "aic/fw_adid.bin",
-		.bt_patch      = "aic/fw_patch.bin",
-		.bt_table      = "aic/fw_patch_table.bin",
-		.wl_fw         = "aic/fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/usb/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
-static const struct aicbsp_firmware fw_u03[] = {
+static const struct aicbsp_firmware fw_h_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
-		.desc          = "normal work mode(usb u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw_usb.bin"
+		.desc          = "normal work mode(usb u02)",
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/usb/aic8800d80/fmacfw_8800d80_h_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
-		.desc          = "rf test mode(usb u03/u04)",
-		.bt_adid       = "aic/fw_adid_u03.bin",
-		.bt_patch      = "aic/fw_patch_u03.bin",
-		.bt_table      = "aic/fw_patch_table_u03.bin",
-		.wl_fw         = "aic/fmacfw_rf_usb.bin"
+		.desc          = "rf test mode(usb u02)",
+		.bt_adid       = "aic/usb/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/usb/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/usb/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/usb/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 #endif
@@ -303,7 +334,6 @@ static int aicwifi_sys_config(struct priv_dev *aicdev)
 	}
 #endif
 
-#ifdef AICWF_SDIO_SUPPORT
 	syscfg_num = sizeof(syscfg_tbl_masked) / sizeof(u32) / 3;
 	for (cnt = 0; cnt < syscfg_num; cnt++) {
 		ret = rwnx_send_dbg_mem_mask_write_req(aicdev,
@@ -313,7 +343,6 @@ static int aicwifi_sys_config(struct priv_dev *aicdev)
 			return ret;
 		}
 	}
-#endif
 
 	syscfg_num = sizeof(rf_tbl_masked) / sizeof(u32) / 3;
 	for (cnt = 0; cnt < syscfg_num; cnt++) {
@@ -524,14 +553,8 @@ int aicbsp_8800d80_fw_init(struct priv_dev *aicdev)
 	const u32 mem_addr = 0x40500000;
 	struct dbg_mem_read_cfm rd_mem_addr_cfm;
 
-	uint8_t binding_status;
-	uint8_t dout[16];
 #ifdef AICWF_SDIO_SUPPORT
 	int ret = 0;
-#endif
-	need_binding_verify = false;
-
-#ifdef AICWF_SDIO_SUPPORT
 	if (rwnx_send_dbg_mem_write_req(aicdev, 0x40500058, 0x40))
 		return -1;
 	sdio_claim_host(aicdev->func[0]);
@@ -565,7 +588,6 @@ int aicbsp_8800d80_fw_init(struct priv_dev *aicdev)
 
 	printk("aicbsp: %s, rev id: 0x%x, subrev id: 0x%x, is_chip_id_h: %d\n", __func__, aicbsp_info.chipinfo->rev, aicbsp_info.chipinfo->subrev, aicbsp_info.chipinfo->is_chip_id_h);
 
-#if defined(AICWF_SDIO_SUPPORT)
 	if (aicbsp_info.chipinfo->is_chip_id_h) {
 		aicbsp_firmware_list = fw_h_u02;
 	} else {
@@ -574,12 +596,6 @@ int aicbsp_8800d80_fw_init(struct priv_dev *aicdev)
 		else if (aicbsp_info.chipinfo->rev == CHIP_REV_ID_U02 || aicbsp_info.chipinfo->rev == CHIP_REV_ID_U03)
 			aicbsp_firmware_list = fw_u02;
 	}
-#elif defined(AICWF_USB_SUPPORT)
-	if (aicbsp_info.chipinfo->rev == CHIP_REV_ID_U02)
-		 aicbsp_firmware_list = fw_u02;
-	else if (aicbsp_info.chipinfo->rev == CHIP_REV_ID_U03)
-		aicbsp_firmware_list = fw_u03;
-#endif
 
 	if (aicbsp_system_config(aicdev))
 		return -1;
@@ -590,36 +606,6 @@ int aicbsp_8800d80_fw_init(struct priv_dev *aicdev)
 	if (aicwifi_init(aicdev))
 		return -1;
 
-	if (need_binding_verify) {
-		printk("aicbsp: crypto data %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
-						binding_enc_data[0],  binding_enc_data[1],  binding_enc_data[2],  binding_enc_data[3],
-						binding_enc_data[4],  binding_enc_data[5],  binding_enc_data[6],  binding_enc_data[7],
-						binding_enc_data[8],  binding_enc_data[9],  binding_enc_data[10], binding_enc_data[11],
-						binding_enc_data[12], binding_enc_data[13], binding_enc_data[14], binding_enc_data[15]);
-
-		/* calculate verify data from crypto data */
-		if (wcn_bind_verify_calculate_verify_data(binding_enc_data, dout)) {
-			pr_err("aicbsp: %s, binding encrypt data incorrect\n", __func__);
-			return -1;
-		}
-
-		printk("aicbsp: verify data %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
-						dout[0],  dout[1],  dout[2],  dout[3],
-						dout[4],  dout[5],  dout[6],  dout[7],
-						dout[8],  dout[9],  dout[10], dout[11],
-						dout[12], dout[13], dout[14], dout[15]);
-
-		if (rwnx_send_dbg_binding_req(aicdev, dout, &binding_status)) {
-			pr_err("aicbsp: %s, send binding request failn", __func__);
-			return -1;
-		}
-
-		if (binding_status) {
-			pr_err("aicbsp: %s, binding verify fail\n", __func__);
-			return -1;
-		}
-	}
-
 #ifdef AICWF_SDIO_SUPPORT
 #if defined(CONFIG_SDIO_PWRCTRL)
 	if (aicwf_sdio_writeb(aicdev->func[0], aicdev->sdio_reg.wakeup_reg, 4)) {
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
index 13e74d4a4ee4..f9c6c08df251 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
@@ -481,23 +481,24 @@ static u32 patch_tbl_rf_func[][2] = {
 	{0x00110bf0, 0x00180001},
 };
 
+#if defined(AICWF_SDIO_SUPPORT)
 static const struct aicbsp_firmware fw_u01[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u01)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc.bin",
-		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc.bin",
-		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/fmacfw_patch_8800dc.bin",
+		.wl_table      = "aic/sdio/aic8800dc/fmacfw_patch_tbl_8800dc.bin",
 		.wl_calib      = NULL,
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u01)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc.bin",
-		.wl_fw         = "aic/aic8800dc/fmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/fmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
 		.wl_calib      = NULL,
 	},
@@ -506,47 +507,116 @@ static const struct aicbsp_firmware fw_u01[] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02.bin",
-		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc_u02.bin",
-		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc_u02.bin",
-		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_u02.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/fmacfw_patch_8800dc_u02.bin",
+		.wl_table      = "aic/sdio/aic8800dc/fmacfw_patch_tbl_8800dc_u02.bin",
+		.wl_calib      = "aic/sdio/aic8800dc/fmacfw_calib_8800dc_u02.bin",
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02.bin",
-		.wl_fw         = "aic/aic8800dc/lmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/lmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
-		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_u02.bin",
+		.wl_calib      = "aic/sdio/aic8800dc/fmacfw_calib_8800dc_u02.bin",
 	},
 };
 
 static const struct aicbsp_firmware fw_h_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio h u02)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02h.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02h.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02h.bin",
-		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc_h_u02.bin",
-		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc_h_u02.bin",
-		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/fmacfw_patch_8800dc_h_u02.bin",
+		.wl_table      = "aic/sdio/aic8800dc/fmacfw_patch_tbl_8800dc_h_u02.bin",
+		.wl_calib      = "aic/sdio/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio h u02)",
-		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02h.bin",
-		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02h.bin",
-		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02h.bin",
-		.wl_fw         = "aic/aic8800dc/lmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/sdio/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "aic/sdio/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "aic/sdio/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "aic/sdio/aic8800dc/lmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
-		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+		.wl_calib      = "aic/sdio/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
 	},
 };
 
+#elif defined(AICWF_USB_SUPPORT)
+static const struct aicbsp_firmware fw_u01[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(usb u01)",
+		.bt_adid       = "aic/usb/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/usb/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/usb/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/usb/aic8800dc/fmacfw_patch_8800dc.bin",
+		.wl_table      = "aic/usb/aic8800dc/fmacfw_patch_tbl_8800dc.bin",
+		.wl_calib      = NULL,
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(usb u01)",
+		.bt_adid       = "aic/usb/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/usb/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/usb/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/usb/aic8800dc/fmacfw_rf_8800dc.bin",
+		.wl_table      = NULL,
+		.wl_calib      = NULL,
+	},
+};
+
+static const struct aicbsp_firmware fw_u02[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(usb u02)",
+		.bt_adid       = "aic/usb/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/usb/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/usb/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/usb/aic8800dc/fmacfw_patch_8800dc_u02.bin",
+		.wl_table      = "aic/usb/aic8800dc/fmacfw_patch_tbl_8800dc_u02.bin",
+		.wl_calib      = "aic/usb/aic8800dc/fmacfw_calib_8800dc_u02.bin",
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(usb u02)",
+		.bt_adid       = "aic/usb/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/usb/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/usb/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/usb/aic8800dc/lmacfw_rf_8800dc.bin",
+		.wl_table      = NULL,
+		.wl_calib      = "aic/usb/aic8800dc/fmacfw_calib_8800dc_u02.bin",
+	},
+};
+
+static const struct aicbsp_firmware fw_h_u02[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(usb h u02)",
+		.bt_adid       = "usb/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "usb/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "usb/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "usb/aic8800dc/fmacfw_patch_8800dc_h_u02.bin",
+		.wl_table      = "usb/aic8800dc/fmacfw_patch_tbl_8800dc_h_u02.bin",
+		.wl_calib      = "usb/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(usb h u02)",
+		.bt_adid       = "usb/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "usb/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "usb/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "usb/aic8800dc/lmacfw_rf_8800dc.bin",
+		.wl_table      = NULL,
+		.wl_calib      = "usb/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+	},
+};
+
+#endif
+
 static int aic8800dc_wifi_patch_table_load(struct priv_dev *aicdev, const char *filename)
 {
 	unsigned int i = 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
index 9eb6f91d5493..23d32165415e 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
@@ -16,6 +16,13 @@
 #include "aicusb.h"
 #include "aic_bsp_driver.h"
 
+#ifdef AICWF_USB_SUPPORT
+static u32 sys_reboot_tbl[][2] = {
+	{0x50017000, 0x0001ffff},
+	{0x50017008, 0x00000002},
+};
+#endif
+
 static void rwnx_set_cmd_tx(void *dev, struct lmac_msg *msg, uint len);
 u8 binding_enc_data[16];
 bool need_binding_verify;
@@ -697,14 +704,35 @@ int aicbt_patch_table_load(struct priv_dev *aicdev, struct aicbt_info_t *aicbt_i
 	return 0;
 }
 
+#ifdef AICWF_USB_SUPPORT
 int aicbsp_system_reboot(struct priv_dev *aicdev)
 {
-	if (aicbsp_info.chipinfo->chipid == PRODUCT_ID_AIC8800D)
-		return aicbsp_8800d_system_reboot(aicdev);
+	int syscfg_num;
+	int ret, cnt;
 
+	syscfg_num = sizeof(sys_reboot_tbl) / sizeof(u32) / 2;
+	for (cnt = 0; cnt < syscfg_num; cnt++) {
+		ret = rwnx_send_dbg_mem_write_req(aicdev, sys_reboot_tbl[cnt][0], sys_reboot_tbl[cnt][1]);
+		if (ret) {
+			printk("%x write fail: %d\n", sys_reboot_tbl[cnt][0], ret);
+			return ret;
+		}
+	}
 	return 0;
 }
 
+int rwnx_send_reboot(struct priv_dev *aicdev)
+{
+	int ret = 0;
+	u32 delay = 2 *1000; //1s
+
+	printk("%s enter \r\n", __func__);
+
+	ret = rwnx_send_dbg_start_app_req(aicdev, delay, HOST_START_APP_REBOOT, NULL);
+	return ret;
+}
+#endif
+
 int aicbsp_platform_init(struct priv_dev *aicdev)
 {
 	rwnx_cmd_mgr_init(&aicdev->cmd_mgr);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
index 81e6aea6c3cc..c49f44235d67 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
@@ -323,6 +323,7 @@ int  aicbsp_platform_init(struct priv_dev *aicdev);
 void aicbsp_platform_deinit(struct priv_dev *aicdev);
 int  aicbsp_driver_fw_init(struct priv_dev *aicdev);
 int  aicbsp_system_reboot(struct priv_dev *aicdev);
+int  rwnx_send_reboot(struct priv_dev *aicdev);
 int  aicbsp_device_init(void);
 void aicbsp_device_exit(void);
 
@@ -468,7 +469,6 @@ struct aicbsp_info_t {
 };
 
 int aicbsp_8800d_fw_init(struct priv_dev *aicdev);
-int aicbsp_8800d_system_reboot(struct priv_dev *aicdev);
 int aicbsp_8800dc_fw_init(struct priv_dev *aicdev);
 int aicbsp_8800d80_fw_init(struct priv_dev *aicdev);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
index d5693ef6fc06..e1fcae402822 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
@@ -33,9 +33,13 @@ enum chip_id {
 
 enum AIC_PRODUCT_ID {
 	PRODUCT_ID_AIC8800D = 0,
+	PRODUCT_ID_AIC8801,
 	PRODUCT_ID_AIC8800DC,
 	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80
+	PRODUCT_ID_AIC8800D80,
+	PRODUCT_ID_AIC8800D81,
+	PRODUCT_ID_AIC8800D80X2,
+	PRODUCT_ID_AIC8800D81X2,
 };
 
 enum aicbsp_cpmode_type {
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
index 9f5f4658892a..4f66121e91cb 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
@@ -21,7 +21,7 @@
 #define DRV_TYPE_NAME   "compatible(unknow)"
 #endif
 
-#define DRV_RELEASE_DATE "20240730"
+#define DRV_RELEASE_DATE "20240919"
 #define DRV_PATCH_LEVEL  "001"
 #define DRV_RELEASE_TAG  "aic-bsp-" DRV_TYPE_NAME "-" DRV_RELEASE_DATE "-" DRV_PATCH_LEVEL
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c
index c27480029b77..d2c3d41d7a8b 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c
@@ -49,7 +49,12 @@ void aicbsp_device_exit(void)
 }
 
 static struct device_match_entry aicdev_match_table[] = {
-	{0xa69c, 0x8800, PRODUCT_ID_AIC8800D,   "aic8800d",   0, 0}, // 8800d in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800,		PRODUCT_ID_AIC8800D,	"aic8800d",		0, 0}, // 8800d in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8801,		PRODUCT_ID_AIC8801,		"aic8801",		0, 0}, // 8801 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D80,	PRODUCT_ID_AIC8800D80,	"aic8800d80",	0, 0}, // 8800d80 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D81,	PRODUCT_ID_AIC8800D81,	"aic8800d81",	0, 0}, // 8800d81 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D40,	PRODUCT_ID_AIC8800D80,	"aic8800d40",	0, 0}, // 8800d40 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D41,	PRODUCT_ID_AIC8800D81,	"aic8800d41",	0, 0}, // 8800d41 in bootloader mode
 };
 
 static struct device_match_entry *aic_matched_ic;
@@ -69,7 +74,7 @@ void *aicbsp_get_drvdata(void *args)
 static int aicbsp_platform_power_on(void)
 {
 #ifdef CONFIG_PLATFORM_SPACEMIT
-	sunxi_wlan_set_power(1);
+	spacemit_wlan_set_power(1);
 	mdelay(50);
 #endif
 	return 0;
@@ -78,7 +83,7 @@ static int aicbsp_platform_power_on(void)
 static void aicbsp_platform_power_off(void)
 {
 #ifdef CONFIG_PLATFORM_SPACEMIT
-	sunxi_wlan_set_power(0);
+	spacemit_wlan_set_power(0);
 	mdelay(100);
 #endif
 	bsp_dbg("%s\n", __func__);
@@ -822,18 +827,28 @@ static int aicwf_parse_usb(struct priv_dev *aicdev, struct usb_interface *interf
 	}
 
 #ifdef CONFIG_USB_MSG_EP
+	if (aicdev->msg_out_pipe != 0 &&
+		(aicbsp_info.chipinfo->chipid == PRODUCT_ID_AIC8801 || aicbsp_info.chipinfo->chipid == PRODUCT_ID_AIC8800D81)){
+		printk("TX Msg Bulk EP found\n");
+		aicdev->use_msg_ep = 1;
+	} else {
+		aicdev->use_msg_ep = 0;
+	}
+#if 0
 	if (aicdev->msg_out_pipe == 0) {
 		bsp_err("No TX Msg (out) Bulk EP found\n");
 		aicdev->use_msg_ep = 0;
 	} else {
 		aicdev->use_msg_ep = 1;
 	}
+#endif
 #endif
 
-	if (usb->speed == USB_SPEED_HIGH)
-		bsp_dbg("Aic high speed USB device detected\n");
-	else
-		bsp_dbg("Aic full speed USB device detected\n");
+	printk("Aic %s speed USB device detected\n", 
+			(usb->speed == USB_SPEED_SUPER) ? "super" :
+			(usb->speed == USB_SPEED_HIGH)  ? "high"  :
+			(usb->speed == USB_SPEED_FULL)  ? "full"  :
+			(usb->speed == USB_SPEED_LOW)   ? "low"   : "NG");
 
 exit:
 	return ret;
@@ -863,6 +878,13 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 		id->bInterfaceSubClass,
 		id->bInterfaceProtocol);
 
+	if (fw_loaded == 1 && 
+		(id->idProduct == USB_DEVICE_ID_AIC_8801 || 
+		id->idProduct == USB_DEVICE_ID_AIC_8800D81 ||
+		id->idProduct == USB_DEVICE_ID_AIC_8800D41)) {
+		return -1;
+	}
+
 	aic_matched_ic = NULL;
 	for (i = 0; i < sizeof(aicdev_match_table) / sizeof(aicdev_match_table[0]); i++) {
 		if (id->idVendor == aicdev_match_table[i].vid && id->idProduct == aicdev_match_table[i].pid) {
@@ -941,8 +963,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 		goto out_free_bus;
 	}
 
-	if (fw_loaded == 0 && id->idProduct == USB_DEVICE_ID_AIC_8801) {
-		rwnx_send_dbg_start_app_req(aicdev, 2000, HOST_START_APP_REBOOT, NULL);
+	if (fw_loaded == 0 && (id->idProduct == USB_DEVICE_ID_AIC_8801 || id->idProduct == USB_DEVICE_ID_AIC_8800D81)) {
+		rwnx_send_reboot(aicdev);
 		goto out_free_bus;
 	}
 
@@ -1010,8 +1032,12 @@ static int aicwf_usb_reset_resume(struct usb_interface *intf)
 }
 
 static struct usb_device_id aicwf_usb_id_table[] = {
-	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800)},
 	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8801)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D80)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D81)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D40)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D41)},
 	{}
 };
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h
index 8f932be01e22..aca9bbf7f4bf 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h
@@ -19,9 +19,19 @@
 
 /* USB Device ID */
 #define USB_VENDOR_ID_AIC               0xA69C
-#define USB_DEVICE_ID_AIC               0x8800
+#define USB_VENDOR_ID_AIC_V2            0x368B
+
+#define USB_DEVICE_ID_AIC_8800          0x8800
 #define USB_DEVICE_ID_AIC_8801          0x8801
 
+#define USB_DEVICE_ID_AIC_8800D80       0x8D80
+#define USB_DEVICE_ID_AIC_8800D81       0x8D81
+#define USB_DEVICE_ID_AIC_8800D40       0x8D40
+#define USB_DEVICE_ID_AIC_8800D41       0x8D41
+
+#define USB_DEVICE_ID_AIC_8800D80X2     0x8D90
+#define USB_DEVICE_ID_AIC_8800D81X2     0x8D91
+
 #define AICWF_USB_RX_URBS               (20)
 #define AICWF_USB_TX_URBS               (100)
 #define AICWF_USB_TX_LOW_WATER          (AICWF_USB_TX_URBS/4)
@@ -33,7 +43,8 @@ typedef enum {
 	PRIV_TYPE_DATA         = 0X00,
 	PRIV_TYPE_CFG          = 0X10,
 	PRIV_TYPE_CFG_CMD_RSP  = 0X11,
-	PRIV_TYPE_CFG_DATA_CFM = 0X12
+	PRIV_TYPE_CFG_DATA_CFM = 0X12,
+	PRIV_TYPE_CFG_PRINT    = 0X13
 } priv_type;
 
 enum aicwf_usb_state {
@@ -91,6 +102,7 @@ struct priv_dev {
 
 	bool tbusy;
 	bool app_cmp;
+	u32 fw_version_uint;
 };
 
 void *aicbsp_get_drvdata(void *args);
diff --git a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c
index 6d6f00ab91c8..374e5f39f38c 100644
--- a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c
+++ b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c
@@ -39,7 +39,7 @@
 
 #define AICBT_RELEASE_NAME "202012_ANDROID"
 #define VERSION            "2.1.0"
-#define DRV_RELEASE_DATE   "20220429"
+#define DRV_RELEASE_DATE   "20240919"
 #define DRV_PATCH_LEVEL    "002"
 #define DRV_RELEASE_TAG    "aic-btusb-" DRV_RELEASE_DATE "-" DRV_PATCH_LEVEL
 
@@ -1398,7 +1398,10 @@ void firmware_info_destroy(struct usb_interface *intf)
 static struct usb_driver btusb_driver;
 
 static struct usb_device_id btusb_table[] = {
-	{USB_DEVICE_AND_INTERFACE_INFO(0xa69c, 0x8801, 0xe0, 0x01, 0x01)},
+	//{USB_DEVICE_AND_INTERFACE_INFO(0xa69c, 0x8801, 0xe0, 0x01, 0x01)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8801, 0xff, 0xff, 0xff)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D81, 0xff, 0xff, 0xff)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D41, 0xff, 0xff, 0xff)},
 	{}
 };
 
diff --git a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h
index 0a68808a9552..2d924ae2b7e3 100644
--- a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h
+++ b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h
@@ -49,6 +49,19 @@
 #include <net/bluetooth/hci.h>
 #endif
 
+#define USB_VENDOR_ID_AIC               0xA69C
+#define USB_VENDOR_ID_AIC_V2            0x368B
+
+#define USB_DEVICE_ID_AIC_8800          0x8800
+#define USB_DEVICE_ID_AIC_8801          0x8801
+
+#define USB_DEVICE_ID_AIC_8800D80       0x8D80
+#define USB_DEVICE_ID_AIC_8800D81       0x8D81
+#define USB_DEVICE_ID_AIC_8800D40       0x8D40
+#define USB_DEVICE_ID_AIC_8800D41       0x8D41
+
+#define USB_DEVICE_ID_AIC_8800D80X2     0x8D90
+#define USB_DEVICE_ID_AIC_8800D81X2     0x8D91
 
 /***********************************
 ** AicSemi - For aic_btusb driver **
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 48758485c267..9b575e28d56a 100755
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -52,9 +52,6 @@ CONFIG_RADAR_OR_IR_DETECT =n
 CONFIG_DOWNLOAD_FW =y
 CONFIG_RFTEST=y
 CONFIG_SDIO_PWRCTRL ?= y
-ifeq ($(CONFIG_USB_SUPPORT),y)
-CONFIG_USB_BT := y
-endif
 CONFIG_GKI_OPT_FEATURES ?= y
 CONFIG_WPA3_FOR_OLD_KERNEL ?= n
 CONFIG_SCHED_SCAN = n
@@ -89,6 +86,15 @@ CONFIG_RWNX_MON_DATA =y
 CONFIG_RWNX_SW_PROFILING ?= n
 CONFIG_RWNX_DBG ?= y
 
+# config for usb interface
+ifeq ($(CONFIG_USB_SUPPORT),y)
+CONFIG_USB_BT = y
+CONFIG_ALIGN_8BYTES = y
+CONFIG_USB_ALIGN_DATA = y
+CONFIG_USB_MSG_OUT_EP = y
+CONFIG_USB_MSG_IN_EP = y
+endif
+
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) := aic8800_fdrv.o
 aic8800_fdrv-y := \
 	rwnx_wakelock.o        \
@@ -228,4 +234,7 @@ ccflags-$(CONFIG_ARP_OFFLOAD) += -DAICWF_ARP_OFFLOAD
 ccflags-$(CONFIG_RADAR_DETECT) += -DRADAR_OR_IR_DETECT
 ccflags-$(CONFIG_DOWNLOAD_FW)  += -DCONFIG_DOWNLOAD_FW
 ccflags-$(CONFIG_USB_BT)  += -DCONFIG_USB_BT
-ccflags-$(CONFIG_USB_MSG_EP) += -DCONFIG_USB_MSG_EP
+ccflags-$(CONFIG_ALIGN_8BYTES)  += -DCONFIG_ALIGN_8BYTES
+ccflags-$(CONFIG_USB_MSG_OUT_EP) += -DCONFIG_USB_MSG_OUT_EP
+ccflags-$(CONFIG_USB_MSG_IN_EP) += -DCONFIG_USB_MSG_IN_EP
+ccflags-$(CONFIG_USB_ALIGN_DATA) += -DCONFIG_USB_ALIGN_DATA
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 604d87106258..81d58ddd9d09 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -380,7 +380,7 @@ static int aicwf_vendor_subcmd_get_feature_set(struct wiphy *wiphy, struct wirel
 	/*bit 21:WiFi mkeep_alive*/
 	feature |= WIFI_FEATURE_MKEEP_ALIVE;
 
-#ifdef AICWF_LATENCY_MODE
+#if defined(AICWF_LATENCY_MODE) && defined(AICWF_SDIO_SUPPORT)
 	feature |= WIFI_FEATURE_SET_LATENCY_MODE;
 #endif
 	if (nla_put_u32(reply, ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET, feature)) {
@@ -616,7 +616,7 @@ static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev
 	return ret;
 }
 
-#ifdef AICWF_LATENCY_MODE
+#if defined(AICWF_LATENCY_MODE) && defined(AICWF_SDIO_SUPPORT)
 static int aicwf_vendor_subcmd_set_latency_mode(struct wiphy *wiphy,
 	struct wireless_dev *wdev, const void *data, int len)
 {
@@ -897,7 +897,7 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		.maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
 #endif
 	},
-#ifdef AICWF_LATENCY_MODE
+#if defined(AICWF_LATENCY_MODE) && defined(AICWF_SDIO_SUPPORT)
 	{
 		{
 			.vendor_id = GOOGLE_OUI,
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
index 7d44a4093f9d..c70582e7ea00 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
@@ -1764,8 +1764,8 @@ void aicwf_sdio_func_deinit(struct aic_sdio_dev *sdiodev)
 	sdio_disable_func(sdiodev->func);
 	sdio_release_host(sdiodev->func);
 
-	if (sdiodev->rwnx_hw->chipid == PRODUCT_ID_AIC8800D || sdiodev->rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
-			sdiodev->rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
+	if (aicwf_chipid == PRODUCT_ID_AIC8800D || aicwf_chipid == PRODUCT_ID_AIC8800DC ||
+			aicwf_chipid == PRODUCT_ID_AIC8800DW) {
 		sdio_claim_host(sdiodev->func2);
 		sdio_disable_func(sdiodev->func2);
 		sdio_release_host(sdiodev->func2);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 808e4ae846a8..bcb424a72010 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -25,8 +25,36 @@
 #ifdef AICWF_SDIO_SUPPORT
 #include "sdio_host.h"
 #endif
+#ifdef AICWF_USB_SUPPORT
+extern bool aicwf_usb_rx_aggr;
+#endif
 #include "aic_bsp_export.h"
 
+#ifdef CONFIG_ALIGN_8BYTES
+void rwnx_skb_align_8bytes(struct sk_buff *skb){
+
+	int align __maybe_unused;
+	u8 *data;
+	size_t len = 0;
+
+	align = ((unsigned long)(skb->data + 14)) & 7;
+	if (align) {
+		if (WARN_ON(skb_headroom(skb) < 7)) {
+			dev_kfree_skb(skb);
+			skb = NULL;
+		} else {
+			//printk("AIDEN align1:%d rx_skb->data + 14:%p\r\n", align, skb->data + 14);
+			data = skb->data;
+			len = skb_headlen(skb);
+			skb->data -= align;
+			memmove(skb->data, data, len);
+			skb_set_tail_pointer(skb, len);
+			//printk("AIDEN align2:%d rx_skb->data + 14:%p\r\n", align, skb->data + 14);
+		}
+	}
+}
+#endif
+
 int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 {
 	int ret = 0;
@@ -48,6 +76,12 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 
 	init_completion(&bus_if->bustx_trgg);
 	init_completion(&bus_if->busrx_trgg);
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(bus_if->bus_priv.usb->msg_in_pipe) {
+		init_completion(&bus_if->msg_busrx_trgg);
+	}
+#endif
+
 #ifdef AICWF_SDIO_SUPPORT
 	bus_if->bustx_thread = kthread_run(sdio_bustx_thread, (void *)bus_if, "aicwf_bustx_thread");
 	bus_if->busrx_thread = kthread_run(sdio_busrx_thread, (void *)bus_if->bus_priv.sdio->rx_priv, "aicwf_busrx_thread");
@@ -57,6 +91,13 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 	bus_if->busrx_thread = kthread_run(usb_busrx_thread, (void *)bus_if->bus_priv.usb->rx_priv, "aicwf_busrx_thread");
 #endif
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(bus_if->bus_priv.usb->msg_in_pipe)
+	{
+		bus_if->msg_busrx_thread = kthread_run(usb_msg_busrx_thread, (void *)bus_if->bus_priv.usb->rx_priv, "aicwf_msg_busrx_thread");
+	}
+#endif
+
 	if (IS_ERR(bus_if->bustx_thread)) {
 		errnum = PTR_ERR(bus_if->bustx_thread);
 		bus_if->bustx_thread  = NULL;
@@ -71,12 +112,23 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 		goto fail;
 	}
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(bus_if->bus_priv.usb->msg_in_pipe){
+		if (IS_ERR(bus_if->msg_busrx_thread)) {
+			bus_if->msg_busrx_thread  = NULL;
+			txrx_err("aicwf_msg_busrx_thread run fail\n");
+			goto fail;
+		}
+	}
+#endif
+
 	return ret;
 fail:
 	aicwf_bus_deinit(dev);
 
 	return ret;
 }
+void aicwf_usb_cancel_all_urbs(struct aic_usb_dev *usb_dev);
 
 void aicwf_bus_deinit(struct device *dev)
 {
@@ -98,8 +150,12 @@ void aicwf_bus_deinit(struct device *dev)
 
 #ifdef AICWF_USB_SUPPORT
 	usb = bus_if->bus_priv.usb;
-	if (g_rwnx_plat->enabled)
+	aicwf_usb_cancel_all_urbs(usb);
+	if(g_rwnx_plat && g_rwnx_plat->enabled){
 		rwnx_platform_deinit(usb->rwnx_hw);
+	}else{
+		txrx_info("%s g_rwnx_plat->enabled is false\r\n", __func__);
+	}
 #endif
 #ifdef AICWF_SDIO_SUPPORT
 	sdiodev = bus_if->bus_priv.sdio;
@@ -114,10 +170,17 @@ void aicwf_bus_deinit(struct device *dev)
 	}
 
 	if (!IS_ERR_OR_NULL(bus_if->bustx_thread)) {
+		txrx_info("%s stop to bustx_thread!! \r\n", __func__);
 		complete_all(&bus_if->bustx_trgg);
 		kthread_stop(bus_if->bustx_thread);
 		bus_if->bustx_thread = NULL;
 	}
+#ifdef AICWF_USB_SUPPORT
+	if (usb->rx_priv)
+		aicwf_rx_deinit(usb->rx_priv);
+
+	rwnx_cmd_mgr_deinit(&usb->cmd_mgr);
+#endif
 	printk("exit %s\n", __func__);
 }
 
@@ -128,10 +191,17 @@ void aicwf_frame_tx(void *dev, struct sk_buff *skb)
 	aicwf_bus_txdata(sdiodev->bus_if, skb);
 #else
 	struct aic_usb_dev *usbdev = (struct aic_usb_dev *)dev;
+	struct rwnx_txhdr *txhdr = NULL;
+	unsigned long flags;
 
 	if (!usbdev->state) {
 		txrx_err("down\n");
+		spin_lock_irqsave(&usbdev->tx_flow_lock, flags);
+		if(!usbdev->tbusy)
 		aicwf_usb_tx_flowctrl(usbdev->rwnx_hw, true);
+		spin_unlock_irqrestore(&usbdev->tx_flow_lock, flags);
+		txhdr = (struct rwnx_txhdr *)skb->data;
+		kmem_cache_free(usbdev->rwnx_hw->sw_txhdr_cache, txhdr->sw_hdr);
 		dev_kfree_skb(skb);
 		return;
 	}
@@ -182,13 +252,12 @@ void aicwf_tx_deinit(struct aicwf_tx_priv *tx_priv)
 	}
 }
 
-#ifdef AICWF_SDIO_SUPPORT
 static bool aicwf_another_ptk(struct sk_buff *skb)
 {
 	u8 *data;
 	u16 aggr_len = 0;
 
-	if (skb->data == NULL || skb->len == 0) {
+	if (skb->data == NULL || skb->len < 2) {
 		return false;
 	}
 	data = skb->data;
@@ -199,7 +268,6 @@ static bool aicwf_another_ptk(struct sk_buff *skb)
 
 	return true;
 }
-#endif
 
 static void aicwf_count_rx_tp(struct aicwf_rx_priv *rx_priv, int len)
 {
@@ -236,6 +304,7 @@ static void aicwf_count_rx_tp(struct aicwf_rx_priv *rx_priv, int len)
 	}
 }
 
+extern bool rx_urb_sched;
 int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 {
 #ifdef AICWF_SDIO_SUPPORT
@@ -344,15 +413,175 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	u8 *data = NULL;
 	u8_l *msg = NULL;
 
-	while (1) {
-		spin_lock_irqsave(&rx_priv->rxqlock, flags);
-		if (aicwf_is_framequeue_empty(&rx_priv->rxq)) {
-			usb_info("no more rxdata\n");
+	if(aicwf_usb_rx_aggr){
+		while (1) {
+			spin_lock_irqsave(&rx_priv->rxqlock, flags);
+			if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
+				usb_info("no more rxdata\n");
+				spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+				break;
+			}
+			skb = aicwf_frame_dequeue(&rx_priv->rxq);
 			spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+
+			if (skb == NULL) {
+				txrx_err("skb_error\r\n");
+				ASSERT_ERR(1);
+				break;
+			}
+			while(aicwf_another_ptk(skb)) {
+				data = skb->data;
+				pkt_len = (*skb->data | (*(skb->data + 1) << 8));
+				//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+
+				if (pkt_len > 1600) {
+					txrx_err("%s pkt_len > 1600 \r\n", __func__);
+					//dev_kfree_skb(skb);
+					//atomic_dec(&rx_priv->rx_cnt);
+					//continue;
+					break;
+				}
+
+				if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+					aggr_len = pkt_len + RX_HWHRD_LEN;
+					adjust_len = aggr_len;
+					skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);//8 is for ccmp mic or wep icv
+					if(skb_inblock == NULL){
+						txrx_err("no more space! skip!\n");
+						skb_pull(skb, adjust_len);
+						continue;
+					}
+
+					skb_put(skb_inblock, aggr_len);
+					memcpy(skb_inblock->data, data, aggr_len);
+					aicwf_count_rx_tp(rx_priv, aggr_len);
+					rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
+
+					///TODO: here need to add rx data process
+
+					skb_pull(skb, adjust_len);
+
+				}
+				else { //  type : config
+					aggr_len = pkt_len;
+					if (aggr_len & (RX_ALIGNMENT - 1))
+						adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+					else
+						adjust_len = aggr_len;
+
+					msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
+					if(msg == NULL){
+						txrx_err("no more space for msg!\n");
+						aicwf_dev_skb_free(skb);
+						return -EBADE;
+					}
+					memcpy(msg, data, aggr_len + 4);
+
+					if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+						rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+
+					if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+						aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+
+					if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+						rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+
+
+					skb_pull(skb, adjust_len+4);
+					kfree(msg);
+
+				}
+			}
+			dev_kfree_skb(skb);
+			atomic_dec(&rx_priv->rx_cnt);
+		}
+	}else{
+		while (1) {
+			spin_lock_irqsave(&rx_priv->rxqlock, flags);
+			if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
+				usb_info("no more rxdata\n");
+				spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+				break;
+			}
+			skb = aicwf_frame_dequeue(&rx_priv->rxq);
+			spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+
+			if (skb == NULL) {
+				txrx_err("skb_error\r\n");
+				ASSERT_ERR(1);
+				break;
+			}
+			data = skb->data;
+			pkt_len = (*skb->data | (*(skb->data + 1) << 8));
+			//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+			if (pkt_len > 1600) {
+				dev_kfree_skb(skb);
+				atomic_dec(&rx_priv->rx_cnt);
+					continue;
+			}
+#endif
+
+			if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+				rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb, (void *)rx_priv);
+			}
+			else { //  type : config
+				aggr_len = pkt_len;
+				if (aggr_len & (RX_ALIGNMENT - 1))
+					adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+				else
+					adjust_len = aggr_len;
+
+				msg = kmalloc(aggr_len+4, GFP_KERNEL);
+				if(msg == NULL){
+					txrx_err("no more space for msg!\n");
+					aicwf_dev_skb_free(skb);
+					return -EBADE;
+				}
+				memcpy(msg, data, aggr_len + 4);
+
+				if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+					rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+
+				if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+					aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+
+				if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+					rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+
+				skb_pull(skb, adjust_len+4);
+				kfree(msg);
+				dev_kfree_skb(skb);
+			}
+			atomic_dec(&rx_priv->rx_cnt);
+		}
+	}
+
+	return ret;
+#endif //AICWF_SDIO_SUPPORT
+}
+
+#ifdef CONFIG_USB_MSG_IN_EP
+int aicwf_process_msg_rxframes(struct aicwf_rx_priv *rx_priv)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+	struct sk_buff *skb = NULL; /* Packet for event or data frames */
+	u16 pkt_len = 0;
+	struct sk_buff *skb_inblock = NULL;
+	u16 aggr_len = 0, adjust_len = 0;
+	u8 *data = NULL;
+	u8_l *msg = NULL;
+
+	while (1) {
+		spin_lock_irqsave(&rx_priv->msg_rxqlock, flags);
+		if(aicwf_is_framequeue_empty(&rx_priv->msg_rxq)) {
+			txrx_info("no more rxmsg\n");
+			spin_unlock_irqrestore(&rx_priv->msg_rxqlock,flags);
 			break;
 		}
-		skb = aicwf_frame_dequeue(&rx_priv->rxq);
-		spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+		skb = aicwf_frame_dequeue(&rx_priv->msg_rxq);
+		spin_unlock_irqrestore(&rx_priv->msg_rxqlock, flags);
 		if (skb == NULL) {
 			txrx_err("skb_error\r\n");
 			break;
@@ -360,13 +589,15 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 		data = skb->data;
 		pkt_len = (*skb->data | (*(skb->data + 1) << 8));
 		//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+	#if 0 //amsdu > 1600
 		if (pkt_len > 1600) {
 			dev_kfree_skb(skb);
 			atomic_dec(&rx_priv->rx_cnt);
-				continue;
+			continue;
 		}
+	#endif
 
-		if ((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+		if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
 			aggr_len = pkt_len + RX_HWHRD_LEN;
 			if (aggr_len & (RX_ALIGNMENT - 1))
 				adjust_len = roundup(aggr_len, RX_ALIGNMENT);
@@ -374,7 +605,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 				adjust_len = aggr_len;
 
 			skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);//8 is for ccmp mic or wep icv
-			if (skb_inblock == NULL) {
+			if(skb_inblock == NULL){
 				txrx_err("no more space! skip!\n");
 				skb_pull(skb, adjust_len);
 				continue;
@@ -382,12 +613,15 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 
 			skb_put(skb_inblock, aggr_len);
 			memcpy(skb_inblock->data, data, aggr_len);
-			aicwf_count_rx_tp(rx_priv, aggr_len);
+	#if 0//AIDEN
+			rwnx_frame_parser((char*)__func__, skb_inblock->data + 60, aggr_len - 60);
+	#endif
 			rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
 			///TODO: here need to add rx data process
 
 			skb_pull(skb, adjust_len);
-		} else { //  type : config
+		}
+		else { //  type : config
 			aggr_len = pkt_len;
 			if (aggr_len & (RX_ALIGNMENT - 1))
 				adjust_len = roundup(aggr_len, RX_ALIGNMENT);
@@ -395,29 +629,36 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 				adjust_len = aggr_len;
 
 			msg = kmalloc(aggr_len+4, GFP_KERNEL);
-			if (msg == NULL) {
+			if(msg == NULL){
 				txrx_err("no more space for msg!\n");
 				aicwf_dev_skb_free(skb);
 				return -EBADE;
 			}
 			memcpy(msg, data, aggr_len + 4);
-			if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP)
+
+			if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
 				rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
 
-			if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+			if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
 				aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
-			skb_pull(skb, adjust_len + 4);
+
+			if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+				rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+
+
+			skb_pull(skb, adjust_len+4);
 			kfree(msg);
 		}
 
 		dev_kfree_skb(skb);
-		atomic_dec(&rx_priv->rx_cnt);
+		atomic_dec(&rx_priv->msg_rx_cnt);
 	}
 
 	return ret;
-#endif //AICWF_SDIO_SUPPORT
 }
+#endif
 
+#ifdef AICWF_RX_REORDER
 static struct recv_msdu *aicwf_rxframe_queue_init(struct list_head *q, int qsize)
 {
 	int i;
@@ -436,7 +677,7 @@ static struct recv_msdu *aicwf_rxframe_queue_init(struct list_head *q, int qsize
 
 	return reqs;
 }
-
+#endif
 struct aicwf_rx_priv *aicwf_rx_init(void *arg)
 {
 	struct aicwf_rx_priv *rx_priv;
@@ -454,6 +695,14 @@ struct aicwf_rx_priv *aicwf_rx_init(void *arg)
 	spin_lock_init(&rx_priv->rxqlock);
 	atomic_set(&rx_priv->rx_cnt, 0);
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(rx_priv->usbdev->msg_in_pipe){
+		aicwf_frame_queue_init(&rx_priv->msg_rxq, 1, MAX_RXQLEN);
+		spin_lock_init(&rx_priv->msg_rxqlock);
+		atomic_set(&rx_priv->msg_rx_cnt, 0);
+	}
+#endif
+
 #ifdef AICWF_RX_REORDER
 	INIT_LIST_HEAD(&rx_priv->rxframes_freequeue);
 	spin_lock_init(&rx_priv->freeq_lock);
@@ -470,7 +719,7 @@ struct aicwf_rx_priv *aicwf_rx_init(void *arg)
 	return rx_priv;
 }
 
-
+#ifdef AICWF_RX_REORDER
 static void aicwf_recvframe_queue_deinit(struct list_head *q)
 {
 	struct recv_msdu *req, *next;
@@ -479,6 +728,7 @@ static void aicwf_recvframe_queue_deinit(struct list_head *q)
 		list_del_init(&req->rxframe_list);
 	}
 }
+#endif
 
 void aicwf_rx_deinit(struct aicwf_rx_priv *rx_priv)
 {
@@ -493,9 +743,8 @@ void aicwf_rx_deinit(struct aicwf_rx_priv *rx_priv)
 	}
 	spin_unlock_bh(&rx_priv->stas_reord_lock);
 #endif
-
-#ifdef AICWF_SDIO_SUPPORT
 	txrx_dbg("sdio rx thread\n");
+#ifdef AICWF_SDIO_SUPPORT
 	if (!IS_ERR_OR_NULL(rx_priv->sdiodev->bus_if->busrx_thread)) {
 		complete_all(&rx_priv->sdiodev->bus_if->busrx_trgg);
 		kthread_stop(rx_priv->sdiodev->bus_if->busrx_thread);
@@ -509,6 +758,21 @@ void aicwf_rx_deinit(struct aicwf_rx_priv *rx_priv)
 		kthread_stop(rx_priv->usbdev->bus_if->busrx_thread);
 		rx_priv->usbdev->bus_if->busrx_thread = NULL;
 	}
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(rx_priv->usbdev->msg_in_pipe){
+		if (rx_priv->usbdev->bus_if->msg_busrx_thread) {
+			complete_all(&rx_priv->usbdev->bus_if->msg_busrx_trgg);
+			kthread_stop(rx_priv->usbdev->bus_if->msg_busrx_thread);
+			rx_priv->usbdev->bus_if->msg_busrx_thread = NULL;
+		}
+	}
+#endif
+#endif
+
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(rx_priv->usbdev->msg_in_pipe){
+		aicwf_frame_queue_flush(&rx_priv->msg_rxq);
+	}
 #endif
 
 	aicwf_frame_queue_flush(&rx_priv->rxq);
@@ -634,6 +898,7 @@ struct sk_buff *aicwf_frame_dequeue(struct frame_queue *pq)
 	return p;
 }
 
+#ifdef AICWF_SDIO_SUPPORT
 bool aicwf_frame_enq(struct device *dev, struct frame_queue *q, struct sk_buff *pkt, int prio)
 {
 	if (q->queuelist[prio].qlen < q->qmax && q->qcnt < q->qmax) {
@@ -642,3 +907,49 @@ bool aicwf_frame_enq(struct device *dev, struct frame_queue *q, struct sk_buff *
 	} else
 		return false;
 }
+#else
+static struct sk_buff *aicwf_skb_dequeue_tail(struct frame_queue *pq, int prio)
+{
+    struct sk_buff_head *q = &pq->queuelist[prio];
+    struct sk_buff *p = skb_dequeue_tail(q);
+
+    if (!p)
+        return NULL;
+
+    pq->qcnt--;
+
+    return p;
+}
+
+bool aicwf_frame_enq(struct device *dev, struct frame_queue *q, struct sk_buff *pkt, int prio)
+{
+    struct sk_buff *p = NULL;
+    int prio_modified = -1;
+
+    if (q->queuelist[prio].qlen < q->qmax && q->qcnt < q->qmax) {
+        aicwf_frame_queue_penq(q, prio, pkt);
+        return true;
+    }
+    if (q->queuelist[prio].qlen >= q->qmax) {
+        prio_modified = prio;
+    } else if (q->qcnt >= q->qmax) {
+        p = aicwf_frame_queue_peek_tail(q, &prio_modified);
+        if (prio_modified > prio)
+            return false;
+    }
+
+    if (prio_modified >= 0) {
+        if (prio_modified == prio)
+            return false;
+
+        p = aicwf_skb_dequeue_tail(q, prio_modified);
+        aicwf_dev_skb_free(p);
+
+        p = aicwf_frame_queue_penq(q, prio_modified, pkt);
+        if (p == NULL)
+            txrx_err("failed\n");
+    }
+
+    return p != NULL;
+}
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
index 715f00747c38..0d0246c82787 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
@@ -19,6 +19,7 @@
 #endif
 
 #define CMD_BUF_MAX                 1536
+#define DATA_BUF_MAX                2048
 #define TXPKT_BLOCKSIZE             512
 #define MAX_AGGR_TXPKT_LEN          (1536*64)
 #define CMD_TX_TIMEOUT              5000
@@ -88,8 +89,14 @@ struct aicwf_bus {
 	u8 *cmd_buf;
 	struct completion bustx_trgg;
 	struct completion busrx_trgg;
+#ifdef CONFIG_USB_MSG_IN_EP
+	struct completion msg_busrx_trgg;
+#endif
 	struct task_struct *bustx_thread;
 	struct task_struct *busrx_thread;
+#ifdef CONFIG_USB_MSG_IN_EP
+	struct task_struct *msg_busrx_thread;
+#endif
 };
 
 struct aicwf_tx_priv {
@@ -178,6 +185,12 @@ struct aicwf_rx_priv {
 	spinlock_t rxqlock;
 	struct frame_queue rxq;
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	atomic_t msg_rx_cnt;
+	spinlock_t msg_rxqlock;
+	struct frame_queue msg_rxq;
+#endif
+
 #ifdef AICWF_RX_REORDER
 	spinlock_t freeq_lock;
 	struct list_head rxframes_freequeue;
@@ -224,6 +237,9 @@ static inline void aicwf_sched_timeout(u32 millisec)
 	}
 }
 
+#ifdef CONFIG_ALIGN_8BYTES
+void rwnx_skb_align_8bytes(struct sk_buff *skb);
+#endif
 int aicwf_bus_init(uint bus_hdrlen, struct device *dev);
 void aicwf_bus_deinit(struct device *dev);
 void aicwf_tx_deinit(struct aicwf_tx_priv *tx_priv);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
index ef198eefa142..7f6372a1adf2 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
@@ -8,6 +8,7 @@
 
 #include <linux/usb.h>
 #include <linux/kthread.h>
+#include <linux/semaphore.h>
 #include "aicwf_txrxif.h"
 #include "aicwf_usb.h"
 #include "rwnx_tx.h"
@@ -16,18 +17,40 @@
 #include "rwnx_platform.h"
 #include "rwnx_wakelock.h"
 
+struct device_match_entry *aic_matched_ic;
+struct aicbsp_feature_t aicwf_feature;
+
+static struct device_match_entry aicdev_match_table[] = {
+//	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800,		PRODUCT_ID_AIC8800D,	"aic8800d",		0, 0}, // 8800d in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8801,		PRODUCT_ID_AIC8801,		"aic8801",		0, 0}, // 8801 in bootloader mode
+//	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D80,	PRODUCT_ID_AIC8800D80,	"aic8800d80",	0, 0}, // 8800d80 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D81,	PRODUCT_ID_AIC8800D81,	"aic8800d81",	0, 0}, // 8800d81 in bootloader mode
+//	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D40,	PRODUCT_ID_AIC8800D80,	"aic8800d40",	0, 0}, // 8800d40 in bootloader mode
+	{USB_VENDOR_ID_AIC,		USB_DEVICE_ID_AIC_8800D41,	PRODUCT_ID_AIC8800D81,	"aic8800d41",	0, 0}, // 8800d41 in bootloader mode
+//	{USB_VENDOR_ID_AIC_V2,	USB_DEVICE_ID_AIC_8800D80X2,PRODUCT_ID_AIC8800D80X2,"aic8800d80x2",	0, 0}, // 8800d80x2 in bootloader mode
+	{USB_VENDOR_ID_AIC_V2,	USB_DEVICE_ID_AIC_8800D81X2,PRODUCT_ID_AIC8800D81X2,"aic8800d81x2",	0, 0}, // 8800d81x2 in bootloader mode
+};
+
+atomic_t rx_urb_cnt;
+bool rx_urb_sched = false;
+
+bool aicwf_usb_rx_aggr = false;
+
+extern struct semaphore aicwf_deinit_sem;
+extern atomic_t aicwf_deinit_atomic;
+#define SEM_TIMOUT 2000
+
 void aicwf_usb_tx_flowctrl(struct rwnx_hw *rwnx_hw, bool state)
 {
 	struct rwnx_vif *rwnx_vif;
+
 	list_for_each_entry(rwnx_vif, &rwnx_hw->vifs, list) {
-		if (!rwnx_vif->up)
-			continue;
-		if (!rwnx_vif->ndev)
+		if (!rwnx_vif || !rwnx_vif->ndev || !rwnx_vif->up)
 			continue;
 		if (state)
-			netif_stop_queue(rwnx_vif->ndev);
+			netif_tx_stop_all_queues(rwnx_vif->ndev);//netif_stop_queue(rwnx_vif->ndev);
 		else
-			netif_wake_queue(rwnx_vif->ndev);
+			netif_tx_wake_all_queues(rwnx_vif->ndev);//netif_wake_queue(rwnx_vif->ndev);
 	}
 }
 
@@ -87,6 +110,33 @@ static void aicwf_usb_rx_buf_put(struct aic_usb_dev *usb_dev, struct aicwf_usb_b
 	spin_unlock_irqrestore(&usb_dev->rx_free_lock, flags);
 }
 
+#ifdef CONFIG_USB_MSG_IN_EP
+static struct aicwf_usb_buf *aicwf_usb_msg_rx_buf_get(struct aic_usb_dev *usb_dev)
+{
+	unsigned long flags;
+	struct aicwf_usb_buf *usb_buf;
+
+	spin_lock_irqsave(&usb_dev->msg_rx_free_lock, flags);
+	if (list_empty(&usb_dev->msg_rx_free_list)) {
+		usb_buf = NULL;
+	} else {
+		usb_buf = list_first_entry(&usb_dev->msg_rx_free_list, struct aicwf_usb_buf, list);
+		list_del_init(&usb_buf->list);
+	}
+	spin_unlock_irqrestore(&usb_dev->msg_rx_free_lock, flags);
+	return usb_buf;
+}
+
+static void aicwf_usb_msg_rx_buf_put(struct aic_usb_dev *usb_dev, struct aicwf_usb_buf *usb_buf)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&usb_dev->msg_rx_free_lock, flags);
+	list_add_tail(&usb_buf->list, &usb_dev->msg_rx_free_list);
+	spin_unlock_irqrestore(&usb_dev->msg_rx_free_lock, flags);
+}
+#endif
+
 static void aicwf_usb_tx_complete(struct urb *urb)
 {
 	unsigned long flags;
@@ -95,15 +145,18 @@ static void aicwf_usb_tx_complete(struct urb *urb)
 	struct sk_buff *skb;
 	u8 *buf;
 
-	if (usb_buf->cfm == false) {
-		skb = usb_buf->skb;
-	} else {
-		buf = (u8 *)usb_buf->skb;
+#ifdef CONFIG_USB_ALIGN_DATA
+	if(usb_buf->usb_align_data) {
+		kfree(usb_buf->usb_align_data);
+		usb_buf->usb_align_data = NULL;
 	}
+#endif
 
 	if (usb_buf->cfm == false) {
+		skb = usb_buf->skb;
 		dev_kfree_skb_any(skb);
 	} else {
+		buf = (u8 *)usb_buf->skb;
 		kfree(buf);
 	}
 	usb_buf->skb = NULL;
@@ -132,43 +185,241 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 	skb = usb_buf->skb;
 	usb_buf->skb = NULL;
 
+	atomic_dec(&rx_urb_cnt);
+	if(atomic_read(&rx_urb_cnt) < 10){
+		usb_dbg("%s %d \r\n", __func__, atomic_read(&rx_urb_cnt));
+	}
+
+	if(!usb_dev->rwnx_hw){
+		aicwf_dev_skb_free(skb);
+		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+		usb_err("usb_dev->rwnx_hw is not ready \r\n");
+		return;
+	}
 	if (urb->actual_length > urb->transfer_buffer_length) {
+		usb_err("urb_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
 		aicwf_dev_skb_free(skb);
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-		schedule_work(&usb_dev->rx_urb_work);
+		aicwf_usb_rx_submit_all_urb_(usb_dev);
 		return;
 	}
 
 	if (urb->status != 0 || !urb->actual_length) {
 		aicwf_dev_skb_free(skb);
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-		schedule_work(&usb_dev->rx_urb_work);
+		if(urb->status < 0){
+			usb_dbg("%s urb->status:%d \r\n", __func__, urb->status);
+
+			if(g_rwnx_plat->wait_disconnect_cb == false){
+				g_rwnx_plat->wait_disconnect_cb = true;
+				if(atomic_read(&aicwf_deinit_atomic) > 0){
+					atomic_set(&aicwf_deinit_atomic, 0);
+					down(&aicwf_deinit_sem);
+					usb_info("%s need to wait for disconnect callback \r\n", __func__);
+				}else{
+					g_rwnx_plat->wait_disconnect_cb = false;
+				}
+			}
+
+			return;
+		}else{
+			//schedule_work(&usb_dev->rx_urb_work);
+			aicwf_usb_rx_submit_all_urb_(usb_dev);
 		return;
+		}
 	}
 
 	if (usb_dev->state == USB_UP_ST) {
 		skb_put(skb, urb->actual_length);
 
+		if (aicwf_usb_rx_aggr) {
+			skb->len = urb->actual_length;
+		}
+
 		spin_lock_irqsave(&rx_priv->rxqlock, flags);
 		if (!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->rxq, skb)) {
 			spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
 			usb_err("rx_priv->rxq is over flow!!!\n");
 			aicwf_dev_skb_free(skb);
 			aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+			aicwf_usb_rx_submit_all_urb_(usb_dev);
 			return;
 		}
 		spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
 		atomic_inc(&rx_priv->rx_cnt);
-		complete(&rx_priv->usbdev->bus_if->busrx_trgg);
+		if(atomic_read(&rx_priv->rx_cnt) == 1){
+				complete(&rx_priv->usbdev->bus_if->busrx_trgg);
+		}
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-
-		schedule_work(&usb_dev->rx_urb_work);
+		aicwf_usb_rx_submit_all_urb_(usb_dev);
+		//schedule_work(&usb_dev->rx_urb_work);
 	} else {
 		aicwf_dev_skb_free(skb);
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 	}
 }
 
+#ifdef CONFIG_USB_MSG_IN_EP
+static void aicwf_usb_msg_rx_complete(struct urb *urb)
+{
+    struct aicwf_usb_buf *usb_buf = (struct aicwf_usb_buf *) urb->context;
+    struct aic_usb_dev *usb_dev = usb_buf->usbdev;
+    struct aicwf_rx_priv* rx_priv = usb_dev->rx_priv;
+    struct sk_buff *skb = NULL;
+    unsigned long flags = 0;
+
+    skb = usb_buf->skb;
+    usb_buf->skb = NULL;
+
+    if (urb->actual_length > urb->transfer_buffer_length) {
+        usb_err("usb_msg_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
+        aicwf_dev_skb_free(skb);
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+		aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+        //schedule_work(&usb_dev->msg_rx_urb_work);
+        return;
+    }
+
+    if (urb->status != 0 || !urb->actual_length) {
+        aicwf_dev_skb_free(skb);
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+
+		if(urb->status < 0){
+			usb_dbg("%s urb->status:%d \r\n", __func__, urb->status);
+			return;
+		}else{
+			aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+			//schedule_work(&usb_dev->msg_rx_urb_work);
+        	return;
+		}
+    }
+
+    if (usb_dev->state == USB_UP_ST) {
+        skb_put(skb, urb->actual_length);
+
+#ifdef CONFIG_USB_RX_REASSEMBLE
+        bool pkt_check = false;
+        if (rx_priv->rx_msg_reassemble_skb) {
+            u32 frag_len = skb->len;
+            struct sk_buff *reassemble_skb = rx_priv->rx_msg_reassemble_skb;
+            bool reassemble_valid = false;
+            bool reassemble_done = false;
+            if ((rx_priv->rx_msg_reassemble_cur_frags + 1) == rx_priv->rx_msg_reassemble_total_frags) {
+                if ((rx_priv->rx_msg_reassemble_cur_len + frag_len) == rx_priv->rx_msg_reassemble_total_len) {
+                    reassemble_valid = true;
+                    reassemble_done = true;
+                }
+            } else {
+                if (frag_len == AICWF_USB_MSG_MAX_PKT_SIZE) {
+                    reassemble_valid = true;
+                }
+            }
+
+            if (reassemble_valid) {
+                memcpy((reassemble_skb->data + reassemble_skb->len), skb->data, frag_len);
+                skb_put(reassemble_skb, skb->len);
+                rx_priv->rx_msg_reassemble_cur_len += frag_len;
+                rx_priv->rx_msg_reassemble_cur_frags++;
+                aicwf_dev_skb_free(skb);
+                if (reassemble_done) {
+                    skb = reassemble_skb;
+                    rx_priv->rx_msg_reassemble_skb = NULL;
+                    rx_priv->rx_msg_reassemble_total_len = 0;
+                    rx_priv->rx_msg_reassemble_cur_len = 0;
+                    rx_priv->rx_msg_reassemble_total_frags = 0;
+                    rx_priv->rx_msg_reassemble_cur_frags = 0;
+                } else {
+                    aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                    aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                    return;
+                }
+            } else {
+                usb_err("invalid frag msg pkt, len=%u/%u/%u, frags=%u/%u\n", frag_len,
+                    rx_priv->rx_msg_reassemble_cur_len, rx_priv->rx_msg_reassemble_cur_len,
+                    rx_priv->rx_msg_reassemble_cur_frags, rx_priv->rx_msg_reassemble_total_frags);
+                aicwf_dev_skb_free(reassemble_skb);
+                rx_priv->rx_msg_reassemble_skb = NULL;
+                rx_priv->rx_msg_reassemble_total_len = 0;
+                rx_priv->rx_msg_reassemble_cur_len = 0;
+                rx_priv->rx_msg_reassemble_total_frags = 0;
+                rx_priv->rx_msg_reassemble_cur_frags = 0;
+                pkt_check = true;
+            }
+        } else {
+            pkt_check = true;
+        }
+
+        if (pkt_check) {
+            bool pkt_drop = false;
+            u8 type = skb->data[2];
+            u32 pkt_len = skb->data[0] | (skb->data[1] << 8);
+            if ((type & USB_TYPE_CFG) != USB_TYPE_CFG) {
+                usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);;
+                pkt_drop = true;
+            } else {
+                if (type == USB_TYPE_CFG_CMD_RSP) {
+                    u32 pkt_total_len = ALIGN((pkt_len + 4), 4);
+                    if ((pkt_total_len > AICWF_USB_MSG_MAX_PKT_SIZE) && (skb->len == AICWF_USB_MSG_MAX_PKT_SIZE)) {
+                        AICWFDBG(LOGINFO, "reassemble msg pkt, len=%u\n", pkt_total_len);
+                        struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                        if (reassemble_skb) {
+                            memcpy(reassemble_skb->data, skb->data, skb->len);
+                            skb_put(reassemble_skb, skb->len);
+                            rx_priv->rx_msg_reassemble_skb = reassemble_skb;
+                            rx_priv->rx_msg_reassemble_total_len = pkt_total_len;
+                            rx_priv->rx_msg_reassemble_cur_len = skb->len;
+                            rx_priv->rx_msg_reassemble_total_frags = ALIGN(pkt_total_len, AICWF_USB_MSG_MAX_PKT_SIZE) / AICWF_USB_MSG_MAX_PKT_SIZE;
+                            rx_priv->rx_msg_reassemble_cur_frags = 1;
+                        } else {
+                            usb_err("reassemble msg pkt alloc fail, len=%u\n", pkt_total_len);
+                        }
+                        aicwf_dev_skb_free(skb);
+                        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                        return;
+                    } else if (pkt_total_len != skb->len) {
+                        usb_err("invalid CMD_RSP, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else if (type == USB_TYPE_CFG_DATA_CFM) {
+                    if (!((pkt_len == 8) && (skb->len == 12))) {
+                        usb_err("invalid DATA_CFM, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else {
+                    usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);
+                    pkt_drop = true;
+                }
+            }
+            if (pkt_drop) {
+                aicwf_dev_skb_free(skb);
+                aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                return;
+            }
+        }
+#endif
+
+        spin_lock_irqsave(&rx_priv->msg_rxqlock, flags);
+        if(!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->msg_rxq, skb)){
+            spin_unlock_irqrestore(&rx_priv->msg_rxqlock, flags);
+            usb_err("rx_priv->rxq is over flow!!!\n");
+            aicwf_dev_skb_free(skb);
+            return;
+        }
+        spin_unlock_irqrestore(&rx_priv->msg_rxqlock, flags);
+        atomic_inc(&rx_priv->msg_rx_cnt);
+        complete(&rx_priv->usbdev->bus_if->msg_busrx_trgg);
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+        aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+        //schedule_work(&usb_dev->msg_rx_urb_work);
+    } else {
+        aicwf_dev_skb_free(skb);
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+    }
+}
+#endif
+
 static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 				struct aicwf_usb_buf *usb_buf)
 {
@@ -184,7 +435,11 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 		return -1;
 	}
 
-	skb = __dev_alloc_skb(AICWF_USB_MAX_PKT_SIZE, GFP_KERNEL);
+	if(aicwf_usb_rx_aggr){
+		skb = __dev_alloc_skb(AICWF_USB_AGGR_MAX_PKT_SIZE, GFP_ATOMIC/*GFP_KERNEL*/);
+	} else {
+		 skb = __dev_alloc_skb(AICWF_USB_MAX_PKT_SIZE, GFP_ATOMIC/*GFP_KERNEL*/);
+	}
 	if (!skb) {
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 		return -1;
@@ -192,10 +447,17 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 
 	usb_buf->skb = skb;
 
-	usb_fill_bulk_urb(usb_buf->urb,
-		usb_dev->udev,
-		usb_dev->bulk_in_pipe,
-		skb->data, skb_tailroom(skb), aicwf_usb_rx_complete, usb_buf);
+	if (aicwf_usb_rx_aggr) {
+		usb_fill_bulk_urb(usb_buf->urb,
+			usb_dev->udev,
+			usb_dev->bulk_in_pipe,
+			skb->data, AICWF_USB_AGGR_MAX_PKT_SIZE, aicwf_usb_rx_complete, usb_buf);
+	} else {
+		usb_fill_bulk_urb(usb_buf->urb,
+			usb_dev->udev,
+			usb_dev->bulk_in_pipe,
+			skb->data, AICWF_USB_MAX_PKT_SIZE, aicwf_usb_rx_complete, usb_buf);
+	}
 
 	usb_buf->usbdev = usb_dev;
 
@@ -209,6 +471,9 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
 		msleep(100);
+		return -1;
+	}else{
+		atomic_inc(&rx_urb_cnt);
 	}
 	return 0;
 }
@@ -224,13 +489,98 @@ static void aicwf_usb_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
 
 	while ((usb_buf = aicwf_usb_rx_buf_get(usb_dev)) != NULL) {
 		if (aicwf_usb_submit_rx_urb(usb_dev, usb_buf)) {
+            usb_err("sub rx fail\n");
+            return;
+            #if 0
 			usb_err("usb rx refill fail\n");
 			if (usb_dev->state != USB_UP_ST)
 				return;
+            #endif
 		}
 	}
+    usb_dev->rx_prepare_ready = true;
+}
+
+#ifdef CONFIG_USB_MSG_IN_EP
+static int aicwf_usb_submit_msg_rx_urb(struct aic_usb_dev *usb_dev,
+                struct aicwf_usb_buf *usb_buf)
+{
+    struct sk_buff *skb;
+    int ret;
+
+    if (!usb_buf || !usb_dev)
+        return -1;
+
+    if (usb_dev->state != USB_UP_ST) {
+        usb_err("usb state is not up!\n");
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+        return -1;
+    }
+
+    skb = __dev_alloc_skb(AICWF_USB_MSG_MAX_PKT_SIZE, GFP_ATOMIC);
+    if (!skb) {
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+        return -1;
+    }
+
+    usb_buf->skb = skb;
+
+    usb_fill_bulk_urb(usb_buf->urb,
+        usb_dev->udev,
+        usb_dev->msg_in_pipe,
+        skb->data, AICWF_USB_MSG_MAX_PKT_SIZE, aicwf_usb_msg_rx_complete, usb_buf);
+
+    usb_buf->usbdev = usb_dev;
+
+    usb_anchor_urb(usb_buf->urb, &usb_dev->msg_rx_submitted);
+    ret = usb_submit_urb(usb_buf->urb, GFP_ATOMIC);
+    if (ret) {
+        usb_err("usb submit msg rx urb fail:%d\n", ret);
+        usb_unanchor_urb(usb_buf->urb);
+        aicwf_dev_skb_free(usb_buf->skb);
+        usb_buf->skb = NULL;
+        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+
+        msleep(100);
+    }
+    return 0;
+}
+
+
+static void aicwf_usb_msg_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
+{
+    struct aicwf_usb_buf *usb_buf;
+
+    if (usb_dev->state != USB_UP_ST) {
+        usb_err("bus is not up=%d\n", usb_dev->state);
+        return;
+    }
+
+    while((usb_buf = aicwf_usb_msg_rx_buf_get(usb_dev)) != NULL) {
+        if (aicwf_usb_submit_msg_rx_urb(usb_dev, usb_buf)) {
+            usb_err("usb msg rx refill fail\n");
+            if (usb_dev->state != USB_UP_ST)
+                return;
+        }
+    }
+}
+#endif
+
+#ifdef CONFIG_USB_MSG_IN_EP
+void aicwf_usb_msg_rx_submit_all_urb_(struct aic_usb_dev *usb_dev){
+	aicwf_usb_msg_rx_submit_all_urb(usb_dev);
 }
 
+static void aicwf_usb_msg_rx_prepare(struct aic_usb_dev *usb_dev)
+{
+    aicwf_usb_msg_rx_submit_all_urb(usb_dev);
+}
+
+#endif
+
+void aicwf_usb_rx_submit_all_urb_(struct aic_usb_dev *usb_dev){
+	aicwf_usb_rx_submit_all_urb(usb_dev);
+}
 static void aicwf_usb_rx_prepare(struct aic_usb_dev *usb_dev)
 {
 	aicwf_usb_rx_submit_all_urb(usb_dev);
@@ -271,7 +621,7 @@ static void aicwf_usb_tx_process(struct aic_usb_dev *usb_dev)
 		}
 		data = usb_buf->skb->data;
 
-		ret = usb_submit_urb(usb_buf->urb, GFP_ATOMIC);
+		ret = usb_submit_urb(usb_buf->urb, GFP_KERNEL);
 		if (ret) {
 			usb_err("aicwf_usb_bus_tx usb_submit_urb FAILED\n");
 			goto fail;
@@ -286,19 +636,40 @@ static void aicwf_usb_tx_process(struct aic_usb_dev *usb_dev)
 	}
 }
 
+static inline void aic_thread_wait_stop(void)
+{
+#if 1// PLATFORM_LINUX
+	#if 0
+	while (!kthread_should_stop())
+		rtw_msleep_os(10);
+	#else
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (!kthread_should_stop()) {
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	__set_current_state(TASK_RUNNING);
+	#endif
+#endif
+}
+
 int usb_bustx_thread(void *data)
 {
 	struct aicwf_bus *bus = (struct aicwf_bus *)data;
 	struct aic_usb_dev *usbdev = bus->bus_priv.usb;
 
 	while (1) {
+		#if 0
 		if (kthread_should_stop()) {
 			usb_err("usb bustx thread stop\n");
 			break;
 		}
+		#endif
 		if (!wait_for_completion_interruptible(&bus->bustx_trgg)) {
-			if (usbdev->bus_if->state == BUS_DOWN_ST)
-				continue;
+			if (usbdev->bus_if->state == BUS_DOWN_ST) {
+				usb_info("usb bustx thread will to stop\n");
+				break;
+			}
 			rwnx_wakeup_lock(usbdev->rwnx_hw->ws_tx);
 			if (usbdev->tx_post_count > 0)
 				aicwf_usb_tx_process(usbdev);
@@ -306,6 +677,9 @@ int usb_bustx_thread(void *data)
 		}
 	}
 
+	aic_thread_wait_stop();
+	usb_info("usb bustx thread stop\n");
+
 	return 0;
 }
 
@@ -316,22 +690,73 @@ int usb_busrx_thread(void *data)
 	struct aic_usb_dev *usbdev = rx_priv->usbdev;
 
 	while (1) {
+		#if 0
 		if (kthread_should_stop()) {
 			usb_err("usb busrx thread stop\n");
 			break;
 		}
+		#endif
 		if (!wait_for_completion_interruptible(&bus_if->busrx_trgg)) {
-			if (bus_if->state == BUS_DOWN_ST)
-				continue;
+			if (bus_if->state == BUS_DOWN_ST) {
+				usb_info("usb busrx thread will to stop\n");
+				break;
+			}
 			rwnx_wakeup_lock(usbdev->rwnx_hw->ws_rx);
 			aicwf_process_rxframes(rx_priv);
 			rwnx_wakeup_unlock(usbdev->rwnx_hw->ws_rx);
 		}
 	}
 
+	aic_thread_wait_stop();
+	usb_info("usb busrx thread stop\n");
+
 	return 0;
 }
 
+#ifdef CONFIG_USB_MSG_IN_EP
+int usb_msg_busrx_thread(void *data)
+{
+    struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
+    struct aicwf_bus *bus_if = rx_priv->usbdev->bus_if;
+
+#ifdef CONFIG_TXRX_THREAD_PRIO
+	if (busrx_thread_prio > 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+        sched_set_fifo_low(current);
+#else
+        struct sched_param param;
+        param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+        sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
+	}
+#endif
+	usb_info("%s the policy of current thread is:%d\n", __func__, current->policy);
+	usb_info("%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+	usb_info("%s the current pid is:%d\n", __func__, current->pid);
+
+    while (1) {
+		#if 0
+		if(kthread_should_stop()) {
+			usb_err("usb msg busrx thread stop\n");
+			break;
+		}
+		#endif
+		if (!wait_for_completion_interruptible(&bus_if->msg_busrx_trgg)) {
+			if(bus_if->state == BUS_DOWN_ST){
+				usb_info("usb msg busrx thread will to stop\n");
+				break;
+			}
+			aicwf_process_msg_rxframes(rx_priv);
+		}
+	}
+
+	aic_thread_wait_stop();
+	usb_info("usb msg busrx thread stop\n");
+
+    return 0;
+}
+#endif
+
 static void aicwf_usb_send_msg_complete(struct urb *urb)
 {
 	struct aic_usb_dev *usb_dev = (struct aic_usb_dev *) urb->context;
@@ -355,7 +780,7 @@ static int aicwf_usb_bus_txmsg(struct device *dev, u8 *buf, u32 len)
 
 	usb_dev->msg_finished = false;
 
-#ifdef CONFIG_USB_MSG_EP
+#ifdef CONFIG_USB_MSG_OUT_EP
 	if (usb_dev->msg_out_pipe) {
 		usb_fill_bulk_urb(usb_dev->msg_out_urb,
 			usb_dev->udev,
@@ -425,8 +850,9 @@ static int aicwf_usb_alloc_rx_urb(struct aic_usb_dev *usb_dev)
 {
 	int i;
 
-	for (i = 0; i < AICWF_USB_RX_URBS; i++) {
-		struct aicwf_usb_buf *usb_buf = &usb_dev->usb_rx_buf[i];
+	usb_info("%s AICWF_USB_RX_URBS:%d \r\n", __func__, AICWF_USB_RX_URBS);
+    for (i = 0; i < AICWF_USB_RX_URBS; i++) {
+        struct aicwf_usb_buf *usb_buf = &usb_dev->usb_rx_buf[i];
 
 		usb_buf->usbdev = usb_dev;
 		usb_buf->urb = usb_alloc_urb(0, GFP_KERNEL);
@@ -447,6 +873,7 @@ static int aicwf_usb_alloc_tx_urb(struct aic_usb_dev *usb_dev)
 {
 	int i;
 
+	usb_info("%s AICWF_USB_TX_URBS:%d \r\n", __func__, AICWF_USB_TX_URBS);
 	for (i = 0; i < AICWF_USB_TX_URBS; i++) {
 		struct aicwf_usb_buf *usb_buf = &usb_dev->usb_tx_buf[i];
 
@@ -466,6 +893,31 @@ static int aicwf_usb_alloc_tx_urb(struct aic_usb_dev *usb_dev)
 	return -ENOMEM;
 }
 
+#ifdef CONFIG_USB_MSG_IN_EP
+static int aicwf_usb_alloc_msg_rx_urb(struct aic_usb_dev *usb_dev)
+{
+    int i;
+
+    usb_info("%s AICWF_USB_MSG_RX_URBS:%d \r\n", __func__, AICWF_USB_MSG_RX_URBS);
+
+    for (i = 0; i < AICWF_USB_MSG_RX_URBS; i++) {
+        struct aicwf_usb_buf *usb_buf = &usb_dev->usb_msg_rx_buf[i];
+
+        usb_buf->usbdev = usb_dev;
+        usb_buf->urb = usb_alloc_urb(0, GFP_KERNEL);
+        if (!usb_buf->urb) {
+            usb_err("could not allocate rx data urb\n");
+            goto err;
+        }
+        list_add_tail(&usb_buf->list, &usb_dev->msg_rx_free_list);
+    }
+    return 0;
+
+err:
+    aicwf_usb_free_urb(&usb_dev->msg_rx_free_list, &usb_dev->msg_rx_free_lock);
+    return -ENOMEM;
+}
+#endif
 
 static void aicwf_usb_state_change(struct aic_usb_dev *usb_dev, int state)
 {
@@ -485,6 +937,10 @@ static void aicwf_usb_state_change(struct aic_usb_dev *usb_dev, int state)
 	}
 }
 
+#ifdef CONFIG_USB_ALIGN_DATA
+int align_param = 8;
+module_param(align_param, int, 0660);
+#endif
 static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 {
 	u8 *buf;
@@ -501,6 +957,10 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 	u8 adj_buf[4] = {0};
 	u16 index = 0;
 	bool need_cfm = false;
+#ifdef CONFIG_USB_ALIGN_DATA
+	u8 *buf_align = NULL;
+	int align;
+#endif
 
 	if (usb_dev->state != USB_UP_ST) {
 		usb_err("usb state is not up!\n");
@@ -521,7 +981,7 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 
 	if (txhdr->sw_hdr->need_cfm) {
 		need_cfm = true;
-		buf = kmalloc(skb->len, GFP_KERNEL);
+		buf = kmalloc(skb->len + 1, GFP_ATOMIC/*GFP_KERNEL*/);
 		index += sizeof(usb_header);
 		memcpy(&buf[index], (u8 *)(long)&txhdr->sw_hdr->desc, sizeof(struct txdesc_api));
 		index += sizeof(struct txdesc_api);
@@ -562,8 +1022,36 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 		usb_buf->cfm = true;
 	else
 		usb_buf->cfm = false;
+
+#ifdef CONFIG_USB_ALIGN_DATA
+#if 0
+		usb_buf->usb_align_data = (u8*)kmalloc(sizeof(u8) * buf_len + align_param, GFP_ATOMIC);
+	
+		align = ((unsigned long)(usb_buf->usb_align_data)) & (align_param - 1);
+		memcpy(usb_buf->usb_align_data + (align_param - align), buf, buf_len);
+	
+		usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
+					usb_buf->usb_align_data + (align_param - align), buf_len, aicwf_usb_tx_complete, usb_buf);
+#else
+		if (!IS_ALIGNED((unsigned long)buf, align_param)) {
+			usb_buf->usb_align_data = (u8*)kmalloc(sizeof(u8) * buf_len + align_param, GFP_ATOMIC);
+			if (usb_buf->usb_align_data) {
+				align = ((unsigned long)(usb_buf->usb_align_data)) & (align_param - 1);
+				buf_align = usb_buf->usb_align_data + (align_param - align);
+				memcpy(buf_align, buf, buf_len);
+			}
+		} else {
+			buf_align = buf;
+		}
+	
+		usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
+					buf_align, buf_len, aicwf_usb_tx_complete, usb_buf);
+#endif
+#else
 	usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
 				buf, buf_len, aicwf_usb_tx_complete, usb_buf);
+#endif
+
 	usb_buf->urb->transfer_flags |= URB_ZERO_PACKET;
 
 	aicwf_usb_tx_queue(usb_dev, &usb_dev->tx_post_list, usb_buf,
@@ -574,6 +1062,8 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 flow_ctrl:
 	spin_lock_irqsave(&usb_dev->tx_flow_lock, flags);
 	if (usb_dev->tx_free_count < AICWF_USB_TX_LOW_WATER) {
+		usb_dbg("usb_dev->tx_free_count < AICWF_USB_TX_LOW_WATER:%d\r\n",
+			usb_dev->tx_free_count);
 		usb_dev->tbusy = true;
 		aicwf_usb_tx_flowctrl(usb_dev->rwnx_hw, true);
 	}
@@ -591,12 +1081,23 @@ static int aicwf_usb_bus_start(struct device *dev)
 		return 0;
 
 	aicwf_usb_state_change(usb_dev, USB_UP_ST);
+	usb_dev->rx_prepare_ready = false;
 	aicwf_usb_rx_prepare(usb_dev);
 	aicwf_usb_tx_prepare(usb_dev);
-	return 0;
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		aicwf_usb_msg_rx_prepare(usb_dev);
+	}
+#endif
+	if(!usb_dev->rx_prepare_ready){
+		usb_err("%s rx prepare fail\r\n", __func__);
+		return -1;
+	}else{
+		return 0;
+	}
 }
 
-static void aicwf_usb_cancel_all_urbs(struct aic_usb_dev *usb_dev)
+static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
 {
 	struct aicwf_usb_buf *usb_buf, *tmp;
 	unsigned long flags;
@@ -618,6 +1119,15 @@ static void aicwf_usb_cancel_all_urbs(struct aic_usb_dev *usb_dev)
 	spin_unlock_irqrestore(&usb_dev->tx_post_lock, flags);
 
 	usb_kill_anchored_urbs(&usb_dev->rx_submitted);
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		usb_kill_anchored_urbs(&usb_dev->msg_rx_submitted);
+	}
+#endif
+}
+
+void aicwf_usb_cancel_all_urbs(struct aic_usb_dev *usb_dev){
+	aicwf_usb_cancel_all_urbs_(usb_dev);
 }
 
 static void aicwf_usb_bus_stop(struct device *dev)
@@ -632,8 +1142,12 @@ static void aicwf_usb_bus_stop(struct device *dev)
 	if (usb_dev->state == USB_DOWN_ST)
 		return;
 
+    if(g_rwnx_plat && g_rwnx_plat->wait_disconnect_cb == true){
+        atomic_set(&aicwf_deinit_atomic, 1);
+        up(&aicwf_deinit_sem);
+    }
 	aicwf_usb_state_change(usb_dev, USB_DOWN_ST);
-	aicwf_usb_cancel_all_urbs(usb_dev);
+    //aicwf_usb_cancel_all_urbs(usb_dev);//AIDEN
 }
 
 static void aicwf_usb_deinit(struct aic_usb_dev *usbdev)
@@ -641,6 +1155,13 @@ static void aicwf_usb_deinit(struct aic_usb_dev *usbdev)
 	cancel_work_sync(&usbdev->rx_urb_work);
 	aicwf_usb_free_urb(&usbdev->rx_free_list, &usbdev->rx_free_lock);
 	aicwf_usb_free_urb(&usbdev->tx_free_list, &usbdev->tx_free_lock);
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usbdev->msg_in_pipe){
+		cancel_work_sync(&usbdev->msg_rx_urb_work);
+		aicwf_usb_free_urb(&usbdev->msg_rx_free_list, &usbdev->msg_rx_free_lock);
+	}
+#endif
+
 	usb_free_urb(usbdev->msg_out_urb);
 }
 
@@ -651,6 +1172,15 @@ static void aicwf_usb_rx_urb_work(struct work_struct *work)
 	aicwf_usb_rx_submit_all_urb(usb_dev);
 }
 
+#ifdef CONFIG_USB_MSG_IN_EP
+static void aicwf_usb_msg_rx_urb_work(struct work_struct *work)
+{
+    struct aic_usb_dev *usb_dev = container_of(work, struct aic_usb_dev, msg_rx_urb_work);
+
+    aicwf_usb_msg_rx_submit_all_urb(usb_dev);
+}
+#endif
+
 static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 {
 	int ret = 0;
@@ -661,15 +1191,32 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 	init_waitqueue_head(&usb_dev->msg_wait);
 	init_usb_anchor(&usb_dev->rx_submitted);
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		init_usb_anchor(&usb_dev->msg_rx_submitted);
+	}
+#endif
+
 	spin_lock_init(&usb_dev->tx_free_lock);
 	spin_lock_init(&usb_dev->tx_post_lock);
 	spin_lock_init(&usb_dev->rx_free_lock);
 	spin_lock_init(&usb_dev->tx_flow_lock);
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		spin_lock_init(&usb_dev->msg_rx_free_lock);
+	}
+#endif
 
 	INIT_LIST_HEAD(&usb_dev->rx_free_list);
 	INIT_LIST_HEAD(&usb_dev->tx_free_list);
 	INIT_LIST_HEAD(&usb_dev->tx_post_list);
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		INIT_LIST_HEAD(&usb_dev->msg_rx_free_list);
+	}
+#endif
 
+	atomic_set(&rx_urb_cnt, 0);
 	usb_dev->tx_free_count = 0;
 	usb_dev->tx_post_count = 0;
 
@@ -681,7 +1228,14 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 	if (ret) {
 		goto error;
 	}
-
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		ret =  aicwf_usb_alloc_msg_rx_urb(usb_dev);
+		if (ret) {
+			goto error;
+		}
+	}
+#endif
 
 	usb_dev->msg_out_urb = usb_alloc_urb(0, GFP_ATOMIC);
 	if (!usb_dev->msg_out_urb) {
@@ -692,6 +1246,12 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 
 	INIT_WORK(&usb_dev->rx_urb_work, aicwf_usb_rx_urb_work);
 
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(usb_dev->msg_in_pipe){
+		INIT_WORK(&usb_dev->msg_rx_urb_work, aicwf_usb_msg_rx_urb_work);
+	}
+#endif
+
 	return ret;
 	error:
 	usb_err("failed!\n");
@@ -713,13 +1273,17 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 	usb_dev->bulk_in_pipe = 0;
 	usb_dev->bulk_out_pipe = 0;
 
-#ifdef CONFIG_USB_MSG_EP
+#ifdef CONFIG_USB_MSG_OUT_EP
 	usb_dev->msg_out_pipe = 0;
 #endif
+#ifdef CONFIG_USB_MSG_IN_EP
+	usb_dev->msg_in_pipe = 0;
+#endif
 
 	host_interface = &interface->altsetting[0];
 	interface_desc = &host_interface->desc;
 	endpoints = interface_desc->bNumEndpoints;
+	usb_info("%s endpoints = %d\n", __func__, endpoints);
 
 	/* Check device configuration */
 	if (usb->descriptor.bNumConfigurations != 1) {
@@ -770,13 +1334,20 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 			if (!usb_dev->bulk_in_pipe) {
 				usb_dev->bulk_in_pipe = usb_rcvbulkpipe(usb, endpoint_num);
 			}
+#ifdef CONFIG_USB_MSG_IN_EP
+			else if (!usb_dev->msg_in_pipe) {
+				if(aicwf_feature.chipinfo->chipid != PRODUCT_ID_AIC8801){
+					usb_dev->msg_in_pipe = usb_rcvbulkpipe(usb, endpoint_num);
+				}
+			}
+#endif
 		}
 
 		if (usb_endpoint_dir_out(endpoint) &&
 			usb_endpoint_xfer_bulk(endpoint)) {
 			if (!usb_dev->bulk_out_pipe) {
 				usb_dev->bulk_out_pipe = usb_sndbulkpipe(usb, endpoint_num);
-#ifdef CONFIG_USB_MSG_EP
+#ifdef CONFIG_USB_MSG_OUT_EP
 			} else if (!usb_dev->msg_out_pipe) {
 				usb_dev->msg_out_pipe = usb_sndbulkpipe(usb, endpoint_num);
 #endif
@@ -795,16 +1366,40 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 		goto exit;
 	}
 
-#ifdef CONFIG_USB_MSG_EP
+#ifdef CONFIG_USB_MSG_OUT_EP
 	if (usb_dev->msg_out_pipe == 0) {
 		usb_err("No TX Msg (out) Bulk EP found\n");
 	}
 #endif
+#ifdef CONFIG_USB_MSG_IN_EP
+	if(aicwf_feature.chipinfo->chipid != PRODUCT_ID_AIC8801){
+		if (usb_dev->msg_in_pipe == 0) {
+			usb_info("No RX Msg (in) Bulk EP found\n");
+		}
+	}
+#endif
 
-	if (usb->speed == USB_SPEED_HIGH)
-		printk("Aic high speed USB device detected\n");
-	else
-		printk("Aic full speed USB device detected\n");
+	switch (usb->speed) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+	case USB_SPEED_SUPER_PLUS:
+		usb_info("Aic super plus speed USB device detected\n");
+		break;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	case USB_SPEED_SUPER:
+		usb_info("Aic super speed USB device detected\n");
+		break;
+#endif
+	case USB_SPEED_HIGH:
+		usb_info("Aic high speed USB device detected\n");
+		break;
+	case USB_SPEED_FULL:
+		usb_info("Aic full speed USB device detected\n");
+		break;
+	default:
+		usb_info("Aic unknown speed(%d) USB device detected\n", usb->speed);
+		break;
+	}
 
 	exit:
 	return ret;
@@ -821,20 +1416,70 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 {
 	int ret = 0;
 	struct usb_device *usb = interface_to_usbdev(intf);
-	struct aicwf_bus *bus_if ;
+    struct aicwf_bus *bus_if = NULL;
 	struct device *dev = NULL;
 	struct aicwf_rx_priv *rx_priv = NULL;
 	struct aic_usb_dev *usb_dev = NULL;
+	int i = 0;
 
 	usb_dev = kzalloc(sizeof(struct aic_usb_dev), GFP_ATOMIC);
 	if (!usb_dev) {
+		usb_err("%s usb_dev kzalloc fail\r\n", __func__);
 		return -ENOMEM;
 	}
 
+	usb_dbg("%s usb_dev:%d usb_tx_buf:%d usb_rx_buf:%d\r\n", 
+		__func__, (int)sizeof(struct aic_usb_dev), (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS, (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+	usb_dev->usb_tx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS);
+    usb_dev->usb_rx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+    if(!usb_dev->usb_tx_buf || !usb_dev->usb_rx_buf){
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev){
+            kfree(usb_dev);
+        }
+        usb_err("%s usb_tx_buf or usb_rx_buf vmalloc fail\r\n", __func__);
+        return -ENOMEM;
+    }
+
+    memset(usb_dev->usb_tx_buf, 0, (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS));
+    memset(usb_dev->usb_rx_buf, 0, (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS));
+
 	usb_dev->udev = usb;
 	usb_dev->dev = &usb->dev;
 	usb_set_intfdata(intf, usb_dev);
 
+	aic_matched_ic = NULL;
+	for (i = 0; i < sizeof(aicdev_match_table) / sizeof(aicdev_match_table[0]); i++) {
+		if (id->idVendor == aicdev_match_table[i].vid && id->idProduct == aicdev_match_table[i].pid) {
+			aic_matched_ic = &aicdev_match_table[i];
+			break;
+		}
+	}
+
+	usb_dbg("%s, matched chip: %s\n", __func__, aic_matched_ic ? aic_matched_ic->name : "none");
+	if (aic_matched_ic == NULL) {
+		usb_dbg("%s device is not support, exit...\n", __func__);
+		return -1;
+	}
+
+#ifdef AICWF_BSP_CTRL
+	aicbsp_get_feature(&aicwf_feature);
+	aicwf_feature.chipinfo = aic_matched_ic;
+#endif
+
+	if(aicwf_feature.chipinfo->chipid == PRODUCT_ID_AIC8800D81){
+		aicwf_usb_rx_aggr = true;
+	}
+
 	ret = aicwf_parse_usb(usb_dev, intf);
 	if (ret) {
 		usb_err("aicwf_parse_usb err %d\n", ret);
@@ -869,6 +1514,7 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 	}
 	usb_dev->rx_priv = rx_priv;
 
+
 	ret = aicwf_bus_init(0, dev);
 	if (ret < 0) {
 		usb_err("aicwf_bus_init err %d\n", ret);
@@ -881,7 +1527,11 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 		goto out_free_bus;
 	}
 
-	aicwf_rwnx_usb_platform_init(usb_dev);
+	ret = aicwf_rwnx_usb_platform_init(usb_dev);
+	if (ret < 0) {
+		usb_err("aicwf_rwnx_usb_platform_init err %d\n", ret);
+		goto out_free_bus;
+	}
 	aicwf_hostif_ready();
 	return 0;
 
@@ -892,6 +1542,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 	aicwf_usb_deinit(usb_dev);
 out_free:
 	usb_err("failed with errno %d\n", ret);
+	vfree(usb_dev->usb_tx_buf);
+	vfree(usb_dev->usb_rx_buf);
 	kfree(usb_dev);
 	usb_set_intfdata(intf, NULL);
 	return ret;
@@ -901,18 +1553,27 @@ static void aicwf_usb_disconnect(struct usb_interface *intf)
 {
 	struct aic_usb_dev *usb_dev =
 			(struct aic_usb_dev *) usb_get_intfdata(intf);
+    usb_info("%s Enter\r\n", __func__);
 
-	if (!usb_dev)
-		return;
+	if(g_rwnx_plat->wait_disconnect_cb == false){
+		atomic_set(&aicwf_deinit_atomic, 0);
+		down(&aicwf_deinit_sem);
+	}
+    if (!usb_dev){
+		usb_err("%s usb_dev is null \r\n", __func__);
+        return;
+    }
 
 	aicwf_bus_deinit(usb_dev->dev);
 	aicwf_usb_deinit(usb_dev);
-	rwnx_cmd_mgr_deinit(&usb_dev->cmd_mgr);
 
-	if (usb_dev->rx_priv)
-		aicwf_rx_deinit(usb_dev->rx_priv);
 	kfree(usb_dev->bus_if);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
 	kfree(usb_dev);
+	usb_info("%s exit\r\n", __func__);
+	up(&aicwf_deinit_sem);
+	atomic_set(&aicwf_deinit_atomic, 1);
 }
 
 static int aicwf_usb_suspend(struct usb_interface *intf, pm_message_t state)
@@ -920,6 +1581,7 @@ static int aicwf_usb_suspend(struct usb_interface *intf, pm_message_t state)
 	struct aic_usb_dev *usb_dev =
 		(struct aic_usb_dev *) usb_get_intfdata(intf);
 
+	printk("%s enter\r\n", __func__);
 	aicwf_usb_state_change(usb_dev, USB_SLEEP_ST);
 	aicwf_bus_stop(usb_dev->bus_if);
 	return 0;
@@ -929,6 +1591,7 @@ static int aicwf_usb_resume(struct usb_interface *intf)
 {
 	struct aic_usb_dev *usb_dev =
 		(struct aic_usb_dev *) usb_get_intfdata(intf);
+	printk("%s enter\r\n", __func__);
 
 	if (usb_dev->state == USB_UP_ST)
 		return 0;
@@ -944,9 +1607,15 @@ static int aicwf_usb_reset_resume(struct usb_interface *intf)
 
 static struct usb_device_id aicwf_usb_id_table[] = {
 #ifndef CONFIG_USB_BT
-	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC)},
+	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800)},
 #else
-	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC, 0xff, 0xff, 0xff)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8801, 0xff, 0xff, 0xff)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D81, 0xff, 0xff, 0xff)},
+	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D41, 0xff, 0xff, 0xff)},
+//	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DC, 0xff, 0xff, 0xff)},
+//	{USB_DEVICE(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DW)},
+//	{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D81X2, 0xff, 0xff, 0xff)},
+//	{USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D89X2)},
 #endif
 	{}
 };
@@ -976,8 +1645,44 @@ void aicwf_usb_register(void)
 
 void aicwf_usb_exit(void)
 {
+    int retry = 5;
+    usb_info("%s Enter\r\n", __func__);
+
+    usb_dbg("%s in_interrupt:%d in_softirq:%d in_atomic:%d\r\n", __func__, (int)in_interrupt(), (int)in_softirq(), (int)in_atomic());
+
+    do{
+        usb_info("aicwf_deinit_atomic is busy. waiting for 500ms retry:%d \r\n",
+            retry);
+        mdelay(500);
+        retry--;
+        if(retry == 0){
+            break;
+        }
+    }while(atomic_read(&aicwf_deinit_atomic) == 0);
+
+	atomic_set(&aicwf_deinit_atomic, 0);
+	if(down_timeout(&aicwf_deinit_sem, msecs_to_jiffies(SEM_TIMOUT)) != 0){
+		usb_err("%s semaphore waiting timeout\r\n", __func__);
+	}
+
+	if(g_rwnx_plat){
+		g_rwnx_plat->wait_disconnect_cb = false;
+	}
+	
+
+	if (!g_rwnx_plat || !g_rwnx_plat->enabled) {
+		usb_info("g_rwnx_plat is not ready. waiting for 500ms\r\n");
+		mdelay(500);
+	}
 	if (g_rwnx_plat && g_rwnx_plat->enabled)
 		rwnx_platform_deinit(g_rwnx_plat->usbdev->rwnx_hw);
+	up(&aicwf_deinit_sem);
+	atomic_set(&aicwf_deinit_atomic, 1);
+
+	usb_info("%s usb_deregister \r\n", __func__);
 	usb_deregister(&aicwf_usbdrvr);
-	kfree(g_rwnx_plat);
+	if (g_rwnx_plat) {
+		kfree(g_rwnx_plat);
+	}
+	usb_info("%s exit\r\n", __func__);
 }
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
index c92d14523e58..8321fcd52898 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
@@ -13,27 +13,41 @@
 #include "rwnx_cmds.h"
 
 #ifdef AICWF_USB_SUPPORT
+extern struct device_match_entry *aic_matched_ic;
+extern struct aicbsp_feature_t aicwf_feature;
 
 /* USB Device ID */
-#define USB_VENDOR_ID_AIC                0xA69C
+#define USB_VENDOR_ID_AIC               0xA69C
+#define USB_VENDOR_ID_AIC_V2            0x368B
 
-#ifndef CONFIG_USB_BT
-#define USB_PRODUCT_ID_AIC               0x8800
-#else
-#define USB_PRODUCT_ID_AIC               0x8801
-#endif
+#define USB_DEVICE_ID_AIC_8800          0x8800
+#define USB_DEVICE_ID_AIC_8801          0x8801
+
+#define USB_DEVICE_ID_AIC_8800D80       0x8D80
+#define USB_DEVICE_ID_AIC_8800D81       0x8D81
+#define USB_DEVICE_ID_AIC_8800D40       0x8D40
+#define USB_DEVICE_ID_AIC_8800D41       0x8D41
 
-#define AICWF_USB_RX_URBS               (200)
-#define AICWF_USB_TX_URBS               (100)
+#define USB_DEVICE_ID_AIC_8800D80X2     0x8D90
+#define USB_DEVICE_ID_AIC_8800D81X2     0x8D91
+
+#define AICWF_USB_RX_URBS               (20)//(200)
+#ifdef CONFIG_USB_MSG_IN_EP
+#define AICWF_USB_MSG_RX_URBS           (100)
+#endif
+#define AICWF_USB_TX_URBS               (200)//(100)
 #define AICWF_USB_TX_LOW_WATER          (AICWF_USB_TX_URBS/4)
 #define AICWF_USB_TX_HIGH_WATER         (AICWF_USB_TX_LOW_WATER*3)
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*10)
+#define AICWF_USB_MSG_MAX_PKT_SIZE      (2048)
 #define AICWF_USB_MAX_PKT_SIZE          (2048)
 
 typedef enum {
 	USB_TYPE_DATA         = 0X00,
 	USB_TYPE_CFG          = 0X10,
 	USB_TYPE_CFG_CMD_RSP  = 0X11,
-	USB_TYPE_CFG_DATA_CFM = 0X12
+	USB_TYPE_CFG_DATA_CFM = 0X12,
+	USB_TYPE_CFG_PRINT    = 0X13
 } usb_type;
 
 enum aicwf_usb_state {
@@ -48,6 +62,7 @@ struct aicwf_usb_buf {
 	struct urb *urb;
 	struct sk_buff *skb;
 	bool cfm;
+	u8* usb_align_data;
 };
 
 struct aic_usb_dev {
@@ -61,28 +76,51 @@ struct aic_usb_dev {
 
 	struct usb_anchor rx_submitted;
 	struct work_struct rx_urb_work;
+#ifdef CONFIG_USB_MSG_IN_EP
+	struct usb_anchor msg_rx_submitted;
+	struct work_struct msg_rx_urb_work;
+#endif
 
 	spinlock_t rx_free_lock;
 	spinlock_t tx_free_lock;
 	spinlock_t tx_post_lock;
 	spinlock_t tx_flow_lock;
+#ifdef CONFIG_USB_MSG_IN_EP
+	spinlock_t msg_rx_free_lock;
+#endif
 
 	struct list_head rx_free_list;
 	struct list_head tx_free_list;
 	struct list_head tx_post_list;
+#ifdef CONFIG_USB_MSG_IN_EP
+	struct list_head msg_rx_free_list;
+#endif
 
 	uint bulk_in_pipe;
 	uint bulk_out_pipe;
-
-#ifdef CONFIG_USB_MSG_EP
-	uint msg_out_pipe;
+#ifdef CONFIG_USB_MSG_OUT_EP
+    uint msg_out_pipe;
+#endif
+#ifdef CONFIG_USB_MSG_IN_EP
+	uint msg_in_pipe;
 #endif
 
+
 	int tx_free_count;
 	int tx_post_count;
+	bool rx_prepare_ready;
 
+#if 0
 	struct aicwf_usb_buf usb_tx_buf[AICWF_USB_TX_URBS];
 	struct aicwf_usb_buf usb_rx_buf[AICWF_USB_RX_URBS];
+#else
+	struct aicwf_usb_buf *usb_tx_buf;
+	struct aicwf_usb_buf *usb_rx_buf;
+#endif
+
+#ifdef CONFIG_USB_MSG_IN_EP
+	struct aicwf_usb_buf usb_msg_rx_buf[AICWF_USB_MSG_RX_URBS];
+#endif
 
 	int msg_finished;
 	wait_queue_head_t msg_wait;
@@ -95,9 +133,18 @@ struct aic_usb_dev {
 extern void aicwf_usb_exit(void);
 extern void aicwf_usb_register(void);
 extern void aicwf_usb_tx_flowctrl(struct rwnx_hw *rwnx_hw, bool state);
+#ifdef CONFIG_USB_MSG_IN_EP
+int usb_msg_busrx_thread(void *data);
+#endif
 int usb_bustx_thread(void *data);
 int usb_busrx_thread(void *data);
 extern void aicwf_hostif_ready(void);
 
+void aicwf_usb_rx_submit_all_urb_(struct aic_usb_dev *usb_dev);
+#ifdef CONFIG_USB_MSG_IN_EP
+void aicwf_usb_msg_rx_submit_all_urb_(struct aic_usb_dev *usb_dev);
+#endif
+
+
 #endif /* AICWF_USB_SUPPORT */
 #endif /* _AICWF_USB_H_       */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 3435dc8be508..bfc60cbe497d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -2626,6 +2626,8 @@ enum {
 #ifdef CONFIG_USB_BT
 	HOST_START_APP_REBOOT,
 #endif // (CONFIG_USB_BT)
+	HOST_START_APP_FNCALL = 4,
+	HOST_START_APP_DUMMY  = 5,
 };
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index 671f0ab1183b..9a00a55bad28 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -19,6 +19,7 @@
 #include <linux/skbuff.h>
 #include <net/cfg80211.h>
 #include <linux/slab.h>
+#include <linux/semaphore.h>
 
 #include "rwnx_mod_params.h"
 #include "rwnx_debugfs.h"
@@ -457,6 +458,15 @@ enum rwnx_drv_connect_status {
 	RWNX_DRV_STATUS_DISCONNECTING,
 	RWNX_DRV_STATUS_CONNECTING,
 	RWNX_DRV_STATUS_CONNECTED,
+	RWNX_DRV_STATUS_ROAMING,
+};
+
+static const char *const s_conn_state[] = {
+	"RWNX_DRV_STATUS_DISCONNECTED",
+	"RWNX_DRV_STATUS_DISCONNECTING",
+	"RWNX_DRV_STATUS_CONNECTING",
+	"RWNX_DRV_STATUS_CONNECTED",
+	"RWNX_DRV_STATUS_ROAMING",
 };
 
 struct rwnx_hw {
@@ -615,4 +625,6 @@ static inline uint8_t master_vif_idx(struct rwnx_vif *vif)
 void rwnx_external_auth_enable(struct rwnx_vif *vif);
 void rwnx_external_auth_disable(struct rwnx_vif *vif);
 
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state);
+
 #endif /* _RWNX_DEFS_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
index 6b291c96e95d..ddcf5c348197 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
@@ -231,14 +231,14 @@ void rwnx_cfg80211_ch_switch_notify(struct cfg80211_registered_device *rdev,
 
 void rwnx_cfg80211_ch_switch_started_notify(struct net_device *dev
 				, struct cfg80211_chan_def *chandef
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
 				, unsigned int link_id
 #endif
 				, u8 count
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
 				, bool quiet
 #endif
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 94))
 				, u16 punct_bitmap
 #endif
 				)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
index ff5dae05acc7..62a01c76c266 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
@@ -30,14 +30,14 @@ void rwnx_cfg80211_ch_switch_notify(struct cfg80211_registered_device *rdev,
 
 void rwnx_cfg80211_ch_switch_started_notify(struct net_device *dev
 				, struct cfg80211_chan_def *chandef
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
 				, unsigned int link_id
 #endif
 				, u8 count
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
 				, bool quiet
 #endif
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 94))
 				, u16 punct_bitmap
 #endif
 				);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index 21f3166956c6..8ea066c36974 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -496,6 +496,11 @@ static const int rwnx_hwq2uapsd[NL80211_NUM_ACS] = {
 
 extern uint8_t scanning;
 
+#ifdef AICWF_USB_SUPPORT
+struct semaphore aicwf_deinit_sem;
+atomic_t aicwf_deinit_atomic;
+#endif
+
 /*********************************************************************
  * helper
  *********************************************************************/
@@ -845,6 +850,14 @@ void rwnx_update_mesh_power_mode(struct rwnx_vif *vif)
 	vif->ap.mesh_pm = mesh_pm;
 }
 
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state){
+	if((int)atomic_read(drv_conn_state) != state){
+		printk("%s drv_conn_state:%p %s --> %s \r\n", __func__, 
+			drv_conn_state, s_conn_state[(int)atomic_read(drv_conn_state)], s_conn_state[state]);
+
+		atomic_set(drv_conn_state, state);
+	}
+}
 
 /*********************************************************************
  * netdev callbacks
@@ -878,7 +891,7 @@ static int rwnx_open(struct net_device *dev)
 		}
 	}
 
-#ifdef AICWF_LATENCY_MODE
+#if defined(AICWF_LATENCY_MODE) && defined(AICWF_SDIO_SUPPORT)
 	if ((!rwnx_hw->cpmode) && (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT)) {
 		rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1, 1);
 	}
@@ -910,7 +923,7 @@ static int rwnx_open(struct net_device *dev)
 	#endif
 
 	set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
-	atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+	rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
 	printk("%s rwnx_vif->drv_flags:%d\r\n", __func__, (int)rwnx_vif->drv_flags);
 
 	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
@@ -1109,7 +1122,7 @@ static int rwnx_close(struct net_device *dev)
 				RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
 				test_counter = waiting_counter;
 				if (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
-					atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
+					rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 					rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
 					while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
 						printk("%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
@@ -1678,7 +1691,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				bytes_written = -EINVAL;
 				break;
 			}
-			if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+			if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 				memcpy(command, &cfm.rftest_result[0], 6 * 12);
 				bytes_written = 6 * 12;
 			} else {
@@ -1696,7 +1709,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			if (func == 0) { // read cur
 				rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
 			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if ((argc > 4) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)) {
+				if ((argc > 4) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D81)) {
 					u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
 					u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
@@ -1707,7 +1720,8 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 					#ifdef AICWF_SDIO_SUPPORT
 					rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
 					#endif
-				} else if ((argc > 3) && (p_rwnx_hw->chipid != PRODUCT_ID_AIC8800D80)) {
+				} else if ((argc > 3) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D || p_rwnx_hw->chipid == PRODUCT_ID_AIC8801 ||
+							p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DW)) {
 					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
 					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
@@ -1722,7 +1736,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			if ((p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DC) ||
 				(p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
 				res_len = 3;
-			} else if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+			} else if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) { // 3 * 2 (2.4g) + 3 * 6 (5g)
 				res_len = 3 * 3 + 3 * 6;
 			} else {
 				res_len = 3 + 4;
@@ -1762,7 +1776,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			if (func == 0) { // read cur
 				rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
 			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if ((argc > 4) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)) {
+				if ((argc > 4) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D81)) {
 					u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
 					u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
@@ -1773,7 +1787,8 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 					#ifdef AICWF_SDIO_SUPPORT
 					rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
 					#endif
-				} else if ((argc > 3) && (p_rwnx_hw->chipid != PRODUCT_ID_AIC8800D80)) {
+				} else if ((argc > 3) && (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D || p_rwnx_hw->chipid == PRODUCT_ID_AIC8801 ||
+							p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DW || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DC)) {
 					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
 					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
@@ -1788,7 +1803,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			if ((p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DC) ||
 				(p_rwnx_hw->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
 				res_len = 3 * 2;
-			} else if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+			} else if (p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || p_rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) { // 3 * 2 (2.4g) + 3 * 6 (5g)
 				res_len = (3 * 3 + 3 * 6) * 2;
 			} else { // 7 = 3(2.4g) + 4(5g)
 				res_len = 3 + 4;
@@ -1999,7 +2014,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			}
 		} else if (strcasecmp(argv[0], "SETSUSPENDMODE") == 0 && p_rwnx_hw->cpmode != AICBSP_CPMODE_TEST) {
 			u8_l setsusp_mode = command_strtoul(argv[1], NULL, 10);
-#ifdef AICWF_LATENCY_MODE
+#if defined(AICWF_LATENCY_MODE) && defined(AICWF_SDIO_SUPPORT)
 			if (setsusp_mode)
 				rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, setsusp_mode, 0);
 			else
@@ -2246,6 +2261,12 @@ static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, void __user
 #endif
 {
 	int ret = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->sdiodev->rwnx_hw;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->usbdev->rwnx_hw;
+#endif
 	///TODO: add ioctl command handler later
 	switch (cmd) {
 	case IOCTL_HOSTAPD:
@@ -2259,9 +2280,9 @@ static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, void __user
 		break;
 	case (SIOCDEVPRIVATE+1):
 		printk("IOCTL PRIVATE\n");
-		rwnx_wakeup_lock(g_rwnx_plat->sdiodev->rwnx_hw->ws_irqrx);
+		rwnx_wakeup_lock(p_rwnx_hw->ws_irqrx);
 		ret = android_priv_cmd(net, req, cmd);
-		rwnx_wakeup_unlock(g_rwnx_plat->sdiodev->rwnx_hw->ws_irqrx);
+		rwnx_wakeup_unlock(p_rwnx_hw->ws_irqrx);
 		break;
 	default:
 		ret = -EOPNOTSUPP;
@@ -3270,10 +3291,14 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	if ((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING ||
 		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
 		printk("%s driver is disconnecting or connecting ,return it \r\n", __func__);
-		return -EALREADY;
+		return 0;
 	}
 
-	atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTING);
+	if (rwnx_vif->sta.is_roam) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_ROAMING);
+	} else {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTING);
+	}
 
 	if (is_wep) {
 		if (sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
@@ -3366,34 +3391,49 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 {
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	int ret = 0;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 	printk("%s drv_vif_index:%d disconnect reason:%d \r\n",
 			__func__, rwnx_vif->drv_vif_index, reason_code);
 
-	if (atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING) {
-		printk("%s call cfg80211_connect_result reason:%d \r\n",
-				__func__, reason_code);
-		msleep(500);
+	if (atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTED) {
+		printk("%s this\r\n", __func__);
+		WARN_ON(1);
+		return -EBUSY;
 	}
 
+
 	if (atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
 		printk("%s wifi is disconnecting, return it:%d \r\n",
 				__func__, reason_code);
 		return -EBUSY;
 	}
 
-	if (atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED) {
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
-		return rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code);
-	} else {
+	if (atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED ||
+		atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING ||
+		atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_ROAMING) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
+		ret = rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code);
+#ifdef AICWF_SDIO_SUPPORT
+		if (rwnx_hw->sdiodev->bus_if->state == BUS_DOWN_ST) {
+			printk("%s bus is down %d\n", __func__, ret);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		}
+#endif
+		return ret;
+	} 
+#if 0
+	else {
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 				reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
 		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
+#endif
+	return 0;
 }
 
 #ifdef CONFIG_SCHED_SCAN
@@ -4965,16 +5005,16 @@ int rwnx_cfg80211_channel_switch (struct wiphy *wiphy,
 		INIT_WORK(&csa->work, rwnx_csa_finish);
 		rwnx_cfg80211_ch_switch_started_notify(dev
 					, &csa->chandef
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
 					, 0
 #endif
 					, params->count
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
 					, false
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
 					, params->block_tx
 #endif
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
 					, 0
 #endif
 					);
@@ -6031,7 +6071,7 @@ static int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw)
 	struct mm_set_rf_calib_cfm cfm;
 	int ret = 0;
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8801) {
 		ret = rwnx_send_txpwr_idx_req(rwnx_hw);
 		if (ret)
 			return ret;
@@ -6049,7 +6089,7 @@ static int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw)
 		ret = aicwf_set_rf_config_8800dc(rwnx_hw, &cfm);
 		if (ret)
 			return ret;
-	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		ret = aicwf_set_rf_config_8800d80(rwnx_hw, &cfm);
 		if (ret)
 			return ret;
@@ -6078,6 +6118,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 
 #ifdef AICWF_BSP_CTRL
 	aicbsp_get_feature(&feature);
+#ifdef AICWF_USB_SUPPORT
+	feature.chipinfo = aic_matched_ic;
+#endif
 #endif
 	get_random_bytes(&dflt_mac[4], 2);
 	/* create a new wiphy for use with cfg80211 */
@@ -6094,9 +6137,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	rwnx_hw->wiphy = wiphy;
 	rwnx_hw->plat = rwnx_plat;
 	rwnx_hw->dev = rwnx_platform_get_dev(rwnx_plat);
-	rwnx_hw->chipid = feature.chipinfo->chipid;
 	rwnx_hw->rev = feature.chipinfo->rev;
 	rwnx_hw->subrev = feature.chipinfo->subrev;
+	rwnx_hw->chipid = feature.chipinfo->chipid;
 #ifdef AICWF_SDIO_SUPPORT
 	rwnx_hw->sdiodev = rwnx_plat->sdiodev;
 	rwnx_plat->sdiodev->rwnx_hw = rwnx_hw;
@@ -6195,7 +6238,7 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	}
 #endif
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8801) {
 		ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, feature.hwinfo < 0, feature.hwinfo, feature.fwlog_en, &set_start_cfm);
 	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
 			rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
@@ -6512,6 +6555,11 @@ static int __init rwnx_mod_init(void)
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 	rwnx_print_version();
 
+#ifdef AICWF_USB_SUPPORT
+	sema_init(&aicwf_deinit_sem, 1);
+	atomic_set(&aicwf_deinit_atomic, 1);
+#endif
+
 #ifdef AICWF_BSP_CTRL
 	if (aicbsp_set_subsys(AIC_WIFI, AIC_PWR_ON) < 0) {
 		printk("%s, set power on fail!\n", __func__);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index c09b29ad86e1..ff2f76b0f43e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -894,10 +894,10 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 										   IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		mcs_map = rwnx_hw->mod_params->he_mcs_map;
-	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
+	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8800D ||
+			rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
 		mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
 	}
 
@@ -1028,10 +1028,10 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 										   IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 	#endif
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		mcs_map = rwnx_hw->mod_params->he_mcs_map;
-	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
+	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8801 ||
+		rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
 		mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
 	}
 
@@ -1143,10 +1143,10 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 											   IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 		#endif
 
-		if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+		if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 			mcs_map = rwnx_hw->mod_params->he_mcs_map;
-		} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
+		} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8801 ||
+			rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
 			mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
 		}
 
@@ -1324,15 +1324,11 @@ int rwnx_handle_dynparams(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	}
 #endif
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		rwnx_hw->mod_params->sgi80 = true;
 		rwnx_hw->mod_params->use_80 = true;
 	}
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
-		rwnx_hw->mod_params->use_80 = true;
-	}
-
 	/* Set wiphy parameters */
 	rwnx_set_wiphy_params(rwnx_hw, wiphy);
 	/* Set VHT capabilities */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 7d811efa54ba..f0078edcab5d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -721,9 +721,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 	const u8 *extcap_ie;
 	const struct ieee_types_extcap *extcap;
 	struct ieee80211_channel *chan;
-	struct cfg80211_bss *bss = NULL;
+	//struct cfg80211_bss *bss = NULL;
 	struct wireless_dev *wdev = NULL;
-	int retry_counter = 10;
+	//int retry_counter = 10;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 	if (rwnx_vif == NULL) {
@@ -844,60 +844,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 			rwnx_vif->wep_auth_err = true;
 			printk("con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
 		}
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	} else {
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}
 
 	printk("%s ind->roamed:%d ind->status_code:%d rwnx_vif->drv_conn_state:%d\r\n",
 			__func__, ind->roamed, ind->status_code, (int)atomic_read(&rwnx_vif->drv_conn_state));
 
-	do {
-		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 20, 0)))
-							wdev->u.client.ssid, wdev->u.client.ssid_len,
-#else
-							wdev->ssid, wdev->ssid_len,
-#endif
-							wdev->conn_bss_type,
-							IEEE80211_PRIVACY_ANY);
-
-		if (!bss) {
-			printk("%s bss is NULL \r\n", __func__);
-
-			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n",
-				__func__,
-				rwnx_vif->sta.ssid_len,
-				rwnx_vif->sta.ssid,
-				IEEE80211_BSS_TYPE_ESS,
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 20, 0)))
-				wdev->u.client.ssid_len,
-				wdev->u.client.ssid,
-#else
-				wdev->ssid_len,
-				wdev->ssid,
-#endif
-				wdev->conn_bss_type);
-
-			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__,
-				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
-				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
-
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41) && defined(KERNEL_AOSP)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 20, 0)))
-			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
-#else
-			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
-#endif
-			msleep(100);
-			retry_counter--;
-			if (retry_counter == 0) {
-				printk("%s bss recover fail \r\n", __func__);
-				break;
-			}
-		}
-	} while (!bss);
+	if (ind->status_code == 0 && (int)atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING){
+		printk("%s the disconnection has been requested, return it\r\n", __func__);
+		goto exit;
+	}
 
 	if (!ind->roamed) { //not roaming
 		cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
@@ -905,18 +863,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 								ind->assoc_rsp_ie_len, ind->status_code,
 								GFP_ATOMIC);
 		if (ind->status_code == 0) {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			printk("%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n",
+				__func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
 		} else {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
 		}
-		printk("%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state: %d \r\n",
-				__func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
 	} else { //roaming
 		if (ind->status_code != 0) {
 			printk("%s roaming fail to notify disconnect \r\n", __func__);
 			cfg80211_disconnected(dev, 0, NULL, 0, 1, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
 		} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
@@ -937,7 +895,6 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 			info.resp_ie_len = ind->assoc_rsp_ie_len;
 			printk("%s roaming success to notify roam \r\n", __func__);
 			cfg80211_roamed(dev, &info, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
 			chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
 			printk("%s roaming success to notify roam \r\n", __func__);
@@ -952,8 +909,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 				, ind->assoc_rsp_ie_len
 				, GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 		}
+		rwnx_vif->sta.is_roam = false;
 	}
 
 	if (ind->status_code == 0) {
@@ -961,6 +919,8 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 		netif_carrier_on(dev);
 	}
 
+exit:
+	rwnx_vif->sta.is_roam = false;
 	return 0;
 }
 
@@ -1009,7 +969,8 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 	struct aicwf_rx_priv *rx_priv;
 #endif
 
-	RWNX_DBG(RWNX_FN_ENTRY_STR);
+	//RWNX_DBG(RWNX_FN_ENTRY_STR);
+	printk("%s reason code:%d \r\n", __func__, ind->reason_code);
 
 	if ((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED) {
 		printk("%s, is already disconnected, drop disconnect ind", __func__);
@@ -1081,7 +1042,10 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 	rwnx_external_auth_disable(rwnx_vif);
 	rwnx_chanctx_unlink(rwnx_vif);
 
-	atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+	if (rwnx_vif->sta.is_roam == false) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+	}
+
 	return 0;
 }
 
@@ -1118,13 +1082,6 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 	}
 	printk("%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
 
-	if (wdev->conn_owner_nlportid != 0) {
-		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
-	} else {
-		printk("%s try to recover conn_owner_nlportid\r\n", __func__);
-		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
-	}
-
 	if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
 		(RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
 		(ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 3ba8abec9bed..cd0a1204fb3b 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -887,8 +887,8 @@ int rwnx_send_coex_req(struct rwnx_hw *rwnx_hw, u8_l disable_coexnull, u8_l enab
 	struct mm_set_coex_req *coex_req;
 	int error;
 
-	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)
-		&& rwnx_hw->cpmode == AICBSP_CPMODE_TEST)
+	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 ||
+		rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) && rwnx_hw->cpmode == AICBSP_CPMODE_TEST)
 		return 0;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
@@ -964,7 +964,7 @@ int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *
 	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800DW) {
 		rf_calib_req->cal_cfg_24g = 0x0f8f;
 		rf_calib_req->cal_cfg_5g = 0;
-	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	} else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		rf_calib_req->cal_cfg_24g = 0x0f8f;
 		rf_calib_req->cal_cfg_5g = 0x0f0f;
 	}
@@ -1375,7 +1375,7 @@ int rwnx_send_me_config_req(struct rwnx_hw *rwnx_hw)
 #endif
 	uint8_t *ht_mcs;
 	int i;
-	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)
+	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81)
 		&& rwnx_hw->cpmode == AICBSP_CPMODE_TEST)
 		return 0;
 
@@ -1473,7 +1473,7 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
 	struct wiphy *wiphy = rwnx_hw->wiphy;
 	int i;
 
-	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)
+	if ((rwnx_hw->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81)
 		&& rwnx_hw->cpmode == AICBSP_CPMODE_TEST)
 		return 0;
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index c733ef729332..43db90c9c1ed 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -620,9 +620,10 @@ void rwnx_plat_userconfig_parsing(struct rwnx_hw *rwnx_hw, char *buffer, int siz
 	}
 
 	efuse_idx = rwnx_hw->vendor_info;
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800DC  ||
+		rwnx_hw->chipid == PRODUCT_ID_AIC8800DW  ||
+		rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 ||
+		rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		efuse_idx = 0xFF;
 	} else  if (rwnx_hw->vendor_info == 0x00) {
 		printk("Empty efuse, using module0 config\n");
@@ -664,15 +665,21 @@ void rwnx_plat_userconfig_parsing(struct rwnx_hw *rwnx_hw, char *buffer, int siz
 		}
 	}
 
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80) {
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81) {
 		memcpy(&(nvram_info.txpwr_lvl_v3), &(nvram_info.txpwr_lvl_v2), sizeof(txpwr_lvl_conf_v2_t));
 	}
 	vfree(data);
 }
 
-#define FW_USERCONFIG_NAME_8800D    "aic/aic_userconfig.txt"
-#define FW_USERCONFIG_NAME_8800DC   "aic/aic8800dc/aic_userconfig_8800dc.txt"
-#define FW_USERCONFIG_NAME_8800D80  "aic/aic8800d80/aic_userconfig_8800d80.txt"
+#ifdef AICWF_SDIO_SUPPORT
+#define FW_USERCONFIG_NAME_8800D    "aic/sdio/aic_userconfig.txt"
+#define FW_USERCONFIG_NAME_8800DC   "aic/sdio/aic8800dc/aic_userconfig_8800dc.txt"
+#define FW_USERCONFIG_NAME_8800D80  "aic/sdio/aic8800d80/aic_userconfig_8800d80.txt"
+#elif AICWF_USB_SUPPORT
+#define FW_USERCONFIG_NAME_8800D    "aic/usb/aic_userconfig.txt"
+#define FW_USERCONFIG_NAME_8800DC   "aic/usb/aic8800dc/aic_userconfig_8800dc.txt"
+#define FW_USERCONFIG_NAME_8800D80  "aic/usb/aic8800d80/aic_userconfig_8800d80.txt"
+#endif
 
 int rwnx_plat_userconfig_upload_android(struct rwnx_hw *rwnx_hw, char *filename)
 {
@@ -715,11 +722,11 @@ static int rwnx_plat_fmac_load(struct rwnx_hw *rwnx_hw)
 	int ret = 0;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
-	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D)
+	if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D || rwnx_hw->chipid == PRODUCT_ID_AIC8801)
 		ret = rwnx_plat_userconfig_upload_android(rwnx_hw, FW_USERCONFIG_NAME_8800D);
 	else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800DC)
 		ret = rwnx_plat_userconfig_upload_android(rwnx_hw, FW_USERCONFIG_NAME_8800DC);
-	else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80)
+	else if (rwnx_hw->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->chipid == PRODUCT_ID_AIC8800D81)
 		ret = rwnx_plat_userconfig_upload_android(rwnx_hw, FW_USERCONFIG_NAME_8800D80);
 
 	return ret;
@@ -1025,6 +1032,9 @@ int rwnx_platform_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 	rwnx_plat->enabled = false;
+#ifdef AICWF_USB_SUPPORT
+	rwnx_plat->wait_disconnect_cb = false;
+#endif
 	g_rwnx_plat = rwnx_plat;
 
 #if defined CONFIG_RWNX_FULLMAC
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index ec65d9f531ae..b2ececa79666 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -77,6 +77,7 @@ struct rwnx_plat {
 
 #ifdef AICWF_USB_SUPPORT
 	struct aic_usb_dev *usbdev;
+	bool wait_disconnect_cb;
 #endif
 	bool enabled;
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index a96466f1b6f6..ae5839e2f240 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -362,6 +362,10 @@ static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *r
 
 	//printk("forward\n");
 
+#ifdef CONFIG_ALIGN_8BYTES
+	rwnx_skb_align_8bytes(rx_skb);
+#endif
+
 	rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 	REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
@@ -507,6 +511,10 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 			rwnx_vif->net_stats.rx_packets++;
 			rwnx_vif->net_stats.rx_bytes += rx_skb->len;
 
+#ifdef CONFIG_ALIGN_8BYTES
+			rwnx_skb_align_8bytes(rx_skb);
+#endif
+
 			rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 #ifdef AICWF_ARP_OFFLOAD
 			if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT)
@@ -1335,6 +1343,10 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
 		//printk("netif sn=%d, len=%d\n", precv_frame->attrib.seq_num, skb->len);
 
 		rx_skb->dev = rwnx_vif->ndev;
+
+#ifdef CONFIG_ALIGN_8BYTES
+		rwnx_skb_align_8bytes(rx_skb);
+#endif
 		rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 
 #ifdef AICWF_ARP_OFFLOAD
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
index f316fc71b43f..7521c92426c5 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
@@ -348,6 +348,9 @@ struct DHCPInfo {
 
 u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv);
 int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv);
+#ifdef CONFIG_USB_MSG_IN_EP
+int aicwf_process_msg_rxframes(struct aicwf_rx_priv *rx_priv);
+#endif
 
 #ifdef AICWF_ARP_OFFLOAD
 void arpoffload_proc(struct sk_buff *skb, struct rwnx_vif *rwnx_vif);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index 7e5b1e335c65..bdc85cc9bea9 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,5 +1,5 @@
 #define RWNX_VERS_REV    "241c091M (master)"
-#define DRV_RELEASE_DATE "20240730"
+#define DRV_RELEASE_DATE "20240919"
 #define DRV_PATCH_LEVEL  "004"
 #define RWNX_VERS_MOD    DRV_RELEASE_DATE "-" DRV_PATCH_LEVEL "-6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx " RWNX_VERS_MOD " - - " RWNX_VERS_REV
-- 
2.47.0

