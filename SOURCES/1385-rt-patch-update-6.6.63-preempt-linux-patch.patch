From 70dd069c583feb8f55fd7743ebfd30ba81f5e795 Mon Sep 17 00:00:00 2001
From: lijuan <juan.li@spacemit.com>
Date: Mon, 23 Dec 2024 16:31:33 +0800
Subject: [PATCH 1385/1448] rt-patch: update 6.6.63 preempt-linux patch

Change-Id: I86b9095455d8eaaf4b605ad3de2deaa93cf6f71a
Signed-off-by: lijuan <juan.li@spacemit.com>
---
 rt-linux/rt-linux-support.patch | 857 +++++++++++++++++++++++---------
 1 file changed, 610 insertions(+), 247 deletions(-)

diff --git a/rt-linux/rt-linux-support.patch b/rt-linux/rt-linux-support.patch
index d3ed9a12adc7..c5456e943eb0 100644
--- a/rt-linux/rt-linux-support.patch
+++ b/rt-linux/rt-linux-support.patch
@@ -1,3 +1,15 @@
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 9d4a12fb6bc8..9b15a117bf5d 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -4784,6 +4784,7 @@ S:	Maintained
+ F:	Documentation/admin-guide/module-signing.rst
+ F:	certs/
+ F:	scripts/sign-file.c
++F:	scripts/ssl-common.h
+ F:	tools/certs/
+ 
+ CFAG12864B LCD DRIVER
 diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
 index 57c0448d017a..e5a283851c02 100644
 --- a/arch/arm/Kconfig
@@ -260,7 +272,7 @@ index 7e8773a2d99d..9fde36fcb80c 100644
  EXPORT_SYMBOL(kernel_neon_end);
  
 diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
-index f9777ce2ccb2..9717c564daac 100644
+index 658c6a61ab6f..f5d5c265f438 100644
 --- a/arch/arm64/Kconfig
 +++ b/arch/arm64/Kconfig
 @@ -97,6 +97,7 @@ config ARM64
@@ -453,10 +465,10 @@ index b1e6d275cda9..9a8d3970da3c 100644
  }
  
 diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
-index 0327fcba0b6a..b39f552241a5 100644
+index 395e58a95299..92a6825c2933 100644
 --- a/arch/riscv/Kconfig
 +++ b/arch/riscv/Kconfig
-@@ -48,6 +48,7 @@ config RISCV
+@@ -49,6 +49,7 @@ config RISCV
  	select ARCH_SUPPORTS_HUGETLBFS if MMU
  	select ARCH_SUPPORTS_PAGE_TABLE_CHECK if MMU
  	select ARCH_SUPPORTS_PER_VMA_LOCK if MMU
@@ -464,7 +476,7 @@ index 0327fcba0b6a..b39f552241a5 100644
  	select ARCH_SUPPORTS_SHADOW_CALL_STACK if HAVE_SHADOW_CALL_STACK
  	select ARCH_USE_MEMTEST
  	select ARCH_USE_QUEUED_RWLOCKS
-@@ -136,6 +137,7 @@ config RISCV
+@@ -137,6 +138,7 @@ config RISCV
  	select HAVE_PERF_USER_STACK_DUMP
  	select HAVE_POSIX_CPU_TIMERS_TASK_WORK
  	select HAVE_PREEMPT_DYNAMIC_KEY if !XIP_KERNEL
@@ -472,41 +484,11 @@ index 0327fcba0b6a..b39f552241a5 100644
  	select HAVE_REGS_AND_STACK_ACCESS_API
  	select HAVE_RETHOOK if !XIP_KERNEL
  	select HAVE_RSEQ
-diff --git a/arch/riscv/configs/k1_rt_defconfig b/arch/riscv/configs/k1_rt_defconfig
-index e214683ef063..50312319ee15 100644
---- a/arch/riscv/configs/k1_rt_defconfig
-+++ b/arch/riscv/configs/k1_rt_defconfig
-@@ -44,6 +44,7 @@ CONFIG_INITRAMFS_SOURCE="rootfs.cpio.gz"
- # CONFIG_RD_ZSTD is not set
- CONFIG_BOOT_CONFIG=y
- CONFIG_EXPERT=y
-+CONFIG_KALLSYMS_ALL=y
- CONFIG_PROFILING=y
- CONFIG_SOC_SPACEMIT=y
- CONFIG_SOC_SPACEMIT_K1X=y
-@@ -877,7 +878,6 @@ CONFIG_SPACEMIT_K1X_SENSOR_V2=y
- # CONFIG_DVB_DRX39XYJ is not set
- # CONFIG_DVB_CXD2099 is not set
- # CONFIG_DVB_SP2 is not set
--# CONFIG_DRM_DEBUG_MODESET_LOCK is not set
- CONFIG_DRM_SPACEMIT=y
- CONFIG_SPACEMIT_MIPI_PANEL=y
- CONFIG_SPACEMIT_HDMI=y
-@@ -1309,9 +1309,6 @@ CONFIG_DEBUG_WX=y
- CONFIG_SCHED_STACK_END_CHECK=y
- CONFIG_KFENCE=y
- CONFIG_DETECT_HUNG_TASK=y
--CONFIG_LOCK_STAT=y
--CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
--CONFIG_DEBUG_RWSEMS=y
- CONFIG_DEBUG_ATOMIC_SLEEP=y
- # CONFIG_RCU_TRACE is not set
- # CONFIG_RUNTIME_TESTING_MENU is not set
 diff --git a/arch/riscv/include/asm/thread_info.h b/arch/riscv/include/asm/thread_info.h
-index 1047a97ddbc8..b42255e0b688 100644
+index eec9d4394f5b..7011a7aeb4e1 100644
 --- a/arch/riscv/include/asm/thread_info.h
 +++ b/arch/riscv/include/asm/thread_info.h
-@@ -95,6 +95,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
+@@ -99,6 +99,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
   * - pending work-to-be-done flags are in lowest half-word
   * - other flags in upper half-word(s)
   */
@@ -514,7 +496,7 @@ index 1047a97ddbc8..b42255e0b688 100644
  #define TIF_NOTIFY_RESUME	1	/* callback before returning to user */
  #define TIF_SIGPENDING		2	/* signal pending */
  #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
-@@ -110,6 +111,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
+@@ -114,6 +115,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
  #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
  #define _TIF_NOTIFY_SIGNAL	(1 << TIF_NOTIFY_SIGNAL)
  #define _TIF_UPROBE		(1 << TIF_UPROBE)
@@ -536,7 +518,7 @@ index 2f31a9caa113..9ceda02507ca 100644
  {
  	__do_softirq();
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 82d12c93feab..7bbf835fe725 100644
+index 05c82fd5d0f6..a29075276e1e 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
 @@ -118,6 +118,7 @@ config X86
@@ -579,11 +561,193 @@ index d63b02940747..1ff38ebbd588 100644
  #define _TIF_SINGLESTEP		(1 << TIF_SINGLESTEP)
  #define _TIF_SSBD		(1 << TIF_SSBD)
  #define _TIF_SPEC_IB		(1 << TIF_SPEC_IB)
+diff --git a/certs/Makefile b/certs/Makefile
+index f15eca11ea1e..801528f1c8d4 100644
+--- a/certs/Makefile
++++ b/certs/Makefile
+@@ -84,5 +84,5 @@ targets += x509_revocation_list
+ 
+ hostprogs := extract-cert
+ 
+-HOSTCFLAGS_extract-cert.o = $(shell $(HOSTPKG_CONFIG) --cflags libcrypto 2> /dev/null)
++HOSTCFLAGS_extract-cert.o = $(shell $(HOSTPKG_CONFIG) --cflags libcrypto 2> /dev/null) -I$(srctree)/scripts
+ HOSTLDLIBS_extract-cert = $(shell $(HOSTPKG_CONFIG) --libs libcrypto 2> /dev/null || echo -lcrypto)
+diff --git a/certs/extract-cert.c b/certs/extract-cert.c
+index 70e9ec89d87d..7d6d468ed612 100644
+--- a/certs/extract-cert.c
++++ b/certs/extract-cert.c
+@@ -21,14 +21,17 @@
+ #include <openssl/bio.h>
+ #include <openssl/pem.h>
+ #include <openssl/err.h>
+-#include <openssl/engine.h>
+-
+-/*
+- * OpenSSL 3.0 deprecates the OpenSSL's ENGINE API.
+- *
+- * Remove this if/when that API is no longer used
+- */
+-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
++#if OPENSSL_VERSION_MAJOR >= 3
++# define USE_PKCS11_PROVIDER
++# include <openssl/provider.h>
++# include <openssl/store.h>
++#else
++# if !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_DEPRECATED_3_0)
++#  define USE_PKCS11_ENGINE
++#  include <openssl/engine.h>
++# endif
++#endif
++#include "ssl-common.h"
+ 
+ #define PKEY_ID_PKCS7 2
+ 
+@@ -40,41 +43,6 @@ void format(void)
+ 	exit(2);
+ }
+ 
+-static void display_openssl_errors(int l)
+-{
+-	const char *file;
+-	char buf[120];
+-	int e, line;
+-
+-	if (ERR_peek_error() == 0)
+-		return;
+-	fprintf(stderr, "At main.c:%d:\n", l);
+-
+-	while ((e = ERR_get_error_line(&file, &line))) {
+-		ERR_error_string(e, buf);
+-		fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
+-	}
+-}
+-
+-static void drain_openssl_errors(void)
+-{
+-	const char *file;
+-	int line;
+-
+-	if (ERR_peek_error() == 0)
+-		return;
+-	while (ERR_get_error_line(&file, &line)) {}
+-}
+-
+-#define ERR(cond, fmt, ...)				\
+-	do {						\
+-		bool __cond = (cond);			\
+-		display_openssl_errors(__LINE__);	\
+-		if (__cond) {				\
+-			err(1, fmt, ## __VA_ARGS__);	\
+-		}					\
+-	} while(0)
+-
+ static const char *key_pass;
+ static BIO *wb;
+ static char *cert_dst;
+@@ -94,6 +62,66 @@ static void write_cert(X509 *x509)
+ 		fprintf(stderr, "Extracted cert: %s\n", buf);
+ }
+ 
++static X509 *load_cert_pkcs11(const char *cert_src)
++{
++	X509 *cert = NULL;
++#ifdef USE_PKCS11_PROVIDER
++	OSSL_STORE_CTX *store;
++
++	if (!OSSL_PROVIDER_try_load(NULL, "pkcs11", true))
++		ERR(1, "OSSL_PROVIDER_try_load(pkcs11)");
++	if (!OSSL_PROVIDER_try_load(NULL, "default", true))
++		ERR(1, "OSSL_PROVIDER_try_load(default)");
++
++	store = OSSL_STORE_open(cert_src, NULL, NULL, NULL, NULL);
++	ERR(!store, "OSSL_STORE_open");
++
++	while (!OSSL_STORE_eof(store)) {
++		OSSL_STORE_INFO *info = OSSL_STORE_load(store);
++
++		if (!info) {
++			drain_openssl_errors(__LINE__, 0);
++			continue;
++		}
++		if (OSSL_STORE_INFO_get_type(info) == OSSL_STORE_INFO_CERT) {
++			cert = OSSL_STORE_INFO_get1_CERT(info);
++			ERR(!cert, "OSSL_STORE_INFO_get1_CERT");
++		}
++		OSSL_STORE_INFO_free(info);
++		if (cert)
++			break;
++	}
++	OSSL_STORE_close(store);
++#elif defined(USE_PKCS11_ENGINE)
++		ENGINE *e;
++		struct {
++			const char *cert_id;
++			X509 *cert;
++		} parms;
++
++		parms.cert_id = cert_src;
++		parms.cert = NULL;
++
++		ENGINE_load_builtin_engines();
++		drain_openssl_errors(__LINE__, 1);
++		e = ENGINE_by_id("pkcs11");
++		ERR(!e, "Load PKCS#11 ENGINE");
++		if (ENGINE_init(e))
++			drain_openssl_errors(__LINE__, 1);
++		else
++			ERR(1, "ENGINE_init");
++		if (key_pass)
++			ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
++		ENGINE_ctrl_cmd(e, "LOAD_CERT_CTRL", 0, &parms, NULL, 1);
++		ERR(!parms.cert, "Get X.509 from PKCS#11");
++		cert = parms.cert;
++#else
++		fprintf(stderr, "no pkcs11 engine/provider available\n");
++		exit(1);
++#endif
++	return cert;
++}
++
+ int main(int argc, char **argv)
+ {
+ 	char *cert_src;
+@@ -122,28 +150,10 @@ int main(int argc, char **argv)
+ 		fclose(f);
+ 		exit(0);
+ 	} else if (!strncmp(cert_src, "pkcs11:", 7)) {
+-		ENGINE *e;
+-		struct {
+-			const char *cert_id;
+-			X509 *cert;
+-		} parms;
+-
+-		parms.cert_id = cert_src;
+-		parms.cert = NULL;
++		X509 *cert = load_cert_pkcs11(cert_src);
+ 
+-		ENGINE_load_builtin_engines();
+-		drain_openssl_errors();
+-		e = ENGINE_by_id("pkcs11");
+-		ERR(!e, "Load PKCS#11 ENGINE");
+-		if (ENGINE_init(e))
+-			drain_openssl_errors();
+-		else
+-			ERR(1, "ENGINE_init");
+-		if (key_pass)
+-			ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
+-		ENGINE_ctrl_cmd(e, "LOAD_CERT_CTRL", 0, &parms, NULL, 1);
+-		ERR(!parms.cert, "Get X.509 from PKCS#11");
+-		write_cert(parms.cert);
++		ERR(!cert, "load_cert_pkcs11 failed");
++		write_cert(cert);
+ 	} else {
+ 		BIO *b;
+ 		X509 *x509;
 diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
-index bd6a7857ce05..d45dfd10b636 100644
+index 831fa4a12159..5af3ebec0f74 100644
 --- a/drivers/acpi/processor_idle.c
 +++ b/drivers/acpi/processor_idle.c
-@@ -108,7 +108,7 @@ static const struct dmi_system_id processor_power_dmi_table[] = {
+@@ -107,7 +107,7 @@ static const struct dmi_system_id processor_power_dmi_table[] = {
   */
  static void __cpuidle acpi_safe_halt(void)
  {
@@ -593,7 +757,7 @@ index bd6a7857ce05..d45dfd10b636 100644
  		raw_local_irq_disable();
  	}
 diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c
-index 06673c6ca255..a5d0f7c06342 100644
+index 606f388c7a57..9d214fa088b0 100644
 --- a/drivers/block/zram/zram_drv.c
 +++ b/drivers/block/zram/zram_drv.c
 @@ -57,6 +57,41 @@ static void zram_free_page(struct zram *zram, size_t index);
@@ -1041,7 +1205,7 @@ index f2973cd1a8aa..aa77f8601b8a 100644
  
  void intel_breadcrumbs_free(struct kref *kref)
 diff --git a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
-index 42e09f158920..ac80e229f1cc 100644
+index 2065be5a196b..73d815fc514b 100644
 --- a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
 +++ b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
 @@ -1303,7 +1303,7 @@ static void execlists_dequeue(struct intel_engine_cs *engine)
@@ -1230,31 +1394,6 @@ index c61066498bf2..48e19e55d6b0 100644
  # define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) WARN_ON_ONCE((ATOMIC) && !in_atomic())
  #else
  # define _WAIT_FOR_ATOMIC_CHECK(ATOMIC) do { } while (0)
-diff --git a/drivers/i2c/busses/i2c-k1x.c b/drivers/i2c/busses/i2c-k1x.c
-index f1761704f182..551472b75223 100644
---- a/drivers/i2c/busses/i2c-k1x.c
-+++ b/drivers/i2c/busses/i2c-k1x.c
-@@ -1096,9 +1096,9 @@ static void spacemit_i2c_choose_xfer_mode(struct spacemit_i2c_dev *spacemit_i2c)
- 		timeout += (cnt - 1) * 220;
- 
- 	if (spacemit_i2c->xfer_mode == SPACEMIT_I2C_MODE_INTERRUPT)
--		spacemit_i2c->timeout = usecs_to_jiffies(timeout + 500000);
-+		spacemit_i2c->timeout = usecs_to_jiffies(timeout + 1500000000);
- 	else
--		spacemit_i2c->timeout = usecs_to_jiffies(timeout + 100000);
-+		spacemit_i2c->timeout = usecs_to_jiffies(timeout + 30000000);
- }
- 
- static void spacemit_i2c_init_xfer_params(struct spacemit_i2c_dev *spacemit_i2c)
-@@ -1928,7 +1928,7 @@ static int spacemit_i2c_probe(struct platform_device *pdev)
- 		}
- 
- 		ret = devm_request_irq(spacemit_i2c->dev, spacemit_i2c->irq, spacemit_i2c_int_handler,
--				IRQF_NO_SUSPEND | IRQF_NO_AUTOEN,
-+				IRQF_NO_SUSPEND | IRQF_NO_AUTOEN | IRQF_NO_THREAD,
- 				dev_name(spacemit_i2c->dev), spacemit_i2c);
- 		if (ret) {
- 			dev_err(spacemit_i2c->dev, "failed to request irq\n");
 diff --git a/drivers/tty/serial/21285.c b/drivers/tty/serial/21285.c
 index d756fcc884cb..4de0c975ebdc 100644
 --- a/drivers/tty/serial/21285.c
@@ -1703,10 +1842,10 @@ index 28f9a2679a20..33699e86eb52 100644
  	if (tty_termios_baud_rate(termios))
  		tty_termios_encode_baud_rate(termios, baud, baud);
 diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
-index 346167afe9e1..db5519ce0192 100644
+index 4caecc3525bf..d732ad6a7cd2 100644
 --- a/drivers/tty/serial/8250/8250_omap.c
 +++ b/drivers/tty/serial/8250/8250_omap.c
-@@ -401,7 +401,7 @@ static void omap_8250_set_termios(struct uart_port *port,
+@@ -405,7 +405,7 @@ static void omap_8250_set_termios(struct uart_port *port,
  	 * interrupts disabled.
  	 */
  	pm_runtime_get_sync(port->dev);
@@ -1715,7 +1854,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	/*
  	 * Update the per-port timeout.
-@@ -504,7 +504,7 @@ static void omap_8250_set_termios(struct uart_port *port,
+@@ -508,7 +508,7 @@ static void omap_8250_set_termios(struct uart_port *port,
  	}
  	omap8250_restore_regs(up);
  
@@ -1724,7 +1863,7 @@ index 346167afe9e1..db5519ce0192 100644
  	pm_runtime_mark_last_busy(port->dev);
  	pm_runtime_put_autosuspend(port->dev);
  
-@@ -529,7 +529,7 @@ static void omap_8250_pm(struct uart_port *port, unsigned int state,
+@@ -533,7 +533,7 @@ static void omap_8250_pm(struct uart_port *port, unsigned int state,
  	pm_runtime_get_sync(port->dev);
  
  	/* Synchronize UART_IER access against the console. */
@@ -1733,7 +1872,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
  	efr = serial_in(up, UART_EFR);
-@@ -541,7 +541,7 @@ static void omap_8250_pm(struct uart_port *port, unsigned int state,
+@@ -545,7 +545,7 @@ static void omap_8250_pm(struct uart_port *port, unsigned int state,
  	serial_out(up, UART_EFR, efr);
  	serial_out(up, UART_LCR, 0);
  
@@ -1742,7 +1881,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	pm_runtime_mark_last_busy(port->dev);
  	pm_runtime_put_autosuspend(port->dev);
-@@ -660,7 +660,7 @@ static irqreturn_t omap8250_irq(int irq, void *dev_id)
+@@ -676,7 +676,7 @@ static irqreturn_t omap8250_irq(int irq, void *dev_id)
  		unsigned long delay;
  
  		/* Synchronize UART_IER access against the console. */
@@ -1751,7 +1890,7 @@ index 346167afe9e1..db5519ce0192 100644
  		up->ier = port->serial_in(port, UART_IER);
  		if (up->ier & (UART_IER_RLSI | UART_IER_RDI)) {
  			port->ops->stop_rx(port);
-@@ -670,7 +670,7 @@ static irqreturn_t omap8250_irq(int irq, void *dev_id)
+@@ -686,7 +686,7 @@ static irqreturn_t omap8250_irq(int irq, void *dev_id)
  			 */
  			cancel_delayed_work(&up->overrun_backoff);
  		}
@@ -1760,7 +1899,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  		delay = msecs_to_jiffies(up->overrun_backoff_time_ms);
  		schedule_delayed_work(&up->overrun_backoff, delay);
-@@ -717,10 +717,10 @@ static int omap_8250_startup(struct uart_port *port)
+@@ -733,10 +733,10 @@ static int omap_8250_startup(struct uart_port *port)
  	}
  
  	/* Synchronize UART_IER access against the console. */
@@ -1773,7 +1912,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  #ifdef CONFIG_PM
  	up->capabilities |= UART_CAP_RPM;
-@@ -733,9 +733,9 @@ static int omap_8250_startup(struct uart_port *port)
+@@ -749,9 +749,9 @@ static int omap_8250_startup(struct uart_port *port)
  	serial_out(up, UART_OMAP_WER, priv->wer);
  
  	if (up->dma && !(priv->habit & UART_HAS_EFR2)) {
@@ -1785,7 +1924,7 @@ index 346167afe9e1..db5519ce0192 100644
  	}
  
  	enable_irq(up->port.irq);
-@@ -761,10 +761,10 @@ static void omap_8250_shutdown(struct uart_port *port)
+@@ -777,10 +777,10 @@ static void omap_8250_shutdown(struct uart_port *port)
  		serial_out(up, UART_OMAP_EFR2, 0x0);
  
  	/* Synchronize UART_IER access against the console. */
@@ -1798,7 +1937,7 @@ index 346167afe9e1..db5519ce0192 100644
  	disable_irq_nosync(up->port.irq);
  	dev_pm_clear_wake_irq(port->dev);
  
-@@ -789,10 +789,10 @@ static void omap_8250_throttle(struct uart_port *port)
+@@ -805,10 +805,10 @@ static void omap_8250_throttle(struct uart_port *port)
  
  	pm_runtime_get_sync(port->dev);
  
@@ -1811,7 +1950,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	pm_runtime_mark_last_busy(port->dev);
  	pm_runtime_put_autosuspend(port->dev);
-@@ -807,14 +807,14 @@ static void omap_8250_unthrottle(struct uart_port *port)
+@@ -823,14 +823,14 @@ static void omap_8250_unthrottle(struct uart_port *port)
  	pm_runtime_get_sync(port->dev);
  
  	/* Synchronize UART_IER access against the console. */
@@ -1828,7 +1967,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	pm_runtime_mark_last_busy(port->dev);
  	pm_runtime_put_autosuspend(port->dev);
-@@ -958,7 +958,7 @@ static void __dma_rx_complete(void *param)
+@@ -974,7 +974,7 @@ static void __dma_rx_complete(void *param)
  	unsigned long flags;
  
  	/* Synchronize UART_IER access against the console. */
@@ -1837,7 +1976,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	/*
  	 * If the tx status is not DMA_COMPLETE, then this is a delayed
-@@ -967,7 +967,7 @@ static void __dma_rx_complete(void *param)
+@@ -983,7 +983,7 @@ static void __dma_rx_complete(void *param)
  	 */
  	if (dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state) !=
  			DMA_COMPLETE) {
@@ -1846,7 +1985,7 @@ index 346167afe9e1..db5519ce0192 100644
  		return;
  	}
  	__dma_rx_do_complete(p);
-@@ -978,7 +978,7 @@ static void __dma_rx_complete(void *param)
+@@ -994,7 +994,7 @@ static void __dma_rx_complete(void *param)
  			omap_8250_rx_dma(p);
  	}
  
@@ -1855,7 +1994,7 @@ index 346167afe9e1..db5519ce0192 100644
  }
  
  static void omap_8250_rx_dma_flush(struct uart_8250_port *p)
-@@ -1083,7 +1083,7 @@ static void omap_8250_dma_tx_complete(void *param)
+@@ -1099,7 +1099,7 @@ static void omap_8250_dma_tx_complete(void *param)
  	dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
  				UART_XMIT_SIZE, DMA_TO_DEVICE);
  
@@ -1864,7 +2003,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	dma->tx_running = 0;
  
-@@ -1112,7 +1112,7 @@ static void omap_8250_dma_tx_complete(void *param)
+@@ -1128,7 +1128,7 @@ static void omap_8250_dma_tx_complete(void *param)
  		serial8250_set_THRI(p);
  	}
  
@@ -1873,7 +2012,7 @@ index 346167afe9e1..db5519ce0192 100644
  }
  
  static int omap_8250_tx_dma(struct uart_8250_port *p)
-@@ -1278,7 +1278,7 @@ static int omap_8250_dma_handle_irq(struct uart_port *port)
+@@ -1294,7 +1294,7 @@ static int omap_8250_dma_handle_irq(struct uart_port *port)
  		return IRQ_HANDLED;
  	}
  
@@ -1882,7 +2021,7 @@ index 346167afe9e1..db5519ce0192 100644
  
  	status = serial_port_in(port, UART_LSR);
  
-@@ -1758,15 +1758,15 @@ static int omap8250_runtime_resume(struct device *dev)
+@@ -1774,15 +1774,15 @@ static int omap8250_runtime_resume(struct device *dev)
  		up = serial8250_get_port(priv->line);
  
  	if (up && omap8250_lost_context(up)) {
@@ -3282,7 +3421,7 @@ index ad4ae19b6ce3..1aa5b2b49c26 100644
  
  static struct console arc_console = {
 diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
-index 88cdafa5ac54..1946fafc3f3e 100644
+index bcca5627afac..5a3f2fc476f9 100644
 --- a/drivers/tty/serial/atmel_serial.c
 +++ b/drivers/tty/serial/atmel_serial.c
 @@ -861,7 +861,7 @@ static void atmel_complete_tx_dma(void *arg)
@@ -3365,7 +3504,7 @@ index 88cdafa5ac54..1946fafc3f3e 100644
  	}
  }
 diff --git a/drivers/tty/serial/bcm63xx_uart.c b/drivers/tty/serial/bcm63xx_uart.c
-index 0dd8cceb837c..4a08fd5ee61b 100644
+index 44c27e5cefbc..b104c36ce5c0 100644
 --- a/drivers/tty/serial/bcm63xx_uart.c
 +++ b/drivers/tty/serial/bcm63xx_uart.c
 @@ -201,7 +201,7 @@ static void bcm_uart_break_ctl(struct uart_port *port, int ctl)
@@ -3386,7 +3525,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  }
  
  /*
-@@ -332,7 +332,7 @@ static irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)
+@@ -335,7 +335,7 @@ static irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)
  	unsigned int irqstat;
  
  	port = dev_id;
@@ -3395,7 +3534,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  
  	irqstat = bcm_uart_readl(port, UART_IR_REG);
  	if (irqstat & UART_RX_INT_STAT)
-@@ -353,7 +353,7 @@ static irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)
+@@ -356,7 +356,7 @@ static irqreturn_t bcm_uart_interrupt(int irq, void *dev_id)
  					       estat & UART_EXTINP_DCD_MASK);
  	}
  
@@ -3404,7 +3543,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  	return IRQ_HANDLED;
  }
  
-@@ -451,9 +451,9 @@ static void bcm_uart_shutdown(struct uart_port *port)
+@@ -454,9 +454,9 @@ static void bcm_uart_shutdown(struct uart_port *port)
  {
  	unsigned long flags;
  
@@ -3416,7 +3555,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  
  	bcm_uart_disable(port);
  	bcm_uart_flush(port);
-@@ -470,7 +470,7 @@ static void bcm_uart_set_termios(struct uart_port *port, struct ktermios *new,
+@@ -473,7 +473,7 @@ static void bcm_uart_set_termios(struct uart_port *port, struct ktermios *new,
  	unsigned long flags;
  	int tries;
  
@@ -3425,7 +3564,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  
  	/* Drain the hot tub fully before we power it off for the winter. */
  	for (tries = 3; !bcm_uart_tx_empty(port) && tries; tries--)
-@@ -546,7 +546,7 @@ static void bcm_uart_set_termios(struct uart_port *port, struct ktermios *new,
+@@ -549,7 +549,7 @@ static void bcm_uart_set_termios(struct uart_port *port, struct ktermios *new,
  
  	uart_update_timeout(port, new->c_cflag, baud);
  	bcm_uart_enable(port);
@@ -3434,7 +3573,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  }
  
  /*
-@@ -712,9 +712,9 @@ static void bcm_console_write(struct console *co, const char *s,
+@@ -715,9 +715,9 @@ static void bcm_console_write(struct console *co, const char *s,
  		/* bcm_uart_interrupt() already took the lock */
  		locked = 0;
  	} else if (oops_in_progress) {
@@ -3446,7 +3585,7 @@ index 0dd8cceb837c..4a08fd5ee61b 100644
  		locked = 1;
  	}
  
-@@ -725,7 +725,7 @@ static void bcm_console_write(struct console *co, const char *s,
+@@ -728,7 +728,7 @@ static void bcm_console_write(struct console *co, const char *s,
  	wait_for_xmitr(port);
  
  	if (locked)
@@ -3798,7 +3937,7 @@ index 249cb380c3c6..7fa809a405e8 100644
  
  /*
 diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
-index 385b41275e8b..71d0cbd74807 100644
+index 8bd0f8e45b14..58c2c460ccd8 100644
 --- a/drivers/tty/serial/fsl_lpuart.c
 +++ b/drivers/tty/serial/fsl_lpuart.c
 @@ -532,9 +532,9 @@ static void lpuart_dma_tx_complete(void *arg)
@@ -4100,7 +4239,7 @@ index 385b41275e8b..71d0cbd74807 100644
  }
  
  /*
-@@ -3092,7 +3092,7 @@ static int lpuart_suspend(struct device *dev)
+@@ -3093,7 +3093,7 @@ static int lpuart_suspend(struct device *dev)
  	uart_suspend_port(&lpuart_reg, &sport->port);
  
  	if (lpuart_uport_is_active(sport)) {
@@ -4109,7 +4248,7 @@ index 385b41275e8b..71d0cbd74807 100644
  		if (lpuart_is_32(sport)) {
  			/* disable Rx/Tx and interrupts */
  			temp = lpuart32_read(&sport->port, UARTCTRL);
-@@ -3104,7 +3104,7 @@ static int lpuart_suspend(struct device *dev)
+@@ -3105,7 +3105,7 @@ static int lpuart_suspend(struct device *dev)
  			temp &= ~(UARTCR2_TE | UARTCR2_TIE | UARTCR2_TCIE);
  			writeb(temp, sport->port.membase + UARTCR2);
  		}
@@ -4118,7 +4257,7 @@ index 385b41275e8b..71d0cbd74807 100644
  
  		if (sport->lpuart_dma_rx_use) {
  			/*
-@@ -3117,7 +3117,7 @@ static int lpuart_suspend(struct device *dev)
+@@ -3118,7 +3118,7 @@ static int lpuart_suspend(struct device *dev)
  			lpuart_dma_rx_free(&sport->port);
  
  			/* Disable Rx DMA to use UART port as wakeup source */
@@ -4127,7 +4266,7 @@ index 385b41275e8b..71d0cbd74807 100644
  			if (lpuart_is_32(sport)) {
  				temp = lpuart32_read(&sport->port, UARTBAUD);
  				lpuart32_write(&sport->port, temp & ~UARTBAUD_RDMAE,
-@@ -3126,11 +3126,11 @@ static int lpuart_suspend(struct device *dev)
+@@ -3127,11 +3127,11 @@ static int lpuart_suspend(struct device *dev)
  				writeb(readb(sport->port.membase + UARTCR5) &
  				       ~UARTCR5_RDMAS, sport->port.membase + UARTCR5);
  			}
@@ -4141,7 +4280,7 @@ index 385b41275e8b..71d0cbd74807 100644
  			if (lpuart_is_32(sport)) {
  				temp = lpuart32_read(&sport->port, UARTBAUD);
  				temp &= ~UARTBAUD_TDMAE;
-@@ -3140,7 +3140,7 @@ static int lpuart_suspend(struct device *dev)
+@@ -3141,7 +3141,7 @@ static int lpuart_suspend(struct device *dev)
  				temp &= ~UARTCR5_TDMAS;
  				writeb(temp, sport->port.membase + UARTCR5);
  			}
@@ -4266,10 +4405,10 @@ index 819f957b6b84..a75eafbcbea3 100644
  
  static const char *icom_type(struct uart_port *port)
 diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
-index a1476e47c6aa..b072cee52cb1 100644
+index 349d4849ba5e..3934ab8fef14 100644
 --- a/drivers/tty/serial/imx.c
 +++ b/drivers/tty/serial/imx.c
-@@ -585,7 +585,7 @@ static void imx_uart_dma_tx_callback(void *data)
+@@ -586,7 +586,7 @@ static void imx_uart_dma_tx_callback(void *data)
  	unsigned long flags;
  	u32 ucr1;
  
@@ -4278,7 +4417,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	dma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);
  
-@@ -610,7 +610,7 @@ static void imx_uart_dma_tx_callback(void *data)
+@@ -611,7 +611,7 @@ static void imx_uart_dma_tx_callback(void *data)
  		imx_uart_writel(sport, ucr4, UCR4);
  	}
  
@@ -4287,7 +4426,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  }
  
  /* called with port.lock taken and irqs off */
-@@ -781,11 +781,11 @@ static irqreturn_t imx_uart_rtsint(int irq, void *dev_id)
+@@ -797,11 +797,11 @@ static irqreturn_t imx_uart_rtsint(int irq, void *dev_id)
  	struct imx_port *sport = dev_id;
  	irqreturn_t ret;
  
@@ -4301,7 +4440,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return ret;
  }
-@@ -794,9 +794,9 @@ static irqreturn_t imx_uart_txint(int irq, void *dev_id)
+@@ -810,9 +810,9 @@ static irqreturn_t imx_uart_txint(int irq, void *dev_id)
  {
  	struct imx_port *sport = dev_id;
  
@@ -4313,7 +4452,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  	return IRQ_HANDLED;
  }
  
-@@ -910,11 +910,11 @@ static irqreturn_t imx_uart_rxint(int irq, void *dev_id)
+@@ -926,11 +926,11 @@ static irqreturn_t imx_uart_rxint(int irq, void *dev_id)
  	struct imx_port *sport = dev_id;
  	irqreturn_t ret;
  
@@ -4327,7 +4466,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return ret;
  }
-@@ -977,7 +977,7 @@ static irqreturn_t imx_uart_int(int irq, void *dev_id)
+@@ -993,7 +993,7 @@ static irqreturn_t imx_uart_int(int irq, void *dev_id)
  	unsigned int usr1, usr2, ucr1, ucr2, ucr3, ucr4;
  	irqreturn_t ret = IRQ_NONE;
  
@@ -4336,7 +4475,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	usr1 = imx_uart_readl(sport, USR1);
  	usr2 = imx_uart_readl(sport, USR2);
-@@ -1047,7 +1047,7 @@ static irqreturn_t imx_uart_int(int irq, void *dev_id)
+@@ -1063,7 +1063,7 @@ static irqreturn_t imx_uart_int(int irq, void *dev_id)
  		ret = IRQ_HANDLED;
  	}
  
@@ -4345,7 +4484,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return ret;
  }
-@@ -1130,7 +1130,7 @@ static void imx_uart_break_ctl(struct uart_port *port, int break_state)
+@@ -1146,7 +1146,7 @@ static void imx_uart_break_ctl(struct uart_port *port, int break_state)
  	unsigned long flags;
  	u32 ucr1;
  
@@ -4354,7 +4493,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	ucr1 = imx_uart_readl(sport, UCR1) & ~UCR1_SNDBRK;
  
-@@ -1139,7 +1139,7 @@ static void imx_uart_break_ctl(struct uart_port *port, int break_state)
+@@ -1155,7 +1155,7 @@ static void imx_uart_break_ctl(struct uart_port *port, int break_state)
  
  	imx_uart_writel(sport, ucr1, UCR1);
  
@@ -4363,7 +4502,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  }
  
  /*
-@@ -1152,9 +1152,9 @@ static void imx_uart_timeout(struct timer_list *t)
+@@ -1168,9 +1168,9 @@ static void imx_uart_timeout(struct timer_list *t)
  	unsigned long flags;
  
  	if (sport->port.state) {
@@ -4375,7 +4514,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
  	}
-@@ -1184,9 +1184,9 @@ static void imx_uart_dma_rx_callback(void *data)
+@@ -1200,9 +1200,9 @@ static void imx_uart_dma_rx_callback(void *data)
  	status = dmaengine_tx_status(chan, sport->rx_cookie, &state);
  
  	if (status == DMA_ERROR) {
@@ -4387,7 +4526,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  		return;
  	}
  
-@@ -1215,9 +1215,9 @@ static void imx_uart_dma_rx_callback(void *data)
+@@ -1231,9 +1231,9 @@ static void imx_uart_dma_rx_callback(void *data)
  		r_bytes = rx_ring->head - rx_ring->tail;
  
  		/* If we received something, check for 0xff flood */
@@ -4399,7 +4538,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  		if (!(sport->port.ignore_status_mask & URXD_DUMMY_READ)) {
  
-@@ -1475,7 +1475,7 @@ static int imx_uart_startup(struct uart_port *port)
+@@ -1491,7 +1491,7 @@ static int imx_uart_startup(struct uart_port *port)
  	if (!uart_console(port) && imx_uart_dma_init(sport) == 0)
  		dma_is_inited = 1;
  
@@ -4408,7 +4547,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	/* Reset fifo's and state machines */
  	imx_uart_soft_reset(sport);
-@@ -1548,7 +1548,7 @@ static int imx_uart_startup(struct uart_port *port)
+@@ -1564,7 +1564,7 @@ static int imx_uart_startup(struct uart_port *port)
  
  	imx_uart_disable_loopback_rs485(sport);
  
@@ -4417,7 +4556,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return 0;
  }
-@@ -1573,21 +1573,21 @@ static void imx_uart_shutdown(struct uart_port *port)
+@@ -1589,21 +1589,21 @@ static void imx_uart_shutdown(struct uart_port *port)
  			sport->dma_is_rxing = 0;
  		}
  
@@ -4443,7 +4582,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	/*
  	 * Stop our timer.
-@@ -1598,7 +1598,7 @@ static void imx_uart_shutdown(struct uart_port *port)
+@@ -1614,7 +1614,7 @@ static void imx_uart_shutdown(struct uart_port *port)
  	 * Disable all interrupts, port and break condition.
  	 */
  
@@ -4452,7 +4591,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	ucr1 = imx_uart_readl(sport, UCR1);
  	ucr1 &= ~(UCR1_TRDYEN | UCR1_RRDYEN | UCR1_RTSDEN | UCR1_RXDMAEN |
-@@ -1620,7 +1620,7 @@ static void imx_uart_shutdown(struct uart_port *port)
+@@ -1636,7 +1636,7 @@ static void imx_uart_shutdown(struct uart_port *port)
  	ucr4 &= ~UCR4_TCEN;
  	imx_uart_writel(sport, ucr4, UCR4);
  
@@ -4461,7 +4600,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	clk_disable_unprepare(sport->clk_per);
  	clk_disable_unprepare(sport->clk_ipg);
-@@ -1683,7 +1683,7 @@ imx_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+@@ -1699,7 +1699,7 @@ imx_uart_set_termios(struct uart_port *port, struct ktermios *termios,
  	baud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);
  	quot = uart_get_divisor(port, baud);
  
@@ -4470,7 +4609,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	/*
  	 * Read current UCR2 and save it for future use, then clear all the bits
-@@ -1811,7 +1811,7 @@ imx_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+@@ -1827,7 +1827,7 @@ imx_uart_set_termios(struct uart_port *port, struct ktermios *termios,
  	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
  		imx_uart_enable_ms(&sport->port);
  
@@ -4479,7 +4618,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  }
  
  static const char *imx_uart_type(struct uart_port *port)
-@@ -1873,7 +1873,7 @@ static int imx_uart_poll_init(struct uart_port *port)
+@@ -1889,7 +1889,7 @@ static int imx_uart_poll_init(struct uart_port *port)
  
  	imx_uart_setup_ufcr(sport, TXTL_DEFAULT, RXTL_DEFAULT);
  
@@ -4488,7 +4627,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	/*
  	 * Be careful about the order of enabling bits here. First enable the
-@@ -1901,7 +1901,7 @@ static int imx_uart_poll_init(struct uart_port *port)
+@@ -1917,7 +1917,7 @@ static int imx_uart_poll_init(struct uart_port *port)
  	imx_uart_writel(sport, ucr1 | UCR1_RRDYEN, UCR1);
  	imx_uart_writel(sport, ucr2 | UCR2_ATEN, UCR2);
  
@@ -4497,7 +4636,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return 0;
  }
-@@ -2016,9 +2016,9 @@ imx_uart_console_write(struct console *co, const char *s, unsigned int count)
+@@ -2037,9 +2037,9 @@ imx_uart_console_write(struct console *co, const char *s, unsigned int count)
  	if (sport->port.sysrq)
  		locked = 0;
  	else if (oops_in_progress)
@@ -4509,7 +4648,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	/*
  	 *	First, save UCR1/2/3 and then disable interrupts
-@@ -2046,7 +2046,7 @@ imx_uart_console_write(struct console *co, const char *s, unsigned int count)
+@@ -2067,7 +2067,7 @@ imx_uart_console_write(struct console *co, const char *s, unsigned int count)
  	imx_uart_ucrs_restore(sport, &old_ucr);
  
  	if (locked)
@@ -4518,7 +4657,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  }
  
  /*
-@@ -2204,10 +2204,10 @@ static enum hrtimer_restart imx_trigger_start_tx(struct hrtimer *t)
+@@ -2225,10 +2225,10 @@ static enum hrtimer_restart imx_trigger_start_tx(struct hrtimer *t)
  	struct imx_port *sport = container_of(t, struct imx_port, trigger_start_tx);
  	unsigned long flags;
  
@@ -4531,7 +4670,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return HRTIMER_NORESTART;
  }
-@@ -2217,10 +2217,10 @@ static enum hrtimer_restart imx_trigger_stop_tx(struct hrtimer *t)
+@@ -2238,10 +2238,10 @@ static enum hrtimer_restart imx_trigger_stop_tx(struct hrtimer *t)
  	struct imx_port *sport = container_of(t, struct imx_port, trigger_stop_tx);
  	unsigned long flags;
  
@@ -4544,7 +4683,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  
  	return HRTIMER_NORESTART;
  }
-@@ -2487,9 +2487,9 @@ static void imx_uart_restore_context(struct imx_port *sport)
+@@ -2508,9 +2508,9 @@ static void imx_uart_restore_context(struct imx_port *sport)
  {
  	unsigned long flags;
  
@@ -4556,7 +4695,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  		return;
  	}
  
-@@ -2504,7 +2504,7 @@ static void imx_uart_restore_context(struct imx_port *sport)
+@@ -2525,7 +2525,7 @@ static void imx_uart_restore_context(struct imx_port *sport)
  	imx_uart_writel(sport, sport->saved_reg[2], UCR3);
  	imx_uart_writel(sport, sport->saved_reg[3], UCR4);
  	sport->context_saved = false;
@@ -4565,7 +4704,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  }
  
  static void imx_uart_save_context(struct imx_port *sport)
-@@ -2512,7 +2512,7 @@ static void imx_uart_save_context(struct imx_port *sport)
+@@ -2533,7 +2533,7 @@ static void imx_uart_save_context(struct imx_port *sport)
  	unsigned long flags;
  
  	/* Save necessary regs */
@@ -4574,7 +4713,7 @@ index a1476e47c6aa..b072cee52cb1 100644
  	sport->saved_reg[0] = imx_uart_readl(sport, UCR1);
  	sport->saved_reg[1] = imx_uart_readl(sport, UCR2);
  	sport->saved_reg[2] = imx_uart_readl(sport, UCR3);
-@@ -2524,7 +2524,7 @@ static void imx_uart_save_context(struct imx_port *sport)
+@@ -2545,7 +2545,7 @@ static void imx_uart_save_context(struct imx_port *sport)
  	sport->saved_reg[8] = imx_uart_readl(sport, UBMR);
  	sport->saved_reg[9] = imx_uart_readl(sport, IMX21_UTS);
  	sport->context_saved = true;
@@ -5007,7 +5146,7 @@ index b38fe4728c26..5149a947b7fe 100644
  	/* Don't rewrite B0 */
  	if (tty_termios_baud_rate(termios))
 diff --git a/drivers/tty/serial/ma35d1_serial.c b/drivers/tty/serial/ma35d1_serial.c
-index 69da24565b99..73910c54d6be 100644
+index 99225f1e02ac..faccd772c68c 100644
 --- a/drivers/tty/serial/ma35d1_serial.c
 +++ b/drivers/tty/serial/ma35d1_serial.c
 @@ -269,16 +269,16 @@ static void receive_chars(struct uart_ma35d1_port *up)
@@ -5088,7 +5227,7 @@ index 69da24565b99..73910c54d6be 100644
  
  static int __init ma35d1serial_console_setup(struct console *co, char *options)
 diff --git a/drivers/tty/serial/mcf.c b/drivers/tty/serial/mcf.c
-index 1666ce012e5e..91b15243f6c6 100644
+index aea29b4e6567..ee40af20a08f 100644
 --- a/drivers/tty/serial/mcf.c
 +++ b/drivers/tty/serial/mcf.c
 @@ -135,12 +135,12 @@ static void mcf_break_ctl(struct uart_port *port, int break_state)
@@ -6452,7 +6591,7 @@ index 73c60f5ea027..46e70e155aab 100644
  	clk_disable(up->clk);
  
 diff --git a/drivers/tty/serial/pxa_k1x.c b/drivers/tty/serial/pxa_k1x.c
-index af1d2d0cad70..b1a182b71b4b 100644
+index 6db39ca8a77b..571b6935218e 100644
 --- a/drivers/tty/serial/pxa_k1x.c
 +++ b/drivers/tty/serial/pxa_k1x.c
 @@ -175,13 +175,13 @@ static inline void stop_dma(struct uart_pxa_port *up, int read)
@@ -6782,7 +6921,7 @@ index af1d2d0cad70..b1a182b71b4b 100644
  	clk_disable(up->fclk);
  	clk_disable(up->gclk);
  }
-@@ -1937,9 +1933,9 @@ static int serial_pxa_suspend(struct device *dev)
+@@ -1943,9 +1939,9 @@ static int serial_pxa_suspend(struct device *dev)
  		if (dma_async_is_tx_complete(pxa_dma->rxdma_chan,
  				pxa_dma->rx_cookie, NULL, NULL) != DMA_COMPLETE) {
  			/* before stop receive, de-assert RTS */
@@ -6795,10 +6934,10 @@ index af1d2d0cad70..b1a182b71b4b 100644
  			dmaengine_pause(pxa_dma->rxdma_chan);
  			udelay(100);
 diff --git a/drivers/tty/serial/qcom_geni_serial.c b/drivers/tty/serial/qcom_geni_serial.c
-index 2e1b1c827dfe..549909644011 100644
+index f820a09cb5c3..a7db08431ef3 100644
 --- a/drivers/tty/serial/qcom_geni_serial.c
 +++ b/drivers/tty/serial/qcom_geni_serial.c
-@@ -482,9 +482,9 @@ static void qcom_geni_serial_console_write(struct console *co, const char *s,
+@@ -492,9 +492,9 @@ static void qcom_geni_serial_console_write(struct console *co, const char *s,
  
  	uport = &port->uport;
  	if (oops_in_progress)
@@ -6810,7 +6949,7 @@ index 2e1b1c827dfe..549909644011 100644
  
  	geni_status = readl(uport->membase + SE_GENI_STATUS);
  
-@@ -520,7 +520,7 @@ static void qcom_geni_serial_console_write(struct console *co, const char *s,
+@@ -530,7 +530,7 @@ static void qcom_geni_serial_console_write(struct console *co, const char *s,
  		qcom_geni_serial_setup_tx(uport, port->tx_remaining);
  
  	if (locked)
@@ -6819,7 +6958,7 @@ index 2e1b1c827dfe..549909644011 100644
  }
  
  static void handle_rx_console(struct uart_port *uport, u32 bytes, bool drop)
-@@ -972,7 +972,7 @@ static irqreturn_t qcom_geni_serial_isr(int isr, void *dev)
+@@ -992,7 +992,7 @@ static irqreturn_t qcom_geni_serial_isr(int isr, void *dev)
  	if (uport->suspended)
  		return IRQ_NONE;
  
@@ -6970,7 +7109,7 @@ index be5c842b5ba9..d824c8318f33 100644
  	local_irq_restore(flags);
  }
 diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
-index de220ac8ca54..d46a81cddfcd 100644
+index 5a1de6044b38..45be2b88168e 100644
 --- a/drivers/tty/serial/rp2.c
 +++ b/drivers/tty/serial/rp2.c
 @@ -276,9 +276,9 @@ static unsigned int rp2_uart_tx_empty(struct uart_port *port)
@@ -7550,7 +7689,7 @@ index d4ec943cb8e9..6d4006b41975 100644
  
  static const char *tegra_uart_type(struct uart_port *u)
 diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
-index 2eceef54e0b3..6cd64ccc2035 100644
+index 8ff0efac6aa0..398104760fbc 100644
 --- a/drivers/tty/serial/serial_core.c
 +++ b/drivers/tty/serial/serial_core.c
 @@ -79,7 +79,7 @@ static inline void uart_port_deref(struct uart_port *uport)
@@ -7604,7 +7743,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  }
  
  /*
-@@ -715,11 +715,11 @@ static void uart_send_xchar(struct tty_struct *tty, char ch)
+@@ -717,11 +717,11 @@ static void uart_send_xchar(struct tty_struct *tty, char ch)
  	if (port->ops->send_xchar)
  		port->ops->send_xchar(port, ch);
  	else {
@@ -7618,7 +7757,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	}
  	uart_port_deref(port);
  }
-@@ -1098,9 +1098,9 @@ static int uart_tiocmget(struct tty_struct *tty)
+@@ -1108,9 +1108,9 @@ static int uart_tiocmget(struct tty_struct *tty)
  
  	if (!tty_io_error(tty)) {
  		result = uport->mctrl;
@@ -7630,7 +7769,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	}
  out:
  	mutex_unlock(&port->mutex);
-@@ -1236,16 +1236,16 @@ static int uart_wait_modem_status(struct uart_state *state, unsigned long arg)
+@@ -1246,16 +1246,16 @@ static int uart_wait_modem_status(struct uart_state *state, unsigned long arg)
  	uport = uart_port_ref(state);
  	if (!uport)
  		return -EIO;
@@ -7651,7 +7790,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  		set_current_state(TASK_INTERRUPTIBLE);
  
-@@ -1290,9 +1290,9 @@ static int uart_get_icount(struct tty_struct *tty,
+@@ -1300,9 +1300,9 @@ static int uart_get_icount(struct tty_struct *tty,
  	uport = uart_port_ref(state);
  	if (!uport)
  		return -EIO;
@@ -7663,7 +7802,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	uart_port_deref(uport);
  
  	icount->cts         = cnow.cts;
-@@ -1445,9 +1445,9 @@ static int uart_rs485_config(struct uart_port *port)
+@@ -1455,9 +1455,9 @@ static int uart_rs485_config(struct uart_port *port)
  	uart_set_rs485_termination(port, rs485);
  	uart_set_rs485_rx_during_tx(port, rs485);
  
@@ -7675,7 +7814,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	if (ret) {
  		memset(rs485, 0, sizeof(*rs485));
  		/* unset GPIOs */
-@@ -1464,9 +1464,9 @@ static int uart_get_rs485_config(struct uart_port *port,
+@@ -1474,9 +1474,9 @@ static int uart_get_rs485_config(struct uart_port *port,
  	unsigned long flags;
  	struct serial_rs485 aux;
  
@@ -7687,7 +7826,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  	if (copy_to_user(rs485, &aux, sizeof(aux)))
  		return -EFAULT;
-@@ -1494,7 +1494,7 @@ static int uart_set_rs485_config(struct tty_struct *tty, struct uart_port *port,
+@@ -1504,7 +1504,7 @@ static int uart_set_rs485_config(struct tty_struct *tty, struct uart_port *port,
  	uart_set_rs485_termination(port, &rs485);
  	uart_set_rs485_rx_during_tx(port, &rs485);
  
@@ -7696,7 +7835,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	ret = port->rs485_config(port, &tty->termios, &rs485);
  	if (!ret) {
  		port->rs485 = rs485;
-@@ -1503,7 +1503,7 @@ static int uart_set_rs485_config(struct tty_struct *tty, struct uart_port *port,
+@@ -1513,7 +1513,7 @@ static int uart_set_rs485_config(struct tty_struct *tty, struct uart_port *port,
  		if (!(rs485.flags & SER_RS485_ENABLED))
  			port->ops->set_mctrl(port, port->mctrl);
  	}
@@ -7705,7 +7844,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	if (ret) {
  		/* restore old GPIO settings */
  		gpiod_set_value_cansleep(port->rs485_term_gpio,
-@@ -1528,9 +1528,9 @@ static int uart_get_iso7816_config(struct uart_port *port,
+@@ -1538,9 +1538,9 @@ static int uart_get_iso7816_config(struct uart_port *port,
  	if (!port->iso7816_config)
  		return -ENOTTY;
  
@@ -7717,7 +7856,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  	if (copy_to_user(iso7816, &aux, sizeof(aux)))
  		return -EFAULT;
-@@ -1559,9 +1559,9 @@ static int uart_set_iso7816_config(struct uart_port *port,
+@@ -1569,9 +1569,9 @@ static int uart_set_iso7816_config(struct uart_port *port,
  		if (iso7816.reserved[i])
  			return -EINVAL;
  
@@ -7729,7 +7868,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	if (ret)
  		return ret;
  
-@@ -1778,9 +1778,9 @@ static void uart_tty_port_shutdown(struct tty_port *port)
+@@ -1788,9 +1788,9 @@ static void uart_tty_port_shutdown(struct tty_port *port)
  	if (WARN(!uport, "detached port still initialized!\n"))
  		return;
  
@@ -7741,7 +7880,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  	serial_base_port_shutdown(uport);
  	uart_port_shutdown(port);
-@@ -1795,11 +1795,11 @@ static void uart_tty_port_shutdown(struct tty_port *port)
+@@ -1805,11 +1805,11 @@ static void uart_tty_port_shutdown(struct tty_port *port)
  	/*
  	 * Free the transmit buffer.
  	 */
@@ -7755,7 +7894,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  	free_page((unsigned long)buf);
  
-@@ -1942,10 +1942,10 @@ static bool uart_carrier_raised(struct tty_port *port)
+@@ -1952,10 +1952,10 @@ static bool uart_carrier_raised(struct tty_port *port)
  	 */
  	if (WARN_ON(!uport))
  		return true;
@@ -7768,7 +7907,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  	uart_port_deref(uport);
  
  	return mctrl & TIOCM_CAR;
-@@ -2062,9 +2062,9 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
+@@ -2072,9 +2072,9 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
  		pm_state = state->pm_state;
  		if (pm_state != UART_PM_STATE_ON)
  			uart_change_pm(state, UART_PM_STATE_ON);
@@ -7780,7 +7919,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  		if (pm_state != UART_PM_STATE_ON)
  			uart_change_pm(state, pm_state);
  
-@@ -2403,9 +2403,9 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2413,9 +2413,9 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
  	 */
  	if (!console_suspend_enabled && uart_console(uport)) {
  		if (uport->ops->start_rx) {
@@ -7792,7 +7931,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  		}
  		goto unlock;
  	}
-@@ -2420,7 +2420,7 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2430,7 +2430,7 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
  		tty_port_set_suspended(port, true);
  		tty_port_set_initialized(port, false);
  
@@ -7801,7 +7940,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  		ops->stop_tx(uport);
  		if (!(uport->rs485.flags & SER_RS485_ENABLED))
  			ops->set_mctrl(uport, 0);
-@@ -2428,7 +2428,7 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2438,7 +2438,7 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
  		mctrl = uport->mctrl;
  		uport->mctrl = 0;
  		ops->stop_rx(uport);
@@ -7810,7 +7949,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  
  		/*
  		 * Wait for the transmitter to empty.
-@@ -2500,9 +2500,9 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2510,9 +2510,9 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
  			uart_change_pm(state, UART_PM_STATE_ON);
  		uport->ops->set_termios(uport, &termios, NULL);
  		if (!console_suspend_enabled && uport->ops->start_rx) {
@@ -7822,7 +7961,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  		}
  		if (console_suspend_enabled)
  			console_start(uport->cons);
-@@ -2513,10 +2513,10 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2523,10 +2523,10 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
  		int ret;
  
  		uart_change_pm(state, UART_PM_STATE_ON);
@@ -7835,7 +7974,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  		if (console_suspend_enabled || !uart_console(uport)) {
  			/* Protected by port mutex for now */
  			struct tty_struct *tty = port->tty;
-@@ -2526,11 +2526,11 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
+@@ -2536,11 +2536,11 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
  				if (tty)
  					uart_change_line_settings(tty, state, NULL);
  				uart_rs485_config(uport);
@@ -7849,7 +7988,7 @@ index 2eceef54e0b3..6cd64ccc2035 100644
  				tty_port_set_initialized(port, true);
  			} else {
  				/*
-@@ -2642,11 +2642,11 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
+@@ -2652,11 +2652,11 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
  		 * keep the DTR setting that is set in uart_set_options()
  		 * We probably don't need a spinlock around this, but
  		 */
@@ -8271,10 +8410,20 @@ index f793624fd501..2559c97812fa 100644
  
  static int serial_console_setup(struct console *co, char *options)
 diff --git a/drivers/tty/serial/sifive.c b/drivers/tty/serial/sifive.c
-index d195c5de52e7..b296e57a9dee 100644
+index d195c5de52e7..d420bed4a3a7 100644
 --- a/drivers/tty/serial/sifive.c
 +++ b/drivers/tty/serial/sifive.c
-@@ -521,11 +521,11 @@ static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
+@@ -412,7 +412,8 @@ static void __ssp_receive_chars(struct sifive_serial_port *ssp)
+ 			break;
+ 
+ 		ssp->port.icount.rx++;
+-		uart_insert_char(&ssp->port, 0, 0, ch, TTY_NORMAL);
++		if (!uart_prepare_sysrq_char(&ssp->port, ch))
++			uart_insert_char(&ssp->port, 0, 0, ch, TTY_NORMAL);
+ 	}
+ 
+ 	tty_flip_buffer_push(&ssp->port.state->port);
+@@ -521,11 +522,11 @@ static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
  	struct sifive_serial_port *ssp = dev_id;
  	u32 ip;
  
@@ -8288,16 +8437,16 @@ index d195c5de52e7..b296e57a9dee 100644
  		return IRQ_NONE;
  	}
  
-@@ -534,7 +534,7 @@ static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
+@@ -534,7 +535,7 @@ static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
  	if (ip & SIFIVE_SERIAL_IP_TXWM_MASK)
  		__ssp_transmit_chars(ssp);
  
 -	spin_unlock(&ssp->port.lock);
-+	uart_port_unlock(&ssp->port);
++	uart_unlock_and_check_sysrq(&ssp->port);
  
  	return IRQ_HANDLED;
  }
-@@ -653,7 +653,7 @@ static void sifive_serial_set_termios(struct uart_port *port,
+@@ -653,7 +654,7 @@ static void sifive_serial_set_termios(struct uart_port *port,
  				  ssp->port.uartclk / 16);
  	__ssp_update_baud_rate(ssp, rate);
  
@@ -8306,7 +8455,7 @@ index d195c5de52e7..b296e57a9dee 100644
  
  	/* Update the per-port timeout */
  	uart_update_timeout(port, termios->c_cflag, rate);
-@@ -670,7 +670,7 @@ static void sifive_serial_set_termios(struct uart_port *port,
+@@ -670,7 +671,7 @@ static void sifive_serial_set_termios(struct uart_port *port,
  	if (v != old_v)
  		__ssp_writel(v, SIFIVE_SERIAL_RXCTRL_OFFS, ssp);
  
@@ -8315,27 +8464,33 @@ index d195c5de52e7..b296e57a9dee 100644
  }
  
  static void sifive_serial_release_port(struct uart_port *port)
-@@ -795,9 +795,9 @@ static void sifive_serial_console_write(struct console *co, const char *s,
- 	if (ssp->port.sysrq)
- 		locked = 0;
- 	else if (oops_in_progress)
+@@ -791,13 +792,10 @@ static void sifive_serial_console_write(struct console *co, const char *s,
+ 	if (!ssp)
+ 		return;
+ 
+-	local_irq_save(flags);
+-	if (ssp->port.sysrq)
+-		locked = 0;
+-	else if (oops_in_progress)
 -		locked = spin_trylock(&ssp->port.lock);
-+		locked = uart_port_trylock(&ssp->port);
++	if (oops_in_progress)
++		locked = uart_port_trylock_irqsave(&ssp->port, &flags);
  	else
 -		spin_lock(&ssp->port.lock);
-+		uart_port_lock(&ssp->port);
++		uart_port_lock_irqsave(&ssp->port, &flags);
  
  	ier = __ssp_readl(ssp, SIFIVE_SERIAL_IE_OFFS);
  	__ssp_writel(0, SIFIVE_SERIAL_IE_OFFS, ssp);
-@@ -807,7 +807,7 @@ static void sifive_serial_console_write(struct console *co, const char *s,
+@@ -807,8 +805,7 @@ static void sifive_serial_console_write(struct console *co, const char *s,
  	__ssp_writel(ier, SIFIVE_SERIAL_IE_OFFS, ssp);
  
  	if (locked)
 -		spin_unlock(&ssp->port.lock);
-+		uart_port_unlock(&ssp->port);
- 	local_irq_restore(flags);
+-	local_irq_restore(flags);
++		uart_port_unlock_irqrestore(&ssp->port, flags);
  }
  
+ static int sifive_serial_console_setup(struct console *co, char *options)
 diff --git a/drivers/tty/serial/sprd_serial.c b/drivers/tty/serial/sprd_serial.c
 index f328fa57231f..f257525f9299 100644
 --- a/drivers/tty/serial/sprd_serial.c
@@ -10151,7 +10306,7 @@ index 4a1dc88ddbff..a5091ac97fc6 100644
  
  static inline struct task_struct *this_cpu_ksoftirqd(void)
 diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
-index b8e60a20416b..ffa5248a90e2 100644
+index 1576e7443eee..65a58e6df3d4 100644
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
 @@ -3258,7 +3258,11 @@ struct softnet_data {
@@ -10234,10 +10389,10 @@ index e4878bb58f66..ebebc32e78de 100644
  
  #ifdef CONFIG_SMP
 diff --git a/include/linux/sched.h b/include/linux/sched.h
-index 77f01ac385f7..c02fd12b49dc 100644
+index 3d83cc397eac..99c2e637591c 100644
 --- a/include/linux/sched.h
 +++ b/include/linux/sched.h
-@@ -911,6 +911,9 @@ struct task_struct {
+@@ -913,6 +913,9 @@ struct task_struct {
  	 * ->sched_remote_wakeup gets used, so it can be in this word.
  	 */
  	unsigned			sched_remote_wakeup:1;
@@ -10247,7 +10402,7 @@ index 77f01ac385f7..c02fd12b49dc 100644
  
  	/* Bit to tell LSMs we're in execve(): */
  	unsigned			in_execve:1;
-@@ -1902,6 +1905,7 @@ static inline int dl_task_check_affinity(struct task_struct *p, const struct cpu
+@@ -1904,6 +1907,7 @@ static inline int dl_task_check_affinity(struct task_struct *p, const struct cpu
  }
  #endif
  
@@ -10255,7 +10410,7 @@ index 77f01ac385f7..c02fd12b49dc 100644
  extern int yield_to(struct task_struct *p, bool preempt);
  extern void set_user_nice(struct task_struct *p, long nice);
  extern int task_prio(const struct task_struct *p);
-@@ -2046,17 +2050,17 @@ static inline void update_tsk_thread_flag(struct task_struct *tsk, int flag,
+@@ -2048,17 +2052,17 @@ static inline void update_tsk_thread_flag(struct task_struct *tsk, int flag,
  	update_ti_thread_flag(task_thread_info(tsk), flag, value);
  }
  
@@ -10276,7 +10431,7 @@ index 77f01ac385f7..c02fd12b49dc 100644
  {
  	return test_ti_thread_flag(task_thread_info(tsk), flag);
  }
-@@ -2069,9 +2073,11 @@ static inline void set_tsk_need_resched(struct task_struct *tsk)
+@@ -2071,9 +2075,11 @@ static inline void set_tsk_need_resched(struct task_struct *tsk)
  static inline void clear_tsk_need_resched(struct task_struct *tsk)
  {
  	clear_tsk_thread_flag(tsk,TIF_NEED_RESCHED);
@@ -10289,7 +10444,7 @@ index 77f01ac385f7..c02fd12b49dc 100644
  {
  	return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED));
  }
-@@ -2252,7 +2258,7 @@ static inline int rwlock_needbreak(rwlock_t *lock)
+@@ -2254,7 +2260,7 @@ static inline int rwlock_needbreak(rwlock_t *lock)
  
  static __always_inline bool need_resched(void)
  {
@@ -10374,7 +10529,7 @@ index be65de65fe61..ec46e3b49ee9 100644
  int serial8250_console_exit(struct uart_port *port);
  
 diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
-index 5da5eb719f61..1694f998c5a9 100644
+index 052df85dfd59..6de3d7aab17d 100644
 --- a/include/linux/serial_core.h
 +++ b/include/linux/serial_core.h
 @@ -489,6 +489,7 @@ struct uart_port {
@@ -10471,7 +10626,7 @@ index 5da5eb719f61..1694f998c5a9 100644
  {
  	spin_unlock_irqrestore(&up->lock, flags);
  }
-@@ -1061,14 +1088,14 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
+@@ -1078,14 +1105,14 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
  	u8 sysrq_ch;
  
  	if (!port->has_sysrq) {
@@ -10488,7 +10643,7 @@ index 5da5eb719f61..1694f998c5a9 100644
  
  	if (sysrq_ch)
  		handle_sysrq(sysrq_ch);
-@@ -1080,14 +1107,14 @@ static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port
+@@ -1097,14 +1124,14 @@ static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port
  	u8 sysrq_ch;
  
  	if (!port->has_sysrq) {
@@ -10505,7 +10660,7 @@ index 5da5eb719f61..1694f998c5a9 100644
  
  	if (sysrq_ch)
  		handle_sysrq(sysrq_ch);
-@@ -1103,12 +1130,12 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)
+@@ -1120,12 +1147,12 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)
  }
  static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
  {
@@ -10570,7 +10725,7 @@ index 9ea0b28068f4..5ded1450ac1a 100644
  
  #ifndef CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES
 diff --git a/include/linux/trace_events.h b/include/linux/trace_events.h
-index 696f8dc4aa53..e44b47305235 100644
+index 9d799777c333..a5e9a533559c 100644
 --- a/include/linux/trace_events.h
 +++ b/include/linux/trace_events.h
 @@ -178,8 +178,8 @@ unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status);
@@ -10666,7 +10821,7 @@ index 5ff4f1cd3644..fd42f0b17dec 100644
  	}
  }
 diff --git a/kernel/entry/kvm.c b/kernel/entry/kvm.c
-index 2e0f75bcb7fd..d952fa5ee880 100644
+index 2e0f75bcb7fd..5253d3d2d013 100644
 --- a/kernel/entry/kvm.c
 +++ b/kernel/entry/kvm.c
 @@ -13,7 +13,7 @@ static int xfer_to_guest_mode_work(struct kvm_vcpu *vcpu, unsigned long ti_work)
@@ -10674,7 +10829,7 @@ index 2e0f75bcb7fd..d952fa5ee880 100644
  		}
  
 -		if (ti_work & _TIF_NEED_RESCHED)
-+		if (ti_work & (_TIF_NEED_RESCHED | TIF_NEED_RESCHED_LAZY))
++		if (ti_work & (_TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY))
  			schedule();
  
  		if (ti_work & _TIF_NOTIFY_RESUME)
@@ -10912,7 +11067,7 @@ index 1d4bc493b2f4..486c68c11bbe 100644
  	NULL
  };
 diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c
-index 151bd3de5936..5c21ba41e308 100644
+index 3468d8230e5f..6eef8527e654 100644
 --- a/kernel/locking/lockdep.c
 +++ b/kernel/locking/lockdep.c
 @@ -56,6 +56,7 @@
@@ -10942,7 +11097,7 @@ index 151bd3de5936..5c21ba41e308 100644
  
  /*
 diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
-index 21db0df0eb00..4a10e8c16fd2 100644
+index bf3a28ee7d8f..99129c89120a 100644
 --- a/kernel/locking/rtmutex.c
 +++ b/kernel/locking/rtmutex.c
 @@ -218,6 +218,11 @@ static __always_inline bool rt_mutex_cmpxchg_acquire(struct rt_mutex_base *lock,
@@ -10987,8 +11142,8 @@ index 21db0df0eb00..4a10e8c16fd2 100644
  
  		raw_spin_lock_irq(&lock->wait_lock);
  		set_current_state(state);
-@@ -1642,7 +1661,7 @@ static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,
- 	WARN(1, "rtmutex deadlock detected\n");
+@@ -1643,7 +1662,7 @@ static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,
+ 
  	while (1) {
  		set_current_state(TASK_INTERRUPTIBLE);
 -		schedule();
@@ -10996,7 +11151,7 @@ index 21db0df0eb00..4a10e8c16fd2 100644
  	}
  }
  
-@@ -1737,6 +1756,15 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+@@ -1738,6 +1757,15 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
  	unsigned long flags;
  	int ret;
  
@@ -11012,7 +11167,7 @@ index 21db0df0eb00..4a10e8c16fd2 100644
  	/*
  	 * Technically we could use raw_spin_[un]lock_irq() here, but this can
  	 * be called in early boot if the cmpxchg() fast path is disabled
-@@ -1748,6 +1776,7 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+@@ -1749,6 +1777,7 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
  	raw_spin_lock_irqsave(&lock->wait_lock, flags);
  	ret = __rt_mutex_slowlock_locked(lock, ww_ctx, state);
  	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
@@ -11020,7 +11175,7 @@ index 21db0df0eb00..4a10e8c16fd2 100644
  
  	return ret;
  }
-@@ -1755,7 +1784,9 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
+@@ -1756,7 +1785,9 @@ static int __sched rt_mutex_slowlock(struct rt_mutex_base *lock,
  static __always_inline int __rt_mutex_lock(struct rt_mutex_base *lock,
  					   unsigned int state)
  {
@@ -11085,7 +11240,7 @@ index 25ec0239477c..34a59569db6b 100644
  }
  
 diff --git a/kernel/locking/rwsem.c b/kernel/locking/rwsem.c
-index 9eabd585ce7a..2340b6d90ec6 100644
+index 11ed7ce6579e..62eac9fd809a 100644
 --- a/kernel/locking/rwsem.c
 +++ b/kernel/locking/rwsem.c
 @@ -1427,8 +1427,14 @@ static inline void __downgrade_write(struct rw_semaphore *sem)
@@ -11385,10 +11540,10 @@ index 7d4979d5c3ce..7db6992c54f3 100644
 +#endif
 diff --git a/kernel/printk/nbcon.c b/kernel/printk/nbcon.c
 new file mode 100644
-index 000000000000..b941039ee7d2
+index 000000000000..b4278854eeb9
 --- /dev/null
 +++ b/kernel/printk/nbcon.c
-@@ -0,0 +1,1665 @@
+@@ -0,0 +1,1659 @@
 +// SPDX-License-Identifier: GPL-2.0-only
 +// Copyright (C) 2022 Linutronix GmbH, John Ogness
 +// Copyright (C) 2022 Intel, Thomas Gleixner
@@ -12492,9 +12647,6 @@ index 000000000000..b941039ee7d2
 +
 +static inline bool rcuwait_has_sleeper(struct rcuwait *w)
 +{
-+	bool has_sleeper;
-+
-+	rcu_read_lock();
 +	/*
 +	 * Guarantee any new records can be seen by tasks preparing to wait
 +	 * before this context checks if the rcuwait is empty.
@@ -12507,10 +12659,7 @@ index 000000000000..b941039ee7d2
 +	 * This pairs with nbcon_kthread_func:A.
 +	 */
 +	smp_mb(); /* LMM(rcuwait_has_sleeper:A) */
-+	has_sleeper = !!rcu_dereference(w->task);
-+	rcu_read_unlock();
-+
-+	return has_sleeper;
++       return rcuwait_active(w);
 +}
 +
 +/**
@@ -14845,7 +14994,7 @@ index 6d10927a07d8..8d9408d653de 100644
  {
  #ifdef CONFIG_KGDB_KDB
 diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
-index 781146600aa4..7ee1c84b52ee 100644
+index 46612fb15fc6..f893f4cfdd38 100644
 --- a/kernel/rcu/rcutorture.c
 +++ b/kernel/rcu/rcutorture.c
 @@ -2409,6 +2409,12 @@ static int rcutorture_booster_init(unsigned int cpu)
@@ -14892,10 +15041,10 @@ index 11a1fac3a589..6f085a159fca 100644
  
  static void print_cpu_stall(unsigned long gps)
 diff --git a/kernel/sched/core.c b/kernel/sched/core.c
-index dcb30e304871..92ded5b2ab6d 100644
+index b6f922a20f83..a88f6276950a 100644
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -898,14 +898,15 @@ static inline void hrtick_rq_init(struct rq *rq)
+@@ -897,14 +897,15 @@ static inline void hrtick_rq_init(struct rq *rq)
  
  #if defined(CONFIG_SMP) && defined(TIF_POLLING_NRFLAG)
  /*
@@ -14914,7 +15063,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  }
  
  /*
-@@ -922,7 +923,7 @@ static bool set_nr_if_polling(struct task_struct *p)
+@@ -921,7 +922,7 @@ static bool set_nr_if_polling(struct task_struct *p)
  	for (;;) {
  		if (!(val & _TIF_POLLING_NRFLAG))
  			return false;
@@ -14923,7 +15072,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  			return true;
  		if (try_cmpxchg(&ti->flags, &val, val | _TIF_NEED_RESCHED))
  			break;
-@@ -931,9 +932,9 @@ static bool set_nr_if_polling(struct task_struct *p)
+@@ -930,9 +931,9 @@ static bool set_nr_if_polling(struct task_struct *p)
  }
  
  #else
@@ -14935,7 +15084,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  	return true;
  }
  
-@@ -1038,28 +1039,47 @@ void wake_up_q(struct wake_q_head *head)
+@@ -1037,28 +1038,47 @@ void wake_up_q(struct wake_q_head *head)
   * might also involve a cross-CPU call to trigger the scheduler on
   * the target CPU.
   */
@@ -14991,7 +15140,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  }
  
  void resched_cpu(int cpu)
-@@ -1132,7 +1152,7 @@ static void wake_up_idle_cpu(int cpu)
+@@ -1131,7 +1151,7 @@ static void wake_up_idle_cpu(int cpu)
  	if (cpu == smp_processor_id())
  		return;
  
@@ -15000,7 +15149,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  		smp_send_reschedule(cpu);
  	else
  		trace_sched_wake_idle_without_ipi(cpu);
-@@ -6721,10 +6741,14 @@ void __noreturn do_task_dead(void)
+@@ -6722,10 +6742,14 @@ void __noreturn do_task_dead(void)
  
  static inline void sched_submit_work(struct task_struct *tsk)
  {
@@ -15017,7 +15166,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  
  	task_flags = tsk->flags;
  	/*
-@@ -6750,6 +6774,8 @@ static inline void sched_submit_work(struct task_struct *tsk)
+@@ -6751,6 +6775,8 @@ static inline void sched_submit_work(struct task_struct *tsk)
  	 * make sure to submit it to avoid deadlocks.
  	 */
  	blk_flush_plug(tsk->plug, true);
@@ -15026,7 +15175,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  }
  
  static void sched_update_worker(struct task_struct *tsk)
-@@ -6762,16 +6788,26 @@ static void sched_update_worker(struct task_struct *tsk)
+@@ -6763,16 +6789,26 @@ static void sched_update_worker(struct task_struct *tsk)
  	}
  }
  
@@ -15058,7 +15207,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  	sched_update_worker(tsk);
  }
  EXPORT_SYMBOL(schedule);
-@@ -6835,11 +6871,7 @@ void __sched schedule_preempt_disabled(void)
+@@ -6836,11 +6872,7 @@ void __sched schedule_preempt_disabled(void)
  #ifdef CONFIG_PREEMPT_RT
  void __sched notrace schedule_rtlock(void)
  {
@@ -15071,7 +15220,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  }
  NOKPROBE_SYMBOL(schedule_rtlock);
  #endif
-@@ -7035,6 +7067,32 @@ static void __setscheduler_prio(struct task_struct *p, int prio)
+@@ -7036,6 +7068,32 @@ static void __setscheduler_prio(struct task_struct *p, int prio)
  
  #ifdef CONFIG_RT_MUTEXES
  
@@ -15104,7 +15253,7 @@ index dcb30e304871..92ded5b2ab6d 100644
  static inline int __rt_effective_prio(struct task_struct *pi_task, int prio)
  {
  	if (pi_task)
-@@ -8885,6 +8943,21 @@ static inline void preempt_dynamic_init(void) { }
+@@ -8886,6 +8944,21 @@ static inline void preempt_dynamic_init(void) { }
  
  #endif /* #ifdef CONFIG_PREEMPT_DYNAMIC */
  
@@ -15164,7 +15313,7 @@ index 4c3d0d9f3db6..63e19b89c8c3 100644
  }
  late_initcall(sched_init_debug);
 diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
-index 01b3fc97ddc2..1e499b4e3c78 100644
+index db59bf549c64..f6e3fc3c20e4 100644
 --- a/kernel/sched/fair.c
 +++ b/kernel/sched/fair.c
 @@ -1022,8 +1022,10 @@ static void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se);
@@ -15232,7 +15381,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  static void update_curr_fair(struct rq *rq)
  {
  	update_curr(cfs_rq_of(&rq->curr->se));
-@@ -5404,7 +5420,7 @@ entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
+@@ -5479,7 +5495,7 @@ entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
  	/*
  	 * Update run-time statistics of the 'current'.
  	 */
@@ -15241,7 +15390,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  
  	/*
  	 * Ensure that runnable average is periodically updated.
-@@ -5418,7 +5434,7 @@ entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
+@@ -5493,7 +5509,7 @@ entity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)
  	 * validating it and just reschedule.
  	 */
  	if (queued) {
@@ -15250,7 +15399,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  		return;
  	}
  	/*
-@@ -5564,7 +5580,7 @@ static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)
+@@ -5639,7 +5655,7 @@ static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)
  	 * hierarchy can be throttled
  	 */
  	if (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))
@@ -15259,7 +15408,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  }
  
  static __always_inline
-@@ -5824,7 +5840,7 @@ void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)
+@@ -5899,7 +5915,7 @@ void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)
  
  	/* Determine whether we need to wake up potentially idle CPU: */
  	if (rq->curr == rq->idle && rq->cfs.nr_running)
@@ -15268,7 +15417,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  }
  
  #ifdef CONFIG_SMP
-@@ -6529,7 +6545,7 @@ static void hrtick_start_fair(struct rq *rq, struct task_struct *p)
+@@ -6604,7 +6620,7 @@ static void hrtick_start_fair(struct rq *rq, struct task_struct *p)
  
  		if (delta < 0) {
  			if (task_current(rq, p))
@@ -15277,7 +15426,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  			return;
  		}
  		hrtick_start(rq, delta);
-@@ -8207,7 +8223,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
+@@ -8282,7 +8298,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
  	 * prevents us from potentially nominating it as a false LAST_BUDDY
  	 * below.
  	 */
@@ -15285,8 +15434,8 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
 +	if (need_resched())
  		return;
  
- 	/* Idle tasks are by definition preempted by non-idle tasks. */
-@@ -8249,7 +8265,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
+ 	if (!sched_feat(WAKEUP_PREEMPTION))
+@@ -8320,7 +8336,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
  	return;
  
  preempt:
@@ -15295,7 +15444,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  }
  
  #ifdef CONFIG_SMP
-@@ -12401,7 +12417,7 @@ static inline void task_tick_core(struct rq *rq, struct task_struct *curr)
+@@ -12466,7 +12482,7 @@ static inline void task_tick_core(struct rq *rq, struct task_struct *curr)
  	 */
  	if (rq->core->core_forceidle_count && rq->cfs.nr_running == 1 &&
  	    __entity_slice_used(&curr->se, MIN_NR_TASKS_DURING_FORCEIDLE))
@@ -15304,7 +15453,7 @@ index 01b3fc97ddc2..1e499b4e3c78 100644
  }
  
  /*
-@@ -12566,7 +12582,7 @@ prio_changed_fair(struct rq *rq, struct task_struct *p, int oldprio)
+@@ -12631,7 +12647,7 @@ prio_changed_fair(struct rq *rq, struct task_struct *p, int oldprio)
  	 */
  	if (task_current(rq, p)) {
  		if (p->prio > oldprio)
@@ -15355,11 +15504,11 @@ index 4ac36eb4cdee..acd1510e8d47 100644
  		rd->rto_cpu = -1;
  
 diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
-index 35c38daa2d3e..5c976c7dcc91 100644
+index 8cbbbea7fdbb..00cdf0db8732 100644
 --- a/kernel/sched/sched.h
 +++ b/kernel/sched/sched.h
-@@ -2437,6 +2437,7 @@ extern void init_sched_fair_class(void);
- extern void reweight_task(struct task_struct *p, int prio);
+@@ -2438,6 +2438,7 @@ extern void init_sched_fair_class(void);
+ extern void reweight_task(struct task_struct *p, const struct load_weight *lw);
  
  extern void resched_curr(struct rq *rq);
 +extern void resched_curr_lazy(struct rq *rq);
@@ -15367,10 +15516,10 @@ index 35c38daa2d3e..5c976c7dcc91 100644
  
  extern struct rt_bandwidth def_rt_bandwidth;
 diff --git a/kernel/signal.c b/kernel/signal.c
-index 09019017d669..b71026341056 100644
+index 3808eaa2f49a..3dc728b4b3cb 100644
 --- a/kernel/signal.c
 +++ b/kernel/signal.c
-@@ -2329,15 +2329,35 @@ static int ptrace_stop(int exit_code, int why, unsigned long message,
+@@ -2330,15 +2330,35 @@ static int ptrace_stop(int exit_code, int why, unsigned long message,
  		do_notify_parent_cldstop(current, false, why);
  
  	/*
@@ -15544,10 +15693,10 @@ index bd9716d7bb63..2fde8af88e48 100644
  }
  early_initcall(spawn_ksoftirqd);
 diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
-index edb0f821dcea..a7290012179a 100644
+index 57e5cb36f1bc..c4ae45701fab 100644
 --- a/kernel/time/hrtimer.c
 +++ b/kernel/time/hrtimer.c
-@@ -1809,7 +1809,7 @@ void hrtimer_interrupt(struct clock_event_device *dev)
+@@ -1812,7 +1812,7 @@ void hrtimer_interrupt(struct clock_event_device *dev)
  	if (!ktime_before(now, cpu_base->softirq_expires_next)) {
  		cpu_base->softirq_expires_next = KTIME_MAX;
  		cpu_base->softirq_activated = 1;
@@ -15556,7 +15705,7 @@ index edb0f821dcea..a7290012179a 100644
  	}
  
  	__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);
-@@ -1922,7 +1922,7 @@ void hrtimer_run_queues(void)
+@@ -1925,7 +1925,7 @@ void hrtimer_run_queues(void)
  	if (!ktime_before(now, cpu_base->softirq_expires_next)) {
  		cpu_base->softirq_expires_next = KTIME_MAX;
  		cpu_base->softirq_activated = 1;
@@ -15610,10 +15759,10 @@ index 63a8ce7177dd..b3fbe97d1e34 100644
  
  /*
 diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
-index fd398af792b4..03653fcb3ee3 100644
+index ecd869ed2767..c2684d3c5b2d 100644
 --- a/kernel/trace/trace.c
 +++ b/kernel/trace/trace.c
-@@ -2708,6 +2708,8 @@ unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status)
+@@ -2706,6 +2706,8 @@ unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status)
  
  	if (tif_need_resched())
  		trace_flags |= TRACE_FLAG_NEED_RESCHED;
@@ -15623,7 +15772,7 @@ index fd398af792b4..03653fcb3ee3 100644
  		trace_flags |= TRACE_FLAG_PREEMPT_RESCHED;
  	return (trace_flags << 16) | (min_t(unsigned int, pc & 0xff, 0xf)) |
 diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
-index 3b7d3e9eb6ea..5a4fefbc0856 100644
+index db575094c498..c251a44ad8ac 100644
 --- a/kernel/trace/trace_output.c
 +++ b/kernel/trace/trace_output.c
 @@ -460,17 +460,29 @@ int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)
@@ -15659,10 +15808,10 @@ index 3b7d3e9eb6ea..5a4fefbc0856 100644
  		need_resched = 'p';
  		break;
 diff --git a/net/core/dev.c b/net/core/dev.c
-index 5a5bd339f11e..8f193d7b8b41 100644
+index 4beb9acf2c18..aa8894995dbe 100644
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -4705,15 +4705,6 @@ static void rps_trigger_softirq(void *data)
+@@ -4713,15 +4713,6 @@ static void rps_trigger_softirq(void *data)
  
  #endif /* CONFIG_RPS */
  
@@ -15678,7 +15827,7 @@ index 5a5bd339f11e..8f193d7b8b41 100644
  /*
   * After we queued a packet into sd->input_pkt_queue,
   * we need to make sure this queue is serviced soon.
-@@ -6682,6 +6673,32 @@ static void skb_defer_free_flush(struct softnet_data *sd)
+@@ -6690,6 +6681,32 @@ static void skb_defer_free_flush(struct softnet_data *sd)
  	}
  }
  
@@ -15711,7 +15860,7 @@ index 5a5bd339f11e..8f193d7b8b41 100644
  static int napi_threaded_poll(void *data)
  {
  	struct napi_struct *napi = data;
-@@ -11619,7 +11636,11 @@ static int __init net_dev_init(void)
+@@ -11627,7 +11644,11 @@ static int __init net_dev_init(void)
  		INIT_CSD(&sd->csd, rps_trigger_softirq, sd);
  		sd->cpu = i;
  #endif
@@ -15742,3 +15891,217 @@ index f0a9ef1aeaa2..682175af439d 100644
  }
  
  static void skb_splice_csum_page(struct sk_buff *skb, struct page *page,
+diff --git a/scripts/sign-file.c b/scripts/sign-file.c
+index 3edb156ae52c..7070245edfc1 100644
+--- a/scripts/sign-file.c
++++ b/scripts/sign-file.c
+@@ -27,14 +27,17 @@
+ #include <openssl/evp.h>
+ #include <openssl/pem.h>
+ #include <openssl/err.h>
+-#include <openssl/engine.h>
+-
+-/*
+- * OpenSSL 3.0 deprecates the OpenSSL's ENGINE API.
+- *
+- * Remove this if/when that API is no longer used
+- */
+-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
++#if OPENSSL_VERSION_MAJOR >= 3
++# define USE_PKCS11_PROVIDER
++# include <openssl/provider.h>
++# include <openssl/store.h>
++#else
++# if !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_DEPRECATED_3_0)
++#  define USE_PKCS11_ENGINE
++#  include <openssl/engine.h>
++# endif
++#endif
++#include "ssl-common.h"
+ 
+ /*
+  * Use CMS if we have openssl-1.0.0 or newer available - otherwise we have to
+@@ -83,41 +86,6 @@ void format(void)
+ 	exit(2);
+ }
+ 
+-static void display_openssl_errors(int l)
+-{
+-	const char *file;
+-	char buf[120];
+-	int e, line;
+-
+-	if (ERR_peek_error() == 0)
+-		return;
+-	fprintf(stderr, "At main.c:%d:\n", l);
+-
+-	while ((e = ERR_get_error_line(&file, &line))) {
+-		ERR_error_string(e, buf);
+-		fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
+-	}
+-}
+-
+-static void drain_openssl_errors(void)
+-{
+-	const char *file;
+-	int line;
+-
+-	if (ERR_peek_error() == 0)
+-		return;
+-	while (ERR_get_error_line(&file, &line)) {}
+-}
+-
+-#define ERR(cond, fmt, ...)				\
+-	do {						\
+-		bool __cond = (cond);			\
+-		display_openssl_errors(__LINE__);	\
+-		if (__cond) {				\
+-			errx(1, fmt, ## __VA_ARGS__);	\
+-		}					\
+-	} while(0)
+-
+ static const char *key_pass;
+ 
+ static int pem_pw_cb(char *buf, int len, int w, void *v)
+@@ -139,28 +107,64 @@ static int pem_pw_cb(char *buf, int len, int w, void *v)
+ 	return pwlen;
+ }
+ 
+-static EVP_PKEY *read_private_key(const char *private_key_name)
++static EVP_PKEY *read_private_key_pkcs11(const char *private_key_name)
+ {
+-	EVP_PKEY *private_key;
++	EVP_PKEY *private_key = NULL;
++#ifdef USE_PKCS11_PROVIDER
++	OSSL_STORE_CTX *store;
+ 
++	if (!OSSL_PROVIDER_try_load(NULL, "pkcs11", true))
++		ERR(1, "OSSL_PROVIDER_try_load(pkcs11)");
++	if (!OSSL_PROVIDER_try_load(NULL, "default", true))
++		ERR(1, "OSSL_PROVIDER_try_load(default)");
++
++	store = OSSL_STORE_open(private_key_name, NULL, NULL, NULL, NULL);
++	ERR(!store, "OSSL_STORE_open");
++
++	while (!OSSL_STORE_eof(store)) {
++		OSSL_STORE_INFO *info = OSSL_STORE_load(store);
++
++		if (!info) {
++			drain_openssl_errors(__LINE__, 0);
++			continue;
++		}
++		if (OSSL_STORE_INFO_get_type(info) == OSSL_STORE_INFO_PKEY) {
++			private_key = OSSL_STORE_INFO_get1_PKEY(info);
++			ERR(!private_key, "OSSL_STORE_INFO_get1_PKEY");
++		}
++		OSSL_STORE_INFO_free(info);
++		if (private_key)
++			break;
++	}
++	OSSL_STORE_close(store);
++#elif defined(USE_PKCS11_ENGINE)
++	ENGINE *e;
++
++	ENGINE_load_builtin_engines();
++	drain_openssl_errors(__LINE__, 1);
++	e = ENGINE_by_id("pkcs11");
++	ERR(!e, "Load PKCS#11 ENGINE");
++	if (ENGINE_init(e))
++		drain_openssl_errors(__LINE__, 1);
++	else
++		ERR(1, "ENGINE_init");
++	if (key_pass)
++		ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
++	private_key = ENGINE_load_private_key(e, private_key_name, NULL, NULL);
++	ERR(!private_key, "%s", private_key_name);
++#else
++	fprintf(stderr, "no pkcs11 engine/provider available\n");
++	exit(1);
++#endif
++	return private_key;
++}
++
++static EVP_PKEY *read_private_key(const char *private_key_name)
++{
+ 	if (!strncmp(private_key_name, "pkcs11:", 7)) {
+-		ENGINE *e;
+-
+-		ENGINE_load_builtin_engines();
+-		drain_openssl_errors();
+-		e = ENGINE_by_id("pkcs11");
+-		ERR(!e, "Load PKCS#11 ENGINE");
+-		if (ENGINE_init(e))
+-			drain_openssl_errors();
+-		else
+-			ERR(1, "ENGINE_init");
+-		if (key_pass)
+-			ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0),
+-			    "Set PKCS#11 PIN");
+-		private_key = ENGINE_load_private_key(e, private_key_name,
+-						      NULL, NULL);
+-		ERR(!private_key, "%s", private_key_name);
++		return read_private_key_pkcs11(private_key_name);
+ 	} else {
++		EVP_PKEY *private_key;
+ 		BIO *b;
+ 
+ 		b = BIO_new_file(private_key_name, "rb");
+@@ -169,9 +173,9 @@ static EVP_PKEY *read_private_key(const char *private_key_name)
+ 						      NULL);
+ 		ERR(!private_key, "%s", private_key_name);
+ 		BIO_free(b);
+-	}
+ 
+-	return private_key;
++		return private_key;
++	}
+ }
+ 
+ static X509 *read_x509(const char *x509_name)
+@@ -306,7 +310,7 @@ int main(int argc, char **argv)
+ 
+ 		/* Digest the module data. */
+ 		OpenSSL_add_all_digests();
+-		display_openssl_errors(__LINE__);
++		drain_openssl_errors(__LINE__, 0);
+ 		digest_algo = EVP_get_digestbyname(hash_algo);
+ 		ERR(!digest_algo, "EVP_get_digestbyname");
+ 
+diff --git a/scripts/ssl-common.h b/scripts/ssl-common.h
+new file mode 100644
+index 000000000000..2db0e181143c
+--- /dev/null
++++ b/scripts/ssl-common.h
+@@ -0,0 +1,32 @@
++/* SPDX-License-Identifier: LGPL-2.1+ */
++/*
++ * SSL helper functions shared by sign-file and extract-cert.
++ */
++
++static void drain_openssl_errors(int l, int silent)
++{
++	const char *file;
++	char buf[120];
++	int e, line;
++
++	if (ERR_peek_error() == 0)
++		return;
++	if (!silent)
++		fprintf(stderr, "At main.c:%d:\n", l);
++
++	while ((e = ERR_peek_error_line(&file, &line))) {
++		ERR_error_string(e, buf);
++		if (!silent)
++			fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
++		ERR_get_error();
++	}
++}
++
++#define ERR(cond, fmt, ...)				\
++	do {						\
++		bool __cond = (cond);			\
++		drain_openssl_errors(__LINE__, 0);	\
++		if (__cond) {				\
++			errx(1, fmt, ## __VA_ARGS__);	\
++		}					\
++	} while (0)
-- 
2.47.0

