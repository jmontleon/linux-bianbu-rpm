From 62870b06df1d23988073f55693206c4a617319af Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Tue, 8 Oct 2024 20:22:44 +0800
Subject: [PATCH 05/13] Update for v2.0rc7

---
 arch/riscv/boot/dts/spacemit/Makefile         |   3 +-
 .../boot/dts/spacemit/k1-x_FusionOne.dts      | 870 +++++++++++++++++
 arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts |   4 +
 .../boot/dts/spacemit/k1-x_MUSE-Book.dts      |   8 +-
 .../boot/dts/spacemit/k1-x_MUSE-Card.dts      |   6 +-
 arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts |   4 +
 .../dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts  |   4 +
 .../boot/dts/spacemit/k1-x_MUSE-Paper.dts     |   6 +-
 arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts |   8 +-
 .../boot/dts/spacemit/k1-x_baton-camera.dts   | 911 ++++++++++++++++++
 arch/riscv/boot/dts/spacemit/k1-x_deb1.dts    |   7 +-
 arch/riscv/boot/dts/spacemit/k1-x_kx312.dts   |   4 +
 arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts   |  14 +-
 .../boot/dts/spacemit/k1-x_milkv-jupiter.dts  |   4 +
 arch/riscv/boot/dts/spacemit/k1-x_mingo.dts   |   4 +
 arch/riscv/configs/k1_defconfig               |   1 +
 drivers/gpu/drm/spacemit/dpu/dpu_saturn.c     |  20 +
 drivers/gpu/drm/spacemit/spacemit_dmmu.c      |   3 +-
 drivers/gpu/drm/spacemit/spacemit_dmmu.h      |   2 +-
 drivers/gpu/drm/spacemit/spacemit_dpu.h       |  11 +
 drivers/gpu/drm/spacemit/spacemit_planes.c    | 100 +-
 drivers/iio/adc/Kconfig                       |   6 +
 drivers/iio/adc/Makefile                      |   1 +
 drivers/iio/adc/k1x_adc.c                     | 226 +++++
 .../spacemit/camera/cam_cpp/k1x_cpp.c         |   1 +
 .../spacemit/camera/cam_sensor/cam_sensor.c   | 172 ++--
 .../spacemit/camera/cam_sensor/cam_sensor.h   |   1 +
 .../spacemit/camera/vi/k1xvi/fe_isp.c         |   6 +-
 drivers/mfd/spacemit-mfd.c                    |   1 +
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |   6 +-
 .../realtek/rtl8852bs/core/rtw_sec_cam.c      |   9 +
 .../rtl8852bs/os_dep/linux/ioctl_cfg80211.c   |   4 +-
 .../realtek/rtl8852bs/os_dep/linux/os_intfs.c |   4 +-
 .../rtl8852bs/os_dep/linux/wifi_regd.c        |   4 +-
 .../soc/spacemit/pm_domain/k1x-pm_domain.c    |   3 +
 .../soc/spacemit/spacemit-rf/spacemit-bt.c    |   4 +-
 .../spacemit/spacemit-rf/spacemit-rfkill.c    |   4 +-
 .../soc/spacemit/spacemit-rf/spacemit-wlan.c  |   4 +-
 drivers/usb/gadget/function/uvc_queue.c       |   3 +
 include/linux/mfd/spacemit/spacemit_pmic.h    |   6 +
 include/linux/mfd/spacemit/spm8821.h          |  94 +-
 include/uapi/media/k1x/cam_sensor_uapi.h      |   6 +
 include/uapi/media/k1x/k1x_cpp_uapi.h         |   6 +
 43 files changed, 2454 insertions(+), 111 deletions(-)
 create mode 100644 arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
 create mode 100644 arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
 create mode 100644 drivers/iio/adc/k1x_adc.c

diff --git a/arch/riscv/boot/dts/spacemit/Makefile b/arch/riscv/boot/dts/spacemit/Makefile
index fb2fdbd4de91..9d30aad78dd8 100644
--- a/arch/riscv/boot/dts/spacemit/Makefile
+++ b/arch/riscv/boot/dts/spacemit/Makefile
@@ -2,5 +2,6 @@ dtb-$(CONFIG_SOC_SPACEMIT_K1X) += k1-x_evb.dtb k1-x_deb2.dtb k1-x_deb1.dtb k1-x_
 				  k1-x_kx312.dtb k1-x_MINI-PC.dtb k1-x_MUSE-N1.dtb k1-x_mingo.dtb \
 				  k1-x_MUSE-Pi.dtb k1-x_milkv-jupiter.dtb m1-x_milkv-jupiter.dtb \
 				  k1-x_MUSE-Book.dtb k1-x_lpi3a.dtb k1-x_MUSE-Card.dtb \
-				  k1-x_MUSE-Paper.dtb k1-x_MUSE-Paper-mini-4g.dtb
+				  k1-x_MUSE-Paper.dtb k1-x_MUSE-Paper-mini-4g.dtb \
+				  k1-x_baton-camera.dtb k1-x_FusionOne.dtb
 obj-$(CONFIG_BUILTIN_DTB) += $(addsuffix .o, $(dtb-y))
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts b/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
new file mode 100644
index 000000000000..e077ddc2b7f2
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/k1-x_FusionOne.dts
@@ -0,0 +1,870 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x-efuse.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "k1-x-hdmi.dtsi"
+#include "k1-x-camera-sdk.dtsi"
+#include "k1-x_opp_table.dtsi"
+#include "k1-x_thermal_cooling.dtsi"
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pwm/pwm.h>
+
+/ {
+	model = "spacemit k1-x FusionOne board";
+	modules_usrload = "8852bs";
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <24000000>;
+
+		cpu_0: cpu@0 {
+			cpu-ai = "true";
+		};
+
+		cpu_1: cpu@1 {
+			cpu-ai = "true";
+		};
+
+		cpu_2: cpu@2 {
+			reg = <2>;
+			cpu-ai = "true";
+		};
+
+		cpu_3: cpu@3 {
+			reg = <3>;
+			cpu-ai = "true";
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu_0>;
+				};
+
+				core1 {
+					cpu = <&cpu_1>;
+				};
+
+				core2 {
+					cpu = <&cpu_2>;
+				};
+
+				core3 {
+					cpu = <&cpu_3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu_4>;
+				};
+
+				core1 {
+					cpu = <&cpu_5>;
+				};
+
+				core2 {
+					cpu = <&cpu_6>;
+				};
+
+				core3 {
+					cpu = <&cpu_7>;
+				};
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x0 0x80000000>;
+	};
+
+	memory@100000000 {
+		device_type = "memory";
+		reg = <0x1 0x00000000 0x0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			/* alloc memory from 0x40000000~0x80000000 */
+			alloc-ranges = <0 0x40000000 0 0x40000000>;
+			/* size of cma buffer is 384MByte */
+			size = <0 0x18000000>;
+			/* start address is 1Mbyte aligned */
+			alignment = <0x0 0x100000>;
+			linux,cma-default;
+			/* besides hardware, dma for ex. buffer can be used by memory management */
+			reusable;
+		};
+
+		/* reserved 384K for dpu, including mmu table(256K) and cmdlist(128K) */
+		dpu_resv: dpu_reserved@2ff40000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x2ff40000 0x0 0x000C0000>;
+			no-map;
+		};
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		stdout-path = "serial0:115200n8";
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc4v0_baseboard: vcc4v0-baseboard {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc4v0_baseboard";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <4000000>;
+		regulator-max-microvolt = <4000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	rf_pwrseq: rf-pwrseq {
+		compatible = "spacemit,rf-pwrseq";
+		//vdd-supply = <&ldo_7>;
+		//vdd_voltage = <3300000>;
+		io-supply = <&dcdc_3>;
+		io_voltage = <1800000>;
+		pwr-gpios  = <&gpio 67 0>,<&gpio 120 0>;
+		status = "okay";
+
+		wlan_pwrseq: wlan-pwrseq {
+			compatible = "spacemit,wlan-pwrseq";
+			regon-gpios = <&gpio 116 0>;
+			interrupt-parent = <&pinctrl>;
+			interrupts = <268>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_wlan_wakeup>;
+		};
+
+		bt_pwrseq: bt-pwrseq {
+			compatible = "spacemit,bt-pwrseq";
+			reset-gpios     = <&gpio 63 0>;
+		};
+	};
+
+	/* led-controller { */
+	/* 	compatible = "pwm-leds"; */
+
+	/* 	led-2 { */
+	/* 		pwms = <&pwm3 0 7812500>; */
+	/* 		active-low; */
+	/* 		color = <LED_COLOR_ID_GREEN>; */
+	/* 		max-brightness = <255>; */
+	/* 		label = "d12"; */
+	/* 	}; */
+	/* }; */
+
+	leds {
+		compatible = "gpio-leds";
+
+		led1 {
+			label = "sys-led";
+			gpios = <&gpio 96 0>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+			status = "okay";
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0_2>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&dpu_online2_hdmi {
+	memory-region = <&dpu_resv>;
+	status = "okay";
+};
+
+&hdmi{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
+		status = "disabled";
+
+		mac_address0: mac_address0@0 {
+			reg = <0x0 6>;
+		};
+
+		mac_address1: mac_address1@6 {
+			reg = <0x6 6>;
+		};
+	};
+
+	es8326: es8326@19{
+		compatible = "everest,es8326";
+		reg = <0x19>;
+		#sound-dai-cells = <0>;
+		interrupt-parent = <&gpio>;
+		interrupts = <126 1>;
+		spk-ctl-gpio = <&gpio 127 0>;
+		everest,mic1-src = [44];
+		everest,mic2-src = [66];
+		status = "okay";
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4_2>;
+
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c8>;
+	status = "okay";
+
+	spm8821@41 {
+		compatible = "spacemit,spm8821";
+		reg = <0x41>;
+		interrupt-parent = <&intc>;
+		interrupts = <64>;
+		status = "okay";
+
+		vcc_sys-supply = <&vcc4v0_baseboard>;
+		dcdc5-supply = <&dcdc_5>;
+
+		regulators {
+			compatible = "pmic,regulator,spm8821";
+
+			/* buck */
+			dcdc_1: DCDC_REG1 {
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <650000>;
+				};
+			};
+
+			dcdc_2: DCDC_REG2 {
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_3: DCDC_REG3 {
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_4: DCDC_REG4 {
+				regulator-name = "dcdc4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_5: DCDC_REG5 {
+				regulator-name = "dcdc5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_6: DCDC_REG6 {
+				regulator-name = "dcdc6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			/* aldo */
+			ldo_1: LDO_REG1 {
+				regulator-name = "ldo1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+			};
+
+			ldo_2: LDO_REG2 {
+				regulator-name = "ldo2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_3: LDO_REG3 {
+				regulator-name = "ldo3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_4: LDO_REG4 {
+				regulator-name = "ldo4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			/* dldo */
+			ldo_5: LDO_REG5 {
+				regulator-name = "ldo5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+			};
+
+			ldo_6: LDO_REG6 {
+				regulator-name = "ldo6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_7: LDO_REG7 {
+				regulator-name = "ldo7";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_8: LDO_REG8 {
+				regulator-name = "ldo8";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_9: LDO_REG9 {
+				regulator-name = "ldo9";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_10: LDO_REG10 {
+				regulator-name = "ldo10";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_11: LDO_REG11 {
+				regulator-name = "ldo11";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			sw_1: SWITCH_REG1 {
+				regulator-name = "switch1";
+			};
+		};
+
+		pmic_pinctrl: pinctrl {
+			compatible = "pmic,pinctrl,spm8821";
+			gpio-controller;
+			#gpio-cells = <2>;
+			spacemit,npins = <6>;
+		};
+
+		pwr_key: key {
+			compatible = "pmic,pwrkey,spm8821";
+		};
+
+		ext_rtc: rtc {
+			compatible = "pmic,rtc,spm8821";
+		};
+	};
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_67  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_75  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_118 2 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_120 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_122 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_125 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_127 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	pinctrl_rcpu: pinctrl_rcpu_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_47, MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_tx */
+			K1X_PADCONF(GPIO_48, MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_rx */
+		>;
+	};
+
+	pinctrl_gmac0: gmac0_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_00, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rxdv */
+			K1X_PADCONF(GPIO_01, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rx_d0 */
+			K1X_PADCONF(GPIO_02, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rx_d1 */
+			K1X_PADCONF(GPIO_03, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rx_clk */
+			K1X_PADCONF(GPIO_04, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rx_d2 */
+			K1X_PADCONF(GPIO_05, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_rx_d3 */
+			K1X_PADCONF(GPIO_06, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx_d0 */
+			K1X_PADCONF(GPIO_07, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx_d1 */
+			K1X_PADCONF(GPIO_08, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx */
+			K1X_PADCONF(GPIO_09, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx_d2 */
+			K1X_PADCONF(GPIO_10, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx_d3 */
+			K1X_PADCONF(GPIO_11, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_tx_en */
+			K1X_PADCONF(GPIO_12, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac0_mdc */
+			K1X_PADCONF(GPIO_13, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac0_mdio */
+			K1X_PADCONF(GPIO_14, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_int_n */
+			K1X_PADCONF(GPIO_45, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac0_clk_ref */
+		>;
+	};
+
+	pinctrl_gmac1: gmac1_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_29, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rxdv */
+			K1X_PADCONF(GPIO_30, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rx_d0 */
+			K1X_PADCONF(GPIO_31, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rx_d1 */
+			K1X_PADCONF(GPIO_32, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rx_clk */
+			K1X_PADCONF(GPIO_33, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rx_d2 */
+			K1X_PADCONF(GPIO_34, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_rx_d3 */
+			K1X_PADCONF(GPIO_35, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_tx_d0 */
+			K1X_PADCONF(GPIO_36, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_tx_d1 */
+			K1X_PADCONF(GPIO_37, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_tx */
+			K1X_PADCONF(GPIO_38, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_tx_d2 */
+			K1X_PADCONF(GPIO_39, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_tx_d3 */
+			K1X_PADCONF(GPIO_40, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_tx_en */
+			K1X_PADCONF(GPIO_41, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_mdc */
+			K1X_PADCONF(GPIO_42, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))	/* gmac1_mdio */
+			K1X_PADCONF(GPIO_43, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_int_n */
+			K1X_PADCONF(GPIO_46, MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))	/* gmac1_clk_ref */
+		>;
+	};
+
+	pinctrl_wlan_wakeup: wlan_wakeup_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_FALL | PULL_DOWN | PAD_3V_DS2))   /* wifi edge detect */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49 GPIO_49 2
+		&pinctrl 58 GPIO_58 1
+		&pinctrl 63 GPIO_63 3
+		&pinctrl 67 GPIO_67 1
+		&pinctrl 75 GPIO_75 1
+		&pinctrl 79 GPIO_79 1
+		&pinctrl 90 GPIO_90 1
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 115 GPIO_115 2
+		&pinctrl 118 GPIO_118 2
+		&pinctrl 120 GPIO_120 1
+		&pinctrl 122 GPIO_122 1
+		&pinctrl 125 GPIO_125 1
+		&pinctrl 127 GPIO_127 1
+	>;
+};
+
+/* SD */
+&sdhci0 {
+	pinctrl-names = "default","fast";
+	pinctrl-0 = <&pinctrl_mmc1>;
+	pinctrl-1 = <&pinctrl_mmc1_fast>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	cd-inverted;
+	vmmc-supply = <&dcdc_4>;
+	vqmmc-supply = <&ldo_1>;
+	no-mmc;
+	no-sdio;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_SDR12 |
+			MMC_CAP_UHS_SDR25
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_INVERTED_WRITE_PROTECT |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE |
+			SDHCI_QUIRK2_SET_AIB_MMC
+			)>;
+	spacemit,aib_mmc1_io_reg = <0xD401E81C>;
+	spacemit,apbc_asfar_reg = <0xD4015050>;
+	spacemit,apbc_assar_reg = <0xD4015054>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0x7f>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <204800000>;
+	status = "okay";
+};
+
+/* SDIO */
+&sdhci1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mmc2>;
+	bus-width = <4>;
+	non-removable;
+	vqmmc-supply = <&dcdc_3>;
+	no-mmc;
+	no-sd;
+	keep-power-in-suspend;
+	/* bcmdhd use private oob solution rather than dat1/standard wakeup */
+	/delete-property/ enable-sdio-wakeup;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_DDR50 |
+			MMC_CAP_NEEDS_POLL
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE
+			)>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	no-sd;
+	no-sdio;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN
+			)>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+&eth0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	emac,reset-gpio = <&gpio 110 0>;
+	emac,reset-active-low;
+	emac,reset-delays-us = <0 10000 100000>;
+
+	/* store forward mode */
+	tx-threshold = <1518>;
+	rx-threshold = <12>;
+	tx-ring-num = <1024>;
+	rx-ring-num = <1024>;
+	dma-burst-len = <5>;
+
+	ref-clock-from-phy;
+
+	clk-tuning-enable;
+	clk-tuning-by-delayline;
+	tx-phase = <60>;
+	rx-phase = <73>;
+
+	nvmem-cells = <&mac_address0>;
+	nvmem-cell-names = "mac-address";
+
+	phy-handle = <&rgmii0>;
+
+	status = "okay";
+
+	mdio-bus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii0: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+			phy-mode = "rgmii";
+		};
+	};
+};
+
+&eth1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac1>;
+
+	emac,reset-gpio = <&gpio 115 0>;
+	emac,reset-active-low;
+	emac,reset-delays-us = <0 10000 100000>;
+
+	/* store forward mode */
+	tx-threshold = <1518>;
+	rx-threshold = <12>;
+	tx-ring-num = <1024>;
+	rx-ring-num = <1024>;
+	dma-burst-len = <5>;
+
+	ref-clock-from-phy;
+
+	clk-tuning-enable;
+	clk-tuning-by-delayline;
+	tx-phase = <90>;
+	rx-phase = <73>;
+	nvmem-cells = <&mac_address1>;
+	nvmem-cell-names = "mac-address";
+
+	phy-handle = <&rgmii1>;
+
+	status = "okay";
+
+	mdio-bus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii1: phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+			phy-mode = "rgmii";
+		};
+	};
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&ehci {
+	spacemit,ude-mode = <MV_USB_MODE_HOST>;
+	spacemit,reset-on-resume;
+	status = "okay";
+};
+
+
+&udc {
+	/*spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	spacemit,extern-attr = <MV_USB_HAS_VBUS_IDPIN_DETECTION>;*/
+	spacemit,udc-mode = <MV_USB_MODE_UDC>;
+	status = "disabled";
+};
+
+&usbphy1 {
+	status = "okay";
+};
+
+&ehci1 {
+	spacemit,reset-on-resume;
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usb3hub {
+	vbus-gpios = <&gpio 127 0>;	/* gpio_127 for usb1 vbus on */
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	reset-on-resume;
+	dwc3@c0a00000 {
+		dr_mode = "otg";
+		phy_type = "utmi";
+		snps,hsphy_interface = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		usb-role-switch;
+		role-switch-default-mode = "host";
+	};
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	k1x,pwr_on = <&gpio 122 0>;
+	status = "okay";
+};
+
+&pcie2_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie2_4>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "okay";
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "okay";
+	};
+};
+
+/* &rcpu { */
+/* 	mboxes = <&mailbox 0>, <&mailbox 1>; */
+/* 	mbox-names = "vq0", "vq1"; */
+/* 	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>; */
+/* 	status = "okay"; */
+/* }; */
+
+
+&cpp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&rcpu {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rcpu>;
+	mboxes = <&mailbox 0>, <&mailbox 1>;
+	mbox-names = "vq0", "vq1";
+	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>;
+	status = "okay";
+};
+
+&i2s0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sspa0_0>;
+	status = "okay";
+};
+
+&sound_hdmi {
+	status = "okay";
+};
+
+&pwm12 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm12_1>;
+	status = "okay";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm3_1>;
+	status = "okay";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm4_1>;
+	status = "okay";
+};
+
+&pwm13 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm13_1>;
+	status = "okay";
+};
+
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_1>;
+	status = "okay";
+};
+&pwm6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm6_1>;
+	status = "okay";
+};
+
+
+&pwm14 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm14_1>;
+	status = "okay";
+};
+
+&pwm7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm7_1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2_2>;
+	status = "okay";
+};
+
+&pwm5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm5_1>;
+	status = "okay";
+};
+
+&rpwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rpwm2_0>;
+	status = "okay";
+};
+
+&frontsensor {
+	status = "disabled";
+};
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts b/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
index 4f5cbdb670e4..beebf2e03bf4 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MINI-PC.dts
@@ -623,6 +623,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
index eed13a50e1ef..e5db5f39daac 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Book.dts
@@ -201,7 +201,7 @@ &dpu_online2_dsi {
 	spacemit-dpu-bitclk = <933000000>;
 	dsi_1v2-supply = <&ldo_5>;
 	vin-supply-names = "dsi_1v2";
-	enable-gpio = <&gpio 83 0>;
+	enable-gpio = <&gpio 75 0>;
 	status = "okay";
 };
 
@@ -326,7 +326,7 @@ lt8911exb_i2c@29 {
 		reg = <0x29>;
 
 		reset-gpio = <&gpio 114 0>;
-		bl-gpio = <&gpio 75 0>;
+		bl-gpio = <&gpio 83 0>;
 		standby-gpio = <&gpio 92 0>;
 
 		status = "okay";
@@ -545,6 +545,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
index 24a15834d1a4..47158b5da12b 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Card.dts
@@ -507,6 +507,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
@@ -622,7 +626,7 @@ SDHCI_QUIRK2_SET_AIB_MMC
 	spacemit,apbc_assar_reg = <0xD4015054>;
 	spacemit,rx_dline_reg = <0x0>;
 	spacemit,tx_dline_reg = <0x0>;
-	spacemit,tx_delaycode = <0x7f>;
+	spacemit,tx_delaycode = <0x8f>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <204800000>;
 	status = "okay";
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
index 5ee252248309..d371a92c9501 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-N1.dts
@@ -380,6 +380,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
index 68fb018652c4..11ee3fdd6d58 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
@@ -625,6 +625,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 
 	sgm4154x: sgm4154x@1a {
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
index 8c8fd9fec450..4ab28479b263 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
@@ -646,6 +646,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
@@ -745,7 +749,7 @@ SDHCI_QUIRK2_SET_AIB_MMC
 	spacemit,apbc_assar_reg = <0xD4015054>;
 	spacemit,rx_dline_reg = <0x0>;
 	spacemit,tx_dline_reg = <0x0>;
-	spacemit,tx_delaycode = <0x7f>;
+	spacemit,tx_delaycode = <0xaf>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <204800000>;
 	status = "okay";
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
index 6d8e6f3c510d..116deeedf474 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Pi.dts
@@ -540,6 +540,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
@@ -682,7 +686,7 @@ SDHCI_QUIRK2_SET_AIB_MMC
 	spacemit,apbc_assar_reg = <0xD4015054>;
 	spacemit,rx_dline_reg = <0x0>;
 	spacemit,tx_dline_reg = <0x0>;
-	spacemit,tx_delaycode = <0x7f>;
+	spacemit,tx_delaycode = <0x9f>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <204800000>;
 	status = "okay";
@@ -713,7 +717,7 @@ SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
 			SDHCI_QUIRK2_BROKEN_PHY_MODULE
 			)>;
 	spacemit,rx_dline_reg = <0x0>;
-	spacemit,tx_delaycode = <0x30>;
+	spacemit,tx_delaycode = <0x9f>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <375000000>;
 	status = "okay";
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts b/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
new file mode 100644
index 000000000000..e9096c1ccaf6
--- /dev/null
+++ b/arch/riscv/boot/dts/spacemit/k1-x_baton-camera.dts
@@ -0,0 +1,911 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/* Copyright (c) 2023 Spacemit, Inc */
+
+/dts-v1/;
+
+#include "k1-x.dtsi"
+#include "k1-x-efuse.dtsi"
+#include "k1-x_pinctrl.dtsi"
+#include "lcd/lcd_gx09inx101_mipi.dtsi"
+#include "k1-x-hdmi.dtsi"
+#include "k1-x-lcd.dtsi"
+#include "k1-x-camera-sdk.dtsi"
+#include "k1-x_opp_table.dtsi"
+#include "k1-x_thermal_cooling.dtsi"
+
+/ {
+	model = "spacemit k1-x baton-camera board";
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <24000000>;
+
+		cpu_0: cpu@0 {
+			cpu-ai = "true";
+		};
+
+		cpu_1: cpu@1 {
+			cpu-ai = "true";
+		};
+
+		cpu_2: cpu@2 {
+			reg = <2>;
+			cpu-ai = "true";
+		};
+
+		cpu_3: cpu@3 {
+			reg = <3>;
+			cpu-ai = "true";
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu_0>;
+				};
+
+				core1 {
+					cpu = <&cpu_1>;
+				};
+
+				core2 {
+					cpu = <&cpu_2>;
+				};
+
+				core3 {
+					cpu = <&cpu_3>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu_4>;
+				};
+
+				core1 {
+					cpu = <&cpu_5>;
+				};
+
+				core2 {
+					cpu = <&cpu_6>;
+				};
+
+				core3 {
+					cpu = <&cpu_7>;
+				};
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00000000 0x0 0x80000000>;
+	};
+
+	memory@100000000 {
+		device_type = "memory";
+		reg = <0x1 0x00000000 0x0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			/* alloc memory from 0x40000000~0x80000000 */
+			alloc-ranges = <0 0x40000000 0 0x40000000>;
+			/* size of cma buffer is 384MByte */
+			size = <0 0x18000000>;
+			/* start address is 1Mbyte aligned */
+			alignment = <0x0 0x100000>;
+			linux,cma-default;
+			/* besides hardware, dma for ex. buffer can be used by memory management */
+			reusable;
+		};
+
+		/* reserved 384K for dpu, including mmu table(256K) and cmdlist(128K) */
+		dpu_resv: dpu_reserved@2ff40000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x2ff40000 0x0 0x000C0000>;
+			no-map;
+		};
+	};
+
+	chosen {
+		bootargs = "earlycon=sbi console=ttyS0,115200n8 debug loglevel=8 swiotlb=65536 rdinit=/init";
+		stdout-path = "serial0:115200n8";
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc4v0_baseboard: vcc4v0-baseboard {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc4v0_baseboard";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <4000000>;
+		regulator-max-microvolt = <4000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led1 {
+			label = "sys-led";
+			gpios = <&gpio 96 0>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+			status = "okay";
+		};
+	};
+
+	usb2hub: usb2hub {
+		compatible = "spacemit,usb3-hub";
+		vbus-gpios = <&gpio 123 0>;	/* for usb2 hub output vbus */
+		status = "okay";
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart0_2>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_0>;
+	status = "okay";
+};
+
+
+&uart8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart8_2>;
+	status = "okay";
+};
+
+&pwm14 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm14_1>;
+	status = "okay";
+};
+
+&dpu_online2_dsi {
+	memory-region = <&dpu_resv>;
+	spacemit-dpu-bitclk = <1000000000>;
+	spacemit-dpu-escclk = <76800000>;
+	dsi_1v2-supply = <&ldo_5>;
+	vin-supply-names = "dsi_1v2";
+	status = "disabled";
+};
+
+&dsi2 {
+	status = "disabled";
+
+	panel2: panel2@0 {
+		status = "ok";
+		compatible = "spacemit,mipi-panel2";
+		reg = <0>;
+
+		gpios-reset = <41>;
+		gpios-dc = <40 83>;
+		id = <2>;
+		delay-after-reset = <10>;
+		force-attached = "lcd_gx09inx101_mipi";
+	};
+};
+
+&lcds {
+	status = "disabled";
+};
+
+&dpu_online2_hdmi {
+	memory-region = <&dpu_resv>;
+	status = "disabled";
+};
+
+&hdmi{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_0>;
+	status = "disabled";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+};
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_0>;
+	spacemit,i2c-fast-mode;
+	status = "okay";
+
+	eeprom@50{
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		power-domains = <&power K1X_PMU_DUMMY_PWR_DOMAIN>;
+		status = "disabled";
+
+		mac_address0: mac_address0@0 {
+			reg = <0x0 6>;
+		};
+
+		mac_address1: mac_address1@6 {
+			reg = <0x6 6>;
+		};
+	};
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_2>;
+	status = "disabled";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4_2>;
+	status = "disabled";
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c5_0>;
+	status = "okay";
+
+	gt9xx@5d {
+		compatible = "goodix,gt9xx";
+		reg = <0x5d>;
+
+		reset-gpios = <&gpio 97 GPIO_ACTIVE_HIGH>;
+		irq-gpios = <&gpio 124 GPIO_ACTIVE_HIGH>;
+		irq-flags = <2>;
+
+		touchscreen-max-id = <11>;
+		touchscreen-size-x = <1200>;
+		touchscreen-size-y = <1920>;
+		touchscreen-max-w = <512>;
+		touchscreen-max-p = <512>;
+
+		goodix,int-sync = <1>;
+		status = "okay";
+	};
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6_2>;
+	status = "disabled";
+};
+
+&i2c7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c7>;
+	status = "okay";
+};
+
+&i2c8 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c8>;
+	status = "okay";
+
+	spm8821@41 {
+		compatible = "spacemit,spm8821";
+		reg = <0x41>;
+		interrupt-parent = <&intc>;
+		interrupts = <64>;
+		status = "okay";
+
+		vcc_sys-supply = <&vcc4v0_baseboard>;
+		dcdc5-supply = <&dcdc_5>;
+
+		regulators {
+			compatible = "pmic,regulator,spm8821";
+
+			/* buck */
+			dcdc_1: DCDC_REG1 {
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <650000>;
+				};
+			};
+
+			dcdc_2: DCDC_REG2 {
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_3: DCDC_REG3 {
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_4: DCDC_REG4 {
+				regulator-name = "dcdc4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			dcdc_5: DCDC_REG5 {
+				regulator-name = "dcdc5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			dcdc_6: DCDC_REG6 {
+				regulator-name = "dcdc6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3450000>;
+				regulator-ramp-delay = <5000>;
+				regulator-always-on;
+			};
+
+			/* aldo */
+			ldo_1: LDO_REG1 {
+				regulator-name = "ldo1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				/* set the min voltage means will disable this vol in suspend for ldo */
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_2: LDO_REG2 {
+				regulator-name = "ldo2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_3: LDO_REG3 {
+				regulator-name = "ldo3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_4: LDO_REG4 {
+				regulator-name = "ldo4";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			/* dldo */
+			ldo_5: LDO_REG5 {
+				regulator-name = "ldo5";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_6: LDO_REG6 {
+				regulator-name = "ldo6";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_7: LDO_REG7 {
+				regulator-name = "ldo7";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <500000>;
+				};
+			};
+
+			ldo_8: LDO_REG8 {
+				regulator-name = "ldo8";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_9: LDO_REG9 {
+				regulator-name = "ldo9";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			ldo_10: LDO_REG10 {
+				regulator-name = "ldo10";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-always-on;
+			};
+
+			ldo_11: LDO_REG11 {
+				regulator-name = "ldo11";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+			};
+
+			sw_1: SWITCH_REG1 {
+				regulator-name = "switch1";
+			};
+		};
+
+		pmic_pinctrl: pinctrl {
+			compatible = "pmic,pinctrl,spm8821";
+			gpio-controller;
+			#gpio-cells = <2>;
+			spacemit,npins = <6>;
+/**
+ *			led_pins: led-pins {
+ *				pins = "PIN3";
+ *				function = "sleep";
+ *				bias-disable = <0>;
+ *				drive-open-drain = <0x1>;
+ *			};
+ */
+		};
+
+		pwr_key: key {
+			compatible = "pmic,pwrkey,spm8821";
+		};
+
+		ext_rtc: rtc {
+			compatible = "pmic,rtc,spm8821";
+		};
+	};
+};
+
+&pinctrl {
+	pinctrl-single,gpio-range = <
+		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_63  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_64  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_65  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_67  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range PRI_TDI  2 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_79  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_90  1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_91  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range DVL0     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range DVL1     1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_110 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_111 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_113 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_114 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_115 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+		&range GPIO_116 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_118 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_123 1 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS0)
+		&range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
+	>;
+
+	pinctrl_rcpu: pinctrl_rcpu_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_47,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_tx */
+			K1X_PADCONF(GPIO_48,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_rx */
+		>;
+	};
+
+	pinctrl_gmac0: gmac0_grp {
+		pinctrl-single,pins =<
+			K1X_PADCONF(GPIO_00,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rxdv */
+			K1X_PADCONF(GPIO_01,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d0 */
+			K1X_PADCONF(GPIO_02,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d1 */
+			K1X_PADCONF(GPIO_03,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_clk */
+			K1X_PADCONF(GPIO_04,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d2 */
+			K1X_PADCONF(GPIO_05,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_rx_d3 */
+			K1X_PADCONF(GPIO_06,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d0 */
+			K1X_PADCONF(GPIO_07,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d1 */
+			K1X_PADCONF(GPIO_08,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx */
+			K1X_PADCONF(GPIO_09,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d2 */
+			K1X_PADCONF(GPIO_10,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_d3 */
+			K1X_PADCONF(GPIO_11,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_tx_en */
+			K1X_PADCONF(GPIO_12,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac0_mdc */
+			K1X_PADCONF(GPIO_13,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS0))   /* gmac0_mdio */
+			K1X_PADCONF(GPIO_14,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_int_n */
+			K1X_PADCONF(GPIO_45,    MUX_MODE1, (EDGE_NONE | PULL_DIS | PAD_1V8_DS2))   /* gmac0_clk_ref */
+		>;
+	};
+};
+
+&gpio{
+	gpio-ranges = <
+		&pinctrl 49  GPIO_49  2
+		&pinctrl 58  GPIO_58  1
+		&pinctrl 63  GPIO_63  1
+		&pinctrl 65  GPIO_65  1
+		&pinctrl 67  GPIO_67  1
+		&pinctrl 70  PRI_TDI  4
+		&pinctrl 74  GPIO_74  1
+		&pinctrl 79  GPIO_79  1
+		&pinctrl 80  GPIO_80  4
+		&pinctrl 90  GPIO_90  3
+		&pinctrl 96  DVL0     2
+		&pinctrl 110 GPIO_110 1
+		&pinctrl 111 GPIO_111 1
+		&pinctrl 113 GPIO_113 1
+		&pinctrl 114 GPIO_114 3
+		&pinctrl 118 GPIO_118 1
+		&pinctrl 123 GPIO_123 5
+	>;
+};
+
+/* SD */
+&sdhci0 {
+	pinctrl-names = "default","fast";
+	pinctrl-0 = <&pinctrl_mmc1>;
+	pinctrl-1 = <&pinctrl_mmc1_fast>;
+	bus-width = <4>;
+	cd-gpios = <&gpio 80 0>;
+	vmmc-supply = <&dcdc_4>;
+	vqmmc-supply = <&ldo_1>;
+	no-mmc;
+	no-sdio;
+	spacemit,sdh-host-caps-disable = <(
+			MMC_CAP_UHS_SDR12 |
+			MMC_CAP_UHS_SDR25
+			)>;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_INVERTED_WRITE_PROTECT |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+			SDHCI_QUIRK2_BROKEN_PHY_MODULE |
+			SDHCI_QUIRK2_SET_AIB_MMC
+			)>;
+	spacemit,aib_mmc1_io_reg = <0xD401E81C>;
+	spacemit,apbc_asfar_reg = <0xD4015050>;
+	spacemit,apbc_assar_reg = <0xD4015054>;
+	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0x7f>;
+	spacemit,rx_tuning_limit = <50>;
+	spacemit,sdh-freq = <204800000>;
+	status = "disabled";
+};
+
+&eth0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gmac0>;
+
+	emac,reset-gpio = <&gpio 110 0>;
+	emac,reset-active-low;
+	emac,reset-delays-us = <0 10000 100000>;
+
+	/* store forward mode */
+	tx-threshold = <1518>;
+	rx-threshold = <12>;
+	tx-ring-num = <1024>;
+	rx-ring-num = <1024>;
+	dma-burst-len = <5>;
+
+	ref-clock-from-phy;
+
+	clk-tuning-enable;
+	clk-tuning-by-delayline;
+	tx-phase = <60>;
+	rx-phase = <73>;
+
+	nvmem-cells = <&mac_address0>;
+	nvmem-cell-names = "mac-address";
+
+	phy-handle = <&rgmii0>;
+
+	status = "okay";
+
+	mdio-bus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		rgmii0: phy@0 {
+			compatible = "ethernet-phy-id001c.c916";
+			device_type = "ethernet-phy";
+			reg = <0x1>;
+			phy-mode = "rgmii";
+		};
+	};
+};
+
+/* eMMC */
+&sdhci2 {
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	no-sd;
+	no-sdio;
+	spacemit,sdh-quirks = <(
+			SDHCI_QUIRK_BROKEN_CARD_DETECTION |
+			SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+			)>;
+	spacemit,sdh-quirks2 = <(
+			SDHCI_QUIRK2_PRESET_VALUE_BROKEN
+			)>;
+	spacemit,sdh-freq = <375000000>;
+	status = "okay";
+};
+
+
+&usbphy {
+	status = "okay";
+};
+
+&udc {
+	/*spacemit,udc-mode = <MV_USB_MODE_OTG>;
+	spacemit,extern-attr = <MV_USB_HAS_VBUS_IDPIN_DETECTION>;*/
+	spacemit,udc-mode = <MV_USB_MODE_UDC>;
+	status = "okay";
+};
+
+&usbphy1 {
+	status = "okay";
+};
+
+&ehci1 {
+	spacemit,reset-on-resume;
+	status = "okay";
+};
+
+&usb2phy {
+	status = "okay";
+};
+
+&combphy {
+	status = "okay";
+};
+
+&usb3hub {
+	vbus-gpios = <&gpio 79 0>;	/* gpio_79 for usb3 hub output vbus */
+	status = "okay";
+};
+
+&usbdrd3 {
+	status = "okay";
+	reset-on-resume;
+	dwc3@c0a00000 {
+		dr_mode = "host";
+		phy_type = "utmi";
+		snps,hsphy_interface = "utmi";
+		snps,dis_enblslpm_quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		snps,parkmode-disable-ss-quirk;
+	};
+};
+
+&pcie1_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie1_3>;
+	status = "disabled";
+};
+
+&pcie2_rc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie2_4>;
+	status = "disabled";
+};
+
+&imggpu {
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "disabled";
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <26500000>;
+		m25p,fast-read;
+		broken-flash-reset;
+		status = "disabled";
+	};
+};
+
+&spi3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ssp3_0>;
+	status = "disabled";
+};
+
+&pwm_bl {
+	pwms = <&pwm14 2000>;
+	brightness-levels = <
+		0   40  40  40  40  40  40  40  40  40  40  40  40  40  40  40
+		40  40  40  40  40  40  40  40  40  40  40  40  40  40  40  40
+		40  40  40  40  40  40  40  40  40  41  42  43  44  45  46  47
+		48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63
+		64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79
+		80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
+		96  97  98  99  100 101 102 103 104 105 106 107 108 109 110 111
+		112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
+		128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143
+		144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
+		160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
+		176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
+		192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
+		208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
+		224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239
+		240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255
+	>;
+	default-brightness-level = <100>;
+
+	status = "okay";
+};
+
+/* MIPI CSI1, clk lane1 */
+&backsensor {
+	af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 113 0>;
+	//reset-gpios = <&gpio 111 0>;
+
+	twsi-index = <0>;
+
+	status = "okay";
+};
+
+/* MIPI CSI3 data line2,3 clk lane2 */
+&backsensor_aux {
+	//af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	//dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 114 0>;
+	reset-gpios = <&gpio 112 0>;
+
+	twsi-index = <1>;
+
+	status = "okay";
+};
+
+/* MIPI CSI3 data line0,1 clk lane3 */
+&frontsensor {
+	//af_2v8-supply = <&ldo_3>;
+	avdd_2v8-supply = <&ldo_2>;
+	dovdd_1v8-supply = <&ldo_7>;
+	dvdd_1v2-supply = <&ldo_6>;
+
+	pwdn-gpios = <&gpio 122 0>;
+	reset-gpios = <&gpio 121 0>;
+
+	twsi-index = <7>;
+
+	status = "okay";
+};
+&csiphy0 {
+
+	status = "okay";
+};
+&csiphy1 {
+
+	status = "disabled";
+};
+&csiphy2 {
+
+	status = "okay";
+};
+
+&ccic0 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic1 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&ccic2 {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+
+	status = "okay";
+};
+&isp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&cpp {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&vi {
+	power-domains = <&power K1X_PMU_ISP_PWR_DOMAIN>;
+};
+
+&rcpu {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_rcpu>;
+	mboxes = <&mailbox 0>, <&mailbox 1>;
+	mbox-names = "vq0", "vq1";
+	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>;
+	status = "okay";
+};
+
+&sound_hdmi {
+	status = "disabled";
+};
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts b/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
index 721d351bcee7..9d60d242cb58 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_deb1.dts
@@ -532,6 +532,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
@@ -671,7 +675,7 @@ SDHCI_QUIRK2_SET_AIB_MMC
 	spacemit,apbc_assar_reg = <0xD4015054>;
 	spacemit,rx_dline_reg = <0x0>;
 	spacemit,tx_dline_reg = <0x0>;
-	spacemit,tx_delaycode = <0x7f>;
+	spacemit,tx_delaycode = <0x5f>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <204800000>;
 	status = "okay";
@@ -702,6 +706,7 @@ SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
 			SDHCI_QUIRK2_BROKEN_PHY_MODULE
 			)>;
 	spacemit,rx_dline_reg = <0x0>;
+	spacemit,tx_delaycode = <0x8f>;
 	spacemit,rx_tuning_limit = <50>;
 	spacemit,sdh-freq = <375000000>;
 	status = "okay";
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts b/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
index c3bff62c562f..3b51cafcbff0 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_kx312.dts
@@ -548,6 +548,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts b/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
index 94c912b26f3a..9a911076d5f5 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_lpi3a.dts
@@ -15,7 +15,7 @@
 
 / {
 	model = "SiPEED LPi3A Board";
-	modules_usrload = "aic8800_bsp", "aic8800_fdrv", "aic8800_btlpm";
+	modules_usrload = "aic8800_bsp,aic8800_fdrv,aic8800_btlpm";
 
 	cpus: cpus {
 		#address-cells = <1>;
@@ -145,12 +145,12 @@ rf_pwrseq: rf-pwrseq {
 		//vdd_voltage = <3300000>;
 		io-supply = <&dcdc_3>;
 		io_voltage = <1800000>;
-		pwr-gpios  = <&ioexp1 4 0>;
+		pwr-gpios  = <&ioexp1 6 0>;  //dummy
 		status = "okay";
 
 		wlan_pwrseq: wlan-pwrseq {
 			compatible = "spacemit,wlan-pwrseq";
-			//regon-gpios     = <&ioexp1 4 0>;
+			regon-gpios     = <&ioexp1 4 0>; //must
 			interrupt-parent = <&pinctrl>;
 			interrupts = <268>;
 			pinctrl-names = "default";
@@ -633,6 +633,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
@@ -784,7 +788,7 @@ &sdhci1 {
 	pinctrl-0 = <&pinctrl_mmc2>;
 	bus-width = <4>;
 	non-removable;
-	vqmmc-supply = <&dcdc_3>;
+	//vqmmc-supply = <&dcdc_3>;
 	no-mmc;
 	no-sd;
 	keep-power-in-suspend;
@@ -804,7 +808,7 @@ SDHCI_QUIRK2_BROKEN_PHY_MODULE
 			)>;
 	spacemit,rx_dline_reg = <0x0>;
 	spacemit,rx_tuning_limit = <50>;
-	spacemit,sdh-freq = <375000000>;
+	spacemit,sdh-freq = <102400000>;
 	status = "okay";
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts b/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
index 5ee17bfae933..4e62ddc0ee51 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_milkv-jupiter.dts
@@ -554,6 +554,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts b/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
index 7fe4b751bf9e..1b420eaf864a 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_mingo.dts
@@ -361,6 +361,10 @@ pwr_key: key {
 		ext_rtc: rtc {
 			compatible = "pmic,rtc,spm8821";
 		};
+
+		ext_adc: adc {
+			compatible = "pmic,adc,spm8821";
+		};
 	};
 };
 
diff --git a/arch/riscv/configs/k1_defconfig b/arch/riscv/configs/k1_defconfig
index 463c5ef2fe65..fc9ee6c7de4a 100644
--- a/arch/riscv/configs/k1_defconfig
+++ b/arch/riscv/configs/k1_defconfig
@@ -1036,6 +1036,7 @@ CONFIG_EXTCON_USB_K1XCI=y
 CONFIG_EXTCON_USB_GPIO=y
 CONFIG_IIO=y
 CONFIG_MXC4005=y
+CONFIG_SPACEMIT_P1_ADC=y
 CONFIG_STK3310=y
 CONFIG_PWM=y
 CONFIG_PWM_PXA=y
diff --git a/drivers/gpu/drm/spacemit/dpu/dpu_saturn.c b/drivers/gpu/drm/spacemit/dpu/dpu_saturn.c
index a77ad3d2837d..e4862f19032e 100644
--- a/drivers/gpu/drm/spacemit/dpu/dpu_saturn.c
+++ b/drivers/gpu/drm/spacemit/dpu/dpu_saturn.c
@@ -1006,6 +1006,26 @@ void spacemit_plane_update_hw_channel(struct drm_plane *plane)
 	crtc_x = state->crtc_x;
 	crtc_y = state->crtc_y;
 
+	if (spacemit_plane_state->is_crop) {
+
+		// src_w = state->src_w >> 16;
+		src_h = state->src_h >> 16;
+		src_x = state->src_x >> 16;
+		src_y = state->src_y >> 16;
+
+		// crtc_w = state->crtc_w;
+		crtc_h = state->crtc_h;
+		// crtc_x = state->crtc_x;
+		// crtc_y = state->crtc_y;
+
+		src_w = spacemit_plane_state->src_crop_w;
+		crtc_w = spacemit_plane_state->dst_crop_w;
+
+		crtc_x = spacemit_plane_state->dst_crop_x;
+		crtc_y = spacemit_plane_state->dst_crop_y;
+
+	}
+
 	if (rdma_id == RDMA_INVALID_ID)
 		solid_en = true;
 
diff --git a/drivers/gpu/drm/spacemit/spacemit_dmmu.c b/drivers/gpu/drm/spacemit/spacemit_dmmu.c
index e91853cf0092..220eb8fc726f 100644
--- a/drivers/gpu/drm/spacemit/spacemit_dmmu.c
+++ b/drivers/gpu/drm/spacemit/spacemit_dmmu.c
@@ -33,8 +33,9 @@ static inline void spacemit_dmmu_fill_pgtable(uint32_t *ttbr, struct sg_table *s
 		*ttbr++ = temp;
 }
 
-int spacemit_dmmu_map(struct drm_framebuffer *fb, struct dpu_mmu_tbl *mmu_tbl, u8 tbu_id, bool wb)
+int spacemit_dmmu_map(struct drm_plane *plane, struct dpu_mmu_tbl *mmu_tbl, u8 tbu_id, bool wb)
 {
+	struct drm_framebuffer *fb = plane->state->fb;
 	struct spacemit_drm_private *priv = fb->dev->dev_private;
 	struct spacemit_hw_device *hwdev = priv->hwdev;
 	const struct drm_format_info *format = NULL;
diff --git a/drivers/gpu/drm/spacemit/spacemit_dmmu.h b/drivers/gpu/drm/spacemit/spacemit_dmmu.h
index a5998c3565bb..b21ba36260c8 100644
--- a/drivers/gpu/drm/spacemit/spacemit_dmmu.h
+++ b/drivers/gpu/drm/spacemit/spacemit_dmmu.h
@@ -87,7 +87,7 @@ struct tbu_instance {
 	uint32_t ttb_size[3];
 };
 
-int spacemit_dmmu_map(struct drm_framebuffer *fb, struct dpu_mmu_tbl *mmu_tbl, u8 tbu_id, bool wb);
+int spacemit_dmmu_map(struct drm_plane *plane, struct dpu_mmu_tbl *mmu_tbl, u8 tbu_id, bool wb);
 void spacemit_dmmu_unmap(struct drm_plane *plane);
 
 #endif /* _SPACEMIT_DMMU_H_ */
diff --git a/drivers/gpu/drm/spacemit/spacemit_dpu.h b/drivers/gpu/drm/spacemit/spacemit_dpu.h
index 5f2a4998d14b..0e5012cdf02f 100644
--- a/drivers/gpu/drm/spacemit/spacemit_dpu.h
+++ b/drivers/gpu/drm/spacemit/spacemit_dpu.h
@@ -229,6 +229,17 @@ struct spacemit_plane_state {
 	u32 fbcmem_size;
 	uint64_t mclk;	//DPU MCLK = MAX(Mclk, Aclk) of all planes
 	uint64_t bw;	//BandWidth = SUM(BW_single) * 1.08
+	bool is_crop;
+	u32 src_crop_x;
+	u32 src_crop_y;
+	u32 src_crop_w;
+	u32 src_crop_h;
+	u32 dst_crop_x;
+	u32 dst_crop_y;
+	u32 dst_crop_w;
+	u32 dst_crop_h;
+	u32 screen_width;
+	u32 screen_height;
 	struct dpu_mmu_tbl mmu_tbl;
 	struct cmdlist cl;
 	uint64_t afbc_effc;
diff --git a/drivers/gpu/drm/spacemit/spacemit_planes.c b/drivers/gpu/drm/spacemit/spacemit_planes.c
index f47bbcc474c8..c49b9fe5b33b 100644
--- a/drivers/gpu/drm/spacemit/spacemit_planes.c
+++ b/drivers/gpu/drm/spacemit/spacemit_planes.c
@@ -257,9 +257,83 @@ static void spacemit_plane_atomic_update(struct drm_plane *plane,
 	struct spacemit_hw_device *hwdev = priv->hwdev;
 	u32 rdma_id = spacemit_pstate->rdma_id;
 
+	struct drm_crtc *dpu_crtc = &dpu->crtc;
+	struct drm_display_mode *mode = NULL;
+	u32 hdisplay;
+	u32 vdisplay;
+	u32 src_x, src_y, src_w, src_h;
+	u32 crtc_x, crtc_y, crtc_w, crtc_h;
+
 	DRM_DEBUG("%s()\n", __func__);
 	trace_spacemit_plane_atomic_update(dpu->dev_id);
 
+	mode = &dpu_crtc->mode;
+	hdisplay = mode->hdisplay;
+	vdisplay = mode->vdisplay;
+
+	src_w = plane->state->src_w >> 16;
+	src_h = plane->state->src_h >> 16;
+	src_x = plane->state->src_x >> 16;
+	src_y = plane->state->src_y >> 16;
+
+	crtc_w = plane->state->crtc_w;
+	crtc_h = plane->state->crtc_h;
+	crtc_x = plane->state->crtc_x;
+	crtc_y = plane->state->crtc_y;
+
+	spacemit_pstate->screen_width = hdisplay;
+	spacemit_pstate->screen_height = vdisplay;
+
+	if ((plane->type == DRM_PLANE_TYPE_CURSOR) && ((crtc_x + crtc_w) > hdisplay)) {
+
+		if ((crtc_x > (hdisplay - crtc_w)) && (crtc_x <= (hdisplay - ((crtc_w * 3) / 4)))) {
+			spacemit_pstate->src_crop_x = src_x;
+			spacemit_pstate->src_crop_y = src_y;
+			spacemit_pstate->src_crop_w = ((src_w * 3) / 4);
+			spacemit_pstate->src_crop_h = src_h;
+			spacemit_pstate->dst_crop_x = crtc_x;
+			spacemit_pstate->dst_crop_y = crtc_y;
+			spacemit_pstate->dst_crop_w = ((crtc_w * 3) / 4);
+			spacemit_pstate->dst_crop_h = crtc_h;
+			spacemit_pstate->is_crop = true;
+		} else if ((crtc_x > (hdisplay - ((crtc_w * 3) / 4))) && (crtc_x <= (hdisplay - (crtc_w  / 2)))) {
+			spacemit_pstate->src_crop_x = src_x;
+			spacemit_pstate->src_crop_y = src_y;
+			spacemit_pstate->src_crop_w = (src_w / 2);
+			spacemit_pstate->src_crop_h = src_h;
+			spacemit_pstate->dst_crop_x = crtc_x;
+			spacemit_pstate->dst_crop_y = crtc_y;
+			spacemit_pstate->dst_crop_w = (crtc_w / 2);
+			spacemit_pstate->dst_crop_h = crtc_h;
+			spacemit_pstate->is_crop = true;
+		} else if ((crtc_x > (hdisplay - (crtc_w / 2))) && (crtc_x <= (hdisplay - (crtc_w / 4)))){
+			spacemit_pstate->src_crop_x = src_x;
+			spacemit_pstate->src_crop_y = src_y;
+			spacemit_pstate->src_crop_w = (src_w / 4);
+			spacemit_pstate->src_crop_h = src_h;
+			spacemit_pstate->dst_crop_x = crtc_x;
+			spacemit_pstate->dst_crop_y = crtc_y;
+			spacemit_pstate->dst_crop_w = (crtc_w / 4);
+			spacemit_pstate->dst_crop_h = crtc_h;
+			spacemit_pstate->is_crop = true;
+		} else if ((crtc_x > (hdisplay - (crtc_w / 4))) && (crtc_x <= hdisplay)) {
+			spacemit_pstate->src_crop_x = src_x;
+			spacemit_pstate->src_crop_y = src_y;
+			spacemit_pstate->src_crop_w = (src_w / 4);
+			spacemit_pstate->src_crop_h = src_h;
+			spacemit_pstate->dst_crop_x = hdisplay - (crtc_w / 4);
+			spacemit_pstate->dst_crop_y = crtc_y;
+			spacemit_pstate->dst_crop_w = (crtc_w / 4);
+			spacemit_pstate->dst_crop_h = crtc_h;
+			spacemit_pstate->is_crop = true;
+		} else {
+			spacemit_pstate->is_crop = false;
+		}
+
+	} else {
+		spacemit_pstate->is_crop = false;
+	}
+
 	spacemit_plane_update_hw_channel(plane);
 
 	spacemit_update_hdr_matrix(plane, spacemit_pstate);
@@ -279,7 +353,7 @@ static void spacemit_plane_atomic_update(struct drm_plane *plane,
 			return;
 		}
 		tbu_id = !spacemit_pstate->right_image ? (rdma_id * 2) : (rdma_id * 2 + 1);
-		ret = spacemit_dmmu_map(plane->state->fb, &spacemit_pstate->mmu_tbl, tbu_id, false);
+		ret = spacemit_dmmu_map(plane, &spacemit_pstate->mmu_tbl, tbu_id, false);
 		if (!ret)
 			cmdlist_regs_packing(plane);
 		else
@@ -328,6 +402,7 @@ static void spacemit_plane_reset(struct drm_plane *plane)
 		s->state.zpos = hwdev->plane_nums - p->hw_pid - 1;
 		s->rdma_id = RDMA_INVALID_ID;
 		s->is_offline = 1;
+		s->is_crop = false;
 		s->scaler_id = SCALER_INVALID_ID;
 	}
 }
@@ -360,6 +435,19 @@ spacemit_plane_atomic_duplicate_state(struct drm_plane *plane)
 	s->scaler_id = SCALER_INVALID_ID;
 	s->use_scl = false;
 	s->fbcmem_size = 0;
+
+	s->is_crop = old_state->is_crop;
+	s->src_crop_x = old_state->src_crop_x;
+	s->src_crop_y = old_state->src_crop_y;
+	s->src_crop_w = old_state->src_crop_w;
+	s->src_crop_h = old_state->src_crop_h;
+	s->dst_crop_x = old_state->dst_crop_x;
+	s->dst_crop_y = old_state->dst_crop_y;
+	s->dst_crop_w = old_state->dst_crop_w;
+	s->dst_crop_h = old_state->dst_crop_h;
+	s->screen_width = old_state->screen_width;
+	s->screen_height = old_state->screen_height;
+
 	if (s->hdr_coefs_blob_prop)
 		drm_property_blob_get(s->hdr_coefs_blob_prop);
 	if (s->scale_coefs_blob_prop)
@@ -670,9 +758,13 @@ struct drm_plane *spacemit_plane_init(struct drm_device *drm,
 		for (j = 0; j < n_formats; j++)
 			formats[j] = hwdev->formats[j].format;
 
-		plane_type = (i < priv->num_pipes)
-			   ? DRM_PLANE_TYPE_PRIMARY
-			   : DRM_PLANE_TYPE_OVERLAY;
+		// plane_type = (i < priv->num_pipes)
+		// 	   ? DRM_PLANE_TYPE_PRIMARY
+		// 	   : DRM_PLANE_TYPE_OVERLAY;
+
+		plane_type = (i < priv->num_pipes) ? DRM_PLANE_TYPE_PRIMARY :
+			   (i == priv->num_pipes) ? DRM_PLANE_TYPE_CURSOR :
+			   DRM_PLANE_TYPE_OVERLAY;
 
 		err = drm_universal_plane_init(drm, &p->plane, plane_crtc_mask,
 					       &spacemit_plane_funcs, formats,
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 6dee3b686eff..0f165efdba8a 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -1448,4 +1448,10 @@ config XILINX_AMS
 	  The driver can also be built as a module. If so, the module will be called
 	  xilinx-ams.
 
+config SPACEMIT_P1_ADC
+	tristate "Spacemit P1 adc driver"
+	depends on MFD_SPACEMIT_PMIC
+	help
+	  Say yes here to support for Spacemit P1 analog-to-digital converter.
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 2facf979327d..dbb2d26ece2b 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -129,3 +129,4 @@ xilinx-xadc-y := xilinx-xadc-core.o xilinx-xadc-events.o
 obj-$(CONFIG_XILINX_XADC) += xilinx-xadc.o
 obj-$(CONFIG_XILINX_AMS) += xilinx-ams.o
 obj-$(CONFIG_SD_ADC_MODULATOR) += sd_adc_modulator.o
+obj-$(CONFIG_SPACEMIT_P1_ADC) += k1x_adc.o
diff --git a/drivers/iio/adc/k1x_adc.c b/drivers/iio/adc/k1x_adc.c
new file mode 100644
index 000000000000..1094d1759c5b
--- /dev/null
+++ b/drivers/iio/adc/k1x_adc.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/of.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/types.h>
+#include <linux/of_device.h>
+#include <linux/iio/driver.h>
+#include <linux/mfd/spacemit/spacemit_pmic.h>
+
+struct spacemit_adc_info {
+	int irq;
+	struct regmap *regmap;
+	struct mutex lock;
+	struct completion completion;
+};
+
+static struct adc_match_data *match_data;
+
+SPM8821_ADC_IIO_DESC;
+SPM8821_ADC_MATCH_DATA;
+
+static const struct of_device_id spacemit_adc_id_table[] = {
+	{ .compatible = "pmic,adc,spm8821", .data = (void *)&spm8821_adc_match_data },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, spacemit_adc_id_table);
+
+static int spacemit_spm8821_adc_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val)
+{
+	unsigned int value;
+	unsigned int adc_val_h, adc_val_l;
+	struct spacemit_adc_info *info;
+
+	info = iio_priv(indio_dev);
+
+	mutex_lock(&info->lock);
+
+	/* reset the ADC auto register */
+	regmap_update_bits(info->regmap, SPM8821_ADC_AUTO_REG,
+			SPM8821_ADC_AUTO_BIT_MSK, 0);
+
+	/* enable the ADC : ADC_CTRL[0] */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CTRL_REG,
+			SPM8821_ADC_CTRL_BIT_MSK, (1 << SPM8821_ADC_CTRL_EN_BIT_OFFSET));
+
+	/* choose the channel of adc : ADC_CFG[1] */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CFG1_REG,
+			SPM8821_ADC_CFG1_ADC_CHNNL_SEL_BIT_MSK,
+			(chan->channel + SPM8821_ADC_EXTERNAL_CHANNEL_OFFSET) <<
+			 SPM8821_ADC_CFG1_ADC_CHNNL_SEL_BIT_OFFSET);
+
+	/* ADC go */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CTRL_REG,
+			SPM8821_ADC_CTRL_BIT_MSK, (1 << SPM8821_ADC_CTRL_GO_BIT_OFFSET)  |
+						(1 << SPM8821_ADC_CTRL_EN_BIT_OFFSET));
+
+	/* then wait the completion */
+	wait_for_completion(&info->completion);
+
+	regmap_read(info->regmap, SPM8821_ADCIN0_RES_H_REG + chan->channel * 2, &adc_val_h);
+	regmap_read(info->regmap, SPM8821_ADCIN0_RES_L_REG + chan->channel * 2, &adc_val_l);
+
+	regmap_read(info->regmap, SPM8821_VERSION_ID_REG, &value);
+
+	*val = (adc_val_h << (ffs(SPM8821_ADCIN0_REG_L_BIT_MSK) - 1)) | (
+			(adc_val_l & SPM8821_ADCIN0_REG_L_BIT_MSK) >>
+			(ffs(SPM8821_ADCIN0_REG_L_BIT_MSK) - 1));
+
+	if (value == 0) {
+		/**
+		 * if the version of P1 is A, the data read from the register is the inverse of the real data
+		 * and the conversion accuracy of P1 is 12 bits
+		 */
+		*val = 4095 - *val;
+	}
+
+	pr_debug("%s:%d, read channel:%d, val:%u\n", __func__, __LINE__, chan->channel,
+			*val);
+
+	mutex_unlock(&info->lock);
+
+	return IIO_VAL_INT;
+}
+
+static int spacemit_spm8821_adc_scale(struct iio_chan_spec const *chan, int *val, int *val2)
+{
+	switch (chan->type) {
+	case IIO_VOLTAGE:
+		*val = 0;
+		/* 3000 % 4095 ~ 0.7326mv */
+		*val2 = 732600;
+		return IIO_VAL_INT_PLUS_MICRO;
+
+	default:
+		return -EINVAL;
+	}
+
+	return -EINVAL;
+}
+
+static int spacemit_adc_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *chan,
+			int *val, int *val2, long mask)
+{
+	switch (mask) {
+		case IIO_CHAN_INFO_RAW:
+			return spacemit_spm8821_adc_raw(indio_dev, chan, val);
+
+		case IIO_CHAN_INFO_SCALE:
+			return spacemit_spm8821_adc_scale(chan, val, val2);
+
+		default:
+			return -EINVAL;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info spacemit_adc_iio_info = {
+	.read_raw = &spacemit_adc_read_raw,
+};
+
+static irqreturn_t adc_complete_irq(int irq, void *_adc)
+{
+	struct spacemit_adc_info *info;
+	struct iio_dev *indio_dev = (struct iio_dev *)_adc;
+
+	info = iio_priv(indio_dev);
+
+	complete(&info->completion);
+
+	return IRQ_HANDLED;
+}
+
+static void spacemit_adc_init(struct iio_dev *indio_dev)
+{
+	struct spacemit_adc_info *info = iio_priv(indio_dev);
+
+	/* enable chop */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CFG1_REG,
+			SPM8821_ADC_CFG1_ADC_CHOP_EN_BIT_MSK, 1 << SPM8821_ADC_CFG1_ADC_CHOP_EN_BIT_OFFSET);
+
+	/* set the vref: 3v3 */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CFG2_REG,
+			SPM8821_ADC_CFG2_REF_SEL_BIT_MSK, SPM8821_ADC_CFG2_3V3_REF <<
+					SPM8821_ADC_CFG2_REF_SEL_BIT_OFFSET);
+	/* set adc deb num: 7 */
+	regmap_update_bits(info->regmap, SPM8821_ADC_CFG2_REG,
+			SPM8821_ADC_CFG2_DEB_NUM_BIT_MSK, SPM8821_ADC_CFG2_7_DEB_NUM <<
+					SPM8821_ADC_CFG2_DEB_NUM_BIT_OFFSET);
+}
+
+static int spacemit_adc_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct iio_dev *indio_dev;
+	struct spacemit_adc_info *info;
+	const struct of_device_id *of_id;
+	struct spacemit_pmic *pmic = dev_get_drvdata(pdev->dev.parent);
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	info = iio_priv(indio_dev);
+	info->irq = platform_get_irq(pdev, 0);
+	if (info->irq < 0) {
+		dev_err(&pdev->dev, "get irq failed\n");
+		return info->irq;
+	}
+
+	ret = devm_request_any_context_irq(&pdev->dev, info->irq,
+				adc_complete_irq, IRQF_TRIGGER_NONE | IRQF_ONESHOT,
+				"p1-adc", indio_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Can't register adc irq: %d\n", ret);
+		return ret;
+	}
+
+	info->regmap = pmic->regmap;
+
+	mutex_init(&info->lock);
+	init_completion(&info->completion);
+
+	of_id = of_match_device(spacemit_adc_id_table, &pdev->dev);
+	if (!of_id) {
+		dev_err(&pdev->dev, "Unable to match OF ID\n");
+		return -ENODEV;
+	}
+
+	/* adc init */
+	spacemit_adc_init(indio_dev);
+
+	match_data = (struct adc_match_data *)of_id->data;
+
+	indio_dev->name = pdev->name;
+	indio_dev->channels = match_data->iio_desc;
+	indio_dev->num_channels = match_data->nr_desc;
+	indio_dev->info = &spacemit_adc_iio_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	ret = devm_iio_map_array_register(&pdev->dev, indio_dev, NULL);
+	if (ret < 0)
+		return ret;
+
+	return devm_iio_device_register(&pdev->dev, indio_dev);
+}
+
+static struct platform_driver spacemit_adc_driver = {
+	.probe = spacemit_adc_probe,
+	.driver = {
+		.name = "spacemit-pmic-adc",
+		.of_match_table = of_match_ptr(spacemit_adc_id_table),
+	},
+};
+module_platform_driver(spacemit_adc_driver);
+
+MODULE_DESCRIPTION("SPACEMIT adc driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/spacemit/camera/cam_cpp/k1x_cpp.c b/drivers/media/platform/spacemit/camera/cam_cpp/k1x_cpp.c
index 1990736cc298..024644514d2c 100644
--- a/drivers/media/platform/spacemit/camera/cam_cpp/k1x_cpp.c
+++ b/drivers/media/platform/spacemit/camera/cam_cpp/k1x_cpp.c
@@ -41,6 +41,7 @@
 
 #define CPP_DRV_NAME "mars-cpp"
 
+//#define CPP_FNC_DEFAULT_FREQ (416000000)
 #define CPP_FNC_DEFAULT_FREQ (307200000)
 #define ISP_BUS_DEFAULT_FREQ (307200000)
 
diff --git a/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.c b/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.c
index e0c71e9d613d..8504c7a4eeaf 100644
--- a/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.c
+++ b/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.c
@@ -1094,102 +1094,124 @@ static long camsnr_compat_ioctl(struct file *file, unsigned int cmd, unsigned lo
 	return 0;
 }
 #endif
-
-static int camsnr_open(struct inode *inode, struct file *file)
+static bool use_pinmulti = false;
+static int request_res_in_pinmulti_mode(struct cam_sensor_device *msnr_dev)
 {
-	struct cam_sensor_device *msnr_dev =
-	    container_of(inode->i_cdev, struct cam_sensor_device, cdev);
-	u32 cell_id;
 	struct device *dev = NULL;
-	int ret;
-
-	file->private_data = msnr_dev;
+	int ret = 0;
+	u32 cell_id;
 
-	if (msnr_dev->is_pinmulti) {
-		dev = &msnr_dev->pdev->dev;
-		cell_id = msnr_dev->id;
+	dev = &msnr_dev->pdev->dev;
+	cell_id = msnr_dev->id;
 
-		// msnr_dev->pinctrl = devm_pinctrl_get (dev);
-		msnr_dev->pinctrl = pinctrl_get_select (dev, "mclk_multi");
-		if (IS_ERR(msnr_dev->pinctrl)) {
-			cam_err("unable to get sensor%d mclk pinctrl\n", cell_id);
-			return PTR_ERR(msnr_dev->pinctrl);
-		}
+	// msnr_dev->pinctrl = devm_pinctrl_get (dev);
+	msnr_dev->pinctrl = pinctrl_get_select (dev, "mclk_multi");
+	if (IS_ERR(msnr_dev->pinctrl)) {
+		cam_err("unable to get sensor%d mclk pinctrl\n", cell_id);
+		return PTR_ERR(msnr_dev->pinctrl);
+	}
 
-		msnr_dev->pinctrl_state = pinctrl_lookup_state(msnr_dev->pinctrl, "mclk_multi");
-		if (IS_ERR(msnr_dev->pinctrl_state)) {
-			cam_err("unable to lookup sensor%d mclk pinctrl state\n", cell_id);
-			pinctrl_put(msnr_dev->pinctrl);
-			return PTR_ERR(msnr_dev->pinctrl_state);
-		}
+	msnr_dev->pinctrl_state = pinctrl_lookup_state(msnr_dev->pinctrl, "mclk_multi");
+	if (IS_ERR(msnr_dev->pinctrl_state)) {
+		cam_err("unable to lookup sensor%d mclk pinctrl state\n", cell_id);
+		pinctrl_put(msnr_dev->pinctrl);
+		return PTR_ERR(msnr_dev->pinctrl_state);
+	}
 
-		pinctrl_select_state(msnr_dev->pinctrl, msnr_dev->pinctrl_state);
+	pinctrl_select_state(msnr_dev->pinctrl, msnr_dev->pinctrl_state);
 
-		/* mclks */
-		msnr_dev->mclk = clk_get(dev, msnr_dev->mclk_name);
-		if (IS_ERR(msnr_dev->mclk)) {
-			cam_err("unable to get cam_mclk%d\n", cell_id);
-			return PTR_ERR(msnr_dev->mclk);
-		}
+	/* mclks */
+	msnr_dev->mclk = clk_get(dev, msnr_dev->mclk_name);
+	if (IS_ERR(msnr_dev->mclk)) {
+		cam_err("unable to get cam_mclk%d\n", cell_id);
+		return PTR_ERR(msnr_dev->mclk);
+	}
 
-		/* pwdn-gpios */
-		msnr_dev->pwdn = gpiod_get(dev, "pwdn", GPIOD_OUT_HIGH);
-		if (IS_ERR(msnr_dev->pwdn)) {
-			cam_info("%s: unable to parse sensor%d pwdn gpio", __func__, cell_id);
-			return PTR_ERR(msnr_dev->pwdn);
-		} else {
-			ret = gpiod_direction_output(msnr_dev->pwdn, 0);
-			if (ret < 0) {
-				cam_err("%s: Failed to init sensor%d pwdn gpio", __func__, cell_id);
-				return ret;
-			}
+	/* pwdn-gpios */
+	msnr_dev->pwdn = gpiod_get(dev, "pwdn", GPIOD_OUT_HIGH);
+	if (IS_ERR(msnr_dev->pwdn)) {
+		cam_info("%s: unable to parse sensor%d pwdn gpio", __func__, cell_id);
+		return PTR_ERR(msnr_dev->pwdn);
+	} else {
+		ret = gpiod_direction_output(msnr_dev->pwdn, 0);
+		if (ret < 0) {
+			cam_err("%s: Failed to init sensor%d pwdn gpio", __func__, cell_id);
+			return ret;
 		}
+	}
 
-		/* rst-gpios */
-		msnr_dev->rst = gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-		if (IS_ERR(msnr_dev->rst)) {
-			cam_info("%s: unable to parse sensor%d reset gpio", __func__, cell_id);
-			return PTR_ERR(msnr_dev->rst);
-		} else {
-			ret = gpiod_direction_output(msnr_dev->rst, 0);
-			if (ret < 0) {
-				cam_err("%s: Failed to init sensor%d reset gpio", __func__, cell_id);
-				return ret;
-			}
+	/* rst-gpios */
+	msnr_dev->rst = gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(msnr_dev->rst)) {
+		cam_info("%s: unable to parse sensor%d reset gpio", __func__, cell_id);
+		return PTR_ERR(msnr_dev->rst);
+	} else {
+		ret = gpiod_direction_output(msnr_dev->rst, 0);
+		if (ret < 0) {
+			cam_err("%s: Failed to init sensor%d reset gpio", __func__, cell_id);
+			return ret;
 		}
 	}
-	cam_dbg("%s open %s%d, twsi_no %d, is_pinmulti %d\n", __func__, DRIVER_NAME, msnr_dev->id,
-		msnr_dev->twsi_no, msnr_dev->is_pinmulti);
+	msnr_dev->req_pinmulti = true;
+	use_pinmulti = true;
 
-	return 0;
+	return ret;
 }
+static int release_res_in_pinmulti_mode(struct cam_sensor_device *msnr_dev)
+{
+	if (msnr_dev->pinctrl)
+		pinctrl_put(msnr_dev->pinctrl);
+	msnr_dev->pinctrl = NULL;
 
-static int camsnr_release(struct inode *inode, struct file *file)
+	/* mclks */
+	if (msnr_dev->mclk)
+		clk_put(msnr_dev->mclk);
+	msnr_dev->mclk = NULL;
+
+	/* pwdn-gpios */
+	if (msnr_dev->pwdn)
+		gpiod_put(msnr_dev->pwdn);
+	msnr_dev->pwdn = NULL;
+
+	/* rst-gpios */
+	if (msnr_dev->rst)
+		gpiod_put(msnr_dev->rst);
+	msnr_dev->rst = NULL;
+	msnr_dev->req_pinmulti = false;
+	use_pinmulti = false;
+
+	return 0;
+}
+static int camsnr_open(struct inode *inode, struct file *file)
 {
 	struct cam_sensor_device *msnr_dev =
 	    container_of(inode->i_cdev, struct cam_sensor_device, cdev);
+	int ret = 0;
 
-	if (msnr_dev->is_pinmulti) {
-		pinctrl_put(msnr_dev->pinctrl);
+	file->private_data = msnr_dev;
 
-		/* mclks */
-		if (msnr_dev->mclk)
-			clk_put(msnr_dev->mclk);
-		msnr_dev->mclk = NULL;
+	//for muse pi
+	if (msnr_dev->is_pinmulti && msnr_dev->req_pinmulti == false && use_pinmulti == false)
+		ret = request_res_in_pinmulti_mode(msnr_dev);
+	else if (msnr_dev->is_pinmulti && msnr_dev->req_pinmulti == false && use_pinmulti == true)
+		cam_warn("previous cam_sensor must be closed before open %s%d in pinmulti mode!", DRIVER_NAME, msnr_dev->id);
 
-		/* pwdn-gpios */
-		if (msnr_dev->pwdn)
-			gpiod_put(msnr_dev->pwdn);
-		msnr_dev->pwdn = NULL;
+	cam_dbg("%s open %s%d, twsi_no %d, is_pinmulti %d, req_pinmulti %d, use_pinmulti %d\n", __func__, DRIVER_NAME, msnr_dev->id,
+		msnr_dev->twsi_no, msnr_dev->is_pinmulti, msnr_dev->req_pinmulti, use_pinmulti);
 
-		/* rst-gpios */
-		if (msnr_dev->rst)
-			gpiod_put(msnr_dev->rst);
-		msnr_dev->rst = NULL;
-	}
+	return ret;
+}
+
+static int camsnr_release(struct inode *inode, struct file *file)
+{
+	struct cam_sensor_device *msnr_dev =
+	    container_of(inode->i_cdev, struct cam_sensor_device, cdev);
 
-	cam_dbg("%s close %s%d, twsi_no %d, is_pinmulti %d\n", __func__, DRIVER_NAME, msnr_dev->id,
-		msnr_dev->twsi_no, msnr_dev->is_pinmulti);
+	if (msnr_dev->is_pinmulti && msnr_dev->req_pinmulti == true && use_pinmulti == true)
+		release_res_in_pinmulti_mode(msnr_dev);
+
+	cam_dbg("%s close %s%d, twsi_no %d, is_pinmulti %d, req_pinmulti %d, use_pinmulti %d\n", __func__, DRIVER_NAME, msnr_dev->id,
+		msnr_dev->twsi_no, msnr_dev->is_pinmulti, msnr_dev->req_pinmulti, use_pinmulti);
 
 	return 0;
 }
@@ -1355,7 +1377,6 @@ static int camsnr_of_parse(struct cam_sensor_device *sensor)
 
 	// mclk/pwdn/rst multiplex
 	sensor->is_pinmulti = of_property_read_bool(of_node, "pinmulti-enable");
-	cam_info("cam_sensor%d is_pinmulti: %d\n", sensor->id, sensor->is_pinmulti);
 	if (!sensor->is_pinmulti) {
 		/* mclks */
 		sensor->mclk = devm_clk_get(dev, sensor->mclk_name);
@@ -1390,6 +1411,9 @@ static int camsnr_of_parse(struct cam_sensor_device *sensor)
 				goto st_err;
 			}
 		}
+	} else {
+		cam_info("cam_sensor%d is_pinmulti: %d\n", sensor->id, sensor->is_pinmulti);
+		sensor->req_pinmulti = false;
 	}
 
 #ifdef CONFIG_ARCH_ZYNQMP
diff --git a/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.h b/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.h
index d70ed1bba223..b75a2ce8d78f 100644
--- a/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.h
+++ b/drivers/media/platform/spacemit/camera/cam_sensor/cam_sensor.h
@@ -36,6 +36,7 @@ struct cam_sensor_device {
 	struct clk *mclk;
 	const char *mclk_name;
 	bool is_pinmulti;
+	bool req_pinmulti;
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pinctrl_state;
 
diff --git a/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c b/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
index 5999097bc2ff..fadc0631de13 100644
--- a/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
+++ b/drivers/media/platform/spacemit/camera/vi/k1xvi/fe_isp.c
@@ -2440,7 +2440,7 @@ static int fe_isp_pipeline_notifier_handler(struct notifier_block *nb,
 							     pipe_ctx->cc_slice_info.slice_width,
 							     format.format.height,
 							     0, bit_depth);
-			cam_not("slice width=%d idi_fifo_depth=%u", pipe_ctx->cc_slice_info.slice_width, idi_fifo_depth);
+			//cam_not("slice width=%d idi_fifo_depth=%u", pipe_ctx->cc_slice_info.slice_width, idi_fifo_depth);
 		}
 		break;
 	default:
@@ -5348,12 +5348,14 @@ static int notify_caputre_until_done(int slice_index,
 	struct isp_pipeline_context *pipe_ctx = NULL;
 	long l_ret = 0;
 
+	/*
 	cam_not("slice(%d/%d) slice_width:%d raw_read_offset:%d yuv_out_offset:%d dwt[1]_offset:%d dwt[2]_offset:%d dwt[3]_offset:%d dwt[4]_offset:%d notify",
 		slice_index, slice_info->total_slice_cnt,
 		slice_info->slice_width, slice_info->raw_read_offset,
 		slice_info->yuv_out_offset,
 		slice_info->dwt_offset[0], slice_info->dwt_offset[1],
 		slice_info->dwt_offset[2], slice_info->dwt_offset[3]);
+	*/
 	if (!pdev) {
 		cam_err("%s pdev is null", __func__);
 		return -1;
@@ -5406,7 +5408,7 @@ static int notify_caputre_until_done(int slice_index,
 		hw_dma_dump_regs(isp_ctx->dma_block);
 		return -1;
 	} else if (l_ret < 0) {
-		cam_err("%s wait for slice doen interrupted by user app", __func__);
+		cam_err("%s wait for slice doen interrupted by user app(%lu)", __func__, l_ret);
 		return -1;
 	}
 	return sc_pipeline->slice_result;
diff --git a/drivers/mfd/spacemit-mfd.c b/drivers/mfd/spacemit-mfd.c
index 6db7ea67068e..1d009248fd2e 100644
--- a/drivers/mfd/spacemit-mfd.c
+++ b/drivers/mfd/spacemit-mfd.c
@@ -16,6 +16,7 @@ SPM8821_IRQS_DESC;
 SPM8821_IRQ_CHIP_DESC;
 SPM8821_POWER_KEY_RESOURCES_DESC;
 SPM8821_RTC_RESOURCES_DESC;
+SPM8821_ADC_RESOURCES_DESC;
 SPM8821_MFD_CELL;
 SPM8821_MFD_MATCH_DATA;
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index 8a0058878b4e..c733ef729332 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -670,9 +670,9 @@ void rwnx_plat_userconfig_parsing(struct rwnx_hw *rwnx_hw, char *buffer, int siz
 	vfree(data);
 }
 
-#define FW_USERCONFIG_NAME_8800D    "aic_userconfig.txt"
-#define FW_USERCONFIG_NAME_8800DC   "aic8800dc/aic_userconfig_8800dc.txt"
-#define FW_USERCONFIG_NAME_8800D80  "aic8800d80/aic_userconfig_8800d80.txt"
+#define FW_USERCONFIG_NAME_8800D    "aic/aic_userconfig.txt"
+#define FW_USERCONFIG_NAME_8800DC   "aic/aic8800dc/aic_userconfig_8800dc.txt"
+#define FW_USERCONFIG_NAME_8800D80  "aic/aic8800d80/aic_userconfig_8800d80.txt"
 
 int rwnx_plat_userconfig_upload_android(struct rwnx_hw *rwnx_hw, char *filename)
 {
diff --git a/drivers/net/wireless/realtek/rtl8852bs/core/rtw_sec_cam.c b/drivers/net/wireless/realtek/rtl8852bs/core/rtw_sec_cam.c
index aac77a4b2f3e..9f9d1162cf83 100644
--- a/drivers/net/wireless/realtek/rtl8852bs/core/rtw_sec_cam.c
+++ b/drivers/net/wireless/realtek/rtl8852bs/core/rtw_sec_cam.c
@@ -991,6 +991,15 @@ static void dump_valid_key(void* sel, u8* addr_map, u8* sec_map, u8* bssid_map\
 
 	_rtw_memcpy(SMA, &addr_map[8], ETH_ALEN);
 	_rtw_memcpy(TMA,&addr_map[14], ETH_ALEN);
+
+	if (nettype >= ARRAY_SIZE(nettype_to_string) ||
+		GET_AX_SEC_CAM_TYPE(sec_map) >= ARRAY_SIZE(enc_algo_to_string) ||
+		key_type >= ARRAY_SIZE(type_to_string)) {
+		RTW_WARN("out of range, nettype: %d enc_algor: %d key_type: %d\n",
+			nettype, GET_AX_SEC_CAM_TYPE(sec_map), key_type);
+		return;
+	}
+
 	RTW_PRINT_SEL(sel, "%-5u %s "MAC_FMT"  " MAC_FMT" " MAC_FMT\
 		" %-5u %-5u %s %-7u %-3u %s "KEY_FMT"\n", macid\
 		, nettype_to_string[nettype], MAC_ARG(SMA), MAC_ARG(TMA)\
diff --git a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/ioctl_cfg80211.c
index 73ff464f20c9..707cd12a97f0 100644
--- a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/ioctl_cfg80211.c
@@ -5115,7 +5115,7 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	mon_wdev->iftype = NL80211_IFTYPE_MONITOR;
 	mon_ndev->ieee80211_ptr = mon_wdev;
 
-	ret = register_netdevice(mon_ndev);
+	ret = cfg80211_register_netdevice(mon_ndev);
 	if (ret)
 		goto out;
 
@@ -5269,7 +5269,7 @@ static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
 		pwdev_priv = adapter_wdev_data(adapter);
 
 		if (ndev == pwdev_priv->pmon_ndev) {
-			unregister_netdevice(ndev);
+			cfg80211_unregister_netdevice(ndev);
 			pwdev_priv->pmon_ndev = NULL;
 			pwdev_priv->ifname_mon[0] = '\0';
 			RTW_INFO(FUNC_NDEV_FMT" remove monitor ndev\n", FUNC_NDEV_ARG(ndev));
diff --git a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/os_intfs.c b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/os_intfs.c
index 7a12c9420c9e..90ef4ad8e1e5 100644
--- a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/os_intfs.c
@@ -647,7 +647,7 @@ int rtw_os_ndev_register(_adapter *adapter, const char *name)
 	if (rtnl_lock_needed)
 		ret = (register_netdev(ndev) == 0) ? _SUCCESS : _FAIL;
 	else
-		ret = (register_netdevice(ndev) == 0) ? _SUCCESS : _FAIL;
+		ret = (cfg80211_register_netdevice(ndev) == 0) ? _SUCCESS : _FAIL;
 
 	if (ret == _SUCCESS)
 		adapter->registered = 1;
@@ -689,7 +689,7 @@ void rtw_os_ndev_unregister(_adapter *adapter)
 		if (rtnl_lock_needed)
 			unregister_netdev(netdev);
 		else
-			unregister_netdevice(netdev);
+			cfg80211_unregister_netdevice(netdev);
 	}
 
 	adapter->registered = 0;
diff --git a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/wifi_regd.c b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/wifi_regd.c
index c39421a0abb8..95eeca0f1cf8 100644
--- a/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/realtek/rtl8852bs/os_dep/linux/wifi_regd.c
@@ -98,7 +98,7 @@ static struct wireless_dev *rtw_regd_alloc_du_wdev(struct wiphy *wiphy)
 	wdev->iftype = NL80211_IFTYPE_AP;
 	ndev->ieee80211_ptr = wdev;
 
-	ret = register_netdevice(ndev);
+	ret = cfg80211_register_netdevice(ndev);
 
 out:
 	if (ret && wdev) {
@@ -125,7 +125,7 @@ void rtw_regd_free_du_wdev(struct wiphy *wiphy)
 	if (rtnl_lock_needed)
 		rtnl_lock();
 
-	unregister_netdevice(wiphy_data->du_wdev->netdev);
+	cfg80211_unregister_netdevice(wiphy_data->du_wdev->netdev);
 
 	if (rtnl_lock_needed)
 		rtnl_unlock();
diff --git a/drivers/soc/spacemit/pm_domain/k1x-pm_domain.c b/drivers/soc/spacemit/pm_domain/k1x-pm_domain.c
index 49f4f6dd8345..3bb94f430bc6 100644
--- a/drivers/soc/spacemit/pm_domain/k1x-pm_domain.c
+++ b/drivers/soc/spacemit/pm_domain/k1x-pm_domain.c
@@ -262,6 +262,9 @@ static int spacemit_pd_power_on(struct generic_pm_domain *domain)
 
 	regmap_read(gpmu->regmap[APMU_REGMAP_INDEX], APMU_POWER_STATUS_REG, &val);
 	if (val & (1 << spd->param.bit_pwr_stat)) {
+		if (spd->pm_index == K1X_PMU_LCD_PWR_DOMAIN)
+			return 0;
+
 		if (!spd->param.use_hw) {
 			/* this is the sw type */
 			regmap_read(gpmu->regmap[APMU_REGMAP_INDEX], spd->param.reg_pwr_ctrl, &val);
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c b/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
index 48677d23778d..ab164855b536 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
@@ -44,11 +44,11 @@ static int spacemit_bt_on(struct bt_pwrseq *pwrseq, bool on_off)
 	if (on_off){
 		if(pwrseq->parent)
 			spacemit_power_on(pwrseq->parent, 1);
-		gpiod_set_value(pwrseq->reset_n, 1);
+		gpiod_set_value_cansleep(pwrseq->reset_n, 1);
 		if (pwrseq->power_on_delay_ms)
 			msleep(pwrseq->power_on_delay_ms);
 	}else{
-		gpiod_set_value(pwrseq->reset_n, 0);
+		gpiod_set_value_cansleep(pwrseq->reset_n, 0);
 		if(pwrseq->parent)
 			spacemit_power_on(pwrseq->parent, 0);
 	}
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c b/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c
index 59e9fa277f3e..e08da8d256ed 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c
@@ -54,12 +54,12 @@ static void spacemit_rfkill_set_pin(struct gpio_desc *gpio, int value,
 		return;
 	if (use_pulse) {
 		value = 1;
-		gpiod_set_value(gpio, value);
+		gpiod_set_value_cansleep(gpio, value);
 		msleep(pulse_delay);
 		/* Pulse power key should restore to original level after pulse */
 		value = !value;
 	}
-	gpiod_set_value(gpio, value);
+	gpiod_set_value_cansleep(gpio, value);
 }
 
 static int spacemit_rfkill_on(struct rfkill_pwrseq *pwrseq, bool on_off)
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
index c7a553ba5f76..f9bb8130088c 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
@@ -94,11 +94,11 @@ static int spacemit_wlan_on(struct wlan_pwrseq *pwrseq, bool on_off)
 	if (on_off){
 		if(pwrseq->parent)
 			spacemit_power_on(pwrseq->parent, 1);
-		gpiod_set_value(pwrseq->regon, 1);
+		gpiod_set_value_cansleep(pwrseq->regon, 1);
 		if (pwrseq->power_on_delay_ms)
 			msleep(pwrseq->power_on_delay_ms);
 	}else{
-		gpiod_set_value(pwrseq->regon, 0);
+		gpiod_set_value_cansleep(pwrseq->regon, 0);
 		if(pwrseq->parent)
 			spacemit_power_on(pwrseq->parent, 0);
 	}
diff --git a/drivers/usb/gadget/function/uvc_queue.c b/drivers/usb/gadget/function/uvc_queue.c
index 0aa3d7e1f3cc..963a5ab35290 100644
--- a/drivers/usb/gadget/function/uvc_queue.c
+++ b/drivers/usb/gadget/function/uvc_queue.c
@@ -153,6 +153,9 @@ int uvcg_queue_init(struct uvc_video_queue *queue, struct device *dev, enum v4l2
 	queue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY
 				     | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
 	queue->queue.dev = dev;
+#if defined(CONFIG_SOC_SPACEMIT_K1X)
+	queue->queue.gfp_flags |= GFP_DMA32;
+#endif
 
 	ret = vb2_queue_init(&queue->queue);
 	if (ret)
diff --git a/include/linux/mfd/spacemit/spacemit_pmic.h b/include/linux/mfd/spacemit/spacemit_pmic.h
index e519487be838..682060d4dadc 100644
--- a/include/linux/mfd/spacemit/spacemit_pmic.h
+++ b/include/linux/mfd/spacemit/spacemit_pmic.h
@@ -213,6 +213,12 @@ struct pinctrl_match_data {
 	const char *name;
 };
 
+struct adc_match_data {
+	int nr_desc;
+	const char *name;
+	struct iio_chan_spec *iio_desc;
+};
+
 /* common regulator defination */
 #define SPM8XX_DESC_COMMON(_id, _match, _supply, _nv, _vr, _vm, _er, _em, _lr, _ops)       \
 	{								\
diff --git a/include/linux/mfd/spacemit/spm8821.h b/include/linux/mfd/spacemit/spm8821.h
index 857963217853..ec7de4509768 100644
--- a/include/linux/mfd/spacemit/spm8821.h
+++ b/include/linux/mfd/spacemit/spm8821.h
@@ -24,6 +24,8 @@ enum SPM8821_reg {
 
 #define SPACEMIT_SPM8821_MAX_REG	0xB0
 
+#define SPM8821_VERSION_ID_REG		0xa1
+
 #define SPM8821_BUCK_VSEL_MASK		0xff
 #define SMP8821_BUCK_EN_MASK		0x1
 
@@ -85,6 +87,37 @@ enum SPM8821_reg {
 
 #define SPM8821_SLEEP_REG_OFFSET	0x1
 
+#define SPM8821_ADC_AUTO_REG		0x22
+#define SPM8821_ADC_AUTO_BIT_MSK	0x7f
+
+#define SPM8821_ADC_CTRL_REG		0x1e
+#define SPM8821_ADC_CTRL_BIT_MSK	0x3
+#define SPM8821_ADC_CTRL_EN_BIT_OFFSET	0x0
+#define SPM8821_ADC_CTRL_GO_BIT_OFFSET	0x1
+
+#define SPM8821_ADC_CFG1_REG		0x20
+
+#define SPM8821_ADC_CFG1_ADC_CHOP_EN_BIT_OFFSET		0x6
+#define SPM8821_ADC_CFG1_ADC_CHOP_EN_BIT_MSK		0x40
+
+#define SPM8821_ADC_CFG1_ADC_CHNNL_SEL_BIT_OFFSET	0x3
+#define SPM8821_ADC_CFG1_ADC_CHNNL_SEL_BIT_MSK		0x38
+
+#define SPM8821_ADC_CFG2_REG				0x21
+#define SPM8821_ADC_CFG2_REF_SEL_BIT_OFFSET		0x0
+#define SPM8821_ADC_CFG2_REF_SEL_BIT_MSK		0x3
+#define SPM8821_ADC_CFG2_3V3_REF			0x2
+
+#define SPM8821_ADC_CFG2_7_DEB_NUM			0x7
+#define SPM8821_ADC_CFG2_DEB_NUM_BIT_MSK		0x70
+#define SPM8821_ADC_CFG2_DEB_NUM_BIT_OFFSET		0x4
+
+#define SPM8821_ADC_EXTERNAL_CHANNEL_OFFSET		2
+
+#define SPM8821_ADCIN0_RES_H_REG			0x2a
+#define SPM8821_ADCIN0_RES_L_REG			0x2b
+#define SPM8821_ADCIN0_REG_L_BIT_MSK			0xf0
+
 #define SPM8821_REGMAP_CONFIG	\
 	static const struct regmap_config spm8821_regmap_config = {	\
 		.reg_bits = 8,	\
@@ -197,6 +230,46 @@ static const struct regulator_desc spm8821_reg[] = {	\
 	SPM8821_DESC_SWITCH(SPM8821_ID_SWITCH1, "SWITCH_REG1", "vcc_sys", SPM8821_SWITCH_CTRL_REG, SPM8821_SWTICH_EN_MASK),		\
 };
 
+#define SPM8821_ADC_IIO_DESC						\
+static struct iio_chan_spec spm8821_iio_desc[] = {		\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 0,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 1,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 2,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 3,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 4,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+	{								\
+		.indexed = 1,						\
+		.type = IIO_VOLTAGE,					\
+		.channel = 5,						\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),		\
+	},								\
+};
+
 /* gpio set */
 #define SPM8821_PINMUX_DESC		\
 const char* spm8821_pinmux_functions[] = {	\
@@ -664,6 +737,12 @@ static const struct resource spm8821_rtc_resources[] = {	\
 	DEFINE_RES_IRQ(SPM8821_E_ALARM),			\
 };
 
+/* adc desc */
+#define SPM8821_ADC_RESOURCES_DESC				\
+static const struct resource spm8821_adc_resources[] = {	\
+	DEFINE_RES_IRQ(SPM8821_E_ADC_EOC),			\
+};
+
 #define SPM8821_RTC_REG_DESC					\
 static const struct rtc_regdesc spm8821_regdesc = {		\
 	.cnt_s = {						\
@@ -754,6 +833,12 @@ static const struct rtc_regdesc spm8821_regdesc = {		\
 			.num_resources = ARRAY_SIZE(spm8821_rtc_resources),	\
 			.resources = &spm8821_rtc_resources[0],			\
 		},								\
+		{								\
+			.name = "spacemit-adc@spm8821",				\
+			.of_compatible = "pmic,adc,spm8821",			\
+			.num_resources = ARRAY_SIZE(spm8821_adc_resources),	\
+			.resources = &spm8821_adc_resources[0],			\
+		},								\
 	};
 
 #define SPM8821_MFD_MATCH_DATA					\
@@ -778,7 +863,7 @@ static struct mfd_match_data spm8821_mfd_match_data = {		\
 };
 
 #define SPM8821_PINCTRL_MATCH_DATA				\
-static struct pinctrl_match_data spm8821_pinctrl_match_data = {				\
+static struct pinctrl_match_data spm8821_pinctrl_match_data = {	\
 	.nr_pin_mux = ARRAY_SIZE(spm8821_pinmux_functions),	\
 	.pinmux_funcs = spm8821_pinmux_functions,		\
 	.nr_pin_fuc_desc = ARRAY_SIZE(spm8821_pinfunc_desc),	\
@@ -796,4 +881,11 @@ static struct regulator_match_data spm8821_regulator_match_data = {	\
 	.sleep_reg_offset = SPM8821_SLEEP_REG_OFFSET,			\
 };
 
+#define SPM8821_ADC_MATCH_DATA						\
+static struct adc_match_data spm8821_adc_match_data = {			\
+	.iio_desc = spm8821_iio_desc,					\
+	.nr_desc = ARRAY_SIZE(spm8821_iio_desc),			\
+	.name = "spm8821",						\
+};
+
 #endif /* __SPM8821_H__ */
diff --git a/include/uapi/media/k1x/cam_sensor_uapi.h b/include/uapi/media/k1x/cam_sensor_uapi.h
index d5ce50aa9f3d..fd9a222ed1ef 100644
--- a/include/uapi/media/k1x/cam_sensor_uapi.h
+++ b/include/uapi/media/k1x/cam_sensor_uapi.h
@@ -12,6 +12,12 @@
 extern "C" {
 #endif
 
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
 #define CAM_SNS_MAX_DEV_NUM    3
 
 #define CAM_SENSOR_DEV_NAME "/dev/cam_sensor"
diff --git a/include/uapi/media/k1x/k1x_cpp_uapi.h b/include/uapi/media/k1x/k1x_cpp_uapi.h
index 3ee11b6ee96d..df88755fd4de 100644
--- a/include/uapi/media/k1x/k1x_cpp_uapi.h
+++ b/include/uapi/media/k1x/k1x_cpp_uapi.h
@@ -10,6 +10,12 @@
 
 #include <linux/videodev2.h>
 
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+
 /*
  * hw version info:
  * 31:16  Version bits
-- 
2.47.0

