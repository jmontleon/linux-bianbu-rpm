From fbdbe1afb19941a3c0bb0e3c4b438d7e4e7f1054 Mon Sep 17 00:00:00 2001
From: weijinmei <jinmei.wei@space-t.cn>
Date: Thu, 27 Jun 2024 19:18:21 +0800
Subject: [PATCH 0879/1448] es8326: fix codec not work after suspend/resume

Change-Id: I5e781eeffe63a9f09c63d1fb57835c91960dd562
---
 sound/soc/codecs/es8326.c | 68 +++++++++++++++++++++++++++++++++++++--
 1 file changed, 65 insertions(+), 3 deletions(-)

diff --git a/sound/soc/codecs/es8326.c b/sound/soc/codecs/es8326.c
index a29939c46355..41e1e2bcd554 100644
--- a/sound/soc/codecs/es8326.c
+++ b/sound/soc/codecs/es8326.c
@@ -52,6 +52,7 @@ struct es8326_priv {
 	int mic_gpio;
 	int mic_irq;
 	struct delayed_work hpmic_detect_work;
+	unsigned int coeff;
 #endif
 };
 
@@ -476,6 +477,9 @@ static int es8326_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	coeff = get_coeff(es8326->sysclk, params_rate(params), array, coeff_div);
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	es8326->coeff = coeff;
+#endif
 	/* bit size */
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -524,6 +528,44 @@ static int es8326_pcm_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static int es8326_reset_clk(struct snd_soc_component *component)
+{
+	const struct _coeff_div *coeff_div;
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	int coeff;
+
+	if (es8326->version == 0) {
+		coeff_div =  coeff_div_v0;
+	} else {
+		coeff_div =  coeff_div_v3;
+	}
+	coeff = es8326->coeff;
+	if (coeff >= 0) {
+		regmap_write(es8326->regmap,  ES8326_CLK_DIV1,
+			     coeff_div[coeff].reg4);
+		regmap_write(es8326->regmap,  ES8326_CLK_DIV2,
+			     coeff_div[coeff].reg5);
+		regmap_write(es8326->regmap,  ES8326_CLK_DLL,
+			     coeff_div[coeff].reg6);
+		regmap_write(es8326->regmap,  ES8326_CLK_MUX,
+			     coeff_div[coeff].reg7);
+		regmap_write(es8326->regmap,  ES8326_CLK_ADC_SEL,
+			     coeff_div[coeff].reg8);
+		regmap_write(es8326->regmap,  ES8326_CLK_DAC_SEL,
+			     coeff_div[coeff].reg9);
+		regmap_write(es8326->regmap,  ES8326_CLK_ADC_OSR,
+			     coeff_div[coeff].rega);
+		regmap_write(es8326->regmap,  ES8326_CLK_DAC_OSR,
+			     coeff_div[coeff].regb);
+	} else {
+		dev_warn(component->dev, "Clock coefficients do not match");
+	}
+
+	return 0;
+}
+#endif
+
 static int es8326_mute(struct snd_soc_dai *dai, int mute, int direction)
 {
 	struct snd_soc_component *component = dai->component;
@@ -825,7 +867,9 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 			 * Don't report jack status.
 			 */
 			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+			#ifndef SPACEMIT_CONFIG_CODEC_ES8326
 			es8326_enable_micbias(es8326->component);
+			#endif
 			usleep_range(50000, 70000);
 			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
 			regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x1f);
@@ -915,7 +959,6 @@ static void es8326_hpmic_detect_handler(struct work_struct *work)
 	} else {
 		if (es8326->hp == 0) {
 			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
-			es8326_enable_micbias(es8326->component);
 			usleep_range(50000, 70000);
 			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
 			regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x1f);
@@ -1096,18 +1139,37 @@ static int es8326_resume(struct snd_soc_component *component)
 
 	regcache_cache_only(es8326->regmap, false);
 	regcache_sync(es8326->regmap);
-	if (es8326->jack)
-		es8326_irq(es8326->irq, es8326);
+	es8326_init(component);
+	es8326_reset_clk(component);
+	if (es8326->jack) {
+		snd_soc_jack_report(es8326->jack, 0, SND_JACK_HEADSET);
+		if (es8326->jd_inverted) {
+			snd_soc_component_update_bits(component, ES8326_HPDET_TYPE,
+					      ES8326_HP_DET_JACK_POL, ~es8326->jack_pol);
+		}
+		es8326_disable_micbias(component);
+		if (es8326->irq > 0)
+			es8326_irq(es8326->irq, es8326);
+		else
+			es8326_irq_hpmic(es8326->irq, es8326);
+	}
 	return 0;
 }
+
 static int es8326_suspend(struct snd_soc_component *component)
 {
 	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
 
 	cancel_delayed_work_sync(&es8326->jack_detect_work);
+	es8326->calibrated = false;
+	regmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_OFF);
 	regcache_cache_only(es8326->regmap, true);
 	regcache_mark_dirty(es8326->regmap);
 
+	/* reset register value to default */
+	regmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x01);
+	usleep_range(1000, 3000);
+	regmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x00);
 	return 0;
 }
 #else
-- 
2.47.0

