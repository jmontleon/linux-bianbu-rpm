From ae0f910b56fcc6a8a5837645f6f9e82daf09c42f Mon Sep 17 00:00:00 2001
From: lilijun <lijun.li@spacemit.com>
Date: Fri, 10 Nov 2023 15:30:28 +0800
Subject: [PATCH 0148/1204] v2d: Add v2d driver

Change-Id: I6e0cf63ac59b78cd5603d10c00a8ac7ed7177297
---
 arch/riscv/boot/dts/spacemit/k1-x.dtsi        |  12 +
 arch/riscv/configs/k1-x_fpga_defconfig        |   1 +
 drivers/media/platform/spacemit/Kconfig       |   1 +
 drivers/media/platform/spacemit/Makefile      |   1 +
 drivers/media/platform/spacemit/v2d/Kconfig   |   7 +
 drivers/media/platform/spacemit/v2d/Makefile  |   5 +
 .../media/platform/spacemit/v2d/csc_matrix.h  | 116 +++
 drivers/media/platform/spacemit/v2d/v2d_drv.c | 946 ++++++++++++++++++
 drivers/media/platform/spacemit/v2d/v2d_drv.h | 327 ++++++
 drivers/media/platform/spacemit/v2d/v2d_hw.c  | 911 +++++++++++++++++
 .../media/platform/spacemit/v2d/v2d_iommu.c   | 277 +++++
 .../media/platform/spacemit/v2d/v2d_priv.h    | 147 +++
 drivers/media/platform/spacemit/v2d/v2d_reg.h | 824 +++++++++++++++
 13 files changed, 3575 insertions(+)
 create mode 100644 drivers/media/platform/spacemit/v2d/Kconfig
 create mode 100644 drivers/media/platform/spacemit/v2d/Makefile
 create mode 100644 drivers/media/platform/spacemit/v2d/csc_matrix.h
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_drv.c
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_drv.h
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_hw.c
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_iommu.c
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_priv.h
 create mode 100644 drivers/media/platform/spacemit/v2d/v2d_reg.h

diff --git a/arch/riscv/boot/dts/spacemit/k1-x.dtsi b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
index 8cab14353721..ade29c08d18e 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
@@ -972,6 +972,18 @@ linlon-v5@c0500000 {
 			interrupts = <74>;
 			status = "disabled";
 		};
+
+		v2d@c0100000 {
+			compatible = "spacemit,v2d";
+			reg =  <0x0 0xc0100000 0x0 0x1000>;
+			reg-names = "v2dreg";
+			clocks = <&ccu CLK_DPU_MCLK>,
+				 <&ccu CLK_V2D>;
+			clock-names = "v2d-io", "v2d-core";
+			interrupt-parent = <&intc>;
+			interrupts = <86>;
+			status = "ok";
+		};
 	};
 
 	pmu {
diff --git a/arch/riscv/configs/k1-x_fpga_defconfig b/arch/riscv/configs/k1-x_fpga_defconfig
index 5c4be03ae3df..39aca611c0b5 100644
--- a/arch/riscv/configs/k1-x_fpga_defconfig
+++ b/arch/riscv/configs/k1-x_fpga_defconfig
@@ -142,6 +142,7 @@ CONFIG_MEDIA_SUPPORT=y
 # CONFIG_DVB_DYNAMIC_MINORS is not set
 # CONFIG_RADIO_ADAPTERS is not set
 CONFIG_VIDEO_LINLON_K1X=y
+CONFIG_SPACEMIT_V2D=y
 # CONFIG_MEDIA_TUNER_E4000 is not set
 # CONFIG_MEDIA_TUNER_FC0011 is not set
 # CONFIG_MEDIA_TUNER_FC0012 is not set
diff --git a/drivers/media/platform/spacemit/Kconfig b/drivers/media/platform/spacemit/Kconfig
index c1e77d454d37..4cc04c56cab0 100644
--- a/drivers/media/platform/spacemit/Kconfig
+++ b/drivers/media/platform/spacemit/Kconfig
@@ -3,3 +3,4 @@
 comment "Spacemit media platform drivers"
 
 source "drivers/media/platform/spacemit/vpu_k1x/Kconfig"
+source "drivers/media/platform/spacemit/v2d/Kconfig"
diff --git a/drivers/media/platform/spacemit/Makefile b/drivers/media/platform/spacemit/Makefile
index be25ea319a80..e2f0c3052a64 100644
--- a/drivers/media/platform/spacemit/Makefile
+++ b/drivers/media/platform/spacemit/Makefile
@@ -1,2 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-y += vpu_k1x/
+obj-y += v2d/
diff --git a/drivers/media/platform/spacemit/v2d/Kconfig b/drivers/media/platform/spacemit/v2d/Kconfig
new file mode 100644
index 000000000000..97de4edb288d
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/Kconfig
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+config SPACEMIT_V2D
+        tristate "Spacemit V2D Engine Driver"
+        depends on SYNC_FILE
+        default m
+        help
+          This enables Spacemit V2D Engine driver
diff --git a/drivers/media/platform/spacemit/v2d/Makefile b/drivers/media/platform/spacemit/v2d/Makefile
new file mode 100644
index 000000000000..d99658dfa818
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_SPACEMIT_V2D) += v2d.o
+v2d-y := v2d_drv.o v2d_hw.o v2d_iommu.o
+
+
diff --git a/drivers/media/platform/spacemit/v2d/csc_matrix.h b/drivers/media/platform/spacemit/v2d/csc_matrix.h
new file mode 100644
index 000000000000..8bbcab6cecc2
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/csc_matrix.h
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef __CSC_MATRIX_h__
+#define __CSC_MATRIX_h__
+#include "v2d_drv.h"
+int cscmatrix[V2D_CSC_MODE_BUTT][3][4] = {
+//RGB2BT601Wide
+    {{  306,  601, 117,   0 },
+     { -173, -339, 512, 128 },
+     {  512, -429, -83, 128 }},
+
+//BT601Wide2RGB
+    {{ 1024,    0, 1436, -179 },
+     { 1024, -352, -731,  135 },
+     { 1024, 1815,    0, -227 }},
+
+//RGB2BT601Narrow
+    {{  263,  516, 100,  16 },
+     { -152, -298, 450, 128 },
+     {  450, -377, -73, 128 }},
+
+//BT601Narrow2RGB
+    {{ 1192,    0, 1634, -223 },
+     { 1192, -401, -832,  136 },
+     { 1192, 2066,    0, -277 }},
+
+//RGB2BT709Wide
+    {{  218,  732,   74,   0 },
+     { -117, -395,  512, 128 },
+     {  512, -465,  -47, 128 }},
+
+//BT709Wide2RGB
+    {{ 1024,    0, 1613, -202 },
+     { 1024, -192, -479,   84 },
+     { 1024, 1900,    0, -238 }},
+
+//RGB2BT709Narrow
+    {{  187,  629,  63, 16 },
+     { -103, -347, 450, 128},
+     {  450, -409, -41, 128}},
+
+//BT709Narrow2RGB
+    {{ 1192,    0, 1836, -248 },
+     { 1192, -218, -546,   77 },
+     { 1192, 2163,    0, -289 }},
+
+//BT601Wide2BT709Wide
+    {{ 1024, -121, -218,  42 },
+     {    0, 1043,  117, -17 },
+     {    0,   77, 1050, -13 }},
+
+//BT601Wide2BT709Narrow
+    {{ 879, -104, -187, 52 },
+     {   0,  916,  103,  1 },
+     {   0,   68,  922,  4 }},
+
+//BT601Wide2BT601Narrow
+    {{ 879,   0,   0,  16 },
+     {   0, 900,   0,  16 },
+     {   0,   0, 900,  16 }},
+
+//BT601Narrow2BT709Wide
+    {{ 1192, -138, -248,   30 },
+     {   0,  1187,  134,  -37 },
+     {   0,    88, 1195,  -32 }},
+
+//BT601Narrow2BT709Narrow
+    {{ 1024, -118, -213,  41 },
+     {    0, 1043,  117, -17 },
+     {    0,   77, 1050, -13 }},
+
+//BT601Narrow2BT601Wide
+    {{ 1192,    0,    0, -19 },
+     {    0, 1166,    0, -18 },
+     {    0,    0, 1166, -18 }},
+
+//BT709Wide2BT601Wide
+    { { 1024,  104,  201,  -38 },
+        {   0, 1014, -113,   15 },
+        {   0,  -74, 1007,   11 } },
+
+//BT709Wide2BT601Narrow
+    {{ 879,  89,  172, -17 },
+     {   0, 890, -100,  29 },
+     {   0, -65,  885,  26 }},
+
+//BT709Wide2BT709Narrow
+    {{ 879,   0,   0,  16 },
+     {   0, 900,   0,  16 },
+     {   0,   0, 900,  16 }},
+
+//BT709Narrow2BT601Wide
+    {{ 1192,  118,  229,  -62 },
+     {    0, 1154, -129,    0 },
+     {    0,  -85, 1146,   -5 }},
+
+//BT709Narrow2BT601Narrow
+    {{ 1024,  102,  196,  -37 },
+     {    0, 1014, -113,   15 },
+     {    0,  -74, 1007,   11 }},
+
+//BT709Narrow2BT709Wide
+    {{ 1192,    0,    0, -19 },
+     {    0, 1166,    0, -18 },
+     {    0,    0, 1166, -18 }},
+
+    //RGB2Grey
+    {{  218,  732,  74,   0  },
+     { -117, -395, 512,  128 },
+     {  512, -465, -47,  128 }},
+
+    //RGB2RGB
+    {{ 1024,    0,    0, 0 },
+     {    0, 1024,    0, 0 },
+     {    0,    0, 1024, 0 }}
+};
+#endif
diff --git a/drivers/media/platform/spacemit/v2d/v2d_drv.c b/drivers/media/platform/spacemit/v2d/v2d_drv.c
new file mode 100644
index 000000000000..78d45926377a
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_drv.c
@@ -0,0 +1,946 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* V2D driver for Spacemit
+* Copyright (C) 2023 Spacemit Co., Ltd.
+*
+*/
+
+#include "v2d_priv.h"
+#include "v2d_drv.h"
+#include "v2d_reg.h"
+#include <linux/clk-provider.h>
+#include <linux/dma-fence.h>
+#include <linux/sync_file.h>
+#include <linux/syscalls.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/workqueue.h>
+#include <linux/clk.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/dma-buf.h>
+#include <linux/highmem.h>
+
+#define  V2D_DRV_NAME		"spacemit_v2d"
+struct v2d_info *v2dInfo;
+
+#ifdef CONFIG_SPACEMIT_DEBUG
+static bool check_v2d_running_status(struct v2d_info *pV2dInfo)
+{
+	return pV2dInfo->b_v2d_running;
+}
+#define to_devinfo(_nb) container_of(_nb, struct v2d_info, nb)
+static int v2d_clkoffdet_notifier_handler(struct notifier_block *nb,
+					  unsigned long msg, void *data)
+{
+	struct clk_notifier_data *cnd = data;
+	struct v2d_info *pV2dInfo = to_devinfo(nb);
+	if ((__clk_is_enabled(cnd->clk)) && (msg & PRE_RATE_CHANGE) &&
+	    (cnd->new_rate == 0) && (cnd->old_rate != 0)) {
+		if (pV2dInfo->is_v2d_running(pV2dInfo))
+			return NOTIFY_BAD;
+	}
+	return NOTIFY_OK;
+}
+#endif
+
+static void v2d_clk_on(struct v2d_info *info)
+{
+	clk_prepare_enable(info->clkcore);
+	clk_prepare_enable(info->clkio);
+#ifdef CONFIG_SPACEMIT_DEBUG
+	info->b_v2d_running = true;
+#endif
+}
+
+static void v2d_clk_off(struct v2d_info *info)
+{
+#ifdef CONFIG_SPACEMIT_DEBUG
+	info->b_v2d_running = false;
+#endif
+	if (__clk_is_enabled(info->clkio)) {
+		clk_disable_unprepare(info->clkio);
+	}
+	if (__clk_is_enabled(info->clkcore)) {
+		clk_disable_unprepare(info->clkcore);
+	}
+}
+
+static ssize_t v2d_sysfs_clkrate_get(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct v2d_info *info  = dev_get_drvdata(dev);
+	long rate = 0;
+	rate = clk_get_rate(info->clkcore);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", (int)rate);
+}
+
+static ssize_t v2d_sysfs_clkrate_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct v2d_info *info  = dev_get_drvdata(dev);
+	long rate = 0;
+	rate = simple_strtol(buf, NULL, 10);
+	if (0 != rate)
+	{
+		clk_set_rate(info->clkcore, rate);
+	}
+	return count;
+}
+
+static struct device_attribute v2d_sysfs_files[] = {
+	__ATTR(clkrate, S_IRUGO | S_IWUSR, v2d_sysfs_clkrate_get, v2d_sysfs_clkrate_set),
+};
+
+static int v2d_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int v2d_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int v2d_runtime_suspend(struct device *dev)
+{
+	struct v2d_info *info  = dev_get_drvdata(dev);
+	if (!IS_ERR_OR_NULL(info->clkcore))
+	{
+		clk_disable_unprepare(info->clkcore);
+		V2DLOGI("v2d: clock off.\n");
+	}
+	return 0;
+}
+
+static int v2d_runtime_resume(struct device *dev)
+{
+	struct v2d_info *info  = dev_get_drvdata(dev);
+	long clk_rate = 0;
+
+	if (!IS_ERR_OR_NULL(info->clkcore))
+	{
+			clk_prepare_enable(info->clkcore);
+			clk_rate = clk_get_rate(info->clkcore);
+			V2DLOGI("v2d: clock on, rate: %ld\n", clk_rate);
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops v2d_pm_ops = {
+	.suspend = v2d_suspend,
+	.resume = v2d_resume,
+	.runtime_suspend = v2d_runtime_suspend,
+	.runtime_resume = v2d_runtime_resume,
+};
+
+static irqreturn_t v2d_irq_handler(int32_t irq, void *dev_id)
+{
+	unsigned long flags =  0;
+	uint32_t irqstatus = 0;
+	uint32_t irqerr = 0;
+
+	struct v2d_info *info = (struct v2d_info *)dev_id;
+
+	if (!info) {
+		V2DLOGE("v2d info is NULL!\n");
+		return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&info->power_spinlock, flags);
+	if (!info->refcount)
+	{
+		spin_unlock_irqrestore(&info->power_spinlock, flags);
+		V2DLOGE("v2d power is off !\n");
+		return IRQ_NONE;
+	}
+	iommu_irq_reset();
+	irqstatus = v2d_irq_status();
+	irqerr = v2d_irqerr_status();
+	v2d_irqerr_clear(irqerr);
+	v2d_irq_clear(irqstatus);
+	if (irqerr){
+		V2DLOGE("%s irq %d irq_status 0x%x,irqerr 0x%x\n", __func__, irq, irqstatus, irqerr);
+		info->do_reset = 1;
+		queue_work(info->v2d_job_done_wq, &info->work);
+	} else if ((irqstatus == V2D_EOF_IRQ_STATUS) || (irqstatus == (V2D_EOF_IRQ_STATUS|V2D_FBCENC_IRQ_STATUS))) {
+		queue_work(info->v2d_job_done_wq, &info->work);
+	}
+	spin_unlock_irqrestore(&info->power_spinlock, flags);
+	return IRQ_HANDLED;
+}
+
+
+static DEFINE_SPINLOCK(v2d_fence_lock);
+static const char *v2d_fence_get_driver_name(struct dma_fence *fence)
+{
+	return "v2d";
+}
+
+static const char *v2d_fence_get_timeline_name(struct dma_fence *fence)
+{
+	return "v2d.timeline";
+}
+
+static bool v2d_fence_enable_signaling(struct dma_fence *fence)
+{
+	return true;
+}
+
+static void v2d_fence_fence_value_str(struct dma_fence *fence, char *str, int size)
+{
+	snprintf(str, size, "%llu", fence->seqno);
+}
+
+const struct dma_fence_ops v2d_fence_ops = {
+	.wait = dma_fence_default_wait,
+	.get_driver_name = v2d_fence_get_driver_name,
+	.get_timeline_name = v2d_fence_get_timeline_name,
+	.enable_signaling = v2d_fence_enable_signaling,
+	.fence_value_str = v2d_fence_fence_value_str
+};
+
+int v2d_fence_generate(struct v2d_info *info, struct dma_fence **fence, int *fence_fd)
+{
+	struct sync_file *sync_file = NULL;
+	int fd;
+
+	struct dma_fence *dmaFence;
+	dmaFence = kzalloc(sizeof(*dmaFence), GFP_KERNEL);
+	if (!dmaFence)
+		return -ENOMEM;
+
+	dma_fence_init(dmaFence, &v2d_fence_ops, &v2d_fence_lock, info->context, atomic_inc_return(&info->seqno));
+	*fence = dmaFence;
+	/* create a sync_file fd representing the fence */
+	#ifdef CONFIG_SYNC_FILE
+	sync_file = sync_file_create(*fence);
+	#endif
+	if (!sync_file) {
+		dma_fence_put(*fence);
+		return -ENOMEM;
+	}
+	fd = get_unused_fd_flags(O_CLOEXEC);
+	*fence_fd = fd;
+	if(fd<0)
+	{
+		dma_fence_put(*fence);
+		fput(sync_file->file);
+		return -ENOMEM;
+	}
+	fd_install(fd, sync_file->file);
+	return 0;
+}
+
+void v2d_fence_wait(struct v2d_info *info, struct dma_fence *fence)
+{
+	int err = dma_fence_wait_timeout(fence, false, msecs_to_jiffies(V2D_SHORT_FENCE_TIMEOUT));
+	if (err > 0)
+		return;
+
+	if (err == 0)
+		err = dma_fence_wait_timeout(fence, false, msecs_to_jiffies(V2D_LONG_FENCE_TIMEOUT));
+
+	if (err <= 0)
+		dev_warn(&info->pdev->dev, "error waiting on fence: %d\n", err);
+}
+
+void kfree_v2d_post_task(struct v2d_pending_post_task *element)
+{
+	if (!element)
+	{
+		return;
+	}
+	if (!element->pTask)
+	{
+		kfree(element);
+		return;
+	}
+	kfree(element->pTask);
+	kfree(element);
+}
+
+#define V2D_TBU_BASE_VA (0x80000000)
+#define V2D_TBU_VA_STEP (0x2000000)
+static int v2d_get_dmabuf(struct v2d_info *v2dinfo, struct v2d_pending_post_task *cfg)
+{
+	V2D_SUBMIT_TASK_S *pTask = cfg->pTask;
+	V2D_SURFACE_S *pLayer0, *pLayer1, *pDst, *pMask;
+	struct dma_buf *dmabuf = NULL;
+	int fd;
+
+	pLayer0 = &pTask->param.layer0;
+	pLayer1 = &pTask->param.layer1;
+	pDst    = &pTask->param.dst;
+	pMask   = &pTask->param.mask;
+
+	if (pLayer0->fbc_enable || pLayer0->fd) {
+		cfg->info[0].valid = 1;
+		cfg->info[0].tbu_id = 0;
+		fd = pLayer0->fbc_enable ? pLayer0->fbcDecInfo.fd : pLayer0->fd;
+		dmabuf = dma_buf_get(fd);
+		if (IS_ERR(dmabuf)) {
+			pr_err("v2d layer0 get dmabuf fail fd:%d\n", fd);
+			return -1;
+		}
+		cfg->info[0].dmabuf = dmabuf;
+	}
+
+	if (pLayer1->fbc_enable || pLayer1->fd) {
+		cfg->info[1].valid = 1;
+		cfg->info[1].tbu_id = -1;
+		fd = pLayer1->fbc_enable ? pLayer1->fbcDecInfo.fd : pLayer1->fd;
+		dmabuf = dma_buf_get(fd);
+		if (IS_ERR(dmabuf)) {
+			pr_err("v2d layer1 get dmabuf fail fd:%d\n", fd);
+			return -1;
+		}
+		cfg->info[1].dmabuf = dmabuf;
+	}
+
+	cfg->info[2].valid = 1;
+	cfg->info[2].tbu_id = 1;
+	fd = pDst->fbc_enable ? pDst->fbcEncInfo.fd : pDst->fd;
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("v2d layer1 get dmabuf fail fd:%d\n", fd);
+		return -1;
+	}
+	cfg->info[2].dmabuf = dmabuf;
+
+	if (pMask->fd) {
+		cfg->info[3].valid = 1;
+		cfg->info[3].tbu_id = -1;
+		dmabuf = dma_buf_get(pMask->fd);
+		if (IS_ERR(dmabuf)) {
+			pr_err("v2d mask get dmabuf fail fd:%d\n", fd);
+			return -1;
+		}
+		cfg->info[3].dmabuf = dmabuf;
+	}
+	return 0;
+}
+
+static int get_addr_from_dmabuf(struct v2d_info *v2dinfo, struct v2d_dma_buf_info *pInfo, dma_addr_t *paddr)
+{
+	struct device *dev = &v2dinfo->pdev->dev;
+	struct sg_table *sgt;
+	dma_addr_t addr;
+	int ret, flags;
+	size_t size = 0;
+	ret = 0;
+
+	pInfo->attach  = dma_buf_attach(pInfo->dmabuf, dev);
+	if (IS_ERR(pInfo->attach)) {
+		pr_err("v2d get dma buf attach fail\n");
+		goto err_dmabuf_put;
+	}
+	pInfo->sgtable = dma_buf_map_attachment(pInfo->attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR(pInfo->sgtable)) {
+		pr_err("v2d get dma buf map attachment fail\n");
+		goto err_dmabuf_detach;
+	}
+	sgt = pInfo->sgtable;
+	flags = IOMMU_READ | IOMMU_CACHE | IOMMU_WRITE;
+
+	if (sgt->nents == 1) {
+		addr = sg_dma_address(sgt->sgl);
+	} else {
+		addr = V2D_TBU_BASE_VA + (dma_addr_t)(pInfo->tbu_id)*V2D_TBU_VA_STEP;
+		size = v2d_iommu_map_sg(addr, sgt->sgl, sgt->orig_nents, flags);
+		if (!size) {
+			pr_err("v2d iommu map sgtable fail\n");
+			goto err_dmabuf_unmap;
+		}
+	}
+	*paddr = addr;
+	return ret;
+
+err_dmabuf_unmap:
+	dma_buf_unmap_attachment(pInfo->attach, pInfo->sgtable, DMA_BIDIRECTIONAL);
+err_dmabuf_detach:
+	dma_buf_detach(pInfo->dmabuf, pInfo->attach);
+err_dmabuf_put:
+	dma_buf_put(pInfo->dmabuf);
+	return -1;
+
+}
+
+static int v2d_get_dma_addr(struct v2d_info *v2dinfo, struct v2d_pending_post_task *cfg)
+{
+	V2D_SUBMIT_TASK_S *pTask = cfg->pTask;
+	V2D_SURFACE_S *pLayer0, *pLayer1, *pDst, *pMask;
+	dma_addr_t addr;
+	struct v2d_dma_buf_info *pInfo;
+	int ret = 0;
+	pLayer0 = &pTask->param.layer0;
+	pLayer1 = &pTask->param.layer1;
+	pDst    = &pTask->param.dst;
+	pMask   = &pTask->param.mask;
+
+	pInfo = &cfg->info[0];
+	if (pInfo->valid) {
+		ret = get_addr_from_dmabuf(v2dinfo, pInfo, &addr);
+		if (ret) return ret;
+		if (pLayer0->fbc_enable) {
+			pLayer0->fbcDecInfo.headerAddr_l = addr & 0xFFFFFFFF;
+			pLayer0->fbcDecInfo.headerAddr_h = (addr >> 32) & 0xFFFFFFFF;
+		} else {
+			pLayer0->phyaddr_y_l  = addr & 0xFFFFFFFF;
+			pLayer0->phyaddr_y_h  = (addr >> 32) & 0xFFFFFFFF;
+			pLayer0->phyaddr_uv_l = pLayer0->offset ? (pLayer0->phyaddr_y_l+pLayer0->offset) : 0;
+			pLayer0->phyaddr_uv_h = pLayer0->offset ? pLayer0->phyaddr_y_h : 0;
+		}
+	}
+
+	pInfo = &cfg->info[1];
+	if (pInfo->valid) {
+		ret = get_addr_from_dmabuf(v2dinfo, pInfo, &addr);
+		if (ret) return ret;
+		if (pLayer1->fbc_enable) {
+			pLayer1->fbcDecInfo.headerAddr_l = addr & 0xFFFFFFFF;
+			pLayer1->fbcDecInfo.headerAddr_h = (addr >> 32) & 0xFFFFFFFF;
+		} else {
+			pLayer1->phyaddr_y_l  = addr & 0xFFFFFFFF;
+			pLayer1->phyaddr_y_h  = (addr >> 32) & 0xFFFFFFFF;
+			pLayer1->phyaddr_uv_l = pLayer0->offset ? (pLayer0->phyaddr_y_l+pLayer0->offset) : 0;
+			pLayer1->phyaddr_uv_h = pLayer0->offset ? pLayer0->phyaddr_y_h : 0;
+		}
+	}
+
+	pInfo = &cfg->info[2];
+	if (pInfo->valid) {
+		ret = get_addr_from_dmabuf(v2dinfo, pInfo, &addr);
+		if (ret) return ret;
+		if (pDst->fbc_enable) {
+			pDst->fbcEncInfo.headerAddr_l  = addr & 0xFFFFFFFF;
+			pDst->fbcEncInfo.headerAddr_h  = (addr >> 32) & 0xFFFFFFFF;
+			pDst->fbcEncInfo.payloadAddr_l = pDst->fbcEncInfo.headerAddr_l + pDst->fbcEncInfo.offset;
+			pDst->fbcEncInfo.payloadAddr_h = pDst->fbcEncInfo.headerAddr_h;
+		} else {
+			pDst->phyaddr_y_l  = addr & 0xFFFFFFFF;
+			pDst->phyaddr_y_h  = (addr >> 32) & 0xFFFFFFFF;
+			pDst->phyaddr_uv_l = pDst->offset ? (pDst->phyaddr_y_l+pDst->offset) : 0;
+			pDst->phyaddr_uv_h = pDst->offset ? pDst->phyaddr_y_h : 0;
+		}
+	}
+
+	pInfo = &cfg->info[3];
+	if (pInfo->valid) {
+		ret = get_addr_from_dmabuf(v2dinfo, pInfo, &addr);
+		if (ret) return ret;
+		pMask->phyaddr_y_l = addr & 0xFFFFFFFF;
+		pMask->phyaddr_y_h = (addr >> 32) & 0xFFFFFFFF;
+	}
+	return ret;
+}
+
+static void v2d_put_dmabuf(struct v2d_info *v2dinfo, struct v2d_pending_post_task *cfg)
+{
+	int i;
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sg_table;
+	struct v2d_dma_buf_info *pInfo;
+
+	for (i=0; i<4; i++) {
+		pInfo    = &cfg->info[i];
+		dmabuf   = pInfo->dmabuf;
+		attach   = pInfo->attach;
+		sg_table = pInfo->sgtable;
+
+		if (dmabuf && attach && sg_table) {
+			dma_buf_unmap_attachment(attach, sg_table, DMA_BIDIRECTIONAL);
+			dma_buf_detach(dmabuf, attach);
+			dma_buf_put(dmabuf);
+		}
+	}
+	v2d_iommu_map_end();
+}
+
+int v2d_job_submit(struct v2d_info *info, V2D_SUBMIT_TASK_S *psubmit)
+{
+	int err = 0;
+ 	V2D_SUBMIT_TASK_S *pTask = NULL;
+	struct v2d_pending_post_task *cfg = NULL;
+	struct dma_fence *fence = NULL;
+	pTask = kzalloc(sizeof(V2D_SUBMIT_TASK_S), GFP_KERNEL);
+	if (!pTask){
+		err = -ENOMEM;
+		goto error;
+	}
+	memset(pTask,0,sizeof(V2D_SUBMIT_TASK_S));
+	if(copy_from_user(pTask,(uint32_t *)psubmit, sizeof(V2D_SUBMIT_TASK_S)) != 0) {
+		err = -EINVAL;
+		goto error;
+	}
+	if(v2d_fence_generate(info, &fence, &pTask->completeFencefd))
+	{
+		printk(KERN_ERR "%s" "-%s-Failed to generate fence(%pf),fd(%d)-slot1\n", "v2d", __func__,fence, pTask->completeFencefd);
+		err = -EINVAL;
+		goto error;
+	}
+	if (0 != copy_to_user((__user uint8_t *)psubmit+offsetof(V2D_SUBMIT_TASK_S, completeFencefd), &pTask->completeFencefd, sizeof(int32_t))) {
+		pTask->completeFencefd = -1;
+		err = -EINVAL;
+		goto error;
+	}
+	mutex_lock(&info->client_lock);
+	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
+	if (!cfg){
+		mutex_unlock(&info->client_lock);
+		err = -ENOMEM;
+		goto error;
+	}
+	memset(cfg,0,sizeof(struct v2d_pending_post_task));
+	INIT_LIST_HEAD(&cfg->head);
+	cfg->pTask = pTask;
+	if (pTask->completeFencefd>=0)
+	{
+		cfg->pCompleteFence = fence;
+	}
+	if (pTask->acquireFencefd>=0)
+	{
+		#ifdef CONFIG_SYNC_FILE
+		cfg->pAcquireFence = sync_file_get_fence(cfg->pTask->acquireFencefd);
+		#endif
+	}
+	err = v2d_get_dmabuf(info, cfg);
+	if (err) {
+		mutex_unlock(&info->client_lock);
+		kfree(cfg);
+		goto error;
+	}
+	mutex_lock(&info->post_lock);
+	list_add_tail(&cfg->head, &info->post_list);
+	kthread_queue_work(&info->post_worker, &info->post_work);
+	mutex_unlock(&info->post_lock);
+	mutex_unlock(&info->client_lock);
+	return 0;
+
+error:
+	if(pTask){
+		kfree(pTask);
+	}
+	return err;
+}
+
+void v2d_work_done(struct work_struct *data)
+{
+	struct v2d_pending_post_task *element, *tmp;
+	int refcount;
+	struct dma_fence *pCompleteFence = NULL;
+	struct v2d_info *info = container_of(data, struct v2d_info, work);
+
+	mutex_lock(&info->free_lock);
+	list_for_each_entry_safe(element, tmp, &info->free_list, head) {
+		if (element->pTask->completeFencefd>=0)
+		{
+			pCompleteFence = element->pCompleteFence;
+			if(NULL != pCompleteFence) {
+				dma_fence_signal(pCompleteFence);
+				dma_fence_put(pCompleteFence);
+			}
+		}
+		v2d_put_dmabuf(info, element);
+		mutex_lock(&info->power_mutex);
+		info->refcount--;
+		refcount = info->refcount;
+		if (info->do_reset) {
+			v2d_golbal_reset();
+			info->do_reset = 0;
+		}
+		if(!refcount)
+		{
+			v2d_irq_disable();
+			v2d_clk_off(info);
+		}
+		mutex_unlock(&info->power_mutex);
+		list_del(&element->head);
+		kfree_v2d_post_task(element);
+		up(&info->sem_lock);
+	}
+	mutex_unlock(&info->free_lock);
+}
+
+void do_softreset(void)
+{
+	struct v2d_pending_post_task *element, *tmp;
+	struct dma_fence *pCompleteFence = NULL;
+	int refcount;
+	unsigned long flags =  0;
+	struct v2d_info *info = v2dInfo;
+
+	mutex_lock(&info->free_lock);
+	list_for_each_entry_safe(element, tmp, &info->free_list, head) {
+		if (element->pTask->completeFencefd>=0)
+		{
+			pCompleteFence = element->pCompleteFence;
+			if(NULL != pCompleteFence) {
+				dma_fence_signal(pCompleteFence);
+				dma_fence_put(pCompleteFence);
+			}
+		}
+		v2d_put_dmabuf(info, element);
+		mutex_lock(&info->power_mutex);
+		spin_lock_irqsave(&info->power_spinlock, flags);
+		info->refcount--;
+		refcount = info->refcount;
+		v2d_dump_irqraw_status();
+		v2d_golbal_reset();
+		spin_unlock_irqrestore(&info->power_spinlock, flags);
+		if(!refcount)
+		{
+			v2d_irq_disable();
+			v2d_clk_off(info);
+		}
+		mutex_unlock(&info->power_mutex);
+		list_del(&element->head);
+		kfree_v2d_post_task(element);
+		up(&info->sem_lock);
+	}
+	mutex_unlock(&info->free_lock);
+	flush_workqueue(info->v2d_job_done_wq);
+}
+
+void v2d_post_work_func(struct kthread_work *work)
+{
+	struct v2d_info *info = container_of(work, struct v2d_info, post_work);
+	struct v2d_pending_post_task *post, *next;
+	int refcount;
+	unsigned long flags = 0;
+	struct dma_fence *pAcquireFence = NULL;
+	mutex_lock(&info->post_lock);
+	list_for_each_entry_safe(post, next, &info->post_list, head) {
+		while(down_timeout(&info->sem_lock, msecs_to_jiffies(2500)))
+		{
+			printk(KERN_ERR "%s hang do softreset\n", "v2d");
+			do_softreset();
+		}
+		if (post->pTask->acquireFencefd>=0)
+		{
+			pAcquireFence = post->pAcquireFence;
+			v2d_fence_wait(info, pAcquireFence);
+			dma_fence_put(pAcquireFence);
+		}
+		list_del(&post->head);
+		mutex_lock(&info->free_lock);
+		list_add_tail(&post->head, &info->free_list);
+		mutex_unlock(&info->free_lock);
+		mutex_lock(&info->power_mutex);
+		spin_lock_irqsave(&info->power_spinlock, flags);
+		refcount = info->refcount;
+		info->refcount++;
+		spin_unlock_irqrestore(&info->power_spinlock, flags);
+		if(!refcount)
+		{
+			v2d_clk_on(info);
+			v2d_irq_enable();
+		}
+		if (v2d_get_dma_addr(info, post)) {
+			queue_work(info->v2d_job_done_wq, &info->work);
+		} else {
+			config_v2d_hw(post->pTask);
+		}
+		mutex_unlock(&info->power_mutex);
+	}
+	mutex_unlock(&info->post_lock);
+}
+
+
+static DEFINE_MUTEX(v2d_wr_lock);
+static DEFINE_MUTEX(v2d_dev_lock);
+static int v2d_dev_ref = 0;
+static int v2d_dev_open(struct inode *inode, struct file *filp)
+{
+	mutex_lock(&(v2d_dev_lock));
+	filp->private_data = (void *)v2dInfo;
+	v2d_dev_ref++;
+	mutex_unlock(&(v2d_dev_lock));
+	return 0;
+}
+
+static int v2d_dev_release(struct inode *inode, struct file *filp)
+{
+	mutex_lock(&(v2d_dev_lock));
+	v2d_dev_ref--;
+	mutex_unlock(&(v2d_dev_lock));
+	return 0;
+}
+
+ssize_t v2d_dev_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+ssize_t v2d_dev_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)
+{
+	int ret;
+	struct v2d_info *pInfo;
+
+	mutex_lock(&(v2d_wr_lock));
+	pInfo = (struct v2d_info *)filp->private_data;
+	ret = v2d_job_submit(pInfo, (V2D_SUBMIT_TASK_S*)buf);
+	if (ret) {
+		mutex_unlock(&(v2d_wr_lock));
+		V2DLOGE("v2d faild to write msg %d\n", ret);
+		return -EIO;
+	}
+	mutex_unlock(&(v2d_wr_lock));
+	return count;
+}
+
+static int v2d_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err;
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	if ((vma->vm_pgoff + (size >> PAGE_SHIFT)) > (1 + (P4D_SHIFT >> PAGE_SHIFT))) {
+			pr_err("out of physical memory\n");
+			return -EINVAL;
+	}
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_ops = NULL;
+	err = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+									size, vma->vm_page_prot);
+	if (err) {
+			pr_err("failed to v2d map memroy\n");
+			return -ENXIO;
+	}
+
+	return 0;
+}
+
+static const struct file_operations v2d_dev_fops = {
+	.owner	= THIS_MODULE,
+	.open	= v2d_dev_open,
+	.release = v2d_dev_release,
+	.read	= v2d_dev_read,
+	.write	= v2d_dev_write,
+	.poll	= NULL,
+	.mmap	= v2d_mmap,
+};
+
+extern struct v2d_iommu_res sV2dIommuRes;
+static int v2d_iommu_init(struct platform_device *pdev, void __iomem *base)
+{
+	struct device *dev = &pdev->dev;
+	int i;
+	struct v2d_iommu_res *v2d_res = &sV2dIommuRes;
+	void *va_temp;
+	dma_addr_t pa_temp;
+
+	v2d_res->base = base;
+	v2d_res->page_size = SZ_4K;
+	va_temp = dma_alloc_coherent(dev, MAX_SIZE_PER_TTB*TBU_INSTANCES_NUM, &pa_temp, GFP_KERNEL|GFP_DMA);
+	if (!va_temp) {
+		pr_err("v2d iommu no memory for %d tbu_ins!\n",
+			TBU_INSTANCES_NUM);
+		return -1;
+	}
+
+	for (i = 0; i < TBU_INSTANCES_NUM; i++) {
+		struct tbu_instance *tbu = NULL;
+		if (i <TBU_INSTANCES_NUM) {
+			tbu = &v2d_res->tbu_ins[i];
+			tbu->ins_id = i;
+		}
+		tbu->ttb_va = va_temp + i * MAX_SIZE_PER_TTB;
+		tbu->ttb_pa = pa_temp + i * MAX_SIZE_PER_TTB;
+	}
+
+	v2d_res->va_base = BASE_VIRTUAL_ADDRESS;
+	v2d_res->va_end  = BASE_VIRTUAL_ADDRESS + TBU_NUM * VA_STEP_PER_TBU;
+	v2d_res->time_out_cycs = DEFAULT_TIMEOUT_CYCS;
+
+	return 0;
+}
+
+static int v2d_iommu_deinit(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct v2d_iommu_res *v2d_res = &sV2dIommuRes;
+
+	dma_free_coherent(dev,
+				MAX_SIZE_PER_TTB*TBU_INSTANCES_NUM,
+				v2d_res->tbu_ins[0].ttb_va,
+				v2d_res->tbu_ins[0].ttb_pa);
+
+	return 0;
+}
+
+
+static u64 v2d_dmamask = 0xffffffffffUL;
+static int v2d_probe(struct platform_device *pdev)
+{
+	struct v2d_info *info;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	void __iomem *base;
+	int i, rval = 0;
+	struct sched_param param;
+
+	info = devm_kzalloc(dev, sizeof(struct v2d_info), GFP_KERNEL);
+	if (info == NULL) {
+		return -ENOMEM;
+	}
+	dev->dma_mask = &v2d_dmamask;
+	dev->coherent_dma_mask = 0xffffffffffull;
+
+	info->clkcore = devm_clk_get(dev, "v2d-core");
+	if (IS_ERR(info->clkcore)) {
+		V2DLOGE("Could not get v2d core clk!\n");
+		return -EINVAL;
+	}
+	clk_set_rate(info->clkcore, 409600000);
+
+	info->clkio = devm_clk_get(dev, "v2d-io");
+	if (IS_ERR(info->clkio)) {
+		V2DLOGE("Could not get v2d io clk!\n");
+		return -EINVAL;
+	}
+	/* get v2d regs base */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "v2dreg");
+	if (res == NULL) {
+		 return -ENOENT;
+	}
+	base = devm_ioremap(dev, res->start, resource_size(res));
+	if (base == NULL) {
+		return -EIO;
+	}
+	info->v2dreg_iomem_base = base;
+	info->irq = platform_get_irq(pdev, 0);
+	V2DLOGI("v2d irq num = %d\n", info->irq);
+	if (info->irq < 0) {
+		return -ENOENT;
+	}
+	rval = devm_request_irq(dev, info->irq, v2d_irq_handler, IRQF_SHARED, "v2d-irq", info);
+	if (rval) {
+		return rval;
+	}
+	v2d_iommu_init(pdev, base);
+
+	for (i = 0; i < ARRAY_SIZE(v2d_sysfs_files); i++) {
+		rval = device_create_file(dev, &v2d_sysfs_files[i]);
+		if (rval)
+			return rval;
+	}
+	mutex_init(&info->power_mutex);
+	spin_lock_init(&info->power_spinlock);
+	info->refcount = 0;
+	info->pdev = pdev;
+	platform_set_drvdata(pdev, info);
+	info->mdev.minor  = MISC_DYNAMIC_MINOR;
+	info->mdev.name   = "v2d_dev";
+	info->mdev.fops   = &v2d_dev_fops;
+	rval = misc_register(&info->mdev);
+	if (rval) {
+		V2DLOGE("failed register v2d misc device ret=%d\n", rval);
+		goto err_misc;
+	}
+	sema_init(&info->sem_lock, 1);
+	info->context = dma_fence_context_alloc(1);
+	info->v2d_job_done_wq = alloc_workqueue("spacemit_v2d", WQ_HIGHPRI | WQ_UNBOUND, 1);
+	if (NULL == info->v2d_job_done_wq) {
+		V2DLOGE( "%s: alloc_workqueue failed\n", __func__);
+		goto err;
+	}
+	INIT_WORK(&info->work, v2d_work_done);
+	mutex_init(&info->client_lock);
+	INIT_LIST_HEAD(&info->post_list);
+	mutex_init(&info->post_lock);
+	INIT_LIST_HEAD(&info->free_list);
+	mutex_init(&info->free_lock);
+	kthread_init_worker(&info->post_worker);
+	info->post_thread = kthread_run(kthread_worker_fn, &info->post_worker, "v2d");
+	if (IS_ERR(info->post_thread)) {
+		rval = PTR_ERR(info->post_thread);
+		info->post_thread = NULL;
+		V2DLOGE("%s: failed to run config posting thread: %d\n", __func__, rval);
+		goto err;
+	}
+	param.sched_priority = 1;
+	sched_setscheduler(info->post_thread, SCHED_FIFO, &param);
+	kthread_init_work(&info->post_work, v2d_post_work_func);
+#ifdef CONFIG_SPACEMIT_DEBUG
+	info->is_v2d_running = check_v2d_running_status;
+	info->nb.notifier_call = v2d_clkoffdet_notifier_handler;
+	clk_notifier_register(info->clkcore, &info->nb);
+#endif
+	V2DLOGI("probe v2d driver done!\n");
+	v2dInfo = info;
+
+	return 0;
+
+err:
+	if(info->post_thread)
+		 kthread_stop(info->post_thread);
+	if(info->v2d_job_done_wq)
+		destroy_workqueue(info->v2d_job_done_wq);
+
+err_misc:
+	for (i = 0; i < ARRAY_SIZE(v2d_sysfs_files); i++) {
+		device_remove_file(dev, &v2d_sysfs_files[i]);
+	}
+	misc_deregister(&info->mdev);
+
+	return rval;
+}
+
+static int v2d_remove(struct platform_device *pdev)
+{
+	struct v2d_info *info = platform_get_drvdata(pdev);
+	struct device *dev = &info->pdev->dev;
+	int i;
+
+	V2DLOGI("remove v2d driver!\n");
+	v2d_iommu_deinit(pdev);
+	devm_free_irq(dev, info->irq, info);
+	kthread_flush_worker(&info->post_worker);
+	kthread_stop(info->post_thread);
+	for (i = 0; i < ARRAY_SIZE(v2d_sysfs_files); i++) {
+		device_remove_file(dev, &v2d_sysfs_files[i]);
+	}
+#ifdef CONFIG_SPACEMIT_DEBUG
+	info->is_v2d_running = NULL;
+	info->nb.notifier_call = NULL;
+	clk_notifier_unregister(info->clkcore, &info->nb);
+#endif
+	misc_deregister(&info->mdev);
+	if(info->v2d_job_done_wq)
+		destroy_workqueue(info->v2d_job_done_wq);
+	v2dInfo = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id v2d_drv_match_table[] = {
+	{ .compatible = "spacemit,v2d" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, v2d_drv_match_table);
+
+static struct platform_driver v2d_driver = {
+	.driver 	= {
+		.name	= V2D_DRV_NAME,
+		.of_match_table = of_match_ptr(v2d_drv_match_table),
+		.pm		= &v2d_pm_ops,
+	},
+	.probe		= v2d_probe,
+	.remove 	= v2d_remove,
+};
+
+static int __init v2d_init(void)
+{
+	return platform_driver_register(&v2d_driver);
+}
+
+static void __exit v2d_exit(void)
+{
+	platform_driver_unregister(&v2d_driver);
+}
+
+module_init(v2d_init);
+module_exit(v2d_exit);
+
+MODULE_DESCRIPTION("Spacemit V2D driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/spacemit/v2d/v2d_drv.h b/drivers/media/platform/spacemit/v2d/v2d_drv.h
new file mode 100644
index 000000000000..5faec6166128
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_drv.h
@@ -0,0 +1,327 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef _V2D_DRV_H_
+#define _V2D_DRV_H_
+#include <linux/types.h>
+
+typedef enum SPACEMIT_V2D_SCALER_MODE_E {
+    V2D_NO_SCALE    =0,
+    V2D_SCALE_DOWN  =1,
+    V2D_SCALE_UP    =2,
+} V2D_SCALER_MODE_E;
+
+typedef enum SPACEMIT_V2D_INPUT_LAYER_E {
+    V2D_INPUT_LAYER0    =0,
+    V2D_INPUT_LAYER1    =1,
+    V2D_INPUT_LAYER_NUM =2,
+} V2D_INPUT_LAYER_E;
+
+typedef enum SPACEMIT_V2D_FUNCTION_MODE_E {
+    V2D_FUNC_DISABLE=0,
+    V2D_FUNC_ENABLE =1,
+} V2D_FUNCTION_MODE_E;
+
+typedef enum SPACEMIT_V2D_DITHER_E {
+    V2D_NO_DITHER   =0,
+    V2D_DITHER_4X4  =1,
+    V2D_DITHER_8X8  =2,
+} V2D_DITHER_E;
+
+typedef enum SPACEMIT_V2D_ROTATE_ANGLE {
+    V2D_ROT_0       =0,
+    V2D_ROT_90      =1,
+    V2D_ROT_180     =2,
+    V2D_ROT_270     =3,
+    V2D_ROT_MIRROR  =4,
+    V2D_ROT_FLIP    =5,
+} V2D_ROTATE_ANGLE_E;
+
+typedef enum SPACEMIT_V2D_BLENDCMD_E {
+    V2D_BLENDCMD_ALPHA  = 0,
+    V2D_BLENDCMD_ROP2   = 1,
+    V2D_BLENDCMD_BUTT
+} V2D_BLENDCMD_E;
+
+typedef enum SPACEMIT_V2D_MASKCMD_E {
+    V2D_MASKCMD_DISABLE     = 0,
+    V2D_MASKCMD_NORMAL      = 1,
+    V2D_MASKCMD_AS_VALUE    = 2,
+    V2D_MASKCMD_BUTT
+} V2D_MASKCMD_E;
+
+typedef enum SPACEMIT_V2D_BLENDALPHA_SOURCE_E {
+    V2D_BLENDALPHA_SOURCE_PIXEL     = 0,
+    V2D_BLENDALPHA_SOURCE_GOLBAL    = 1,
+    V2D_BLENDALPHA_SOURCE_MASK      = 2,
+    V2D_BLENDALPHA_SOURCE_BUTT
+} V2D_BLENDALPHA_SOURCE_E;
+
+typedef enum SPACEMIT_V2D_BLEND_PRE_ALPHA_FUNC_E {
+    V2D_BLEND_PRE_ALPHA_FUNC_DISABLE                = 0,
+    V2D_BLEND_PRE_ALPHA_FUNC_GLOBAL_MULTI_SOURCE    = 1,
+    V2D_BLEND_PRE_ALPHA_FUNC_MASK_MULTI_SOURCE      = 2,
+    V2D_BLEND_PRE_ALPHA_FUNC_BUTT
+} V2D_BLEND_PRE_ALPHA_FUNC_E;
+
+typedef enum SPACEMIT_V2D_BLEND_MODE_E {
+    V2D_BLEND_ZERO = 0x0,
+    V2D_BLEND_ONE,
+    V2D_BLEND_SRC_ALPHA,
+    V2D_BLEND_ONE_MINUS_SRC_ALPHA,
+    V2D_BLEND_DST_ALPHA,
+    V2D_BLEND_ONE_MINUS_DST_ALPHA,
+    V2D_BLEND_BUTT
+}V2D_BLEND_MODE_E;
+
+typedef enum SPACEMIT_V2D_ROP2_MODE_E {
+    V2D_ROP2_BLACK      =0,
+    V2D_ROP2_NOTMERGEPEN=1,
+    V2D_ROP2_MASKNOTPEN =2,
+    V2D_ROP2_NOTCOPYPEN =3,
+    V2D_ROP2_MASKPENNOT =4,
+    V2D_ROP2_NOT        =5,
+    V2D_ROP2_XORPEN     =6,
+    V2D_ROP2_NOTMASKPEN =7,
+    V2D_ROP2_MASKPEN    =8,
+    V2D_ROP2_NOTXORPEN  =9,
+    V2D_ROP2_NOP        =10,
+    V2D_ROP2_MERGENOTPEN=11,
+    V2D_ROP2_COPYPEN    =12,
+    V2D_ROP2_MERGEPENNOT=13,
+    V2D_ROP2_MERGEPEN   =14,
+    V2D_ROP2_WHITE      =15,
+    V2D_ROP2_BUTT       =16
+}V2D_ROP2_MODE_E;
+
+typedef enum SPACEMIT_V2D_COLOR_FORMAT_E {
+    V2D_COLOR_FORMAT_RGB888     =0,
+    V2D_COLOR_FORMAT_RGBX8888   =1,
+    V2D_COLOR_FORMAT_RGBA8888   =2,
+    V2D_COLOR_FORMAT_ARGB8888   =3,
+    V2D_COLOR_FORMAT_RGB565     =4,
+    V2D_COLOR_FORMAT_NV12       =5,
+    V2D_COLOR_FORMAT_RGBA5658   =6,
+    V2D_COLOR_FORMAT_ARGB8565   =7,
+    V2D_COLOR_FORMAT_A8         =8,
+    V2D_COLOR_FORMAT_Y8         =9,
+    V2D_COLOR_FORMAT_L8_RGBA8888=10,
+    V2D_COLOR_FORMAT_L8_RGB888  =11,
+    V2D_COLOR_FORMAT_L8_RGB565  =12,
+    V2D_COLOR_FORMAT_BGR888     =13,
+    V2D_COLOR_FORMAT_BGRX8888   =14,
+    V2D_COLOR_FORMAT_BGRA8888   =15,
+    V2D_COLOR_FORMAT_ABGR8888   =16,
+    V2D_COLOR_FORMAT_BGR565     =17,
+    V2D_COLOR_FORMAT_NV21       =18,
+    V2D_COLOR_FORMAT_BGRA5658   =19,
+    V2D_COLOR_FORMAT_ABGR8565   =20,
+    V2D_COLOR_FORMAT_L8_BGRA8888=21,
+    V2D_COLOR_FORMAT_L8_BGR888  =22,
+    V2D_COLOR_FORMAT_L8_BGR565  =23,
+    V2D_COLOR_FORMAT_BUTT,
+}V2D_COLOR_FORMAT_E;
+
+typedef enum SPACEMIT_V2D_CSC_MODE_E {
+    V2D_CSC_MODE_RGB_2_BT601WIDE            =0,
+    V2D_CSC_MODE_BT601WIDE_2_RGB            =1,
+    V2D_CSC_MODE_RGB_2_BT601NARROW          =2,
+    V2D_CSC_MODE_BT601NARROW_2_RGB          =3,
+    V2D_CSC_MODE_RGB_2_BT709WIDE            =4,
+    V2D_CSC_MODE_BT709WIDE_2_RGB            =5,
+    V2D_CSC_MODE_RGB_2_BT709NARROW          =6,
+    V2D_CSC_MODE_BT709NARROW_2_RGB          =7,
+    V2D_CSC_MODE_BT601WIDE_2_BT709WIDE      =8,
+    V2D_CSC_MODE_BT601WIDE_2_BT709NARROW    =9,
+    V2D_CSC_MODE_BT601WIDE_2_BT601NARROW    =10,
+    V2D_CSC_MODE_BT601NARROW_2_BT709WIDE    =11,
+    V2D_CSC_MODE_BT601NARROW_2_BT709NARROW  =12,
+    V2D_CSC_MODE_BT601NARROW_2_BT601WIDE    =13,
+    V2D_CSC_MODE_BT709WIDE_2_BT601WIDE      =14,
+    V2D_CSC_MODE_BT709WIDE_2_BT601NARROW    =15,
+    V2D_CSC_MODE_BT709WIDE_2_BT709NARROW    =16,
+    V2D_CSC_MODE_BT709NARROW_2_BT601WIDE    =17,
+    V2D_CSC_MODE_BT709NARROW_2_BT601NARROW  =18,
+    V2D_CSC_MODE_BT709NARROW_2_BT709WIDE    =19,
+    V2D_CSC_MODE_RGB_2_GREY                 =20,
+    V2D_CSC_MODE_RGB_2_RGB                  =21,
+    V2D_CSC_MODE_BUTT                       =22,
+} V2D_CSC_MODE_E;
+
+typedef enum SPACEMIT_FBC_DECODER_MODE_E {
+    FBC_DECODER_MODE_SCAN_LINE            =0,
+    FBC_DECODER_MODE_LDC_Y                =1,
+    FBC_DECODER_MODE_LDC_UV               =2,
+    FBC_DECODER_MODE_H264_32x16           =3,
+    FBC_DECODER_MODE_H265_32x32           =4,
+    FBC_DECODER_MODE_BUTT                 =5,
+} FBC_DECODER_MODE_E;
+
+typedef enum SPACEMIT_FBC_DECODER_FORMAT_E {
+    FBC_DECODER_FORMAT_NV12               =0,
+    FBC_DECODER_FORMAT_RGB888             =1,
+    FBC_DECODER_FORMAT_ARGB8888           =2,
+    FBC_DECODER_FORMAT_RGB565             =3,
+    FBC_DECODER_FORMAT_BUTT               =4,
+} FBC_DECODER_FORMAT_E;
+
+typedef struct {
+    uint16_t x; /* left */
+    uint16_t y; /* top */
+    uint16_t w; /* crop width */
+    uint16_t h; /* crop height */
+} V2D_AREA_S;
+
+typedef struct SPACEMIT_V2D_FILLCOLOR_S {
+    uint32_t colorvalue;
+    V2D_COLOR_FORMAT_E format;
+} V2D_FILLCOLOR_S;
+
+typedef struct SPACEMIT_V2D_BACKGROUND_S {
+    V2D_FILLCOLOR_S fillcolor;
+    bool enable;
+} V2D_BACKGROUND_S;
+
+typedef struct SPACEMIT_V2D_SOLIDCOLOR_S {
+    V2D_FILLCOLOR_S fillcolor;
+    bool enable;
+} V2D_SOLIDCOLOR_S;
+
+typedef struct SPACEMIT_V2D_PALETTE_S {
+    uint8_t palVal[1024];
+    int len;
+} V2D_PALETTE_S;
+
+typedef struct SPACEMIT_FBC_DECODER_S {
+    int fd;
+    uint32_t headerAddr_h;
+    uint32_t headerAddr_l;
+    uint16_t bboxLeft;
+    uint16_t bboxRight;
+    uint16_t bboxTop;
+    uint16_t bboxBottom;
+    bool rgb_pack_en;
+    bool is_split;
+    FBC_DECODER_MODE_E   enFbcdecMode;
+    FBC_DECODER_FORMAT_E enFbcdecFmt;
+} FBC_DECODER_S;
+
+typedef FBC_DECODER_FORMAT_E FBC_ENCODER_FORMAT_E;
+typedef struct SPACEMIT_FBC_ENCODER_S {
+    int fd;
+    int offset;
+    uint32_t headerAddr_h;
+    uint32_t headerAddr_l;
+    uint32_t payloadAddr_h;
+    uint32_t payloadAddr_l;
+    uint16_t bboxLeft;
+    uint16_t bboxRight;
+    uint16_t bboxTop;
+    uint16_t bboxBottom;
+    bool is_split;
+    FBC_ENCODER_FORMAT_E enFbcencFmt;
+} FBC_ENCODER_S;
+
+typedef struct SPACEMIT_V2D_SURFACE_S {
+    struct {
+        bool fbc_enable;
+        int fd;
+        int offset;
+        uint32_t phyaddr_y_l;
+        uint32_t phyaddr_y_h;
+        uint32_t phyaddr_uv_l;
+        uint32_t phyaddr_uv_h;
+        uint16_t w;
+        uint16_t h;
+        uint16_t stride;
+        V2D_COLOR_FORMAT_E format;
+    };
+    union {
+        FBC_DECODER_S fbcDecInfo;
+        FBC_ENCODER_S fbcEncInfo;
+    };
+    V2D_SOLIDCOLOR_S solidcolor;
+} V2D_SURFACE_S;
+
+typedef struct {
+    V2D_BLEND_MODE_E srcColorFactor;
+    V2D_BLEND_MODE_E dstColorFactor;
+    V2D_BLEND_MODE_E srcAlphaFactor;
+    V2D_BLEND_MODE_E dstAlphaFactor;
+} V2D_BLEND_FACTOR_S;
+
+typedef struct {
+    V2D_ROP2_MODE_E colorRop2Code;
+    V2D_ROP2_MODE_E alphaRop2Code;
+} V2D_ROP2_CODE_S;
+
+typedef struct {
+    V2D_BLENDALPHA_SOURCE_E blend_alpha_source;
+    V2D_BLEND_PRE_ALPHA_FUNC_E blend_pre_alpha_func;
+    uint8_t global_alpha;
+    union {
+        V2D_BLEND_FACTOR_S stBlendFactor;
+        V2D_ROP2_CODE_S stRop2Code;
+    };
+    V2D_AREA_S blend_area;
+} V2D_BLEND_LAYER_CONF_S;
+
+typedef struct {
+    V2D_BLENDCMD_E blend_cmd;
+    V2D_BACKGROUND_S bgcolor;
+    V2D_MASKCMD_E mask_cmd;
+    V2D_AREA_S blend_mask_area;
+    V2D_BLEND_LAYER_CONF_S blendlayer[V2D_INPUT_LAYER_NUM];
+} V2D_BLEND_CONF_S;
+
+typedef struct {
+    V2D_SURFACE_S layer0;
+    V2D_SURFACE_S layer1;
+    V2D_SURFACE_S mask;
+    V2D_SURFACE_S dst;
+    V2D_AREA_S l0_rect;
+    V2D_AREA_S l1_rect;
+    V2D_AREA_S mask_rect;
+    V2D_AREA_S dst_rect;
+    V2D_BLEND_CONF_S blendconf;
+    V2D_ROTATE_ANGLE_E l0_rt;
+    V2D_ROTATE_ANGLE_E l1_rt;
+    V2D_CSC_MODE_E l0_csc;
+    V2D_CSC_MODE_E l1_csc;
+    V2D_DITHER_E dither;
+    V2D_PALETTE_S palette;
+} V2D_PARAM_S;
+
+typedef struct  {
+    V2D_PARAM_S param;
+    int32_t acquireFencefd;
+    int32_t completeFencefd;
+} V2D_SUBMIT_TASK_S;
+
+struct v2d_dma_buf_info {
+    struct dma_buf *dmabuf;
+    struct dma_buf_attachment *attach;
+    struct sg_table *sgtable;
+    int tbu_id;
+    int valid;
+};
+
+struct v2d_pending_post_task {
+    struct list_head head;
+    V2D_SUBMIT_TASK_S *pTask;
+    struct dma_fence *pCompleteFence;
+    struct dma_fence *pAcquireFence;
+    struct v2d_dma_buf_info info[4];
+};
+
+void v2d_golbal_reset(void);
+uint32_t v2d_irq_status(void);
+uint32_t v2d_irqerr_status(void);
+void v2d_dump_irqraw_status(void);
+void v2d_irq_clear(uint32_t irqstaus);
+void v2d_irqerr_clear(uint32_t irqerr);
+void v2d_irq_enable(void);
+void v2d_irq_disable(void);
+void config_v2d_hw(V2D_SUBMIT_TASK_S *pTask);
+int v2d_iommu_map_sg(unsigned long iova, struct scatterlist *sg, unsigned int nents, int prot);
+void v2d_iommu_map_end(void);
+void iommu_irq_reset(void);
+#endif
diff --git a/drivers/media/platform/spacemit/v2d/v2d_hw.c b/drivers/media/platform/spacemit/v2d/v2d_hw.c
new file mode 100644
index 000000000000..998146b570e5
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_hw.c
@@ -0,0 +1,911 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* V2D hardware driver for Spacemit
+* Copyright (C) 2023 Spacemit Co., Ltd.
+*
+*/
+
+#include "v2d_priv.h"
+#include "v2d_drv.h"
+#include "v2d_reg.h"
+#include "csc_matrix.h"
+#include <linux/dma-buf.h>
+
+enum {
+	R = 0,
+	G,
+	B,
+	A
+};
+
+static int32_t bicubic_coef[16][3] = {
+	{ 246, 507, 246 },
+	{ 222, 505, 270 },
+	{ 199, 501, 294 },
+	{ 177, 494, 318 },
+	{ 155, 486, 342 },
+	{ 136, 474, 365 },
+	{ 117, 461, 387 },
+	{ 100, 445, 408 },
+	{ 85, 427, 427 },
+	{ 71, 408, 445 },
+	{ 59, 387, 461 },
+	{ 49, 365, 474 },
+	{ 41, 343, 485 },
+	{ 35, 318, 494 },
+	{ 30, 294, 501 },
+	{ 27, 270, 505 }
+};
+
+extern struct v2d_info *v2dInfo;
+
+static void v2d_write(uint32_t reg, uint32_t val)
+{
+	writel(val, v2dInfo->v2dreg_iomem_base+reg);
+}
+
+static uint32_t v2d_read(uint32_t reg)
+{
+	return readl(v2dInfo->v2dreg_iomem_base+reg);
+}
+
+static void v2d_set_bits(uint32_t reg, uint32_t bits)
+{
+	v2d_write(reg, v2d_read(reg) | bits);
+}
+
+#if 0
+static void v2d_clear_bits(uint32_t reg, uint32_t bits)
+{
+	v2d_write(reg, v2d_read(reg) & ~bits);
+}
+#endif
+
+static void v2d_write_bits(uint32_t reg, uint32_t value, uint32_t mask, uint32_t shifts)
+{
+	uint32_t reg_val;
+
+	reg_val = v2d_read(reg);
+	reg_val &= ~(mask << shifts);
+	reg_val |= (value << shifts);
+	v2d_write(reg, reg_val);
+}
+
+void v2d_golbal_reset(void)
+{
+	v2d_set_bits(V2D_AUTO_CLK_REG, V2D_GLOBAL_RESET);
+	while (v2d_read(V2D_AUTO_CLK_REG) & V2D_GLOBAL_RESET);
+	V2DLOGD("v2d golbal reset done!\n");
+}
+
+uint32_t v2d_irq_status(void)
+{
+	return v2d_read(V2D_IRQ_STATUS);
+}
+
+void v2d_dump_irqraw_status(void)
+{
+	uint32_t irqerr_raw, encirq, dec0_irqraw, dec1_irqraw;
+	irqerr_raw  = v2d_read(V2D_ERR_IRQ_RAW);
+	dec0_irqraw = v2d_read(V2D_L0_DEC_REG8);
+	dec1_irqraw = v2d_read(V2D_L1_DEC_REG8);
+	encirq      = v2d_read(V2D_ENC_REG18);
+	printk(KERN_ERR "v2d dump core:0x%x, dec0:0x%x, dec1:0x%x, enc:0x%x\n",  irqerr_raw, dec0_irqraw, dec1_irqraw, encirq);
+}
+
+uint32_t v2d_irqerr_status(void)
+{
+	return v2d_read(V2D_ERR_IRQ_STATUS);
+}
+
+void v2d_irqerr_clear(uint32_t irqerr)
+{
+	v2d_write(V2D_ERR_IRQ_STATUS, irqerr);
+}
+
+void v2d_irq_clear(uint32_t irqstaus)
+{
+	v2d_write(V2D_ENC_REG18, 0x3ffff);
+	v2d_write(V2D_IRQ_STATUS, irqstaus);
+}
+
+void v2d_irq_enable(void)
+{
+	v2d_write(V2D_IRQ_MASK, V2D_EOF_IRQ_MASK|V2D_FBCENC_IRQ_MASK);
+	v2d_write(V2D_ERR_IRQ_MASK, 0xE07);
+	v2d_write_bits(V2D_DEBUG_REG0, 0x1, 0x1, 0);
+}
+
+void v2d_irq_disable(void)
+{
+	v2d_write(V2D_IRQ_MASK, 0x00);
+	v2d_write(V2D_ERR_IRQ_MASK, 0x00);
+}
+
+static void ConfigAxiBus(void)
+{
+	v2d_axi_bus_ctrl_reg_t ctrl;
+
+	ctrl.overlay = 0;
+	ctrl.field.arqos_m = 2;
+	ctrl.field.awqos_m = 2;
+	ctrl.field.shadow_mode = 1;
+	v2d_write(V2D_AXI_BUS_CTRL, ctrl.overlay);
+}
+
+int getBytePerPixel(V2D_COLOR_FORMAT_E enFormat)
+{
+	int Bpp=0;
+
+	switch(enFormat){
+	case V2D_COLOR_FORMAT_NV12:
+	case V2D_COLOR_FORMAT_NV21:
+		Bpp = 1;
+		break;
+	case V2D_COLOR_FORMAT_RGB888:
+	case V2D_COLOR_FORMAT_BGR888:
+		Bpp = 3;
+		break;
+	case V2D_COLOR_FORMAT_RGBX8888:
+	case V2D_COLOR_FORMAT_RGBA8888:
+	case V2D_COLOR_FORMAT_ARGB8888:
+	case V2D_COLOR_FORMAT_BGRX8888:
+	case V2D_COLOR_FORMAT_BGRA8888:
+	case V2D_COLOR_FORMAT_ABGR8888:
+		Bpp = 4;
+		break;
+	case V2D_COLOR_FORMAT_RGB565:
+	case V2D_COLOR_FORMAT_BGR565:
+		Bpp = 2;
+		break;
+	case V2D_COLOR_FORMAT_RGBA5658:
+	case V2D_COLOR_FORMAT_ARGB8565:
+	case V2D_COLOR_FORMAT_BGRA5658:
+	case V2D_COLOR_FORMAT_ABGR8565:
+		Bpp = 3;
+		break;
+	case V2D_COLOR_FORMAT_A8:
+	case V2D_COLOR_FORMAT_Y8:
+		Bpp = 1;
+		break;
+	default:
+		V2DLOGE("err format:%d not supported\n",enFormat);
+	}
+	return Bpp;
+}
+
+static void v2d_scaler_coef_init(void)
+{
+	int i;
+	int32_t *pCoef;
+	v2d_scaler_coef_reg_t scaler_coef;
+
+	scaler_coef.overlay = 0;
+	pCoef = &bicubic_coef[0][0];
+	for (i=0; i<SCALER_COEF_REG_NUM; i++) {
+		scaler_coef.field.scaler_coef0 = *(pCoef + 2*i);
+		scaler_coef.field.scaler_coef1 = *(pCoef + 2*i+1);
+		v2d_write(V2D_SCALER_COEF_REG(i), scaler_coef.overlay);
+	}
+}
+
+static void split_fillcolor(uint32_t fillcolor, V2D_COLOR_FORMAT_E enFormatIn, uint8_t *pChl)
+{
+	uint8_t r, g, b, a;
+
+	switch (enFormatIn) {
+		case V2D_COLOR_FORMAT_NV12:
+			r = fillcolor & 0xFF;
+			g = (fillcolor >> 8) & 0xFF;
+			b = (fillcolor >> 16) & 0xFF;
+			a = 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_NV21:
+			r = fillcolor & 0xFF;
+			b = (fillcolor >> 8) & 0xFF;
+			g = (fillcolor >> 16) & 0xFF;
+			a = 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_RGB888:
+		case V2D_COLOR_FORMAT_RGBX8888:
+			r = fillcolor & 0xFF;
+			g = (fillcolor >> 8) & 0xFF;
+			b = (fillcolor >> 16) & 0xFF;
+			a = 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_RGBA8888:
+			r = fillcolor & 0xFF;
+			g = (fillcolor >> 8) & 0xFF;
+			b = (fillcolor >> 16) & 0xFF;
+			a = (fillcolor >> 24) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_ARGB8888:
+			a = fillcolor & 0xFF;
+			r = (fillcolor >> 8) & 0xFF;
+			g = (fillcolor >> 16) & 0xFF;
+			b = (fillcolor >> 24) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_RGB565:
+			a = 0xFF;
+			r = fillcolor & 0x1F;
+			g = (fillcolor >> 5) & 0x3F;
+			b = (fillcolor >> 11) & 0x1F;
+			break;
+		case V2D_COLOR_FORMAT_RGBA5658:
+			r = fillcolor & 0x1F;
+			g = (fillcolor >> 5) & 0x3F;
+			b = (fillcolor >> 11) & 0x1F;
+			a = (fillcolor >> 16) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_ARGB8565:
+			a = fillcolor & 0xFF;
+			r = (fillcolor >> 8) & 0x1F;
+			g = (fillcolor >> 13) & 0x3F;
+			b = (fillcolor >> 19) & 0x1F;
+			break;
+		case V2D_COLOR_FORMAT_BGR888:
+		case V2D_COLOR_FORMAT_BGRX8888:
+			b = fillcolor & 0xFF;
+			g = (fillcolor >> 8) & 0xFF;
+			r = (fillcolor >> 16) & 0xFF;
+			a = 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_BGRA8888:
+			b = fillcolor & 0xFF;
+			g = (fillcolor >> 8) & 0xFF;
+			r = (fillcolor >> 16) & 0xFF;
+			a = (fillcolor >> 24) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_ABGR8888:
+			a = fillcolor & 0xFF;
+			b = (fillcolor >> 8) & 0xFF;
+			g = (fillcolor >> 16) & 0xFF;
+			r = (fillcolor >> 24) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_BGR565:
+			a = 0xFF;
+			b = fillcolor & 0x1F;
+			g = (fillcolor >> 5) & 0x3F;
+			r = (fillcolor >> 11) & 0x1F;
+			break;
+		case V2D_COLOR_FORMAT_BGRA5658:
+			b = fillcolor & 0x1F;
+			g = (fillcolor >> 5) & 0x3F;
+			r = (fillcolor >> 11) & 0x1F;
+			a = (fillcolor >> 16) & 0xFF;
+			break;
+		case V2D_COLOR_FORMAT_ABGR8565:
+			a = fillcolor & 0xFF;
+			b = (fillcolor >> 8) & 0x1F;
+			g = (fillcolor >> 13) & 0x3F;
+			r = (fillcolor >> 19) & 0x1F;
+			break;
+		default:
+			r = 0xFF;
+			g = 0xFF;
+			b = 0xFF;
+			a = 0xFF;
+			break;
+	}
+	pChl[R] = r;
+	pChl[G] = g;
+	pChl[B] = b;
+	pChl[A] = a;
+}
+
+static bool do_swap(V2D_COLOR_FORMAT_E enFormatIn)
+{
+	switch (enFormatIn) {
+		case V2D_COLOR_FORMAT_BGR888:
+		case V2D_COLOR_FORMAT_BGRX8888:
+		case V2D_COLOR_FORMAT_BGRA8888:
+		case V2D_COLOR_FORMAT_ABGR8888:
+		case V2D_COLOR_FORMAT_BGR565:
+		case V2D_COLOR_FORMAT_BGRA5658:
+		case V2D_COLOR_FORMAT_ABGR8565:
+		case V2D_COLOR_FORMAT_NV21:
+		case V2D_COLOR_FORMAT_L8_BGR565:
+		case V2D_COLOR_FORMAT_L8_BGR888:
+		case V2D_COLOR_FORMAT_L8_BGRA8888:
+			return V2D_TRUE;
+		default:
+			return V2D_FALSE;
+	}
+}
+
+static bool do_narrow(V2D_CSC_MODE_E enForeCSCMode, V2D_CSC_MODE_E enBackCSCMode)
+{
+	int ret = V2D_FALSE;
+
+	switch (enForeCSCMode) {
+		case V2D_CSC_MODE_RGB_2_BT601NARROW:
+		case V2D_CSC_MODE_RGB_2_BT709NARROW:
+		case V2D_CSC_MODE_BT601WIDE_2_BT709NARROW:
+		case V2D_CSC_MODE_BT601WIDE_2_BT601NARROW:
+		case V2D_CSC_MODE_BT601NARROW_2_BT709NARROW:
+		case V2D_CSC_MODE_BT709WIDE_2_BT601NARROW:
+		case V2D_CSC_MODE_BT709WIDE_2_BT709NARROW:
+		case V2D_CSC_MODE_BT709NARROW_2_BT601NARROW:
+			ret = V2D_TRUE;
+			break;
+		default:
+			break;
+	}
+	switch (enBackCSCMode) {
+		case V2D_CSC_MODE_RGB_2_BT601NARROW:
+		case V2D_CSC_MODE_RGB_2_BT709NARROW:
+		case V2D_CSC_MODE_BT601WIDE_2_BT709NARROW:
+		case V2D_CSC_MODE_BT601WIDE_2_BT601NARROW:
+		case V2D_CSC_MODE_BT601NARROW_2_BT709NARROW:
+		case V2D_CSC_MODE_BT709WIDE_2_BT601NARROW:
+		case V2D_CSC_MODE_BT709WIDE_2_BT709NARROW:
+		case V2D_CSC_MODE_BT709NARROW_2_BT601NARROW:
+			ret = V2D_TRUE;
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
+static V2D_COLOR_FORMAT_E fmt_convert(V2D_COLOR_FORMAT_E enFormatIn)
+{
+	V2D_COLOR_FORMAT_E enFormatOut = 0;
+
+	switch (enFormatIn) {
+		case V2D_COLOR_FORMAT_RGB888:
+		case V2D_COLOR_FORMAT_RGBX8888:
+		case V2D_COLOR_FORMAT_RGBA8888:
+		case V2D_COLOR_FORMAT_ARGB8888:
+		case V2D_COLOR_FORMAT_RGB565:
+		case V2D_COLOR_FORMAT_NV12:
+		case V2D_COLOR_FORMAT_RGBA5658:
+		case V2D_COLOR_FORMAT_ARGB8565:
+		case V2D_COLOR_FORMAT_A8:
+		case V2D_COLOR_FORMAT_Y8:
+			enFormatOut = enFormatIn;
+			break;
+		case V2D_COLOR_FORMAT_BGR888:
+		case V2D_COLOR_FORMAT_BGRX8888:
+		case V2D_COLOR_FORMAT_BGRA8888:
+		case V2D_COLOR_FORMAT_ABGR8888:
+		case V2D_COLOR_FORMAT_BGR565:
+		case V2D_COLOR_FORMAT_NV21:
+		case V2D_COLOR_FORMAT_BGRA5658:
+		case V2D_COLOR_FORMAT_ABGR8565:
+			enFormatOut = enFormatIn - V2D_COLOR_FORMAT_BGR888;
+			break;
+		case V2D_COLOR_FORMAT_L8_RGBA8888:
+		case V2D_COLOR_FORMAT_L8_RGB888:
+		case V2D_COLOR_FORMAT_L8_RGB565:
+		case V2D_COLOR_FORMAT_L8_BGRA8888:
+		case V2D_COLOR_FORMAT_L8_BGR888:
+		case V2D_COLOR_FORMAT_L8_BGR565:
+			enFormatOut = V2D_COLOR_FORMAT_L8_RGBA8888;
+			break;
+		default:
+			break;
+	}
+	return enFormatOut;
+}
+
+static int Get_L8_Palette_bytePerPixel(V2D_SURFACE_S *pstBackGround, V2D_SURFACE_S *pstForeGround)
+{
+	int bpp = 4;
+
+	if (pstBackGround) {
+		if (pstBackGround->format == V2D_COLOR_FORMAT_L8_RGBA8888 || pstBackGround->format == V2D_COLOR_FORMAT_L8_BGRA8888) {
+			bpp = 4;
+		}
+		else if (pstBackGround->format == V2D_COLOR_FORMAT_L8_RGB888 || pstBackGround->format == V2D_COLOR_FORMAT_L8_BGR888) {
+			bpp = 3;
+		}
+		else if (pstBackGround->format == V2D_COLOR_FORMAT_L8_RGB565 || pstBackGround->format == V2D_COLOR_FORMAT_L8_BGR565) {
+			bpp = 2;
+		}
+	}
+	if (pstForeGround) {
+		if (pstForeGround->format == V2D_COLOR_FORMAT_L8_RGBA8888 || pstForeGround->format == V2D_COLOR_FORMAT_L8_BGRA8888) {
+			bpp = 4;
+		}
+		else if (pstForeGround->format == V2D_COLOR_FORMAT_L8_RGB888 || pstForeGround->format == V2D_COLOR_FORMAT_L8_BGR888) {
+			bpp = 3;
+		}
+		else if (pstForeGround->format == V2D_COLOR_FORMAT_L8_RGB565 || pstForeGround->format == V2D_COLOR_FORMAT_L8_BGR565) {
+			bpp = 2;
+		}
+	}
+	return bpp;
+}
+
+static void ConfigV2dFbcDecoder(V2D_SURFACE_S *pstV2DSurface, V2D_INPUT_LAYER_E enInputLayer)
+{
+	v2d_fbc_decoder_bbox_reg_t bbox_x, bbox_y;
+	v2d_fbc_decoder_imgae_size_reg_t img_size;
+	v2d_fbc_decoder_mode_reg_t dec_mode;
+	v2d_fbc_decoder_dma_ctrl_reg_t dmac;
+	v2d_fbc_decoder_irq_ctrl_reg_t irqmask;
+	FBC_DECODER_S *pDecInfo = &pstV2DSurface->fbcDecInfo;
+
+	V2DLOGD("config %s fbc decoder \n", (enInputLayer > 0 ? "layer1" : "layer0"));
+	bbox_x.field.bbox_start = pDecInfo->bboxLeft;
+	bbox_x.field.bbox_end   = pDecInfo->bboxRight;
+	bbox_y.field.bbox_start = pDecInfo->bboxTop;
+	bbox_y.field.bbox_end   = pDecInfo->bboxBottom;
+	img_size.field.width    = pstV2DSurface->w;
+	img_size.field.height   = pstV2DSurface->h;
+	dec_mode.field.mode	    = pDecInfo->enFbcdecMode;
+	dec_mode.field.format   = pDecInfo->enFbcdecFmt;
+	dec_mode.field.is_split = pDecInfo->is_split;
+	dec_mode.field.rgb_pack_en = pDecInfo->rgb_pack_en;
+	dmac.overlay = 0xffff1a02;
+	irqmask.overlay = 0x00000017;
+
+	v2d_write(V2D_LAYER_DEC_REG0_L(enInputLayer), pDecInfo->headerAddr_l);
+	v2d_write(V2D_LAYER_DEC_REG1_L(enInputLayer), pDecInfo->headerAddr_h);
+	v2d_write(V2D_LAYER_DEC_REG2_L(enInputLayer), bbox_x.overlay);
+	v2d_write(V2D_LAYER_DEC_REG3_L(enInputLayer), bbox_y.overlay);
+	v2d_write(V2D_LAYER_DEC_REG4_L(enInputLayer), img_size.overlay);
+	v2d_write(V2D_LAYER_DEC_REG5_L(enInputLayer), dec_mode.overlay);
+	v2d_write(V2D_LAYER_DEC_REG6_L(enInputLayer), dmac.overlay);
+	v2d_write(V2D_LAYER_DEC_REG7_L(enInputLayer), irqmask.overlay);
+}
+
+static void ConfigV2dFbcEncoder(V2D_SURFACE_S *pstV2DSurface)
+{
+	v2d_fbc_encoder_bbox_reg_t bbox_x, bbox_y;
+	v2d_fbc_encoder_buf_size_reg_t y_buf_size, uv_buf_size;
+	v2d_fbc_encoder_irq_reg_t irqmask;
+	v2d_fbc_encoder_mode_reg_t enc_mode;
+	v2d_fbc_encoder_dmac_burst_reg_t dmac_burst;
+	FBC_ENCODER_S *pEncInfo = &pstV2DSurface->fbcEncInfo;
+
+	V2DLOGD("config fbc encoder \n");
+	bbox_x.field.bbox_start = pEncInfo->bboxLeft;
+	bbox_x.field.bbox_end   = pEncInfo->bboxRight;
+	bbox_y.field.bbox_start = pEncInfo->bboxTop;
+	bbox_y.field.bbox_end   = pEncInfo->bboxBottom;
+	y_buf_size.field.x_size = pstV2DSurface->w;
+	y_buf_size.field.y_size = pstV2DSurface->h;
+	uv_buf_size.field.x_size = pstV2DSurface->w >> 1;
+	uv_buf_size.field.y_size = pstV2DSurface->w >> 1;
+	irqmask.overlay = 0x0001ffff;
+	enc_mode.field.encode_enable = 1;
+	enc_mode.field.split_mode_en = pEncInfo->is_split;
+	enc_mode.field.img_pix_format = pEncInfo->enFbcencFmt;
+	dmac_burst.field.burst_length = 0x10;
+
+	v2d_write(V2D_ENC_REG0, pEncInfo->headerAddr_l);
+	v2d_write(V2D_ENC_REG1, pEncInfo->headerAddr_h);
+	v2d_write(V2D_ENC_REG2, pEncInfo->payloadAddr_l);
+	v2d_write(V2D_ENC_REG3, pEncInfo->payloadAddr_h);
+	v2d_write(V2D_ENC_REG4, bbox_x.overlay);
+	v2d_write(V2D_ENC_REG5, bbox_y.overlay);
+	v2d_write(V2D_ENC_REG10, y_buf_size.overlay);
+	v2d_write(V2D_ENC_REG11, uv_buf_size.overlay);
+	v2d_write(V2D_ENC_REG13, irqmask.overlay);
+	v2d_write(V2D_ENC_REG15, 0x9e00ffff);
+	v2d_write(V2D_ENC_REG16, enc_mode.overlay);
+	v2d_write(V2D_ENC_REG17, dmac_burst.overlay);
+}
+
+static void ConfigV2dInputLayer(V2D_SURFACE_S *pstV2DSurface,
+								V2D_AREA_S *pstV2DArea,
+								V2D_BLEND_CONF_S *pstBlendConf,
+								V2D_ROTATE_ANGLE_E enRotateAngle,
+								V2D_CSC_MODE_E enCSCMode,
+								V2D_INPUT_LAYER_E enInputLayer)
+{
+	int *pCscMatrix, i;
+	V2D_SCALER_MODE_E enScaleMode = V2D_NO_SCALE;
+	uint32_t width = 0, height = 0, tmp;
+	V2D_FILLCOLOR_S *pFillColor; uint8_t chl[4];
+	V2D_BLEND_LAYER_CONF_S *pBlendLayerConf;
+	v2d_blend_layer_ctrl0_reg_t bld_layer_ctrl0;
+	v2d_blend_layer_ctrl1_reg_t bld_layer_ctrl1;
+	v2d_blend_layer_ctrl2_reg_t bld_layer_ctrl2;
+	v2d_blend_layer_ctrl3_reg_t bld_layer_ctrl3;
+	v2d_blend_layer_factor_reg_t bld_layer_factor;
+	v2d_solid_color_ctrl0_reg_t solidcolor_ctrl0;
+	v2d_solid_color_ctrl1_reg_t solidcolor_ctrl1;
+	v2d_input_layer_width_height_reg_t layer_in_ori_w_h;
+	v2d_input_layer_ctrl_reg_t layer_in_ctrl;
+	v2d_input_layer_crop0_reg_t layer_in_crop0;
+	v2d_input_layer_crop1_reg_t layer_in_crop1;
+	v2d_input_layer_csc_ctrl0_reg_t layer_in_csc_ctrl0;
+	v2d_input_layer_csc_ctrl1_reg_t layer_in_csc_ctrl1;
+	v2d_input_layer_csc_ctrl2_reg_t layer_in_csc_ctrl2;
+	v2d_input_layer_scale_mode_reg_t layer_scale_mode;
+	v2d_input_layer_scale_delta_x_reg_t layer_scale_delta_x;
+	v2d_input_layer_scale_delta_y_reg_t layer_scale_delta_y;
+
+	bld_layer_ctrl1.overlay = 0;
+	bld_layer_ctrl3.overlay = 0;
+	bld_layer_factor.overlay = 0;
+	solidcolor_ctrl0.overlay = 0;
+	solidcolor_ctrl1.overlay = 0;
+	layer_in_ctrl.overlay = 0;
+	layer_in_csc_ctrl0.overlay = 0;
+	layer_in_csc_ctrl1.overlay = 0;
+	layer_in_csc_ctrl2.overlay = 0;
+	layer_scale_mode.overlay = 0;
+	layer_scale_delta_x.overlay = 0;
+	layer_scale_delta_y.overlay = 0;
+
+	if ((!pstV2DSurface->solidcolor.enable) && (pstV2DSurface->phyaddr_y_l == 0) && (!pstV2DSurface->fbc_enable)) {
+			V2DLOGD("%s disable\n", (enInputLayer > 0 ? "layer1" : "layer0"));
+			bld_layer_ctrl1.field.blend_en = V2D_FUNC_DISABLE;
+			v2d_write(V2D_LAYER_BLD_CTRL1_LAYER(enInputLayer), bld_layer_ctrl1.overlay);
+	} else {
+		V2DLOGD("config %s\n", (enInputLayer > 0 ? "layer1" : "layer0"));
+		V2DLOGD("rot:%d,csc:%d\n", enRotateAngle, enCSCMode);
+		//blendlayer
+		pBlendLayerConf = &pstBlendConf->blendlayer[enInputLayer];
+		bld_layer_ctrl0.field.bld_alpha_source = pBlendLayerConf->blend_alpha_source;
+		bld_layer_ctrl0.field.bld_pre_alp_func = pBlendLayerConf->blend_pre_alpha_func;
+		bld_layer_ctrl0.field.bld_glb_alp = pBlendLayerConf->global_alpha;
+		bld_layer_ctrl0.field.scl_delta_y = 0;
+		bld_layer_ctrl1.field.blend_en = V2D_FUNC_ENABLE;
+		bld_layer_ctrl1.field.bld_rect_ltop_x = pBlendLayerConf->blend_area.x;
+		bld_layer_ctrl2.field.bld_rect_ltop_y = pBlendLayerConf->blend_area.y;
+		bld_layer_ctrl2.field.bld_rect_width = pBlendLayerConf->blend_area.w;
+		bld_layer_ctrl3.field.bld_rect_height = pBlendLayerConf->blend_area.h;
+		V2DLOGD("bld alpha_src:%d,pre_func:%d,glb_alpha:%d\n", pBlendLayerConf->blend_alpha_source, pBlendLayerConf->blend_pre_alpha_func, pBlendLayerConf->global_alpha);
+		V2DLOGD("bld_rect:(%d,%d,%d,%d)\n", pBlendLayerConf->blend_area.x, pBlendLayerConf->blend_area.y, pBlendLayerConf->blend_area.w, pBlendLayerConf->blend_area.h);
+		v2d_write(V2D_LAYER_BLD_CTRL0_LAYER(enInputLayer), bld_layer_ctrl0.overlay);
+		v2d_write(V2D_LAYER_BLD_CTRL1_LAYER(enInputLayer), bld_layer_ctrl1.overlay);
+		v2d_write(V2D_LAYER_BLD_CTRL2_LAYER(enInputLayer), bld_layer_ctrl2.overlay);
+		v2d_write(V2D_LAYER_BLD_CTRL3_LAYER(enInputLayer), bld_layer_ctrl3.overlay);
+
+		if (pstBlendConf->blend_cmd) {
+			bld_layer_factor.field.bld_color_rop2_code = pBlendLayerConf->stRop2Code.colorRop2Code;
+			bld_layer_factor.field.bld_alpha_rop2_code = pBlendLayerConf->stRop2Code.alphaRop2Code;
+		}
+		else {
+			bld_layer_factor.field.bld_src_color_factor = pBlendLayerConf->stBlendFactor.srcColorFactor;
+			bld_layer_factor.field.bld_src_alpha_factor = pBlendLayerConf->stBlendFactor.srcAlphaFactor;
+			bld_layer_factor.field.bld_dst_color_factor = pBlendLayerConf->stBlendFactor.dstColorFactor;
+			bld_layer_factor.field.bld_dst_alpha_factor = pBlendLayerConf->stBlendFactor.dstAlphaFactor;
+		}
+		V2DLOGD("bld factor:src_c=%d,src_a=%d,dst_c=%d,dst_a=%d\n", pBlendLayerConf->stBlendFactor.srcColorFactor, pBlendLayerConf->stBlendFactor.srcAlphaFactor,
+				pBlendLayerConf->stBlendFactor.dstColorFactor, pBlendLayerConf->stBlendFactor.dstAlphaFactor);
+		v2d_write(V2D_LAYER_BLD_FACTOR_LAYER(enInputLayer), bld_layer_factor.overlay);
+
+		if (pstV2DSurface->solidcolor.enable) {//solid color
+			pFillColor = &pstV2DSurface->solidcolor.fillcolor;
+			split_fillcolor(pFillColor->colorvalue, pFillColor->format, chl);
+			solidcolor_ctrl0.field.solid_en = V2D_FUNC_ENABLE;
+			solidcolor_ctrl0.field.solid_R = chl[R];
+			solidcolor_ctrl0.field.solid_G = chl[G];
+			solidcolor_ctrl0.field.solid_B = chl[B];
+			solidcolor_ctrl1.field.solid_A = chl[A];
+			solidcolor_ctrl1.field.csc_en = V2D_FUNC_DISABLE;
+			v2d_write(V2D_LAYER_SOLIDCOLOR_CTRL0_LAYER(enInputLayer), solidcolor_ctrl0.overlay);
+			v2d_write(V2D_LAYER_SOLIDCOLOR_CTRL1_LAYER(enInputLayer), solidcolor_ctrl1.overlay);
+		}
+		else {  //input layer
+			solidcolor_ctrl0.field.solid_en = V2D_FUNC_DISABLE;
+			v2d_write(V2D_LAYER_SOLIDCOLOR_CTRL0_LAYER(enInputLayer), solidcolor_ctrl0.overlay);
+			if (pstV2DSurface->fbc_enable) {
+				ConfigV2dFbcDecoder(pstV2DSurface, enInputLayer);
+			} else {
+				v2d_write(V2D_LAYER_Y_ADDR_L_LAYER(enInputLayer),  pstV2DSurface->phyaddr_y_l);
+				v2d_write(V2D_LAYER_Y_ADDR_H_LAYER(enInputLayer),  pstV2DSurface->phyaddr_y_h);
+				v2d_write(V2D_LAYER_UV_ADDR_L_LAYER(enInputLayer), pstV2DSurface->phyaddr_uv_l);
+				tmp = v2d_read(V2D_LAYER_UV_ADDR_H_LAYER(enInputLayer)) | (pstV2DSurface->phyaddr_uv_h & V2D_H_ADDR_MASK);
+				v2d_write(V2D_LAYER_UV_ADDR_H_LAYER(enInputLayer), tmp);
+			}
+			layer_in_ori_w_h.field.layer_in_ori_width = pstV2DSurface->w;
+			layer_in_ori_w_h.field.layer_in_ori_height = pstV2DSurface->h;
+			v2d_write(V2D_LAYER_WIDTH_HEIGHT_LAYER(enInputLayer), layer_in_ori_w_h.overlay);
+
+			layer_in_ctrl.field.stride = pstV2DSurface->stride;
+			layer_in_ctrl.field.swap = do_swap(pstV2DSurface->format);
+			layer_in_ctrl.field.format = fmt_convert(pstV2DSurface->format);
+			layer_in_ctrl.field.rotation = enRotateAngle;
+			layer_in_ctrl.field.fbc_en = pstV2DSurface->fbc_enable;
+			v2d_write(V2D_LAYER_CTRL_LAYER(enInputLayer), layer_in_ctrl.overlay);
+			//crop
+			layer_in_crop0.field.layer_in_crop_ltop_x = pstV2DArea->x;
+			layer_in_crop0.field.layer_in_crop_ltop_y = pstV2DArea->y;
+			layer_in_crop1.field.layer_in_crop_width = pstV2DArea->w;
+			layer_in_crop1.field.layer_in_crop_height = pstV2DArea->h;
+			V2DLOGD("crop:(%d,%d,%d,%d)\n", pstV2DArea->x, pstV2DArea->y, pstV2DArea->w, pstV2DArea->h);
+			v2d_write(V2D_LAYER_CROP_REG0_LAYER(enInputLayer), layer_in_crop0.overlay);
+			v2d_write(V2D_LAYER_CROP_REG1_LAYER(enInputLayer), layer_in_crop1.overlay);
+			//csc
+			if (enCSCMode < V2D_CSC_MODE_BUTT) {
+				layer_in_csc_ctrl0.field.csc_en = V2D_FUNC_ENABLE;
+				pCscMatrix = &cscmatrix[enCSCMode][0][0];
+				layer_in_csc_ctrl0.field.csc_matrix0 = pCscMatrix[0];
+				for (i = 0; i < 5; i++) {
+					layer_in_csc_ctrl1.field.csc_matrix1 = pCscMatrix[2 * i + 1];
+					layer_in_csc_ctrl1.field.csc_matrix2 = pCscMatrix[2 * i + 2];
+					v2d_write(V2D_LAYER_CSC_CRTL1_LAYER(enInputLayer) + 0x4 * i, layer_in_csc_ctrl1.overlay);
+				}
+				layer_in_csc_ctrl2.field.csc_matrix11 = pCscMatrix[11];
+				v2d_write(V2D_LAYER_CSC_CRTL6_LAYER(enInputLayer), layer_in_csc_ctrl2.overlay);
+			}
+			else {
+				layer_in_csc_ctrl0.field.csc_en = V2D_FUNC_DISABLE;
+			}
+			v2d_write(V2D_LAYER_CSC_CRTL0_LAYER(enInputLayer), layer_in_csc_ctrl0.overlay);
+			//scale
+			if (enRotateAngle == V2D_ROT_90 || enRotateAngle == V2D_ROT_270) {
+				width = pstV2DArea->h; height = pstV2DArea->w;
+			}
+			else {
+				width = pstV2DArea->w; height = pstV2DArea->h;
+			}
+			if (width == pBlendLayerConf->blend_area.w && height == pBlendLayerConf->blend_area.h) {
+				enScaleMode = V2D_NO_SCALE;
+			}
+			else if (width > pBlendLayerConf->blend_area.w || height > pBlendLayerConf->blend_area.h) {
+				enScaleMode = V2D_SCALE_DOWN;
+			}
+			else if (width < pBlendLayerConf->blend_area.w || height < pBlendLayerConf->blend_area.h) {
+				enScaleMode = V2D_SCALE_UP;
+			}
+			V2DLOGD("scale:%d\n", enScaleMode);
+			layer_scale_mode.overlay = layer_in_csc_ctrl2.overlay;
+			layer_scale_mode.field.scl_mode = enScaleMode;
+			v2d_write(V2D_LAYER_SCALE_MODE_LAYER(enInputLayer), layer_scale_mode.overlay);
+			if (enScaleMode) {
+				layer_scale_delta_x.field.scl_delta_x = (width << 16) / pBlendLayerConf->blend_area.w;
+				layer_scale_delta_y.overlay = bld_layer_ctrl0.overlay;
+				layer_scale_delta_y.field.scl_delta_y = (height << 16) / pBlendLayerConf->blend_area.h;
+				v2d_write(V2D_LAYER_SCALE_DELTA_X_LAYER(enInputLayer), layer_scale_delta_x.overlay);
+				v2d_write(V2D_LAYER_SCALE_DELTA_Y_LAYER(enInputLayer), layer_scale_delta_y.overlay);
+			}
+			else {
+				layer_scale_delta_x.field.scl_delta_x = (1 << 16);
+				layer_scale_delta_y.overlay = bld_layer_ctrl0.overlay;
+				layer_scale_delta_y.field.scl_delta_y = (1 << 16);
+				v2d_write(V2D_LAYER_SCALE_DELTA_X_LAYER(enInputLayer), layer_scale_delta_x.overlay);
+				v2d_write(V2D_LAYER_SCALE_DELTA_Y_LAYER(enInputLayer), layer_scale_delta_y.overlay);
+			}
+		}
+	}
+}
+
+static void ConfigV2dMaskLayer(V2D_SURFACE_S *pstMask, V2D_AREA_S *pstMaskRect, V2D_BLEND_CONF_S *pstBlendConf)
+{
+	v2d_mask_width_reg_t mask_in_width;
+	v2d_mask_height_reg_t mask_in_height;
+	v2d_mask_crop0_reg_t mask_in_crop0;
+	v2d_mask_crop1_reg_t mask_in_crop1;
+	v2d_blend_mask_ctrl0_reg_t bld_mask_ctrl0;
+	v2d_blend_mask_ctrl1_reg_t bld_mask_ctrl1;
+	v2d_blend_mask_ctrl2_reg_t bld_mask_ctrl2;
+
+	bld_mask_ctrl0.overlay = 0;
+	mask_in_width.overlay = 0;
+	bld_mask_ctrl2.overlay = 0;
+
+	if (pstMask->phyaddr_y_l != 0) {
+		V2DLOGD("ConfigV2dMaskLayer\n");
+		mask_in_width.field.mask_addr_33_32 = (pstMask->phyaddr_y_h & V2D_H_ADDR_MASK);
+		mask_in_width.field.mask_ori_width = pstMask->w;
+		mask_in_height.field.mask_ori_height = pstMask->h;
+		mask_in_height.field.mask_ori_stride = pstMask->stride;
+		mask_in_crop0.field.mask_crop_ltop_x = pstMaskRect->x;
+		mask_in_crop0.field.mask_crop_ltop_y = pstMaskRect->y;
+		mask_in_crop1.field.mask_crop_width = pstMaskRect->w;
+		mask_in_crop1.field.mask_crop_height = pstMaskRect->h;
+		bld_mask_ctrl0.field.bld_mask_enable = pstBlendConf->mask_cmd;
+		bld_mask_ctrl0.field.bld_mask_rect_ltop_x = pstBlendConf->blend_mask_area.x;
+		bld_mask_ctrl1.field.bld_mask_rect_ltop_y = pstBlendConf->blend_mask_area.y;
+		bld_mask_ctrl1.field.bld_mask_rect_width = pstBlendConf->blend_mask_area.w;
+		bld_mask_ctrl2.field.bld_mask_rect_height = pstBlendConf->blend_mask_area.h;
+		v2d_write(V2D_MASK_ADDR_L, pstMask->phyaddr_y_l);
+		v2d_write(V2D_MASK_WIDTH,  mask_in_width.overlay);
+		v2d_write(V2D_MASK_HEIGHT, mask_in_height.overlay);
+		v2d_write(V2D_MASK_CROP_REG0, mask_in_crop0.overlay);
+		v2d_write(V2D_MASK_CROP_REG1, mask_in_crop1.overlay);
+		v2d_write(V2D_BLD_MASK_REG0,  bld_mask_ctrl0.overlay);
+		v2d_write(V2D_BLD_MASK_REG1,  bld_mask_ctrl1.overlay);
+		v2d_write(V2D_BLD_MASK_REG2,  bld_mask_ctrl2.overlay);
+	}
+	else {
+		V2DLOGD("mask layer disable\n");
+		bld_mask_ctrl0.field.bld_mask_enable = V2D_FUNC_DISABLE;
+		v2d_write(V2D_BLD_MASK_REG0,  bld_mask_ctrl0.overlay);
+	}
+}
+
+static void ConfigPaletteTable(V2D_SURFACE_S *pstBackGround, V2D_SURFACE_S *pstForeGround, V2D_PALETTE_S *pstPalette)
+{
+	int i, bpp;
+	uint32_t val;
+	uint8_t *pTmp, r, g, b, a;
+
+	if (pstPalette->len != 0) {
+		V2DLOGD("ConfigPaletteTable\n");
+		pTmp = pstPalette->palVal;
+		bpp = Get_L8_Palette_bytePerPixel(pstBackGround, pstForeGround);
+		V2DLOGD("bpp:%d, palette len:%d\n", bpp, pstPalette->len);
+		for (i = 0; i < (pstPalette->len / bpp); i++) {
+			if (bpp == 4) {
+				r = *(pTmp + 4 * i);  g = *(pTmp + 4 * i + 1);
+				b = *(pTmp + 4 * i + 2); a = *(pTmp + 4 * i + 3);
+			}
+			else if (bpp == 3) {
+				r = *(pTmp + 3 * i);   g = *(pTmp + 3 * i + 1);
+				b = *(pTmp + 3 * i + 2); a = 0xFF;
+			}
+			else if (bpp == 2) {
+				r = *(pTmp + 2 * i) & 0x1F;
+				g = ((*(pTmp + 2 * i) >> 5) & 0x7) | ((*(pTmp + 2 * i + 1) & 0x7) << 3);
+				b = (*(pTmp + 2 * i + 1) >> 3) & 0x1F;
+				a = 0xFF;
+			}
+			val = r | (g << 8) | (b << 16) | (a << 24);
+			v2d_write(V2D_PALETTE_TABLE(i), val);
+		}
+	}
+}
+
+static void ConfigV2dBlendMode_And_BgColor(V2D_BLEND_CONF_S *pstBlendConf)
+{
+	V2D_FILLCOLOR_S *pFillColor;
+	uint8_t chl[4];
+	v2d_blend_ctrl0_reg_t blend_ctrl0;
+	v2d_blend_ctrl1_reg_t blend_ctrl1;
+
+	V2DLOGD("ConfigV2dBlendMode_And_BgColor\n");
+	blend_ctrl0.overlay = 0;
+	blend_ctrl1.overlay = 0;
+	blend_ctrl0.field.bld_mode = pstBlendConf->blend_cmd;
+	blend_ctrl0.field.bld_bg_enable = pstBlendConf->bgcolor.enable;
+	pFillColor = &pstBlendConf->bgcolor.fillcolor;
+	split_fillcolor(pFillColor->colorvalue, V2D_COLOR_FORMAT_RGBA8888, chl);
+	V2DLOGD("bgcolor_en:%d,r:%d,g:%d,b:%d,alpha:%d\n",  pstBlendConf->bgcolor.enable, chl[R], chl[G], chl[B], chl[A]);
+	blend_ctrl0.field.bld_bg_r = chl[R];
+	blend_ctrl0.field.bld_bg_g = chl[G];
+	blend_ctrl0.field.bld_bg_b = chl[B];
+	blend_ctrl1.field.bld_bg_a = chl[A];
+	v2d_write(V2D_BLEND_REG0, blend_ctrl0.overlay);
+	v2d_write(V2D_BLEND_REG1, blend_ctrl1.overlay);
+}
+
+static void ConfigV2dOutput(V2D_SURFACE_S *pstDst,
+							V2D_AREA_S *pstDstRect,
+							V2D_CSC_MODE_E enForeCSCMode,
+							V2D_CSC_MODE_E enBackCSCMode,
+							V2D_DITHER_E dither)
+{
+	v2d_output_width_reg_t output_width;
+	v2d_output_height_reg_t output_height;
+	v2d_output_ctrl0_reg_t output_ctrl0;
+	v2d_output_ctrl1_reg_t output_ctrl1;
+	v2d_output_ctrl2_reg_t output_ctrl2;
+
+	V2DLOGD("config output\n");
+	output_width.overlay = 0;
+	output_ctrl0.overlay = 0;
+	output_ctrl2.overlay = 0;
+	output_width.field.out_ori_width = pstDst->w;
+	output_width.field.out_addr_uv_33_32 = (pstDst->phyaddr_uv_h & V2D_H_ADDR_MASK);
+	output_height.field.out_ori_height = pstDst->h;
+	output_height.field.out_ori_stride = pstDst->stride;
+	output_ctrl0.field.format = fmt_convert(pstDst->format);
+	output_ctrl0.field.range = do_narrow(enForeCSCMode, enBackCSCMode);
+	output_ctrl0.field.dither = dither;
+	output_ctrl0.field.swap = do_swap(pstDst->format);
+	output_ctrl0.field.fbc_en = pstDst->fbc_enable;
+	output_ctrl0.field.crop_ltop_x = pstDstRect->x;
+	output_ctrl1.field.crop_ltop_y = pstDstRect->y;
+	output_ctrl1.field.crop_width = pstDstRect->w;
+	output_ctrl2.field.crop_height = pstDstRect->h;
+	V2DLOGD("dst:w=%d,h=%d\n", pstDst->w, pstDst->h);
+	V2DLOGD("crop=(%d,%d,%d,%d)\n", pstDstRect->x, pstDstRect->y, pstDstRect->w, pstDstRect->h);
+	V2DLOGD("dst:fmt=%d, dither:%d,narrow=%d, swap=%d, stride=%d\n",
+			output_ctrl0.field.format, output_ctrl0.field.dither, output_ctrl0.field.range, output_ctrl0.field.swap, pstDst->stride);
+
+	v2d_write(V2D_OUTPUT_WIDTH,  output_width.overlay);
+	v2d_write(V2D_OUTPUT_HEIGHT, output_height.overlay);
+	v2d_write(V2D_OUTPUT_CRTL0,  output_ctrl0.overlay);
+	v2d_write(V2D_OUTPUT_CRTL1,  output_ctrl1.overlay);
+	v2d_write(V2D_OUTPUT_CRTL2,  output_ctrl2.overlay);
+	if (pstDst->fbc_enable) {
+		ConfigV2dFbcEncoder(pstDst);
+	} else {
+		v2d_write(V2D_OUTPUT_Y_ADDR_L, pstDst->phyaddr_y_l);
+		v2d_write(V2D_OUTPUT_Y_ADDR_H, pstDst->phyaddr_y_h);
+		v2d_write(V2D_OUTPUT_UV_ADDR_L, pstDst->phyaddr_uv_l);
+	}
+}
+
+static void ConfigV2dDmac(void)
+{
+	v2d_dma_ctrl_reg_t dma_ctrl;
+
+	dma_ctrl.overlay = 0;
+	dma_ctrl.field.dmac_arb_mode = 2;
+	dma_ctrl.field.dmac_max_req_num = 7;
+	dma_ctrl.field.dmac_postwr_en = 255;
+	dma_ctrl.field.dmac_rst_n_pwr = 1;
+	dma_ctrl.field.dmac_arqos = 2;
+	dma_ctrl.field.dmac_awqos = 2;
+	v2d_write(V2D_DMA_CTRL, dma_ctrl.overlay);
+}
+
+static void TriggerV2dRun(V2D_PARAM_S *pParam)
+{
+	v2d_ctrl_reg_t ctrl;
+	v2d_fbc_decoder_trigger_reg_t decTrigger;
+	v2d_fbc_encoder_trigger_reg_t encTrigger;
+
+	if (pParam->layer0.fbc_enable) {
+		decTrigger.overlay = 0;
+		decTrigger.field.direct_swap = 1;
+		v2d_write(V2D_L0_DEC_REG10, decTrigger.overlay);
+	}
+	if (pParam->layer1.fbc_enable) {
+		decTrigger.overlay = 0;
+		decTrigger.field.direct_swap = 1;
+		v2d_write(V2D_L1_DEC_REG10, decTrigger.overlay);
+	}
+	if (pParam->dst.fbc_enable) {
+		encTrigger.overlay = 0;
+		encTrigger.field.direct_swap = 1;
+		v2d_write(V2D_ENC_REG12, encTrigger.overlay);
+	}
+	ctrl.overlay = 0;
+	ctrl.field.rdma_burst_len = 4;
+	ctrl.field.wdma_burst_len = 16;
+	ctrl.field.trigger        = 1;
+	v2d_write(V2D_CTRL_REG, ctrl.overlay);
+}
+
+void config_v2d_hw(V2D_SUBMIT_TASK_S *pTask)
+{
+	V2D_SURFACE_S *pstBackGround, *pstForeGround, *pstMask, *pstDst;
+	V2D_AREA_S *pstBackGroundRect, *pstForeGroundRect, *pstMaskRect, *pstDstRect;
+	V2D_BLEND_CONF_S *pstBlendConf;
+	V2D_ROTATE_ANGLE_E enForeRoate, enBackRotate;
+	V2D_CSC_MODE_E enForeCscMode, enBackCscMode;
+	V2D_PALETTE_S *pstPalette;
+	V2D_DITHER_E enDither;
+	V2D_PARAM_S *pV2dParam;
+
+	pV2dParam = &pTask->param;
+	pstBackGround = &pV2dParam->layer0;
+	pstBackGroundRect = &pV2dParam->l0_rect;
+	pstForeGround = &pV2dParam->layer1;
+	pstForeGroundRect = &pV2dParam->l1_rect;
+	pstMask = &pV2dParam->mask;
+	pstMaskRect = &pV2dParam->mask_rect;
+	pstDst = &pV2dParam->dst;
+	pstDstRect = &pV2dParam->dst_rect;
+	pstBlendConf = &pV2dParam->blendconf;
+	enBackRotate = pV2dParam->l0_rt;
+	enForeRoate = pV2dParam->l1_rt;
+	enBackCscMode = pV2dParam->l0_csc;
+	enForeCscMode = pV2dParam->l1_csc;
+	enDither = pV2dParam->dither;
+	pstPalette = &pV2dParam->palette;
+
+	//init scaler coef
+	v2d_scaler_coef_init();
+	//config layer0
+	ConfigV2dInputLayer(pstBackGround, pstBackGroundRect, pstBlendConf, enBackRotate, enBackCscMode, V2D_INPUT_LAYER0);
+	//config layer1
+	ConfigV2dInputLayer(pstForeGround, pstForeGroundRect, pstBlendConf, enForeRoate, enForeCscMode, V2D_INPUT_LAYER1);
+	//set palette
+	ConfigPaletteTable(pstBackGround, pstForeGround, pstPalette);
+	//config mask
+	ConfigV2dMaskLayer(pstMask, pstMaskRect, pstBlendConf);
+	//blend
+	ConfigV2dBlendMode_And_BgColor(pstBlendConf);
+	//output
+	ConfigV2dOutput(pstDst, pstDstRect, enForeCscMode, enBackCscMode, enDither);
+	//DMA control
+	ConfigV2dDmac();
+	//set v2d qos
+	ConfigAxiBus();
+	//trigger
+	TriggerV2dRun(pV2dParam);
+	V2DLOGD("v2d config done\n");
+}
+
diff --git a/drivers/media/platform/spacemit/v2d/v2d_iommu.c b/drivers/media/platform/spacemit/v2d/v2d_iommu.c
new file mode 100644
index 000000000000..60d2ba66901e
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_iommu.c
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* V2D mmu driver for Spacemit
+* Copyright (C) 2023 Spacemit Co., Ltd.
+*
+*/
+#include "v2d_priv.h"
+#include "v2d_reg.h"
+
+struct v2d_iommu_res sV2dIommuRes;
+
+static u32 __read_reg(struct v2d_iommu_res *res, u64 offset)
+{
+	return readl(res->base + offset + V2D_IOMMU_BASE_OFFSET);
+}
+
+static inline void __write_reg(struct v2d_iommu_res *res, u64 offset, u32 data)
+{
+	writel(data, res->base + offset + V2D_IOMMU_BASE_OFFSET);
+}
+
+static void __set_reg_bits(struct v2d_iommu_res *res, u64 offset, u32 bits)
+{
+	__write_reg(res, offset, (__read_reg(res, offset) | bits));
+}
+
+static void __clear_reg_bits(struct v2d_iommu_res *res, u64 offset, u32 bits)
+{
+	__write_reg(res, offset, (__read_reg(res, offset) & ~bits));
+}
+
+static int __enable_spacemit_iommu_hw(struct v2d_iommu_res *res)
+{
+	int i;
+	struct tbu_instance *tbu;
+
+	if (res->is_hw_enable == false) {
+		for (i = 0; i < TBU_INSTANCES_NUM; i++) {
+			tbu = &res->tbu_ins[i];
+			tbu->ttb_size = 0;
+			tbu->always_preload = false;
+			tbu->enable_preload = true;
+			tbu->nsaid = 0;
+			tbu->qos = 2;
+			tbu->secure_enable = false;
+		}
+		res->tbu_ins_map = -1;
+
+		/* Set V2D_MMU iova base */
+		__write_reg(res, V2D_MMU_BVA_LO, res->va_base&0xFFFFFFFF);
+		__write_reg(res, V2D_MMU_BVA_HI, res->va_base>>32);
+
+		/* Set V2D_MMU timeout cycles */
+		__write_reg(res, V2D_MMU_TIMEOUT_VALUE, res->time_out_cycs);
+
+		/* Enable V2D_MMU irq */
+		__set_reg_bits(res, V2D_MMU_IRQ_ENABLE, 0x00);
+
+		res->is_hw_enable = true;
+	}
+
+	return 0;
+}
+
+static void __disable_spacemit_iommu_hw(struct v2d_iommu_res *res)
+{
+	int i;
+	struct tbu_instance *tbu;
+
+	/* Waiting for post done. */
+	res->is_hw_enable = false;
+	for (i=0; i<TBU_INSTANCES_NUM; i++) {
+		tbu = &res->tbu_ins[i];
+		tbu->ttb_size = 0;
+	}
+	/* Disable all TBUs. */
+	for (i = 0; i < TBU_NUM; i++)
+		__write_reg(res, V2D_MMU_TCR0_BASE+V2D_MMU_TBUx_STEP*i, 0);
+
+	/* Disable V2D_MMU irq. */
+	__clear_reg_bits(res, V2D_MMU_IRQ_ENABLE, 0x1FF);
+}
+
+static void __write_tbu_table(struct v2d_iommu_res *res, struct tbu_instance *tbu,
+	unsigned long iova, phys_addr_t paddr, size_t size)
+{
+	u32 *ttb_entry;
+	uint64_t mask  = 0;
+	uint32_t val;
+
+	mask = (res->page_size == 4096) ? 0xFFFFFFFFFFFFF000 : 0xFFFFFFFFFFFF0000;
+	ttb_entry = tbu->ttb_va + (iova - tbu->va_base) / res->page_size;
+	while (size != 0) {
+		paddr = paddr & 0xFFFFFFFF;
+		val = ((paddr & mask) >> TTB_ENTRY_SHIFT) & 0x1FFFFF;
+		*ttb_entry = val;
+		size -= res->page_size;
+		ttb_entry++;
+		paddr += res->page_size;
+	}
+}
+
+void v2d_iommu_map_end(void)
+{
+	__disable_spacemit_iommu_hw(&sV2dIommuRes);
+}
+
+static void v2d_iommu_post(struct v2d_iommu_res *res, int *ins_id, int num)
+{
+	u32 reg;
+	struct tbu_instance *tbu;
+	int i, tbu_slot[TBU_NUM];
+
+	for (i = 0; i < TBU_NUM; i++)
+		tbu_slot[i] = -1;
+
+	for (i = 0; i < num; i++) {
+		int index;
+		tbu = &res->tbu_ins[ins_id[i]];
+		index = (tbu->va_base - res->va_base) / VA_STEP_PER_TBU;
+		tbu_slot[index] = ins_id[i];
+	}
+
+	if (!res->is_hw_enable) {
+		return;
+	}
+
+	for (i = 0; i < TBU_NUM; i++) {
+		if (tbu_slot[i] != -1) {
+			tbu = &res->tbu_ins[tbu_slot[i]];
+			if (tbu->ttb_size == 0) {
+				__write_reg(res, V2D_MMU_TCR0_BASE+i*V2D_MMU_TBUx_STEP, 0);
+			} else {
+				__write_reg(res, V2D_MMU_TTBLR_BASE+i*V2D_MMU_TBUx_STEP, tbu->ttb_pa & 0xFFFFFFFF);
+				__write_reg(res, V2D_MMU_TTBHR_BASE+i*V2D_MMU_TBUx_STEP, tbu->ttb_pa >> 32);
+
+				reg = (tbu->ttb_size - 1) << 16;
+				if (tbu->always_preload)
+					reg |= BIT(3);
+				if (tbu->enable_preload)
+					reg |= BIT(2);
+				reg |= (tbu->qos << 4);
+				if (res->page_size == SZ_64K)
+					reg |= BIT(1);
+				reg |= BIT(0);
+				__write_reg(res, V2D_MMU_TCR0_BASE+i*V2D_MMU_TBUx_STEP, reg);
+			}
+		}
+	}
+}
+
+int v2d_iommu_map_sg(unsigned long iova, struct scatterlist *sg, unsigned int nents, int prot)
+{
+	struct v2d_iommu_res *res = &sV2dIommuRes;
+	struct tbu_instance *tbu;
+	struct scatterlist *s;
+	unsigned int i;
+	phys_addr_t paddr;
+	size_t size;
+	unsigned long orig_iova = iova;
+
+	if ((iova >= res->va_end) && (nents == 1))
+		return sg->length;
+
+	__enable_spacemit_iommu_hw(res);
+	res->tbu_ins_map = (iova - BASE_VIRTUAL_ADDRESS) / VA_STEP_PER_TBU;
+	pr_debug("tbu ins map:%d\n", res->tbu_ins_map);
+
+	if (res->tbu_ins_map < 0 || res->tbu_ins_map >= TBU_INSTANCES_NUM)
+		goto out_id_err;
+
+	tbu = &res->tbu_ins[res->tbu_ins_map];
+
+	if (tbu->ttb_size == 0) {
+		int index;
+		if (iova < res->va_base || iova >= res->va_end)
+			goto out_iova_err;
+
+		index = (iova - res->va_base) / VA_STEP_PER_TBU;
+		tbu->va_base = res->va_base + index * VA_STEP_PER_TBU;
+		tbu->va_end = tbu->va_base + VA_STEP_PER_TBU;
+	}
+
+	if (iova < tbu->va_base || iova >= tbu->va_end)
+		goto out_iova_err;
+
+	for_each_sg(sg, s, nents, i) {
+		paddr = page_to_phys(sg_page(s)) + s->offset;
+		size = s->length;
+		if (!IS_ALIGNED(s->offset, res->page_size)) {
+			pr_err("v2d iommu paddr not aligned: iova %lx, paddr %llx, size %lx\n",
+				iova, paddr, size);
+			goto out_region_err;
+		}
+
+		if (iova+size > tbu->va_end || size == 0)
+			goto out_region_err;
+
+		__write_tbu_table(res, tbu, iova, paddr, size);
+		iova += size;
+	}
+
+	if (iova > tbu->va_base + res->page_size * tbu->ttb_size)
+		tbu->ttb_size = (iova - tbu->va_base) / res->page_size;
+
+	v2d_iommu_post(res, &res->tbu_ins_map, 1);
+
+	return (iova - orig_iova);
+
+out_region_err:
+	pr_err("v2d map_sg is wrong: iova %lx, paddr %llx, size %lx\n",
+			iova, paddr, size);
+	return 0;
+
+out_iova_err:
+	pr_err("v2d map_sg is wrong: iova %lx", iova);
+
+	return 0;
+
+out_id_err:
+	pr_err("v2d tbu ins_id is wrong: %d\n", res->tbu_ins_map);
+
+	return 0;
+}
+
+void iommu_irq_reset(void)
+{
+	u64 last_va, last_pa;
+	u32 IRQ_status;
+	u32 reg;
+	int i;
+	struct v2d_iommu_res *res = &sV2dIommuRes;
+
+	IRQ_status = __read_reg(res, V2D_MMU_IRQ_STATUS);
+
+	if (IRQ_status == 0) {
+		return;
+	}
+
+	reg = __read_reg(res, V2D_MMU_LAST_PA_ADDR_HI);
+	last_pa = reg & 0x1;
+	reg = __read_reg(res, V2D_MMU_LAST_PA_ADDR_LO);
+	last_pa = (last_pa << 32) | reg;
+	reg = __read_reg(res, V2D_MMU_LAST_VA_ADDR_HI);
+	last_va = reg & 0x1;
+	reg = __read_reg(res, V2D_MMU_LAST_VA_ADDR_LO);
+	last_va = (last_va << 32) | reg;
+
+	/* Print IRQ status. */
+	pr_err("V2d Iommu Unexpected fault: IRQ status 0x%x, last PA 0x%09llx, last VA 0x%09llx\n", IRQ_status, last_pa, last_va);
+
+	if (IRQ_status & BIT(8)) {
+		u64 timeout_va_addr;
+		reg = __read_reg(res, V2D_MMU_TIMEOUT_VA_ADDR_HI);
+		timeout_va_addr = reg & 0x1;
+		reg = __read_reg(res, V2D_MMU_TIMEOUT_VA_ADDR_LO);
+		timeout_va_addr = (timeout_va_addr << 32) | reg;
+		pr_err("v2d iommu timeout error: timeout_va 0x%09llx\n", timeout_va_addr);
+	}
+
+	for (i = 0; i < TBU_NUM; i++) {
+		if (IRQ_status & BIT(i)) {
+			reg = __read_reg(res,
+				V2D_MMU_TBU_STATUS_BASE+i*V2D_MMU_TBUx_STEP);
+			pr_err("V2d Iommu TBU%d error: read addr 0x%08x, write addr 0x%08x\n",
+					i, ((reg >> 16) & 0xFFF), reg &0x1FFF);
+		}
+	}
+
+	/* clear DMA error */
+	if (IRQ_status & 0xFF)
+		__set_reg_bits(res, V2D_MMU_ERROR_CLEAR, BIT(1));
+
+	/* reset IRQ status */
+	__write_reg(res, V2D_MMU_IRQ_STATUS, IRQ_status);
+}
+
diff --git a/drivers/media/platform/spacemit/v2d/v2d_priv.h b/drivers/media/platform/spacemit/v2d/v2d_priv.h
new file mode 100644
index 000000000000..328a6a062768
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_priv.h
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef __SPACEMIT_V2D_PRIV_H__
+#define __SPACEMIT_V2D_PRIV_H__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/miscdevice.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/genalloc.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/iommu.h>
+#include <linux/pm_qos.h>
+
+#define V2D_PRINT_DEBUG
+#define V2D_FALSE 0
+#define V2D_TRUE  1
+
+#ifdef V2D_PRINT_ERROR
+#define V2D_LOG_LEVEL_ERROR
+#endif
+
+#ifdef V2D_PRINT_WARNING
+#define V2D_LOG_LEVEL_ERROR
+#define V2D_LOG_LEVEL_WARNING
+#endif
+
+#ifdef V2D_PRINT_INFO
+#define V2D_LOG_LEVEL_ERROR
+#define V2D_LOG_LEVEL_WARNING
+#define V2D_LOG_LEVEL_INFO
+#endif
+
+#ifdef V2D_PRINT_DEBUG
+#define V2D_LOG_LEVEL_ERROR
+#define V2D_LOG_LEVEL_WARNING
+#define V2D_LOG_LEVEL_INFO
+#define V2D_LOG_LEVEL_DEBUG
+#endif
+
+#ifdef V2D_LOG_LEVEL_ERROR
+#define V2DLOGE(fmt, ...) pr_err(fmt, ## __VA_ARGS__)
+#else
+#define V2DLOGE(fmt, ...)
+#endif
+
+#ifdef V2D_LOG_LEVEL_WARNING
+#define V2DLOGW(fmt, ...) pr_warn(fmt, ## __VA_ARGS__)
+#else
+#define V2DLOGW(fmt, ...)
+#endif
+
+#ifdef V2D_LOG_LEVEL_INFO
+#define V2DLOGI(fmt, ...) pr_info(fmt, ## __VA_ARGS__)
+#else
+#define V2DLOGI(fmt, ...)
+#endif
+
+#ifdef V2D_LOG_LEVEL_DEBUG
+#define V2DLOGD(fmt, ...) pr_debug(fmt, ## __VA_ARGS__)
+#else
+#define V2DLOGD(fmt, ...)
+#endif
+#define V2D_SHORT_FENCE_TIMEOUT (1 * MSEC_PER_SEC)
+#define V2D_LONG_FENCE_TIMEOUT (2 * MSEC_PER_SEC)
+#define V2D_DISABLE_BAND_CAL
+struct v2d_info {
+	struct platform_device  *pdev;
+	struct miscdevice       mdev;
+	int32_t                 irq;
+	void __iomem            *v2dreg_iomem_base;
+	struct clk              *clkcore;
+	struct clk              *clkio;
+	int                     refcount;
+	int                     do_reset;
+	struct mutex            power_mutex;
+	spinlock_t              power_spinlock;
+	struct work_struct      work;
+	struct workqueue_struct *v2d_job_done_wq;
+	uint64_t                context;
+	atomic_t                seqno;
+	struct semaphore        sem_lock;
+	struct mutex            client_lock;
+	struct list_head        post_list;
+	struct mutex            post_lock;
+	struct kthread_worker   post_worker;
+	struct task_struct      *post_thread;
+	struct kthread_work     post_work;
+	struct list_head        free_list;
+	struct mutex            free_lock;
+#if IS_ENABLED(CONFIG_SPACEMIT_DDR_FC) && defined(CONFIG_PM)
+#ifndef V2D_DISABLE_BAND_CAL
+	struct spacemit_bw_con *ddr_qos_cons;
+#endif
+#endif
+#ifdef CONFIG_SPACEMIT_DEBUG
+	bool b_v2d_running;
+	bool (*is_v2d_running)(struct v2d_info *pV2dInfo);
+	struct notifier_block nb;
+#endif
+};
+
+#define BASE_VIRTUAL_ADDRESS 0x80000000
+#define VA_STEP_PER_TBU 0x2000000
+#define MAX_ENTRIES_PER_TTB 8096
+#define ENTRY_SIZE 4
+#define MAX_SIZE_PER_TTB (MAX_ENTRIES_PER_TTB*ENTRY_SIZE)
+#define DEFAULT_TIMEOUT_CYCS 0x80000
+#define V2D_MMU_PGSIZE_BITMAP 0x02FFF000 /* 4K~32M */
+#define TBU_INSTANCES_NUM (3)
+#define TTB_ENTRY_SHIFT 12
+#define AQUIRE_TIMEOUT_MS 100
+
+struct tbu_instance {
+	int ins_id;
+	u32 *ttb_va;
+	dma_addr_t ttb_pa;
+	u64 ttb_size;
+	u64 va_base;
+	u64 va_end;
+	bool always_preload;
+	bool enable_preload;
+	u32 nsaid;
+	u32 qos;
+	bool secure_enable;
+};
+
+struct v2d_iommu_res {
+	void __iomem *base;
+	u32 time_out_cycs;
+	u32 page_size;
+	u64 va_base;
+	u64 va_end;
+	struct tbu_instance tbu_ins[TBU_INSTANCES_NUM];
+	int tbu_ins_map;
+	bool is_hw_enable;
+};
+#endif  /* __SPACEMIT_V2D_PRIV_H__*/
diff --git a/drivers/media/platform/spacemit/v2d/v2d_reg.h b/drivers/media/platform/spacemit/v2d/v2d_reg.h
new file mode 100644
index 000000000000..9e00fdff66c9
--- /dev/null
+++ b/drivers/media/platform/spacemit/v2d/v2d_reg.h
@@ -0,0 +1,824 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef _V2D_REG_H_
+#define _V2D_REG_H_
+
+#define V2D_REG_BASE       0xC0100000
+#define PMUA_REG_BASE      0xd4282800
+#define V2D_TOP_BASE       (0x000)
+#define V2D_CORE_BASE      (0x100)
+#define V2D_ENC_BASE       (0x800)
+#define V2D_L0_DEC_BASE    (0x900)
+#define V2D_L1_DEC_BASE    (0xa00)
+
+//v2d clk offset
+#define V2D_CLK_RES_CTRL0  (0x44)
+#define V2D_CLK_RES_CTRL1  (0x4c)
+
+//v2d top offset
+#define V2D_AUTO_CLK_REG               (0x00 + V2D_TOP_BASE)
+#define V2D_ERR_IRQ_MASK               (0x04 + V2D_TOP_BASE)
+#define V2D_IRQ_MASK                   (0x08 + V2D_TOP_BASE)
+#define V2D_ERR_IRQ_STATUS             (0x0C + V2D_TOP_BASE)
+#define V2D_IRQ_STATUS                 (0x10 + V2D_TOP_BASE)
+#define V2D_ERR_IRQ_RAW                (0x14 + V2D_TOP_BASE)
+#define V2D_IRQ_RAW                    (0x18 + V2D_TOP_BASE)
+#define V2D_AXI_BUS_CTRL               (0x1C + V2D_TOP_BASE)
+
+#define V2D_GLOBAL_RESET               BIT(8)
+#define V2D_AUTO_CLK_EN                BIT(9)
+#define V2D_ENC_AUTO_CLK_EN            BIT(10)
+#define V2D_TOP_AUTO_CLK_EN            BIT(11)
+#define V2D_EOF_IRQ_STATUS             BIT(0)
+#define V2D_FBCENC_IRQ_STATUS          BIT(1)
+#define V2D_EOF_IRQ_MASK               BIT(0)
+#define V2D_FBCENC_IRQ_MASK            BIT(1)
+
+#define V2D_H_ADDR_MASK                (0x3)
+//v2d core offset
+#define V2D_CTRL_REG                   (0x00 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG0           (0x04 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG1           (0x08 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG2           (0x0C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG3           (0x10 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG4           (0x14 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG5           (0x18 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG6           (0x1C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG7           (0x20 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG8           (0x24 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG9           (0x28 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG10          (0x2C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG11          (0x30 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG12          (0x34 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG13          (0x38 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG14          (0x3C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG15          (0x40 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG16          (0x44 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG17          (0x48 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG18          (0x4C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG19          (0x50 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG20          (0x54 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG21          (0x58 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG22          (0x5C + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_RGG23          (0x60 + V2D_CORE_BASE)
+#define V2D_SCALER_COEF_REG(i)         (0x04 * (i + 1) + V2D_CORE_BASE)
+#define SCALER_COEF_REG_NUM            (24)
+
+#define V2D_BLEND_REG0                 (0x64 + V2D_CORE_BASE)
+#define V2D_BLEND_REG1                 (0x68 + V2D_CORE_BASE)
+#define V2D_BLD_MASK_REG0              (0x6C + V2D_CORE_BASE)
+#define V2D_BLD_MASK_REG1              (0x70 + V2D_CORE_BASE)
+#define V2D_BLD_MASK_REG2              (0x74 + V2D_CORE_BASE)
+
+#define V2D_OUTPUT_Y_ADDR_L            (0x78 + V2D_CORE_BASE)
+#define V2D_OUTPUT_Y_ADDR_H            (0x7C + V2D_CORE_BASE)
+#define V2D_OUTPUT_UV_ADDR_L           (0x80 + V2D_CORE_BASE)
+#define V2D_OUTPUT_UV_ADDR_H           (0x84 + V2D_CORE_BASE)
+#define V2D_OUTPUT_WIDTH               (0x84 + V2D_CORE_BASE)
+#define V2D_OUTPUT_HEIGHT              (0x88 + V2D_CORE_BASE)
+#define V2D_OUTPUT_CRTL0               (0x8C + V2D_CORE_BASE)
+#define V2D_OUTPUT_CRTL1               (0x90 + V2D_CORE_BASE)
+#define V2D_OUTPUT_CRTL2               (0x94 + V2D_CORE_BASE)
+
+#define V2D_MASK_ADDR_L                (0x98 + V2D_CORE_BASE)
+#define V2D_MASK_ADDR_H                (0x9C + V2D_CORE_BASE)
+#define V2D_MASK_WIDTH                 (0x9C + V2D_CORE_BASE)
+#define V2D_MASK_HEIGHT                (0xA0 + V2D_CORE_BASE)
+#define V2D_MASK_CROP_REG0             (0xA4 + V2D_CORE_BASE)
+#define V2D_MASK_CROP_REG1             (0xA8 + V2D_CORE_BASE)
+
+#define V2D_LAYER0_Y_ADDR_L            (0xAC + V2D_CORE_BASE)
+#define V2D_LAYER0_Y_ADDR_H            (0xB0 + V2D_CORE_BASE)
+#define V2D_LAYER0_UV_ADDR_L           (0xB4 + V2D_CORE_BASE)
+#define V2D_LAYER0_UV_ADDR_H           (0xB8 + V2D_CORE_BASE)
+#define V2D_LAYER0_BLD_FACTOR          (0xB8 + V2D_CORE_BASE)
+#define V2D_LAYER0_WIDTH_HEIGHT        (0xBC + V2D_CORE_BASE)
+#define V2D_LAYER0_CTRL                (0xC0 + V2D_CORE_BASE)
+#define V2D_LAYER0_CROP_REG0           (0xC4 + V2D_CORE_BASE)
+#define V2D_LAYER0_CROP_REG1           (0xC8 + V2D_CORE_BASE)
+#define V2D_LAYER0_SOLIDCOLOR_CTRL0    (0xCC + V2D_CORE_BASE)
+#define V2D_LAYER0_SOLIDCOLOR_CTRL1    (0xD0 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL0           (0xD0 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL1           (0xD4 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL2           (0xD8 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL3           (0xDC + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL4           (0xE0 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL5           (0xE4 + V2D_CORE_BASE)
+#define V2D_LAYER0_CSC_CRTL6           (0xE8 + V2D_CORE_BASE)
+#define V2D_LAYER0_SCALE_MODE          (0xE8 + V2D_CORE_BASE)
+#define V2D_LAYER0_SCALE_DELTA_X       (0xEC + V2D_CORE_BASE)
+#define V2D_LAYER0_SCALE_DELTA_Y       (0xF0 + V2D_CORE_BASE)
+#define V2D_LAYER0_BLD_CTRL0           (0xF0 + V2D_CORE_BASE)
+#define V2D_LAYER0_BLD_CTRL1           (0xF4 + V2D_CORE_BASE)
+#define V2D_LAYER0_BLD_CTRL2           (0xF8 + V2D_CORE_BASE)
+#define V2D_LAYER0_BLD_CTRL3           (0xFC + V2D_CORE_BASE)
+
+#define V2D_LAYER1_Y_ADDR_L            (0x100 + V2D_CORE_BASE)
+#define V2D_LAYER1_Y_ADDR_H            (0x104 + V2D_CORE_BASE)
+#define V2D_LAYER1_UV_ADDR_L           (0x108 + V2D_CORE_BASE)
+#define V2D_LAYER1_UV_ADDR_H           (0x10C + V2D_CORE_BASE)
+#define V2D_LAYER1_BLD_FACTOR          (0x10C + V2D_CORE_BASE)
+#define V2D_LAYER1_WIDTH_HEIGHT        (0x110 + V2D_CORE_BASE)
+#define V2D_LAYER1_CTRL                (0x114 + V2D_CORE_BASE)
+#define V2D_LAYER1_CROP_REG0           (0x118 + V2D_CORE_BASE)
+#define V2D_LAYER1_CROP_REG1           (0x11C + V2D_CORE_BASE)
+#define V2D_LAYER1_SOLIDCOLOR_CTRL0    (0x120 + V2D_CORE_BASE)
+#define V2D_LAYER1_SOLIDCOLOR_CTRL1    (0x124 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL0           (0x124 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL1           (0x128 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL2           (0x12C + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL3           (0x130 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL4           (0x134 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL5           (0x138 + V2D_CORE_BASE)
+#define V2D_LAYER1_CSC_CRTL6           (0x13C + V2D_CORE_BASE)
+#define V2D_LAYER1_SCALE_MODE          (0x13C + V2D_CORE_BASE)
+#define V2D_LAYER1_SCALE_DELTA_X       (0x140 + V2D_CORE_BASE)
+#define V2D_LAYER1_SCALE_DELTA_Y       (0x144 + V2D_CORE_BASE)
+#define V2D_LAYER1_BLD_CTRL0           (0x144 + V2D_CORE_BASE)
+#define V2D_LAYER1_BLD_CTRL1           (0x148 + V2D_CORE_BASE)
+#define V2D_LAYER1_BLD_CTRL2           (0x14C + V2D_CORE_BASE)
+#define V2D_LAYER1_BLD_CTRL3           (0x150 + V2D_CORE_BASE)
+
+#define V2D_LAYER_Y_ADDR_L_LAYER(i)           (0xAC + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_Y_ADDR_H_LAYER(i)           (0xB0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_UV_ADDR_L_LAYER(i)          (0xB4 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_UV_ADDR_H_LAYER(i)          (0xB8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_BLD_FACTOR_LAYER(i)         (0xB8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_WIDTH_HEIGHT_LAYER(i)       (0xBC + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CTRL_LAYER(i)               (0xC0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CROP_REG0_LAYER(i)          (0xC4 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CROP_REG1_LAYER(i)          (0xC8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_SOLIDCOLOR_CTRL0_LAYER(i)   (0xCC + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_SOLIDCOLOR_CTRL1_LAYER(i)   (0xD0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL0_LAYER(i)          (0xD0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL1_LAYER(i)          (0xD4 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL2_LAYER(i)          (0xD8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL3_LAYER(i)          (0xDC + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL4_LAYER(i)          (0xE0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL5_LAYER(i)          (0xE4 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_CSC_CRTL6_LAYER(i)          (0xE8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_SCALE_MODE_LAYER(i)         (0xE8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_SCALE_DELTA_X_LAYER(i)      (0xEC + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_SCALE_DELTA_Y_LAYER(i)      (0xF0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_BLD_CTRL0_LAYER(i)          (0xF0 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_BLD_CTRL1_LAYER(i)          (0xF4 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_BLD_CTRL2_LAYER(i)          (0xF8 + i * 0x54 + V2D_CORE_BASE)
+#define V2D_LAYER_BLD_CTRL3_LAYER(i)          (0xFC + i * 0x54 + V2D_CORE_BASE)
+
+#define V2D_DEBUG_REG0                 (0x1FC + V2D_CORE_BASE)
+#define V2D_DEBUG_REG1                 (0x200 + V2D_CORE_BASE)
+#define V2D_DMA_CTRL                   (0x204 + V2D_CORE_BASE)
+#define V2D_PALETTE_TABLE(i)           (0x208 + i * 0x4 + V2D_CORE_BASE)
+
+#define V2D_L0_DEC_REG0       (V2D_L0_DEC_BASE + 0x000)  //register hdr_base_addr_low
+#define V2D_L0_DEC_REG1       (V2D_L0_DEC_BASE + 0x004)  //register hdr_base_addr_high
+#define V2D_L0_DEC_REG2       (V2D_L0_DEC_BASE + 0x008)  //register bbox_coor_x
+#define V2D_L0_DEC_REG3       (V2D_L0_DEC_BASE + 0x00c)  //register bbox_coor_y
+#define V2D_L0_DEC_REG4       (V2D_L0_DEC_BASE + 0x010)  //register image_size
+#define V2D_L0_DEC_REG5       (V2D_L0_DEC_BASE + 0x014)  //register dec_mode
+#define V2D_L0_DEC_REG6       (V2D_L0_DEC_BASE + 0x018)  //register dmac_ctrl
+#define V2D_L0_DEC_REG7       (V2D_L0_DEC_BASE + 0x01c)  //register irq_mask
+#define V2D_L0_DEC_REG8       (V2D_L0_DEC_BASE + 0x020)  //register irq_raw
+#define V2D_L0_DEC_REG9       (V2D_L0_DEC_BASE + 0x024)  //register irq_status
+#define V2D_L0_DEC_REG10      (V2D_L0_DEC_BASE + 0x028)  //register trig_ctrl
+#define V2D_L0_DEC_REG11      (V2D_L0_DEC_BASE + 0x02c)  //register output_ybase
+#define V2D_L0_DEC_REG12      (V2D_L0_DEC_BASE + 0x030)  //register output_cbase
+#define V2D_L0_DEC_REG13      (V2D_L0_DEC_BASE + 0x034)  //register output_stride
+
+#define V2D_L1_DEC_REG0       (V2D_L1_DEC_BASE + 0x000)
+#define V2D_L1_DEC_REG1       (V2D_L1_DEC_BASE + 0x004)
+#define V2D_L1_DEC_REG2       (V2D_L1_DEC_BASE + 0x008)
+#define V2D_L1_DEC_REG3       (V2D_L1_DEC_BASE + 0x00c)
+#define V2D_L1_DEC_REG4       (V2D_L1_DEC_BASE + 0x010)
+#define V2D_L1_DEC_REG5       (V2D_L1_DEC_BASE + 0x014)
+#define V2D_L1_DEC_REG6       (V2D_L1_DEC_BASE + 0x018)
+#define V2D_L1_DEC_REG7       (V2D_L1_DEC_BASE + 0x01c)
+#define V2D_L1_DEC_REG8       (V2D_L1_DEC_BASE + 0x020)
+#define V2D_L1_DEC_REG9       (V2D_L1_DEC_BASE + 0x024)
+#define V2D_L1_DEC_REG10      (V2D_L1_DEC_BASE + 0x028)
+#define V2D_L1_DEC_REG11      (V2D_L1_DEC_BASE + 0x02c)
+#define V2D_L1_DEC_REG12      (V2D_L1_DEC_BASE + 0x030)
+#define V2D_L1_DEC_REG13      (V2D_L1_DEC_BASE + 0x034)
+
+#define V2D_LAYER_DEC_REG0_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x000)
+#define V2D_LAYER_DEC_REG1_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x004)
+#define V2D_LAYER_DEC_REG2_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x008)
+#define V2D_LAYER_DEC_REG3_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x00c)
+#define V2D_LAYER_DEC_REG4_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x010)
+#define V2D_LAYER_DEC_REG5_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x014)
+#define V2D_LAYER_DEC_REG6_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x018)
+#define V2D_LAYER_DEC_REG7_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x01c)
+#define V2D_LAYER_DEC_REG8_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x020)
+#define V2D_LAYER_DEC_REG9_L(i)       (V2D_L0_DEC_BASE + i * 0x100 + 0x024)
+#define V2D_LAYER_DEC_REG10_L(i)      (V2D_L0_DEC_BASE + i * 0x100 + 0x028)
+#define V2D_LAYER_DEC_REG11_L(i)      (V2D_L0_DEC_BASE + i * 0x100 + 0x02c)
+#define V2D_LAYER_DEC_REG12_L(i)      (V2D_L0_DEC_BASE + i * 0x100 + 0x030)
+#define V2D_LAYER_DEC_REG13_L(i)      (V2D_L0_DEC_BASE + i * 0x100 + 0x034)
+
+#define V2D_ENC_REG0       (V2D_ENC_BASE + 0x000)  //REGISTER HEADER_BASE_ADDR_LOW
+#define V2D_ENC_REG1       (V2D_ENC_BASE + 0x004)  //REGISTER HEADER_BASE_ADDR_HIGH
+#define V2D_ENC_REG2       (V2D_ENC_BASE + 0x008)  //REGISTER PAYLOAD_BASE_ADDR_LOW
+#define V2D_ENC_REG3       (V2D_ENC_BASE + 0x00c)  //REGISTER PAYLOAD_BASE_ADDR_HIGH
+#define V2D_ENC_REG4       (V2D_ENC_BASE + 0x010)  //REGISTER Bbox_coor_x
+#define V2D_ENC_REG5       (V2D_ENC_BASE + 0x014)  //REGISTER Bbox_coor_y
+#define V2D_ENC_REG6       (V2D_ENC_BASE + 0x018)  //REGISTER Y_BUF_BASE_ADDR
+#define V2D_ENC_REG7       (V2D_ENC_BASE + 0x01c)  //REGISTER Y_BUF_PITCH
+#define V2D_ENC_REG8       (V2D_ENC_BASE + 0x020)  //REGISTER UV_BUF_BASE_ADDR
+#define V2D_ENC_REG9       (V2D_ENC_BASE + 0x024)  //REGISTER UV_BUF_PITCH
+#define V2D_ENC_REG10      (V2D_ENC_BASE + 0x028)  //REGISTER Y_BUF_SIZE
+#define V2D_ENC_REG11      (V2D_ENC_BASE + 0x02c)  //REGISTER UV_BUF_SIZE
+#define V2D_ENC_REG12      (V2D_ENC_BASE + 0x030)  //REGISTER REG_SHADOW_CTRL
+#define V2D_ENC_REG13      (V2D_ENC_BASE + 0x034)  //REGISTER IRQ_MASK
+#define V2D_ENC_REG14      (V2D_ENC_BASE + 0x038)  //REGISTER IRQ_CLEAR
+#define V2D_ENC_REG15      (V2D_ENC_BASE + 0x03c)  //REGISTER DMAC_CTRL_0
+#define V2D_ENC_REG16      (V2D_ENC_BASE + 0x040)  //REGISTER ENC_MODE
+#define V2D_ENC_REG17      (V2D_ENC_BASE + 0x044)  //REGISTER DMAC_LENGTH
+#define V2D_ENC_REG18      (V2D_ENC_BASE + 0x048)  //REGISTER IRQ_STATUS
+//v2d iommu
+#define TBU_NUM 32
+#define V2D_MMU_TTBLR_BASE         (0x40)
+#define V2D_MMU_TTBHR_BASE         (0x44)
+#define V2D_MMU_TCR0_BASE          (0x48)
+#define V2D_MMU_TCR1_BASE          (0x4c)
+#define V2D_MMU_TBU_STATUS_BASE    (0x50)
+#define V2D_MMU_TBUx_STEP          (0x20)
+#define V2D_MMU_BVA_LO             (0x00)
+#define V2D_MMU_BVA_HI             (0x04)
+#define V2D_MMU_TIMEOUT_VA_ADDR_LO (0x08)
+#define V2D_MMU_TIMEOUT_VA_ADDR_HI (0x0C)
+#define V2D_MMU_IRQ_STATUS         (0x10)
+#define V2D_MMU_IRQ_ENABLE         (0x14)
+#define V2D_MMU_TIMEOUT_VALUE      (0x18)
+#define V2D_MMU_ERROR_CLEAR        (0x1C)
+#define V2D_MMU_LAST_VA_ADDR_LO    (0x20)
+#define V2D_MMU_LAST_VA_ADDR_HI    (0x24)
+#define V2D_MMU_LAST_PA_ADDR_LO    (0x28)
+#define V2D_MMU_LAST_PA_ADDR_HI    (0x2C)
+#define V2D_MMU_VERSION            (0x3C)
+#define V2D_IOMMU_BASE_OFFSET      (0xB00)
+
+/**
+ *@brief V2D Control register
+ */
+typedef union {
+    struct {
+        unsigned int trigger                  : 1;      /**< trigger v2d to work */
+        unsigned int rdma_burst_len           : 3;      /**< set rdma burst lenght */
+        unsigned int reserved1                : 4;      /**< Reserved */
+        unsigned int wdma_burst_len           : 5;      /**< set wdma burst length */
+        unsigned int reserved2                : 19;     /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_ctrl_reg_t;
+
+/**
+ *@brief V2D DMA Control register
+ */
+typedef union {
+    struct {
+        unsigned int dmac_arb_mode            : 2;
+        unsigned int dmac_arqos               : 4;
+        unsigned int reserved                 : 2;   /**< Reserved */
+        unsigned int dmac_awqos               : 4;
+        unsigned int dmac_axi_sec             : 1;
+        unsigned int dmac_max_req_num         : 3;
+        unsigned int dmac_postwr_en           : 8;
+        unsigned int dmac_rst_n_pwr           : 1;
+        unsigned int dmac_rst_req             : 1;
+        unsigned int dmac_user_id             : 4;
+        unsigned int damc_rd_int_clr          : 1;
+        unsigned int damc_wr_int_clr          : 1;
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_dma_ctrl_reg_t;
+
+/**
+ *@brief V2D Scaler Coefficient register
+ */
+typedef union {
+    struct {
+        int scaler_coef0                        : 12;   /**< scaler coefficient0 */
+        unsigned int reserved1                  : 4;    /**< Reserved */
+        int scaler_coef1                        : 12;   /**< scaler coefficient1 */
+        unsigned int reserved2                  : 4;    /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_scaler_coef_reg_t;
+
+/**
+ *@brief V2D Blend Control0 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_mode                  :  1;    /**< blend mode alpha blending or ROP operation */
+        unsigned int bld_bg_enable             :  1;    /**< background color enable */
+        unsigned int reserved                  :  6;    /**< Rerserved */
+        unsigned int bld_bg_r                  :  8;    /**< background color R value */
+        unsigned int bld_bg_g                  :  8;    /**< background color G value */
+        unsigned int bld_bg_b                  :  8;    /**< background color B value */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_ctrl0_reg_t;
+
+/**
+ *@brief V2D Blend Control1 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_bg_a                  :  8;    /**< background color alpha value */
+        unsigned int reserved                  :  24;   /**< Rerserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_ctrl1_reg_t;
+
+/**
+ *@brief V2D Blend Mask Control0 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_mask_enable           : 2;     /**< blend mask enable */
+        unsigned int reserved1                 : 6;     /**< Rerserved */
+        unsigned int bld_mask_rect_ltop_x      : 16;    /**< blend mask rectangle left-top point x-axis coordinate */
+        unsigned int reserved2                 : 8;     /**< Rerserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_mask_ctrl0_reg_t;
+
+/**
+ *@brief V2D Blend Mask Control1 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_mask_rect_ltop_y      : 16;    /**< blend mask rectangle left-top point y-axis coordinate */
+        unsigned int bld_mask_rect_width       : 16;    /**< blend mask rectangle width */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_mask_ctrl1_reg_t;
+
+/**
+ *@brief V2D Blend Mask Control2 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_mask_rect_height      : 16;    /**< blend mask rectangle height */
+        unsigned int reserved                  : 16;    /**< Rerserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_mask_ctrl2_reg_t;
+
+/**
+ *@brief V2D Output Width register
+ */
+typedef union {
+    struct {
+        unsigned int out_addr_uv_33_32         : 2;     /**< output uv address_h_bit */
+        unsigned int reserved1                 : 6;     /**< Rerserved */
+        unsigned int out_ori_width             : 16;    /**< output width */
+        unsigned int reserved2                 : 8;     /**< Rerserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_output_width_reg_t;
+
+/**
+ *@brief V2D Output Height register
+ */
+typedef union {
+    struct {
+        unsigned int out_ori_height            : 16;    /**< output height */
+        unsigned int out_ori_stride            : 16;    /**< output stride */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_output_height_reg_t;
+
+/**
+ *@brief V2D Output Control0 register
+ */
+typedef union {
+    struct {
+        unsigned int format                  : 4;   /**< output format */
+        unsigned int range                   : 1;   /**< output range yuv narrow/wide */
+        unsigned int dither                  : 2;   /**< output dither mode */
+        unsigned int swap                    : 1;   /**< output swap */
+        unsigned int fbc_en                  : 1;   /**< output fbc enable */
+        unsigned int reserved                : 7;   /**< Rerserved */
+        unsigned int crop_ltop_x             : 16;  /**< output crop left-top point x-axis coordinate */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_output_ctrl0_reg_t;
+
+/**
+ *@brief V2D Output Control1 register
+ */
+typedef union {
+    struct {
+        unsigned int crop_ltop_y             : 16;  /**< output crop left-top point y-axis coordinate */
+        unsigned int crop_width              : 16;  /**< output crop width */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_output_ctrl1_reg_t;
+
+/**
+ *@brief V2D Output Control2 register
+ */
+typedef union {
+    struct {
+        unsigned int crop_height             : 16;  /**< output crop height */
+        unsigned int reserved                : 16;  /**< Rerserved */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_output_ctrl2_reg_t;
+
+/**
+ *@brief V2D mask input Width register
+ */
+typedef union {
+    struct {
+        unsigned int mask_addr_33_32         : 2;   /**< mask address_h_bit */
+        unsigned int reserved1               : 6;   /**< Rerserved */
+        unsigned int mask_ori_width          : 16;  /**< mask in width */
+        unsigned int reserved2               : 8;   /**< Rerserved */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_mask_width_reg_t;
+
+/**
+ *@brief V2D mask input Height register
+ */
+typedef union {
+    struct {
+        unsigned int mask_ori_height            : 16;   /**< mask in height */
+        unsigned int mask_ori_stride            : 16;   /**< mask in stride */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_mask_height_reg_t;
+
+/**
+ *@brief V2D mask input crop0 register
+ */
+typedef union {
+    struct {
+        unsigned int mask_crop_ltop_x           : 16;   /**< mask crop left-top point x-axis coordinate */
+        unsigned int mask_crop_ltop_y           : 16;   /**< mask crop left-top point y-axis coordinate */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_mask_crop0_reg_t;
+
+/**
+ *@brief V2D mask input crop1 register
+ */
+typedef union {
+    struct {
+        unsigned int mask_crop_width            : 16;   /**< mask crop in width */
+        unsigned int mask_crop_height           : 16;   /**< mask crop in height */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_mask_crop1_reg_t;
+
+/**
+ *@brief V2D Blend Layer Factor register
+ */
+typedef union {
+    struct {
+        unsigned int in_addr_uv_33_32               : 2;    /**< input layer uv address_h_bit */
+        unsigned int bld_src_color_factor           : 3;    /**< blend source color factor */
+        unsigned int bld_dst_color_factor           : 3;    /**< blend dst color factor */
+        unsigned int bld_src_alpha_factor           : 3;    /**< blend source alpha factor */
+        unsigned int bld_dst_alpha_factor           : 3;    /**< blend dst alpha factor */
+        unsigned int reserved1                      : 2;    /**< Reserved */
+        unsigned int bld_color_rop2_code            : 4;    /**< ROP color code */
+        unsigned int bld_alpha_rop2_code            : 4;    /**< ROP alpha code */
+        unsigned int reserved2                      : 8;    /**< Reserved */
+    } field;                                                /**< Fields view */
+    unsigned int overlay;                                   /**< Overlay view */
+} v2d_blend_layer_factor_reg_t;
+
+/**
+ *@brief V2D Input Layer width/height register
+ */
+typedef union {
+    struct {
+        unsigned int layer_in_ori_width            : 16;    /**< input layer width */
+        unsigned int layer_in_ori_height           : 16;    /**< input layer height */
+    } field;                                                /**< Fields view */
+    unsigned int overlay;                                   /**< Overlay view */
+} v2d_input_layer_width_height_reg_t;
+
+/**
+ *@brief V2D Input Layer Control register
+ */
+typedef union {
+    struct {
+        unsigned int stride               : 16; /**< input layer stride */
+        unsigned int format               : 4;  /**< input layer format */
+        unsigned int rotation             : 3;  /**< input layer rotation */
+        unsigned int swap                 : 1;  /**< input layer swap */
+        unsigned int fbc_en               : 1;  /**< input layer fbc enbale */
+        unsigned int reserved             : 7;  /**< Reserved */
+    } field;                                    /**< Fields view */
+    unsigned int overlay;                       /**< Overlay view */
+} v2d_input_layer_ctrl_reg_t;
+
+/**
+ *@brief V2D input layer crop0 register
+ */
+typedef union {
+    struct {
+        unsigned int layer_in_crop_ltop_x           : 16;   /**< input layer crop left-top point x-axis coordinate */
+        unsigned int layer_in_crop_ltop_y           : 16;   /**< input layer crop left-top point y-axis coordinate */
+    } field;                                                /**< Fields view */
+    unsigned int overlay;                                   /**< Overlay view */
+} v2d_input_layer_crop0_reg_t;
+
+/**
+ *@brief V2D input layer crop1 register
+ */
+typedef union {
+    struct {
+        unsigned int layer_in_crop_width            : 16;   /**< input layer crop in width */
+        unsigned int layer_in_crop_height           : 16;   /**< input layer crop in height */
+    } field;                                                /**< Fields view */
+    unsigned int overlay;                                   /**< Overlay view */
+} v2d_input_layer_crop1_reg_t;
+
+/**
+ *@brief V2D input solid color control0 register
+ */
+typedef union {
+    struct {
+        unsigned int solid_en              : 1;     /**< input layer solid color enable */
+        unsigned int reserved              : 7;     /**< Rrserved */
+        unsigned int solid_R               : 8;     /**< solid color R channel value */
+        unsigned int solid_G               : 8;     /**< solid color G channel value */
+        unsigned int solid_B               : 8;     /**< solid color B channel value */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_solid_color_ctrl0_reg_t;
+
+/**
+ *@brief V2D input solid color control1 register
+ */
+typedef union {
+    struct {
+        unsigned int solid_A               : 8;     /**< solid color alpha channel value */
+        unsigned int csc_en                : 1;     /**< input layer csc enable */
+        unsigned int reserved1             : 7;     /**< Rrserved */
+        int csc_matrix0           : 13;             /**< input layer csc matrix0 */
+        unsigned int reserved2             : 3;     /**< Rrserved */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_solid_color_ctrl1_reg_t;
+typedef v2d_solid_color_ctrl1_reg_t v2d_input_layer_csc_ctrl0_reg_t;
+
+/**
+ *@brief V2D input layer csc control1~5 register
+ */
+typedef union {
+    struct {
+        int csc_matrix1                    : 13;         /**< input layer csc matrix 2*i-1 */
+        unsigned int reserved1             : 3; /**< Rrserved */
+        int csc_matrix2                    : 13;         /**< input layer csc matrix 2*i */
+        unsigned int reserved2             : 3; /**< Rrserved */
+    } field;                                    /**< Fields view */
+    unsigned int overlay;                       /**< Overlay view */
+} v2d_input_layer_csc_ctrl1_reg_t;
+
+/**
+ *@brief V2D input layer csc control6 register
+ */
+typedef union {
+    struct {
+        int csc_matrix11                   : 13;             /**< input layer csc matrix11  */
+        unsigned int scl_mode              : 2;     /**< scaler mode 0:bypass, 1:scale down, 2:scale up */
+        unsigned int reserved1             : 17;    /**< Rrserved */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_input_layer_csc_ctrl2_reg_t;
+typedef v2d_input_layer_csc_ctrl2_reg_t v2d_input_layer_scale_mode_reg_t;
+
+/**
+ *@brief V2D input layer scale delta x register
+ */
+typedef union {
+    struct {
+        unsigned int scl_delta_x           : 20;    /**< input layer scale delta x, (in_width<<16) /bld_rectWidth  */
+        unsigned int reserved              : 12;    /**< Rrserved */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_input_layer_scale_delta_x_reg_t;
+
+/**
+ *@brief V2D input layer scale delta y register
+ */
+typedef union {
+    struct {
+        unsigned int scl_delta_y           : 20;    /**< input layer scale delta y, (in_height<<16) /bld_rectHeight  */
+        unsigned int bld_alpha_source      : 2;     /**< blend alpha source, 0:pixel, 1:golbal, 2: mask value */
+        unsigned int bld_pre_alp_func      : 2;     /**< blend premultiplied function, 0:disable, 1:global alpha* src_alpha, 2:mask*src_a */
+        unsigned int bld_glb_alp           : 8;     /**< global alpha value */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_input_layer_scale_delta_y_reg_t;
+typedef v2d_input_layer_scale_delta_y_reg_t v2d_blend_layer_ctrl0_reg_t;
+
+/**
+ * @brief V2D Blend Layer Control1 register
+ */
+typedef union {
+    struct {
+        unsigned int blend_en             : 1;  /**< blend layer enable */
+        unsigned int reserved1            : 7;  /**< Reserved */
+        unsigned int bld_rect_ltop_x      : 16; /**< blend layer rectangle left-top point x-axis coordinate */
+        unsigned int reserved2            : 8;  /**< Reserved */
+    } field;                                    /**< Fields view */
+    unsigned int overlay;                       /**< Overlay view */
+} v2d_blend_layer_ctrl1_reg_t;
+
+/**
+ * @brief V2D Blend Layer Control2 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_rect_ltop_y       : 16;    /**< blend layer rectangle left-top point y-axis coordinate */
+        unsigned int bld_rect_width        : 16;    /**< blend layer rectangle width */
+    } field;                                        /**< Fields view */
+    unsigned int overlay;                           /**< Overlay view */
+} v2d_blend_layer_ctrl2_reg_t;
+
+/**
+ * @brief V2D Blend Layer Control3 register
+ */
+typedef union {
+    struct {
+        unsigned int bld_rect_height            : 16;   /**< blend layer rectangle height */
+        unsigned int reserved                   : 16;   /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_blend_layer_ctrl3_reg_t;
+
+/**
+ * @brief V2D FBC decoder bbox register
+ */
+typedef union {
+    struct {
+        unsigned int bbox_start            : 13;      /**< v2d fbc decoder bbox start */
+        unsigned int reserved1             : 3;       /**< Reserved */
+        unsigned int bbox_end              : 13;      /**< v2d fbc decoder bbox end */
+        unsigned int reserved2             : 3;       /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_decoder_bbox_reg_t;
+
+/**
+ * @brief V2D FBC decoder image size register
+ */
+typedef union {
+    struct {
+        unsigned int width               : 16;          /**< v2d fbc decoder image width  */
+        unsigned int height              : 16;          /**< v2d fbc decoder image height */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_decoder_imgae_size_reg_t;
+
+/**
+ * @brief V2D FBC decoder mode register
+ */
+typedef union {
+    struct {
+        unsigned int mode                : 3;          /**< v2d fbc decoder mode  */
+        unsigned int format              : 3;          /**< v2d fbc decoder pixel format */
+        unsigned int is_split            : 1;          /**< v2d fbc decoder split mode */
+        unsigned int rgb_pack_en         : 1;          /**< v2d fbc decoder rgb pack enable */
+        unsigned int reserved            : 24;         /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_decoder_mode_reg_t;
+
+/**
+ * @brief V2D FBC decoder dma control register
+ */
+typedef union {
+    struct {
+        unsigned int dmac_arqos                : 4;    /**< v2d fbc decoder dma qos  */
+        unsigned int damc_axi_sec              : 1;    /**< v2d fbc decoder dma axi sec */
+        unsigned int dmac_user_id              : 4;    /**< v2d fbc decoder dma user id */
+        unsigned int dmac_rstn_pwr             : 1;    /**< v2d fbc decoder dma rstn pwr */
+        unsigned int dmac_rst_req              : 1;    /**< v2d fbc decoder dma rst req*/
+        unsigned int dmac_max_req_num          : 3;    /**< v2d fbc decoder dma max req num */
+        unsigned int dmac_arb_mode             : 2;    /**< v2d fbc decoder dma arb mode */
+        unsigned int rdma_timeout_num          : 16;   /**< v2d fbc decoder dma timeout num */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_decoder_dma_ctrl_reg_t;
+
+/**
+ * @brief V2D FBC decoder irq mask/raw/status register
+ */
+typedef union {
+    struct {
+        unsigned int decode_eof               : 1;    /**< v2d fbc decoder eof irq mask  */
+        unsigned int cfg_swaped               : 1;    /**< v2d fbc decoder cfg sswap irq mask */
+        unsigned int dmac_err                 : 1;    /**< v2d fbc decoder dmac err irq mask */
+        unsigned int rdma_timeout             : 1;    /**< v2d fbc decoder rdma timeout mask */
+        unsigned int dec_err                  : 1;    /**< v2d fbc decoder decode err irq mask */
+        unsigned int reserved                 : 27;   /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_decoder_irq_ctrl_reg_t;
+
+/**
+ * @brief V2D FBC decoder trigger register
+ */
+typedef union {
+    struct {
+        unsigned int direct_swap               : 1;    /**< v2d fbc decoder direct swap  */
+        unsigned int pending_swap              : 1;    /**< v2d fbc decoder pending swap */
+        unsigned int reserved                  : 30;   /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_decoder_trigger_reg_t;
+
+/**
+ * @brief V2D FBC encoder bbox register
+ */
+typedef union {
+    struct {
+        unsigned int bbox_start            : 16;      /**< v2d fbc encoder bbox start */
+        unsigned int bbox_end              : 16;      /**< v2d fbc encoder bbox end */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_encoder_bbox_reg_t;
+
+/**
+ * @brief V2D FBC encoder y or uv buf szie register
+ */
+typedef union {
+    struct {
+        unsigned int x_size              : 16;      /**< v2d fbc encoder buf x size  */
+        unsigned int y_size              : 16;      /**< v2d fbc encoder buf y size */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_fbc_encoder_buf_size_reg_t;
+
+/**
+ * @brief V2D FBC encoder trigger register
+ */
+typedef union {
+    struct {
+        unsigned int direct_swap               : 1;    /**< v2d fbc encoder direct swap  */
+        unsigned int pending_swap              : 1;    /**< v2d fbc encoder pending swap */
+        unsigned int reserved                  : 30;   /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_encoder_trigger_reg_t;
+
+/**
+ * @brief V2D FBC encoder irq mask,raw,status register
+ */
+typedef union {
+    struct {
+        unsigned int dma_wr_err                    : 16;   /**< v2d fbc encoder dma wr err  */
+        unsigned int dma_wr_eof                    : 1;    /**< v2d fbc encoder dma wr eof */
+        unsigned int cfg_update_done               : 1;    /**< v2d fbc encoder cfg update done */
+        unsigned int reserved                      : 14;   /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_encoder_irq_reg_t;
+
+/**
+ * @brief V2D FBC encoder mode register
+ */
+typedef union {
+    struct {
+        unsigned int encode_enable                    : 1;   /**< v2d fbc encoder enable */
+        unsigned int split_mode_en                    : 1;   /**< v2d fbc encoder split mode */
+        unsigned int img_pix_format                   : 2;   /**< v2d fbc encoder pixel format */
+        unsigned int reserved                         : 28;  /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_encoder_mode_reg_t;
+
+/**
+ * @brief V2D FBC encoder dmac length register
+ */
+typedef union {
+    struct {
+        unsigned int burst_length                     : 7;   /**< v2d fbc encoder dmac burst length */
+        unsigned int reserved                         : 25;  /**< Reserved */
+    } field;                                               /**< Fields view */
+    unsigned int overlay;                                  /**< Overlay view */
+} v2d_fbc_encoder_dmac_burst_reg_t;
+
+/**
+*@brief V2D Top AXI bus control register
+*/
+typedef union {
+    struct {
+        unsigned int arqos_m                      : 4;	/**< v2d axi bus read qos */
+        unsigned int aruser_m                     : 4;  /**< v2d axi bus read user */
+        unsigned int awqos_m                      : 4;  /** <v2d axi bus write qos */
+        unsigned int awuser_m                     : 4;  /**< v2d axi bus write user */
+        unsigned int shadow_mode                  : 1;  /**< v2d reg cfg is shadow mode */
+        unsigned int reserved                     : 15; /**< Reserved */
+    } field;                                            /**< Fields view */
+    unsigned int overlay;                               /**< Overlay view */
+} v2d_axi_bus_ctrl_reg_t;
+#endif
-- 
2.47.0

