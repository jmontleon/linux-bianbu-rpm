From f50a36449e055ce4f116d97eca418d54af0d07e3 Mon Sep 17 00:00:00 2001
From: wanlong <long.wan@spacemit.com>
Date: Wed, 30 Aug 2023 18:29:05 +0800
Subject: [PATCH 0095/1204] mmc: support spacemit k1x platform

Change-Id: Iac553b07dd96bc7f80dcd521b8e41733bdda828a
---
 arch/riscv/boot/dts/spacemit/k1-x.dtsi        |   71 +
 arch/riscv/configs/k1-pro_fpga_defconfig      |    2 +-
 arch/riscv/configs/k1-x_fpga_defconfig        |    4 +
 drivers/mmc/core/bus.c                        |    4 +
 drivers/mmc/core/core.c                       |   30 +
 drivers/mmc/core/mmc.c                        |   31 +
 drivers/mmc/core/sd.c                         |   31 +
 drivers/mmc/core/slot-gpio.c                  |    9 +
 drivers/mmc/host/Kconfig                      |   20 +-
 drivers/mmc/host/Makefile                     |    3 +-
 .../{sdhci-of-spacemit.c => sdhci-of-k1pro.c} |    0
 drivers/mmc/host/sdhci-of-k1x.c               | 1530 +++++++++++++++++
 drivers/mmc/host/sdhci.c                      |  112 ++
 drivers/mmc/host/sdhci.h                      |   24 +
 include/dt-bindings/mmc/k1x_sdhci.h           |   53 +
 include/linux/mmc/host.h                      |   14 +-
 include/linux/platform_data/k1x_sdhci.h       |   92 +
 17 files changed, 2024 insertions(+), 6 deletions(-)
 rename drivers/mmc/host/{sdhci-of-spacemit.c => sdhci-of-k1pro.c} (100%)
 create mode 100644 drivers/mmc/host/sdhci-of-k1x.c
 create mode 100644 include/dt-bindings/mmc/k1x_sdhci.h
 create mode 100644 include/linux/platform_data/k1x_sdhci.h

diff --git a/arch/riscv/boot/dts/spacemit/k1-x.dtsi b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
index a10f426d88f3..5f1aca227452 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
@@ -3,6 +3,7 @@
 
 /dts-v1/;
 
+#include <dt-bindings/mmc/k1x_sdhci.h>
 
 / {
 	compatible = "spacemit,k1-x", "riscv";
@@ -135,6 +136,34 @@ pll_clk_emac_ptp: clock-pll_clk_emac_ptp {
 			clock-frequency = <50000000>;
 			clock-output-names = "pll_clk_emac_ptp";
 		};
+
+		pll_clk_sdh0: clock-pll_clk_sdh0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <50000000>;
+			clock-output-names = "pll_clk_sdh0";
+		};
+
+		pll_clk_sdh1: clock-pll_clk_sdh1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <50000000>;
+			clock-output-names = "pll_clk_sdh1";
+		};
+
+		pll_clk_sdh2: clock-pll_clk_sdh2 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <50000000>;
+			clock-output-names = "pll_clk_sdh2";
+		};
+
+		pll_clk_axi: clock-pll_clk_axi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <50000000>;
+			clock-output-names = "pll_clk_axi";
+		};
 	};
 
 	reserved-memory {
@@ -279,6 +308,48 @@ eth0: ethernet@cac80000 {
 			lpm-qos = <7>;
 			status = "disabled";
 		};
+
+		/* AXI */
+		axi@d4200000 {
+			compatible = "spacemit,axi-bus", "simple-bus";
+			reg = <0 0xd4200000 0 0x00200000>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+
+			sdhci2: sdh@d4281000 {
+				compatible = "spacemit,k1-x-sdhci";
+				reg = <0x0 0xd4281000 0x0 0x200>;
+				interrupts = <101>;
+				interrupt-parent = <&intc>;
+				clocks = <&pll_clk_sdh2
+					  &pll_clk_axi>;
+				clock-names = "sdh-io", "sdh-core";
+				status = "disabled";
+			};
+
+			sdhci0: sdh@d4280000 {
+				compatible = "spacemit,k1-x-sdhci";
+				reg = <0x0 0xd4280000 0x0 0x200>;
+				interrupts = <99>;
+				interrupt-parent = <&intc>;
+				clocks = <&pll_clk_sdh0
+					  &pll_clk_axi>;
+				clock-names = "sdh-io", "sdh-core";
+				status = "disabled";
+			};
+
+			sdhci1: sdh@d4280800 {
+				compatible = "spacemit,k1-x-sdhci";
+				reg = <0x0 0xd4280800 0x0 0x200>;
+				interrupts = <100>;
+				interrupt-parent = <&intc>;
+				clocks = <&pll_clk_sdh1
+					  &pll_clk_axi>;
+				clock-names = "sdh-io", "sdh-core";
+				status = "disabled";
+			};
+		}; /* AXI */
 	};
 
 	pmu {
diff --git a/arch/riscv/configs/k1-pro_fpga_defconfig b/arch/riscv/configs/k1-pro_fpga_defconfig
index 98ef1d8f2796..c338b36470e2 100644
--- a/arch/riscv/configs/k1-pro_fpga_defconfig
+++ b/arch/riscv/configs/k1-pro_fpga_defconfig
@@ -213,7 +213,7 @@ CONFIG_MMC=y
 # CONFIG_PWRSEQ_SIMPLE is not set
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_PLTFM=y
-CONFIG_MMC_SDHCI_OF_SPACEMIT=y
+CONFIG_MMC_SDHCI_OF_K1PRO=y
 CONFIG_SYNC_FILE=y
 CONFIG_SW_SYNC=y
 CONFIG_UDMABUF=y
diff --git a/arch/riscv/configs/k1-x_fpga_defconfig b/arch/riscv/configs/k1-x_fpga_defconfig
index 2f151bd94112..1d9b7ad5d684 100644
--- a/arch/riscv/configs/k1-x_fpga_defconfig
+++ b/arch/riscv/configs/k1-x_fpga_defconfig
@@ -128,6 +128,10 @@ CONFIG_MFD_SYSCON=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_HID_GENERIC is not set
 # CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_K1X=y
 CONFIG_DMADEVICES=y
 CONFIG_MMP_PDMA_SPACEMIT_K1X=y
 CONFIG_SYNC_FILE=y
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index 1cf64e0952fb..5472fe829859 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -377,6 +377,10 @@ int mmc_add_card(struct mmc_card *card)
 
 	device_enable_async_suspend(&card->dev);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (card->host->ops->encrypt_config)
+		card->host->ops->encrypt_config(card->host, 1);
+#endif
 	ret = device_add(&card->dev);
 	if (ret)
 		return ret;
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d996d39c0d6f..7bec1eb7d752 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1205,6 +1205,11 @@ int mmc_host_set_uhs_voltage(struct mmc_host *host)
 
 	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
 	mmc_delay(10);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	/* disable auto clock gate */
+	if (host->ops->auto_clk_gate)
+		host->ops->auto_clk_gate(host, 0);
+#endif
 	host->ios.clock = clock;
 	mmc_set_ios(host);
 
@@ -1266,6 +1271,11 @@ int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
 	if (host->ops->card_busy && host->ops->card_busy(host))
 		err = -EAGAIN;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	/* enable auto clock gate */
+	if (host->ops->auto_clk_gate)
+		host->ops->auto_clk_gate(host, 1);
+#endif
 power_cycle:
 	if (err) {
 		pr_debug("%s: Signal voltage switch failed, "
@@ -1430,6 +1440,12 @@ void _mmc_detect_change(struct mmc_host *host, unsigned long delay, bool cd_irq)
 		__pm_wakeup_event(host->ws, 5000);
 
 	host->detect_change = 1;
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (!(host->caps2 & MMC_CAP2_NO_MMC)) {
+		mmc_rescan(&host->detect.work);
+		return;
+	}
+#endif
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
@@ -2108,6 +2124,11 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 			return 0;
 	}
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->encrypt_config)
+		host->ops->encrypt_config(host, 0);
+#endif
+
 	/* Order's important: probe SDIO, then SD, then MMC */
 	if (!(host->caps2 & MMC_CAP2_NO_SDIO))
 		if (!mmc_attach_sdio(host))
@@ -2121,6 +2142,11 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 		if (!mmc_attach_mmc(host))
 			return 0;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->encrypt_config)
+		host->ops->encrypt_config(host, 1);
+#endif
+
 out:
 	mmc_power_off(host);
 	return -EIO;
@@ -2330,6 +2356,10 @@ void mmc_start_host(struct mmc_host *host)
 	}
 
 	mmc_gpiod_request_cd_irq(host);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->caps2 & MMC_CAP2_DISABLE_PROBE_SCAN)
+		return;
+#endif
 	_mmc_detect_change(host, 0, false);
 }
 
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 6a23be214543..c54609922a86 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1169,6 +1169,11 @@ static int mmc_select_hs400(struct mmc_card *card)
 	      host->ios.bus_width == MMC_BUS_WIDTH_8))
 		return 0;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->pre_select_hs400)
+		host->ops->pre_select_hs400(host);
+#endif
+
 	/* Switch card to HS mode */
 	val = EXT_CSD_TIMING_HS;
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
@@ -1238,6 +1243,11 @@ static int mmc_select_hs400(struct mmc_card *card)
 	if (host->ops->hs400_complete)
 		host->ops->hs400_complete(host);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->post_select_hs400)
+		host->ops->post_select_hs400(host);
+#endif
+
 	err = mmc_switch_status(card, true);
 	if (err)
 		goto out_err;
@@ -1296,6 +1306,10 @@ int mmc_hs400_to_hs200(struct mmc_card *card)
 	if (err)
 		goto out_err;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->pre_hs400_to_hs200)
+		host->ops->pre_hs400_to_hs200(host);
+#endif
 	/* Switch HS to HS200 */
 	val = EXT_CSD_TIMING_HS200 |
 	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
@@ -1427,6 +1441,9 @@ static int mmc_select_hs400es(struct mmc_card *card)
 
 	/* Set host controller to HS400 timing and frequency */
 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	mmc_set_bus_speed(card);
+#endif
 
 	/* Controller enable enhanced strobe function */
 	host->ios.enhanced_strobe = true;
@@ -2160,14 +2177,28 @@ static int mmc_suspend(struct mmc_host *host)
 static int _mmc_resume(struct mmc_host *host)
 {
 	int err = 0;
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	int retry = 3;
+#endif
 
 	mmc_claim_host(host);
 
 	if (!mmc_card_suspended(host->card))
 		goto out;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+retry_resume:
+#endif
 	mmc_power_up(host, host->card->ocr);
 	err = mmc_init_card(host, host->card->ocr, host->card);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (err && retry--) {
+		pr_err("%s: try to retry resume, err:%d\n",
+			mmc_hostname(host), err);
+		mmc_power_off(host);
+		goto retry_resume;
+	}
+#endif
 	mmc_card_clr_suspended(host->card);
 
 out:
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index cc757b850e79..b88ca9d3808d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1408,6 +1408,9 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	u32 rocr = 0;
 	bool v18_fixup_failed = false;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	u8 tuning_fail = 0;
+#endif
 	WARN_ON(!host->claimed);
 retry:
 	err = mmc_sd_get_cid(host, ocr, cid, &rocr);
@@ -1503,9 +1506,22 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		goto cont;
 	}
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (tuning_fail)
+		card->sw_caps.sd3_bus_mode &= ~SD_MODE_UHS_SDR104;
+#endif
 	/* Initialization sequence for UHS-I cards */
 	if (rocr & SD_ROCR_S18A && mmc_host_uhs(host)) {
 		err = mmc_sd_init_uhs_card(card);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+		if (err && err == -EIO) {
+			mmc_power_off(host);
+			mmc_delay(1);
+			mmc_power_up(host, host->ocr_avail);
+			tuning_fail = 1;
+			goto retry;
+		}
+#endif
 		if (err)
 			goto free_card;
 	} else {
@@ -1808,8 +1824,23 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 
 static int mmc_sd_hw_reset(struct mmc_host *host)
 {
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	int ret;
+	int sdr104;
+#endif
 	mmc_power_cycle(host, host->card->ocr);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	/* if all selected delaycode have crc, reset to DDR50 */
+	sdr104 = host->caps & MMC_CAP_UHS_SDR104;
+	if (sdr104)
+		host->caps &= ~MMC_CAP_UHS_SDR104;
+	ret = mmc_sd_init_card(host, host->card->ocr, host->card);
+	if (sdr104)
+		host->caps |= MMC_CAP_UHS_SDR104;
+	return ret;
+#else
 	return mmc_sd_init_card(host, host->card->ocr, host->card);
+#endif
 }
 
 static const struct mmc_bus_ops mmc_sd_ops = {
diff --git a/drivers/mmc/core/slot-gpio.c b/drivers/mmc/core/slot-gpio.c
index 12247219e1c2..e3456015f379 100644
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@ -16,6 +16,10 @@
 
 #include "slot-gpio.h"
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+#include <linux/regulator/consumer.h>
+#endif
+
 struct mmc_gpio {
 	struct gpio_desc *ro_gpio;
 	struct gpio_desc *cd_gpio;
@@ -32,6 +36,11 @@ static irqreturn_t mmc_gpio_cd_irqt(int irq, void *dev_id)
 	struct mmc_host *host = dev_id;
 	struct mmc_gpio *ctx = host->slot.handler_priv;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (!(host->caps2 & MMC_CAP2_NO_SD) && !IS_ERR(host->supply.vqmmc) &&
+		host->card && (host->ios.signal_voltage != MMC_SIGNAL_VOLTAGE_330))
+		regulator_set_voltage(host->supply.vqmmc, 3300000, 3600000);
+#endif
 	host->trigger_card_event = true;
 	mmc_detect_change(host, msecs_to_jiffies(ctx->cd_debounce_delay_ms));
 
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index e8003c9f81f5..45a8b7aa528a 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -274,14 +274,27 @@ config MMC_SDHCI_OF_MA35D1
 
 	  If unsure, say N.
 
-config MMC_SDHCI_OF_SPACEMIT
-	tristate "SDHCI OF support for the Spacemit SDHCI controllers"
+config MMC_SDHCI_OF_K1PRO
+	tristate "SDHCI OF support for the Spacemit K1PRO SDHCI controllers"
 	depends on MMC_SDHCI_PLTFM
 	depends on OF
 	depends on COMMON_CLK
 	help
 	  This selects the Secure Digital Host Controller Interface (SDHCI)
-	  found in the Spacemit SoC.
+	  found in the Spacemit SoC K1PRO.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_SDHCI_OF_K1X
+	tristate "SDHCI OF support for the Spacemit K1X SDHCI controllers"
+	depends on MMC_SDHCI_PLTFM
+	depends on OF
+	depends on COMMON_CLK
+	help
+	  This selects the Secure Digital Host Controller Interface (SDHCI)
+	  found in the Spacemit SoC K1X.
 
 	  If you have a controller with this interface, say Y or M here.
 
@@ -1125,3 +1138,4 @@ config MMC_LITEX
 	  module will be called litex_mmc.
 
 	  If unsure, say N.
+
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 66842ce6ef56..c58010147ba4 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -90,7 +90,8 @@ obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 obj-$(CONFIG_MMC_SDHCI_OF_DWCMSHC)	+= sdhci-of-dwcmshc.o
 obj-$(CONFIG_MMC_SDHCI_OF_SPARX5)	+= sdhci-of-sparx5.o
 obj-$(CONFIG_MMC_SDHCI_OF_MA35D1)	+= sdhci-of-ma35d1.o
-obj-$(CONFIG_MMC_SDHCI_OF_SPACEMIT)	+= sdhci-of-spacemit.o
+obj-$(CONFIG_MMC_SDHCI_OF_K1PRO)	+= sdhci-of-k1pro.o
+obj-$(CONFIG_MMC_SDHCI_OF_K1X)		+= sdhci-of-k1x.o
 obj-$(CONFIG_MMC_SDHCI_BCM_KONA)	+= sdhci-bcm-kona.o
 obj-$(CONFIG_MMC_SDHCI_IPROC)		+= sdhci-iproc.o
 obj-$(CONFIG_MMC_SDHCI_NPCM)		+= sdhci-npcm.o
diff --git a/drivers/mmc/host/sdhci-of-spacemit.c b/drivers/mmc/host/sdhci-of-k1pro.c
similarity index 100%
rename from drivers/mmc/host/sdhci-of-spacemit.c
rename to drivers/mmc/host/sdhci-of-k1pro.c
diff --git a/drivers/mmc/host/sdhci-of-k1x.c b/drivers/mmc/host/sdhci-of-k1x.c
new file mode 100644
index 000000000000..030bc3845fed
--- /dev/null
+++ b/drivers/mmc/host/sdhci-of-k1x.c
@@ -0,0 +1,1530 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for Spacemit Mobile Storage Host Controller
+ *
+ * Copyright (C) 2023 Spacemit
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_data/k1x_sdhci.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+
+#include "sdhci.h"
+#include "sdhci-pltfm.h"
+
+/* SDH registers define */
+#define SDHC_OP_EXT_REG			0x108
+#define OVRRD_CLK_OEN			0x0800
+#define FORCE_CLK_ON			0x1000
+
+#define SDHC_LEGACY_CTRL_REG		0x10C
+#define GEN_PAD_CLK_ON			0x0040
+
+#define SDHC_MMC_CTRL_REG		0x114
+#define MISC_INT_EN			0x0002
+#define MISC_INT			0x0004
+#define ENHANCE_STROBE_EN		0x0100
+#define MMC_HS400			0x0200
+#define MMC_HS200			0x0400
+#define MMC_CARD_MODE			0x1000
+
+#define SDHC_TX_CFG_REG			0x11C
+#define TX_INT_CLK_SEL			0x40000000
+#define TX_MUX_SEL			0x80000000
+
+#define SDHC_PHY_CTRL_REG		0x160
+#define PHY_FUNC_EN			0x0001
+#define PHY_PLL_LOCK			0x0002
+#define HOST_LEGACY_MODE		0x80000000
+
+#define SDHC_PHY_FUNC_REG		0x164
+#define PHY_TEST_EN			0x0080
+#define HS200_USE_RFIFO			0x8000
+
+#define SDHC_PHY_DLLCFG			0x168
+#define DLL_PREDLY_NUM			0x04
+#define DLL_FULLDLY_RANGE		0x10
+#define DLL_VREG_CTRL			0x40
+#define DLL_ENABLE			0x80000000
+#define DLL_REFRESH_SWEN_SHIFT		0x1C
+#define DLL_REFRESH_SW_SHIFT		0x1D
+
+#define SDHC_PHY_DLLCFG1		0x16C
+#define DLL_REG2_CTRL			0x0C
+#define DLL_REG3_CTRL_MASK		0xFF
+#define DLL_REG3_CTRL_SHIFT		0x08
+
+#define SDHC_PHY_DLLSTS			0x170
+#define DLL_LOCK_STATE			0x01
+
+#define SDHC_PHY_DLLSTS1		0x174
+#define DLL_MASTER_DELAY_MASK		0xFF
+#define DLL_MASTER_DELAY_SHIFT		0x10
+
+#define SDHC_PHY_PADCFG_REG		0x178
+#define RX_BIAS_CTRL_SHIFT		0x5
+
+#define RPM_DELAY			50
+#define MAX_74CLK_WAIT_COUNT		100
+
+#define MMC1_IO_V18EN			0x04
+#define AKEY_ASFAR			0xBABA
+#define AKEY_ASSAR			0xEB10
+
+#define SDHC_RX_CFG_REG			0x118
+#define RX_SDCLK_SEL0_MASK		0x03
+#define RX_SDCLK_SEL0_SHIFT		0x00
+#define RX_SDCLK_SEL0			0x02
+#define RX_SDCLK_SEL1_MASK		0x03
+#define RX_SDCLK_SEL1_SHIFT		0x02
+#define RX_SDCLK_SEL1			0x01
+
+#define SDHC_DLINE_CTRL_REG		0x130
+#define DLINE_PU			0x01
+#define RX_DLINE_CODE_MASK		0xFF
+#define RX_DLINE_CODE_SHIFT		0x10
+#define TX_DLINE_CODE_MASK		0xFF
+#define TX_DLINE_CODE_SHIFT		0x18
+
+#define SDHC_DLINE_CFG_REG		0x134
+#define RX_DLINE_REG_MASK		0xFF
+#define RX_DLINE_REG_SHIFT		0x00
+#define RX_DLINE_GAIN_MASK		0x1
+#define RX_DLINE_GAIN_SHIFT		0x8
+#define RX_DLINE_GAIN			0x1
+#define TX_DLINE_REG_MASK		0xFF
+#define TX_DLINE_REG_SHIFT		0x10
+
+#define SDHC_RX_TUNE_DELAY_MIN		0x0
+#define SDHC_RX_TUNE_DELAY_MAX		0xFF
+#define SDHC_RX_TUNE_DELAY_STEP		0x1
+
+static struct sdhci_host* sdio_host;
+
+struct sdhci_spacemit {
+	struct clk *clk_core;
+	struct clk *clk_io;
+	unsigned char power_mode;
+	struct pinctrl_state *pin;
+	struct pinctrl *pinctrl;
+};
+
+static int spacemit_reg[] = {
+	0x100, 0x104, 0x108, 0x10c, 0x110, 0x114, 0x118, 0x11c,
+	0x120, 0x124, 0x128, 0x12c, 0x130, 0x134, 0x160, 0x164,
+	0x168, 0x16c, 0x170, 0x174, 0x178, 0x17c, 0x180, 0x184,
+	0x188, 0x18c, 0x190, 0x1f0, 0x1f4, 0xFFF,
+};
+static u8 cur_com_reg[960]; /* 8 line, 120  character  per line */
+static u8 cur_pri_reg[960];
+static u8 pre_com_reg[960];
+static u8 pre_pri_reg[960];
+
+#define spacemit_monitor_cmd(cmd) (((cmd) == MMC_READ_SINGLE_BLOCK) || \
+				((cmd) == MMC_READ_MULTIPLE_BLOCK) || \
+				((cmd) == MMC_WRITE_BLOCK) || \
+				((cmd) == MMC_WRITE_MULTIPLE_BLOCK) || \
+				((cmd) == MMC_SWITCH) || \
+				((cmd) == MMC_ERASE))
+
+static const u32 tuning_patten4[16] = {
+	0x00ff0fff, 0xccc3ccff, 0xffcc3cc3, 0xeffefffe,
+	0xddffdfff, 0xfbfffbff, 0xff7fffbf, 0xefbdf777,
+	0xf0fff0ff, 0x3cccfc0f, 0xcfcc33cc, 0xeeffefff,
+	0xfdfffdff, 0xffbfffdf, 0xfff7ffbb, 0xde7b7ff7,
+};
+
+static const u32 tuning_patten8[32] = {
+	0xff00ffff, 0x0000ffff, 0xccccffff, 0xcccc33cc,
+	0xcc3333cc, 0xffffcccc, 0xffffeeff, 0xffeeeeff,
+	0xffddffff, 0xddddffff, 0xbbffffff, 0xbbffffff,
+	0xffffffbb, 0xffffff77, 0x77ff7777, 0xffeeddbb,
+	0x00ffffff, 0x00ffffff, 0xccffff00, 0xcc33cccc,
+	0x3333cccc, 0xffcccccc, 0xffeeffff, 0xeeeeffff,
+	0xddffffff, 0xddffffff, 0xffffffdd, 0xffffffbb,
+	0xffffbbbb, 0xffff77ff, 0xff7777ff, 0xeeddbb77,
+};
+
+static int is_recovery_boot;
+#ifndef MODULE
+static int __init recovery_boot_mode(char *str)
+{
+	if ((str != NULL) && (str[0] == '1'))
+		is_recovery_boot = 1;
+
+	return 0;
+}
+__setup("recovery=", recovery_boot_mode);
+#endif
+
+static void read_sdh_regs(struct sdhci_host *host, u8 *com_reg, u8 *pri_reg)
+{
+	int val;
+	int offset;
+	int i;
+	int len;
+	u8 *buf;
+
+	buf = com_reg;
+	len = 0;
+	i = 0;
+	for (offset = 0; offset < 0x70; offset += 4) {
+		val = sdhci_readl(host, offset);
+		if (i % 4 == 0)
+			len += sprintf(buf + len, "\n");
+		len += sprintf(buf + len, "\toffset:0x%03x 0x%08x\t", offset, val);
+		i++;
+	}
+
+	if (i % 4 == 0)
+		len += sprintf(buf + len, "\n");
+	val = sdhci_readl(host, 0xe0);
+	len += sprintf(buf + len, "\toffset:0x%03x 0x%08x\t", 0xe0, val);
+	val = sdhci_readl(host, 0xfc);
+	len += sprintf(buf + len, "\toffset:0x%03x 0x%08x\t\n", 0xfc, val);
+
+	buf = pri_reg;
+	len = 0;
+	i = 0;
+	do {
+		if (((host->mmc->caps2 & MMC_CAP2_NO_MMC) || (host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)) &&
+		    (spacemit_reg[i] > 0x134))
+			break;
+		val = sdhci_readl(host, spacemit_reg[i]);
+		if (i % 4 == 0)
+			len += sprintf(buf + len, "\n");
+		len += sprintf(buf + len, "\toffset:0x%03x 0x%08x\t", spacemit_reg[i], val);
+		i++;
+	} while (spacemit_reg[i] != 0xFFF);
+	len += sprintf(buf + len, "\n");
+}
+
+static void spacemit_reset_dllcfg1_reg(struct sdhci_host *host, u32 dllcfg1)
+{
+	u32 reg;
+
+	sdhci_writel(host, dllcfg1, SDHC_PHY_DLLCFG1);
+
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg |= 1 << DLL_REFRESH_SWEN_SHIFT;
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg |= 1 << DLL_REFRESH_SW_SHIFT;
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg &= ~(1 << DLL_REFRESH_SW_SHIFT);
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg &= ~(1 << DLL_REFRESH_SWEN_SHIFT);
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	udelay(1);
+}
+
+static void spacemit_handle_emmc_read_crc(struct sdhci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
+
+	u32 data;
+	u32 dllcfg1, dlldelay;
+	u32 dll_reg3_ctrl, dll_master_delay;
+
+	pdata->prev_dllcfg1 = pdata->curr_dllcfg1;
+	pdata->curr_dllcfg1 = sdhci_readl(host, SDHC_PHY_DLLCFG1);
+
+	dllcfg1 = pdata->curr_dllcfg1;
+	dll_reg3_ctrl = (dllcfg1 >> DLL_REG3_CTRL_SHIFT) & DLL_REG3_CTRL_MASK;
+	dlldelay = sdhci_readl(host, SDHC_PHY_DLLSTS1);
+	dll_master_delay = (dlldelay >> DLL_MASTER_DELAY_SHIFT) & DLL_MASTER_DELAY_MASK;
+
+	if (!dll_reg3_ctrl) {
+		/* first time reset */
+		data = dll_master_delay / 3;
+		pdata->dllcfg1_odd_reset = 1;
+	} else if (pdata->dllcfg1_odd_reset & 0x1) {
+		/* odd time */
+		data = 0xFF - (dll_master_delay - dll_reg3_ctrl) / 3;
+		pdata->dllcfg1_odd_reset = 2;
+	} else {
+		/* even time */
+		data = dll_master_delay + 0xFF - dll_reg3_ctrl;
+		data = data / 3;
+		pdata->dllcfg1_odd_reset = 1;
+	}
+
+	/* reset DLL_REG3_CTRL */
+	dllcfg1 &= (~(DLL_REG3_CTRL_MASK << DLL_REG3_CTRL_SHIFT));
+	dllcfg1 |= (data << DLL_REG3_CTRL_SHIFT);
+
+	if (unlikely(dllcfg1 == pdata->prev_dllcfg1)) {
+		/* reset the default: 0x0000000c */
+		pr_warn("%s: maybe fail to fix crc!\n", mmc_hostname(mmc));
+		/* debug purpose */
+		BUG_ON(1);
+		spacemit_reset_dllcfg1_reg(host, 0x0000000c);
+		pdata->new_dllcfg1 = 0x0000000c;
+		pdata->need_reset_dllcfg1 = 0;
+	} else {
+		spacemit_reset_dllcfg1_reg(host, dllcfg1);
+		pdata->new_dllcfg1 = dllcfg1;
+		pdata->need_reset_dllcfg1 = 1;
+	}
+}
+
+static void spacemit_handle_error_interrupt(struct sdhci_host *host, u32 status, u8 force)
+{
+	u32 cmd;
+
+	cmd = SDHCI_GET_CMD(sdhci_readw(host, SDHCI_COMMAND));
+	read_sdh_regs(host, &cur_com_reg[0], &cur_pri_reg[0]);
+
+	/* dump host register */
+	if (force) {
+		pr_err("%s dump host registers(cmd%d):%s",
+			mmc_hostname(host->mmc), cmd, cur_com_reg);
+		pr_err("%s", cur_pri_reg);
+	} else if ((status & SDHCI_INT_ERROR) && spacemit_monitor_cmd(cmd)) {
+		pr_err("%s cmd%d error(INT status:0x%08x), %s",
+				mmc_hostname(host->mmc), cmd, status,
+				cur_com_reg);
+		pr_err("%s", cur_pri_reg);
+
+#ifdef CONFIG_MMC_DEBUG
+		pr_err("register before cmd%d trigger %s", cmd, pre_com_reg);
+		pr_err("%s", pre_pri_reg);
+#endif
+	}
+
+	/* a workaround to handle eMMC read CRC on aquilac platform */
+	if (status & SDHCI_INT_DATA_CRC) {
+		if (cmd != MMC_READ_SINGLE_BLOCK &&
+			cmd != MMC_READ_MULTIPLE_BLOCK)
+			return;
+
+		if (host->mmc->caps2 & MMC_CAP2_CRC_SW_RETRY)
+			spacemit_handle_emmc_read_crc(host);
+	}
+}
+
+static void spacemit_save_sdhci_regs(struct sdhci_host *host, u32 cmd)
+{
+	if (host->mmc->card && spacemit_monitor_cmd(cmd))
+		read_sdh_regs(host, &pre_com_reg[0], &pre_pri_reg[0]);
+}
+
+void spacemit_sdio_detect_change(void)
+{
+	if (sdio_host)
+		mmc_detect_change(sdio_host->mmc, 0);
+}
+EXPORT_SYMBOL(spacemit_sdio_detect_change);
+
+static void spacemit_sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	struct platform_device *pdev;
+	struct k1x_sdhci_platdata *pdata;
+	unsigned int reg;
+
+	pdev = to_platform_device(mmc_dev(host->mmc));
+	pdata = pdev->dev.platform_data;
+	sdhci_reset(host, mask);
+
+	/* sd/sdio only be SDHCI_QUIRK2_BROKEN_PHY_MODULE */
+	if (!(host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)) {
+		if (host->quirks2 & SDHCI_QUIRK2_SUPPORT_PHY_BYPASS) {
+			/* use phy bypass */
+			reg = sdhci_readl(host, SDHC_TX_CFG_REG);
+			reg |= TX_INT_CLK_SEL;
+			sdhci_writel (host, reg, SDHC_TX_CFG_REG);
+
+			reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+			reg |= HOST_LEGACY_MODE;
+			sdhci_writel (host, reg, SDHC_PHY_CTRL_REG);
+
+			reg = sdhci_readl(host, SDHC_PHY_FUNC_REG);
+			reg |= PHY_TEST_EN;
+			sdhci_writel (host, reg, SDHC_PHY_FUNC_REG);
+		} else {
+			/* use phy func mode */
+			reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+			reg |= (PHY_FUNC_EN | PHY_PLL_LOCK);
+			sdhci_writel(host, reg, SDHC_PHY_CTRL_REG);
+
+			reg = sdhci_readl(host, SDHC_PHY_PADCFG_REG);
+			reg |= (1 << RX_BIAS_CTRL_SHIFT);
+			sdhci_writel(host, reg, SDHC_PHY_PADCFG_REG);
+		}
+	} else {
+		reg = sdhci_readl(host, SDHC_TX_CFG_REG);
+		reg |= TX_INT_CLK_SEL;
+		sdhci_writel (host, reg, SDHC_TX_CFG_REG);
+	}
+
+	/* for emmc */
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_MMC)) {
+		/* mmc card mode */
+		reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+		reg |= MMC_CARD_MODE;
+		sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+	}
+}
+
+static void spacemit_sdhci_gen_init_74_clocks(struct sdhci_host *host, u8 power_mode)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	unsigned int reg;
+	int count;
+
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_SDIO))
+		return;
+
+	if ((spacemit->power_mode == MMC_POWER_UP) &&
+		(power_mode == MMC_POWER_ON)) {
+		reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+		reg |= MISC_INT_EN;
+		sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+
+		reg = sdhci_readl(host, SDHC_LEGACY_CTRL_REG);
+		reg |= GEN_PAD_CLK_ON;
+		sdhci_writel(host, reg, SDHC_LEGACY_CTRL_REG);
+
+		count = 0;
+		while (count++ < MAX_74CLK_WAIT_COUNT) {
+			if (sdhci_readl(host, SDHC_MMC_CTRL_REG) & MISC_INT)
+				break;
+			udelay(10);
+		}
+
+		if (count == MAX_74CLK_WAIT_COUNT)
+			pr_warn("%s: gen 74 clock interrupt timeout\n",
+				mmc_hostname(host->mmc));
+
+		reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+		reg |= MISC_INT;
+		sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+	}
+	spacemit->power_mode = power_mode;
+}
+
+static void spacemit_sdhci_caps_disable(struct sdhci_host *host)
+{
+	struct platform_device *pdev;
+	struct k1x_sdhci_platdata *pdata;
+
+	pdev = to_platform_device(mmc_dev(host->mmc));
+	pdata = pdev->dev.platform_data;
+
+	if (pdata->host_caps_disable)
+		host->mmc->caps &= ~(pdata->host_caps_disable);
+	if (pdata->host_caps2_disable)
+		host->mmc->caps2 &= ~(pdata->host_caps2_disable);
+}
+
+static void spacemit_sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing)
+{
+	u16 reg;
+
+	if ((timing == MMC_TIMING_MMC_HS200) ||
+	    (timing == MMC_TIMING_MMC_HS400)) {
+		reg = sdhci_readw(host, SDHC_MMC_CTRL_REG);
+		reg |= (timing == MMC_TIMING_MMC_HS200) ? MMC_HS200 : MMC_HS400;
+		sdhci_writew(host, reg, SDHC_MMC_CTRL_REG);
+	}
+	sdhci_set_uhs_signaling(host, timing);
+}
+
+static void spacemit_sdhci_set_clk_gate(struct sdhci_host *host, unsigned int auto_gate)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHC_OP_EXT_REG);
+	if (auto_gate)
+		reg &= ~(OVRRD_CLK_OEN | FORCE_CLK_ON);
+	else
+		reg |= (OVRRD_CLK_OEN | FORCE_CLK_ON);
+	sdhci_writel(host, reg, SDHC_OP_EXT_REG);
+}
+
+static void spacemit_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	struct mmc_host *mmc = host->mmc;
+	unsigned int reg;
+
+	/* according to the SDHC_TX_CFG_REG(0x11c<bit>),
+	 * set TX_INT_CLK_SEL to gurantee the hold time
+	 * at default speed mode or HS/SDR12/SDR25/SDR50 mode.
+	 */
+	reg = sdhci_readl(host, SDHC_TX_CFG_REG);
+	if ((mmc->ios.timing == MMC_TIMING_LEGACY) ||
+	    (mmc->ios.timing == MMC_TIMING_SD_HS) ||
+	    (mmc->ios.timing == MMC_TIMING_UHS_SDR12) ||
+	    (mmc->ios.timing == MMC_TIMING_UHS_SDR25) ||
+	    (mmc->ios.timing == MMC_TIMING_UHS_SDR50) ||
+	    (mmc->ios.timing == MMC_TIMING_MMC_HS)) {
+		reg |= TX_INT_CLK_SEL;
+	} else {
+		reg &= ~TX_INT_CLK_SEL;
+	}
+	sdhci_writel(host, reg, SDHC_TX_CFG_REG);
+
+	/* set pinctrl state */
+	if (spacemit->pinctrl && !IS_ERR(spacemit->pinctrl)) {
+		if (clock >= 200000000) {
+			spacemit->pin = pinctrl_lookup_state(spacemit->pinctrl, "fast");
+			if (IS_ERR(spacemit->pin))
+				pr_warn("could not get sdhci pinctrl state.\n");
+			else
+				pinctrl_select_state(spacemit->pinctrl, spacemit->pin);
+
+		} else {
+			spacemit->pin = pinctrl_lookup_state(spacemit->pinctrl, "default");
+			if (IS_ERR(spacemit->pin))
+				pr_warn("could not get sdhci pinctrl state.\n");
+			else
+				pinctrl_select_state(spacemit->pinctrl, spacemit->pin);
+		}
+	}
+
+	sdhci_set_clock(host, clock);
+};
+
+static int spacemit_sdhci_enable_dma(struct sdhci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct device *dev = mmc_dev(mmc);
+	int ret = -EINVAL;
+
+#ifdef CONFIG_AQUILAC_STPU
+	if (host->flags & SDHCI_USE_64_BIT_DMA) {
+		ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+		if (ret) {
+			pr_warn("%s: Failed to set 64-bit DMA mask.\n", mmc_hostname(mmc));
+			host->flags &= ~SDHCI_USE_64_BIT_DMA;
+		}
+	}
+
+	if (ret) {
+		ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
+		if (ret)
+			pr_warn("%s: Failed to set 32-bit DMA mask.\n", mmc_hostname(mmc));
+	}
+#else
+	/* set 64-bit DMA mask on stpu-evb */
+	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (ret) {
+		pr_warn("%s: Failed to set 64-bit DMA mask.\n", mmc_hostname(mmc));
+		host->flags &= ~SDHCI_USE_64_BIT_DMA;
+	}
+#endif
+
+	return ret;
+}
+
+static void spacemit_sdhci_phy_dll_init(struct sdhci_host *host)
+{
+	u32 reg;
+	int i;
+
+	/* config dll_reg1 & dll_reg2 */
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg |= (DLL_PREDLY_NUM | DLL_FULLDLY_RANGE | DLL_VREG_CTRL);
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG1);
+	reg |= DLL_REG2_CTRL;
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG1);
+
+	/* dll enable */
+	reg = sdhci_readl(host, SDHC_PHY_DLLCFG);
+	reg |= DLL_ENABLE;
+	sdhci_writel(host, reg, SDHC_PHY_DLLCFG);
+
+	/* wait dll lock */
+	i = 0;
+	while (i++ < 100) {
+		if (sdhci_readl(host, SDHC_PHY_DLLSTS) & DLL_LOCK_STATE)
+			break;
+		udelay(10);
+	}
+	if (i == 100)
+		pr_err("%s: dll lock timeout\n", mmc_hostname(host->mmc));
+}
+
+static void spacemit_sdhci_hs400_enhanced_strobe(struct mmc_host *mmc,
+					struct mmc_ios *ios)
+{
+	u32 reg;
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+	if (ios->enhanced_strobe)
+		reg |= ENHANCE_STROBE_EN;
+	else
+		reg &= ~ENHANCE_STROBE_EN;
+	sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+
+	if (ios->enhanced_strobe)
+		spacemit_sdhci_phy_dll_init(host);
+}
+
+static void spacemit_set_aib_mmc1_io(struct sdhci_host *host, int vol)
+{
+	void __iomem *aib_mmc1_io;
+	void __iomem *apbc_asfar;
+	void __iomem *apbc_assar;
+	u32 reg;
+	struct platform_device *pdev;
+	struct k1x_sdhci_platdata *pdata;
+
+	pdev = to_platform_device(mmc_dev(host->mmc));
+	pdata = pdev->dev.platform_data;
+
+	if (!pdata->aib_mmc1_io_reg ||
+	    !pdata->apbc_asfar_reg ||
+	    !pdata->apbc_assar_reg)
+		return;
+
+	aib_mmc1_io = ioremap(pdata->aib_mmc1_io_reg, 4);
+	apbc_asfar = ioremap(pdata->apbc_asfar_reg, 4);
+	apbc_assar = ioremap(pdata->apbc_assar_reg, 4);
+
+	writel(AKEY_ASFAR, apbc_asfar);
+	writel(AKEY_ASSAR, apbc_assar);
+	reg = readl(aib_mmc1_io);
+
+	switch (vol) {
+	case MMC_SIGNAL_VOLTAGE_180:
+		reg |= MMC1_IO_V18EN;
+		break;
+	default:
+		reg &= ~MMC1_IO_V18EN;
+		break;
+	}
+	writel(AKEY_ASFAR, apbc_asfar);
+	writel(AKEY_ASSAR, apbc_assar);
+	writel(reg, aib_mmc1_io);
+
+	iounmap(apbc_assar);
+	iounmap(apbc_asfar);
+	iounmap(aib_mmc1_io);
+}
+
+static void spacemit_sdhci_voltage_switch(struct sdhci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_ios ios = mmc->ios;
+
+	/*
+	 * v18en(MS) bit should meet TSMC's requirement when switch SOC SD
+	 * IO voltage from 3.3(3.0)v to 1.8v
+	 */
+	if (host->quirks2 & SDHCI_QUIRK2_SET_AIB_MMC)
+		spacemit_set_aib_mmc1_io(host, ios.signal_voltage);
+}
+
+static void spacemit_sw_rx_tuning_prepare(struct sdhci_host *host, u8 dline_reg)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_ios ios = mmc->ios;
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_DLINE_CFG_REG);
+	reg &= ~(RX_DLINE_REG_MASK << RX_DLINE_REG_SHIFT);
+	reg |= dline_reg << RX_DLINE_REG_SHIFT;
+
+	if (host->quirks2 & SDHCI_QUIRK2_SUPPORT_ENCRYPT) {
+		/* this RX_DLINE_GAIN bit is used for crypto module */
+	} else {
+		reg &= ~(RX_DLINE_GAIN_MASK << RX_DLINE_GAIN_SHIFT);
+		if ((ios.timing == MMC_TIMING_UHS_SDR50) && (reg & 0x40))
+			reg |= RX_DLINE_GAIN << RX_DLINE_GAIN_SHIFT;
+	}
+	sdhci_writel(host, reg, SDHC_DLINE_CFG_REG);
+
+	reg = sdhci_readl(host, SDHC_DLINE_CTRL_REG);
+	reg |= DLINE_PU;
+	sdhci_writel(host, reg, SDHC_DLINE_CTRL_REG);
+	udelay(5);
+
+	reg = sdhci_readl(host, SDHC_RX_CFG_REG);
+	reg &= ~(RX_SDCLK_SEL1_MASK << RX_SDCLK_SEL1_SHIFT);
+	reg |= RX_SDCLK_SEL1 << RX_SDCLK_SEL1_SHIFT;
+	sdhci_writel(host, reg, SDHC_RX_CFG_REG);
+
+	if ((mmc->ios.timing == MMC_TIMING_MMC_HS200)
+		&& !(host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)) {
+		reg = sdhci_readl(host, SDHC_PHY_FUNC_REG);
+		reg |= HS200_USE_RFIFO;
+		sdhci_writel(host, reg, SDHC_PHY_FUNC_REG);
+	}
+}
+
+static void spacemit_sw_rx_set_delaycode(struct sdhci_host *host, u32 delay)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_DLINE_CTRL_REG);
+	reg &= ~(RX_DLINE_CODE_MASK << RX_DLINE_CODE_SHIFT);
+	reg |= (delay & RX_DLINE_CODE_MASK) << RX_DLINE_CODE_SHIFT;
+	sdhci_writel(host, reg, SDHC_DLINE_CTRL_REG);
+}
+
+static void spacemit_sw_tx_tuning_prepare(struct sdhci_host *host)
+{
+	u32 reg;
+
+	/* set TX_MUX_SEL */
+	reg = sdhci_readl(host, SDHC_TX_CFG_REG);
+	reg |= TX_MUX_SEL;
+	sdhci_writel(host, reg, SDHC_TX_CFG_REG);
+
+	reg = sdhci_readl(host, SDHC_DLINE_CTRL_REG);
+	reg |= DLINE_PU;
+	sdhci_writel(host, reg, SDHC_DLINE_CTRL_REG);
+	udelay(5);
+}
+
+static void spacemit_sw_tx_set_dlinereg(struct sdhci_host *host, u8 dline_reg)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_DLINE_CFG_REG);
+	reg &= ~(TX_DLINE_REG_MASK << TX_DLINE_REG_SHIFT);
+	reg |= dline_reg << TX_DLINE_REG_SHIFT;
+	sdhci_writel(host, reg, SDHC_DLINE_CFG_REG);
+}
+
+static void spacemit_sw_tx_set_delaycode(struct sdhci_host *host, u32 delay)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_DLINE_CTRL_REG);
+	reg &= ~(TX_DLINE_CODE_MASK << TX_DLINE_CODE_SHIFT);
+	reg |= (delay & TX_DLINE_CODE_MASK) << TX_DLINE_CODE_SHIFT;
+	sdhci_writel(host, reg, SDHC_DLINE_CTRL_REG);
+}
+
+static void spacemit_sdhci_clear_set_irqs(struct sdhci_host *host, u32 clr, u32 set)
+{
+	u32 ier;
+
+	ier = sdhci_readl(host, SDHCI_INT_ENABLE);
+	ier &= ~clr;
+	ier |= set;
+	sdhci_writel(host, ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static int spacemit_tuning_patten_check(struct sdhci_host *host, int point)
+{
+	u32 read_patten;
+	unsigned int i;
+	u32 *tuning_patten;
+	int patten_len;
+	int err = 0;
+
+	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_8) {
+		tuning_patten = (u32 *)tuning_patten8;
+		patten_len = ARRAY_SIZE(tuning_patten8);
+	} else {
+		tuning_patten = (u32 *)tuning_patten4;
+		patten_len = ARRAY_SIZE(tuning_patten4);
+	}
+
+	for (i = 0; i < patten_len; i++) {
+		read_patten = sdhci_readl(host, SDHCI_BUFFER);
+		if (read_patten != tuning_patten[i])
+			err++;
+	}
+
+	return err;
+}
+
+static int spacemit_send_tuning_cmd(struct sdhci_host *host, u32 opcode,
+					int point, unsigned long flags)
+{
+	int err = 0;
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	sdhci_send_tuning(host, opcode);
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!host->tuning_done) {
+		pr_err("%s: Timeout waiting for Buffer Read Ready interrupt "
+			"during tuning procedure, resetting CMD and DATA\n",
+			mmc_hostname(host->mmc));
+		sdhci_reset(host, SDHCI_RESET_CMD|SDHCI_RESET_DATA);
+		err = -EIO;
+	} else
+		err = spacemit_tuning_patten_check(host, point);
+
+	host->tuning_done = 0;
+	return err;
+}
+
+static int spacemit_sw_rx_select_window(struct sdhci_host *host, u32 opcode)
+{
+	int min;
+	int max;
+	u16 ctrl;
+	u32 ier;
+	unsigned long flags = 0;
+	int err = 0;
+	struct tuning_window *window;
+	struct mmc_host *mmc = host->mmc;
+	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
+	struct rx_tuning *rxtuning = &pdata->rxtuning;
+
+	/* change to pio mode during the tuning stage */
+	spin_lock_irqsave(&host->lock, flags);
+	ier = sdhci_readl(host, SDHCI_INT_ENABLE);
+	spacemit_sdhci_clear_set_irqs(host, ier, SDHCI_INT_DATA_AVAIL);
+
+	window = &rxtuning->windows[WINDOW_1ST];
+	min = SDHC_RX_TUNE_DELAY_MIN;
+	do {
+		/* find the mininum delay first which can pass tuning */
+		while (min < SDHC_RX_TUNE_DELAY_MAX) {
+			spacemit_sw_rx_set_delaycode(host, min);
+			if (!mmc->ops->get_cd(mmc)) {
+				spin_unlock_irqrestore(&host->lock, flags);
+				return -ENODEV;
+			}
+			err = spacemit_send_tuning_cmd(host, opcode, min, flags);
+			if (err == -EIO) {
+				spin_unlock_irqrestore(&host->lock, flags);
+				return -EIO;
+			}
+			if (!err)
+				break;
+			ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+			ctrl &= ~(SDHCI_CTRL_TUNED_CLK | SDHCI_CTRL_EXEC_TUNING);
+			sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+			min += SDHC_RX_TUNE_DELAY_STEP;
+		}
+
+		/* find the maxinum delay which can not pass tuning */
+		max = min + SDHC_RX_TUNE_DELAY_STEP;
+		while (max < SDHC_RX_TUNE_DELAY_MAX) {
+			spacemit_sw_rx_set_delaycode(host, max);
+			if (!mmc->ops->get_cd(mmc)) {
+				spin_unlock_irqrestore(&host->lock, flags);
+				return -ENODEV;
+			}
+			err = spacemit_send_tuning_cmd(host, opcode, max, flags);
+			if (err) {
+				ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+				ctrl &= ~(SDHCI_CTRL_TUNED_CLK | SDHCI_CTRL_EXEC_TUNING);
+				sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+				if (err == -EIO) {
+					spin_unlock_irqrestore(&host->lock, flags);
+					return -EIO;
+				}
+				break;
+			}
+			max += SDHC_RX_TUNE_DELAY_STEP;
+		}
+
+		pr_debug("%s: pass window [%d %d) \n", mmc_hostname(host->mmc), min, max);
+		/* store the top 3 window */
+		if ((max - min) >= rxtuning->window_limit) {
+			window->max_delay = max;
+			window->min_delay = min;
+			window->type = LEFT_WINDOW;
+			if (window == &rxtuning->windows[WINDOW_3RD])
+				break;
+			else
+				window++;
+		}
+		min = max + SDHC_RX_TUNE_DELAY_STEP;
+	} while (min < SDHC_RX_TUNE_DELAY_MAX);
+
+	spacemit_sdhci_clear_set_irqs(host, SDHCI_INT_DATA_AVAIL, ier);
+	spin_unlock_irqrestore(&host->lock, flags);
+	return 0;
+}
+
+static int spacemit_sw_rx_select_delay(struct sdhci_host *host)
+{
+	int i;
+	int win_len, min, max, mid;
+	struct tuning_window *window;
+
+	struct mmc_host *mmc = host->mmc;
+	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
+	struct rx_tuning *tuning = &pdata->rxtuning;
+
+	for (i = 0; i < CANDIDATE_WIN_NUM; i++) {
+		window = &tuning->windows[i];
+		min = window->min_delay;
+		max = window->max_delay;
+		mid = (min + max - 1) / 2;
+		win_len = max - min;
+		if (win_len < tuning->window_limit)
+			continue;
+
+		if (window->type == LEFT_WINDOW) {
+			tuning->select_delay[tuning->select_delay_num++] = min + win_len / 4;
+			tuning->select_delay[tuning->select_delay_num++] = min + win_len / 3;
+		} else if (window->type == RIGHT_WINDOW) {
+			tuning->select_delay[tuning->select_delay_num++] = max - win_len / 4;
+			tuning->select_delay[tuning->select_delay_num++] = min - win_len / 3;
+		} else {
+			tuning->select_delay[tuning->select_delay_num++] = mid;
+			tuning->select_delay[tuning->select_delay_num++] = mid + win_len / 4;
+			tuning->select_delay[tuning->select_delay_num++] = mid - win_len / 4;
+		}
+	}
+
+	return tuning->select_delay_num;
+}
+
+static void spacemit_sw_rx_card_store(struct sdhci_host *host, struct rx_tuning *tuning)
+{
+	struct mmc_card *card = host->mmc->card;
+
+	if (card)
+		memcpy(tuning->card_cid, card->raw_cid, sizeof(card->raw_cid));
+}
+
+static int spacemit_sw_rx_card_pretuned(struct sdhci_host *host, struct rx_tuning *tuning)
+{
+	struct mmc_card *card = host->mmc->card;
+
+	if (!card)
+		return 0;
+
+	return !memcmp(tuning->card_cid, card->raw_cid, sizeof(card->raw_cid));
+}
+
+static int spacemit_sdhci_execute_sw_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int ret;
+	int index;
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_ios ios = mmc->ios;
+	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
+	struct rx_tuning *rxtuning = &pdata->rxtuning;
+
+	/*
+	 * Tuning is required for SDR50/SDR104, HS200/HS400 cards and
+	 * if clock frequency is greater than 100MHz in these modes.
+	 */
+	if (host->clock < 100 * 1000 * 1000 ||
+	    !((ios.timing == MMC_TIMING_MMC_HS200) ||
+	      (ios.timing == MMC_TIMING_UHS_SDR50) ||
+	      (ios.timing == MMC_TIMING_UHS_SDR104)))
+		return 0;
+
+	if (!(mmc->caps2 & MMC_CAP2_NO_SD) && !mmc->ops->get_cd(mmc)) {
+		return 0;
+	}
+
+	/* TX tuning config */
+	if ((host->mmc->caps2 & MMC_CAP2_NO_MMC) || (host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)) {
+		spacemit_sw_tx_set_dlinereg(host, pdata->tx_dline_reg);
+		spacemit_sw_tx_set_delaycode(host, pdata->tx_delaycode);
+		spacemit_sw_tx_tuning_prepare(host);
+	}
+
+	/* step 1: check pretuned card */
+	if (spacemit_sw_rx_card_pretuned(host, rxtuning) &&
+	    rxtuning->select_delay_num) {
+		index = rxtuning->current_delay_index;
+		if (mmc->doing_retune)
+			index++;
+		if (index == rxtuning->select_delay_num) {
+			pr_info("%s: all select delay failed, re-init to DDR50\n", mmc_hostname(mmc));
+			rxtuning->select_delay_num = 0;
+			rxtuning->current_delay_index = 0;
+			memset(rxtuning->windows, 0, sizeof(rxtuning->windows));
+			memset(rxtuning->select_delay, 0xFF, sizeof(rxtuning->select_delay));
+			memset(rxtuning->card_cid, 0, sizeof(rxtuning->card_cid));
+			return -EIO;
+		}
+
+		spacemit_sw_rx_tuning_prepare(host, rxtuning->rx_dline_reg);
+		spacemit_sw_rx_set_delaycode(host, rxtuning->select_delay[index]);
+		pr_info("%s: pretuned card, use select_delay[%d]:%d\n",
+			mmc_hostname(mmc), index, rxtuning->select_delay[index]);
+		rxtuning->current_delay_index = index;
+		return 0;
+	}
+
+	rxtuning->select_delay_num = 0;
+	rxtuning->current_delay_index = 0;
+	memset(rxtuning->windows, 0, sizeof(rxtuning->windows));
+	memset(rxtuning->select_delay, 0xFF, sizeof(rxtuning->select_delay));
+	memset(rxtuning->card_cid, 0, sizeof(rxtuning->card_cid));
+
+	/* step 2: get pass window and caculate the select_delay */
+	spacemit_sw_rx_tuning_prepare(host, rxtuning->rx_dline_reg);
+	ret = spacemit_sw_rx_select_window(host, opcode);
+
+	if (ret) {
+		pr_warn("%s: abort tuning, err:%d\n", mmc_hostname(mmc), ret);
+		return ret;
+	}
+
+	if (!spacemit_sw_rx_select_delay(host)) {
+		pr_warn("%s: fail to get delaycode\n", mmc_hostname(mmc));
+		return -EIO;
+	}
+
+	/* step 3: set the delay code and store card cid */
+	spacemit_sw_rx_set_delaycode(host, rxtuning->select_delay[0]);
+	spacemit_sw_rx_card_store(host, rxtuning);
+	pr_info("%s: tuning done, use the firstly delay_code:%d\n",
+		mmc_hostname(mmc), rxtuning->select_delay[0]);
+	return 0;
+}
+
+static unsigned int spacemit_sdhci_clk_get_max_clock(struct sdhci_host *host)
+{
+	unsigned long rate;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+
+	rate = clk_get_rate(pltfm_host->clk);
+	return rate;
+}
+
+static unsigned int spacemit_get_max_timeout_count(struct sdhci_host *host)
+{
+	/*
+	 * the default sdhci code use the 1 << 27 as the max timeout counter
+	 * to calculate the max_busy_timeout.
+	 * aquilac sdhci support 1 << 29 as the timeout counter.
+	 */
+	return 1 << 29;
+}
+
+static void spacemit_sdhci_pre_select_hs400(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+	reg |= MMC_HS400;
+	sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+	host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;
+}
+
+static void spacemit_sdhci_post_select_hs400(struct sdhci_host *host)
+{
+	spacemit_sdhci_phy_dll_init(host);
+	host->mmc->caps &= ~MMC_CAP_WAIT_WHILE_BUSY;
+}
+
+static void spacemit_sdhci_pre_hs400_to_hs200(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+	reg &= ~(PHY_FUNC_EN | PHY_PLL_LOCK);
+	sdhci_writel(host, reg, SDHC_PHY_CTRL_REG);
+
+	reg = sdhci_readl(host, SDHC_MMC_CTRL_REG);
+	reg &= ~(MMC_HS400 | MMC_HS200 | ENHANCE_STROBE_EN);
+	sdhci_writel(host, reg, SDHC_MMC_CTRL_REG);
+
+	reg = sdhci_readl(host, SDHC_PHY_FUNC_REG);
+	reg &= ~HS200_USE_RFIFO;
+	sdhci_writel(host, reg, SDHC_PHY_FUNC_REG);
+
+	udelay(5);
+
+	reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+	reg |= (PHY_FUNC_EN | PHY_PLL_LOCK);
+	sdhci_writel(host, reg, SDHC_PHY_CTRL_REG);
+}
+
+static void spacemit_sdhci_reset_dllcfg1(struct sdhci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct k1x_sdhci_platdata *pdata = mmc->parent->platform_data;
+
+	if (sdhci_readl(host, SDHC_PHY_DLLCFG1) == pdata->new_dllcfg1)
+		return;
+	if (!pdata->need_reset_dllcfg1)
+		return;
+
+	spacemit_reset_dllcfg1_reg(host, pdata->new_dllcfg1);
+}
+
+static void spacemit_sdhci_set_encrypt(struct sdhci_host *host, unsigned int enc_flag)
+{
+	u32 reg;
+
+	if ((host->quirks2 & SDHCI_QUIRK2_SUPPORT_ENCRYPT)) {
+		reg = sdhci_readl(host, SDHC_DLINE_CFG_REG);
+		if (enc_flag)
+			reg &= ~(0x1 << 8);
+		else
+			reg |= (0x1 << 8);
+		sdhci_writel(host, reg, SDHC_DLINE_CFG_REG);
+	}
+}
+
+static const struct sdhci_ops spacemit_sdhci_ops = {
+	.set_clock = spacemit_sdhci_set_clock,
+	.enable_dma = spacemit_sdhci_enable_dma,
+	.platform_send_init_74_clocks = spacemit_sdhci_gen_init_74_clocks,
+	.get_max_clock = spacemit_sdhci_clk_get_max_clock,
+	.get_max_timeout_count = spacemit_get_max_timeout_count,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset = spacemit_sdhci_reset,
+	.set_uhs_signaling = spacemit_sdhci_set_uhs_signaling,
+	.voltage_switch = spacemit_sdhci_voltage_switch,
+	.platform_execute_tuning = spacemit_sdhci_execute_sw_tuning,
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	.caps_disable = spacemit_sdhci_caps_disable,
+	.set_auto_clk_gate  = spacemit_sdhci_set_clk_gate,
+	.error_handle = spacemit_handle_error_interrupt,
+	.save_register = spacemit_save_sdhci_regs,
+	.pre_select_hs400 = spacemit_sdhci_pre_select_hs400,
+	.post_select_hs400 = spacemit_sdhci_post_select_hs400,
+	.pre_hs400_to_hs200 = spacemit_sdhci_pre_hs400_to_hs200,
+	.reset_dllcfg1 = spacemit_sdhci_reset_dllcfg1,
+	.set_encrypt_feature = spacemit_sdhci_set_encrypt,
+#endif
+};
+
+static struct sdhci_pltfm_data sdhci_k1x_pdata = {
+	.ops = &spacemit_sdhci_ops,
+	.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
+		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC
+		| SDHCI_QUIRK_32BIT_ADMA_SIZE
+		| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+};
+
+static const struct of_device_id sdhci_spacemit_of_match[] = {
+	{
+		.compatible = "spacemit,k1-x-sdhci",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sdhci_spacemit_of_match);
+
+static struct k1x_sdhci_platdata *spacemit_get_mmc_pdata(struct device *dev)
+{
+	struct k1x_sdhci_platdata *pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+	return pdata;
+}
+
+static void spacemit_get_of_property(struct sdhci_host *host,
+		struct device *dev, struct k1x_sdhci_platdata *pdata)
+{
+	struct device_node *np = dev->of_node;
+	u32 property;
+
+	/* sdh io clk */
+	if (!of_property_read_u32(np, "spacemit,sdh-freq", &property))
+		pdata->host_freq = property;
+
+	if (!of_property_read_u32(np, "spacemit,sdh-flags", &property))
+		pdata->flags |= property;
+
+	if (!of_property_read_u32(np, "spacemit,sdh-host-caps", &property))
+		pdata->host_caps |= property;
+	if (!of_property_read_u32(np, "spacemit,sdh-host-caps2", &property))
+		pdata->host_caps2 |= property;
+
+	if (!of_property_read_u32(np, "spacemit,sdh-host-caps-disable", &property))
+		pdata->host_caps_disable |= property;
+	if (!of_property_read_u32(np, "spacemit,sdh-host-caps2-disable", &property))
+		pdata->host_caps2_disable |= property;
+
+	if (!of_property_read_u32(np, "spacemit,sdh-quirks", &property))
+		pdata->quirks |= property;
+	if (!of_property_read_u32(np, "spacemit,sdh-quirks2", &property))
+		pdata->quirks2 |= property;
+
+	pdata->aib_mmc1_io_reg = 0x0;
+	pdata->apbc_asfar_reg = 0x0;
+	pdata->apbc_assar_reg = 0x0;
+	if (!of_property_read_u32(np, "spacemit,aib_mmc1_io_reg", &property))
+		pdata->aib_mmc1_io_reg = property;
+	if (!of_property_read_u32(np, "spacemit,apbc_asfar_reg", &property))
+		pdata->apbc_asfar_reg = property;
+	if (!of_property_read_u32(np, "spacemit,apbc_assar_reg", &property))
+		pdata->apbc_assar_reg = property;
+
+	/* read rx tuning dline_reg */
+	if (!of_property_read_u32(np, "spacemit,rx_dline_reg", &property))
+		pdata->rxtuning.rx_dline_reg = (u8)property;
+	else
+		pdata->rxtuning.rx_dline_reg = RX_TUNING_DLINE_REG;
+
+	/* read rx tuning window limit */
+	if (!of_property_read_u32(np, "spacemit,rx_tuning_limit", &property))
+		pdata->rxtuning.window_limit = (u8)property;
+	else
+		pdata->rxtuning.window_limit = RX_TUNING_WINDOW_THRESHOLD;
+
+	/* tx tuning dline_reg */
+	if (!of_property_read_u32(np, "spacemit,tx_dline_reg", &property))
+		pdata->tx_dline_reg = (u8)property;
+	else
+		pdata->tx_dline_reg = TX_TUNING_DLINE_REG;
+	if (!of_property_read_u32(np, "spacemit,tx_delaycode", &property))
+		pdata->tx_delaycode = (u8)property;
+	else
+		pdata->tx_delaycode = TX_TUNING_DELAYCODE;
+
+	return;
+}
+
+#ifdef CONFIG_SPACEMIT_SW_JTAG
+extern void switch_jtag_tapctl(unsigned int tap_ctl);
+#endif
+#define SD_PMUX_SYSFS "/sys/devices/platform/soc/d4200000.axi/d4280000.sdh/sd_card_pmux"
+ssize_t sdhci_sysfs_pmux_set(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	char pinname[16];
+
+	if (spacemit == NULL || spacemit->pinctrl == NULL) {
+		pr_err("could not set sd pinctrl.\n");
+		return count;
+	}
+
+	if (!strncmp(buf, "jtag", strlen("jtag"))) {
+		strncpy(pinname, "jtag", strlen("jtag") + 1);
+		spacemit_set_aib_mmc1_io(host, MMC_SIGNAL_VOLTAGE_180);
+#ifdef CONFIG_SPACEMIT_SW_JTAG
+		/* switch tap_ctl as seconod jtag by sw_jtag */
+		switch_jtag_tapctl(0x42);
+#endif
+	} else if (!strncmp(buf, "default", strlen("default"))) {
+		strncpy(pinname, "default", strlen("default") + 1);
+		spacemit_set_aib_mmc1_io(host, MMC_SIGNAL_VOLTAGE_330);
+#ifdef CONFIG_SPACEMIT_SW_JTAG
+		/* switch tap_ctl as primary jtag by sw_jtag */
+		switch_jtag_tapctl(0x0a);
+#endif
+	} else {
+		pr_info("usage: echo [jtag | default] > %s\n", SD_PMUX_SYSFS);
+		return count;
+	}
+
+	spacemit->pin = pinctrl_lookup_state(spacemit->pinctrl, pinname);
+	if (IS_ERR(spacemit->pin)) {
+		pr_err("could not get sdhci pinctrl state.\n");
+		return count;
+	}
+	pinctrl_select_state(spacemit->pinctrl, spacemit->pin);
+	msleep(1);
+
+	return count;
+}
+
+static struct device_attribute sdhci_sysfs_files[] = {
+	__ATTR(sd_card_pmux, S_IWUSR, NULL, sdhci_sysfs_pmux_set),
+};
+
+static int spacemit_sdhci_probe(struct platform_device *pdev)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct device *dev = &pdev->dev;
+	struct sdhci_host *host;
+	const struct of_device_id *match;
+	int i;
+	struct sdhci_spacemit *spacemit;
+	struct k1x_sdhci_platdata *pdata;
+	int ret;
+
+	host = sdhci_pltfm_init(pdev, &sdhci_k1x_pdata, sizeof(*spacemit));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+
+	spacemit = sdhci_pltfm_priv(pltfm_host);
+
+	spacemit->clk_io = devm_clk_get(dev, "sdh-io");
+	if (IS_ERR(spacemit->clk_io))
+		spacemit->clk_io = devm_clk_get(dev, NULL);
+	if (IS_ERR(spacemit->clk_io)) {
+		dev_err(dev, "failed to get io clock\n");
+		ret = PTR_ERR(spacemit->clk_io);
+		goto err_clk_get;
+	}
+	pltfm_host->clk = spacemit->clk_io;
+	clk_prepare_enable(spacemit->clk_io);
+
+	spacemit->clk_core = devm_clk_get(dev, "sdh-core");
+	if (!IS_ERR(spacemit->clk_core))
+		clk_prepare_enable(spacemit->clk_core);
+
+	match = of_match_device(of_match_ptr(sdhci_spacemit_of_match), &pdev->dev);
+	if (match) {
+		ret = mmc_of_parse(host->mmc);
+		if (ret)
+			goto err_of_parse;
+		sdhci_get_of_property(pdev);
+	}
+
+	pdata = pdev->dev.platform_data ? pdev->dev.platform_data : spacemit_get_mmc_pdata(dev);
+	if (IS_ERR_OR_NULL(pdata))
+		goto err_of_parse;
+
+	spacemit_get_of_property(host, dev, pdata);
+	if (pdata->quirks)
+		host->quirks |= pdata->quirks;
+	if (pdata->quirks2)
+		host->quirks2 |= pdata->quirks2;
+	if (pdata->host_caps)
+		host->mmc->caps |= pdata->host_caps;
+	if (pdata->host_caps2)
+		host->mmc->caps2 |= pdata->host_caps2;
+	if (pdata->pm_caps)
+		host->mmc->pm_caps |= pdata->pm_caps;
+	pdev->dev.platform_data = pdata;
+
+	if (host->mmc->pm_caps)
+		host->mmc->pm_flags |= host->mmc->pm_caps;
+
+	if (host->mmc->caps2 & MMC_CAP2_HS400_ES)
+		host->mmc_host_ops.hs400_enhanced_strobe =
+					spacemit_sdhci_hs400_enhanced_strobe;
+
+	if (host->quirks2 & SDHCI_QUIRK2_DISABLE_PROBE_CDSCAN)
+		host->mmc->caps2 |= MMC_CAP2_DISABLE_PROBE_SCAN;
+
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_MMC) && !is_recovery_boot)
+		host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;
+
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, RPM_DELAY);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	pm_suspend_ignore_children(&pdev->dev, 1);
+
+	if ((host->mmc->caps2 & MMC_CAP2_NO_MMC) || (host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)) {
+		pr_debug("%s: get card pinctrl\n", mmc_hostname(host->mmc));
+		spacemit->pinctrl = devm_pinctrl_get(&pdev->dev);
+	}
+
+	/* set io clock rate */
+	if (pdata->host_freq) {
+		ret = clk_set_rate(spacemit->clk_io, pdata->host_freq);
+		if (ret) {
+			dev_err(dev, "failed to set io clock freq\n");
+			goto err_add_host;
+		}
+	} else {
+		dev_err(dev, "failed to get io clock freq\n");
+		goto err_add_host;
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add spacemit sdhc.\n");
+		goto err_add_host;
+	} else {
+		if (!(host->mmc->caps2 & MMC_CAP2_NO_SDIO)) {
+			pr_notice("sdio: save sdio_host <- %p\n", host);
+			sdio_host = host;
+		}
+	}
+
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_SD)) {
+#ifdef CONFIG_SYSFS
+		for (i = 0; i < ARRAY_SIZE(sdhci_sysfs_files); i++) {
+			device_create_file(dev, &sdhci_sysfs_files[i]);
+		}
+#endif
+	}
+
+	if (host->mmc->pm_caps & MMC_PM_WAKE_SDIO_IRQ)
+		device_init_wakeup(&pdev->dev, 1);
+	pm_runtime_put_autosuspend(&pdev->dev);
+	return 0;
+
+err_add_host:
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+err_of_parse:
+	clk_disable_unprepare(spacemit->clk_io);
+	clk_disable_unprepare(spacemit->clk_core);
+err_clk_get:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int spacemit_sdhci_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	int i;
+
+	pm_runtime_get_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+	sdhci_remove_host(host, 1);
+
+	clk_disable_unprepare(spacemit->clk_io);
+	clk_disable_unprepare(spacemit->clk_core);
+
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_SD)) {
+#ifdef CONFIG_SYSFS
+		for (i = 0; i < ARRAY_SIZE(sdhci_sysfs_files); i++) {
+			device_remove_file(&pdev->dev, &sdhci_sysfs_files[i]);
+		}
+#endif
+	}
+
+	sdhci_pltfm_free(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int spacemit_sdhci_suspend(struct device *dev)
+{
+	int ret;
+	struct sdhci_host *host = dev_get_drvdata(dev);
+
+	pm_runtime_get_sync(dev);
+	ret = sdhci_suspend_host(host);
+	if (ret)
+		return ret;
+	ret = pm_runtime_force_suspend(dev);
+	return ret;
+}
+
+static int spacemit_sdhci_resume(struct device *dev)
+{
+	int ret;
+	struct sdhci_host *host = dev_get_drvdata(dev);
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret) {
+		dev_err(dev, "failed to resume pm_runtime (%d)\n", ret);
+		return ret;
+	}
+	ret = sdhci_resume_host(host);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	if (ret) {
+		dev_err(dev, "failed to resume (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int spacemit_sdhci_runtime_suspend(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->runtime_suspended = true;
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_MMC)
+		&& !(host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)
+		&& !(host->quirks2 & SDHCI_QUIRK2_SUPPORT_PHY_BYPASS)) {
+		reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+		reg &= ~PHY_FUNC_EN;
+		sdhci_writel(host, reg, SDHC_PHY_CTRL_REG);
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	clk_disable_unprepare(spacemit->clk_io);
+	if (!IS_ERR(spacemit->clk_core))
+		clk_disable_unprepare(spacemit->clk_core);
+
+	return 0;
+}
+
+static int spacemit_sdhci_runtime_resume(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_spacemit *spacemit = sdhci_pltfm_priv(pltfm_host);
+	unsigned long flags;
+	u32 reg;
+
+	clk_prepare_enable(spacemit->clk_io);
+	if (!IS_ERR(spacemit->clk_core))
+		clk_prepare_enable(spacemit->clk_core);
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!(host->mmc->caps2 & MMC_CAP2_NO_MMC)
+		&& !(host->quirks2 & SDHCI_QUIRK2_BROKEN_PHY_MODULE)
+		&& !(host->quirks2 & SDHCI_QUIRK2_SUPPORT_PHY_BYPASS)) {
+		reg = sdhci_readl(host, SDHC_PHY_CTRL_REG);
+		reg |= PHY_FUNC_EN;
+		sdhci_writel(host, reg, SDHC_PHY_CTRL_REG);
+	}
+	host->runtime_suspended = false;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sdhci_spacemit_pmops = {
+	SET_SYSTEM_SLEEP_PM_OPS(spacemit_sdhci_suspend, spacemit_sdhci_resume)
+	SET_RUNTIME_PM_OPS(spacemit_sdhci_runtime_suspend,
+		spacemit_sdhci_runtime_resume, NULL)
+};
+
+#define SDHCI_SPACEMIT_PMOPS (&sdhci_spacemit_pmops)
+
+#else
+#define SDHCI_SPACEMIT_PMOPS NULL
+#endif
+
+static struct platform_driver spacemit_sdhci_driver = {
+	.driver		= {
+		.name	= "sdhci-spacemit",
+		.of_match_table = of_match_ptr(sdhci_spacemit_of_match),
+		.pm	= SDHCI_SPACEMIT_PMOPS,
+	},
+	.probe		= spacemit_sdhci_probe,
+	.remove		= spacemit_sdhci_remove,
+};
+
+module_platform_driver(spacemit_sdhci_driver);
+
+MODULE_DESCRIPTION("SDHCI platform driver for Spacemit");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index f4a7733a8ad2..42a8c281e200 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1733,6 +1733,15 @@ static bool sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 		timeout += 10 * HZ;
 	sdhci_mod_timer(host, cmd->mrq, timeout);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+#ifdef CONFIG_MMC_DEBUG
+	host->ops->save_register(host, cmd->opcode);
+#endif
+	if (host->mmc->caps2 & MMC_CAP2_CRC_SW_RETRY)
+		if (flags & SDHCI_CMD_DATA)
+			host->ops->reset_dllcfg1(host);
+#endif
+
 	if (host->use_external_dma)
 		sdhci_external_dma_pre_transfer(host, cmd);
 
@@ -2079,13 +2088,43 @@ static void sdhci_set_power_reg(struct sdhci_host *host, unsigned char mode,
 				unsigned short vdd)
 {
 	struct mmc_host *mmc = host->mmc;
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	u8 pwr = 0;
+#endif
 
 	mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (mode != MMC_POWER_OFF) {
+		switch (1 << vdd) {
+		case MMC_VDD_165_195:
+			pwr = SDHCI_POWER_180;
+			break;
+		case MMC_VDD_29_30:
+		case MMC_VDD_30_31:
+			pwr = SDHCI_POWER_300;
+			break;
+		case MMC_VDD_32_33:
+		case MMC_VDD_33_34:
+			pwr = SDHCI_POWER_330;
+			break;
+		default:
+			WARN(1, "%s: Invalid vdd %#x\n",
+			     mmc_hostname(host->mmc), vdd);
+			break;
+		}
+
+		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+		sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+		sdhci_writeb(host, (pwr | SDHCI_POWER_ON), SDHCI_POWER_CONTROL);
+	} else
+		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+#else
 	if (mode != MMC_POWER_OFF)
 		sdhci_writeb(host, SDHCI_POWER_ON, SDHCI_POWER_CONTROL);
 	else
 		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+#endif
 }
 
 unsigned short sdhci_get_vdd_value(unsigned short vdd)
@@ -2657,6 +2696,12 @@ int sdhci_start_signal_voltage_switch(struct mmc_host *mmc,
 		ctrl &= ~SDHCI_CTRL_VDD_180;
 		sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+		/* Some controller need to do more when switching */
+		if (host->ops->voltage_switch)
+			host->ops->voltage_switch(host);
+#endif
+
 		if (!IS_ERR(mmc->supply.vqmmc)) {
 			ret = mmc_regulator_set_vqmmc(mmc, ios);
 			if (ret < 0) {
@@ -2739,6 +2784,56 @@ static int sdhci_card_busy(struct mmc_host *mmc)
 	return !(present_state & SDHCI_DATA_0_LVL_MASK);
 }
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+static void sdhci_auto_clk_gate(struct mmc_host *mmc, int auto_gate)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->set_auto_clk_gate)
+		host->ops->set_auto_clk_gate(host, auto_gate);
+}
+
+static void sdhci_pre_select_hs400(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->pre_select_hs400)
+		host->ops->pre_select_hs400(host);
+}
+
+static void sdhci_post_select_hs400(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->post_select_hs400)
+		host->ops->post_select_hs400(host);
+}
+
+static void sdhci_pre_hs400_to_hs200(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->pre_hs400_to_hs200)
+		host->ops->pre_hs400_to_hs200(host);
+}
+
+static void sdhci_dump_host_register(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->error_handle)
+		host->ops->error_handle(host, 0, 1);
+}
+
+static void sdhci_encrypt_config(struct mmc_host *mmc, unsigned int enc_flag)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->ops->set_encrypt_feature)
+		host->ops->set_encrypt_feature(host, enc_flag);
+}
+#endif
+
 static int sdhci_prepare_hs400_tuning(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
@@ -3091,6 +3186,14 @@ static const struct mmc_host_ops sdhci_ops = {
 	.execute_tuning			= sdhci_execute_tuning,
 	.card_event			= sdhci_card_event,
 	.card_busy	= sdhci_card_busy,
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	.auto_clk_gate	= sdhci_auto_clk_gate,
+	.pre_select_hs400 = sdhci_pre_select_hs400,
+	.post_select_hs400 = sdhci_post_select_hs400,
+	.pre_hs400_to_hs200 = sdhci_pre_hs400_to_hs200,
+	.dump_host_register = sdhci_dump_host_register,
+	.encrypt_config = sdhci_encrypt_config,
+#endif
 };
 
 /*****************************************************************************\
@@ -3577,6 +3680,10 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 
 	do {
 		DBG("IRQ status 0x%08x\n", intmask);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+		if (intmask & SDHCI_INT_ERROR)
+			host->ops->error_handle(host, intmask, 0);
+#endif
 
 		if (host->ops->irq) {
 			intmask = host->ops->irq(host, intmask);
@@ -4632,6 +4739,11 @@ int sdhci_setup_host(struct sdhci_host *host)
 	if (host->caps1 & SDHCI_DRIVER_TYPE_D)
 		mmc->caps |= MMC_CAP_DRIVER_TYPE_D;
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	if (host->ops->caps_disable)
+		host->ops->caps_disable(host);
+#endif
+
 	/* Initial value for re-tuning timer count */
 	host->tuning_count = FIELD_GET(SDHCI_RETUNING_TIMER_COUNT_MASK,
 				       host->caps1);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index cd0e35a80542..d8a412a402f2 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -536,6 +536,19 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_USE_32BIT_BLK_CNT			(1<<18)
 /* Issue CMD and DATA reset together */
 #define SDHCI_QUIRK2_ISSUE_CMD_DAT_RESET_TOGETHER	(1<<19)
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+/* Support SDH controller on FPGA */
+#define SDHCI_QUIRK2_SUPPORT_PHY_BYPASS			(1<<25)
+/* Disable scan card at probe phase */
+#define SDHCI_QUIRK2_DISABLE_PROBE_CDSCAN		(1<<26)
+/* Need to set IO capability by SOC part register */
+#define SDHCI_QUIRK2_SET_AIB_MMC			(1<<27)
+/* Controller not support phy module */
+#define SDHCI_QUIRK2_BROKEN_PHY_MODULE			(1<<28)
+/* Controller support encrypt module */
+#define SDHCI_QUIRK2_SUPPORT_ENCRYPT			(1<<29)
+#endif
+
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
@@ -724,6 +737,17 @@ struct sdhci_ops {
 	void    (*dump_vendor_regs)(struct sdhci_host *host);
 	void	(*dump_uhs2_regs)(struct sdhci_host *host);
 	void    (*uhs2_pre_detect_init)(struct sdhci_host *host);
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	void	(*caps_disable)(struct sdhci_host *host);
+	void	(*set_auto_clk_gate)(struct sdhci_host *host, unsigned int ctrl);
+	void    (*error_handle)(struct sdhci_host *host, u32 status, u8 force);
+	void    (*save_register)(struct sdhci_host *host, u32 cmd);
+	void    (*pre_select_hs400)(struct sdhci_host *host);
+	void    (*post_select_hs400)(struct sdhci_host *host);
+	void    (*pre_hs400_to_hs200)(struct sdhci_host *host);
+	void    (*reset_dllcfg1)(struct sdhci_host *host);
+	void	(*set_encrypt_feature)(struct sdhci_host *host, unsigned int enc_flag);
+#endif
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/include/dt-bindings/mmc/k1x_sdhci.h b/include/dt-bindings/mmc/k1x_sdhci.h
new file mode 100644
index 000000000000..8f93a718e9ce
--- /dev/null
+++ b/include/dt-bindings/mmc/k1x_sdhci.h
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * include/linux/dt-bindings/mmc/k1x_sdhci.h
+ *
+ * SDH driver for SPACEMIT K1X SDCHI
+ * Copyright (C) 2023 Spacemit
+ */
+
+#ifndef K1X_DT_BINDINGS_MMC_SDHCI_H
+#define K1X_DT_BINDINGS_MMC_SDHCI_H
+
+/* K1x specific flag */
+
+/* MMC Quirks */
+/* Controller has an unusable ADMA engine */
+#define SDHCI_QUIRK_BROKEN_ADMA					(1<<6)
+#define SDHCI_QUIRK2_PRESET_VALUE_BROKEN			(1<<3)
+/* Controller does not support HS200 */
+#define SDHCI_QUIRK2_BROKEN_HS200				(1<<6)
+/* Support SDH controller on FPGA */
+#define SDHCI_QUIRK2_SUPPORT_PHY_BYPASS				(1<<25)
+/* Disable scan card at probe phase */
+#define SDHCI_QUIRK2_DISABLE_PROBE_CDSCAN			(1<<26)
+/* Need to set IO capability by SOC part register */
+#define SDHCI_QUIRK2_SET_AIB_MMC				(1<<27)
+/* Controller not support phy module */
+#define SDHCI_QUIRK2_BROKEN_PHY_MODULE				(1<<28)
+/* Controller support encrypt module */
+#define SDHCI_QUIRK2_SUPPORT_ENCRYPT				(1<<29)
+
+/* Common flag */
+/* Controller provides an incorrect timeout value for transfers */
+#define SDHCI_QUIRK_BROKEN_TIMEOUT_VAL				(1<<12)
+/* Controller has unreliable card detection */
+#define SDHCI_QUIRK_BROKEN_CARD_DETECTION			(1<<15)
+
+/* Controller reports inverted write-protect state */
+#define SDHCI_QUIRK_INVERTED_WRITE_PROTECT			(1<<16)
+
+/* MMC caps */
+#define MMC_CAP2_CRC_SW_RETRY	(1 << 30)
+
+/* for SDIO */
+#define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
+
+/* for SD card */
+#define MMC_CAP_UHS_SDR12	(1 << 16)	/* Host supports UHS SDR12 mode */
+#define MMC_CAP_UHS_SDR25	(1 << 17)	/* Host supports UHS SDR25 mode */
+#define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
+#define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
+#define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
+#endif /* K1X_DT_BINDINGS_MMC_SDHCI_H */
+
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f166d6611ddb..8e3b91850b79 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -272,6 +272,15 @@ struct mmc_host_ops {
 	 * negative errno in case of a failure or zero for success.
 	 */
 	int	(*uhs2_control)(struct mmc_host *host, enum sd_uhs2_operation op);
+
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	void	(*auto_clk_gate)(struct mmc_host *host, int auto_gate);
+	void    (*pre_select_hs400)(struct mmc_host *host);
+	void    (*post_select_hs400)(struct mmc_host *host);
+	void    (*pre_hs400_to_hs200)(struct mmc_host *host);
+	void    (*dump_host_register)(struct mmc_host *host);
+	void	(*encrypt_config)(struct mmc_host *host, unsigned int enc_flag);
+#endif
 };
 
 struct mmc_cqe_ops {
@@ -459,7 +468,10 @@ struct mmc_host {
 #define MMC_CAP2_CRYPTO		0
 #endif
 #define MMC_CAP2_ALT_GPT_TEGRA	(1 << 28)	/* Host with eMMC that has GPT entry at a non-standard location */
-
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+#define MMC_CAP2_DISABLE_PROBE_SCAN	(1 << 29)
+#define MMC_CAP2_CRC_SW_RETRY	(1 << 30)
+#endif
 	bool			uhs2_sd_tran;	/* UHS-II flag for SD_TRAN state */
 	bool			uhs2_app_cmd;	/* UHS-II flag for APP command */
 	struct sd_uhs2_caps	uhs2_caps;	/* Host UHS-II capabilities */
diff --git a/include/linux/platform_data/k1x_sdhci.h b/include/linux/platform_data/k1x_sdhci.h
new file mode 100644
index 000000000000..c3a4fe7e13d1
--- /dev/null
+++ b/include/linux/platform_data/k1x_sdhci.h
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * include/linux/platform_data/k1x_sdhci.h
+ *
+ * Copyright (C) 2023 Spacemit
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _K1X_SDHCI_H_
+#define _K1X_SDHCI_H_
+
+#define CANDIDATE_WIN_NUM 3
+#define SELECT_DELAY_NUM 9
+#define WINDOW_1ST 0
+#define WINDOW_2ND 1
+#define WINDOW_3RD 2
+
+#define RX_TUNING_WINDOW_THRESHOLD 80
+#define RX_TUNING_DLINE_REG 0x09
+#define TX_TUNING_DLINE_REG 0x00
+#define TX_TUNING_DELAYCODE 127
+
+enum window_type {
+	LEFT_WINDOW = 0,
+	MIDDLE_WINDOW = 1,
+	RIGHT_WINDOW = 2,
+};
+
+struct tuning_window {
+	u8 type;
+	u8 min_delay;
+	u8 max_delay;
+};
+
+struct rx_tuning {
+	u8 rx_dline_reg;
+	u8 select_delay_num;
+	u8 current_delay_index;
+	/* 0: biggest window, 1: bigger, 2:  small */
+	struct tuning_window windows[CANDIDATE_WIN_NUM];
+	u8 select_delay[SELECT_DELAY_NUM];
+
+	u32 card_cid[4];
+	u8 window_limit;
+};
+
+/*
+ * struct k1x_sdhci_platdata() - Platform device data for Spacemit K1x SDHCI
+ * @flags: flags for platform requirement
+ * @host_caps: Standard MMC host capabilities bit field
+ * @host_caps2: Standard MMC host capabilities bit field
+ * @host_caps_disable: Aquila MMC host capabilities disable bit field
+ * @host_caps2_disable: Aquila MMC host capabilities disable bit field
+ * @quirks: quirks of platform
+ * @quirks2: quirks2 of platform
+ * @pm_caps: pm_caps of platform
+ */
+struct k1x_sdhci_platdata {
+	u32 host_freq;
+	u32 flags;
+	u32 host_caps;
+	u32 host_caps2;
+	u32 host_caps_disable;
+	u32 host_caps2_disable;
+	u32 quirks;
+	u32 quirks2;
+	u32 pm_caps;
+
+	u32 aib_mmc1_io_reg;
+	u32 apbc_asfar_reg;
+	u32 apbc_assar_reg;
+
+	u8 tx_dline_reg;
+	u8 tx_delaycode;
+	struct rx_tuning rxtuning;
+	u8 need_reset_dllcfg1;
+	u32 prev_dllcfg1;
+	u32 curr_dllcfg1;
+	u32 new_dllcfg1;
+	u8 dllcfg1_odd_reset;
+};
+
+#endif /* _K1X_SDHCI_H_ */
-- 
2.47.0

