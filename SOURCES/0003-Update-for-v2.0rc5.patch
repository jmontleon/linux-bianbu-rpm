From f109518b693ad65c6ec9129bf3a8846ca3009d8a Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Mon, 2 Sep 2024 15:34:14 +0800
Subject: [PATCH 03/16] Update for v2.0rc5

---
 arch/riscv/boot/dts/spacemit/k1-x.dtsi        |   21 +
 .../dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts  |   41 +-
 .../boot/dts/spacemit/k1-x_opp_table.dtsi     |  145 +-
 .../riscv/boot/dts/spacemit/k1-x_pinctrl.dtsi |   12 +
 .../dts/spacemit/k1-x_thermal_cooling.dtsi    |   64 +-
 .../boot/dts/spacemit/m1-x_milkv-jupiter.dts  |    4 +-
 .../boot/dts/spacemit/m1-x_opp_table.dtsi     |  234 --
 .../dts/spacemit/m1-x_thermal_cooling.dtsi    |  106 -
 arch/riscv/configs/k1_defconfig               |    9 +-
 drivers/cpufreq/cpufreq-dt.c                  |   10 +
 drivers/cpufreq/cpufreq.c                     |   20 +
 drivers/cpufreq/freq_table.c                  |    2 +
 drivers/cpufreq/spacemit-cpufreq.c            |   87 +-
 drivers/media/rc/ir-spacemit.c                |  193 +-
 drivers/mmc/host/sdhci-of-k1x.c               |    6 +-
 drivers/net/can/flexcan/flexcan-core.c        |    4 +
 drivers/net/usb/Kconfig                       |   23 +
 drivers/net/usb/Makefile                      |    1 +
 drivers/net/usb/asix_usb/ax_main.c            |    7 +-
 drivers/net/usb/qmi_wwan_f.c                  | 2537 +++++++++++++++++
 .../aic8800/aic8800_bsp/aic_bsp_8800d.c       |   68 +-
 .../aic8800/aic8800_bsp/aic_bsp_8800d80.c     |   80 +-
 .../aic8800/aic8800_bsp/aic_bsp_8800dc.c      |   62 +-
 .../aic8800/aic8800_bsp/aic_bsp_driver.c      |    0
 .../aic8800/aic8800_bsp/aic_bsp_driver.h      |    2 +-
 .../aic8800/aic8800_bsp/aic_bsp_export.h      |    0
 .../aic8800/aic8800_bsp/aic_bsp_helper.c      |    0
 .../aic8800/aic8800_bsp/aic_bsp_main.c        |    0
 .../aic8800/aic8800_bsp/aic_bsp_txrxif.c      |    0
 .../aic8800/aic8800_bsp/aic_bsp_txrxif.h      |    0
 .../aic8800/aic8800_bsp/aic_bsp_verify.c      |    0
 .../wireless/aic8800/aic8800_bsp/aicsdio.c    |    0
 .../wireless/aic8800/aic8800_bsp/aicsdio.h    |    0
 .../net/wireless/aic8800/aic8800_bsp/aicusb.c |    0
 .../net/wireless/aic8800/aic8800_bsp/aicusb.h |    0
 .../aic8800/aic8800_btlpm/aic8800_btlpm.c     |    0
 .../aic8800/aic8800_btusb/aic_btusb.c         |    0
 .../aic8800/aic8800_btusb/aic_btusb.h         |    0
 .../aic8800/aic8800_fdrv/aic_vendor.c         |    0
 .../aic8800/aic8800_fdrv/aic_vendor.h         |    0
 .../aic8800/aic8800_fdrv/aicwf_8800d80.c      |    0
 .../aic8800/aic8800_fdrv/aicwf_8800d80.h      |    0
 .../aic8800/aic8800_fdrv/aicwf_8800dc.c       |    0
 .../aic8800/aic8800_fdrv/aicwf_8800dc.h       |    0
 .../aic8800/aic8800_fdrv/aicwf_sdio.c         |    0
 .../aic8800/aic8800_fdrv/aicwf_sdio.h         |    0
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.c      |    0
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.h      |    0
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |    0
 .../aic8800/aic8800_fdrv/aicwf_txrxif.h       |    0
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c |    0
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |    0
 .../wireless/aic8800/aic8800_fdrv/hal_desc.h  |    0
 .../aic8800/aic8800_fdrv/ipc_compat.h         |    0
 .../wireless/aic8800/aic8800_fdrv/ipc_host.c  |    0
 .../wireless/aic8800/aic8800_fdrv/ipc_host.h  |    0
 .../aic8800/aic8800_fdrv/ipc_shared.h         |    0
 .../wireless/aic8800/aic8800_fdrv/lmac_mac.h  |    0
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |    0
 .../aic8800/aic8800_fdrv/lmac_types.h         |    0
 .../aic8800/aic8800_fdrv/reg_access.h         |    0
 .../aic8800/aic8800_fdrv/rwnx_bfmer.c         |    0
 .../aic8800/aic8800_fdrv/rwnx_bfmer.h         |    0
 .../aic8800/aic8800_fdrv/rwnx_cfgfile.c       |    0
 .../aic8800/aic8800_fdrv/rwnx_cfgfile.h       |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.h |    0
 .../aic8800/aic8800_fdrv/rwnx_compat.h        |    0
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       |    0
 .../aic8800/aic8800_fdrv/rwnx_debugfs.h       |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_dini.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_dini.h |    0
 .../aic8800/aic8800_fdrv/rwnx_events.h        |    0
 .../aic8800/aic8800_fdrv/rwnx_fw_trace.c      |    0
 .../aic8800/aic8800_fdrv/rwnx_fw_trace.h      |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.c  |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.h  |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_irqs.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_irqs.h |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.h |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_mesh.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_mesh.h |    0
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |    0
 .../aic8800/aic8800_fdrv/rwnx_mod_params.h    |    0
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |    0
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.h        |    0
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        |    0
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |    0
 .../aic8800/aic8800_fdrv/rwnx_mu_group.c      |    0
 .../aic8800/aic8800_fdrv/rwnx_mu_group.h      |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_pci.c  |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_pci.h  |    0
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |    0
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_prof.h |    0
 .../aic8800/aic8800_fdrv/rwnx_radar.c         |    0
 .../aic8800/aic8800_fdrv/rwnx_radar.h         |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.h   |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_strs.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_strs.h |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tdls.c |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tdls.h |    0
 .../aic8800/aic8800_fdrv/rwnx_testmode.c      |    0
 .../aic8800/aic8800_fdrv/rwnx_testmode.h      |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.h   |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.c  |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.h  |    0
 .../aic8800/aic8800_fdrv/rwnx_utils.c         |    0
 .../aic8800/aic8800_fdrv/rwnx_utils.h         |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_v7.c   |    0
 .../wireless/aic8800/aic8800_fdrv/rwnx_v7.h   |    0
 .../aic8800/aic8800_fdrv/rwnx_version.h       |    0
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |    0
 .../aic8800/aic8800_fdrv/rwnx_wakelock.c      |    0
 .../aic8800/aic8800_fdrv/rwnx_wakelock.h      |    0
 .../wireless/aic8800/aic8800_fdrv/sdio_host.c |    0
 .../wireless/aic8800/aic8800_fdrv/sdio_host.h |    0
 .../wireless/aic8800/aic8800_fdrv/usb_host.c  |    0
 .../wireless/aic8800/aic8800_fdrv/usb_host.h  |    0
 drivers/pci/controller/dwc/pcie-k1x.c         |   18 +
 drivers/power/supply/sbs-charger-virtual.c    |    0
 drivers/soc/spacemit/spacemit-rf/Makefile     |    2 +-
 .../soc/spacemit/spacemit-rf/spacemit-bt.c    |   12 +-
 .../spacemit/spacemit-rf/spacemit-pwrseq.c    |   11 +-
 .../spacemit/spacemit-rf/spacemit-pwrseq.h    |    2 +-
 .../spacemit/spacemit-rf/spacemit-rfkill.c    |  321 +++
 .../soc/spacemit/spacemit-rf/spacemit-wlan.c  |   12 +-
 drivers/spi/spi-k1x-qspi.c                    |   20 +
 drivers/usb/phy/phy-k1x-ci-otg.c              |    1 -
 133 files changed, 3556 insertions(+), 581 deletions(-)
 delete mode 100644 arch/riscv/boot/dts/spacemit/m1-x_opp_table.dtsi
 delete mode 100644 arch/riscv/boot/dts/spacemit/m1-x_thermal_cooling.dtsi
 create mode 100644 drivers/net/usb/qmi_wwan_f.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_helper.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_verify.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h
 mode change 100755 => 100644 drivers/power/supply/sbs-charger-virtual.c
 create mode 100644 drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c

diff --git a/arch/riscv/boot/dts/spacemit/k1-x.dtsi b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
index 99a1c6301c45..5cf2ba13617f 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x.dtsi
@@ -1624,6 +1624,27 @@ rpwm2: pwm@c0888300 {
 			status = "disabled";
 		};
 
+		ircrx: irc-rx@d4017f00 {
+			compatible = "spacemit,k1x-irc";
+			reg = <0x0 0xd4017f00 0x0 0x100>;
+			interrupts = <69>;
+			interrupt-parent = <&intc>;
+			clocks = <&ccu CLK_IR>;
+			resets = <&reset RESET_IR>;
+			clock-frequency = <102400000>;
+			status = "disabled";
+		};
+
+		r_ircrx: irc-rx@c088e000 {
+			compatible = "spacemit,k1x-rirc";
+			reg = <0x0 0xc088e000 0x0 0x100>;
+			clocks = <&ccu CLK_RCPU_IR>;
+			resets = <&reset RESET_RCPU_IR>;
+			clock-frequency = <30720000>;
+			rcpu-ir;
+			status = "disabled";
+		};
+
 		timer0: timer@d4014000 {
 			compatible = "spacemit,soc-timer";
 			reg = <0x0 0xd4014000 0x0 0xc8>;
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
index 7ec6e3c77110..cd256bdf1912 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
@@ -18,7 +18,7 @@
 
 / {
 	model = "MUSE-PAPER-MINI-4G";
-	modules_usrload = "8852bs";
+	modules_usrload = "aic8800_bsp,aic8800_fdrv,aic8800_btlpm";
 
 	cpus: cpus {
 		#address-cells = <1>;
@@ -166,6 +166,22 @@ bt_pwrseq: bt-pwrseq {
 		};
 	};
 
+	wwan_pwrseq: wwan-pwrseq {
+		compatible = "spacemit,wwan-pwrseq";
+		rfkill-name = "spacemit-wwan4g";
+
+		power-gpios = <&gpio 48 0>;
+		power-use-pulse;
+		power-pulse-delay-ms = <100>;
+		power-off-pulse-delay-ms = <3000>;
+
+		reset-gpios = <&gpio 2 0>;
+		reset-use-pulse;
+		reset-pulse-delay-ms = <700>;
+
+		status = "okay";
+	};
+
 	typec_0: connector@0 {
 		compatible = "usb-c-connector";
 		label = "USB-C";
@@ -635,7 +651,9 @@ sgm4154x: sgm4154x@1a {
 
 &pinctrl {
 	pinctrl-single,gpio-range = <
+		&range GPIO_02  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_03  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
+		&range GPIO_48  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS2)
 		&range GPIO_49  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
 		&range GPIO_58  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_63  2 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
@@ -661,13 +679,6 @@ &range GPIO_124 1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_125 3 (MUX_MODE0 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
 	>;
 
-	pinctrl_rcpu: pinctrl_rcpu_grp {
-		pinctrl-single,pins = <
-			K1X_PADCONF(GPIO_47,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_tx */
-			K1X_PADCONF(GPIO_48,   MUX_MODE1, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_uart0_rx */
-		>;
-	};
-
 	pinctrl_wlan_wakeup: wlan_wakeup_grp {
 		pinctrl-single,pins =<
 			K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_FALL | PULL_DOWN | PAD_3V_DS2))   /* wifi edge detect */
@@ -677,7 +688,9 @@ K1X_PADCONF(GPIO_66, MUX_MODE0, (EDGE_FALL | PULL_DOWN | PAD_3V_DS2))   /* wifi
 
 &gpio{
 	gpio-ranges = <
+		&pinctrl 02  GPIO_02  1
 		&pinctrl 03  GPIO_03  1
+		&pinctrl 48  GPIO_48  1
 		&pinctrl 49  GPIO_49  2
 		&pinctrl 58  GPIO_58  1
 		&pinctrl 63  GPIO_63  5
@@ -817,12 +830,12 @@ otg_role_switch: endpoint {
 };
 
 &usbphy1 {
-	status = "disabled";
+	status = "okay";
 };
 
 &ehci1 {
 	spacemit,reset-on-resume;
-	status = "disabled";
+	status = "okay";
 };
 
 &usb2phy {
@@ -833,12 +846,6 @@ &combphy {
 	status = "disabled";
 };
 
-&usb3hub {
-	vbus-gpios = <&gpio 89 0>,
-		     <&gpio 124 0>;
-	status = "disabled";
-};
-
 &usbdrd3 {
 	status = "disabled";
 	reset-on-resume;
@@ -998,8 +1005,6 @@ &pwm_bl {
 };
 
 &rcpu {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_rcpu>;
 	mboxes = <&mailbox 0>, <&mailbox 1>;
 	mbox-names = "vq0", "vq1";
 	memory-region = <&rcpu_mem_0>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>, <&rsc_table>, <&rcpu_mem_snapshots>;
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_opp_table.dtsi b/arch/riscv/boot/dts/spacemit/k1-x_opp_table.dtsi
index 6826398e7f23..4d432544c82d 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_opp_table.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x_opp_table.dtsi
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Copyright (c) 2024 Spacemit, Inc */
+/* Copyright (c) 2023 Spacemit, Inc */
 
 &cpus {
 	clst_core_opp_table0: opp_table0 {
@@ -11,6 +11,133 @@ clst_core_opp_table0: opp_table0 {
 		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
 		cci-hz = /bits/ 64 <614000000>;
 
+		opp1800000000 {
+			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
+			tcm-hz = /bits/ 64 <900000000>;
+			ace-hz = /bits/ 64 <900000000>;
+			opp-microvolt = <1160000>;
+			clock-latency-ns = <200000>;
+			turbo-mode;
+		};
+
+		opp1600000000 {
+			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
+			tcm-hz = /bits/ 64 <800000000>;
+			ace-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1050000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp1228800000 {
+			opp-hz = /bits/ 64 <1228800000>, /bits/ 64 <1228800000>;
+			tcm-hz = /bits/ 64 <614400000>;
+			ace-hz = /bits/ 64 <614400000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp1000000000 {
+			opp-hz = /bits/ 64 <1000000000>, /bits/ 64 <1000000000>;
+			tcm-hz = /bits/ 64 <500000000>;
+			ace-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp819000000 {
+			opp-hz = /bits/ 64 <819000000>, /bits/ 64 <819000000>;
+			opp-microvolt = <950000>;
+			tcm-hz = /bits/ 64 <409500000>;
+			ace-hz = /bits/ 64 <409500000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp614400000 {
+			opp-hz = /bits/ 64 <614400000>, /bits/ 64 <614400000>;
+			tcm-hz = /bits/ 64 <307200000>;
+			ace-hz = /bits/ 64 <307200000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+	};
+
+	clst_core_opp_table1: opp_table1 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		clocks = <&ccu CLK_CPU_C0_ACE>, <&ccu CLK_CPU_C1_ACE>, <&ccu CLK_CPU_C0_TCM>,
+			<&ccu CLK_CCI550>, <&ccu CLK_PLL3>, <&ccu CLK_CPU_C0_HI>, <&ccu CLK_CPU_C1_HI>;
+		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
+		cci-hz = /bits/ 64 <614000000>;
+
+		opp1800000000 {
+			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
+			tcm-hz = /bits/ 64 <900000000>;
+			ace-hz = /bits/ 64 <900000000>;
+			opp-microvolt = <1100000>;
+			clock-latency-ns = <200000>;
+			turbo-mode;
+		};
+
+		opp1600000000 {
+			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
+			tcm-hz = /bits/ 64 <800000000>;
+			ace-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1050000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp1228800000 {
+			opp-hz = /bits/ 64 <1228800000>, /bits/ 64 <1228800000>;
+			tcm-hz = /bits/ 64 <614400000>;
+			ace-hz = /bits/ 64 <614400000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp1000000000 {
+			opp-hz = /bits/ 64 <1000000000>, /bits/ 64 <1000000000>;
+			tcm-hz = /bits/ 64 <500000000>;
+			ace-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp819000000 {
+			opp-hz = /bits/ 64 <819000000>, /bits/ 64 <819000000>;
+			opp-microvolt = <950000>;
+			tcm-hz = /bits/ 64 <409500000>;
+			ace-hz = /bits/ 64 <409500000>;
+			clock-latency-ns = <200000>;
+		};
+
+		opp614400000 {
+			opp-hz = /bits/ 64 <614400000>, /bits/ 64 <614400000>;
+			tcm-hz = /bits/ 64 <307200000>;
+			ace-hz = /bits/ 64 <307200000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <200000>;
+		};
+	};
+
+	clst_core_opp_table2: opp_table2 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		clocks = <&ccu CLK_CPU_C0_ACE>, <&ccu CLK_CPU_C1_ACE>, <&ccu CLK_CPU_C0_TCM>,
+			<&ccu CLK_CCI550>, <&ccu CLK_PLL3>, <&ccu CLK_CPU_C0_HI>, <&ccu CLK_CPU_C1_HI>;
+		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
+		cci-hz = /bits/ 64 <614000000>;
+
+		opp1800000000 {
+			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
+			tcm-hz = /bits/ 64 <900000000>;
+			ace-hz = /bits/ 64 <900000000>;
+			opp-microvolt = <1050000>;
+			clock-latency-ns = <200000>;
+			turbo-mode;
+		};
+
 		opp1600000000 {
 			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
 			tcm-hz = /bits/ 64 <800000000>;
@@ -57,54 +184,54 @@ &cpu_0 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_1 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_2 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_3 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_4 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_5 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_6 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
 
 &cpu_7 {
 	clst-supply = <&dcdc_1>;
 	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
 	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>;
+	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
 };
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_pinctrl.dtsi b/arch/riscv/boot/dts/spacemit/k1-x_pinctrl.dtsi
index 0841ddfdab4b..04fc08d016fd 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_pinctrl.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x_pinctrl.dtsi
@@ -391,6 +391,18 @@ K1X_PADCONF(GPIO_58, MUX_MODE4, (EDGE_NONE | PULL_UP | PAD_1V8_DS2))	/* ir_rx */
 		>;
 	};
 
+	pinctrl_r_ir_rx_0: r_ir_rx_0_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_48, MUX_MODE3, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* r_ir_rx */
+		>;
+	};
+
+	pinctrl_r_ir_rx_1: r_ir_rx_1_grp {
+		pinctrl-single,pins = <
+			K1X_PADCONF(GPIO_44, MUX_MODE3, (EDGE_NONE | PULL_UP | PAD_1V8_DS2))	/* r_ir_rx */
+		>;
+	};
+
 	pinctrl_pwm0_0: pwm0_0_grp {
 		pinctrl-single,pins = <
 			K1X_PADCONF(MMC1_DAT3, MUX_MODE5, (EDGE_NONE | PULL_UP | PAD_3V_DS4))	/* pwm0 */
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi b/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
index 9304607a03ea..e2d73dd2f6c3 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
@@ -9,18 +9,24 @@ cluster0_thermal {
 
 		thermal0_trips: trips {
 			cls0_trip0: cls0-trip-point0 {
+				temperature = <90000>;
+				hysteresis = <4000>;
+				type = "passive";
+			};
+
+			cls0_trip1: cls0-trip-point1 {
 				temperature = <95000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
-			cls0_trip1: cls0-trip-point1 {
+			cls0_trip2: cls0-trip-point2 {
 				temperature = <105000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
-			cls0_trip2: cls0-trip-point2 {
+			cls0_trip3: cls0-trip-point3 {
 				temperature = <115000>;
 				hysteresis = <5000>;
 				type = "critical";
@@ -30,26 +36,38 @@ cls0_trip2: cls0-trip-point2 {
 		cooling-maps {
 			map0 {
 				trip = <&cls0_trip0>;
-				cooling-device = <&cpu_0 1 2>,
-						 <&cpu_1 1 2>,
-						 <&cpu_2 1 2>,
-						 <&cpu_3 1 2>,
-						 <&cpu_4 1 2>,
-						 <&cpu_5 1 2>,
-						 <&cpu_6 1 2>,
-						 <&cpu_7 1 2>;
+				cooling-device = <&cpu_0 1 1>,
+						 <&cpu_1 1 1>,
+						 <&cpu_2 1 1>,
+						 <&cpu_3 1 1>,
+						 <&cpu_4 1 1>,
+						 <&cpu_5 1 1>,
+						 <&cpu_6 1 1>,
+						 <&cpu_7 1 1>;
 			};
 
 			map1 {
 				trip = <&cls0_trip1>;
-				cooling-device = <&cpu_0 3 3>,
-						 <&cpu_1 3 3>,
-						 <&cpu_2 3 3>,
-						 <&cpu_3 3 3>,
-						 <&cpu_4 3 3>,
-						 <&cpu_5 3 3>,
-						 <&cpu_6 3 3>,
-						 <&cpu_7 3 3>;
+				cooling-device = <&cpu_0 2 3>,
+						 <&cpu_1 2 3>,
+						 <&cpu_2 2 3>,
+						 <&cpu_3 2 3>,
+						 <&cpu_4 2 3>,
+						 <&cpu_5 2 3>,
+						 <&cpu_6 2 3>,
+						 <&cpu_7 2 3>;
+			};
+
+			map2 {
+				trip = <&cls0_trip2>;
+				cooling-device = <&cpu_0 4 5>,
+						 <&cpu_1 4 5>,
+						 <&cpu_2 4 5>,
+						 <&cpu_3 4 5>,
+						 <&cpu_4 4 5>,
+						 <&cpu_5 4 5>,
+						 <&cpu_6 4 5>,
+						 <&cpu_7 4 5>;
 			};
 		};
 	};
@@ -61,18 +79,24 @@ cluster1_thermal {
 
 		thermal1_trips: trips {
 			cls1_trip0: cls1-trip-point0 {
+				temperature = <90000>;
+				hysteresis = <4000>;
+				type = "passive";
+			};
+
+			cls1_trip1: cls1-trip-point1 {
 				temperature = <95000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
-			cls1_trip1: cls1-trip-point1 {
+			cls1_trip2: cls1-trip-point2 {
 				temperature = <105000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
-			cls1_trip2: cls1-trip-point2 {
+			cls1_trip3: cls1-trip-point3 {
 				temperature = <115000>;
 				hysteresis = <5000>;
 				type = "critical";
diff --git a/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts b/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
index 1cb9348b61a9..ea686d02d08f 100644
--- a/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
+++ b/arch/riscv/boot/dts/spacemit/m1-x_milkv-jupiter.dts
@@ -10,8 +10,8 @@
 #include "k1-x-hdmi.dtsi"
 #include "k1-x-lcd.dtsi"
 #include "k1-x-camera-sdk.dtsi"
-#include "m1-x_opp_table.dtsi"
-#include "m1-x_thermal_cooling.dtsi"
+#include "k1-x_opp_table.dtsi"
+#include "k1-x_thermal_cooling.dtsi"
 
 / {
 	model = "Milk-V(M1) Jupiter";
diff --git a/arch/riscv/boot/dts/spacemit/m1-x_opp_table.dtsi b/arch/riscv/boot/dts/spacemit/m1-x_opp_table.dtsi
deleted file mode 100644
index fa02fda0ad36..000000000000
--- a/arch/riscv/boot/dts/spacemit/m1-x_opp_table.dtsi
+++ /dev/null
@@ -1,234 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Copyright (c) 2023 Spacemit, Inc */
-
-&cpus {
-	clst_core_opp_table0: opp_table0 {
-		compatible = "operating-points-v2";
-		opp-shared;
-
-		clocks = <&ccu CLK_CPU_C0_ACE>, <&ccu CLK_CPU_C1_ACE>, <&ccu CLK_CPU_C0_TCM>,
-			<&ccu CLK_CCI550>, <&ccu CLK_PLL3>, <&ccu CLK_CPU_C0_HI>, <&ccu CLK_CPU_C1_HI>;
-		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
-		cci-hz = /bits/ 64 <614000000>;
-
-		opp1800000000 {
-			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
-			tcm-hz = /bits/ 64 <900000000>;
-			ace-hz = /bits/ 64 <900000000>;
-			opp-microvolt = <1160000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1600000000 {
-			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
-			tcm-hz = /bits/ 64 <800000000>;
-			ace-hz = /bits/ 64 <800000000>;
-			opp-microvolt = <1050000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1228800000 {
-			opp-hz = /bits/ 64 <1228800000>, /bits/ 64 <1228800000>;
-			tcm-hz = /bits/ 64 <614400000>;
-			ace-hz = /bits/ 64 <614400000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1000000000 {
-			opp-hz = /bits/ 64 <1000000000>, /bits/ 64 <1000000000>;
-			tcm-hz = /bits/ 64 <500000000>;
-			ace-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp819000000 {
-			opp-hz = /bits/ 64 <819000000>, /bits/ 64 <819000000>;
-			opp-microvolt = <950000>;
-			tcm-hz = /bits/ 64 <409500000>;
-			ace-hz = /bits/ 64 <409500000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp614400000 {
-			opp-hz = /bits/ 64 <614400000>, /bits/ 64 <614400000>;
-			tcm-hz = /bits/ 64 <307200000>;
-			ace-hz = /bits/ 64 <307200000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-	};
-
-	clst_core_opp_table1: opp_table1 {
-		compatible = "operating-points-v2";
-		opp-shared;
-
-		clocks = <&ccu CLK_CPU_C0_ACE>, <&ccu CLK_CPU_C1_ACE>, <&ccu CLK_CPU_C0_TCM>,
-			<&ccu CLK_CCI550>, <&ccu CLK_PLL3>, <&ccu CLK_CPU_C0_HI>, <&ccu CLK_CPU_C1_HI>;
-		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
-		cci-hz = /bits/ 64 <614000000>;
-
-		opp1800000000 {
-			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
-			tcm-hz = /bits/ 64 <900000000>;
-			ace-hz = /bits/ 64 <900000000>;
-			opp-microvolt = <1100000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1600000000 {
-			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
-			tcm-hz = /bits/ 64 <800000000>;
-			ace-hz = /bits/ 64 <800000000>;
-			opp-microvolt = <1050000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1228800000 {
-			opp-hz = /bits/ 64 <1228800000>, /bits/ 64 <1228800000>;
-			tcm-hz = /bits/ 64 <614400000>;
-			ace-hz = /bits/ 64 <614400000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1000000000 {
-			opp-hz = /bits/ 64 <1000000000>, /bits/ 64 <1000000000>;
-			tcm-hz = /bits/ 64 <500000000>;
-			ace-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp819000000 {
-			opp-hz = /bits/ 64 <819000000>, /bits/ 64 <819000000>;
-			opp-microvolt = <950000>;
-			tcm-hz = /bits/ 64 <409500000>;
-			ace-hz = /bits/ 64 <409500000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp614400000 {
-			opp-hz = /bits/ 64 <614400000>, /bits/ 64 <614400000>;
-			tcm-hz = /bits/ 64 <307200000>;
-			ace-hz = /bits/ 64 <307200000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-	};
-
-	clst_core_opp_table2: opp_table2 {
-		compatible = "operating-points-v2";
-		opp-shared;
-
-		clocks = <&ccu CLK_CPU_C0_ACE>, <&ccu CLK_CPU_C1_ACE>, <&ccu CLK_CPU_C0_TCM>,
-			<&ccu CLK_CCI550>, <&ccu CLK_PLL3>, <&ccu CLK_CPU_C0_HI>, <&ccu CLK_CPU_C1_HI>;
-		clock-names = "ace0","ace1","tcm","cci","pll3", "c0hi", "c1hi";
-		cci-hz = /bits/ 64 <614000000>;
-
-		opp1800000000 {
-			opp-hz = /bits/ 64 <1800000000>, /bits/ 64 <1800000000>;
-			tcm-hz = /bits/ 64 <900000000>;
-			ace-hz = /bits/ 64 <900000000>;
-			opp-microvolt = <1050000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1600000000 {
-			opp-hz = /bits/ 64 <1600000000>, /bits/ 64 <1600000000>;
-			tcm-hz = /bits/ 64 <800000000>;
-			ace-hz = /bits/ 64 <800000000>;
-			opp-microvolt = <1050000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1228800000 {
-			opp-hz = /bits/ 64 <1228800000>, /bits/ 64 <1228800000>;
-			tcm-hz = /bits/ 64 <614400000>;
-			ace-hz = /bits/ 64 <614400000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp1000000000 {
-			opp-hz = /bits/ 64 <1000000000>, /bits/ 64 <1000000000>;
-			tcm-hz = /bits/ 64 <500000000>;
-			ace-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp819000000 {
-			opp-hz = /bits/ 64 <819000000>, /bits/ 64 <819000000>;
-			opp-microvolt = <950000>;
-			tcm-hz = /bits/ 64 <409500000>;
-			ace-hz = /bits/ 64 <409500000>;
-			clock-latency-ns = <200000>;
-		};
-
-		opp614400000 {
-			opp-hz = /bits/ 64 <614400000>, /bits/ 64 <614400000>;
-			tcm-hz = /bits/ 64 <307200000>;
-			ace-hz = /bits/ 64 <307200000>;
-			opp-microvolt = <950000>;
-			clock-latency-ns = <200000>;
-		};
-	};
-};
-
-&cpu_0 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_1 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_2 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_3 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_4 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_5 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_6 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
-
-&cpu_7 {
-	clst-supply = <&dcdc_1>;
-	clocks = <&ccu CLK_CPU_C0_CORE>, <&ccu CLK_CPU_C1_CORE>;
-	clock-names = "cls0", "cls1";
-	operating-points-v2 = <&clst_core_opp_table0>, <&clst_core_opp_table1>, <&clst_core_opp_table2>;
-};
diff --git a/arch/riscv/boot/dts/spacemit/m1-x_thermal_cooling.dtsi b/arch/riscv/boot/dts/spacemit/m1-x_thermal_cooling.dtsi
deleted file mode 100644
index 3a0252791dcb..000000000000
--- a/arch/riscv/boot/dts/spacemit/m1-x_thermal_cooling.dtsi
+++ /dev/null
@@ -1,106 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
-/* Copyright (c) 2023 Spacemit, Inc */
-
-&thermal_zones {
-	cluster0_thermal {
-		polling-delay = <0>;
-		polling-delay-passive = <0>;
-		thermal-sensors = <&thermal 3>;
-
-		thermal0_trips: trips {
-			cls0_trip0: cls0-trip-point0 {
-				temperature = <90000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls0_trip1: cls0-trip-point1 {
-				temperature = <95000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls0_trip2: cls0-trip-point2 {
-				temperature = <105000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls0_trip3: cls0-trip-point3 {
-				temperature = <115000>;
-				hysteresis = <5000>;
-				type = "critical";
-			};
-		};
-
-		cooling-maps {
-			map0 {
-				trip = <&cls0_trip0>;
-				cooling-device = <&cpu_0 1 1>,
-						 <&cpu_1 1 1>,
-						 <&cpu_2 1 1>,
-						 <&cpu_3 1 1>,
-						 <&cpu_4 1 1>,
-						 <&cpu_5 1 1>,
-						 <&cpu_6 1 1>,
-						 <&cpu_7 1 1>;
-			};
-
-			map1 {
-				trip = <&cls0_trip1>;
-				cooling-device = <&cpu_0 2 3>,
-						 <&cpu_1 2 3>,
-						 <&cpu_2 2 3>,
-						 <&cpu_3 2 3>,
-						 <&cpu_4 2 3>,
-						 <&cpu_5 2 3>,
-						 <&cpu_6 2 3>,
-						 <&cpu_7 2 3>;
-			};
-
-			map2 {
-				trip = <&cls0_trip2>;
-				cooling-device = <&cpu_0 4 5>,
-						 <&cpu_1 4 5>,
-						 <&cpu_2 4 5>,
-						 <&cpu_3 4 5>,
-						 <&cpu_4 4 5>,
-						 <&cpu_5 4 5>,
-						 <&cpu_6 4 5>,
-						 <&cpu_7 4 5>;
-			};
-		};
-	};
-
-	cluster1_thermal {
-		polling-delay = <0>;
-		polling-delay-passive = <0>;
-		thermal-sensors = <&thermal 4>;
-
-		thermal1_trips: trips {
-			cls1_trip0: cls1-trip-point0 {
-				temperature = <90000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls1_trip1: cls1-trip-point1 {
-				temperature = <95000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls1_trip2: cls1-trip-point2 {
-				temperature = <105000>;
-				hysteresis = <5000>;
-				type = "passive";
-			};
-
-			cls1_trip3: cls1-trip-point3 {
-				temperature = <115000>;
-				hysteresis = <5000>;
-				type = "critical";
-			};
-		};
-	};
-};
diff --git a/arch/riscv/configs/k1_defconfig b/arch/riscv/configs/k1_defconfig
index 90f1b8eb4a25..886618a5d211 100644
--- a/arch/riscv/configs/k1_defconfig
+++ b/arch/riscv/configs/k1_defconfig
@@ -499,6 +499,8 @@ CONFIG_DEVTMPFS_MOUNT=y
 # CONFIG_ARM_SCMI_POWER_DOMAIN is not set
 # CONFIG_ARM_SCPI_POWER_DOMAIN is not set
 CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_OF_PARTS is not set
 CONFIG_MTD_BLOCK=y
 # CONFIG_MTD_SPEAR_SMI is not set
 CONFIG_MTD_SPI_NAND=y
@@ -642,6 +644,7 @@ CONFIG_USB_USBNET=y
 # CONFIG_USB_NET_AX88179_178A is not set
 CONFIG_USB_NET_CDC_NCM=m
 # CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_QMI_WWAN_F=m
 CONFIG_USB_NET_QMI_WWAN=m
 CONFIG_USB_NET_ASIX=m
 # CONFIG_WLAN_VENDOR_ADMTEK is not set
@@ -666,7 +669,6 @@ CONFIG_RTL8852BE=m
 # CONFIG_WLAN_VENDOR_QUANTENNA is not set
 CONFIG_AIC_WLAN_SUPPORT=y
 CONFIG_AIC8800_WLAN_SUPPORT=m
-CONFIG_AIC_LOADFW_SUPPORT=m
 CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
@@ -714,6 +716,9 @@ CONFIG_SPACEMIT_WATCHDOG=y
 CONFIG_MFD_SPACEMIT_PMIC=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_SPACEMIT=y
+CONFIG_RC_CORE=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_SPACEMIT=y
 # CONFIG_MEDIA_CEC_SUPPORT is not set
 CONFIG_MEDIA_SUPPORT=y
 # CONFIG_DVB_NET is not set
@@ -972,6 +977,8 @@ CONFIG_USB_CONFIGFS=y
 CONFIG_USB_CONFIGFS_RNDIS=y
 CONFIG_USB_CONFIGFS_MASS_STORAGE=y
 CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
 CONFIG_USB_CONFIGFS_F_UVC=y
 CONFIG_USB_CONFIGFS_F_TCM=y
 CONFIG_TYPEC=m
diff --git a/drivers/cpufreq/cpufreq-dt.c b/drivers/cpufreq/cpufreq-dt.c
index 3ea6a9207ce3..47d18d46218d 100644
--- a/drivers/cpufreq/cpufreq-dt.c
+++ b/drivers/cpufreq/cpufreq-dt.c
@@ -191,10 +191,20 @@ static int cpufreq_exit(struct cpufreq_policy *policy)
 	return 0;
 }
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+extern int spacmeit_cpufreq_veritfy(struct cpufreq_policy_data *policy);
+extern void spacemit_cpufreq_ready(struct cpufreq_policy *policy);
+#endif
+
 static struct cpufreq_driver dt_cpufreq_driver = {
 	.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK |
 		 CPUFREQ_IS_COOLING_DEV,
+#ifndef CONFIG_SOC_SPACEMIT_K1X
 	.verify = cpufreq_generic_frequency_table_verify,
+#else
+	.verify = spacmeit_cpufreq_veritfy,
+	.ready = spacemit_cpufreq_ready,
+#endif
 	.target_index = set_target,
 	.get = cpufreq_generic_get,
 	.init = cpufreq_init,
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index df445b44e9ec..3e333a8ef7d6 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -2811,11 +2811,31 @@ static int create_boost_sysfs_file(void)
 	return ret;
 }
 
+#ifndef CONFIG_SOC_SPACEMIT_K1X
 static void remove_boost_sysfs_file(void)
 {
 	if (cpufreq_boost_supported())
 		sysfs_remove_file(cpufreq_global_kobject, &boost.attr);
 }
+#else
+void remove_boost_sysfs_file(void)
+{
+	if (cpufreq_boost_supported())
+		sysfs_remove_file(cpufreq_global_kobject, &boost.attr);
+}
+
+void remove_policy_boost_sysfs_file(struct cpufreq_policy *policy)
+{
+	if (cpufreq_driver->attr[CPUFREQ_BOOST_FREQ]) {
+		sysfs_remove_file(&policy->kobj,
+				&((cpufreq_driver->attr[CPUFREQ_BOOST_FREQ])->attr));
+	}
+
+	if (cpufreq_boost_supported()) {
+		sysfs_remove_file(&policy->kobj, &local_boost.attr);
+	}
+}
+#endif
 
 int cpufreq_enable_boost_support(void)
 {
diff --git a/drivers/cpufreq/freq_table.c b/drivers/cpufreq/freq_table.c
index c17dc51a5a02..a58db13292f5 100644
--- a/drivers/cpufreq/freq_table.c
+++ b/drivers/cpufreq/freq_table.c
@@ -57,7 +57,9 @@ int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 	 * If the driver has set its own cpuinfo.max_freq above max_freq, leave
 	 * it as is.
 	 */
+#ifndef  CONFIG_SOC_SPACEMIT_K1X
 	if (policy->cpuinfo.max_freq < max_freq)
+#endif
 		policy->max = policy->cpuinfo.max_freq = max_freq;
 
 	if (policy->min == ~0)
diff --git a/drivers/cpufreq/spacemit-cpufreq.c b/drivers/cpufreq/spacemit-cpufreq.c
index 6636edaf9991..745844e9d2b2 100644
--- a/drivers/cpufreq/spacemit-cpufreq.c
+++ b/drivers/cpufreq/spacemit-cpufreq.c
@@ -28,24 +28,33 @@ struct private_data {
 	int opp_token;
 };
 
+static u32 product_prop = 0, wafer_prop = 0;
+
 #ifdef CONFIG_CPU_HOTPLUG_THERMAL
 struct thermal_cooling_device **ghotplug_cooling;
 extern struct thermal_cooling_device **
 of_hotplug_cooling_register(struct cpufreq_policy *policy);
 #endif
 
+#define FREQ_TABLE_0		(0)
+#define FREQ_TABLE_1		(1)
+#define FREQ_TABLE_2		(2)
+
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+
 #define TURBO0_FREQUENCY		(1600000000)
 #define TURBO1_FREQUENCY		(3200000000)
-#define STABLE_FREQUENCY	(1200000000)
+#define STABLE_FREQUENCY		(1200000000)
 
-#define FILTER_POINTS_0		(135)
-#define FILTER_POINTS_1		(142)
+#define FILTER_POINTS_0			(135)
+#define FILTER_POINTS_1			(142)
 
-#define FREQ_TABLE_0		(0)
-#define FREQ_TABLE_1		(1)
-#define FREQ_TABLE_2		(2)
+#define K1_MAX_FREQ_LIMITATION		(1600000)
+#define M1_MAX_FREQ_LIMITATION		(1800000)
+
+#endif
 
-#define PRODUCT_ID_M1		(0x36070000)
+#define PRODUCT_ID_M1			(0x36070000)
 
 static int spacemit_policy_notifier(struct notifier_block *nb,
                                   unsigned long event, void *data)
@@ -408,13 +417,73 @@ static int spacemit_dt_cpufreq_pre_early_init(struct device *dev, int cpu, int i
 	return ret;
 }
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+int spacmeit_cpufreq_veritfy(struct cpufreq_policy_data *policy)
+{
+	struct cpufreq_frequency_table *pos;
+	unsigned int freq, next_larger = ~0;
+	bool found = false;
+
+	if (!policy->freq_table)
+		return -ENODEV;
+
+	if ((wafer_prop << 16 | product_prop) == PRODUCT_ID_M1) {
+		/* M1 */
+		/* can update to 1.8G */
+		cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+					policy->cpuinfo.max_freq);
+	} else {
+		/* K1 */
+		/* only 1.6G allowed max */
+		policy->max = policy->max > K1_MAX_FREQ_LIMITATION ? K1_MAX_FREQ_LIMITATION : policy->max;
+		cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+					K1_MAX_FREQ_LIMITATION);
+	}
+
+	cpufreq_for_each_valid_entry(pos, policy->freq_table) {
+		freq = pos->frequency;
+
+		if ((freq >= policy->min) && (freq <= policy->max)) {
+			found = true;
+			break;
+		}
+
+		if ((next_larger > freq) && (freq > policy->max))
+			next_larger = freq;
+	}
+
+	if (!found) {
+		policy->max = next_larger;
+		cpufreq_verify_within_cpu_limits(policy);
+	}
+
+	pr_debug("verification lead to (%u - %u kHz) for cpu %u\n",
+				policy->min, policy->max, policy->cpu);
+	return 0;
+}
+
+extern void remove_boost_sysfs_file(void);
+extern void remove_policy_boost_sysfs_file(struct cpufreq_policy *policy);
+
+void spacemit_cpufreq_ready(struct cpufreq_policy *policy)
+{
+	if ((wafer_prop << 16 | product_prop) == PRODUCT_ID_M1) {
+		/* M1 */
+	} else {
+		/* K1 or other */
+		remove_policy_boost_sysfs_file(policy);
+		remove_boost_sysfs_file();
+	}
+}
+
+#endif
+
 static int spacemit_dt_cpufreq_pre_probe(struct platform_device *pdev)
 {
 	int cpu, ret;
 	struct device_node *cpus;
 	struct device_node *product_id, *wafer_id;
 	u32 prop = 0;
-	u32 product_prop = 0, wafer_prop = 0;
 
 	if (strncmp(pdev->name, "cpufreq-dt", 10) != 0)
 		return 0;
@@ -434,6 +503,7 @@ static int spacemit_dt_cpufreq_pre_probe(struct platform_device *pdev)
 		pr_info("Spacemit Platform with no 'product-id' in DTS\n");
 	}
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
 	if ((wafer_prop << 16 | product_prop) == PRODUCT_ID_M1) {
 		for_each_possible_cpu(cpu) {
 			if (prop <= FILTER_POINTS_0)
@@ -450,6 +520,7 @@ static int spacemit_dt_cpufreq_pre_probe(struct platform_device *pdev)
 			spacemit_dt_cpufreq_pre_early_init(&pdev->dev, cpu, FREQ_TABLE_0);
 		}
 	}
+#endif
 
 	return 0;
 }
diff --git a/drivers/media/rc/ir-spacemit.c b/drivers/media/rc/ir-spacemit.c
index e022603e743c..65572dbb2418 100644
--- a/drivers/media/rc/ir-spacemit.c
+++ b/drivers/media/rc/ir-spacemit.c
@@ -10,8 +10,13 @@
 #include <linux/of_platform.h>
 #include <linux/reset.h>
 #include <media/rc-core.h>
+#include <linux/rpmsg.h>
 
 #define SPACEMIT_IR_DEV "spacemit-ir"
+#define SPACEMIT_RIR_DEV "spacemit-rir"
+#define IRQUP_MSG	"irqon"
+#define STARTUP_MSG		"startup"
+#define STARTUP_OK_MSG		"startup-ok"
 
 /*Registers*/
 #define SPACEMIT_IRC_EN 0x0
@@ -52,22 +57,29 @@
 #define SPACEMIT_IR_TIMEOUT 10000
 #define IRFIFO_DEF_CMP 1
 
+static void *private_data[1];
+static const struct of_device_id spacemit_rir_match[];
+
 struct spacemit_ir {
 	struct rc_dev *rc;
 	void __iomem *base;
 	int irq;
 	int fifo_size;
 	int clkdiv;
-	struct clk *apb_clk;
+	int freq;
 	const char      *map_name;
-#ifndef CONFIG_SOC_SPACEMIT_K1X
 	struct clk *clk;
 	struct reset_control *rst;
-#endif
+};
+
+struct instance_data {
+	struct rpmsg_device *rpdev;
+	struct spacemit_ir *ir;
 };
 
 struct spacemit_ir_data {
 	int fifo_size;
+	void **pdate;
 };
 
 static irqreturn_t spacemit_ir_irq(int irqno,void *dev_id)
@@ -106,11 +118,9 @@ static irqreturn_t spacemit_ir_irq(int irqno,void *dev_id)
 static int spacemit_ir_config(struct rc_dev *rc_dev)
 {
 	struct spacemit_ir *ir = rc_dev->priv;
-	//u32 base_clk = clk_get_rate(ir->apb_clk);
-	u32 base_clk = 50000000;
 
 	/*set clkdiv*/
-	ir->clkdiv = DIV_ROUND_UP(base_clk, IR_FREQ)-1;
+	ir->clkdiv = DIV_ROUND_UP(ir->freq, IR_FREQ) - 1;
 	writel(ir->clkdiv, ir->base + SPACEMIT_IR_CLKDIV);
 
 	writel(IRQ_CLEAR_ALL,ir->base + SPACEMIT_IR_INTSTA);
@@ -136,33 +146,23 @@ static int spacemit_ir_hw_init(struct device *dev)
 	struct spacemit_ir *ir = dev_get_drvdata(dev);
 	int ret;
 
-#if 0
-#ifndef CONFIG_SOC_SPACEMIT_K1X
 	ret = reset_control_deassert(ir->rst);
 	if(ret)
-		goto disable_apb_clk;
-#endif
+		return ret;
 
 	ret = clk_prepare_enable(ir->clk);
 	if(ret){
 		dev_err(dev,"failed to enable ir clk\n");
-#ifdef CONFIG_SOC_SPACEMIT_K1X
 		goto exit;
-#endif
 	}
-#endif
 
 	spacemit_ir_config(ir->rc);
 	writel(IR_IRQ_ENALL, ir->base + SPACEMIT_IR_INTEN);
 	writel(SPACEMIT_IR_ENABLE, ir->base + SPACEMIT_IRC_EN);
 	return 0;
 
-#if 0
 exit:
 	reset_control_assert(ir->rst);
-disable_apb_clk:
-	clk_disable_unprepare(ir->apb_clk);
-#endif
 
 	return ret;
 }
@@ -171,12 +171,8 @@ static void spacemit_ir_hw_exit(struct device *dev)
 {
 	struct spacemit_ir *ir = dev_get_drvdata(dev);
 
-#ifdef CONFIG_SOC_SPACEMIY_K1X
 	clk_disable_unprepare(ir->clk);
 	reset_control_assert(ir->rst);
-#endif
-
-	clk_disable_unprepare(ir->apb_clk);
 }
 
 static int spacemit_ir_probe(struct platform_device *pdev)
@@ -184,37 +180,36 @@ static int spacemit_ir_probe(struct platform_device *pdev)
 	int ret = 0;
 	struct device *dev = &pdev->dev;
 	struct device_node *dn = dev->of_node;
-#if 0
-	u32 ir_clk;
-#endif
+	const struct of_device_id *of_id;
+	struct instance_data *idata;
+	struct rpmsg_device *rpdev;
 	struct spacemit_ir *ir;
 
 	ir = devm_kzalloc(dev, sizeof(struct spacemit_ir), GFP_KERNEL);
 	if (!ir)
 		return -ENOMEM;
 
-#if 0
-	ir->clk = devm_clk_get(dev, "ir");
+	ir->freq = 0;
+	ir->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(ir->clk)) {
 		dev_err(dev, "failed to get a ir clock.\n");
 		return PTR_ERR(ir->clk);
 	}
-#ifndef CONFIG_SOC_SPACEMIT_K1X
 	ir->rst = devm_reset_control_get_exclusive(dev, NULL);
 	if (IS_ERR(ir->rst))
 		return PTR_ERR(ir->rst);
-#endif
 
 	/* Base clock frequency (optional) */
-	of_property_read_u32(dn, "clock-frequency", &ir_clk);
-
-	ret = clk_set_rate(ir->clk, ir_clk);
-	if(ret){
-		dev_err(dev,"set ir base clock failed!\n");
-		return ret;
+	of_property_read_u32(dn, "clock-frequency", &ir->freq);
+	if(!ir->freq) {
+		ir->freq = clk_get_rate(ir->clk);
+		if(!ir->freq) {
+			dev_err(dev, "failed to get ir function clk-freq\n");
+			return -ENODEV;
+		}
 	}
-	dev_dbg(dev, "set base clock frequency to %d Hz.\n", ir_clk);
-#endif
+
+	dev_dbg(dev, "ir base clock frequency : %d Hz.\n", ir->freq);
 
 	ir->base = devm_platform_ioremap_resource(pdev,0);
 	if(IS_ERR(ir->base)){
@@ -251,16 +246,33 @@ static int spacemit_ir_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ir);
 
-	ir->irq = platform_get_irq(pdev, 0);
-	if (ir->irq < 0) {
-		ret = ir->irq;
-		goto free_dev;
-	}
+	//ir->irq = platform_get_irq(pdev, 0);
+	if (of_get_property(pdev->dev.of_node, "rcpu-ir", NULL)) {
+		/* rcpu service */
+		of_id = of_match_device(spacemit_rir_match, &pdev->dev);
+		if (!of_id) {
+			pr_err("Unable to match OF ID\n");
+			ret = -ENODEV;
+			goto free_dev;
+		}
 
-	ret = devm_request_irq(dev, ir->irq, spacemit_ir_irq, 0, SPACEMIT_IR_DEV, ir);
-	if (ret) {
-		dev_err(dev, "failed request irq\n");
-		goto free_dev;
+		idata = (struct instance_data *)(((struct spacemit_ir_data *)of_id->data)->pdate)[0];
+		rpdev = idata->rpdev;
+		idata->ir = ir;
+
+		ret = rpmsg_send(rpdev->ept, STARTUP_MSG, strlen(STARTUP_MSG));
+		if (ret) {
+			dev_err(&rpdev->dev, "rpmsg_send failed: %d\n", ret);
+			goto free_dev;
+		}
+
+	} else {
+		ir->irq = platform_get_irq(pdev, 0);
+		ret = devm_request_irq(dev, ir->irq, spacemit_ir_irq, 0, SPACEMIT_IR_DEV, ir);
+		if (ret) {
+			dev_err(dev, "failed request irq\n");
+			goto free_dev;
+		}
 	}
 
 	ret = spacemit_ir_hw_init(dev);
@@ -303,13 +315,9 @@ static const struct spacemit_ir_data spacemit_k1x_ir_data = {
 	.fifo_size = 32,
 };
 
-static const struct spacemit_ir_data spacemit_k1pro_ir_data = {
-	.fifo_size = 32,
-};
-
 static const struct of_device_id spacemit_ir_match[] = {
 	{
-		.compatible = "spacemit,irc",
+		.compatible = "spacemit,k1x-irc",
 		.data = &spacemit_k1x_ir_data,
 	},
 };
@@ -327,5 +335,88 @@ static struct platform_driver spacemit_ir_driver = {
 
 module_platform_driver(spacemit_ir_driver);
 
+static struct spacemit_ir_data spacemit_k1x_rir_data = {
+	.fifo_size = 32,
+	.pdate = &private_data[0],
+};
+
+static const struct of_device_id spacemit_rir_match[] = {
+	{
+		.compatible = "spacemit,k1x-rirc",
+		.data = &spacemit_k1x_rir_data,
+	},
+};
+
+static struct platform_driver spacemit_rir_driver = {
+	.probe = spacemit_ir_probe,
+	.remove = spacemit_ir_remove,
+	.shutdown = spacemit_ir_shutdown,
+	.driver = {
+		.name = SPACEMIT_RIR_DEV,
+		.of_match_table = spacemit_rir_match,
+		.pm = &spacemit_ir_pm_ops,
+	},
+};
+
+static struct rpmsg_device_id rpmsg_driver_rir_id_table[] = {
+	{ .name	= "rir-service", .driver_data = 0, },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_rir_id_table);
+
+static int rpmsg_rir_client_cb(struct rpmsg_device *rpdev, void *data,
+		int len, void *priv, u32 src)
+{
+	struct instance_data *idata = dev_get_drvdata(&rpdev->dev);
+	struct spacemit_ir *dev = idata->ir;
+	int ret;
+
+	spacemit_ir_irq(0, (void *)dev);
+
+	ret = rpmsg_send(rpdev->ept, IRQUP_MSG, strlen(IRQUP_MSG));
+	if (ret) {
+		dev_err(&rpdev->dev, "rpmsg_send failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rpmsg_rir_client_probe(struct rpmsg_device *rpdev)
+{
+	struct instance_data *idata;
+
+	dev_info(&rpdev->dev, "new channel: 0x%x -> 0x%x!\n",
+					rpdev->src, rpdev->dst);
+
+	idata = devm_kzalloc(&rpdev->dev, sizeof(*idata), GFP_KERNEL);
+	if (!idata)
+		return -ENOMEM;
+
+	dev_set_drvdata(&rpdev->dev, idata);
+	idata->rpdev = rpdev;
+
+	private_data[0] = (void *)idata;
+
+	platform_driver_register(&spacemit_rir_driver);
+
+	return 0;
+}
+
+static void rpmsg_rir_client_remove(struct rpmsg_device *rpdev)
+{
+	dev_info(&rpdev->dev, "rpmsg rcan client driver is removed\n");
+	platform_driver_unregister(&spacemit_rir_driver);
+}
+
+static struct rpmsg_driver rpmsg_rir_client = {
+	.drv.name	= KBUILD_MODNAME,
+	.id_table	= rpmsg_driver_rir_id_table,
+	.probe		= rpmsg_rir_client_probe,
+	.callback	= rpmsg_rir_client_cb,
+	.remove		= rpmsg_rir_client_remove,
+};
+module_rpmsg_driver(rpmsg_rir_client);
+
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Spacemit");
\ No newline at end of file
+MODULE_AUTHOR("Spacemit");
diff --git a/drivers/mmc/host/sdhci-of-k1x.c b/drivers/mmc/host/sdhci-of-k1x.c
index fc9d388d637b..66a183817205 100644
--- a/drivers/mmc/host/sdhci-of-k1x.c
+++ b/drivers/mmc/host/sdhci-of-k1x.c
@@ -1754,7 +1754,7 @@ static int spacemit_sdhci_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int spacemit_sdhci_remove(struct platform_device *pdev)
+static void spacemit_sdhci_remove(struct platform_device *pdev)
 {
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
@@ -1781,8 +1781,6 @@ static int spacemit_sdhci_remove(struct platform_device *pdev)
 	}
 
 	sdhci_pltfm_free(pdev);
-
-	return 0;
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -1896,7 +1894,7 @@ static struct platform_driver spacemit_sdhci_driver = {
 		.pm	= SDHCI_SPACEMIT_PMOPS,
 	},
 	.probe		= spacemit_sdhci_probe,
-	.remove		= spacemit_sdhci_remove,
+	.remove_new	= spacemit_sdhci_remove,
 };
 
 module_platform_driver(spacemit_sdhci_driver);
diff --git a/drivers/net/can/flexcan/flexcan-core.c b/drivers/net/can/flexcan/flexcan-core.c
index 549b4092b733..d5c0e0cc7e42 100644
--- a/drivers/net/can/flexcan/flexcan-core.c
+++ b/drivers/net/can/flexcan/flexcan-core.c
@@ -2254,6 +2254,10 @@ static int flexcan_probe(struct platform_device *pdev)
 	of_id = of_match_device(flexcan_of_match, &pdev->dev);
 	if (of_id)
 		devtype_data = of_id->data;
+	else if (of_match_device(r_flexcan_of_match, &pdev->dev)) {
+		of_id = of_match_device(r_flexcan_of_match, &pdev->dev);
+		devtype_data = of_id->data;
+	}
 	else if (platform_get_device_id(pdev)->driver_data)
 		devtype_data = (struct flexcan_devtype_data *)
 			platform_get_device_id(pdev)->driver_data;
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 912ba6d05529..b288a84a19f0 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -529,6 +529,29 @@ config USB_NET_KALMIA
 	  To compile this driver as a module, choose M here: the
 	  module will be called kalmia.
 
+config USB_NET_QMI_WWAN_F
+	tristate "QMI WWAN driver for Fibocom Qualcomm MSM based 3G and LTE modems"
+	depends on USB_USBNET
+	select USB_WDM
+	help
+	  Support Fibocom WWAN LTE/3G devices based on Qualcomm Modem chipsets.
+	  Examples of such devices are
+	    * Fibocom NL668
+	    * Fibocom FG150
+
+	  This driver will only drive the ethernet part of the chips.
+	  The devices require additional configuration to be usable.
+	  Multiple management interfaces with linux drivers are
+	  available:
+
+	    * option: AT commands on /dev/ttyUSBx
+	    * cdc-wdm: Qualcomm MSM Interface (QMI) protocol on /dev/cdc-wdmx
+
+	  Fibocom QMI dial app is recommended to use.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called qmi_wwan_f.
+
 config USB_NET_QMI_WWAN
 	tristate "QMI WWAN driver for Qualcomm MSM based 3G and LTE modems"
 	depends on USB_USBNET
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index d6b22ee47ba4..cccef21b099d 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_USB_NET_CX82310_ETH)	+= cx82310_eth.o
 obj-$(CONFIG_USB_NET_CDC_NCM)	+= cdc_ncm.o
 obj-$(CONFIG_USB_NET_HUAWEI_CDC_NCM)	+= huawei_cdc_ncm.o
 obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
+obj-$(CONFIG_USB_NET_QMI_WWAN_F)	+= qmi_wwan_f.o
 obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
 obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
diff --git a/drivers/net/usb/asix_usb/ax_main.c b/drivers/net/usb/asix_usb/ax_main.c
index 93253f0e144f..20fbb2bf04ce 100644
--- a/drivers/net/usb/asix_usb/ax_main.c
+++ b/drivers/net/usb/asix_usb/ax_main.c
@@ -2095,12 +2095,17 @@ static int ax_get_mac_address(struct ax_device *axdev)
 {
 	struct net_device *netdev = axdev->netdev;
 
+	char addr_buf[ETH_ALEN];
+	memset(addr_buf, 0, ETH_ALEN);
+
 	if (ax_read_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
-			ETH_ALEN, (void *)netdev->dev_addr, 0) < 0) {
+			ETH_ALEN, (void *)addr_buf, 0) < 0) {
 		dev_err(&axdev->intf->dev, "Failed to read MAC address");
 		return -ENODEV;
 	}
 
+	eth_hw_addr_set(netdev, addr_buf);
+
 	if (ax_check_ether_addr(axdev))
 		dev_warn(&axdev->intf->dev, "Found invalid MAC address value");
 
diff --git a/drivers/net/usb/qmi_wwan_f.c b/drivers/net/usb/qmi_wwan_f.c
new file mode 100644
index 000000000000..08dd67d30996
--- /dev/null
+++ b/drivers/net/usb/qmi_wwan_f.c
@@ -0,0 +1,2537 @@
+/*
+ * Copyright (c) 2012  Bjørn Mork <bjorn@mork.no>
+ *
+ * The probing code is heavily inspired by cdc_ether, which is:
+ * Copyright (C) 2003-2005 by David Brownell
+ * Copyright (C) 2006 by Ole Andre Vadla Ravnas (ActiveSync)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/time.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,16,0) //8b094cd03b4a3793220d8d8d86a173bfea8c285b
+#include <linux/timekeeping.h>
+#else
+#define timespec64  timespec
+#define ktime_get_ts64 ktime_get_ts
+#define timespec64_sub timespec_sub
+#endif
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/usb/cdc.h>
+#include <linux/usb/usbnet.h>
+#include <linux/usb/cdc-wdm.h>
+
+#ifndef ETH_P_MAP
+#define ETH_P_MAP 0xDA1A
+#endif
+
+#if (ETH_P_MAP == 0x00F9)
+#undef ETH_P_MAP
+#define ETH_P_MAP 0xDA1A
+#endif
+
+#ifndef ARPHRD_RAWIP
+#define ARPHRD_RAWIP ARPHRD_NONE
+#endif
+
+#ifdef CONFIG_PINCTRL_IPQ807x
+#define CONFIG_QCA_NSS_DRV
+#endif
+
+#if 1//def CONFIG_QCA_NSS_DRV
+#define _RMNET_NSS_H_
+#define _RMENT_NSS_H_
+struct rmnet_nss_cb {
+        int (*nss_create)(struct net_device *dev);
+        int (*nss_free)(struct net_device *dev);
+        int (*nss_tx)(struct sk_buff *skb);
+};
+static struct rmnet_nss_cb *rmnet_nss_callbacks __rcu __read_mostly;
+#ifdef CONFIG_QCA_NSS_DRV
+static uint __read_mostly qca_nss_enabled = 1;
+module_param( qca_nss_enabled, uint, S_IRUGO);
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,0,0 )) //1e9e39f4a29857a396ac7b669d109f697f66695e
+#define usbnet_set_skb_tx_stats(skb, packets, bytes_delta) do { dev->net->stats.tx_packets += packets; } while(0)
+#endif
+
+/* This driver supports wwan (3G/LTE/?) devices using a vendor
+ * specific management protocol called Qualcomm MSM Interface (QMI) -
+ * in addition to the more common AT commands over serial interface
+ * management
+ *
+ * QMI is wrapped in CDC, using CDC encapsulated commands on the
+ * control ("master") interface of a two-interface CDC Union
+ * resembling standard CDC ECM.  The devices do not use the control
+ * interface for any other CDC messages. Most likely because the
+ * management protocol is used in place of the standard CDC
+ * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE
+ *
+ * Alternatively, control and data functions can be combined in a
+ * single USB interface.
+ *
+ * Handling a protocol like QMI is out of the scope for any driver.
+ * It is exported as a character device using the cdc-wdm driver as
+ * a subdriver, enabling userspace applications ("modem managers") to
+ * handle it.
+ *
+ * These devices may alternatively/additionally be configured using AT
+ * commands on a serial interface
+ */
+#define VERSION_NUMBER "V1.0.5"
+#define FIBOCOM_WWAN_VERSION "Fibocom_QMI_WWAN_Driver_"VERSION_NUMBER
+static const char driver_name[] = "qmi_wwan_f";
+
+/* driver specific data */
+struct qmi_wwan_state {
+    struct usb_driver *subdriver;
+    atomic_t pmcount;
+    unsigned long unused;
+    struct usb_interface *control;
+    struct usb_interface *data;
+};
+
+/* default ethernet address used by the modem */
+static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+
+#if 1
+#define FIBOCOM_WWAN_QMAP 4 //MAX is 7
+
+#if defined(FIBOCOM_WWAN_QMAP)
+#define FIBOCOM_QMAP_MUX_ID 0x81
+
+static uint __read_mostly qmap_mode = 0;
+module_param( qmap_mode, uint, S_IRUGO);
+module_param_named( rx_qmap, qmap_mode, uint, S_IRUGO );
+#endif
+
+#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+#define FIBOCOM_BRIDGE_MODE
+#endif
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static uint __read_mostly bridge_mode = 0/*|BIT(1)*/;
+module_param( bridge_mode, uint, S_IRUGO );
+#endif
+
+#if defined(FIBOCOM_WWAN_QMAP)
+#define FIBOCOM_UL_DATA_AGG 1
+
+#if defined(FIBOCOM_UL_DATA_AGG)
+struct tx_agg_ctx {
+    /* QMIWDS_ADMIN_SET_DATA_FORMAT_RESP TLV_0x17 and TLV_0x18 */
+    uint ul_data_aggregation_max_datagrams; //UplinkDataAggregationMaxDatagramsTlv
+    uint ul_data_aggregation_max_size; //UplinkDataAggregationMaxSizeTlv
+    uint dl_minimum_padding; //0x1A
+};
+#endif
+
+typedef struct {
+    unsigned int size;
+    unsigned int rx_urb_size;
+    unsigned int ep_type;
+    unsigned int iface_id;
+    unsigned int qmap_mode;
+    unsigned int qmap_version;
+    unsigned int dl_minimum_padding;
+    char ifname[8][16];
+    unsigned char mux_id[8];
+} RMNET_INFO;
+
+typedef struct sQmiWwanQmap
+{
+    struct usbnet *mpNetDev;
+    struct driver_info driver_info;
+    atomic_t refcount;
+    struct net_device *mpQmapNetDev[FIBOCOM_WWAN_QMAP];
+    uint link_state;
+    uint qmap_mode;
+    uint qmap_size;
+    uint qmap_version;
+    struct sk_buff_head skb_chain;
+
+#if defined(FIBOCOM_UL_DATA_AGG)
+    struct tx_agg_ctx tx_ctx;
+    struct tasklet_struct    txq;
+#endif
+
+#ifdef FIBOCOM_BRIDGE_MODE
+    uint bridge_mode;
+    uint bridge_ipv4;
+    unsigned char bridge_mac[ETH_ALEN];
+#endif
+    uint use_rmnet_usb;
+    RMNET_INFO rmnet_info;
+} sQmiWwanQmap;
+//2021-03-19 willa.liu@fibocom.com changed begin for support mantis 0073129
+//#if LINUX_VERSION_CODE > KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,15,0)
+//2021-03-19 willa.liu@fibocom.com changed end for support mantis 0073129
+#define MHI_NETDEV_STATUS64
+#endif
+struct qmap_priv {
+    struct usbnet *dev;
+    struct net_device *real_dev;
+    struct net_device *self_dev;
+    u8 offset_id;
+    u8 mux_id;
+    u8 qmap_version;
+    u8 link_state;
+
+#if defined(MHI_NETDEV_STATUS64)
+    struct pcpu_sw_netstats __percpu *stats64;
+#endif
+
+    spinlock_t agg_lock;
+    struct sk_buff *agg_skb;
+    unsigned agg_count;
+    struct timespec64 agg_time;
+    struct hrtimer agg_hrtimer;
+    struct work_struct agg_wq;
+
+#ifdef FIBOCOM_BRIDGE_MODE
+    uint bridge_mode;
+    uint bridge_ipv4;
+    unsigned char bridge_mac[ETH_ALEN];
+#endif
+};
+
+struct qmap_hdr {
+    u8 cd_rsvd_pad;
+    u8 mux_id;
+    u16 pkt_len;
+} __packed;
+
+enum rmnet_map_v5_header_type {
+    RMNET_MAP_HEADER_TYPE_UNKNOWN,
+    RMNET_MAP_HEADER_TYPE_COALESCING = 0x1,
+    RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD = 0x2,
+    RMNET_MAP_HEADER_TYPE_ENUM_LENGTH
+};
+
+/* Main QMAP header */
+struct rmnet_map_header {
+    u8  pad_len:6;
+    u8  next_hdr:1;
+    u8  cd_bit:1;
+    u8  mux_id;
+    __be16 pkt_len;
+}  __aligned(1);
+
+/* QMAP v5 headers */
+struct rmnet_map_v5_csum_header {
+    u8  next_hdr:1;
+    u8  header_type:7;
+    u8  hw_reserved:7;
+    u8  csum_valid_required:1;
+    __be16 reserved;
+} __aligned(1);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev);
+#endif
+#endif
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static int bridge_arp_reply(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4) {
+    struct arphdr *parp;
+    u8 *arpptr, *sha;
+    u8  sip[4], tip[4], ipv4[4];
+    struct sk_buff *reply = NULL;
+
+    ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+    ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+    ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+    ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+
+    parp = arp_hdr(skb);
+
+    if (parp->ar_hrd == htons(ARPHRD_ETHER)  && parp->ar_pro == htons(ETH_P_IP)
+        && parp->ar_op == htons(ARPOP_REQUEST) && parp->ar_hln == 6 && parp->ar_pln == 4) {
+        arpptr = (u8 *)parp + sizeof(struct arphdr);
+        sha = arpptr;
+        arpptr += net->addr_len;    /* sha */
+        memcpy(sip, arpptr, sizeof(sip));
+        arpptr += sizeof(sip);
+        arpptr += net->addr_len;    /* tha */
+        memcpy(tip, arpptr, sizeof(tip));
+
+        pr_info("%s sip = %d.%d.%d.%d, tip=%d.%d.%d.%d, ipv4=%d.%d.%d.%d\n", netdev_name(net),
+            sip[0], sip[1], sip[2], sip[3], tip[0], tip[1], tip[2], tip[3], ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
+    //wwan0 sip = 10.151.137.255, tip=10.151.138.0, ipv4=10.151.137.255
+        if (tip[0] == ipv4[0] && tip[1] == ipv4[1] && (tip[2]&0xFC) == (ipv4[2]&0xFC) && tip[3] != ipv4[3])
+            reply = arp_create(ARPOP_REPLY, ETH_P_ARP, *((__be32 *)sip), net, *((__be32 *)tip), sha, default_modem_addr, sha);
+
+        if (reply) {
+            skb_reset_mac_header(reply);
+            __skb_pull(reply, skb_network_offset(reply));
+            reply->ip_summed = CHECKSUM_UNNECESSARY;
+            reply->pkt_type = PACKET_HOST;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+            netif_rx_ni(reply);
+#else
+            netif_rx(reply);
+#endif
+        }
+        return 1;
+    }
+
+    return 0;
+}
+
+static struct sk_buff *bridge_mode_tx_fixup(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4, unsigned char *bridge_mac) {
+    struct ethhdr *ehdr;
+    const struct iphdr *iph;
+
+    skb_reset_mac_header(skb);
+    ehdr = eth_hdr(skb);
+
+    if (ehdr->h_proto == htons(ETH_P_ARP)) {
+        if (bridge_ipv4)
+            bridge_arp_reply(net, skb, bridge_ipv4);
+        return NULL;
+    }
+
+    iph = ip_hdr(skb);
+    //DBG("iphdr: ");
+    //PrintHex((void *)iph, sizeof(struct iphdr));
+
+// 1    0.000000000    0.0.0.0    255.255.255.255    DHCP    362    DHCP Request  - Transaction ID 0xe7643ad7
+    if (ehdr->h_proto == htons(ETH_P_IP) && iph->protocol == IPPROTO_UDP && iph->saddr == 0x00000000 && iph->daddr == 0xFFFFFFFF) {
+        //if (udp_hdr(skb)->dest == htons(67)) //DHCP Request
+        {
+            memcpy(bridge_mac, ehdr->h_source, ETH_ALEN);
+            pr_info("%s PC Mac Address: %02x:%02x:%02x:%02x:%02x:%02x\n", netdev_name(net),
+                bridge_mac[0], bridge_mac[1], bridge_mac[2], bridge_mac[3], bridge_mac[4], bridge_mac[5]);
+        }
+    }
+
+    if (memcmp(ehdr->h_source, bridge_mac, ETH_ALEN)) {
+        return NULL;
+    }
+
+    return skb;
+}
+
+static void bridge_mode_rx_fixup(sQmiWwanQmap *pQmapDev, struct net_device *net, struct sk_buff *skb) {
+    uint bridge_mode = 0;
+    unsigned char *bridge_mac;
+
+    if (pQmapDev->qmap_mode > 1 || pQmapDev->use_rmnet_usb == 1) {
+        struct qmap_priv *priv = netdev_priv(net);
+        bridge_mode = priv->bridge_mode;
+        bridge_mac = priv->bridge_mac;
+    }
+    else {
+        bridge_mode = pQmapDev->bridge_mode;
+        bridge_mac = pQmapDev->bridge_mac;
+    }
+
+    if (bridge_mode)
+        memcpy(eth_hdr(skb)->h_dest, bridge_mac, ETH_ALEN);
+    else
+        memcpy(eth_hdr(skb)->h_dest, net->dev_addr, ETH_ALEN);
+}
+#endif
+
+#if defined(FIBOCOM_WWAN_QMAP)
+static ssize_t qmap_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    return snprintf(buf, PAGE_SIZE, "%d\n",  pQmapDev->qmap_mode);
+}
+
+static DEVICE_ATTR(qmap_mode, S_IRUGO, qmap_mode_show, NULL);
+
+static ssize_t qmap_size_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    return snprintf(buf, PAGE_SIZE, "%u\n",  pQmapDev->qmap_size);
+}
+
+static DEVICE_ATTR(qmap_size, S_IRUGO, qmap_size_show, NULL);
+
+static ssize_t link_state_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    return snprintf(buf, PAGE_SIZE, "0x%x\n",  pQmapDev->link_state);
+}
+
+static ssize_t link_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+    struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    unsigned link_state = 0;
+    unsigned old_link = pQmapDev->link_state;
+    uint offset_id = 0;
+
+    link_state = simple_strtoul(buf, NULL, 0);
+
+    if (pQmapDev->qmap_mode == 1) {
+        pQmapDev->link_state = !!link_state;
+    }
+    else if (pQmapDev->qmap_mode > 1) {
+        offset_id = ((link_state&0x7F) - 1);
+
+        if (offset_id >= pQmapDev->qmap_mode) {
+            dev_info(dev, "%s offset_id is %d. but qmap_mode is %d\n", __func__, offset_id, pQmapDev->qmap_mode);
+            return count;
+        }
+
+        if (link_state&0x80)
+            pQmapDev->link_state &= ~(1 << offset_id);
+        else
+            pQmapDev->link_state |= (1 << offset_id);
+    }
+
+    if (old_link != pQmapDev->link_state) {
+        struct net_device *qmap_net = pQmapDev->mpQmapNetDev[offset_id];
+
+        if (pQmapDev->link_state) {
+            netif_carrier_on(usbnetdev->net);
+        } else {
+            netif_carrier_off(usbnetdev->net);
+        }
+
+        if (qmap_net && qmap_net != netdev) {
+            struct qmap_priv *priv = netdev_priv(qmap_net);
+
+            priv->link_state = !!(pQmapDev->link_state & (1 << offset_id));
+            if (priv->link_state) {
+                netif_carrier_on(qmap_net);
+                if (netif_queue_stopped(qmap_net) && !netif_queue_stopped(usbnetdev->net))
+                    netif_wake_queue(qmap_net);
+            }
+            else {
+                netif_carrier_off(qmap_net);
+            }
+        }
+
+        dev_info(dev, "link_state 0x%x -> 0x%x\n", old_link, pQmapDev->link_state);
+    }
+
+    return count;
+}
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static ssize_t bridge_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+    struct net_device *netdev = to_net_dev(dev);
+    uint old_mode = 0;
+    uint bridge_mode = simple_strtoul(buf, NULL, 0);
+
+    if (netdev->type != ARPHRD_ETHER) {
+        return count;
+    }
+
+    if (is_qmap_netdev(netdev)) {
+        struct qmap_priv *priv = netdev_priv(netdev);
+        old_mode = priv->bridge_mode;
+        priv->bridge_mode = bridge_mode;
+    }
+    else {
+        struct usbnet * usbnetdev = netdev_priv( netdev );
+        struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+        old_mode = pQmapDev->bridge_mode;
+        pQmapDev->bridge_mode = bridge_mode;
+    }
+
+    if (old_mode != bridge_mode) {
+        dev_info(dev, "bridge_mode change to 0x%x\n", bridge_mode);
+    }
+
+    return count;
+}
+
+static ssize_t bridge_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    struct net_device *netdev = to_net_dev(dev);
+    uint bridge_mode = 0;
+
+    if (is_qmap_netdev(netdev)) {
+        struct qmap_priv *priv = netdev_priv(netdev);
+        bridge_mode = priv->bridge_mode;
+    }
+    else {
+        struct usbnet * usbnetdev = netdev_priv( netdev );
+        struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+        bridge_mode = pQmapDev->bridge_mode;
+    }
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", bridge_mode);
+}
+
+static ssize_t bridge_ipv4_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    struct net_device *netdev = to_net_dev(dev);
+    unsigned int bridge_ipv4 = 0;
+    unsigned char ipv4[4];
+
+    if (is_qmap_netdev(netdev)) {
+        struct qmap_priv *priv = netdev_priv(netdev);
+        bridge_ipv4 = priv->bridge_ipv4;
+    }
+    else {
+        struct usbnet * usbnetdev = netdev_priv( netdev );
+        struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+        bridge_ipv4 = pQmapDev->bridge_ipv4;
+    }
+
+    ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+    ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+    ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+    ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+
+    return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",  ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
+}
+
+static ssize_t bridge_ipv4_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+    struct net_device *netdev = to_net_dev(dev);
+
+    if (is_qmap_netdev(netdev)) {
+        struct qmap_priv *priv = netdev_priv(netdev);
+        priv->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+    }
+    else {
+        struct usbnet * usbnetdev = netdev_priv( netdev );
+        struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+        pQmapDev->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+    }
+
+    return count;
+}
+#endif
+
+static DEVICE_ATTR(link_state, S_IWUSR | S_IRUGO, link_state_show, link_state_store);
+#ifdef FIBOCOM_BRIDGE_MODE
+static DEVICE_ATTR(bridge_mode, S_IWUSR | S_IRUGO, bridge_mode_show, bridge_mode_store);
+static DEVICE_ATTR(bridge_ipv4, S_IWUSR | S_IRUGO, bridge_ipv4_show, bridge_ipv4_store);
+#endif
+
+static struct attribute *qmi_wwan_sysfs_attrs[] = {
+    &dev_attr_link_state.attr,
+    &dev_attr_qmap_mode.attr,
+    &dev_attr_qmap_size.attr,
+#ifdef FIBOCOM_BRIDGE_MODE
+    &dev_attr_bridge_mode.attr,
+    &dev_attr_bridge_ipv4.attr,
+#endif
+    NULL,
+};
+
+static struct attribute_group qmi_wwan_sysfs_attr_group = {
+    .attrs = qmi_wwan_sysfs_attrs,
+};
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static struct attribute *qmi_qmap_sysfs_attrs[] = {
+    &dev_attr_bridge_mode.attr,
+    &dev_attr_bridge_ipv4.attr,
+    NULL,
+};
+
+static struct attribute_group qmi_qmap_sysfs_attr_group = {
+    .attrs = qmi_qmap_sysfs_attrs,
+};
+#endif
+
+static int qmap_open(struct net_device *dev)
+{
+    struct qmap_priv *priv = netdev_priv(dev);
+    struct net_device *real_dev = priv->real_dev;
+
+    if (!(priv->real_dev->flags & IFF_UP))
+        return -ENETDOWN;
+
+    if (netif_carrier_ok(real_dev) && priv->link_state)
+        netif_carrier_on(dev);
+
+    if (netif_carrier_ok(dev)) {
+        if (netif_queue_stopped(dev) && !netif_queue_stopped(real_dev))
+            netif_wake_queue(dev);
+    }
+
+    return 0;
+}
+
+static int qmap_stop(struct net_device *pNet)
+{
+    netif_carrier_off(pNet);
+    return 0;
+}
+
+static struct sk_buff * add_qhdr(struct sk_buff *skb, u8 mux_id) {
+    struct qmap_hdr *qhdr;
+    int pad = 0;
+
+    pad = skb->len%4;
+    if (pad) {
+        pad = 4 - pad;
+        if (skb_tailroom(skb) < pad) {
+            printk("skb_tailroom small!\n");
+            pad = 0;
+        }
+        if (pad)
+            __skb_put(skb, pad);
+    }
+
+    qhdr = (struct qmap_hdr *)skb_push(skb, sizeof(struct qmap_hdr));
+    qhdr->cd_rsvd_pad = pad;
+    qhdr->mux_id = mux_id;
+    qhdr->pkt_len = cpu_to_be16(skb->len - sizeof(struct qmap_hdr));
+
+    return skb;
+}
+
+static struct sk_buff * add_qhdr_v5(struct sk_buff *skb, u8 mux_id) {
+    struct rmnet_map_header *map_header;
+    struct rmnet_map_v5_csum_header *ul_header;
+    u32 padding, map_datalen;
+
+    map_datalen = skb->len;
+    padding = map_datalen%4;
+    if (padding) {
+        padding = 4 - padding;
+        if (skb_tailroom(skb) < padding) {
+            printk("skb_tailroom small!\n");
+            padding = 0;
+        }
+        if (padding)
+            __skb_put(skb, padding);
+    }
+
+    map_header = (struct rmnet_map_header *)skb_push(skb, (sizeof(struct rmnet_map_header) + sizeof(struct rmnet_map_v5_csum_header)));
+    map_header->cd_bit = 0;
+    map_header->next_hdr = 1;
+    map_header->pad_len = padding;
+    map_header->mux_id = mux_id;
+    map_header->pkt_len = htons(map_datalen + padding);
+
+    ul_header = (struct rmnet_map_v5_csum_header *)(map_header + 1);
+    memset(ul_header, 0, sizeof(*ul_header));
+    ul_header->header_type = RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD;
+    if (skb->ip_summed == CHECKSUM_PARTIAL) {
+#if 0 //TODO
+        skb->ip_summed = CHECKSUM_NONE;
+        /* Ask for checksum offloading */
+        ul_header->csum_valid_required = 1;
+#endif
+    }
+
+    return skb;
+}
+
+static void rmnet_vnd_update_rx_stats(struct net_device *net,
+            unsigned rx_packets, unsigned rx_bytes) {
+#if defined(MHI_NETDEV_STATUS64)
+    struct qmap_priv *dev = netdev_priv(net);
+    struct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->stats64);
+
+    u64_stats_update_begin(&stats64->syncp);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+    stats64->rx_packets += rx_packets;
+    stats64->rx_bytes += rx_bytes;
+#else
+	u64_stats_add(&stats64->rx_packets, rx_packets);
+	u64_stats_add(&stats64->rx_bytes, rx_bytes);
+#endif
+    u64_stats_update_end(&stats64->syncp);
+#else
+    net->stats.rx_packets += rx_packets;
+    net->stats.rx_bytes += rx_bytes;
+#endif
+}
+
+static void rmnet_vnd_update_tx_stats(struct net_device *net,
+            unsigned tx_packets, unsigned tx_bytes) {
+#if defined(MHI_NETDEV_STATUS64)
+    struct qmap_priv *dev = netdev_priv(net);
+    struct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->stats64);
+
+    u64_stats_update_begin(&stats64->syncp);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+    stats64->tx_packets += tx_packets;
+    stats64->tx_bytes += tx_bytes;
+#else
+    u64_stats_add(&stats64->tx_packets, tx_packets);
+    u64_stats_add(&stats64->tx_bytes, tx_bytes);
+#endif
+    u64_stats_update_end(&stats64->syncp);
+#else
+    net->stats.tx_packets += tx_packets;
+    net->stats.tx_bytes += tx_bytes;
+#endif
+}
+
+#if defined(MHI_NETDEV_STATUS64)
+static struct rtnl_link_stats64 *_rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats)
+{
+    struct qmap_priv *dev = netdev_priv(net);
+    unsigned int start;
+    int cpu;
+    struct rmnet_nss_cb *nss_cb;
+
+    netdev_stats_to_stats64(stats, &net->stats);
+
+    nss_cb = rcu_dereference(rmnet_nss_callbacks);
+    if (nss_cb) { // rmnet_nss.c:rmnet_nss_tx() will update rx stats
+        stats->rx_packets = 0;
+        stats->rx_bytes = 0;
+    }
+
+    for_each_possible_cpu(cpu) {
+        struct pcpu_sw_netstats *stats64;
+        u64 rx_packets, rx_bytes;
+        u64 tx_packets, tx_bytes;
+
+        stats64 = per_cpu_ptr(dev->stats64, cpu);
+
+        do {
+            start = u64_stats_fetch_begin(&stats64->syncp);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+            rx_packets = stats64->rx_packets;
+            rx_bytes = stats64->rx_bytes;
+            tx_packets = stats64->tx_packets;
+            tx_bytes = stats64->tx_bytes;
+#else
+	    rx_packets = u64_stats_read(&stats64->rx_packets);
+	    rx_bytes = u64_stats_read(&stats64->rx_bytes);
+	    tx_packets = u64_stats_read(&stats64->tx_packets);
+	    tx_bytes = u64_stats_read(&stats64->tx_bytes);
+#endif
+        } while (u64_stats_fetch_retry(&stats64->syncp, start));
+
+        stats->rx_packets += rx_packets;
+        stats->rx_bytes += rx_bytes;
+        stats->tx_packets += tx_packets;
+        stats->tx_bytes += tx_bytes;
+    }
+
+    return stats;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,10,0 )) //bc1f44709cf27fb2a5766cadafe7e2ad5e9cb221
+static void rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+    _rmnet_vnd_get_stats64(net, stats);
+}
+#else
+static struct rtnl_link_stats64 *rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+    return _rmnet_vnd_get_stats64(net, stats);
+}
+#endif
+#endif
+
+#if defined(FIBOCOM_UL_DATA_AGG)
+static void rmnet_usb_tx_wake_queue(unsigned long data) {
+    sQmiWwanQmap *pQmapDev = (void *)data;
+    int i;
+
+    for (i = 0; i < pQmapDev->qmap_mode; i++) {
+        struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+        if (qmap_net) {
+            if (netif_queue_stopped(qmap_net) && !netif_queue_stopped(pQmapDev->mpNetDev->net)) {
+                netif_wake_queue(qmap_net);
+            }
+        }
+    }
+}
+
+static void rmnet_usb_tx_skb_destructor(struct sk_buff *skb) {
+    struct net_device    *net = skb->dev;
+    struct usbnet * dev = netdev_priv( net );
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    if (pQmapDev && pQmapDev->use_rmnet_usb) {
+        int i;
+
+        for (i = 0; i < pQmapDev->qmap_mode; i++) {
+            struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+
+            if (qmap_net) {
+                if (netif_queue_stopped(qmap_net)) {
+                    tasklet_schedule(&pQmapDev->txq);
+                    break;
+                }
+            }
+        }
+    }
+}
+
+static int rmnet_usb_tx_agg_skip(struct sk_buff *skb, int offset)
+{
+    u8 *packet_start = skb->data + offset;
+    int ready2send = 0;
+
+    if (skb->protocol == htons(ETH_P_IP)) {
+        struct iphdr *ip4h = (struct iphdr *)(packet_start);
+
+        if (ip4h->protocol == IPPROTO_TCP) {
+            const struct tcphdr *th = (const struct tcphdr *)(packet_start + sizeof(struct iphdr));
+            if (th->psh) {
+                ready2send = 1;
+            }
+        }
+        else if (ip4h->protocol == IPPROTO_ICMP)
+            ready2send = 1;
+
+    } else if (skb->protocol == htons(ETH_P_IPV6)) {
+        struct ipv6hdr *ip6h = (struct ipv6hdr *)(packet_start);
+
+        if (ip6h->nexthdr == NEXTHDR_TCP) {
+            const struct tcphdr *th = (const struct tcphdr *)(packet_start + sizeof(struct ipv6hdr));
+            if (th->psh) {
+                ready2send = 1;
+            }
+        } else if (ip6h->nexthdr == NEXTHDR_ICMP) {
+            ready2send = 1;
+        } else if (ip6h->nexthdr == NEXTHDR_FRAGMENT) {
+            struct frag_hdr *frag;
+
+            frag = (struct frag_hdr *)(packet_start
+                           + sizeof(struct ipv6hdr));
+            if (frag->nexthdr == IPPROTO_ICMPV6)
+                ready2send = 1;
+        }
+    }
+
+    return ready2send;
+}
+
+static void rmnet_usb_tx_agg_work(struct work_struct *work)
+{
+    struct qmap_priv *priv =
+            container_of(work, struct qmap_priv, agg_wq);
+    struct sk_buff *skb = NULL;
+    unsigned long flags;
+
+    spin_lock_irqsave(&priv->agg_lock, flags);
+    if (likely(priv->agg_skb)) {
+        skb = priv->agg_skb;
+        priv->agg_skb = NULL;
+        priv->agg_count = 0;
+        skb->protocol = htons(ETH_P_MAP);
+        skb->dev = priv->real_dev;
+        ktime_get_ts64(&priv->agg_time);
+    }
+    spin_unlock_irqrestore(&priv->agg_lock, flags);
+
+    if (skb) {
+        int err = dev_queue_xmit(skb);
+        if (err != NET_XMIT_SUCCESS) {
+            priv->self_dev->stats.tx_errors++;
+        }
+    }
+}
+
+static enum hrtimer_restart  rmnet_usb_tx_agg_timer_cb(struct hrtimer *timer)
+{
+    struct qmap_priv *priv =
+            container_of(timer, struct qmap_priv, agg_hrtimer);
+
+    schedule_work(&priv->agg_wq);
+    return HRTIMER_NORESTART;
+}
+
+static long agg_time_limit __read_mostly = 1000000L; //reduce this time, can get better TPUT performance, but will increase USB interrupts
+module_param(agg_time_limit, long, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(agg_time_limit, "Maximum time packets sit in the agg buf");
+
+static long agg_bypass_time __read_mostly = 10000000L;
+module_param(agg_bypass_time, long, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(agg_bypass_time, "Skip agg when apart spaced more than this");
+
+static int rmnet_usb_tx_agg(struct sk_buff *skb, struct qmap_priv *priv) {
+    struct qmi_wwan_state *info = (void *)&priv->dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    struct tx_agg_ctx *ctx = &pQmapDev->tx_ctx;
+    int ready2send = 0;
+    int xmit_more = 0;
+    struct timespec64 diff, now;
+    struct sk_buff *agg_skb = NULL;
+    unsigned long flags;
+    int err;
+    struct net_device *pNet = priv->self_dev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0) //6b16f9ee89b8d5709f24bc3ac89ae8b5452c0d7c
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,16,0)
+    xmit_more = skb->xmit_more;
+#endif
+#else
+    xmit_more = netdev_xmit_more();
+#endif
+
+    rmnet_vnd_update_tx_stats(pNet, 1, skb->len);
+
+    if (ctx->ul_data_aggregation_max_datagrams == 1) {
+        skb->protocol = htons(ETH_P_MAP);
+        skb->dev = priv->real_dev;
+        if (!skb->destructor)
+            skb->destructor = rmnet_usb_tx_skb_destructor;
+        err = dev_queue_xmit(skb);
+        if (err != NET_XMIT_SUCCESS)
+            pNet->stats.tx_errors++;
+        return NET_XMIT_SUCCESS;
+    }
+
+new_packet:
+    spin_lock_irqsave(&priv->agg_lock, flags);
+    agg_skb = NULL;
+    ready2send = 0;
+    ktime_get_ts64(&now);
+    diff = timespec64_sub(now, priv->agg_time);
+
+    if (priv->agg_skb) {
+        if ((priv->agg_skb->len + skb->len) < ctx->ul_data_aggregation_max_size) {
+            memcpy(skb_put(priv->agg_skb, skb->len), skb->data, skb->len);
+            priv->agg_count++;
+
+            if (diff.tv_sec > 0 || diff.tv_nsec > agg_time_limit) {
+                ready2send = 1;
+            }
+            else if (priv->agg_count == ctx->ul_data_aggregation_max_datagrams) {
+                ready2send = 1;
+            }
+            else if (xmit_more == 0) {
+                struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb->data;
+                size_t offset = sizeof(struct rmnet_map_header);
+                if (map_header->next_hdr)
+                    offset += sizeof(struct rmnet_map_v5_csum_header);
+
+                ready2send = rmnet_usb_tx_agg_skip(skb, offset);
+            }
+
+            dev_kfree_skb_any(skb);
+            skb = NULL;
+        }
+        else {
+            ready2send = 1;
+        }
+
+        if (ready2send) {
+            agg_skb = priv->agg_skb;
+            priv->agg_skb = NULL;
+            priv->agg_count = 0;
+        }
+    }
+    else if (skb) {
+        if (diff.tv_sec > 0 || diff.tv_nsec > agg_bypass_time) {
+            ready2send = 1;
+        }
+        else if (xmit_more == 0) {
+            struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb->data;
+            size_t offset = sizeof(struct rmnet_map_header);
+            if (map_header->next_hdr)
+                offset += sizeof(struct rmnet_map_v5_csum_header);
+
+            ready2send = rmnet_usb_tx_agg_skip(skb, offset);
+        }
+
+        if (ready2send == 0) {
+            priv->agg_skb = alloc_skb(ctx->ul_data_aggregation_max_size, GFP_ATOMIC);
+            if (priv->agg_skb) {
+                memcpy(skb_put(priv->agg_skb, skb->len), skb->data, skb->len);
+                priv->agg_count++;
+                dev_kfree_skb_any(skb);
+                skb = NULL;
+            }
+            else {
+                ready2send = 1;
+            }
+        }
+
+        if (ready2send) {
+            agg_skb = skb;
+            skb = NULL;
+        }
+    }
+
+    if (ready2send) {
+        priv->agg_time = now;
+    }
+    spin_unlock_irqrestore(&priv->agg_lock, flags);
+
+    if (agg_skb) {
+        agg_skb->protocol = htons(ETH_P_MAP);
+        agg_skb->dev = priv->real_dev;
+        if (!agg_skb->destructor)
+            agg_skb->destructor = rmnet_usb_tx_skb_destructor;
+        err = dev_queue_xmit(agg_skb);
+        if (err != NET_XMIT_SUCCESS) {
+            pNet->stats.tx_errors++;
+        }
+    }
+
+    if (skb) {
+        goto new_packet;
+    }
+
+    if (priv->agg_skb) {
+        if (!hrtimer_is_queued(&priv->agg_hrtimer))
+            hrtimer_start(&priv->agg_hrtimer, ns_to_ktime(NSEC_PER_MSEC * 2), HRTIMER_MODE_REL);
+    }
+
+    return NET_XMIT_SUCCESS;
+}
+#endif
+
+static netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,
+                    struct net_device *pNet)
+{
+    int err;
+    struct qmap_priv *priv = netdev_priv(pNet);
+
+    if (netif_queue_stopped(priv->real_dev)) {
+        netif_stop_queue(pNet);
+        return NETDEV_TX_BUSY;
+    }
+
+    //printk("%s 1 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+    if (pNet->type == ARPHRD_ETHER) {
+        skb_reset_mac_header(skb);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+        if (priv->bridge_mode && bridge_mode_tx_fixup(pNet, skb, priv->bridge_ipv4, priv->bridge_mac) == NULL) {
+              dev_kfree_skb_any (skb);
+              return NETDEV_TX_OK;
+        }
+#endif
+
+        if (skb_pull(skb, ETH_HLEN) == NULL) {
+            dev_kfree_skb_any (skb);
+            return NETDEV_TX_OK;
+        }
+    }
+    //printk("%s 2 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+    if (priv->qmap_version == 5) {
+        add_qhdr(skb, priv->mux_id);
+    }
+    else if (priv->qmap_version == 9) {
+        add_qhdr_v5(skb, priv->mux_id);
+    }
+    else {
+        dev_kfree_skb_any (skb);
+        return NETDEV_TX_OK;
+    }
+    //printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+#if 0
+    skb->protocol = htons(ETH_P_MAP);
+    skb->dev = priv->real_dev;
+    err = dev_queue_xmit(skb);
+
+    if (err == NET_XMIT_SUCCESS) {
+        rmnet_vnd_update_tx_stats(pNet, 1, skb->len);
+    } else {
+        pNet->stats.tx_errors++;
+    }
+#else
+    err = rmnet_usb_tx_agg(skb, priv);
+#endif
+
+    return err;
+}
+
+static int rmnet_vnd_change_mtu(struct net_device *rmnet_dev, int new_mtu)
+{
+    if (new_mtu < 0 || new_mtu > 1500)
+        return -EINVAL;
+
+    rmnet_dev->mtu = new_mtu;
+    return 0;
+}
+
+/* drivers may override default ethtool_ops in their bind() routine */
+static const struct ethtool_ops rmnet_vnd_ethtool_ops = {
+    .get_link        = ethtool_op_get_link,
+};
+
+static int qmap_start_xmit(struct sk_buff *skb, struct net_device *pNet)
+{
+    int err;
+    struct qmap_priv *priv = netdev_priv(pNet);
+
+    //printk("%s 1 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+    if (pNet->type == ARPHRD_ETHER) {
+        skb_reset_mac_header(skb);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+        if (priv->bridge_mode && bridge_mode_tx_fixup(pNet, skb, priv->bridge_ipv4, priv->bridge_mac) == NULL) {
+            dev_kfree_skb_any (skb);
+            return NETDEV_TX_OK;
+        }
+#endif
+
+        if (skb_pull(skb, ETH_HLEN) == NULL) {
+            dev_kfree_skb_any (skb);
+            return NETDEV_TX_OK;
+        }
+    }
+
+
+    add_qhdr(skb, FIBOCOM_QMAP_MUX_ID + priv->offset_id);
+
+    skb->dev = priv->real_dev;
+    err = dev_queue_xmit(skb);
+    if (err == NET_XMIT_SUCCESS) {
+        pNet->stats.tx_packets++;
+        pNet->stats.tx_bytes += skb->len;
+    } else {
+        pNet->stats.tx_errors++;
+    }
+
+    return err;
+}
+
+static const struct net_device_ops qmap_netdev_ops = {
+    .ndo_open       = qmap_open,
+    .ndo_stop       = qmap_stop,
+    .ndo_start_xmit = qmap_start_xmit,
+};
+
+static const struct net_device_ops rmnet_vnd_ops = {
+    .ndo_open       = qmap_open,
+    .ndo_stop       = qmap_stop,
+    .ndo_start_xmit = rmnet_vnd_start_xmit,
+    .ndo_change_mtu = rmnet_vnd_change_mtu,
+#if defined(MHI_NETDEV_STATUS64)
+    .ndo_get_stats64    = rmnet_vnd_get_stats64,
+#endif
+};
+
+static void rmnet_usb_vnd_setup(struct net_device *rmnet_dev)
+{
+    rmnet_dev->needed_headroom = 16;
+
+    /* Raw IP mode */
+    rmnet_dev->header_ops = NULL;  /* No header */
+    rmnet_dev->type = ARPHRD_RAWIP;
+    rmnet_dev->hard_header_len = 0;
+    rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+}
+
+static rx_handler_result_t rmnet_usb_rx_priv_handler(struct sk_buff **pskb)
+{
+    struct sk_buff *skb = *pskb;
+    struct rmnet_nss_cb *nss_cb;
+
+    if (!skb)
+        return RX_HANDLER_CONSUMED;
+
+    //printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+    if (skb->pkt_type == PACKET_LOOPBACK)
+        return RX_HANDLER_PASS;
+
+    /* Check this so that we dont loop around netif_receive_skb */
+    if (skb->cb[0] == 1) {
+        skb->cb[0] = 0;
+
+        return RX_HANDLER_PASS;
+    }
+
+    nss_cb = rcu_dereference(rmnet_nss_callbacks);
+    if (nss_cb) {
+        nss_cb->nss_tx(skb);
+        return RX_HANDLER_CONSUMED;
+    }
+
+    return RX_HANDLER_PASS;
+}
+
+static int qmap_register_device(sQmiWwanQmap * pDev, u8 offset_id)
+{
+    struct net_device *real_dev = pDev->mpNetDev->net;
+    struct net_device *qmap_net;
+    struct qmap_priv *priv;
+    int err;
+    struct rmnet_nss_cb *nss_cb;
+
+    qmap_net = alloc_etherdev(sizeof(*priv));
+    if (!qmap_net)
+        return -ENOBUFS;
+
+    SET_NETDEV_DEV(qmap_net, &real_dev->dev);
+    priv = netdev_priv(qmap_net);
+    priv->offset_id = offset_id;
+    priv->real_dev = real_dev;
+    priv->self_dev = qmap_net;
+    priv->dev = pDev->mpNetDev;
+    priv->qmap_version = pDev->qmap_version;
+    priv->mux_id = FIBOCOM_QMAP_MUX_ID + offset_id;
+    sprintf(qmap_net->name, "%s.%d", real_dev->name, offset_id + 1);
+    qmap_net->netdev_ops = &qmap_netdev_ops;
+    //memcpy (qmap_net->dev_addr, real_dev->dev_addr, ETH_ALEN);
+    dev_addr_mod(qmap_net, 0, real_dev->dev_addr, ETH_ALEN);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+    priv->bridge_mode = !!(pDev->bridge_mode & BIT(offset_id));
+    qmap_net->sysfs_groups[0] = &qmi_qmap_sysfs_attr_group;
+#endif
+
+    priv->agg_skb = NULL;
+    priv->agg_count = 0;
+    hrtimer_init(&priv->agg_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    priv->agg_hrtimer.function = rmnet_usb_tx_agg_timer_cb;
+    INIT_WORK(&priv->agg_wq, rmnet_usb_tx_agg_work);
+    ktime_get_ts64(&priv->agg_time);
+    spin_lock_init(&priv->agg_lock);
+
+    if (pDev->use_rmnet_usb) {
+        qmap_net->ethtool_ops = &rmnet_vnd_ethtool_ops;
+        qmap_net->netdev_ops = &rmnet_vnd_ops;
+#if defined(MHI_NETDEV_STATUS64)
+        priv->stats64 = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+        if (!priv->stats64) {
+            err = -ENOBUFS;
+            goto out_free_newdev;
+        }
+#endif
+    }
+
+    nss_cb = rcu_dereference(rmnet_nss_callbacks);
+#ifdef FIBOCOM_BRIDGE_MODE
+    if(nss_cb && !priv->bridge_mode) {
+#else
+    if (nss_cb) {
+#endif
+        rmnet_usb_vnd_setup(qmap_net);
+    }
+
+    err = register_netdev(qmap_net);
+    dev_info(&real_dev->dev, "%s(%s)=%d\n", __func__, qmap_net->name, err);
+    if (err < 0)
+        goto out_free_newdev;
+    netif_device_attach (qmap_net);
+    netif_carrier_off(qmap_net);
+
+    nss_cb = rcu_dereference(rmnet_nss_callbacks);
+#ifdef FIBOCOM_BRIDGE_MODE
+    if(nss_cb && !priv->bridge_mode) {
+#else
+    if (nss_cb) {
+#endif
+        int rc = nss_cb->nss_create(qmap_net);
+        if (rc) {
+            /* Log, but don't fail the device creation */
+            netdev_err(qmap_net, "Device will not use NSS path: %d\n", rc);
+        } else {
+            netdev_info(qmap_net, "NSS context created\n");
+            rtnl_lock();
+            netdev_rx_handler_register(qmap_net, rmnet_usb_rx_priv_handler, NULL);
+            rtnl_unlock();
+        }
+    }
+
+    if (pDev->use_rmnet_usb) {
+        strcpy(pDev->rmnet_info.ifname[offset_id], qmap_net->name);
+        pDev->rmnet_info.mux_id[offset_id] = priv->mux_id;
+    }
+
+    pDev->mpQmapNetDev[offset_id] = qmap_net;
+    qmap_net->flags |= IFF_NOARP;
+    qmap_net->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+
+    dev_info(&real_dev->dev, "%s %s\n", __func__, qmap_net->name);
+
+    return 0;
+
+out_free_newdev:
+    free_netdev(qmap_net);
+    return err;
+}
+
+static void qmap_unregister_device(sQmiWwanQmap * pDev, u8 offset_id) {
+    struct net_device *qmap_net = pDev->mpQmapNetDev[offset_id];
+
+    if (qmap_net != NULL && qmap_net != pDev->mpNetDev->net) {
+        struct rmnet_nss_cb *nss_cb;
+        struct qmap_priv *priv = netdev_priv(qmap_net);
+        unsigned long flags;
+
+        pr_info("qmap_unregister_device(%s)\n", qmap_net->name);
+        pDev->mpQmapNetDev[offset_id] = NULL;
+        netif_carrier_off( qmap_net );
+        netif_stop_queue( qmap_net );
+
+        hrtimer_cancel(&priv->agg_hrtimer);
+        cancel_work_sync(&priv->agg_wq);
+        spin_lock_irqsave(&priv->agg_lock, flags);
+        if (priv->agg_skb) {
+            kfree_skb(priv->agg_skb);
+        }
+        spin_unlock_irqrestore(&priv->agg_lock, flags);
+        nss_cb = rcu_dereference(rmnet_nss_callbacks);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+        if(nss_cb && !priv->bridge_mode) {
+#else
+        if (nss_cb) {
+#endif
+            rtnl_lock();
+            netdev_rx_handler_unregister(qmap_net);
+            rtnl_unlock();
+            nss_cb->nss_free(qmap_net);
+        }
+
+#if defined(MHI_NETDEV_STATUS64)
+        free_percpu(priv->stats64);
+#endif
+        unregister_netdev (qmap_net);
+        free_netdev(qmap_net);
+    }
+}
+
+#if 1//def CONFIG_ANDROID
+typedef struct {
+    unsigned int size;
+    unsigned int rx_urb_size;
+    unsigned int ep_type;
+    unsigned int iface_id;
+    unsigned int MuxId;
+    unsigned int ul_data_aggregation_max_datagrams; //0x17
+    unsigned int ul_data_aggregation_max_size ;//0x18
+    unsigned int dl_minimum_padding; //0x1A
+} QMAP_SETTING;
+
+int qma_setting_store(struct device *dev, QMAP_SETTING *qmap_settings, size_t size) {
+    struct net_device *netdev = to_net_dev(dev);
+    struct usbnet * usbnetdev = netdev_priv( netdev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    if (qmap_settings->size != size) {
+        dev_err(dev, "ERROR: qmap_settings.size donot match!\n");
+        return -EOPNOTSUPP;
+    }
+
+#ifdef FIBOCOM_UL_DATA_AGG
+    netif_tx_lock_bh(netdev);
+    if (pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams == 1 && qmap_settings->ul_data_aggregation_max_datagrams > 1) {
+        pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams = qmap_settings->ul_data_aggregation_max_datagrams;
+        pQmapDev->tx_ctx.ul_data_aggregation_max_size = qmap_settings->ul_data_aggregation_max_size;
+        pQmapDev->tx_ctx.dl_minimum_padding = qmap_settings->dl_minimum_padding;
+        dev_info(dev, "ul_data_aggregation_max_datagrams=%d, ul_data_aggregation_max_size=%d, dl_minimum_padding=%d\n",
+            pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams,
+            pQmapDev->tx_ctx.ul_data_aggregation_max_size,
+            pQmapDev->tx_ctx.dl_minimum_padding);
+    }
+    netif_tx_unlock_bh(netdev);
+    return 0;
+#endif
+
+    return -EOPNOTSUPP;
+}
+
+static int qmap_ndo_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) {
+    struct usbnet * usbnetdev = netdev_priv( dev );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    int rc = -EOPNOTSUPP;
+    uint link_state = 0;
+    QMAP_SETTING qmap_settings = {0};
+
+    switch (cmd) {
+    case 0x89F1: //SIOCDEVPRIVATE
+        rc = copy_from_user(&link_state, ifr->ifr_ifru.ifru_data, sizeof(link_state));
+        if (!rc) {
+            char buf[32];
+            snprintf(buf, sizeof(buf), "%u", link_state);
+            link_state_store(&dev->dev, NULL, buf, strlen(buf));
+        }
+    break;
+
+    case 0x89F2: //SIOCDEVPRIVATE
+        rc = copy_from_user(&qmap_settings, ifr->ifr_ifru.ifru_data, sizeof(qmap_settings));
+        if (!rc) {
+            rc = qma_setting_store(&dev->dev, &qmap_settings, sizeof(qmap_settings));
+        }
+    break;
+
+    case 0x89F3: //SIOCDEVPRIVATE
+        if (pQmapDev->use_rmnet_usb) {
+            uint i;
+
+            for (i = 0; i < pQmapDev->qmap_mode; i++) {
+                struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+
+                if (!qmap_net)
+                    break;
+
+                strcpy(pQmapDev->rmnet_info.ifname[i], qmap_net->name);
+            }
+            rc = copy_to_user(ifr->ifr_ifru.ifru_data, &pQmapDev->rmnet_info, sizeof(pQmapDev->rmnet_info));
+        }
+    break;
+
+    default:
+    break;
+    }
+
+    return rc;
+}
+#endif
+
+#ifdef FIBOCOM_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev) {
+    return netdev->netdev_ops == &qmap_netdev_ops || netdev->netdev_ops == &rmnet_vnd_ops;
+}
+#endif
+#endif
+
+static struct sk_buff *qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+    if ((dev->driver_info->flags & FLAG_NOARP) == 0)
+        return skb;
+
+    // Skip Ethernet header from message
+    if (dev->net->hard_header_len == 0)
+        return skb;
+    else
+        skb_reset_mac_header(skb);
+
+#ifdef FIBOCOM_BRIDGE_MODE
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    if (pQmapDev->bridge_mode && bridge_mode_tx_fixup(dev->net, skb, pQmapDev->bridge_ipv4, pQmapDev->bridge_mac) == NULL) {
+          dev_kfree_skb_any (skb);
+          return NULL;
+    }
+}
+#endif
+
+    if (skb_pull(skb, ETH_HLEN)) {
+        return skb;
+    } else {
+        dev_err(&dev->intf->dev,  "Packet Dropped ");
+    }
+
+    // Filter the packet out, release it
+    dev_kfree_skb_any(skb);
+    return NULL;
+}
+#endif
+
+/* Make up an ethernet header if the packet doesn't have one.
+ *
+ * A firmware bug common among several devices cause them to send raw
+ * IP packets under some circumstances.  There is no way for the
+ * driver/host to know when this will happen.  And even when the bug
+ * hits, some packets will still arrive with an intact header.
+ *
+ * The supported devices are only capably of sending IPv4, IPv6 and
+ * ARP packets on a point-to-point link. Any packet with an ethernet
+ * header will have either our address or a broadcast/multicast
+ * address as destination.  ARP packets will always have a header.
+ *
+ * This means that this function will reliably add the appropriate
+ * header if necessary, provided our hardware address does not start
+ * with 4 or 6.
+ *
+ * Another common firmware bug results in all packets being addressed
+ * to 00:a0:c6:00:00:00 despite the host address being different.
+ * This function will also fixup such packets.
+ */
+static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+    __be16 proto;
+
+    /* This check is no longer done by usbnet */
+    if (skb->len < dev->net->hard_header_len)
+        return 0;
+
+    switch (skb->data[0] & 0xf0) {
+    case 0x40:
+        proto = htons(ETH_P_IP);
+        break;
+    case 0x60:
+        proto = htons(ETH_P_IPV6);
+        break;
+    case 0x00:
+        if (is_multicast_ether_addr(skb->data))
+            return 1;
+        /* possibly bogus destination - rewrite just in case */
+        skb_reset_mac_header(skb);
+        goto fix_dest;
+    default:
+        /* pass along other packets without modifications */
+        return 1;
+    }
+    if (skb_headroom(skb) < ETH_HLEN)
+        return 0;
+    skb_push(skb, ETH_HLEN);
+    skb_reset_mac_header(skb);
+    eth_hdr(skb)->h_proto = proto;
+    memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+#if 1 //Added by Fibocom
+    //some kernel will drop ethernet packet which's souce mac is all zero
+    memcpy(eth_hdr(skb)->h_source, default_modem_addr, ETH_ALEN);
+#endif
+
+fix_dest:
+#ifdef FIBOCOM_BRIDGE_MODE
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    bridge_mode_rx_fixup(pQmapDev, dev->net, skb);
+}
+#else
+    memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+#endif
+
+    return 1;
+}
+
+#if defined(FIBOCOM_WWAN_QMAP)
+static struct sk_buff *qmap_qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    struct qmap_hdr *qhdr;
+
+    if (unlikely(pQmapDev == NULL)) {
+        goto drop_skb;
+    } else if (unlikely(pQmapDev->qmap_mode && !pQmapDev->link_state)) {
+        dev_dbg(&dev->net->dev, "link_state 0x%x, drop skb, len = %u\n", pQmapDev->link_state, skb->len);
+        goto drop_skb;
+    } else if (pQmapDev->qmap_mode == 0) {
+        skb = qmi_wwan_tx_fixup(dev, skb, flags);
+    }
+    else if (pQmapDev->qmap_mode > 1) {
+        if (likely(skb)) {
+            qhdr = (struct qmap_hdr *)skb->data;
+            if ((qhdr->mux_id&0xF0) != 0x80 || ((be16_to_cpu(qhdr->pkt_len) + sizeof(struct qmap_hdr)) != skb->len)) {
+                goto drop_skb;
+            }
+        }
+    }
+    else {
+        if (likely(skb)) {
+            skb = qmi_wwan_tx_fixup(dev, skb, flags);
+
+            if (skb) {
+                add_qhdr(skb, FIBOCOM_QMAP_MUX_ID);
+            }
+            else {
+                return NULL;
+            }
+        }
+    }
+
+    if (skb && (dev->driver_info->flags&FLAG_MULTI_PACKET)) {
+        usbnet_set_skb_tx_stats(skb, 1, 0);
+     }
+
+
+    return skb;
+drop_skb:
+    dev_kfree_skb_any (skb);
+    return NULL;
+}
+
+static int qmap_qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    unsigned headroom = 0;
+    const unsigned need_headroot = ETH_HLEN;
+    struct sk_buff *qmap_skb;
+
+    if (pQmapDev->qmap_mode == 0)
+        return qmi_wwan_rx_fixup(dev, skb_in);
+
+    headroom = skb_headroom(skb_in);
+
+    while (skb_in->len > sizeof(struct qmap_hdr)) {
+        struct qmap_hdr *qhdr = (struct qmap_hdr *)skb_in->data;
+        struct net_device *qmap_net;
+        int pkt_len = be16_to_cpu(qhdr->pkt_len);
+        int skb_len;
+        __be16 protocol;
+        int mux_id;
+
+        skb_len = pkt_len - (qhdr->cd_rsvd_pad&0x3F);
+        if (skb_len > 1500) {
+            dev_info(&dev->net->dev, "drop skb_len=%x larger than 1500\n", skb_len);
+            goto error_pkt;
+        }
+
+        if (skb_in->len < (pkt_len + sizeof(struct qmap_hdr))) {
+            dev_info(&dev->net->dev, "drop qmap unknow pkt, len=%d, pkt_len=%d\n", skb_in->len, pkt_len);
+            goto error_pkt;
+        }
+
+        if (qhdr->cd_rsvd_pad & 0x80) {
+            dev_info(&dev->net->dev, "skip qmap command packet %x\n", qhdr->cd_rsvd_pad);
+            goto skip_pkt;
+        }
+
+        switch (skb_in->data[sizeof(struct qmap_hdr)] & 0xf0) {
+            case 0x40:
+                protocol = htons(ETH_P_IP);
+            break;
+            case 0x60:
+                protocol = htons(ETH_P_IPV6);
+            break;
+            default:
+                dev_info(&dev->net->dev, "unknow skb->protocol %02x\n", skb_in->data[sizeof(struct qmap_hdr)]);
+                goto error_pkt;
+        }
+
+        mux_id = qhdr->mux_id - FIBOCOM_QMAP_MUX_ID;
+        if (mux_id >= pQmapDev->qmap_mode) {
+            dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", qhdr->mux_id);
+            goto error_pkt;
+        }
+
+        qmap_net = pQmapDev->mpQmapNetDev[mux_id];
+
+        if (qmap_net == NULL) {
+            dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", qhdr->mux_id);
+            goto skip_pkt;
+        }
+
+        if (headroom >= need_headroot) {
+            qmap_skb = skb_clone(skb_in, GFP_ATOMIC);
+            if (qmap_skb) {
+                qmap_skb->dev = qmap_net;
+                skb_pull(qmap_skb, sizeof(struct qmap_hdr));
+                skb_trim(qmap_skb, skb_len);
+            }
+            headroom = (qhdr->cd_rsvd_pad&0x3F);
+        }
+        else {
+            qmap_skb = netdev_alloc_skb(qmap_net, need_headroot + skb_len);
+            if (qmap_skb) {
+                skb_reserve(qmap_skb, need_headroot);
+                skb_put(qmap_skb, skb_len);
+                memcpy(qmap_skb->data, skb_in->data + sizeof(struct qmap_hdr), skb_len);
+            }
+            headroom = pkt_len;
+        }
+
+        if (qmap_skb == NULL) {
+            dev_info(&dev->net->dev, "fail to alloc skb, pkt_len = %d\n", skb_len);
+            return 0;
+        }
+
+        skb_push(qmap_skb, ETH_HLEN);
+        skb_reset_mac_header(qmap_skb);
+        memcpy(eth_hdr(qmap_skb)->h_source, default_modem_addr, ETH_ALEN);
+        memcpy(eth_hdr(qmap_skb)->h_dest, qmap_net->dev_addr, ETH_ALEN);
+        eth_hdr(qmap_skb)->h_proto =  protocol;
+#ifdef FIBOCOM_BRIDGE_MODE
+        bridge_mode_rx_fixup(pQmapDev, qmap_net, qmap_skb);
+#endif
+
+        if (qmap_net != dev->net) {
+            qmap_net->stats.rx_packets++;
+            qmap_net->stats.rx_bytes += qmap_skb->len;
+        }
+
+        skb_queue_tail(&pQmapDev->skb_chain, qmap_skb);
+
+skip_pkt:
+        skb_pull(skb_in, pkt_len + sizeof(struct qmap_hdr));
+    }
+
+    while ((qmap_skb = skb_dequeue (&pQmapDev->skb_chain))) {
+        if (qmap_skb->dev != dev->net) {
+            qmap_skb->protocol = eth_type_trans (qmap_skb, qmap_skb->dev);
+            netif_rx(qmap_skb);
+        }
+        else {
+            qmap_skb->protocol = 0;
+            usbnet_skb_return(dev, qmap_skb);
+        }
+    }
+
+error_pkt:
+    return 0;
+}
+#endif
+
+/* very simplistic detection of IPv4 or IPv6 headers */
+static bool possibly_iphdr(const char *data)
+{
+    return (data[0] & 0xd0) == 0x40;
+}
+
+/* disallow addresses which may be confused with IP headers */
+static int qmi_wwan_mac_addr(struct net_device *dev, void *p)
+{
+    int ret;
+    struct sockaddr *addr = p;
+
+    ret = eth_prepare_mac_addr_change(dev, p);
+    if (ret < 0)
+        return ret;
+    if (possibly_iphdr(addr->sa_data))
+        return -EADDRNOTAVAIL;
+    eth_commit_mac_addr_change(dev, p);
+    return 0;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,10,0 )) //bc1f44709cf27fb2a5766cadafe7e2ad5e9cb221
+static void (*_usbnet_get_stats64)(struct net_device *net, struct rtnl_link_stats64 *stats);
+
+static void qmi_wwan_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+    if (_usbnet_get_stats64) ////c8b5d129ee293bcf972e7279ac996bb8a138505c
+        return _usbnet_get_stats64(net, stats);
+
+    netdev_stats_to_stats64(stats, &net->stats);
+}
+#else
+static struct rtnl_link_stats64 * (*_usbnet_get_stats64)(struct net_device *net, struct rtnl_link_stats64 *stats);
+
+static struct rtnl_link_stats64 * qmi_wwan_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+    if (_usbnet_get_stats64)
+        return _usbnet_get_stats64(net, stats);
+
+    netdev_stats_to_stats64(stats, &net->stats);
+    return stats;
+}
+#endif
+
+static netdev_tx_t qmi_wwan_start_xmit (struct sk_buff *skb,
+                     struct net_device *net)
+{
+    struct usbnet * usbnetdev = netdev_priv( net );
+    struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    int retval;
+
+    retval = usbnet_start_xmit(skb, net);
+
+    if (netif_queue_stopped(net) && pQmapDev && pQmapDev->use_rmnet_usb) {
+        int i;
+
+        for (i = 0; i < pQmapDev->qmap_mode; i++) {
+            struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+            if (qmap_net) {
+                netif_stop_queue(qmap_net);
+            }
+        }
+    }
+
+    return retval;
+}
+
+static const struct net_device_ops qmi_wwan_netdev_ops = {
+    .ndo_open        = usbnet_open,
+    .ndo_stop        = usbnet_stop,
+    .ndo_start_xmit        = qmi_wwan_start_xmit,
+    .ndo_tx_timeout        = usbnet_tx_timeout,
+    .ndo_change_mtu        = usbnet_change_mtu,
+    .ndo_get_stats64    = qmi_wwan_get_stats64,
+    .ndo_set_mac_address    = qmi_wwan_mac_addr,
+    .ndo_validate_addr    = eth_validate_addr,
+#if defined(FIBOCOM_WWAN_QMAP)// && defined(CONFIG_ANDROID)
+    .ndo_do_ioctl = qmap_ndo_do_ioctl,
+#endif
+};
+
+static void ql_net_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+    /* Inherit standard device info */
+    usbnet_get_drvinfo(net, info);
+    strlcpy(info->driver, driver_name, sizeof(info->driver));
+    strlcpy(info->version, VERSION_NUMBER, sizeof(info->version));
+}
+
+static struct ethtool_ops ql_net_ethtool_ops;
+
+/* using a counter to merge subdriver requests with our own into a
+ * combined state
+ */
+static int qmi_wwan_manage_power(struct usbnet *dev, int on)
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    int rv;
+
+    dev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__,
+        atomic_read(&info->pmcount), on);
+
+    if ((on && atomic_add_return(1, &info->pmcount) == 1) ||
+        (!on && atomic_dec_and_test(&info->pmcount))) {
+        /* need autopm_get/put here to ensure the usbcore sees
+         * the new value
+         */
+        rv = usb_autopm_get_interface(dev->intf);
+        dev->intf->needs_remote_wakeup = on;
+        if (!rv)
+            usb_autopm_put_interface(dev->intf);
+    }
+    return 0;
+}
+
+static int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+
+    /* can be called while disconnecting */
+    if (!dev)
+        return 0;
+    return qmi_wwan_manage_power(dev, on);
+}
+
+/* collect all three endpoints and register subdriver */
+static int qmi_wwan_register_subdriver(struct usbnet *dev)
+{
+    int rv;
+    struct usb_driver *subdriver = NULL;
+    struct qmi_wwan_state *info = (void *)&dev->data;
+
+    /* collect bulk endpoints */
+    rv = usbnet_get_endpoints(dev, info->data);
+    if (rv < 0)
+        goto err;
+
+    /* update status endpoint if separate control interface */
+    if (info->control != info->data)
+        dev->status = &info->control->cur_altsetting->endpoint[0];
+
+    /* require interrupt endpoint for subdriver */
+    if (!dev->status) {
+        rv = -EINVAL;
+        goto err;
+    }
+
+    /* for subdriver power management */
+    atomic_set(&info->pmcount, 0);
+
+    /* register subdriver */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 5,12,0 )) //cac6fb015f719104e60b1c68c15ca5b734f57b9c
+	subdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,
+					 4096, WWAN_PORT_QMI, &qmi_wwan_cdc_wdm_manage_power);
+#else
+	subdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,
+					 4096, &qmi_wwan_cdc_wdm_manage_power);
+
+#endif
+    if (IS_ERR(subdriver)) {
+        dev_err(&info->control->dev, "subdriver registration failed\n");
+        rv = PTR_ERR(subdriver);
+        goto err;
+    }
+
+    /* prevent usbnet from using status endpoint */
+    dev->status = NULL;
+
+    /* save subdriver struct for suspend/resume wrappers */
+    info->subdriver = subdriver;
+
+err:
+    return rv;
+}
+
+static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+    int status = -1;
+    struct usb_driver *driver = driver_of(intf);
+    struct qmi_wwan_state *info = (void *)&dev->data;
+
+    BUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <
+              sizeof(struct qmi_wwan_state)));
+
+    /* set up initial state */
+    info->control = intf;
+    info->data = intf;
+
+    status = qmi_wwan_register_subdriver(dev);
+    if (status < 0 && info->control != info->data) {
+        usb_set_intfdata(info->data, NULL);
+        usb_driver_release_interface(driver, info->data);
+    }
+
+    /* Never use the same address on both ends of the link, even
+     * if the buggy firmware told us to.
+     */
+    if (ether_addr_equal(dev->net->dev_addr, default_modem_addr))
+        eth_hw_addr_random(dev->net);
+
+    /* make MAC addr easily distinguishable from an IP header */
+    if (possibly_iphdr(dev->net->dev_addr)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+        dev->net->dev_addr[0] |= 0x02;    /* set local assignment bit */
+        dev->net->dev_addr[0] &= 0xbf;    /* clear "IP" bit */
+#else
+	u8 addr = dev->net->dev_addr[0];
+
+	addr |= 0x02;	/* set local assignment bit */
+	addr &= 0xbf;	/* clear "IP" bit */
+	dev_addr_mod(dev->net, 0, &addr, 1);
+#endif
+    }
+    if (!_usbnet_get_stats64)
+        _usbnet_get_stats64 = dev->net->netdev_ops->ndo_get_stats64;
+    dev->net->netdev_ops = &qmi_wwan_netdev_ops;
+
+    ql_net_ethtool_ops = *dev->net->ethtool_ops;
+    ql_net_ethtool_ops.get_drvinfo = ql_net_get_drvinfo;
+    dev->net->ethtool_ops = &ql_net_ethtool_ops;
+
+#if 1 //Added by Fibocom
+    if (dev->driver_info->flags & FLAG_NOARP) {
+        int ret;
+        char buf[32] = "Module";
+
+        ret = usb_string(dev->udev, dev->udev->descriptor.iProduct, buf, sizeof(buf));
+        if (ret > 0) {
+            buf[ret] = '\0';
+        }
+
+		dev_err(&intf->dev, "Fibocom %s work on RawIP mode\n", buf);
+		dev->net->flags |= IFF_NOARP;
+		dev->net->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+
+        usb_control_msg(
+            interface_to_usbdev(intf),
+            usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+            0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+            0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+            1, //active CDC DTR
+            intf->cur_altsetting->desc.bInterfaceNumber,
+            NULL, 0, 100);
+    }
+
+    dev->rx_urb_size = ETH_DATA_LEN + ETH_HLEN + 6;
+
+#if defined(FIBOCOM_WWAN_QMAP)
+    if (qmap_mode > FIBOCOM_WWAN_QMAP)
+        qmap_mode = FIBOCOM_WWAN_QMAP;
+
+    if (!status)
+    {
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)kzalloc(sizeof(sQmiWwanQmap), GFP_KERNEL);
+
+        if (pQmapDev == NULL)
+            return -ENODEV;
+
+#ifdef FIBOCOM_BRIDGE_MODE
+        pQmapDev->bridge_mode = bridge_mode;
+#endif
+        pQmapDev->mpNetDev = dev;
+        pQmapDev->link_state = 1;
+
+        dev->net->features |= (NETIF_F_VLAN_CHALLENGED);
+
+        skb_queue_head_init(&pQmapDev->skb_chain);
+
+        if (dev->driver_info->flags & FLAG_NOARP)
+        {
+            int idProduct = le16_to_cpu(dev->udev->descriptor.idProduct);
+            int lte_a = (idProduct == 0x0104 || idProduct == 0x0109 || idProduct == 0x0113 || idProduct == 0x1000 || idProduct == 0x1001);
+
+            pQmapDev->qmap_mode = qmap_mode;
+            if (lte_a || dev->udev->speed >= USB_SPEED_SUPER) {
+                if (pQmapDev->qmap_mode == 0) {
+                    pQmapDev->qmap_mode = 1;
+                    if(qmap_mode == 0)
+                        qmap_mode = 1;
+                }
+            }
+
+            if (pQmapDev->qmap_mode) {
+                pQmapDev->qmap_version = 5;
+                pQmapDev->qmap_size = (dev->udev->speed >= USB_SPEED_SUPER) ? 16*1024 : 4*1024;
+/*
+                switch (idProduct) {
+                    case 0x0104:
+                        pQmapDev->qmap_version = 9;
+                        pQmapDev->qmap_size = 31*1024;
+                    break;
+                    default:
+                    break;
+                }
+*/
+                dev->rx_urb_size = pQmapDev->qmap_size;
+                //for these modules, if send pakcet before qmi_start_network, or cause host PC crash, or cause modules crash
+                if (lte_a || dev->udev->speed >= USB_SPEED_SUPER)
+                    pQmapDev->link_state = 0;
+            }
+
+#if defined(FIBOCOM_UL_DATA_AGG)
+            if (pQmapDev->qmap_mode) {
+                struct tx_agg_ctx *ctx = &pQmapDev->tx_ctx;
+                ctx->ul_data_aggregation_max_datagrams = 1;
+                ctx->ul_data_aggregation_max_size = 1500;
+            }
+#endif
+
+            if (pQmapDev->qmap_mode == 0) {
+                pQmapDev->driver_info = *dev->driver_info;
+                pQmapDev->driver_info.flags &= ~(FLAG_MULTI_PACKET); //see usbnet.c rx_process()
+                dev->driver_info = &pQmapDev->driver_info;
+            }
+        }
+
+        info->unused = (unsigned long)pQmapDev;
+        dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
+
+        dev_info(&intf->dev, "rx_urb_size = %zd\n", dev->rx_urb_size);
+    }
+#endif
+#endif
+
+    return status;
+}
+
+static void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    struct usb_driver *driver = driver_of(intf);
+    struct usb_interface *other;
+
+    if (dev->udev && dev->udev->state == USB_STATE_CONFIGURED) {
+        usb_control_msg(
+            interface_to_usbdev(intf),
+            usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+            0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+            0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+            0, //deactive CDC DTR
+            intf->cur_altsetting->desc.bInterfaceNumber,
+            NULL, 0, 100);
+    }
+
+    if (info->subdriver && info->subdriver->disconnect)
+        info->subdriver->disconnect(info->control);
+
+    /* allow user to unbind using either control or data */
+    if (intf == info->control)
+        other = info->data;
+    else
+        other = info->control;
+
+    /* only if not shared */
+    if (other && intf != other) {
+        usb_set_intfdata(other, NULL);
+        usb_driver_release_interface(driver, other);
+    }
+
+    info->subdriver = NULL;
+    info->data = NULL;
+    info->control = NULL;
+}
+
+/* suspend/resume wrappers calling both usbnet and the cdc-wdm
+ * subdriver if present.
+ *
+ * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide
+ * wrappers for those without adding usbnet reset support first.
+ */
+static int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    int ret;
+
+    /* Both usbnet_suspend() and subdriver->suspend() MUST return 0
+     * in system sleep context, otherwise, the resume callback has
+     * to recover device from previous suspend failure.
+     */
+    ret = usbnet_suspend(intf, message);
+    if (ret < 0)
+        goto err;
+
+    if (intf == info->control && info->subdriver &&
+        info->subdriver->suspend)
+        ret = info->subdriver->suspend(intf, message);
+    if (ret < 0)
+        usbnet_resume(intf);
+err:
+    return ret;
+}
+
+static int qmi_wwan_resume(struct usb_interface *intf)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    int ret = 0;
+    bool callsub = (intf == info->control && info->subdriver &&
+            info->subdriver->resume);
+
+    if (callsub)
+        ret = info->subdriver->resume(intf);
+    if (ret < 0)
+        goto err;
+    ret = usbnet_resume(intf);
+    if (ret < 0 && callsub)
+        info->subdriver->suspend(intf, PMSG_SUSPEND);
+err:
+    return ret;
+}
+
+static int qmi_wwan_reset_resume(struct usb_interface *intf)
+{
+    dev_info(&intf->dev, "device do not support reset_resume\n");
+    intf->needs_binding = 1;
+    return -EOPNOTSUPP;
+}
+
+static int rmnet_usb_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+    int status = qmi_wwan_bind(dev, intf);
+    dev_err(&intf->dev, "rmnet_usb_bind\n");
+
+    if (!status) {
+        struct qmi_wwan_state *info = (void *)&dev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+        if (pQmapDev && pQmapDev->qmap_mode) {
+            struct net_device *rmmet_usb = dev->net;
+
+            pQmapDev->use_rmnet_usb = 1;
+            pQmapDev->rmnet_info.size = sizeof(RMNET_INFO);
+            pQmapDev->rmnet_info.rx_urb_size = pQmapDev->qmap_size;
+            pQmapDev->rmnet_info.ep_type = 2; //DATA_EP_TYPE_HSUSB
+            pQmapDev->rmnet_info.iface_id = 4;
+            pQmapDev->rmnet_info.qmap_mode = pQmapDev->qmap_mode;
+            pQmapDev->rmnet_info.qmap_version = pQmapDev->qmap_version;
+            pQmapDev->rmnet_info.dl_minimum_padding = 0;
+
+            strcpy(rmmet_usb->name, "rmnet_usb%d");
+
+#if 0
+            rmmet_usb->header_ops = NULL; /* No header */
+            rmmet_usb->type = ARPHRD_RAWIP;
+            rmmet_usb->hard_header_len = 0;
+            rmmet_usb->addr_len = 0;
+#endif
+            rmmet_usb->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+            rmmet_usb->flags |= (IFF_NOARP);
+        }
+    }
+
+    return status;
+}
+
+static struct sk_buff *rmnet_usb_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+    //printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+    if (skb->protocol != htons(ETH_P_MAP)) {
+        dev_kfree_skb_any(skb);
+        return NULL;
+    }
+
+    return skb;
+}
+
+static int rmnet_usb_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+    struct net_device    *net = dev->net;
+
+    //printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+    if (net->type == ARPHRD_ETHER && skb_headroom(skb) >= ETH_HLEN) {
+        //usbnet.c rx_process() usbnet_skb_return() eth_type_trans()
+        skb_push(skb, ETH_HLEN);
+        skb_reset_mac_header(skb);
+        memcpy(eth_hdr(skb)->h_source, default_modem_addr, ETH_ALEN);
+        memcpy(eth_hdr(skb)->h_dest, net->dev_addr, ETH_ALEN);
+        eth_hdr(skb)->h_proto = htons(ETH_P_MAP);
+
+        return 1;
+    }
+
+    return 0;
+}
+
+static void _rmnet_usb_rx_handler(struct usbnet *dev, struct sk_buff *skb_in)
+{
+    struct qmi_wwan_state *info = (void *)&dev->data;
+    sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+    struct sk_buff *qmap_skb;
+    struct sk_buff_head skb_chain;
+    uint dl_minimum_padding = 0;
+
+    if (pQmapDev->qmap_version == 9)
+        dl_minimum_padding = pQmapDev->tx_ctx.dl_minimum_padding;
+
+    __skb_queue_head_init(&skb_chain);
+
+    while (skb_in->len > sizeof(struct qmap_hdr)) {
+        struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb_in->data;
+        struct rmnet_map_v5_csum_header *ul_header = NULL;
+        size_t hdr_size = sizeof(struct rmnet_map_header);
+        struct net_device *qmap_net;
+        int pkt_len = ntohs(map_header->pkt_len);
+        int skb_len;
+        __be16 protocol;
+        int mux_id;
+
+        if (map_header->next_hdr) {
+            ul_header = (struct rmnet_map_v5_csum_header *)(map_header + 1);
+            hdr_size += sizeof(struct rmnet_map_v5_csum_header);
+        }
+
+        skb_len = pkt_len - (map_header->pad_len&0x3F);
+        skb_len -= dl_minimum_padding;
+        if (skb_len > 1500) {
+            dev_info(&dev->net->dev, "drop skb_len=%x larger than 1500\n", skb_len);
+            goto error_pkt;
+        }
+
+        if (skb_in->len < (pkt_len + hdr_size)) {
+            dev_info(&dev->net->dev, "drop qmap unknow pkt, len=%d, pkt_len=%d\n", skb_in->len, pkt_len);
+            goto error_pkt;
+        }
+
+        if (map_header->cd_bit) {
+            dev_info(&dev->net->dev, "skip qmap command packet\n");
+            goto skip_pkt;
+        }
+
+        switch (skb_in->data[hdr_size] & 0xf0) {
+            case 0x40:
+                protocol = htons(ETH_P_IP);
+            break;
+            case 0x60:
+                protocol = htons(ETH_P_IPV6);
+            break;
+            default:
+                dev_info(&dev->net->dev, "unknow skb->protocol %02x\n", skb_in->data[hdr_size]);
+                goto error_pkt;
+        }
+
+        mux_id = map_header->mux_id - FIBOCOM_QMAP_MUX_ID;
+        if (mux_id >= pQmapDev->qmap_mode) {
+            dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", map_header->mux_id);
+            goto error_pkt;
+        }
+
+        qmap_net = pQmapDev->mpQmapNetDev[mux_id];
+
+        if (qmap_net == NULL) {
+            dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", map_header->mux_id);
+            goto skip_pkt;
+        }
+
+        qmap_skb = netdev_alloc_skb(qmap_net, skb_len);
+        if (qmap_skb) {
+            skb_put(qmap_skb, skb_len);
+            memcpy(qmap_skb->data, skb_in->data + hdr_size, skb_len);
+        }
+
+        if (qmap_skb == NULL) {
+            dev_info(&dev->net->dev, "fail to alloc skb, pkt_len = %d\n", skb_len);
+            goto error_pkt;
+        }
+
+        skb_reset_transport_header(qmap_skb);
+        skb_reset_network_header(qmap_skb);
+        qmap_skb->pkt_type = PACKET_HOST;
+        skb_set_mac_header(qmap_skb, 0);
+        qmap_skb->protocol = protocol;
+
+        if (ul_header && ul_header->header_type == RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD
+            && ul_header->csum_valid_required) {
+#if 0 //TODO
+            qmap_skb->ip_summed = CHECKSUM_UNNECESSARY;
+#endif
+        }
+
+        if (qmap_skb->dev->type == ARPHRD_ETHER) {
+            skb_push(qmap_skb, ETH_HLEN);
+            skb_reset_mac_header(qmap_skb);
+            memcpy(eth_hdr(qmap_skb)->h_source, default_modem_addr, ETH_ALEN);
+            memcpy(eth_hdr(qmap_skb)->h_dest, qmap_net->dev_addr, ETH_ALEN);
+            eth_hdr(qmap_skb)->h_proto = protocol;
+#ifdef FIBOCOM_BRIDGE_MODE
+            bridge_mode_rx_fixup(pQmapDev, qmap_net, qmap_skb);
+#endif
+            __skb_pull(qmap_skb, ETH_HLEN);
+        }
+
+        rmnet_vnd_update_rx_stats(qmap_net, 1, skb_len);
+        __skb_queue_tail(&skb_chain, qmap_skb);
+
+skip_pkt:
+        skb_pull(skb_in, pkt_len + hdr_size);
+    }
+
+error_pkt:
+    while ((qmap_skb = __skb_dequeue (&skb_chain))) {
+        netif_receive_skb(qmap_skb);
+    }
+}
+
+static rx_handler_result_t rmnet_usb_rx_handler(struct sk_buff **pskb)
+{
+    struct sk_buff *skb = *pskb;
+    struct usbnet *dev;
+
+    if (!skb)
+        goto done;
+
+    //printk("%s skb=%p, protocol=%x, len=%d\n", __func__, skb, skb->protocol, skb->len);
+
+    if (skb->pkt_type == PACKET_LOOPBACK)
+        return RX_HANDLER_PASS;
+
+    if (skb->protocol != htons(ETH_P_MAP)) {
+        WARN_ON(1);
+        return RX_HANDLER_PASS;
+    }
+    /* when open hyfi function, run cm will make system crash */
+    //dev = rcu_dereference(skb->dev->rx_handler_data);
+    dev = netdev_priv(skb->dev);
+
+    if (dev == NULL) {
+        WARN_ON(1);
+        return RX_HANDLER_PASS;
+    }
+
+    _rmnet_usb_rx_handler(dev, skb);
+    consume_skb(skb);
+
+done:
+    return RX_HANDLER_CONSUMED;
+}
+
+static const struct driver_info    qmi_wwan_info = {
+    .description    = "WWAN/QMI device",
+    .flags        = FLAG_WWAN,
+    .bind        = qmi_wwan_bind,
+    .unbind        = qmi_wwan_unbind,
+    .manage_power    = qmi_wwan_manage_power,
+    .rx_fixup       = qmi_wwan_rx_fixup,
+};
+
+static const struct driver_info qmi_wwan_raw_ip_info = {
+    .description    = "WWAN/QMI device",
+    .flags        = FLAG_WWAN | FLAG_RX_ASSEMBLE | FLAG_NOARP | FLAG_SEND_ZLP | FLAG_MULTI_PACKET,
+    .bind        = qmi_wwan_bind,
+    .unbind        = qmi_wwan_unbind,
+    .manage_power    = qmi_wwan_manage_power,
+#if defined(FIBOCOM_WWAN_QMAP)
+    .tx_fixup       = qmap_qmi_wwan_tx_fixup,
+    .rx_fixup       = qmap_qmi_wwan_rx_fixup,
+#else
+    .tx_fixup       = qmi_wwan_tx_fixup,
+    .rx_fixup       = qmi_wwan_rx_fixup,
+#endif
+};
+
+static const struct driver_info rmnet_usb_info = {
+    .description = "RMNET/USB device",
+    .flags        =  FLAG_NOARP | FLAG_SEND_ZLP,
+    .bind = rmnet_usb_bind,
+    .unbind = qmi_wwan_unbind,
+    .manage_power = qmi_wwan_manage_power,
+    .tx_fixup = rmnet_usb_tx_fixup,
+    .rx_fixup = rmnet_usb_rx_fixup,
+};
+
+/* map QMI/wwan function by a fixed interface number */
+#define QMI_FIXED_INTF(vend, prod, num) \
+    USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+    .driver_info = (unsigned long)&qmi_wwan_info
+
+#define QMI_FIXED_RAWIP_INTF(vend, prod, num) \
+    USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+    .driver_info = (unsigned long)&qmi_wwan_raw_ip_info
+
+#define RMNET_USB_INTF(vend, prod, num) \
+        USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+        .driver_info = (unsigned long) &rmnet_usb_info
+
+static const struct usb_device_id products[] = {
+#if 1 //Added by Fibocom
+    { QMI_FIXED_RAWIP_INTF(0x2cb7, 0x0104, 4) },  /* Fibocom FG150/FM150/NL952/FG101 */
+    { QMI_FIXED_RAWIP_INTF(0x2cb7, 0x0109, 2) },  /* Fibocom FG150/FM150 */
+    { QMI_FIXED_RAWIP_INTF(0x2cb7, 0x0113, 0) },  /* Fibocom FG101 */
+    { QMI_FIXED_RAWIP_INTF(0x1508, 0x1000, 2) },  /* Fibocom NL668 */
+    { QMI_FIXED_RAWIP_INTF(0x1508, 0x1001, 4) },  /* Fibocom NL668 */
+    { QMI_FIXED_RAWIP_INTF(0x05c6, 0x9025, 4) },  /* Fibocom NL668 */
+#endif
+    { }                    /* END */
+};
+MODULE_DEVICE_TABLE(usb, products);
+
+static int qmi_wwan_probe(struct usb_interface *intf,
+              const struct usb_device_id *prod)
+{
+    struct usb_device_id *id = (struct usb_device_id *)prod;
+
+    /* Workaround to enable dynamic IDs.  This disables usbnet
+     * blacklisting functionality.  Which, if required, can be
+     * reimplemented here by using a magic "blacklist" value
+     * instead of 0 in the static device id table
+     */
+    if (!id->driver_info) {
+        dev_dbg(&intf->dev, "setting defaults for dynamic device id\n");
+        id->driver_info = (unsigned long)&qmi_wwan_info;
+    }
+
+    if (intf->cur_altsetting->desc.bInterfaceClass != 0xff) {
+        dev_info(&intf->dev,  "Fibocom module not qmi_wwan mode!\n");
+        return -ENODEV;
+    }
+
+    return usbnet_probe(intf, id);
+}
+
+#if defined(FIBOCOM_WWAN_QMAP)
+static int qmap_qmi_wwan_probe(struct usb_interface *intf,
+              const struct usb_device_id *prod)
+{
+    int status = qmi_wwan_probe(intf, prod);
+
+    if (!status) {
+        struct usbnet *dev = usb_get_intfdata(intf);
+        struct qmi_wwan_state *info = (void *)&dev->data;
+        sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+        unsigned i;
+
+        if (!pQmapDev)
+            return status;
+
+        tasklet_init(&pQmapDev->txq, rmnet_usb_tx_wake_queue, (unsigned long)pQmapDev);
+
+        if (pQmapDev->qmap_mode == 1) {
+            pQmapDev->mpQmapNetDev[0] = dev->net;
+            if (pQmapDev->use_rmnet_usb) {
+                pQmapDev->mpQmapNetDev[0] = NULL;
+                qmap_register_device(pQmapDev, 0);
+            }
+        }
+        else if (pQmapDev->qmap_mode > 1) {
+            for (i = 0; i < pQmapDev->qmap_mode; i++) {
+                qmap_register_device(pQmapDev, i);
+            }
+        }
+
+        if (pQmapDev->use_rmnet_usb) {
+            rtnl_lock();
+            /* when open hyfi function, run cm will make system crash */
+            //netdev_rx_handler_register(dev->net, rmnet_usb_rx_handler, dev);
+            netdev_rx_handler_register(dev->net, rmnet_usb_rx_handler, NULL);
+            rtnl_unlock();
+        }
+
+        if (pQmapDev->link_state == 0) {
+            netif_carrier_off(dev->net);
+        }
+    }
+
+    return status;
+}
+
+static void qmap_qmi_wwan_disconnect(struct usb_interface *intf)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    struct qmi_wwan_state *info;
+    sQmiWwanQmap *pQmapDev;
+    uint i;
+
+    if (!dev)
+        return;
+
+    info = (void *)&dev->data;
+    pQmapDev = (sQmiWwanQmap *)info->unused;
+
+    if (!pQmapDev) {
+        return usbnet_disconnect(intf);
+    }
+
+    pQmapDev->link_state = 0;
+
+    if (pQmapDev->qmap_mode > 1) {
+        for (i = 0; i < pQmapDev->qmap_mode; i++) {
+            qmap_unregister_device(pQmapDev, i);
+        }
+    }
+
+    if (pQmapDev->use_rmnet_usb) {
+        qmap_unregister_device(pQmapDev, 0);
+        rtnl_lock();
+        netdev_rx_handler_unregister(dev->net);
+        rtnl_unlock();
+    }
+
+    tasklet_kill(&pQmapDev->txq);
+
+    usbnet_disconnect(intf);
+    info->unused = 0;
+    kfree(pQmapDev);
+}
+#endif
+
+static struct usb_driver qmi_wwan_driver = {
+    .name              = "qmi_wwan_f",
+    .id_table          = products,
+#if !defined(FIBOCOM_WWAN_QMAP)
+    .probe              = qmi_wwan_probe,
+#endif
+#if defined(FIBOCOM_WWAN_QMAP)
+    .probe              = qmap_qmi_wwan_probe,
+    .disconnect          = qmap_qmi_wwan_disconnect,
+#else
+    .probe              = qmi_wwan_probe,
+    .disconnect          = usbnet_disconnect,
+#endif
+    .suspend          = qmi_wwan_suspend,
+    .resume              =    qmi_wwan_resume,
+    .reset_resume         = qmi_wwan_reset_resume,
+    .supports_autosuspend = 1,
+    .disable_hub_initiated_lpm = 1,
+};
+
+#ifdef CONFIG_QCA_NSS_DRV
+/*
+    EXTRA_CFLAGS="-I$(STAGING_DIR)/usr/include/qca-nss-drv  $(EXTRA_CFLAGS)"
+    qsdk/qca/src/data-kernel/drivers/rmnet-nss/rmnet_nss.c
+*/
+#include "rmnet_nss.c"
+#endif
+
+static int __init qmi_wwan_driver_init(void)
+{
+    RCU_INIT_POINTER(rmnet_nss_callbacks, NULL);
+#ifdef CONFIG_QCA_NSS_DRV
+    if (qca_nss_enabled)
+        rmnet_nss_init();
+#endif
+    return usb_register(&qmi_wwan_driver);
+}
+module_init(qmi_wwan_driver_init);
+static void __exit qmi_wwan_driver_exit(void)
+{
+#ifdef CONFIG_QCA_NSS_DRV
+    if (qca_nss_enabled)
+        rmnet_nss_exit();
+#endif
+    usb_deregister(&qmi_wwan_driver);
+}
+module_exit(qmi_wwan_driver_exit);
+
+MODULE_AUTHOR("Bjørn Mork <bjorn@mork.no>");
+MODULE_DESCRIPTION("Qualcomm MSM Interface (QMI) WWAN driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(FIBOCOM_WWAN_VERSION);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
old mode 100755
new mode 100644
index 5b4ca93325e4..ff099f1c5a49
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d.c
@@ -178,38 +178,38 @@ static u32 sys_reboot_tbl[][2] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw.bin",
-		.wl_table      = "fmacfw_patch.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw.bin",
+		.wl_table      = "aic/fmacfw_patch.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw_rf.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw_rf.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u03[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw.bin",
-		.wl_table      = "fmacfw_patch.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw.bin",
+		.wl_table      = "aic/fmacfw_patch.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw_rf.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw_rf.bin"
 	},
 };
 
@@ -218,36 +218,36 @@ static const struct aicbsp_firmware fw_u03[] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw_usb.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw_usb.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw_rf_usb.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u03[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw_usb.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw_usb.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw_rf_usb.bin"
 	},
 };
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
old mode 100755
new mode 100644
index 309d1afe8aa4..ba8c63186633
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800d80.c
@@ -120,54 +120,54 @@ u32 gpio_cfg_tbl_8800d40d80[][2] = {
 static const struct aicbsp_firmware fw_u01[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u01)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80.bin",
-		.wl_fw         = "aic8800d80/fmacfw_8800d80.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u01)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80.bin",
-		.wl_fw         = "aic8800d80/lmacfw_rf_8800d80.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80.bin",
+		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic8800d80/fmacfw_8800d80_u02.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic8800d80/lmacfw_rf_8800d80_u02.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_h_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic8800d80/fmacfw_8800d80_h_u02.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/aic8800d80/fmacfw_8800d80_h_u02.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic8800d80/fw_adid_8800d80_u02.bin",
-		.bt_patch      = "aic8800d80/fw_patch_8800d80_u02.bin",
-		.bt_table      = "aic8800d80/fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "aic8800d80/lmacfw_rf_8800d80_u02.bin"
+		.bt_adid       = "aic/aic8800d80/fw_adid_8800d80_u02.bin",
+		.bt_patch      = "aic/aic8800d80/fw_patch_8800d80_u02.bin",
+		.bt_table      = "aic/aic8800d80/fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "aic/aic8800d80/lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
@@ -176,36 +176,36 @@ static const struct aicbsp_firmware fw_h_u02[] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw_usb.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw_usb.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u02)",
-		.bt_adid       = "fw_adid.bin",
-		.bt_patch      = "fw_patch.bin",
-		.bt_table      = "fw_patch_table.bin",
-		.wl_fw         = "fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/fw_adid.bin",
+		.bt_patch      = "aic/fw_patch.bin",
+		.bt_table      = "aic/fw_patch_table.bin",
+		.wl_fw         = "aic/fmacfw_rf_usb.bin"
 	},
 };
 
 static const struct aicbsp_firmware fw_u03[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(usb u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw_usb.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw_usb.bin"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(usb u03/u04)",
-		.bt_adid       = "fw_adid_u03.bin",
-		.bt_patch      = "fw_patch_u03.bin",
-		.bt_table      = "fw_patch_table_u03.bin",
-		.wl_fw         = "fmacfw_rf_usb.bin"
+		.bt_adid       = "aic/fw_adid_u03.bin",
+		.bt_patch      = "aic/fw_patch_u03.bin",
+		.bt_table      = "aic/fw_patch_table_u03.bin",
+		.wl_fw         = "aic/fmacfw_rf_usb.bin"
 	},
 };
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
old mode 100755
new mode 100644
index 4b660bfa557e..13e74d4a4ee4
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_8800dc.c
@@ -484,20 +484,20 @@ static u32 patch_tbl_rf_func[][2] = {
 static const struct aicbsp_firmware fw_u01[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u01)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc.bin",
-		.wl_fw         = "aic8800dc/fmacfw_patch_8800dc.bin",
-		.wl_table      = "aic8800dc/fmacfw_patch_tbl_8800dc.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc.bin",
+		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc.bin",
 		.wl_calib      = NULL,
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u01)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc.bin",
-		.wl_fw         = "aic8800dc/fmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc.bin",
+		.wl_fw         = "aic/aic8800dc/fmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
 		.wl_calib      = NULL,
 	},
@@ -506,44 +506,44 @@ static const struct aicbsp_firmware fw_u01[] = {
 static const struct aicbsp_firmware fw_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio u02)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc_u02.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc_u02.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc_u02.bin",
-		.wl_fw         = "aic8800dc/fmacfw_patch_8800dc_u02.bin",
-		.wl_table      = "aic8800dc/fmacfw_patch_tbl_8800dc_u02.bin",
-		.wl_calib      = "aic8800dc/fmacfw_calib_8800dc_u02.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc_u02.bin",
+		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc_u02.bin",
+		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_u02.bin",
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio u02)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc_u02.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc_u02.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc_u02.bin",
-		.wl_fw         = "aic8800dc/lmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02.bin",
+		.wl_fw         = "aic/aic8800dc/lmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
-		.wl_calib      = "aic8800dc/fmacfw_calib_8800dc_u02.bin",
+		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_u02.bin",
 	},
 };
 
 static const struct aicbsp_firmware fw_h_u02[] = {
 	[AICBSP_CPMODE_WORK] = {
 		.desc          = "normal work mode(sdio h u02)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc_u02h.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc_u02h.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc_u02h.bin",
-		.wl_fw         = "aic8800dc/fmacfw_patch_8800dc_h_u02.bin",
-		.wl_table      = "aic8800dc/fmacfw_patch_tbl_8800dc_h_u02.bin",
-		.wl_calib      = "aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "aic/aic8800dc/fmacfw_patch_8800dc_h_u02.bin",
+		.wl_table      = "aic/aic8800dc/fmacfw_patch_tbl_8800dc_h_u02.bin",
+		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
 	},
 
 	[AICBSP_CPMODE_TEST] = {
 		.desc          = "rf test mode(sdio h u02)",
-		.bt_adid       = "aic8800dc/fw_adid_8800dc_u02h.bin",
-		.bt_patch      = "aic8800dc/fw_patch_8800dc_u02h.bin",
-		.bt_table      = "aic8800dc/fw_patch_table_8800dc_u02h.bin",
-		.wl_fw         = "aic8800dc/lmacfw_rf_8800dc.bin",
+		.bt_adid       = "aic/aic8800dc/fw_adid_8800dc_u02h.bin",
+		.bt_patch      = "aic/aic8800dc/fw_patch_8800dc_u02h.bin",
+		.bt_table      = "aic/aic8800dc/fw_patch_table_8800dc_u02h.bin",
+		.wl_fw         = "aic/aic8800dc/lmacfw_rf_8800dc.bin",
 		.wl_table      = NULL,
-		.wl_calib      = "aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
+		.wl_calib      = "aic/aic8800dc/fmacfw_calib_8800dc_h_u02.bin",
 	},
 };
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
old mode 100755
new mode 100644
index d03dea1dfe17..81e6aea6c3cc
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
@@ -402,7 +402,7 @@ enum aicdev_hw_feature {
 #endif
 #define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
 #define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT    1
+#define AICBT_LPM_ENABLE_DEFAULT    0
 #define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_LVL
 
 #define AIC_SDIO_V2_CLOCK           70000000U  // 0: default, other: target clock rate
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_helper.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_helper.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_txrxif.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_verify.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_verify.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicusb.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c b/drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h b/drivers/net/wireless/aic8800/aic8800_btusb/aic_btusb.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800d80.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_8800dc.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h
old mode 100755
new mode 100644
diff --git a/drivers/pci/controller/dwc/pcie-k1x.c b/drivers/pci/controller/dwc/pcie-k1x.c
index 61a3d9d5374c..cd807578749a 100644
--- a/drivers/pci/controller/dwc/pcie-k1x.c
+++ b/drivers/pci/controller/dwc/pcie-k1x.c
@@ -30,6 +30,11 @@
 #include "../../pci.h"
 #include "pcie-designware.h"
 
+#define PCIE_VENDORID_MASK	0xffff
+#define PCIE_DEVICEID_SHIFT	16
+#define K1X_PCIE_VENDOR_ID	0x201F
+#define k1X_PCIE_DEVICE_ID	0x0001
+
 /* PCIe controller wrapper k1x configuration registers */
 
 #define	K1X_PHY_AHB_IRQ_EN              0x0000
@@ -1012,6 +1017,17 @@ int k1x_pcie_wait_for_speed_change(struct dw_pcie *pci)
 	return -ETIMEDOUT;
 }
 
+static int __init k1x_pcie_init_id(struct k1x_pcie *k1x)
+{
+	struct dw_pcie *pci = k1x->pci;
+
+	dw_pcie_dbi_ro_wr_en(pci);
+	dw_pcie_writew_dbi(pci, PCI_VENDOR_ID, K1X_PCIE_VENDOR_ID);
+	dw_pcie_writew_dbi(pci, PCI_DEVICE_ID, k1X_PCIE_DEVICE_ID);
+	dw_pcie_dbi_ro_wr_dis(pci);
+
+	return 0;
+}
 
 static int k1x_pcie_host_init(struct dw_pcie_rp *pp)
 {
@@ -1375,6 +1391,8 @@ static int __init k1x_add_pcie_port(struct k1x_pcie *k1x,
 
 	pp->ops = &k1x_pcie_host_ops;
 
+	k1x_pcie_init_id(k1x);
+
 	pp->num_vectors = MAX_MSI_IRQS;
 	ret = dw_pcie_host_init(pp);
 	if (ret) {
diff --git a/drivers/power/supply/sbs-charger-virtual.c b/drivers/power/supply/sbs-charger-virtual.c
old mode 100755
new mode 100644
diff --git a/drivers/soc/spacemit/spacemit-rf/Makefile b/drivers/soc/spacemit/spacemit-rf/Makefile
index c2cb0d17295f..5bd183c2b043 100644
--- a/drivers/soc/spacemit/spacemit-rf/Makefile
+++ b/drivers/soc/spacemit/spacemit-rf/Makefile
@@ -3,4 +3,4 @@
 # Makefile for wifi bluetooth power controller drivers
 #
 
-obj-$(CONFIG_SPACEMIT_RFKILL)   += spacemit-pwrseq.o spacemit-wlan.o spacemit-bt.o
+obj-$(CONFIG_SPACEMIT_RFKILL)   += spacemit-pwrseq.o spacemit-wlan.o spacemit-bt.o spacemit-rfkill.o
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c b/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
index 4cd27bbcbfe4..48677d23778d 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-bt.c
@@ -27,6 +27,7 @@
 
 struct bt_pwrseq {
 	struct device		*dev;
+	struct spacemit_pwrseq *parent;
 	bool power_state;
 	u32 power_on_delay_ms;
 
@@ -37,21 +38,19 @@ struct bt_pwrseq {
 
 static int spacemit_bt_on(struct bt_pwrseq *pwrseq, bool on_off)
 {
-	struct spacemit_pwrseq *parent_pwrseq = spacemit_get_pwrseq();
-
 	if (!pwrseq || IS_ERR(pwrseq->reset_n))
 		return 0;
 
 	if (on_off){
-		if(parent_pwrseq)
-			spacemit_power_on(parent_pwrseq, 1);
+		if(pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 1);
 		gpiod_set_value(pwrseq->reset_n, 1);
 		if (pwrseq->power_on_delay_ms)
 			msleep(pwrseq->power_on_delay_ms);
 	}else{
 		gpiod_set_value(pwrseq->reset_n, 0);
-		if(parent_pwrseq)
-			spacemit_power_on(parent_pwrseq, 0);
+		if(pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 0);
 	}
 
 	pwrseq->power_state = on_off;
@@ -93,6 +92,7 @@ static int spacemit_bt_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	pwrseq->dev = dev;
+	pwrseq->parent = spacemit_get_pwrseq_from_dev(pwrseq->dev);
 	platform_set_drvdata(pdev, pwrseq);
 
 	pwrseq->reset_n = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
index fe9cd20545ef..eb9afa9bced3 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.c
@@ -24,11 +24,13 @@
 #include <linux/platform_device.h>
 #include "spacemit-pwrseq.h"
 
-struct spacemit_pwrseq *pwrseq_data;
 
-struct spacemit_pwrseq *spacemit_get_pwrseq(void)
+struct spacemit_pwrseq *spacemit_get_pwrseq_from_dev(struct device *dev)
 {
-	return pwrseq_data;
+	if (dev && dev->parent && dev->parent->of_node &&
+	    of_device_is_compatible(dev->parent->of_node, "spacemit,rf-pwrseq"))
+		return platform_get_drvdata(to_platform_device(dev->parent));
+	return NULL;
 }
 
 static void spacemit_set_gpios_value(struct spacemit_pwrseq *pwrseq,
@@ -251,8 +253,6 @@ static int spacemit_pwrseq_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	pwrseq_data = pwrseq;
-
 	mutex_init(&pwrseq->pwrseq_mutex);
 	atomic_set(&pwrseq->pwrseq_count, 0);
 
@@ -272,7 +272,6 @@ static int spacemit_pwrseq_remove(struct platform_device *pdev)
 	mutex_destroy(&pwrseq->pwrseq_mutex);
 	of_platform_depopulate(&pdev->dev);
 
-	pwrseq_data = NULL;
 	return 0;
 }
 
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.h b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.h
index 75cd875d4e67..22ff01890757 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.h
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-pwrseq.h
@@ -20,5 +20,5 @@ struct spacemit_pwrseq {
 };
 
 void spacemit_power_on(struct spacemit_pwrseq *pwrseq, bool on_off);
-struct spacemit_pwrseq *spacemit_get_pwrseq(void);
+struct spacemit_pwrseq *spacemit_get_pwrseq_from_dev(struct device*);
 #endif
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c b/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c
new file mode 100644
index 000000000000..59e9fa277f3e
--- /dev/null
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-rfkill.c
@@ -0,0 +1,321 @@
+/*
+ * spacemit-rfkill.c -- power on/off rfkill part of SoC
+ *
+ * Copyright 2023, Spacemit Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/rfkill.h>
+#include <linux/gpio/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of.h>
+#include "spacemit-pwrseq.h"
+
+struct rfkill_pwrseq {
+	struct device *dev;
+	struct spacemit_pwrseq *parent;
+
+	bool unblock_at_boot;
+	bool power_state;
+	u32 power_on_delay_ms;
+
+	bool power_use_pulse;
+	u32 power_pulse_delay_ms;
+	u32 power_off_pulse_delay_ms;
+
+	bool reset_power_off;
+	bool reset_use_pulse;
+	u32 reset_pulse_delay_ms;
+
+	struct gpio_desc *reset_n;
+	struct gpio_desc *power_n;
+	struct clk *ext_clk;
+	struct rfkill *rfkill;
+};
+
+static void spacemit_rfkill_set_pin(struct gpio_desc *gpio, int value,
+				    bool use_pulse, u32 pulse_delay)
+{
+	if (!gpio)
+		return;
+	if (use_pulse) {
+		value = 1;
+		gpiod_set_value(gpio, value);
+		msleep(pulse_delay);
+		/* Pulse power key should restore to original level after pulse */
+		value = !value;
+	}
+	gpiod_set_value(gpio, value);
+}
+
+static int spacemit_rfkill_on(struct rfkill_pwrseq *pwrseq, bool on_off)
+{
+	if (!pwrseq || IS_ERR(pwrseq->reset_n))
+		return 0;
+
+	if (on_off) {
+		if (pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 1);
+		spacemit_rfkill_set_pin(pwrseq->power_n, 1,
+					pwrseq->power_use_pulse,
+					pwrseq->power_pulse_delay_ms);
+		if (pwrseq->power_on_delay_ms)
+			msleep(pwrseq->power_on_delay_ms);
+		spacemit_rfkill_set_pin(pwrseq->reset_n, 1,
+					pwrseq->reset_use_pulse,
+					pwrseq->reset_pulse_delay_ms);
+	} else {
+		if (pwrseq->reset_power_off)
+			spacemit_rfkill_set_pin(pwrseq->reset_n, 0,
+						pwrseq->reset_use_pulse,
+						pwrseq->reset_pulse_delay_ms);
+		spacemit_rfkill_set_pin(pwrseq->power_n, 0,
+					pwrseq->power_use_pulse,
+					pwrseq->power_off_pulse_delay_ms);
+		if (pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 0);
+	}
+
+	pwrseq->power_state = on_off;
+	return 0;
+}
+
+static int spacemit_rfkill_set_block(void *data, bool blocked)
+{
+	struct rfkill_pwrseq *pwrseq = data;
+	int ret;
+
+	if (blocked != pwrseq->power_state) {
+		dev_warn(pwrseq->dev, "block state already is %d\n", blocked);
+		return 0;
+	}
+
+	dev_info(pwrseq->dev, "set block: %d\n", blocked);
+	ret = spacemit_rfkill_on(pwrseq, !blocked);
+	if (ret) {
+		dev_err(pwrseq->dev, "set block failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct rfkill_ops spacemit_rfkill_ops = {
+	.set_block = spacemit_rfkill_set_block,
+};
+
+static const char *const spacemit_rfkill_types[] = {
+	[RFKILL_TYPE_ALL] = "spacemit,rfkill-pwrseq",
+	[RFKILL_TYPE_WLAN] = "spacemit,wlan-pwrseq",
+	[RFKILL_TYPE_BLUETOOTH] = "spacemit,bt-pwrseq",
+	[RFKILL_TYPE_UWB] = "spacemit,uwb-pwrseq",
+	[RFKILL_TYPE_WIMAX] = "spacemit,wimax-pwrseq",
+	[RFKILL_TYPE_WWAN] = "spacemit,wwan-pwrseq",
+	[RFKILL_TYPE_GPS] = "spacemit,gps-pwrseq",
+	[RFKILL_TYPE_FM] = "spacemit,fm-pwrseq",
+	[RFKILL_TYPE_NFC] = "spacemit,nfc-pwrseq"
+};
+
+static enum rfkill_type
+spacemit_rfkill_determine_type(struct rfkill_pwrseq *pwrseq)
+{
+	struct device *dev = pwrseq->dev;
+	const char *compatible;
+	int ret;
+	ret = of_property_read_string(dev->of_node, "compatible", &compatible);
+	if (ret) {
+		dev_warn(dev, "failed to get compatible\n");
+		compatible = "spacemit,rfkill-pwrseq";
+	}
+	ret = match_string(spacemit_rfkill_types,
+			   ARRAY_SIZE(spacemit_rfkill_types), compatible);
+	return (ret < 0) ? RFKILL_TYPE_ALL : ret;
+}
+
+static int spacemit_rfkill_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rfkill_pwrseq *pwrseq;
+	const char *device_name;
+	enum rfkill_type rftype;
+	int ret;
+
+	pwrseq = devm_kzalloc(dev, sizeof(*pwrseq), GFP_KERNEL);
+	if (!pwrseq)
+		return -ENOMEM;
+
+	pwrseq->dev = dev;
+	pwrseq->parent = spacemit_get_pwrseq_from_dev(dev);
+	platform_set_drvdata(pdev, pwrseq);
+
+	pwrseq->reset_n = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(pwrseq->reset_n) && PTR_ERR(pwrseq->reset_n) != -ENOENT &&
+	    PTR_ERR(pwrseq->reset_n) != -ENOSYS) {
+		return PTR_ERR(pwrseq->reset_n);
+	}
+
+	pwrseq->power_n = devm_gpiod_get_optional(dev, "power", GPIOD_OUT_LOW);
+	if (IS_ERR(pwrseq->power_n) && PTR_ERR(pwrseq->power_n) != -ENOENT &&
+	    PTR_ERR(pwrseq->power_n) != -ENOSYS) {
+		return PTR_ERR(pwrseq->power_n);
+	}
+
+	pwrseq->ext_clk = devm_clk_get(dev, "clock");
+	if (IS_ERR_OR_NULL(pwrseq->ext_clk)) {
+		dev_dbg(dev, "failed get ext clock\n");
+	} else {
+		ret = clk_prepare_enable(pwrseq->ext_clk);
+		if (ret < 0)
+			dev_warn(dev, "can't enable clk\n");
+	}
+
+	if (device_property_read_u32(dev, "power-on-delay-ms",
+				     &pwrseq->power_on_delay_ms))
+		pwrseq->power_on_delay_ms = 10;
+
+	if (device_property_read_u32(dev, "power-pulse-delay-ms",
+				     &pwrseq->power_pulse_delay_ms))
+		pwrseq->power_pulse_delay_ms = 10;
+
+	if (device_property_read_u32(dev, "power-off-pulse-delay-ms",
+				     &pwrseq->power_off_pulse_delay_ms))
+		pwrseq->power_off_pulse_delay_ms = pwrseq->power_pulse_delay_ms;
+
+	/* Some rf modules reset cause power on, thus not reset on power-off sequence by default */
+	pwrseq->reset_power_off =
+		device_property_read_bool(dev, "reset-power-off");
+
+	pwrseq->power_use_pulse =
+		device_property_read_bool(dev, "power-use-pulse");
+	if (pwrseq->power_use_pulse) {
+		dev_info(dev, "power use pulse, delay: %dms/%dms\n",
+			 pwrseq->power_pulse_delay_ms,
+			 pwrseq->power_off_pulse_delay_ms);
+	}
+
+	if (device_property_read_u32(dev, "reset-pulse-delay-ms",
+				     &pwrseq->reset_pulse_delay_ms))
+		pwrseq->reset_pulse_delay_ms = 10;
+
+	pwrseq->reset_use_pulse =
+		device_property_read_bool(dev, "reset-use-pulse");
+	if (pwrseq->reset_use_pulse) {
+		dev_info(dev, "reset use pulse, delay: %dms\n",
+			 pwrseq->reset_pulse_delay_ms);
+	}
+
+	rftype = spacemit_rfkill_determine_type(pwrseq);
+
+	ret = device_property_read_string(dev, "rfkill-name", &device_name);
+	if (ret) {
+		dev_warn(dev, "no rfkill name specificed, use default one\n");
+		device_name = spacemit_rfkill_types[rftype];
+	}
+
+	pwrseq->rfkill = rfkill_alloc(device_name, dev, rftype,
+				      &spacemit_rfkill_ops, pwrseq);
+	if (!pwrseq->rfkill) {
+		dev_err(dev, "failed alloc rfkill device\n");
+		ret = -ENOMEM;
+		goto alloc_err;
+	}
+
+	rfkill_set_states(pwrseq->rfkill, true, false);
+
+	ret = rfkill_register(pwrseq->rfkill);
+	if (ret) {
+		dev_err(dev, "failed register %s rfkill\n", device_name);
+		goto register_err;
+	}
+
+	if (device_property_read_bool(dev, "rfkill-unblock-at-boot")) {
+		spacemit_rfkill_on(pwrseq, true);
+		rfkill_set_states(pwrseq->rfkill, false, false);
+	}
+
+	return 0;
+
+register_err:
+	if (pwrseq->rfkill)
+		rfkill_destroy(pwrseq->rfkill);
+alloc_err:
+	if (!IS_ERR_OR_NULL(pwrseq->ext_clk))
+		clk_disable_unprepare(pwrseq->ext_clk);
+	return ret;
+}
+
+static int spacemit_rfkill_remove(struct platform_device *pdev)
+{
+	struct rfkill_pwrseq *pwrseq = platform_get_drvdata(pdev);
+
+	if (pwrseq->rfkill) {
+		rfkill_unregister(pwrseq->rfkill);
+		rfkill_destroy(pwrseq->rfkill);
+	}
+
+	if (!IS_ERR_OR_NULL(pwrseq->ext_clk))
+		clk_disable_unprepare(pwrseq->ext_clk);
+
+	return 0;
+}
+
+static const struct of_device_id spacemit_rfkill_ids[] = {
+	{ .compatible = "spacemit,rfkill-pwrseq" },
+	/* { .compatible =  "spacemit,wlan-pwrseq" },
+	 * { .compatible =  "spacemit,bt-pwrseq" }, */
+	{ .compatible =  "spacemit,uwb-pwrseq" },
+	{ .compatible = "spacemit,wwan-pwrseq" },
+	{ .compatible = "spacemit,gps-pwrseq" },
+	{ .compatible = "spacemit,fm-pwrseq" },
+	{ .compatible = "spacemit,nfc-pwrseq" },
+	{ /* Sentinel */ }
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int spacemit_rfkill_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int spacemit_rfkill_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops spacemit_rfkill_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(spacemit_rfkill_suspend, spacemit_rfkill_resume)
+};
+
+#define DEV_PM_OPS (&spacemit_rfkill_dev_pm_ops)
+#else
+#define DEV_PM_OPS NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static struct platform_driver spacemit_rfkill_driver = {
+	.probe		= spacemit_rfkill_probe,
+	.remove	= spacemit_rfkill_remove,
+	.driver	= {
+		.owner	= THIS_MODULE,
+		.name	= "spacemit-rfkill",
+		.of_match_table	= spacemit_rfkill_ids,
+	},
+};
+
+module_platform_driver(spacemit_rfkill_driver);
+
+MODULE_DESCRIPTION("spacemit rfkill pwrseq driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
index bf02ade21dd4..c7a553ba5f76 100644
--- a/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
+++ b/drivers/soc/spacemit/spacemit-rf/spacemit-wlan.c
@@ -26,6 +26,7 @@
 
 struct wlan_pwrseq {
 	struct device		*dev;
+	struct spacemit_pwrseq *parent;
 	bool power_state;
 	u32 power_on_delay_ms;
 
@@ -87,21 +88,19 @@ EXPORT_SYMBOL_GPL(spacemit_wlan_get_oob_irq_flags);
 
 static int spacemit_wlan_on(struct wlan_pwrseq *pwrseq, bool on_off)
 {
-	struct spacemit_pwrseq *parent_pwrseq = spacemit_get_pwrseq();
-
 	if (!pwrseq || IS_ERR(pwrseq->regon))
 		return 0;
 
 	if (on_off){
-		if(parent_pwrseq)
-			spacemit_power_on(parent_pwrseq, 1);
+		if(pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 1);
 		gpiod_set_value(pwrseq->regon, 1);
 		if (pwrseq->power_on_delay_ms)
 			msleep(pwrseq->power_on_delay_ms);
 	}else{
 		gpiod_set_value(pwrseq->regon, 0);
-		if(parent_pwrseq)
-			spacemit_power_on(parent_pwrseq, 0);
+		if(pwrseq->parent)
+			spacemit_power_on(pwrseq->parent, 0);
 	}
 
 	pwrseq->power_state = on_off;
@@ -118,6 +117,7 @@ static int spacemit_wlan_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	pwrseq->dev = dev;
+	pwrseq->parent = spacemit_get_pwrseq_from_dev(dev);
 	platform_set_drvdata(pdev, pwrseq);
 
 	pwrseq->regon = devm_gpiod_get(dev, "regon", GPIOD_OUT_LOW);
diff --git a/drivers/spi/spi-k1x-qspi.c b/drivers/spi/spi-k1x-qspi.c
index 88a73be7d29e..3fc36a35b308 100644
--- a/drivers/spi/spi-k1x-qspi.c
+++ b/drivers/spi/spi-k1x-qspi.c
@@ -1216,6 +1216,25 @@ static bool k1x_qspi_supports_op(struct spi_mem *mem,
 	return true;
 }
 
+static const char *k1x_qspi_get_name(struct spi_mem *mem)
+{
+
+	struct k1x_qspi *qspi = spi_master_get_devdata(mem->spi->master);
+	struct device *dev = qspi->dev;
+	const char *name;
+
+	name = devm_kasprintf(dev, GFP_KERNEL,
+			      "%s-%d", dev_name(dev),
+			      mem->spi->chip_select);
+
+	if (!name) {
+		dev_err(dev, "failed to get memory for custom flash name\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return name;
+}
+
 static int k1x_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 {
 	struct k1x_qspi *qspi = spi_controller_get_devdata(mem->spi->master);
@@ -1385,6 +1404,7 @@ static const struct spi_controller_mem_ops k1x_qspi_mem_ops = {
 	.adjust_op_size = k1x_qspi_adjust_op_size,
 	.supports_op = k1x_qspi_supports_op,
 	.exec_op = k1x_qspi_exec_op,
+	.get_name = k1x_qspi_get_name,
 };
 
 static int k1x_qspi_probe(struct platform_device *pdev)
diff --git a/drivers/usb/phy/phy-k1x-ci-otg.c b/drivers/usb/phy/phy-k1x-ci-otg.c
index 4bd7ebfd093c..522135bef288 100644
--- a/drivers/usb/phy/phy-k1x-ci-otg.c
+++ b/drivers/usb/phy/phy-k1x-ci-otg.c
@@ -229,7 +229,6 @@ static int mv_otg_enable_internal(struct mv_otg *mvotg)
 		"otg enabled, will enable clk, release rst\n");
 
 	otg_clock_enable(mvotg);
-	otg_reset_assert(mvotg);
 	otg_reset_deassert(mvotg);
 	retval = usb_phy_init(mvotg->outer_phy);
 	if (retval) {
-- 
2.47.0

