From c719cd220b75a7a1f5b1d6d0d2ddfa9ff2ee688e Mon Sep 17 00:00:00 2001
From: yanhaodong <haodong.yan@spacemit.com>
Date: Thu, 19 Dec 2024 17:52:24 +0800
Subject: [PATCH 1373/1451] Revert "k1x-fix i2c driver:send stop signal after
 every msg"

this method is not compatible with some smbus protocols.
We adopt other methods to solve retry problem of i2c,revert this patch.

This reverts commit 95a7890af813014568518a1cca5a55a95d4a28b9.

Change-Id: I81890bbb88ee60a4c1913b541bee10bda00c9d85
---
 drivers/i2c/busses/i2c-k1x.c | 23 ++++++-----------------
 1 file changed, 6 insertions(+), 17 deletions(-)

diff --git a/drivers/i2c/busses/i2c-k1x.c b/drivers/i2c/busses/i2c-k1x.c
index fdf9ea536f87..363e150eabbb 100644
--- a/drivers/i2c/busses/i2c-k1x.c
+++ b/drivers/i2c/busses/i2c-k1x.c
@@ -28,6 +28,7 @@
 #include <linux/reboot.h>
 #include <linux/of_device.h>
 #include <linux/rpmsg.h>
+
 #include "i2c-k1x.h"
 
 #ifdef CONFIG_SOC_SPACEMIT_K1X
@@ -241,8 +242,8 @@ spacemit_i2c_clear_int_status(struct spacemit_i2c_dev *spacemit_i2c, u32 mask)
 
 static bool spacemit_i2c_is_last_byte_to_send(struct spacemit_i2c_dev *spacemit_i2c)
 {
-	return (spacemit_i2c->tx_cnt == spacemit_i2c->cur_msg->len
-		&& spacemit_i2c->msg_idx == spacemit_i2c->num - 1) ? true : false;
+	return (spacemit_i2c->tx_cnt == spacemit_i2c->cur_msg->len &&
+		spacemit_i2c->msg_idx == spacemit_i2c->num - 1) ? true : false;
 }
 
 static bool spacemit_i2c_is_last_byte_to_receive(struct spacemit_i2c_dev *spacemit_i2c)
@@ -368,8 +369,7 @@ static int spacemit_i2c_byte_xfer_body(struct spacemit_i2c_dev *spacemit_i2c)
 		}
 	} else if (spacemit_i2c->i2c_status & SR_ITE) { /* i2c transmit empty */
 		/* MSD comes with ITE */
-		if ((spacemit_i2c->i2c_status & SR_MSD) && (spacemit_i2c->msg_idx == spacemit_i2c->num - 1))
-			/* only if stop signal come with the last msg, we do nothing */
+		if (spacemit_i2c->i2c_status & SR_MSD)
 			return ret;
 
 		if (spacemit_i2c->i2c_status & SR_RWM) { /* receive mode */
@@ -403,10 +403,7 @@ static int spacemit_i2c_byte_xfer_body(struct spacemit_i2c_dev *spacemit_i2c)
 				/* send stop pulse for last byte of last msg */
 				if (spacemit_i2c_is_last_byte_to_send(spacemit_i2c))
 					cr_val |= CR_STOP;
-				else if (spacemit_i2c->tx_cnt == spacemit_i2c->cur_msg->len) {
-					cr_val |= CR_STOP;
-					cr_val &= ~CR_DTEIE;
-				}
+
 				cr_val |= CR_ALDIE | CR_TB;
 				spacemit_i2c_write_reg(spacemit_i2c, REG_CR, cr_val);
 			} else if (spacemit_i2c->msg_idx < spacemit_i2c->num - 1) {
@@ -1005,7 +1002,7 @@ static irqreturn_t spacemit_i2c_int_handler(int irq, void *devid)
 	 * send transaction complete signal:
 	 * error happens, detect master stop
 	 */
-	if (likely(spacemit_i2c->i2c_err || (ret < 0) || ((status & SR_MSD) && !(status & SR_ITE)))) {
+	if (likely(spacemit_i2c->i2c_err || (ret < 0) || (status & SR_MSD))) {
 		/*
 		 * Here the transaction is already done, we don't need any
 		 * other interrupt signals from now, in case any interrupt
@@ -1020,14 +1017,6 @@ static irqreturn_t spacemit_i2c_int_handler(int irq, void *devid)
 		spacemit_i2c_clear_int_status(spacemit_i2c, SPACEMIT_I2C_INT_STATUS_MASK);
 
 		complete(&spacemit_i2c->complete);
-	} else if ((status & SR_MSD) && (status & SR_ITE)) {
-		if (spacemit_i2c->tx_cnt > 1) {
-			ctrl = spacemit_i2c_read_reg(spacemit_i2c, REG_CR);
-			ctrl &= ~SPACEMIT_I2C_INT_CTRL_MASK;
-			spacemit_i2c_write_reg(spacemit_i2c, REG_CR, ctrl);
-			spacemit_i2c_clear_int_status(spacemit_i2c, SPACEMIT_I2C_INT_STATUS_MASK);
-			complete(&spacemit_i2c->complete);
-		}
 	}
 
 	return IRQ_HANDLED;
-- 
2.47.0

