From a5968854174505f60c982b1985407ff281b6ed05 Mon Sep 17 00:00:00 2001
From: wanlong <long.wan@spacemit.com>
Date: Thu, 25 Apr 2024 18:32:22 +0800
Subject: [PATCH 0671/1204] net: usb: add asix usb nic driver, ver: v3.1.0

Change-Id: I8d62eea450b69c7569eb1eebdc4be6269b6f7319
---
 drivers/net/usb/Kconfig                       |    1 +
 drivers/net/usb/Makefile                      |    1 +
 drivers/net/usb/asix_usb/Kconfig              |    6 +
 drivers/net/usb/asix_usb/Makefile             |  103 +
 drivers/net/usb/asix_usb/Readme               |  255 ++
 drivers/net/usb/asix_usb/ax88179_178a.c       | 1238 ++++++++
 drivers/net/usb/asix_usb/ax88179_178a.h       |   35 +
 drivers/net/usb/asix_usb/ax88179_programmer.c |  629 ++++
 drivers/net/usb/asix_usb/ax88179a_772d.c      | 2627 +++++++++++++++++
 drivers/net/usb/asix_usb/ax88179a_772d.h      |  246 ++
 drivers/net/usb/asix_usb/ax88179a_ieee.c      |  369 +++
 .../net/usb/asix_usb/ax88179a_programmer.c    | 1532 ++++++++++
 drivers/net/usb/asix_usb/ax88279_programmer.c | 1813 ++++++++++++
 drivers/net/usb/asix_usb/ax_ioctl.h           |  212 ++
 drivers/net/usb/asix_usb/ax_main.c            | 2620 ++++++++++++++++
 drivers/net/usb/asix_usb/ax_main.h            |  674 +++++
 drivers/net/usb/asix_usb/ax_ptp.c             | 1167 ++++++++
 drivers/net/usb/asix_usb/ax_ptp.h             |  242 ++
 drivers/net/usb/asix_usb/axcmd.c              |  295 ++
 19 files changed, 14065 insertions(+)
 create mode 100755 drivers/net/usb/asix_usb/Kconfig
 create mode 100755 drivers/net/usb/asix_usb/Makefile
 create mode 100755 drivers/net/usb/asix_usb/Readme
 create mode 100755 drivers/net/usb/asix_usb/ax88179_178a.c
 create mode 100755 drivers/net/usb/asix_usb/ax88179_178a.h
 create mode 100755 drivers/net/usb/asix_usb/ax88179_programmer.c
 create mode 100755 drivers/net/usb/asix_usb/ax88179a_772d.c
 create mode 100755 drivers/net/usb/asix_usb/ax88179a_772d.h
 create mode 100755 drivers/net/usb/asix_usb/ax88179a_ieee.c
 create mode 100755 drivers/net/usb/asix_usb/ax88179a_programmer.c
 create mode 100755 drivers/net/usb/asix_usb/ax88279_programmer.c
 create mode 100755 drivers/net/usb/asix_usb/ax_ioctl.h
 create mode 100755 drivers/net/usb/asix_usb/ax_main.c
 create mode 100755 drivers/net/usb/asix_usb/ax_main.h
 create mode 100755 drivers/net/usb/asix_usb/ax_ptp.c
 create mode 100755 drivers/net/usb/asix_usb/ax_ptp.h
 create mode 100755 drivers/net/usb/asix_usb/axcmd.c

diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 3c360d4f0635..8779ef3a73a2 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -644,4 +644,5 @@ config USB_RTL8153_ECM
 	  CONFIG_USB_RTL8152 is not set, or the RTL8153 device is not
 	  supported by r8152 driver.
 
+source "drivers/net/usb/asix_usb/Kconfig"
 endif # USB_NET_DRIVERS
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 4964f7b326fb..9470c7d3e46c 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -42,3 +42,4 @@ obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
 obj-$(CONFIG_USB_NET_AQC111)	+= aqc111.o
 obj-$(CONFIG_USB_RTL8153_ECM)	+= r8153_ecm.o
+obj-$(CONFIG_USB_NET_ASIX)	+= asix_usb/
diff --git a/drivers/net/usb/asix_usb/Kconfig b/drivers/net/usb/asix_usb/Kconfig
new file mode 100755
index 000000000000..9ddc3c404c55
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Kconfig
@@ -0,0 +1,6 @@
+config USB_NET_ASIX
+	tristate "ASIX USB 3.0/2.0 to Gigabit Ethernet"
+	depends on USB_USBNET
+	help
+	  This option adds support for ASIX USB3.0/2.0 Gigabit Ethernet Network
+	  Adapter Driver Compilation & Configuration on Linux
diff --git a/drivers/net/usb/asix_usb/Makefile b/drivers/net/usb/asix_usb/Makefile
new file mode 100755
index 000000000000..bc07ac9c5936
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Makefile
@@ -0,0 +1,103 @@
+TARGET	= ax_usb_nic
+KDIR	:= /lib/modules/$(shell uname -r)/build
+PWD	= $(shell pwd)
+
+ENABLE_IOCTL_DEBUG = n
+ENABLE_AUTODETACH_FUNC = n
+ENABLE_MAC_PASS = n
+ENABLE_INT_AGGRESSIVE = y
+ENABLE_INT_POLLING = n
+ENABLE_AUTOSUSPEND = n
+ENABLE_TX_TASKLET = n
+ENABLE_RX_TASKLET = n
+ENABLE_PTP_FUNC = n
+ENABLE_PTP_DEBUG = n
+ENABLE_QUEUE_PRIORITY = n
+
+obj-m := $(TARGET).o
+$(TARGET)-objs := ax_main.o ax88179_178a.o ax88179a_772d.o
+EXTRA_CFLAGS = -fno-pie
+TOOL_EXTRA_CFLAGS = -Werror
+
+ifeq ($(ENABLE_IOCTL_DEBUG), y)
+	EXTRA_CFLAGS += -DENABLE_IOCTL_DEBUG
+	TOOL_EXTRA_CFLAGS += -DENABLE_IOCTL_DEBUG
+endif
+
+ifeq ($(ENABLE_AUTODETACH_FUNC), y)
+	EXTRA_CFLAGS += -DENABLE_AUTODETACH_FUNC
+endif
+
+ifeq ($(ENABLE_MAC_PASS), y)
+	EXTRA_CFLAGS += -DENABLE_MAC_PASS
+endif
+
+ifeq ($(ENABLE_INT_AGGRESSIVE), y)
+	EXTRA_CFLAGS += -DENABLE_INT_AGGRESSIVE
+endif
+
+ifeq ($(ENABLE_INT_POLLING), y)
+	EXTRA_CFLAGS += -DENABLE_INT_POLLING
+endif
+
+ifeq ($(ENABLE_AUTOSUSPEND), y)
+	EXTRA_CFLAGS += -DENABLE_AUTOSUSPEND
+endif
+
+ifeq ($(ENABLE_TX_TASKLET), y)
+	EXTRA_CFLAGS += -DENABLE_TX_TASKLET
+endif
+ifeq ($(ENABLE_RX_TASKLET), y)
+	EXTRA_CFLAGS += -DENABLE_RX_TASKLET
+endif
+
+ifeq ($(ENABLE_PTP_FUNC), y)
+	$(TARGET)-objs += ax_ptp.o
+	EXTRA_CFLAGS += -DENABLE_PTP_FUNC
+ifeq ($(ENABLE_PTP_DEBUG), y)
+	EXTRA_CFLAGS += -DENABLE_PTP_DEBUG
+endif
+endif
+
+ifeq ($(ENABLE_QUEUE_PRIORITY), y)
+	EXTRA_CFLAGS += -DENABLE_QUEUE_PRIORITY
+endif
+
+	EXTRA_CFLAGS += -DENABLE_AX88279
+ifeq ($(ENABLE_MACSEC_FUNC), y)
+	$(TARGET)-objs += ax_macsec.o
+	EXTRA_CFLAGS += -DENABLE_MACSEC_FUNC
+endif
+	EXTRA_CFLAGS += -DENABLE_AX88279_MINIP_2_5G
+
+
+ifneq (,$(filter $(SUBLEVEL),14 15 16 17 18 19 20 21))
+MDIR	= kernel/drivers/usb/net
+else
+MDIR	= kernel/drivers/net/usb
+endif
+
+all:
+	make -C $(KDIR) M=$(PWD) modules
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179_programmer.c -o ax88179_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179a_programmer.c -o ax88179b_179a_772d_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88279_programmer.c -o ax88279_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179a_ieee.c -o ax88179b_179a_772d_ieee
+	$(CC) $(TOOL_EXTRA_CFLAGS) axcmd.c -o axcmd
+
+install:
+ifneq (,$(wildcard /lib/modules/$(shell uname -r)/$(MDIR)/ax88179_178a.ko))
+	gzip /lib/modules/$(shell uname -r)/$(MDIR)/ax88179_178a.ko
+endif
+	make -C $(KDIR) M=$(PWD) INSTALL_MOD_DIR=$(MDIR) modules_install
+	depmod -a
+
+uninstall:
+ifneq (,$(wildcard /lib/modules/$(shell uname -r)/$(MDIR)/$(TARGET).ko))
+	rm -f /lib/modules/$(shell uname -r)/$(MDIR)/$(TARGET).ko
+endif
+	depmod -a
+
+clean:
+	make -C $(KDIR) M=$(PWD) clean
+	rm -rf *_programmer *_ieee axcmd .tmp_versions
diff --git a/drivers/net/usb/asix_usb/Readme b/drivers/net/usb/asix_usb/Readme
new file mode 100755
index 000000000000..d3bda757b0da
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Readme
@@ -0,0 +1,255 @@
+===============================================================================
+ASIX USB3.0/2.0 Gigabit Ethernet Network Adapter
+Driver Compilation & Configuration on Linux
+===============================================================================
+
+================
+Prerequisites
+================
+
+Prepare to build the driver, you need the Linux kernel sources installed on the
+build machine, and make sure that the version of the running kernel must match
+the installed kernel sources. If you don't have the kernel sources, you can get
+it from www.kernel.org or contact to your Linux distributor. If you don't know 
+how to do, please refer to KERNEL-HOWTO.
+
+Note: Please make sure the kernel is built with one of the "Support for 
+      Host-side, XHCI, EHCI, OHCI, or UHCI" option support.
+
+================
+Getting Start
+================
+
+1. Extract the compressed driver source file to your temporary directory by the
+following command:
+	$tar -xf DRIVER_SOURCE_PACKAGE.tar.bz2
+
+
+2. Now, the driver source files should be extracted under the current directory.
+Issue the following command to compile the driver:
+	$make
+
+
+3. If the compilation is done, the ax_usb_nic.ko will be created under the
+current directory.
+
+================
+Usage
+================
+
+=== Install driver to your system
+1. If you want to use modprobe command to mount the driver, issue the
+following command to install the driver into your system:
+	$sudo make install
+Note: This command will backup the built-in ax88179_178a driver if it exists.
+
+2. If you want to load the driver by modprobe command, issue the following 
+commands:
+	$sudo modprobe ax_usb_nic
+
+3. If you want to unload the driver by modprobe command, issue the following 
+commands:
+	$sudo modprobe -r ax_usb_nic
+
+4. If you want to check the information of driver, issue the following commands:
+	$modinfo ax_usb_nic 
+
+=== Install driver manually
+1. If you want to load the driver manually, go to the driver directory and
+execute the following commands:
+	$sudo modprobe mii
+	$sudo insmod ax_usb_nic.ko
+
+2. If you want to unload the driver, just executing the following command:
+	$sudo rmmod ax_usb_nic
+
+3. If you want to check the information of driver, issue the following commands:
+	$modinfo ax_usb_nic.ko
+
+
+================
+Programmer & IEEE TEST
+================
+ASIX USB Ethernet Linux Command Line Programming Tool
+
+[Note]: Enable DEBUG message
+* Modify ENABLE_IOCTL_DEBUG to y in Makefile.
+	ENABLE_IOCTL_DEBUG = n
+	->
+	ENABLE_IOCTL_DEBUG = y
+
+1. Extract the compressed driver source file to your temporary directory by the
+following command:
+	$tar -xf DRIVER_SOURCE_PACKAGE.tar.bz2
+
+2. Now, the driver source files should be extracted under the current directory.
+Executing the following command to compile the driver:
+	$make
+
+3. Load the driver manually, go to the driver directory and execute the 
+following commands:
+	$sudo modprobe mii
+	$sudo insmod ax_usb_nic.ko
+
+4. If the compilation is well, the ioctl will be created under the current 
+directory.
+
+Note: The default way to find the interface is to scan the ASIX device using
+ the ethx (x: 0~255).It is defined in the file, command.h.
+	(As follows)
+	...
+	// DEFAULT_SCAN   : scan "eth0" - "eth255"
+	// INTERFACE_SCAN : scan all available network interfaces
+	#define NET_INTERFACE	DEFAULT_SCAN
+	#define	DEFAULT_SCAN	0x00
+	#define	INTERFACE_SCAN	0x01
+	...
+Adjust the contents of #define NET_INTERFACE to select the method you want.
+
+================
+Enable PTP(Precision Time Protocol)
+================
+1. If you want to enable the PTP function, please modify ENABLE_PTP_FUNC to 'y' in the makefile, 
+	and then recompile it.
+	
+	ENABLE_PTP_FUNC = n
+	->
+	ENABLE_PTP_FUNC = y
+
+=== AX88179/178A EEPROM/eFuse Programmer
+1. If you want to read out values of the EEPROM/EFUSE to a file, go to the 
+driver directory and execute the following command:
+	$sudo ./ax88179_programmer reeprom 0 eeprom 512
+	$sudo ./ax88179_programmer reeprom 1 efuse 64
+
+2. If you want to write values of a file to the EEPROM/EFUSE,  go to the driver
+directory and execute the following command:
+	$sudo ./ax88179_programmer weeprom 0 eeprom 512
+	$sudo ./ax88179_programmer weeprom 1 efuse 64
+
+3. If you want to change the MAC address of a dongle, go to the driver directory
+ and execute the following command:
+	$sudo ./ax88179_programmer chgmac 0 mac_addr 512
+	$sudo ./ax88179_programmer chgmac 1 mac_addr 64
+
+4. If you need more information about the instructions, go to the driver 
+directory and execute the following commands:
+	$sudo ./ax88179_programmer reeprom help
+	$sudo ./ax88179_programmer weeprom help
+	$sudo ./ax88179_programmer chgmac help
+
+=== AX88179B/179A/772E/772D Flash/eFuse Programmer
+1. If you want to get help message for specific command, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer help [command]
+
+2. If you want to get the version of firmware, go to the driver directory 
+and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer rversion
+
+3. If you want to get the MAC address, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer rmacaddr
+
+4. If you want to write values of a file to the flash, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer wflash [file]
+
+5. If you want to write the eFuse, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m [MAC] -s [SN] -f [File]
+	--led0 [value] --led1 [value] -p [device]
+		-m [MAC]    - MAC address (XX:XX:XX:XX:XX:XX)
+		-s [SN]     - Serial number
+		-f [File]   - eFuse file path
+		--led0 [value]   - value: control_blink (XXXX_XXXX)
+		--led1 [value]   - value: control_blink (XXXX_XXXX)
+		-p [device] - device: "AX88179B" or "AX88179A" or "AX88772E" or "AX88772D" 
+	example: 
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:81:79:01 
+		-s 00000000000001 -f eFuse_Dump.txt
+
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:81:79:01 
+		-s 0000000000179A --led0 8007_0000 --led1 8000_003F -p AX88179A
+
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:87:72:D1
+		-s 0000000000772D -p AX88772D
+
+6. If you want to read the eFuse, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer refuse -f [File]
+
+7. If you want to reload the flash or eFuse to check version or MAC address 
+and so, go to the driver directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer reload
+
+=== AX88179B/179A/772E/772D IEEE Test Tool
+1. If you want to execute IEEE test, go to the driver directory and execute the following command:
+
+	$sudo ./ax88179b_179a_772e_772d_ieee ieeetest speed option
+	    -- AX88179B_179A_772E_772D IEEE Test Tool
+		[speed]    - 1000: 1000Mbps,  100: 100Mbps,  10: 10Mbps
+		[option]   - For 1000Mbps
+				M1: Mode 1
+				M2: Mode 2
+				M3: Mode 3
+				M4: Mode 4
+
+			   - For 100Mbps
+				CA: Channel A
+				CB: Channel B
+
+			   - For 10Mbps
+				RP: Random Pattern
+				FF: Fixed Pattern(FF)
+				MDI: MDI
+
+=== AX88279 Linux Flash Programming Tool
+1. If you want to get help message for specific command, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88279_programmer help [command]
+
+2. If you want to get the version of firmware, go to the driver directory 
+and execute the following command:
+	$sudo ./ax88279_programmer rversion
+
+3. If you want to get the MAC address, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88279_programmer rmacaddr
+
+4. If you want to write values of a file to the flash, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88279_programmer wflash [file]
+
+5. If you want to write the parameter in flash, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88279_programmer wpara -m [MAC] -s [SN] -p [PID] -v [VID] -P [PS] -M [MN] -D [dump]
+	-S [SS] -H [HS] -w [wol] -l [led0 value] -e [led1 value] -d [led2 value]
+       -m [MAC]   	 - MAC address (XX:XX:XX:XX:XX:XX) X:'0'-'F'
+       -s [SN]    	 - Serial Number (Characters must be less than 19 bytes) X:'0'-'F'
+       -p [PID]   	 - Product ID (XX:XX) X:'0'-'F'
+       -v [VID]   	 - Vendor ID (XX:XX) X:'0'-'F'
+       -P [PS]    	 - Product String (Characters must be less than 19 bytes)
+       -M [MN]    	 - Manufacture Name (Characters must be less than 19 bytes)
+       -D [dump]	 - The parameter content currently in flash (dump)
+       -S [SS]    	 - SS bus power (XX) X:0-896
+       -H [HS]    	 - HS bus power (XX) X:0-500
+       -w [wol]    	 - wake on LAN (XXXXXXXX) X:digit
+       -l [led0 value]	 - value: control_blink (XXXX_XXXX)
+       -e [led1 value]	 - value: control_blink (XXXX_XXXX)
+	example: 
+		$sudo ./ax88279_programmer wpara -m 00:0e:c6:81:79:01 -s 00000000000001
+
+		$sudo ./ax88279_programmer wpara -p 17:90 -v 0b:95 -P ax88279 -M asix
+
+		$sudo ./ax88279_programmer wpara -S 400 -H 200 -w 21426543
+
+		$sudo ./ax88279_programmer wpara -l C113_0004 -e C002_0C4F
+
+6. If you want to view the current parameter content in flash, go to the driver directory and execute 
+the following command, and you can see the file parameter.txt in driver directory:
+	$sudo ./ax88279_programmer wpara -D dump
+
+7. If you want to reload the flash to check version or MAC address 
+and so, go to the driver directory and execute the following command:
+	$sudo ./ax88279_programmer reload
\ No newline at end of file
diff --git a/drivers/net/usb/asix_usb/ax88179_178a.c b/drivers/net/usb/asix_usb/ax88179_178a.c
new file mode 100755
index 000000000000..fb5485184756
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_178a.c
@@ -0,0 +1,1238 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179_178a.h"
+
+struct _ax_buikin_setting AX88179_BULKIN_SIZE[] = {
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x20, 3,	0x16, 0xff},
+	{7, 0xae, 7,	0x18, 0xff},
+};
+const struct ethtool_ops ax88179_ethtool_ops = {
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+	.get_ts_info	= ethtool_op_get_ts_info,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+};
+
+int ax88179_signature(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	strncpy(info->sig, AX88179_SIGNATURE, strlen(AX88179_SIGNATURE));
+	return 0;
+}
+
+int ax88179_read_eeprom(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	u8 i;
+	u16 tmp;
+	u8 value;
+	unsigned short *buf;
+
+	if (info->buf != NULL) {
+		buf = kmalloc_array(info->size, sizeof(unsigned short),
+				    GFP_KERNEL);
+		if (!buf) {
+#if KERNEL_VERSION(2, 6, 34) <= LINUX_VERSION_CODE
+			netdev_err(axdev->netdev,
+				   "Cannot allocate memory for buffer");
+#endif
+			return -ENOMEM;
+		}
+	} else {
+		netdev_info(axdev->netdev,
+			    "The EEPROM buffer cannot be NULL. \r\n");
+		return -EINVAL;
+	}
+
+	if (info->type == 0) {
+		for (i = 0; i < info->size; i++) {
+
+			if (ax_write_cmd(axdev, AX_ACCESS_MAC,
+					      AX_SROM_ADDR, 1, 1, &i) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			value = EEP_RD;
+			if (ax_write_cmd(axdev, AX_ACCESS_MAC,
+					      AX_SROM_CMD, 1, 1, &value) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			do {
+				ax_read_cmd(axdev, AX_ACCESS_MAC,
+						 AX_SROM_CMD, 1, 1, &value, 0);
+			} while (value & EEP_BUSY);
+
+			if (ax_read_cmd(axdev, AX_ACCESS_MAC,
+					     AX_SROM_DATA_LOW, 2, 2,
+					     &tmp, 1) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			*(buf + i) = be16_to_cpu(tmp);
+
+			if (i == (info->size - 1))
+				break;
+		}
+	} else {
+		for (i = 0; i < info->size; i++) {
+			if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, i,
+					     1, 2, &tmp, 1) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+			*(buf + i) = be16_to_cpu(tmp);
+			if (i == (info->size - 1))
+				break;
+		}
+	}
+
+	if (copy_to_user(info->buf, buf, sizeof(unsigned short) * info->size)) {
+		kfree(buf);
+		return -EFAULT;
+	}
+
+	kfree(buf);
+
+	return 0;
+}
+
+int ax88179_write_eeprom(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int i;
+	u16 data, csum = 0;
+	unsigned short *buf;
+
+	if (info->buf != NULL) {
+		buf = kmalloc_array(info->size, sizeof(unsigned short),
+				    GFP_KERNEL);
+		if (!buf) {
+#if KERNEL_VERSION(2, 6, 34) <= LINUX_VERSION_CODE
+			netdev_err(axdev->netdev,
+				   "Cannot allocate memory for buffer");
+#endif
+			return -ENOMEM;
+		}
+		if (copy_from_user(buf, info->buf,
+				   sizeof(unsigned short) * info->size)) {
+			kfree(buf);
+			return -EFAULT;
+		}
+	} else {
+		netdev_err(axdev->netdev,
+			   "The EEPROM buffer cannot be NULL. \r\n");
+		return -EINVAL;
+	}
+
+	if (info->type == 0) {
+		if ((*(buf) >> 8) & 0x01) {
+			netdev_info(axdev->netdev,
+				"Cannot be set to muliticast MAC address, ");
+			netdev_info(axdev->netdev,
+				"bit0 of Node ID-0 cannot be set to 1. \r\n");
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		csum = (*(buf + 3) & 0xff) + ((*(buf + 3) >> 8) & 0xff) +
+		       (*(buf + 4) & 0xff) + ((*(buf + 4) >> 8) & 0xff);
+		csum = 0xff - ((csum >> 8) + (csum & 0xff));
+		data = ((*(buf + 5)) & 0xff) | (csum << 8);
+		*(buf + 5) = data;
+
+		for (i = 0; i < info->size; i++) {
+			data = cpu_to_be16(*(buf + i));
+			if (ax_write_cmd(axdev, AX_ACCESS_EEPROM,
+					      i, 1, 2, &data) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			mdelay(info->delay);
+		}
+	} else if (info->type == 1) {
+		if ((*(buf) >> 8) & 0x01) {
+			netdev_info(axdev->netdev,
+				"Cannot be set to muliticast MAC address, ");
+			netdev_info(axdev->netdev,
+				"bit0 of Node ID-0 cannot be set to 1. \r\n");
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < info->size; i++)
+			csum += (*(buf + i)&0xff) + ((*(buf + i) >> 8)&0xff);
+
+		csum -= ((*(buf + 0x19) >> 8) & 0xff);
+		while (csum > 255)
+			csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
+		csum = 0xFF - csum;
+
+		data = ((*(buf + 0x19)) & 0xff) | (csum << 8);
+		*(buf + 0x19) = data;
+
+		if (ax_write_cmd(axdev, AX_WRITE_EFUSE_EN,
+				      0, 0, 0, NULL) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		mdelay(info->delay);
+
+		for (i = 0; i < info->size; i++) {
+			data = cpu_to_be16(*(buf + i));
+			if (ax_write_cmd(axdev, AX_ACCESS_EFUSE,
+					      i, 1, 2, &data) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			mdelay(info->delay);
+		}
+
+		if (ax_write_cmd(axdev, AX_WRITE_EFUSE_DIS,
+				 0, 0, 0, NULL) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		mdelay(info->delay);
+	} else if (info->type == 2) {
+		if (ax_read_cmd(axdev, AX_ACCESS_EFUSE,
+				0, 1, 2, &data, 1) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		if (data == 0xFFFF)
+			info->type = 0;
+		else
+			info->type = 1;
+	} else {
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	kfree(buf);
+	return 0;
+}
+
+IOCTRL_TABLE ax88179_tbl[] = {
+	ax88179_signature,
+	NULL,//ax_usb_command,
+	ax88179_read_eeprom,
+	ax88179_write_eeprom,
+};
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			   void __user *udata, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	struct _ax_ioctl_command *uptr =
+				(struct _ax_ioctl_command *) rq->ifr_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		if ((*ax88179_tbl[info.ioctl_cmd])(axdev, &info) < 0) {
+			netdev_info(netdev, "ax88179_tbl, return -EFAULT");
+			return -EFAULT;
+		}
+
+		if (copy_to_user(uptr, &info, sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+int ax88179_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+}
+#else
+int ax88179_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	struct _ax_ioctl_command *uptr =
+				(struct _ax_ioctl_command *) rq->ifr_data;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		if ((*ax88179_tbl[info.ioctl_cmd])(axdev, &info) < 0) {
+			netdev_info(netdev, "ax88179_tbl, return -EFAULT");
+			return -EFAULT;
+		}
+
+		if (copy_to_user(uptr, &info, sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		break;
+	default:
+		return  generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+	}
+	return 0;
+}
+#endif
+
+void ax88179_set_multicast(struct net_device *net)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u8 *m_filter = axdev->m_filter;
+	int mc_count = 0;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	axdev->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB);
+
+	if (net->flags & IFF_PROMISC) {
+		axdev->rxctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		axdev->rxctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+	} else {
+		u32 crc_bits;
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i = 0;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits = ether_crc(ETH_ALEN,
+					     mc_list->dmi_addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax_write_cmd_async(axdev, AX_ACCESS_MAC,
+					AX_MULTI_FILTER_ARRY,
+					AX_MCAST_FILTER_SIZE,
+					AX_MCAST_FILTER_SIZE, m_filter);
+
+		axdev->rxctl |= AX_RX_CTL_AM;
+	}
+
+	ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+}
+
+int ax88179_set_mac_addr(struct net_device *netdev, void *p)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct sockaddr *addr = p;
+	int ret;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	if (netif_running(netdev))
+		return -EBUSY;
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE
+	eth_hw_addr_set(netdev, addr->sa_data);
+#else
+	memcpy(netdev->dev_addr, addr->sa_data, ETH_ALEN);	
+#endif
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			   ETH_ALEN, addr->sa_data);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+
+}
+
+static int ax88179_check_eeprom(struct ax_device *axdev)
+{
+	u8 i = 0;
+	u8 buf[2];
+	u8 eeprom[20];
+	u16 csum = 0, delay = HZ / 10;
+
+	for (i = 0 ; i < 6; i++) {
+		buf[0] = i;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
+				      1, 1, buf) < 0)
+			return -EINVAL;
+
+		buf[0] = EEP_RD;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+				      1, 1, buf) < 0)
+			return -EINVAL;
+
+		do {
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, buf, 0);
+
+			if (time_after(jiffies, (jiffies + delay)))
+				return -EINVAL;
+		} while (buf[0] & EEP_BUSY);
+
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 2, 2, &eeprom[i * 2], 0);
+
+		if ((i == 0) && (eeprom[0] == 0xFF))
+			return -EINVAL;
+	}
+
+	csum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];
+	csum = (csum >> 8) + (csum & 0xff);
+
+	if ((csum + eeprom[10]) == 0xff)
+		return 0;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ax88179_check_efuse(struct ax_device *axdev, void *ledmode)
+{
+	u8	i = 0;
+	u16	csum = 0;
+	u8	efuse[64];
+
+	if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, 0, 64, 64, efuse, 0) < 0)
+		return -EINVAL;
+
+	if (efuse[0] == 0xFF)
+		return -EINVAL;
+
+	for (i = 0; i < 64; i++)
+		csum = csum + efuse[i];
+
+	while (csum > 255)
+		csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
+
+	if (csum == 0xFF) {
+		memcpy((u8 *)ledmode, &efuse[51], 2);
+		return 0;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ax88179_convert_old_led(struct ax_device *axdev, u8 efuse, void *ledvalue)
+{
+	u8 ledmode = 0;
+	u16 reg16;
+	u16 led = 0;
+
+	/* loaded the old eFuse LED Mode */
+	if (efuse) {
+		if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, 0x18,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8)(reg16 & 0xFF);
+	} else { /* loaded the old EEprom LED Mode */
+		if (ax_read_cmd(axdev, AX_ACCESS_EEPROM, 0x3C,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8) (reg16 >> 8);
+	}
+	netdev_dbg(axdev->netdev, "Old LED Mode = %02X\n", ledmode);
+
+	switch (ledmode) {
+	case 0xFF:
+		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
+		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
+		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
+		break;
+	case 0xFE:
+		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 | LED_VALID;
+		break;
+	case 0xFD:
+		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 |
+		      LED2_LINK_10 | LED_VALID;
+		break;
+	case 0xFC:
+		led = LED0_ACTIVE | LED1_ACTIVE | LED1_LINK_1000 | LED2_ACTIVE |
+		      LED2_LINK_100 | LED2_LINK_10 | LED_VALID;
+		break;
+	default:
+		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
+		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
+		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
+		break;
+	}
+
+	memcpy((u8 *)ledvalue, &led, 2);
+
+	return 0;
+}
+
+static void ax88179_Gether_setting(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = 0x03;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  31, 2, &reg16);
+	reg16 = 0x3246;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  25, 2, &reg16);
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  31, 2, &reg16);
+}
+
+static int ax88179_LED_setting(struct ax_device *axdev)
+{
+	u16 ledvalue = 0, delay = HZ / 10;
+	u16 ledact, ledlink;
+	u16 reg16;
+	u8 value;
+
+	ax_read_cmd(axdev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value, 0);
+
+	if (!(value & AX_SECLD)) {
+		value = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |
+			AX_GPIO_CTRL_GPIO1EN;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_GPIO_CTRL,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+	}
+
+	if (!ax88179_check_eeprom(axdev)) {
+		value = 0x42;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+
+		value = EEP_RD;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+
+		do {
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
+
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
+
+			if (time_after(jiffies, (jiffies + delay)))
+				return -EINVAL;
+		} while (value & EEP_BUSY);
+
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,
+				 1, 1, &value, 0);
+		ledvalue = (value << 8);
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 1, 1, &value, 0);
+		ledvalue |= value;
+
+		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
+			ax88179_convert_old_led(axdev, 0, &ledvalue);
+
+	} else if (!ax88179_check_efuse(axdev, &ledvalue)) {
+		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
+			ax88179_convert_old_led(axdev, 0, &ledvalue);
+	} else {
+		ax88179_convert_old_led(axdev, 0, &ledvalue);
+	}
+
+	reg16 = GMII_PHY_PAGE_SELECT_EXT;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
+
+	reg16 = 0x2c;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHYPAGE, 2, &reg16);
+
+	ax_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_ACTIVE, 2, &ledact, 1);
+
+	ax_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_LINK, 2, &ledlink, 1);
+
+	ledact &= GMII_LED_ACTIVE_MASK;
+	ledlink &= GMII_LED_LINK_MASK;
+
+	if (ledvalue & LED0_ACTIVE)
+		ledact |= GMII_LED0_ACTIVE;
+	if (ledvalue & LED1_ACTIVE)
+		ledact |= GMII_LED1_ACTIVE;
+	if (ledvalue & LED2_ACTIVE)
+		ledact |= GMII_LED2_ACTIVE;
+
+	if (ledvalue & LED0_LINK_10)
+		ledlink |= GMII_LED0_LINK_10;
+	if (ledvalue & LED1_LINK_10)
+		ledlink |= GMII_LED1_LINK_10;
+	if (ledvalue & LED2_LINK_10)
+		ledlink |= GMII_LED2_LINK_10;
+
+	if (ledvalue & LED0_LINK_100)
+		ledlink |= GMII_LED0_LINK_100;
+	if (ledvalue & LED1_LINK_100)
+		ledlink |= GMII_LED1_LINK_100;
+	if (ledvalue & LED2_LINK_100)
+		ledlink |= GMII_LED2_LINK_100;
+
+	if (ledvalue & LED0_LINK_1000)
+		ledlink |= GMII_LED0_LINK_1000;
+	if (ledvalue & LED1_LINK_1000)
+		ledlink |= GMII_LED1_LINK_1000;
+	if (ledvalue & LED2_LINK_1000)
+		ledlink |= GMII_LED2_LINK_1000;
+
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_ACTIVE, 2, &ledact);
+
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_LINK, 2, &ledlink);
+
+	reg16 = GMII_PHY_PAGE_SELECT_PAGE0;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
+
+	/* LED full duplex setting */
+	reg16 = 0;
+	if (ledvalue & LED0_FD)
+		reg16 |= 0x01;
+	else if ((ledvalue & LED0_USB3_MASK) == 0)
+		reg16 |= 0x02;
+
+	if (ledvalue & LED1_FD)
+		reg16 |= 0x04;
+	else if ((ledvalue & LED1_USB3_MASK) == 0)
+		reg16 |= 0x08;
+
+	if (ledvalue & LED2_FD) /* LED2_FD */
+		reg16 |= 0x10;
+	else if ((ledvalue & LED2_USB3_MASK) == 0) /* LED2_USB3 */
+		reg16 |= 0x20;
+
+	ax_write_cmd(axdev, AX_ACCESS_MAC, 0x73, 1, 1, &reg16);
+
+	return 0;
+}
+
+static void ax88179_EEE_setting(struct ax_device *axdev)
+{
+	u16 reg16;
+	/* Disable */
+	reg16 = 0x07;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MACR, 2, &reg16);
+	reg16 = 0x3c;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MAADR, 2, &reg16);
+	reg16 = 0x4007;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MACR, 2, &reg16);
+	reg16 = 0x00;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MAADR, 2, &reg16);
+}
+
+static int ax88179_AutoDetach(struct ax_device *axdev, int in_pm)
+{
+	u16 reg16;
+	usb_read_function fnr;
+	usb_write_function fnw;
+
+	if (!in_pm) {
+		fnr = ax_read_cmd;
+		fnw = ax_write_cmd;
+	} else {
+		fnr = ax_read_cmd_nopm;
+		fnw = ax_write_cmd_nopm;
+	}
+
+	if (fnr(axdev, AX_ACCESS_EEPROM, 0x43, 1, 2, &reg16, 1) < 0)
+		return 0;
+
+	if ((reg16 == 0xFFFF) || (!(reg16 & 0x0100)))
+		return 0;
+
+	reg16 = 0;
+	fnr(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16, 0);
+	reg16 |= AX_CLK_SELECT_ULR;
+	fnw(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16);
+
+	fnr(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16, 1);
+	reg16 |= AX_PHYPWR_RSTCTL_AUTODETACH;
+	fnw(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_hw_init(struct ax_device *axdev)
+{
+	u32 reg32;
+	u16 reg16;
+	u8 reg8;
+	u8 buf[6] = {0};
+
+	reg32 = 0;
+	ax_write_cmd(axdev, 0x81, 0x310, 0, 4, &reg32);
+
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	reg16 = AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	reg8 = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+	msleep(100);
+
+	ax88179_AutoDetach(axdev, 0);
+
+	memcpy(buf, &AX88179_BULKIN_SIZE[0], 5);
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, buf);
+
+	reg8 = 0x34;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW,
+			  1, 1, &reg8);
+
+	reg8 = 0x52;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+			  1, 1, &reg8);
+
+	ax_write_cmd(axdev, 0x91, 0, 0, 0, NULL);
+
+	reg8 = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+
+	reg8 = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
+	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+
+	reg8 = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
+	       AX_MONITOR_MODE_RWLC | AX_MONITOR_MODE_RWMP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+
+	ax88179_LED_setting(axdev);
+
+	ax88179_EEE_setting(axdev);
+
+	ax88179_Gether_setting(axdev);
+
+	ax_set_tx_qlen(axdev);
+
+	mii_nway_restart(&axdev->mii);
+
+	return 0;
+
+}
+
+static int ax88179_bind(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	PRINT_VERSION(axdev, AX_DRIVER_STRING_179_178A);
+
+	netdev->features    |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST;
+	netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST;
+
+	netdev->max_mtu = (9 * 1024);
+	axdev->tx_casecade_size = TX_CASECADES_SIZE;
+	axdev->gso_max_size = AX_GSO_DEFAULT_SIZE;
+	axdev->mii.supports_gmii = 1;
+	axdev->mii.dev = netdev;
+	axdev->mii.mdio_read = ax_mdio_read;
+	axdev->mii.mdio_write = ax_mdio_write;
+	axdev->mii.phy_id_mask = 0xff;
+	axdev->mii.reg_num_mask = 0xff;
+	axdev->mii.phy_id = AX88179_PHY_ID;
+	axdev->mii.force_media = 0;
+	axdev->mii.advertising = ADVERTISE_10HALF | ADVERTISE_10FULL |
+				 ADVERTISE_100HALF | ADVERTISE_100FULL;
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_set_tso_max_size(netdev, axdev->gso_max_size);
+#else
+	netif_set_gso_max_size(netdev, axdev->gso_max_size);
+#endif
+
+	axdev->bin_setting.custom = 1;
+	axdev->tx_align_len = 4;
+
+	netdev->ethtool_ops = &ax88179_ethtool_ops;
+	axdev->netdev->netdev_ops = &ax88179_netdev_ops;
+
+	return 0;
+}
+
+static void ax88179_unbind(struct ax_device *axdev)
+{
+
+}
+
+static int ax88179_stop(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2, &reg16);
+
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16);
+
+	reg16 = AX_PHYPWR_RSTCTL_BZ;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	return 0;
+}
+
+static int ax88179_link_reset(struct ax_device *axdev)
+{
+	u8 reg8[5], link_sts;
+	u16 mode, reg16, delay;
+	u32 reg32;
+
+	mode = AX_MEDIUM_TXFLOW_CTRLEN | AX_MEDIUM_RXFLOW_CTRLEN;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			 1, 1, &link_sts, 0);
+	ax_read_cmd_nopm(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_PHY_PHYSR, 2, &reg16, 1);
+
+	if (!(reg16 & GMII_PHY_PHYSR_LINK)) {
+		return -1;
+	} else if (GMII_PHY_PHYSR_GIGA == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_GIGAMODE;
+		if (axdev->netdev->mtu > 1500)
+			mode |= AX_MEDIUM_JUMBO_EN;
+
+		if (link_sts & AX_USB_SS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[0], 5);
+		else if (link_sts & AX_USB_HS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[1], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else if (GMII_PHY_PHYSR_100 == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_PS;
+		if (link_sts & (AX_USB_SS | AX_USB_HS))
+			memcpy(reg8, &AX88179_BULKIN_SIZE[2], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else {
+		memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	}
+
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, reg8);
+
+	if (reg16 & GMII_PHY_PHYSR_FULL)
+		mode |= AX_MEDIUM_FULL_DUPLEX;
+
+	ax_read_cmd_nopm(axdev, 0x81, 0x8c, 0, 4, &reg32, 1);
+	delay = HZ / 2;
+	if (reg32 & 0x40000000) {
+		unsigned long jtimeout;
+		u16 temp16 = 0;
+
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &temp16);
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				  2, 2, &mode);
+
+		jtimeout = jiffies + delay;
+		while (time_before(jiffies, jtimeout)) {
+			ax_read_cmd_nopm(axdev, 0x81, 0x8c, 0, 4, &reg32, 1);
+
+			if (!(reg32 & 0x40000000))
+				break;
+
+			reg32 = 0x80000000;
+			ax_write_cmd(axdev, 0x81, 0x8c, 0, 4, &reg32);
+		}
+
+		temp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START |
+			 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &temp16);
+	}
+
+	axdev->rxctl |= AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+			  2, 2, &axdev->rxctl);
+
+	mode |= AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &mode);
+
+	return 0;
+}
+
+
+static int ax88179_tx_fixup(struct ax_device *axdev, struct tx_desc *desc)
+{
+	struct sk_buff_head skb_head, *tx_queue = &axdev->tx_queue[0];
+	struct net_device_stats *stats = &axdev->netdev->stats;
+	int remain, ret;
+	u8 *tx_data;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = desc->head;
+	desc->skb_num = 0;
+	desc->skb_len = 0;
+	remain = axdev->tx_casecade_size;
+
+	while (remain >= ETH_ZLEN + 8) {
+		struct sk_buff *skb;
+		u32 *tx_hdr1, *tx_hdr2;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		if ((skb->len + AX_TX_HEADER_LEN) > remain &&
+		    (skb_shinfo(skb)->gso_size == 0)) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		memset(tx_data, 0, AX_TX_HEADER_LEN);
+		tx_hdr1 = (u32 *)tx_data;
+		tx_hdr2 = tx_hdr1 + 1;
+		*tx_hdr1 = skb->len;
+		*tx_hdr2 = skb_shinfo(skb)->gso_size;
+		cpu_to_le32s(tx_hdr1);
+		cpu_to_le32s(tx_hdr2);
+		tx_data += 8;
+
+		if (skb_copy_bits(skb, 0, tx_data, skb->len) < 0) {
+			stats->tx_dropped++;
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		tx_data += skb->len;
+		desc->skb_len += skb->len;
+		desc->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+		dev_kfree_skb_any(skb);
+
+		tx_data = __tx_buf_align(tx_data, axdev->tx_align_len);
+		if (*tx_hdr2 > 0)
+			break;
+		remain = axdev->tx_casecade_size -
+			 (int)((void *)tx_data - desc->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(axdev->netdev);
+
+	if (netif_queue_stopped(axdev->netdev) &&
+	    skb_queue_len(tx_queue) < axdev->tx_qlen) {
+		netif_wake_queue(axdev->netdev);
+	}
+
+	netif_tx_unlock(axdev->netdev);
+
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(desc->urb, axdev->udev,
+			  usb_sndbulkpipe(axdev->udev, 3),
+			  desc->head, (int)(tx_data - (u8 *)desc->head),
+			  (usb_complete_t)ax_write_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(axdev->intf);
+
+out_tx_fill:
+	return ret;
+}
+
+static void ax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	if ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||
+	    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))
+		return;
+
+	if (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||
+	    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+}
+
+static void ax88179_rx_fixup(struct ax_device *axdev, struct rx_desc *desc,
+			     int *work_done, int budget)
+{
+	u8 *rx_data;
+	u32 const actual_length = desc->urb->actual_length;
+	u32 rx_hdr = 0, pkt_hdr = 0, pkt_hdr_curr = 0, hdr_off = 0;
+	u32 aa = 0;
+	int pkt_cnt = 0;
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+
+	memcpy(&rx_hdr, (((u8 *)desc->head) + actual_length - 4),
+	       sizeof(rx_hdr));
+	le32_to_cpus(&rx_hdr);
+
+	pkt_cnt = rx_hdr & 0xFF;
+	pkt_hdr_curr = hdr_off = rx_hdr >> 16;
+
+	aa = (actual_length - (((pkt_cnt + 2) & 0xFE) * 4));
+	if ((aa != hdr_off) ||
+	    (hdr_off >= desc->urb->actual_length) ||
+	    (pkt_cnt == 0)) {
+		desc->urb->actual_length = 0;
+		stats->rx_length_errors++;
+		return;
+	}
+
+	rx_data = desc->head;
+	while (pkt_cnt--) {
+		u32 pkt_len;
+		struct sk_buff *skb;
+
+		memcpy(&pkt_hdr, (((u8 *)desc->head) + pkt_hdr_curr),
+		       sizeof(pkt_hdr));
+		pkt_hdr_curr += 4;
+
+		le32_to_cpus(&pkt_hdr);
+		pkt_len = (pkt_hdr >> 16) & 0x1FFF;
+
+		if (pkt_hdr & AX_RXHDR_CRC_ERR) {
+			stats->rx_crc_errors++;
+			goto find_next_rx;
+		}
+		if (pkt_hdr & AX_RXHDR_DROP_ERR) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+#ifdef ENABLE_RX_TASKLET
+		skb = netdev_alloc_skb(netdev, pkt_len);
+#else
+		skb = napi_alloc_skb(&axdev->napi, pkt_len);
+#endif
+		if (!skb) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+		memcpy(skb->data, rx_data, pkt_len);
+		skb_put(skb, pkt_len);
+
+		ax88179_rx_checksum(skb, &pkt_hdr);
+
+		skb->protocol = eth_type_trans(skb, netdev);
+
+		if (*work_done < budget) {
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(&axdev->napi, skb);
+#endif
+			*work_done += 1;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		} else {
+			__skb_queue_tail(&axdev->rx_queue, skb);
+		}
+find_next_rx:
+		rx_data += (pkt_len + 7) & 0xFFF8;
+	}
+}
+
+static int ax88179_system_suspend(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			 2, 2, &reg16, 1);
+	reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &reg16);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+			 2, 2, &reg16, 1);
+	reg16 |= AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+			  2, 2, &reg16);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_system_resume(struct ax_device *axdev)
+{
+	u16 reg16;
+	u8 reg8;
+
+	reg16 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+#if KERNEL_VERSION(2, 6, 36) <= LINUX_VERSION_CODE
+	usleep_range(1000, 2000);
+#else
+	msleep(20);
+#endif
+	reg16 = AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	ax88179_AutoDetach(axdev, 1);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC,  AX_CLK_SELECT, 1, 1, &reg8, 0);
+	reg8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+	msleep(100);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AP |
+		AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_runtime_suspend(struct ax_device *axdev)
+{
+       u16 reg16;
+#if 0
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg16,
+                        1);
+       reg16 &= ~AX_MONITOR_MODE_RWLC;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg16);
+#endif
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                        &reg16, 1);
+       reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                         &reg16);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16,
+                        1);
+       reg16 |= AX_PHYPWR_RSTCTL_IPRL;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+       reg16 = AX_RX_CTL_STOP;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+       return 0;
+}
+
+static int ax88179_runtime_resume(struct ax_device *axdev)
+{
+       u16 reg16;
+       u8 reg8;
+       reg16 = 0;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+#if KERNEL_VERSION(2, 6, 36) <= LINUX_VERSION_CODE
+       usleep_range(1000, 2000);
+#else
+       msleep(20);
+#endif
+       reg16 = AX_PHYPWR_RSTCTL_IPRL;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+       msleep(200);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8, 0);
+       reg8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+       msleep(100);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                        &reg16, 1);
+       reg16 |= AX_MEDIUM_RECEIVE_EN;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                         &reg16);
+       reg16 = AX_RX_CTL_START | AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+       return 0;
+}
+
+const struct driver_info ax88179_info = {
+	.bind = ax88179_bind,
+	.unbind = ax88179_unbind,
+	.hw_init = ax88179_hw_init,
+	.stop = ax88179_stop,
+	.link_reset = ax88179_link_reset,
+	.rx_fixup = ax88179_rx_fixup,
+	.tx_fixup = ax88179_tx_fixup,
+	.system_suspend = ax88179_system_suspend,
+	.system_resume = ax88179_system_resume,
+	.runtime_suspend = ax88179_runtime_suspend,
+    .runtime_resume = ax88179_runtime_resume,
+	.napi_weight = AX88179_NAPI_WEIGHT,
+	.buf_rx_size = AX88179_BUF_RX_SIZE,
+};
diff --git a/drivers/net/usb/asix_usb/ax88179_178a.h b/drivers/net/usb/asix_usb/ax88179_178a.h
new file mode 100755
index 000000000000..ecbdf532fd2d
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_178a.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_AX88179_178A_H
+#define __ASIX_AX88179_178A_H
+
+#define AX88179_NAPI_WEIGHT		64
+#define AX88179_BUF_RX_SIZE		(48 * 1024)
+#define AX88179_PHY_ID			0x03
+
+extern const struct net_device_ops ax88179_netdev_ops;
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			   void __user *udata, int cmd);
+#endif
+int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd);
+
+int ax88179_set_mac_addr(struct net_device *net, void *p);
+void ax88179_set_multicast(struct net_device *net);
+
+extern const struct driver_info ax88179_info;
+#endif
diff --git a/drivers/net/usb/asix_usb/ax88179_programmer.c b/drivers/net/usb/asix_usb/ax88179_programmer.c
new file mode 100755
index 000000000000..4990918ef64b
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_programmer.c
@@ -0,0 +1,629 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define AX88179_IOCTL_VERSION \
+"AX88179/AX88178A Linux EEPROM/eFuse Programming Tool v1.5.0"
+
+const char help_str1[] =
+"./ax88179_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readeeprom_str1[] =
+"./ax88179_programmer reeprom [type] [file] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse read tool\n";
+const char readeeprom_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [file]    - Output file\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM maximum 512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+const char writeeeprom_str1[] =
+"./ax88179_programmer weeeprom [type] [file] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse write tool\n";
+const char writeeeprom_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [file]    - Input file\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM size 12-512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+const char chgmac_str1[] =
+"./ax88179_programmer chgmac [type] [mac_addr] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse write tool (specify MAC address)\n";
+const char chgmac_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [mac_addr]- MAC address (xx:xx:xx:xx:xx:xx)\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM size 12-512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+static int help_func(struct ax_command_info *info);
+static int readeeprom_func(struct ax_command_info *info);
+static int writeeeprom_func(struct ax_command_info *info);
+static int chgmac_func(struct ax_command_info *info);
+struct _command_list ax88179_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"reeprom",
+		AX88179_READ_EEPROM,
+		readeeprom_func,
+		readeeprom_str1,
+		readeeprom_str2
+	},
+	{
+		"weeprom",
+		AX88179_WRITE_EEPROM,
+		writeeeprom_func,
+		writeeeprom_str1,
+		writeeeprom_str2
+	},
+	{
+		"chgmac",
+		AX88179_WRITE_EEPROM,
+		chgmac_func,
+		chgmac_str1,
+		chgmac_str2
+	},
+	{NULL},
+};
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+			       ax88179_cmd_list[i].help_desc);
+		}
+	}
+
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+			    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+			       ax88179_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int compare_file(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned short *rout_buf;
+	unsigned short *ori_buf;
+	struct _ax_ioctl_command *ioctl_cmd =
+				(struct _ax_ioctl_command *)(ifr->ifr_data);
+	int i;
+
+	rout_buf = malloc(sizeof(unsigned short) * ioctl_cmd->size);
+
+	ori_buf = ioctl_cmd->buf;
+
+	ioctl_cmd->ioctl_cmd = AX88179_READ_EEPROM;
+	ioctl_cmd->buf = rout_buf;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		return -1;
+	}
+
+	for (i = 0; i < ioctl_cmd->size; i++) {
+		if (*(ioctl_cmd->buf + i) != *(ori_buf + i)) {
+			ioctl_cmd->buf = ori_buf;
+			free(rout_buf);
+			return -1;
+		}
+	}
+
+	ioctl_cmd->buf = ori_buf;
+	free(rout_buf);
+	return 0;
+}
+
+static int readeeprom_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	unsigned short *buf;
+	unsigned short wLen;
+	char str_buf[50];
+	unsigned char type;
+	FILE *pFile;
+	int i;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	pFile = fopen(info->argv[3], "w");
+	if (pFile == NULL) {
+		printf("fail to open %s file\n", info->argv[3]);
+		return -FAIL_LOAD_FILE;
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.type = type;
+	ioctl_cmd.delay = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		free(buf);
+		fclose(pFile);
+		return -FAIL_IOCTL;
+	}
+
+	for (i = 0; i < wLen / 8; i++) {
+		int j = 8 * i;
+
+		snprintf(str_buf, 50,
+			 "%04x %04x %04x %04x %04x %04x %04x %04x\n",
+			 *(buf + j + 0), *(buf + j + 1),
+			 *(buf + j + 2), *(buf + j + 3),
+			 *(buf + j + 4), *(buf + j + 5),
+			 *(buf + j + 6), *(buf + j + 7));
+
+		fputs(str_buf, pFile);
+	}
+
+	free(buf);
+	fclose(pFile);
+	printf("read completely\n");
+
+	return SUCCESS;
+}
+
+static int writeeeprom_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int i;
+	unsigned short *buf;
+	unsigned short wLen;
+	char c[2] = {'\0'};
+	FILE *pFile;
+	unsigned char retried = 0;
+	unsigned char type;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 0) && (wLen < 6)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	pFile = fopen(info->argv[3], "r");
+	if (pFile == NULL) {
+		printf("fail to open %s file\n", info->argv[3]);
+		return -FAIL_LOAD_FILE;
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	for (i = 0; i < wLen / 8; i++) {
+		int j = 8 * i;
+
+		fscanf(pFile, "%04X %04X %04X %04X %04X %04X %04X %04X%c",
+				(unsigned int *)&buf[j + 0],
+				(unsigned int *)&buf[j + 1],
+				(unsigned int *)&buf[j + 2],
+				(unsigned int *)&buf[j + 3],
+				(unsigned int *)&buf[j + 4],
+				(unsigned int *)&buf[j + 5],
+				(unsigned int *)&buf[j + 6],
+				(unsigned int *)&buf[j + 7], c);
+	}
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.delay = 5;
+
+	if (type) {
+		ioctl_cmd.type = 2;
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			free(buf);
+			fclose(pFile);
+			perror("ioctl");
+			return -FAIL_IOCTL;
+		}
+		if (ioctl_cmd.type) {
+			printf("EFuse has been programed.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	ioctl_cmd.type = type;
+io:
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		free(buf);
+		fclose(pFile);
+		perror("ioctl");
+		return -FAIL_IOCTL;
+	}
+	if (compare_file(info) && retried < 3) {
+		ioctl_cmd.delay += 5;
+		ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+		retried++;
+		goto io;
+	}
+	if (retried == 3) {
+		printf("Failure to write\n");
+		free(buf);
+		fclose(pFile);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	printf("Write completely\n");
+	free(buf);
+	fclose(pFile);
+
+	return SUCCESS;
+}
+
+static int chgmac_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int i;
+	unsigned short *buf;
+	unsigned short wLen;
+	unsigned char retried = 0;
+	unsigned int MAC[6] = {0};
+	int ret = 0;
+	unsigned char type;
+	char c[2] = {'\0'};
+	FILE *pFile;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 0) && (wLen < 6)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	if (type) {
+		pFile = fopen("efuse", "r");
+		if (pFile == NULL) {
+			printf("fail to open 'efuse' file\n");
+			free(buf);
+			return -FAIL_LOAD_FILE;
+		}
+
+		for (i = 0; i < wLen / 8; i++) {
+			int j = 8 * i;
+
+			fscanf(pFile, "%04X %04X %04X %04X %04X %04X %04X %04X%c",
+					(unsigned int *)&buf[j + 0],
+					(unsigned int *)&buf[j + 1],
+					(unsigned int *)&buf[j + 2],
+					(unsigned int *)&buf[j + 3],
+					(unsigned int *)&buf[j + 4],
+					(unsigned int *)&buf[j + 5],
+					(unsigned int *)&buf[j + 6],
+					(unsigned int *)&buf[j + 7], c);
+		}
+	} else {
+		ioctl_cmd.ioctl_cmd = AX88179_READ_EEPROM;
+		ioctl_cmd.size = wLen;
+		ioctl_cmd.buf = buf;
+		ioctl_cmd.delay = 0;
+		ioctl_cmd.type = type;
+
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			perror("ioctl");
+			free(buf);
+			return -FAIL_IOCTL;
+		}
+	}
+
+	ret = sscanf(info->argv[3], "%02X:%02X:%02X:%02X:%02X:%02X",
+					(unsigned int *)&MAC[0],
+					(unsigned int *)&MAC[1],
+					(unsigned int *)&MAC[2],
+					(unsigned int *)&MAC[3],
+					(unsigned int *)&MAC[4],
+					(unsigned int *)&MAC[5]);
+	if (ret != 6) {
+		printf("Invalid MAC address\n");
+		return -FAIL_INVALID_PARAMETER;
+	}
+
+	*(((char *)buf) + 0) = (unsigned char)MAC[1];
+	*(((char *)buf) + 1) = (unsigned char)MAC[0];
+	*(((char *)buf) + 2) = (unsigned char)MAC[3];
+	*(((char *)buf) + 3) = (unsigned char)MAC[2];
+	*(((char *)buf) + 4) = (unsigned char)MAC[5];
+	*(((char *)buf) + 5) = (unsigned char)MAC[4];
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.delay = 5;
+	ioctl_cmd.type = type;
+
+	if (type) {
+		ioctl_cmd.type = 2;
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			free(buf);
+			perror("ioctl");
+			return -FAIL_IOCTL;
+		} else if (ioctl_cmd.type) {
+			printf("EFuse has been programed.\n");
+		}
+	}
+io:
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		free(buf);
+		return -FAIL_IOCTL;
+	}
+	if (compare_file(info) && retried < 3) {
+		ioctl_cmd.delay += 5;
+		ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+		retried++;
+		goto io;
+	}
+	if (retried == 3) {
+		printf("Failure to write\n");
+		free(buf);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	printf("Chgmac completely\n");
+	free(buf);
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	int inet_sock;
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned char i;
+	unsigned char count = 0;
+	const unsigned char length = sizeof(char);
+	struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+	struct ifaddrs *addrs, *tmp;
+	unsigned char	dev_exist;
+#endif
+
+	printf("\n%s\n", AX88179_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return 0;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#if NET_INTERFACE == INTERFACE_SCAN
+	getifaddrs(&addrs);
+	tmp = addrs;
+	dev_exist = 0;
+
+	while (tmp) {
+		memset(&ioctl_cmd, 0, sizeof(struct _ax_ioctl_command));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "%s", tmp->ifa_name);
+		tmp = tmp->ifa_next;
+
+		ioctl(inet_sock, SIOCGIFFLAGS, &ifr);
+		if (!(ifr.ifr_flags & IFF_UP))
+			continue;
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+	}
+
+	freeifaddrs(addrs);
+
+	if (dev_exist == 0) {
+		printf("No %s found\n", AX88179_SIGNATURE);
+		return 0;
+	}
+#else
+	for (i = 0; i < 255; i++) {
+
+		memset(&ioctl_cmd, 0, sizeof(struct _ax_ioctl_command));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "eth%d", i);
+
+		ioctl(inet_sock, SIOCGIFFLAGS, &ifr);
+		if (!(ifr.ifr_flags & IFF_UP))
+			continue;
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0)
+			break;
+	}
+
+	if (i == 255) {
+		printf("No %s found\n", AX88179_SIGNATURE);
+		return 0;
+	}
+#endif
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1], ax88179_cmd_list[i].cmd,
+			    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179_cmd_list[i].help_ins;
+			info.help_desc = ax88179_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179_cmd_list[i].ioctl_cmd;
+			(ax88179_cmd_list[i].OptFunc)(&info);
+			return 0;
+		}
+	}
+	printf("Wrong command\n");
+
+	return 0;
+}
diff --git a/drivers/net/usb/asix_usb/ax88179a_772d.c b/drivers/net/usb/asix_usb/ax88179a_772d.c
new file mode 100755
index 000000000000..064fc45b46a5
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_772d.c
@@ -0,0 +1,2627 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179a_772d.h"
+#ifdef ENABLE_PTP_FUNC
+#include "ax_ptp.h"
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+#include "ax_macsec.h"
+#endif
+
+struct _ax_buikin_setting AX88179A_BULKIN_SIZE[] = {
+	{5, 0x7B, 0x00,	0x18, 0x0F},	//1G, SS
+	{5, 0xC0, 0x02,	0x06, 0x0F},	//1G, HS
+	{7, 0xF0, 0x00,	0x0C, 0x0F},	//100M, Full, SS
+	{6, 0x00, 0x00,	0x06, 0x0F},	//100M, Half, SS
+	{5, 0xC0, 0x04,	0x06, 0x0F},	//100M, Full, HS
+	{7, 0xC0, 0x04,	0x06, 0x0F},	//100M, Half, HS
+	{7, 0x00, 0,	0x03, 0x3F},	//FS
+};
+#ifdef ENABLE_AX88279
+struct _ax_buikin_setting AX88279_BULKIN_SIZE[] = {
+	{5, 0x10, 0x01,	0x11, 0x0F},	//2.5G
+	{7, 0xB3, 0x01,	0x11, 0x0F},	//1G, SS
+	{7, 0xC0, 0x02,	0x06, 0x0F},	//1G, HS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Full, SS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Half, SS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Full, HS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Half, HS
+	{7, 0x00, 0,	0x03, 0x3F},	//FS
+};
+#endif
+
+static int ax88179a_set_phy_power(struct ax_device *axdev, bool on);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int ax88179a_chk_eee(struct ax_device *axdev)
+{
+	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
+
+	mii_ethtool_gset(&axdev->mii, &ecmd);
+
+	if (ecmd.speed == SPEED_1000) {
+		int eee_lp, eee_cap, eee_adv;
+		u32 lp, cap, adv;
+
+		eee_cap = ax_mmd_read(axdev->netdev,
+				      MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+		if (eee_cap < 0)
+			goto exit;
+		eee_cap &= ~MDIO_EEE_100TX;
+
+		cap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);
+		if (!cap)
+			goto exit;
+
+		eee_lp = ax_mmd_read(axdev->netdev,
+				     MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+		if (eee_lp < 0)
+			goto exit;
+
+		eee_adv = ax_mmd_read(axdev->netdev,
+				      MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+		if (eee_adv < 0)
+			goto exit;
+
+		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
+		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
+		if (!(lp & adv & SUPPORTED_1000baseT_Full))
+			goto exit;
+
+		axdev->eee_active = 1;
+		return true;
+	}
+exit:
+	axdev->eee_active = 0;
+	return false;
+}
+
+static int ax88179a_ethtool_get_eee(struct ax_device *axdev,
+				    struct ethtool_eee *data)
+{
+	int val;
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+	if (val < 0)
+		return val;
+	val &= ~MDIO_EEE_100TX;
+	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+	if (val < 0)
+		return val;
+	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+	if (val < 0)
+		return val;
+	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	return 0;
+}
+
+static int ax88179a_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	edata->eee_enabled = axdev->eee_enabled;
+	edata->eee_active = axdev->eee_active;
+
+	return ax88179a_ethtool_get_eee(axdev, edata);
+}
+
+static void ax88179a_eee_setting(struct ax_device *axdev, bool enable)
+{
+	ax_write_cmd(axdev, AX88179_GPHY_CTRL, AX_GPHY_EEE_CTRL,
+		     enable, 0, NULL);
+}
+
+static int ax88179a_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	if (edata->advertised & MDIO_EEE_100TX)
+		return -EOPNOTSUPP;
+
+	axdev->eee_enabled = edata->eee_enabled;
+	ax88179a_eee_setting(axdev, axdev->eee_enabled);
+	if (axdev->eee_enabled) {
+		axdev->eee_enabled = ax88179a_chk_eee(axdev);
+		if (!axdev->eee_enabled) {
+			ax88179a_eee_setting(axdev, false);
+			return -EOPNOTSUPP;
+		}
+	}
+
+	mii_nway_restart(&axdev->mii);
+
+	return 0;
+}
+#endif
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+static int ax88179a_get_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce,
+				 struct kernel_ethtool_coalesce *kernel_coal,
+				 struct netlink_ext_ack *extack)
+#else
+static int ax88179a_get_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	coalesce->rx_coalesce_usecs = axdev->coalesce;
+
+	return 0;
+}
+
+static u16 ax88179a_usec_to_bin_timer(struct ax_device *axdev)
+{
+	u16 speed_multiple;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_10:
+		speed_multiple = 100;
+		break;
+	case ETHER_LINK_100:
+		speed_multiple = 10;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		speed_multiple = 1;
+		break;
+	};
+
+	return (axdev->coalesce * US_TO_NS * speed_multiple) /
+		AX88179A_BIN_TIMER_UINT;
+}
+
+static u32 ax88179a_bin_timer_to_usec(struct ax_device *axdev, u16 timer)
+{
+	u16 speed_multiple;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_10:
+		speed_multiple = 100;
+		break;
+	case ETHER_LINK_100:
+		speed_multiple = 10;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		speed_multiple = 1;
+		break;
+	};
+
+	return (AX88179A_BIN_TIMER_UINT * timer) / (US_TO_NS * speed_multiple);
+}
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+static int ax88179a_set_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce,
+				 struct kernel_ethtool_coalesce *kernel_coal,
+				 struct netlink_ext_ack *extack)
+#else
+static int ax88179a_set_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 timer;
+	int ret = 0;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	axdev->coalesce = coalesce->rx_coalesce_usecs;
+
+	timer = ax88179a_usec_to_bin_timer(axdev);
+	if (timer > 0) {
+		timer &= 0x7FFF;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QTIMR_LOW,
+			     2, 2, &timer);
+	}
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+#ifdef ENABLE_PTP_FUNC
+static int ax88179a_set_wol_get_ts_info
+(struct net_device *dev, struct ethtool_ts_info *info)
+{
+	struct ax_device *axdev = (struct ax_device *)netdev_priv(dev);
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	info->so_timestamping =
+			SOF_TIMESTAMPING_TX_SOFTWARE |
+			SOF_TIMESTAMPING_RX_SOFTWARE |
+			SOF_TIMESTAMPING_SOFTWARE |
+			SOF_TIMESTAMPING_TX_HARDWARE |
+			SOF_TIMESTAMPING_RX_HARDWARE |
+			SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	info->phc_index = ptp_cfg->phc_index;
+
+	info->tx_types = BIT(HWTSTAMP_TX_OFF) |
+			 BIT(HWTSTAMP_TX_ON) |
+			 BIT(HWTSTAMP_TX_ONESTEP_SYNC) |
+			 BIT(HWTSTAMP_TX_ONESTEP_P2P);
+
+	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);
+
+	return 0;
+}
+#endif
+
+const struct ethtool_ops ax88179a_ethtool_ops = {
+#if KERNEL_VERSION(5, 7, 0) < LINUX_VERSION_CODE
+	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,
+#endif
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	.get_eee	= ax88179a_get_eee,
+	.set_eee	= ax88179a_set_eee,
+#endif
+	.get_coalesce	= ax88179a_get_coalesce,
+	.set_coalesce	= ax88179a_set_coalesce,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_pauseparam = ax_get_pauseparam,
+	.set_pauseparam = ax_set_pauseparam,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+#ifdef ENABLE_PTP_FUNC
+	.get_ts_info	= ax88179a_set_wol_get_ts_info,
+#else
+	.get_ts_info	= ethtool_op_get_ts_info,
+#endif
+};
+
+#ifdef ENABLE_AX88279
+const struct ethtool_ops ax88279_ethtool_ops = {
+#if KERNEL_VERSION(5, 7, 0) < LINUX_VERSION_CODE
+	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,
+#endif
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+	.get_coalesce	= ax88179a_get_coalesce,
+	.set_coalesce	= ax88179a_set_coalesce,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_pauseparam = ax_get_pauseparam,
+	.set_pauseparam = ax_set_pauseparam,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+#ifdef ENABLE_PTP_FUNC
+	.get_ts_info	= ax88179a_set_wol_get_ts_info,
+#else
+	.get_ts_info	= ethtool_op_get_ts_info,
+#endif
+};
+#endif
+
+void ax88179a_get_fw_version(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, (0xFD + i),
+				1, 1, &axdev->fw_version[i], 1) < 0) {
+			axdev->fw_version[i] = ~0;
+		}
+	}
+
+	if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, AX88179A_SW_REVERSION, 1, 1,
+			&axdev->fw_version[3], 0) < 0)
+		axdev->fw_version[3] = ~0;
+	else
+		axdev->fw_version[3] &= 0xF;
+}
+
+int ax88179a_signature(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	strncpy(info->sig, AX88179A_SIGNATURE, strlen(AX88179A_SIGNATURE));
+	return 0;
+}
+
+int ax88179a_read_version(struct ax_device *axdev,
+			  struct _ax_ioctl_command *info)
+{
+	unsigned char temp[16] = {0};
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	sprintf(temp, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+
+	memcpy(&info->version.version, temp, 16);
+
+	return 0;
+}
+
+int ax88179a_write_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int i, ret;
+	u8 *buf = NULL;
+	u8 *block;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(256, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	block = buf;
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		goto out;
+	}
+
+	for (i = info->flash.offset;
+	     i < (info->flash.length + info->flash.offset);
+	     i += 256) {
+		if (copy_from_user(block,
+				   (void __user *)&info->flash.buf[i], 256)) {
+			netdev_err(axdev->netdev,
+				   "copy_from_user offset: 0x%x failed", i);
+			ret = -EFAULT;
+			goto out;
+		}
+
+		ret = ax_write_cmd(axdev, AX88179A_FLASH_WRITE,
+					(u16)((i >> 16) & 0xFFFF),
+					(u16)(i & 0xFFFF), 256, block);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Flash write offset: 0x%x failed", i);
+			info->flash.status = -ERR_FALSH_WRITE;
+			goto out;
+		}
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+out:
+	kfree(buf);
+
+	return ret;
+}
+
+int ax88179a_read_flash(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	int i, ret = 0;
+	void *buf = NULL;
+	u8 *block;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(256, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	block = buf;
+
+	for (i = info->flash.offset;
+	     i < (info->flash.length + info->flash.offset);
+	     i += 256) {
+		ret = ax_read_cmd(axdev, AX88179A_FLASH_READ,
+				  (u16)((i >> 16) & 0xFFFF),
+				  (u16)(i & 0xFFFF), 256, block, 0);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Flash read offset: 0x%x failed", i);
+			info->flash.status = -ERR_FALSH_READ;
+			break;
+		}
+
+		if (copy_to_user((void __user *)&info->flash.buf[i],
+				 block, 256)) {
+			netdev_err(axdev->netdev,
+				   "copy_to_user offset: 0x%x failed", i);
+			ret = -EFAULT;
+			break;
+		}
+	}
+
+	kfree(buf);
+
+	return ret;
+}
+
+int ax88179a_program_efuse(struct ax_device *axdev,
+			   struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+	u16 offset = (u16)(info->flash.offset * 16);
+	u8 buf[20] = {0};
+
+	DEBUG_PRINTK("%s - Start offset: %d (0x%x)", __func__, offset, offset);
+
+	ret = copy_from_user(buf, (void __user *)info->flash.buf, 20);
+	if (ret) {
+		netdev_err(axdev->netdev,
+			   "copy_from_user efuse offset: 0x%x failed", offset);
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_EFUSE, offset, 0, 20, buf);
+	if (ret < 0) {
+		netdev_err(axdev->netdev,
+			   "eFuse write offset: 0x%x failed", offset);
+		info->flash.status = -ERR_EFUSE_WRITE;
+		return ret;
+	}
+
+	return ret;
+}
+
+int ax88179a_dump_efuse(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+	u16 offset = (u16)(info->flash.offset * 16);
+	u8 buf[20] = {0};
+
+	DEBUG_PRINTK("%s - Start offset: %d (0x%x)", __func__, offset, offset);
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_EFUSE, offset, 0, 20, buf, 0);
+	if (ret < 0) {
+		netdev_err(axdev->netdev,
+			   "eFuse read offset: 0x%x failed", offset);
+		info->flash.status = -ERR_EFUSE_READ;
+		return ret;
+	}
+
+	ret = copy_to_user((void __user *)info->flash.buf, buf, 20);
+	if (ret) {
+		netdev_err(axdev->netdev,
+			   "copy_to_user efuse offset: 0x%x failed", offset);
+		return ret;
+	}
+
+	return ret;
+}
+
+int ax88179a_boot_to_rom(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret;
+	u8 reg8;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 1);
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      AX88179A_BOOT_TO_ROM,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x5A5A, 0xA5A5, NULL, 0, 1);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Booting to rom failed");
+		info->flash.status = -ERR_BOOT_CODE;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_erase_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		return ret;
+	}
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      AX88179A_FLASH_EARSE_ALL,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0, 0, NULL, 0, 300000);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash erase all failed");
+		info->flash.status = -ERR_FALSH_ERASE_ALL;
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_erase_sector_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		return ret;
+	}
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      0x28,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      (info->flash.offset >> 16) & 0xFFFF, info->flash.offset & 0xFFFF, NULL, 0, 300000);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash erase sector failed");
+		info->flash.status = -ERR_FALSH_ERASE_ALL;
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_sw_reset(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	void *buf = NULL;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(sizeof(u32), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+/*
+	*((u32 *)buf) = 1;
+
+	usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0), 0x10,
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			0x18E8, 0x000F, buf, 4, 10);
+*/
+	*((u8 *)buf) = 0x41;
+
+	ax_write_cmd(axdev, 0x2A, 0xAA00, 0, 1, buf);
+
+	kfree(buf);
+
+	return 0;
+}
+
+#define _MDIO_WRITE(offset, value) \
+	ax_mdio_write(netdev, phy_id, offset, value)
+
+int ax88179a_ieee_test(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	struct net_device *netdev = axdev->netdev;
+	int phy_id = axdev->mii.phy_id;
+	int ret;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+	DEBUG_PRINTK("Stop: %d", info->ieee.stop);
+	DEBUG_PRINTK("Speed: %d", info->ieee.speed);
+	DEBUG_PRINTK("Type: %d", info->ieee.type);
+
+	if (info->ieee.speed == 1000 && axdev->chip_pin == CHIP_32PIN) {
+		netdev_err(axdev->netdev, "Invalid Chip pin");
+		info->ieee.status = -ERR_IEEE_INVALID_CHIP;
+		return -EINVAL;
+	}
+
+	if (info->ieee.stop) {
+		ret = ax88179a_set_phy_power(axdev, false);
+		if (ret < 0)
+			return ret;
+		msleep(500);
+
+		ret = ax88179a_set_phy_power(axdev, true);
+		if (ret < 0)
+			return ret;
+		msleep(500);
+
+		switch (info->ieee.speed) {
+		case 1000:
+		case 100:
+			break;
+		case 10:
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			break;
+		default:
+			return -EINVAL;
+		};
+	} else {
+		switch (info->ieee.type) {
+		case IEEE_1000M1:
+			_MDIO_WRITE(0x09, 0x2700);
+			break;
+		case IEEE_1000M2:
+			_MDIO_WRITE(0x09, 0x4700);
+			break;
+		case IEEE_1000M3:
+			_MDIO_WRITE(0x09, 0x6700);
+			break;
+		case IEEE_1000M4:
+			_MDIO_WRITE(0x09, 0x8700);
+			break;
+		case IEEE_100CA:
+			_MDIO_WRITE(0x00, 0x2100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			break;
+		case IEEE_100CB:
+			_MDIO_WRITE(0x00, 0x2100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5018);
+			break;
+		case IEEE_10R:
+			ret = ax88179a_set_phy_power(axdev, false);
+			if (ret < 0)
+				return ret;
+			msleep(100);
+
+			ret = ax88179a_set_phy_power(axdev, true);
+			if (ret < 0)
+				return ret;
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			_MDIO_WRITE(0x00, 0x0800);
+			_MDIO_WRITE(0x1F, 0x0001);
+			_MDIO_WRITE(0x1D, 0xF842);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A3, 0x2);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A4, 0x110e);
+			_MDIO_WRITE(0x1F, 0x0000);
+			_MDIO_WRITE(0x00, 0x0100);
+			break;
+		case IEEE_10FF:
+			ret = ax88179a_set_phy_power(axdev, false);
+			if (ret < 0)
+				return ret;
+			msleep(100);
+
+			ret = ax88179a_set_phy_power(axdev, true);
+			if (ret < 0)
+				return ret;
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			_MDIO_WRITE(0x00, 0x0800);
+			_MDIO_WRITE(0x1F, 0x0001);
+			_MDIO_WRITE(0x1D, 0xF840);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A3, 0x0000);
+			_MDIO_WRITE(0x1F, 0x0000);
+			_MDIO_WRITE(0x00, 0x0100);
+			break;
+		case IEEE_10MDI:
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			break;
+		default:
+			return -EINVAL;
+		};
+	}
+
+	return 0;
+}
+
+int ax88179a_autosuspend_en(struct ax_device *axdev,
+			    struct _ax_ioctl_command *info)
+{
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	if (axdev->autosuspend_is_supported) {
+		if (info->autosuspend.enable)
+			usb_enable_autosuspend(axdev->udev);
+		else
+			usb_disable_autosuspend(axdev->udev);
+	}
+
+	return 0;
+}
+
+IOCTRL_TABLE ax88179a_tbl[] = {
+	ax88179a_signature,
+	ax_usb_command,
+	ax88179a_read_version,
+	ax88179a_write_flash,
+	ax88179a_boot_to_rom,
+	ax88179a_erase_flash,
+	ax88179a_sw_reset,
+	ax88179a_read_flash,
+	ax88179a_program_efuse,
+	ax88179a_dump_efuse,
+	ax88179a_ieee_test,
+	ax88179a_autosuspend_en,
+	ax88179a_erase_sector_flash,
+};
+
+#ifdef ENABLE_PTP_FUNC
+static int ax88179a_hwtstamp_ioctl
+(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct hwtstamp_config config;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	if (config.flags)
+		return -EINVAL;
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
+}
+#endif
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179a_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			    void __user *udata, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	void __user *uptr = (void __user *) rq->ifr_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_from_user, return -EFAULT");
+			return -EFAULT;
+		}
+		DEBUG_PRINTK("ioctl_cmd: %d", info.ioctl_cmd);
+		ret = (*ax88179a_tbl[info.ioctl_cmd])(axdev, &info);
+		if (ret < 0)
+			netdev_err(netdev, "ax88179a_tbl, return %d", ret);
+
+		if (copy_to_user(uptr, &info,
+				 sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_to_user failed");
+			return ret;
+		}
+
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+int ax88179a_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	switch (cmd) {
+#ifdef ENABLE_PTP_FUNC
+	case SIOCSHWTSTAMP:
+		return ax88179a_hwtstamp_ioctl(netdev, rq, cmd);
+#endif
+	}
+	return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+}
+#else
+int ax88179a_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	void __user *uptr = (void __user *) rq->ifr_data;
+	int ret;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_from_user, return -EFAULT");
+			return -EFAULT;
+		}
+		DEBUG_PRINTK("ioctl_cmd: %d", info.ioctl_cmd);
+		ret = (*ax88179a_tbl[info.ioctl_cmd])(axdev, &info);
+		if (ret < 0) {
+			netdev_err(netdev, "ax88179a_tbl, return %d", ret);
+			return ret;
+		}
+
+		if (copy_to_user(uptr, &info,
+				 sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_to_user, return -EFAULT");
+			return -EFAULT;
+		}
+
+		break;
+#ifdef ENABLE_PTP_FUNC
+	case SIOCSHWTSTAMP:
+		return ax88179a_hwtstamp_ioctl(netdev, rq, cmd);
+#endif
+	default:
+		return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+	}
+	return 0;
+}
+#endif
+
+static int ax88179a_autodetach(struct ax_device *axdev)
+{
+	u16 value = ((axdev->autodetach) ? 1 : 0) | AX88179A_AUTODETACH_DELAY;
+
+	return ax_write_cmd(axdev, AX88179A_AUTODETACH, value, 0, 0, NULL);
+}
+
+static bool ax88179a_check_phy_power(struct ax_device *axdev)
+{
+	u8 reg8 = 0;
+	int ret = 0;
+
+	ret = ax_read_cmd_nopm(axdev, AX88179A_PHY_POWER, 0, 0, 1, &reg8, 1);
+	if (ret < 0)
+		return false;
+
+	return (reg8 & AX_PHY_POWER);
+}
+
+static int ax88179a_set_phy_power(struct ax_device *axdev, bool on)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = (on)?AX_PHY_POWER:0;
+	ret = ax_write_cmd_nopm(axdev, AX88179A_PHY_POWER, 0, 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+	msleep(250);
+#ifdef ENABLE_INT_AGGRESSIVE
+	if (on) {
+		u16 reg16;
+		printk("ENABLE_INT_AGGRESSIVE");
+		ax_write_cmd(axdev, 0x32, 0x3, 0, 0, &reg16);
+	}
+#endif
+	return 0;
+}
+
+static int ax88179a_bind(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	u16 wvalue = 0;
+	int ret;
+
+	ax88179a_get_fw_version(axdev);
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279)
+		PRINT_VERSION(axdev, AX_DRIVER_STRING_279);
+	else
+		PRINT_VERSION(axdev, AX_DRIVER_STRING_179A_772D);
+#else
+	PRINT_VERSION(axdev, AX_DRIVER_STRING_179A_772D);
+#endif
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	wvalue |= AX_USB_EP5_EN;
+#endif
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	wvalue |= AX_USB_EP4_EN;
+#endif
+#endif
+	ret = ax_write_cmd(axdev, AX_FW_MODE, AX_FW_MODE_179A, wvalue, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_RELOAD_FLASH_EFUSE, 0, 0, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	netdev->features    |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+					NETIF_F_HW_VLAN_CTAG_RX |
+					NETIF_F_HW_VLAN_CTAG_TX;
+#else
+					NETIF_F_HW_VLAN_RX |
+					NETIF_F_HW_VLAN_TX;
+#endif
+	netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+					NETIF_F_HW_VLAN_CTAG_RX |
+					NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_RXALL;
+#else
+					NETIF_F_HW_VLAN_RX |
+					NETIF_F_HW_VLAN_TX | NETIF_F_RXALL;
+#endif
+
+		netdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+				NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
+				NETIF_F_IPV6_CSUM;
+
+	netdev->max_mtu = (9 * 1024);
+	axdev->tx_casecade_size = TX_CASECADES_SIZE;
+	axdev->gso_max_size = AX_GSO_DEFAULT_SIZE;
+	axdev->mii.supports_gmii = true;
+	axdev->mii.dev = netdev;
+	axdev->mii.mdio_read = ax_mdio_read;
+	axdev->mii.mdio_write = ax_mdio_write;
+	axdev->mii.phy_id_mask = 0x3F;
+	axdev->mii.reg_num_mask = 0x1F;
+	axdev->mii.phy_id = AX88179A_PHY_ID;
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_set_tso_max_size(netdev, axdev->gso_max_size);
+#else
+	netif_set_gso_max_size(netdev, axdev->gso_max_size);
+#endif
+	axdev->bin_setting.custom = false;
+	axdev->tx_align_len = 8;
+	axdev->coalesce = 0;
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+		netdev->ethtool_ops = &ax88279_ethtool_ops;
+	} else {
+		netdev->ethtool_ops = &ax88179a_ethtool_ops;
+	}
+#else
+	netdev->ethtool_ops = &ax88179a_ethtool_ops;
+#endif
+	
+	axdev->netdev->netdev_ops = &ax88179a_netdev_ops;
+
+#ifdef ENABLE_PTP_FUNC
+	ret = ax_ptp_register(axdev);
+	if (ret < 0)
+		netdev_warn(netdev,
+			    "Failed to register PHC device. (%d)\n", ret);
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	ret = ax_macsec_register(axdev);
+	if (ret < 0)
+		netdev_warn(netdev,
+			    "Failed to register MACsec feature. (%d)\n", ret);
+#endif
+
+#ifdef ENABLE_AUTOSUSPEND
+	axdev->autosuspend_is_supported = true;
+	usb_enable_autosuspend(axdev->udev);
+#else
+	axdev->autosuspend_is_supported = false;
+	usb_disable_autosuspend(axdev->udev);
+#endif
+
+	return ret;
+}
+
+static void ax88179a_unbind(struct ax_device *axdev)
+{
+#ifdef ENABLE_PTP_FUNC
+	ax_ptp_unregister(axdev);
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	ax_macsec_unregister(axdev);
+#endif
+}
+
+static int ax88179a_stop(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2, &reg16);
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+
+	ax88179a_set_phy_power(axdev, false);
+
+	return 0;
+}
+
+void ax88179a_set_multicast(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 *m_filter = axdev->m_filter;
+	int mc_count = 0;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(netdev);
+#endif
+
+	axdev->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB);
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279)
+		axdev->rxctl |= AX_RX_CTL_DROPCRCERR;
+#endif
+
+	if (netdev->flags & IFF_PROMISC) {
+		axdev->rxctl |= AX_RX_CTL_PRO;
+	} else if (netdev->flags & IFF_ALLMULTI || mc_count > AX_MAX_MCAST) {
+		axdev->rxctl |= AX_RX_CTL_AMALL;
+	} else if (netdev_mc_empty(netdev)) {
+	} else {
+		u32 crc_bits;
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+		struct dev_mc_list *mc_list = netdev->mc_list;
+		int i = 0;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		for (i = 0; i < netdev->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, netdev) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |= 1 << (crc_bits & 7);
+		}
+#endif
+		ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_MULTI_FILTER_ARRY,
+				   AX_MCAST_FILTER_SIZE, AX_MCAST_FILTER_SIZE,
+				   m_filter);
+
+		axdev->rxctl |= AX_RX_CTL_AM;
+	}
+
+	ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+			   2, 2, &axdev->rxctl);
+}
+
+static int ax88179a_hw_init(struct ax_device *axdev)
+{
+	u16 reg16;
+	u8 reg8;
+	int ret;
+
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version != AX_VERSION_AX88279) {
+		u32 reg32 = 0;
+		ret = ax_read_cmd(axdev, AX88179A_PBUS_REG,0x18C8, 0, 4,
+				  &reg32, 1);
+		if (ret < 0)
+			return ret;
+		axdev->chip_pin = reg32 & 0x03;
+	}
+#endif
+	ret = ax88179a_set_phy_power(axdev, true);
+	if (ret < 0)
+		return ret;
+	msleep(250);
+
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+#ifdef ENABLE_AX88279_MINIP_2_5G
+		do {
+			int i;
+
+			ax_mmd_write(axdev->netdev, 0x07, 0, 0x2000);
+			for (i = 0; i < 1000; i++) {
+				reg16 = ax_mmd_read(axdev->netdev, 0x07, 0x10);
+				ax_mmd_write(axdev->netdev, 0x07, 0x10,
+						(reg16 | 0x0C00));
+				reg16 = ax_mmd_read(axdev->netdev, 0x07, 0x10);
+				if (reg16 & 0x0C00)
+					break;
+			}
+			ax_mmd_write(axdev->netdev, 0x07, 0xC400, 0x1453);
+			ax_mmd_write(axdev->netdev, 0x07, 0x20, 0x1);
+			ax_mmd_write(axdev->netdev, 0x07, 0, 0x3200);
+		} while (0);
+#else
+		reg16 = ax_mdio_read(axdev->netdev, axdev->mii.phy_id,
+				     MII_ADVERTISE);
+		reg16 &= ~(ADVERTISE_10FULL | ADVERTISE_10HALF);
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, MII_ADVERTISE,
+			      (reg16 | ADVERTISE_RESV));
+		reg16 = ax_mdio_read(axdev->netdev, axdev->mii.phy_id,
+				     MII_CTRL1000);
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, MII_CTRL1000,
+			      (reg16 | CTL1000_AS_MASTER));
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, 0,
+			      (BMCR_ANRESTART | BMCR_ANENABLE));
+#endif
+	}
+#endif
+	ret = ax88179a_autodetach(axdev);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
+	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_EFF_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BULK_OUT_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg16 = 0;
+	ret = ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0x04;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0x10;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)
+#else
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_FILTER)
+#endif		
+		reg8 |= AX_VLAN_CONTROL_VFE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)
+#else
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_RX)
+#endif		
+	reg8 |= AX_VLAN_CONTROL_VSO;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_VLAN_ID_CONTROL,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0xff;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_INT_MASK,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_RX_DMA_CTL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_TX_DMA_CTL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_ARC_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_SWP_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	reg8 = AX_TXHDR_CKSUM_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_TX_HDR_CKSUM,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AP | AX_RX_CTL_AMALL |
+		AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 1);
+	if (ret < 0)
+		return ret;
+	reg8 &= 0xE0;
+	reg8 |= AX_MONITOR_MODE_RWMP;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				 2, 2, &reg16, 2);
+	if (ret < 0)
+		return ret;
+
+	reg16 &= ~AX_MEDIUM_GIGAMODE;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg16 |= AX_MEDIUM_GIGAMODE;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_CDC_ECM_CTRL,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ax_set_tx_qlen(axdev);
+
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_start_get_ts(axdev);
+#endif
+#endif
+
+	return ret;
+}
+
+static int ax88179a_get_ether_link(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	struct ethtool_cmd cmd;
+
+	mii_ethtool_gset(&axdev->mii, &cmd);
+	switch (ethtool_cmd_speed(&cmd)) {
+	case SPEED_1000:
+		link_info->eth_speed = ETHER_LINK_1000;
+		break;
+	case SPEED_100:
+		link_info->eth_speed = ETHER_LINK_100;
+		break;
+	case SPEED_10:
+	default:
+		link_info->eth_speed = ETHER_LINK_10;
+		break;
+	};
+
+	link_info->full_duplex = cmd.duplex;
+#else
+	struct ethtool_link_ksettings cmd;
+
+	mii_ethtool_get_link_ksettings(&axdev->mii, &cmd);
+	switch (cmd.base.speed) {
+	case SPEED_1000:
+		link_info->eth_speed = ETHER_LINK_1000;
+		break;
+	case SPEED_100:
+		link_info->eth_speed = ETHER_LINK_100;
+		break;
+	case SPEED_10:
+	default:
+		link_info->eth_speed = ETHER_LINK_10;
+		break;
+	};
+
+	link_info->full_duplex = cmd.base.duplex;
+#endif
+	return 0;
+}
+
+static int ax88179a_set_bulkin_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u8 link_sts;
+	int index = 0, ret;
+
+	ret = ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			       1, 1, &link_sts, 0);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_1000:
+		if (link_sts & AX_USB_SS)
+			index = 0;
+		else if (link_sts & AX_USB_HS)
+			index = 1;
+		break;
+	case ETHER_LINK_100:
+		if (link_sts & AX_USB_SS)
+			index = 2;
+		else if (link_sts & AX_USB_HS)
+			index = 4;
+
+		if (!link_info->full_duplex)
+			index++;
+		break;
+	case ETHER_LINK_10:
+		index = 6;
+		break;
+	case ETHER_LINK_NONE:
+	default:
+		index = 0;
+		break;
+	};
+
+	if (axdev->coalesce == 0) {
+		u16 timer = *((u16 *)&AX88179A_BULKIN_SIZE[index].timer_l);
+
+		axdev->coalesce = ax88179a_bin_timer_to_usec(axdev, timer);
+	} else {
+		u16 timer = ax88179a_usec_to_bin_timer(axdev);
+
+		AX88179A_BULKIN_SIZE[index].timer_l = timer & 0xFF;
+		AX88179A_BULKIN_SIZE[index].timer_h = (timer >> 8) & 0xFF;
+	}
+
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL,
+				5, 5, &AX88179A_BULKIN_SIZE[index]);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88179a_link_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 medium_mode, reg16;
+	u8 reg8[3];
+	int ret;
+
+	reg16 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0xA5;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_CDC_DELAY_TX,
+				 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x10;
+	reg8[1] = 0x04;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+				2, 2, reg8);
+	if (ret < 0)
+		return ret;
+
+	medium_mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		      AX_MEDIUM_TXFLOW_CTRLEN;
+	reg8[0] = 0x28 | AX_NEW_PAUSE_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_NEW_PAUSE_CTRL,
+			   1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_1000:
+	case ETHER_LINK_100:
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5) | AX_GMII_CRC_APPEND;
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					1, 1, reg8);
+		if (ret < 0)
+			return ret;
+		if (link_info->eth_speed == ETHER_LINK_1000)
+			medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_10:
+		reg8[0] = 0xFA;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5) | AX_GMII_CRC_APPEND;
+		reg8[2] = 0xFF;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					1, 1, reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88179a_set_bulkin_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				2, 2, &medium_mode);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static int ax88179a_queue_priority(struct ax_device *axdev)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX88179A_HIGH_QUEUE_POINT;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_QUEUE_CFG | AX_TX_QUEUE_SET;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_Q1_AHB_FC_EN | AX_TX_QUEUE_CFG;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_STOP_EP5_ACCESS;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BFM_CTRL,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#endif
+
+static int ax88179a_link_reset(struct ax_device *axdev)
+{
+	int ret;
+
+	ret = ax88179a_get_ether_link(axdev);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88179a_link_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	ret = axdev->driver_info->queue_priority(axdev);
+	if (ret < 0)
+		return ret;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	axdev->eee_enabled = ax88179a_chk_eee(axdev);
+	ax88179a_eee_setting(axdev, axdev->eee_enabled);
+#endif
+
+#ifdef ENABLE_PTP_FUNC
+	if (axdev->driver_info->ptp_init)
+		axdev->driver_info->ptp_init(axdev);
+#endif
+
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->driver_info->macsec_init)
+		axdev->driver_info->macsec_init(axdev);
+#endif
+
+	return 0;
+}
+#ifdef ENABLE_AX88279
+static int ax88279_get_ether_link(struct ax_device *axdev)
+{
+	ax88179a_get_ether_link(axdev);
+
+	if (axdev->chip_version >= AX_VERSION_AX88279) {
+		if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500) {
+			axdev->link_info.eth_speed = ETHER_LINK_2500;
+			axdev->link_info.full_duplex = true;
+		}
+	}
+
+	return 0;
+}
+
+static int ax88279_set_bulkin_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u8 link_sts;
+	int index, ret;
+
+	ret = ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			       1, 1, &link_sts, 0);
+	if (ret < 0)
+		return ret;
+
+	if (link_sts & AX_USB_FS) {
+		index = 7;
+	} else {
+		switch (link_info->eth_speed) {
+		case ETHER_LINK_2500:
+			index = 0;
+			break;
+		case ETHER_LINK_1000:
+			if (link_sts & AX_USB_SS)
+				index = 1;
+			else if (link_sts & AX_USB_HS)
+				index = 2;
+			break;
+		case ETHER_LINK_100:
+			if (link_sts & AX_USB_SS)
+				index = 3;
+			else if (link_sts & AX_USB_HS)
+				index = 5;
+
+			if (!link_info->full_duplex)
+				index++;
+			break;
+		case ETHER_LINK_10:
+			break;
+		default:
+			return -1;
+		};
+	}
+
+	if (axdev->coalesce == 0) {
+		u16 timer = *((u16 *)&AX88279_BULKIN_SIZE[index].timer_l);
+
+		axdev->coalesce = ax88179a_bin_timer_to_usec(axdev, timer);
+	} else {
+		u16 timer = ax88179a_usec_to_bin_timer(axdev);
+
+		AX88179A_BULKIN_SIZE[index].timer_l = timer & 0xFF;
+		AX88179A_BULKIN_SIZE[index].timer_h = (timer >> 8) & 0xFF;
+	}
+
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL,
+				5, 5, &AX88279_BULKIN_SIZE[index]);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_link_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 medium_mode, reg16;
+	u8 reg8[3];
+	int ret;
+
+	reg16 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg16 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0xA5;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_CDC_DELAY_TX, 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x10;
+	reg8[1] = 0x04;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX_PAUSE_WATERLVL_HIGH, 2, 2, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_ETH_TX_GAP, 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x07;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_EP5_EHR, 1, 1,
+				&reg8);
+	if (ret < 0)
+		return ret;
+
+	medium_mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		      AX_MEDIUM_TXFLOW_CTRLEN;
+	reg8[0] = 0x28 | AX_NEW_PAUSE_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_NEW_PAUSE_CTRL,
+			   1, 1, reg8);
+	if (ret < 0)
+		return ret;
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_2500:
+		reg8[0] = 0x00;
+		reg8[1] = 0xF8;
+		reg8[2] = 0x07;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = AX_XGMII_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = (0x1C) | AX_LSO_ENHANCE_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_1000:
+		reg8[0] = 0x48;
+		reg8[1] = 0xF1;
+		reg8[2] = 0x3E;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+
+
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_100:
+		reg8[0] = 0x90;
+		reg8[1] = 0xE2;
+		reg8[2] = 0x7D;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_10:
+		reg8[0] = 0x90;
+		reg8[1] = 0xE2;
+		reg8[2] = 0x7D;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0xFF;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	ret = ax88279_set_bulkin_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				2, 2, &medium_mode);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg16 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static int ax88279_queue_setting(struct ax_device *axdev)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX88279_HIGH_QUEUE_POINT;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_QUEUE_SET | AX_TX_QUEUE_CFG;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+	       AX_MAC_STOP_EP5_ACCESS | AX_MAC_STOP_EP3_ACCESS |
+	       AX_MAC_LSO_ERR_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_BFM_CTRL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_EP5_DAT_ERROR_HANDLE;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_EP5_EHR,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_2500:
+		reg8 = AX_TX_QUEUE_CFG | AX_TX_Q1_AHB_FC_EN |
+		       AX_XGMII_EN | AX_TX_Q2_AHB_FC_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_1000:
+	case ETHER_LINK_100:
+		reg8 = AX_TX_QUEUE_CFG | AX_TX_Q1_AHB_FC_EN |
+		       AX_TX_Q2_AHB_FC_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_10:
+		reg8 = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#endif
+
+static int ax88279_link_reset(struct ax_device *axdev)
+{
+	int ret;
+
+	ret = ax88279_get_ether_link(axdev);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88279_link_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	ret = axdev->driver_info->queue_priority(axdev);
+	if (ret < 0)
+		return ret;
+#endif
+
+#ifdef ENABLE_PTP_FUNC
+	if (axdev->driver_info->ptp_init)
+		axdev->driver_info->ptp_init(axdev);
+#endif
+
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->driver_info->macsec_init)
+		axdev->driver_info->macsec_init(axdev);
+#endif
+
+	return 0;
+}
+#endif
+inline void ax88179a_rx_checksum(struct sk_buff *skb, void *pkt_hdr)
+{
+	struct _179a_rx_pkt_header *hdr = (struct _179a_rx_pkt_header *)pkt_hdr;
+
+	skb->ip_summed = CHECKSUM_NONE;
+
+	if ((hdr->L4_err) ||
+	    (hdr->L3_err))
+		return;
+
+	if ((hdr->L4_pkt_type == AX_RXHDR_L4_TYPE_TCP) ||
+	    (hdr->L4_pkt_type == AX_RXHDR_L4_TYPE_UDP))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+}
+
+static void ax88179a_rx_fixup(struct ax_device *axdev, struct rx_desc *desc,
+			      int *work_done, int budget)
+{
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+	struct _179a_rx_pkt_header *pkt_hdr;
+	struct _179a_rx_header *rx_header;
+	const u32 actual_length = desc->urb->actual_length;
+	u8 *rx_data;
+	u32 aa = 0, rx_hdroffset = 0;
+	u16 pkt_count = 0;
+
+	rx_header = (struct _179a_rx_header *)
+		(((u8 *)desc->head) + actual_length - AX88179A_RX_HEADER_SIZE);
+	le64_to_cpus((u64 *)rx_header);
+
+	rx_hdroffset = rx_header->hdr_off;
+	pkt_count = rx_header->pkt_cnt;
+	aa = (actual_length - ((pkt_count + 1) * 8));
+	if (((aa != rx_hdroffset) && ((aa - rx_hdroffset) % 16) != 0) ||
+	    (rx_hdroffset >= desc->urb->actual_length) ||
+	    (pkt_count == 0)) {
+		desc->urb->actual_length = 0;
+		stats->rx_length_errors++;
+		return;
+	}
+
+	pkt_hdr = (struct _179a_rx_pkt_header *)
+			(((u8 *)desc->head) + rx_header->hdr_off);
+
+	rx_data = desc->head;
+	while (pkt_count--) {
+		struct sk_buff *skb;
+		u32 pkt_len = 0;
+
+		le64_to_cpus((u64 *)pkt_hdr);
+
+		if (!pkt_hdr->RxOk) {
+			stats->rx_crc_errors++;
+			if (!(netdev->features & NETIF_F_RXALL))
+				goto find_next_rx;
+		}
+
+		if (pkt_hdr->drop) {
+			stats->rx_dropped++;
+			if (!(netdev->features & NETIF_F_RXALL))
+				goto find_next_rx;
+		}
+
+		pkt_len = (u32)(pkt_hdr->length & 0x7FFF);
+
+#ifdef ENABLE_RX_TASKLET
+		skb = netdev_alloc_skb(netdev, pkt_len);
+#else
+		skb = napi_alloc_skb(napi, pkt_len);
+#endif
+		if (!skb) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+		skb_put(skb, pkt_len);
+		memcpy(skb->data, rx_data, pkt_len);
+		ax88179a_rx_checksum(skb, pkt_hdr);
+
+		skb->truesize = skb->len + sizeof(struct sk_buff);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (pkt_hdr->vlan_ind) {
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+						     pkt_hdr->vlan_tag & VLAN_VID_MASK);
+		}
+#else
+		if (pkt_hdr->vlan_ind) {
+			__vlan_hwaccel_put_tag(skb, pkt_hdr->vlan_tag & VLAN_VID_MASK);
+		}
+#endif
+#ifdef ENABLE_PTP_FUNC
+		if (pkt_hdr->PTP_ind) {
+			ax_rx_get_timestamp(skb, (u64 *)pkt_hdr);
+			pkt_hdr += 2;
+		}
+#endif
+		skb->protocol = eth_type_trans(skb, netdev);
+		if (*work_done < budget) {
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(napi, skb);
+#endif
+
+			*work_done += 1;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		} else {
+			__skb_queue_tail(&axdev->rx_queue, skb);
+		}
+find_next_rx:
+		rx_data += (pkt_len + 7) & 0x7FFF8;
+		pkt_hdr++;
+	}
+}
+
+static int ax88179a_tx_fixup(struct ax_device *axdev, struct tx_desc *desc)
+{
+	struct sk_buff_head skb_head, *tx_queue;
+	struct net_device_stats *stats = &axdev->netdev->stats;
+	int remain, ret;
+#ifdef ENABLE_QUEUE_PRIORITY
+	int endpoint = (desc->q_index == 1)?5:3;
+#else
+	int endpoint = 3;
+#endif
+	u8 *tx_data;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	tx_queue = &axdev->tx_queue[desc->q_index];
+#else
+	tx_queue = axdev->tx_queue;
+#endif
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = desc->head;
+	desc->skb_num = 0;
+	desc->skb_len = 0;
+	remain = axdev->tx_casecade_size;
+
+	while (remain >= (ETH_ZLEN + AX88179A_TX_HEADER_SIZE)) {
+		struct sk_buff *skb;
+		struct _179a_tx_pkt_header *tx_hdr;
+		u16 tci = 0;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		if ((skb->len + AX88179A_TX_HEADER_SIZE) > remain &&
+		    (skb_shinfo(skb)->gso_size == 0)) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		tx_hdr = (struct _179a_tx_pkt_header *)tx_data;
+		memset(tx_hdr, 0, AX88179A_TX_HEADER_SIZE);
+		tx_hdr->length = (skb->len & 0x1FFFFF);
+		tx_hdr->checksum = AX88179A_TX_HERDER_CHKSUM(tx_hdr->length);
+		tx_hdr->max_seg_size = skb_shinfo(skb)->gso_size;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if ((axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_TX) &&
+#else
+		if ((axdev->netdev->features & NETIF_F_HW_VLAN_TX) &&
+#endif		   
+			(vlan_get_tag(skb, &tci) >= 0)) {
+			tx_hdr->vlan_tag = 1;
+			tx_hdr->vlan_info = tci;
+		}
+
+		cpu_to_le64s((u64 *)tx_data);
+		tx_data += AX88179A_TX_HEADER_SIZE;
+
+		if (skb_copy_bits(skb, 0, tx_data, skb->len) < 0) {
+			stats->tx_dropped += skb_shinfo(skb)->gso_segs ?: 1;
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		tx_data = __tx_buf_align((void *)(tx_data + skb->len),
+					 axdev->tx_align_len);
+		desc->skb_len += skb->len;
+		desc->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+#ifdef ENABLE_PTP_FUNC
+		if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+			skb_queue_tail(&axdev->tx_timestamp, skb);
+			set_bit(AX_TX_TIMESTAMPS, &desc->flags);
+		} else {
+			dev_kfree_skb_any(skb);
+		}
+#else
+		dev_kfree_skb_any(skb);
+#endif
+
+		if (tx_hdr->max_seg_size)
+			break;
+
+		remain = axdev->tx_casecade_size -
+			 (int)((void *)tx_data - desc->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(axdev->netdev);
+	if (netif_queue_stopped(axdev->netdev) &&
+	    skb_queue_len(tx_queue) < axdev->tx_qlen) {
+		netif_wake_queue(axdev->netdev);
+	}
+	netif_tx_unlock(axdev->netdev);
+
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	usb_fill_bulk_urb(desc->urb, axdev->udev,
+			  usb_sndbulkpipe(axdev->udev, endpoint),
+			  desc->head, (int)(tx_data - (u8 *)desc->head),
+			  (usb_complete_t)ax_write_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(axdev->intf);
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	if (endpoint == 5)
+		axdev->ep5_count++;
+	else
+		axdev->ep3_count++;
+#endif
+
+	return 0;
+}
+
+static int ax88179a_system_suspend(struct ax_device *axdev)
+{
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+
+	return 0;
+}
+
+static int ax88179a_system_resume(struct ax_device *axdev)
+{
+	int ret;
+
+	if (!ax88179a_check_phy_power(axdev))
+		ax88179a_set_phy_power(axdev, true);
+
+	ret = ax_write_cmd_nopm(axdev, AX_FW_MODE, AX_FW_MODE_179A, 0, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	axdev->driver_info->hw_init(axdev);
+
+	return 0;
+}
+
+static int ax88179a_runtime_suspend(struct ax_device *axdev)
+{
+	u16 reg16, medium_mode;
+	u8 reg8, loop = 100;
+
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+	while(loop--) {
+		ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, 0x57, 2, 2, &reg16, 0);
+		if (reg16 >= 0x11FF)
+			break;
+		mdelay(10);
+	};
+	loop = 100;
+	while(loop--) {
+		u8 reg[4];
+		ax_read_cmd_nopm(axdev, AX88179A_USB_DC, 0x1230, 4, 4, reg, 0);
+		if (reg[2] & 0x02)
+			break;
+		mdelay(10);
+	};
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			 &medium_mode, 0);
+	medium_mode &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = 0x10;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, 0x53, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, 0x53, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	ax_write_cmd_nopm(axdev, AX8179A_WAKEUP_SETTING, 0, 0, 0, NULL);
+
+	reg16 = AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB ;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 0);
+	reg8 &= 0xE0;
+	reg8 |= AX_MONITOR_MODE_RWLC | AX_MONITOR_MODE_RWMP |
+		AX_MONITOR_MODE_PMETYPE;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+
+	medium_mode |= AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	return 0;
+}
+
+static int ax88179a_runtime_resume(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 reg16, medium_mode;
+	u8 reg8;
+
+	if (!ax88179a_check_phy_power(axdev))
+		ax88179a_set_phy_power(axdev, true);
+
+	ax_write_cmd_nopm(axdev, AX_FW_MODE, AX_FW_MODE_179A, 0, 0, NULL);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			 &medium_mode, 0);
+	medium_mode &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	reg8 = 0xFF;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_INT_MASK,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_RX_DMA_CTL,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_TX_DMA_CTL,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_ARC_CTRL,
+			  1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_SWP_CTRL,
+			  1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	if (link_info->eth_speed == ETHER_LINK_1000)
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+
+	medium_mode |= AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		       AX_MEDIUM_TXFLOW_CTRLEN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	return 0;
+}
+
+#ifdef ENABLE_AX88279
+const struct driver_info ax88279_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88279_queue_setting,
+#endif
+	.link_reset	= ax88279_link_reset,
+	.link_setting	= ax88279_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88279_ptp_pps_ctrl,
+	.ptp_init	= ax88279_ptp_init,
+	.ptp_remove	= ax88279_ptp_remove,
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	.macsec_init	= ax_macsec_init,
+#endif
+	.napi_weight	= AX88279_NAPI_WEIGHT,
+	.buf_rx_size	= AX88279_BUF_RX_SIZE,
+};
+#endif
+const struct driver_info ax88179a_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88179a_queue_priority,
+#endif
+	.link_reset	= ax88179a_link_reset,
+	.link_setting	= ax88179a_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88179a_ptp_pps_ctrl,
+	.ptp_init	= ax88179a_ptp_init,
+	.ptp_remove	= ax88179a_ptp_remove,
+#endif
+	.napi_weight	= AX88179A_NAPI_WEIGHT,
+	.buf_rx_size	= AX88179A_BUF_RX_SIZE,
+};
+
+const struct driver_info ax88772d_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88179a_queue_priority,
+#endif
+	.link_reset	= ax88179a_link_reset,
+	.link_setting	= ax88179a_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88179a_ptp_pps_ctrl,
+	.ptp_init	= ax88179a_ptp_init,
+	.ptp_remove	= ax88179a_ptp_remove,
+#endif
+	.napi_weight	= AX88179A_NAPI_WEIGHT,
+	.buf_rx_size	= AX88179A_BUF_RX_SIZE,
+};
diff --git a/drivers/net/usb/asix_usb/ax88179a_772d.h b/drivers/net/usb/asix_usb/ax88179a_772d.h
new file mode 100755
index 000000000000..992a04493b85
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_772d.h
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_AX88179A_772D_H
+#define __ASIX_AX88179A_772D_H
+
+#define AX88179A_BIN_TIMER_UINT		800		//ns
+
+#define AX88179A_NAPI_WEIGHT		64
+#ifdef ENABLE_AX88279
+#define AX88279_NAPI_WEIGHT		256
+#endif
+#define AX88179A_BUF_RX_SIZE		(48 * 1024)
+#ifdef ENABLE_AX88279
+#define AX88279_BUF_RX_SIZE		(48 * 1024)
+#endif
+#define AX88179A_PHY_ID			0x03
+#define AX88179_GPHY_CTRL		0x0F
+	#define AX_GPHY_EEE_CTRL		0x01
+#define AX88179A_HIGH_QUEUE_POINT	0x60
+#ifdef ENABLE_AX88279
+#define AX88279_HIGH_QUEUE_POINT	0x70
+#endif
+#define AX88179A_AUTODETACH_DELAY	(5UL << 8)
+
+#define AX8179A_WAKEUP_SETTING		0x07
+#define AX88179A_PBUS_REG		0x10
+#define AX88179A_ACCESS_BL		0x2A
+#define AX88179A_PHY_CLAUSE45		0x27
+#define AX88179A_PHY_POWER		0x31
+	#define AX_PHY_POWER			0x02
+#define AX88179A_USB_DC			0x81
+#define AX88179A_BOOT_TO_ROM		0x9F
+#define AX88179A_AUTODETACH		0xC0
+
+#define AX88179A_BFM_DATA		0x0E
+	#define AX_TX_QUEUE_CFG			0x02
+	#define AX_TX_QUEUE_SET			0x08
+	#define AX_TX_Q1_AHB_FC_EN		0x10
+	#define AX_TX_Q2_AHB_FC_EN		0x20
+	#define AX_XGMII_EN			0x80
+#define AX88179A_ETH_TX_GAP		0x0D
+#define AX88179A_FLASH_READ		0x21
+#define AX88179A_FLASH_WEN		0x22
+#define AX88179A_FLASH_WDIS		0x23
+#define AX88179A_FLASH_WRITE		0x24
+#define AX88179A_FLASH_EARSE_ALL	0x25
+#define AX88179A_VLAN_ID_CONTROL	0x2B
+	#define AX_VLAN_CONTROL_WE		0x0001
+	#define AX_VLAN_CONTROL_RD		0x0002
+	#define AX_VLAN_CONTROL_VSO		0x0010
+	#define AX_VLAN_CONTROL_VFE		0x0020
+#define AX88179A_MAC_BM_INT_MASK	0x41
+#define AX88179A_MAC_BM_RX_DMA_CTL	0x43
+#define AX88179A_MAC_BM_TX_DMA_CTL	0x46
+#define AX88179A_CLK_EN_ARRAY_1		0x4B
+	#define AX_MAC_MII_TX_25M_EN		0x02
+	#define AX_MAC_RX_25M_EN		0x08
+#define AX88179A_MAC_CLK_SELECT_1	0x4D
+	#define AX_MAC_PCSCLK_MII_TX		0x01
+#define AX88179A_MAC_RX_STATUS_CDC	0x6D
+#define AX88179A_MAC_LSOFC_GMIIPF	0x6E
+	#define AX_GMII_CRC_APPEND		0x10
+	#define AX_LSOFC_WCNT_1_ACCESS		0x00
+	#define AX_LSOFC_WCNT_2_ACCESS		0x01
+	#define AX_LSOFC_WCNT_5_ACCESS		0x02
+	#define AX_LSOFC_WCNT_7_ACCESS		0x03
+#define AX88179A_MAC_RX_FILTER_CTRL	0x6F
+	#define AX_MAC_RX_FILTER_OFT_EN	0x80
+#define AX88179A_MAC_QUEUE_POINT	0x7F
+#define AX88179A_MAC_ARC_CTRL		0x9E
+#define AX88179A_CDC_ECM_CTRL		0xB0
+#define AX88179A_MAC_SWP_CTRL		0xB1
+#define AX88179A_MAC_TX_PAUSE_0		0xB2
+#define AX88179A_MAC_TX_PAUSE_1		0xB3
+#define AX88179A_MAC_TX_PAUSE_2		0xB4
+#define AX88179A_MAC_CDC_DELAY_TX	0xB5
+#define AX88179A_MAC_PATH		0xB7
+	#define AX_MAC_RX_PATH_READY		0x01
+	#define AX_MAC_TX_PATH_READY		0x02
+#define AX88179A_NEW_PAUSE_CTRL		0xB8
+	#define AX_NEW_PAUSE_EN			0x01
+#define AX88179A_MAC_BULK_OUT_CTRL	0xB9
+	#define AX_MAC_EFF_EN			0x02
+#define AX88179A_MAC_RX_DATA_CDC_CNT	0xC0
+#define AX88179A_MAC_BFM_CTRL		0xC1
+	#define AX_MAC_STOP_EP5_ACCESS		0x01
+	#define AX_MAC_STOP_EP3_ACCESS		0x02
+	#define AX_MAC_LSO_ERR_EN		0x04
+	#define AX_MAC_MIQFFCTRL_FORMAT		0x10
+	#define AX_MAC_MIQFFCTRL_DROP_CRC	0x20
+#define AX88179A_MAC_LSO_ENHANCE_CTRL	0xC3
+	#define AX_LSO_ENHANCE_EN		0x01
+#define AX88179A_MAC_TX_HDR_CKSUM	0xCC
+	#define AX_TXHDR_CKSUM_EN		0x01
+	#define AX_TXRX_INDV_RESET_EN		0x02
+#define AX88179A_MAC_CPU_CTRL_MAC_1	0xCE
+	#define AX_RX_INDV_RESET		0x01
+	#define AX_TX_INDV_RESET		0x02
+#define AX88179A_EP5_EHR		0xF9
+	#define AX_EP5_DAT_ERROR_HANDLE		0x80
+#define AX88179A_HW_EC_VERSION		0xFB
+#define AX88179A_SW_REVERSION		0xFC
+	#define AX88179A_FLASH_MODE		0x80
+
+#define PHY_1000M_STS			0x11
+	#define LINK_1000M_OK		0x1000
+#define PHY_100M_STS			0x10
+	#define LINK_100M_OK		0x1000
+#define PHY_10M_STS			0x16
+	#define LINK_10M_OK		0x40
+
+#ifdef ENABLE_AX88279
+#define AX_PBUS_A32			0x11
+
+#define AX_PBUS_REG_BASE_ADDR_HI	0x0013
+#define AX_TX_READY_CTRL		0x1008
+	#define AX_IPG_COUNTER_100M		0x28
+	#define AX_IPG_COUNTER_1G		0x22
+	#define AX_SOF_DELAY_COUNTER_100M	0x1C
+	#define AX_SOF_DELAY_COUNTER_1G		0x06
+	#define AX_VAILD_DELAY_COUNTER_100M	0x0F
+	#define AX_VAILD_DELAY_COUNTER_1G	0x07
+#define AX_MAC_CLK_CTRL			0x3004
+	#define AX_DIVIDE_PTP_CLK_SHIFT		0
+	#define AX_DIVIDE_AES_CLK_SHIFT		8
+	#define AX_PTP_CLK_EN			0x010000
+	#define AX_AES_CLK_EN			0x020000
+	#define AX_PTP_CLK_SELECT_DIVIDE	0x040000
+	#define AX_AES_CLK_SELECT_DIVIDE	0x080000
+	#define AX_XGMAC_TX_CLK_EN		0x100000
+	#define AX_XGMAC_RX_CLK_EN		0x200000
+#endif
+
+struct _179a_rx_pkt_header {
+#ifdef __BIG_ENDIAN
+	u64	reserved	:7,
+		PTP_ind		:1,
+		WUF_ind		:6,
+		WUF_wake	:1,
+		WUF_detect	:1,
+		vlan_tag	:16,
+		drop		:1,
+		length		:15,
+		BMC		:1,
+		reserved2	:3,
+		RxOk		:1,
+		vlan_ind	:1,
+		node_ID_match	:1,
+		TCO_match	:1,
+		CE		:1,
+		L3_pkt_type	:2,
+		L4_pkt_type	:3,
+		L3_err		:1,
+		L4_err		:1;
+#else
+	u64	L4_err		:1,
+		L3_err		:1,
+		L4_pkt_type	:3,
+		L3_pkt_type	:2,
+		CE		:1,
+		TCO_match	:1,
+		node_ID_match	:1,
+		vlan_ind	:1,
+		RxOk		:1,
+		reserved2	:3,
+		BMC		:1,
+		length		:15,
+		drop		:1,
+		vlan_tag	:16,
+		WUF_detect	:1,
+		WUF_wake	:1,
+		WUF_ind		:6,
+		PTP_ind		:1,
+		reserved	:7;
+#endif
+} __packed;
+
+struct _179a_rx_header {
+#ifdef __BIG_ENDIAN
+	u64	rxThroughput: 32,
+		hdr_off	:19,
+		pkt_cnt	:13;
+#else
+	u64	pkt_cnt	:13,
+		hdr_off	:19,
+		rxThroughput: 32;
+#endif
+} __packed;
+#define AX88179A_RX_HEADER_SIZE	sizeof(struct _179a_rx_header)
+
+struct _179a_tx_pkt_header {
+#ifdef __BIG_ENDIAN
+	u64	vlan_info	:16,
+		reserved	:1,
+		max_seg_size	:15,
+		DICF		:1,
+		CPHI		:1,
+		vlan_tag	:1,
+		padding		:1,
+		checksum	:7,
+		length		:21;
+#else
+	u64	length		:21,
+		checksum	:7,
+		padding		:1,
+		vlan_tag	:1,
+		CPHI		:1,
+		DICF		:1,
+		max_seg_size	:15,
+		reserved	:1,
+		vlan_info	:16;
+#endif
+} __packed;
+#define AX88179A_TX_HEADER_SIZE	sizeof(struct _179a_tx_pkt_header)
+
+#define AX88179A_TX_HERDER_CHKSUM(len)  ((tx_hdr->length + \
+					(tx_hdr->length >> 8) + \
+					((tx_hdr->length >> 16) & 0x1F)) & 0x7F)
+
+extern const struct net_device_ops ax88179a_netdev_ops;
+#ifdef ENABLE_AX88279
+extern const struct driver_info ax88279_info;
+#endif
+extern const struct driver_info ax88179a_info;
+extern const struct driver_info ax88772d_info;
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179a_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			    void __user *udata, int cmd);
+#endif
+int ax88179a_ioctl(struct net_device *net, struct ifreq *rq, int cmd);
+void ax88179a_set_multicast(struct net_device *net);
+#endif /* End of __ASIX_AX88179A_772D_H */
diff --git a/drivers/net/usb/asix_usb/ax88179a_ieee.c b/drivers/net/usb/asix_usb/ax88179a_ieee.c
new file mode 100755
index 000000000000..8d0464b7f0bc
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_ieee.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88179A/AX88772D Linux IEEE Test Tool v1.0.0"
+
+const char help_str1[] =
+"./ax88179a_772d_ieee help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char ieeetest_str1[] =
+"./ax88179a_772d_ieee ieeetest [speed] [option]\n"
+"    -- AX88179A_772D IEEE Test Tool\n";
+const char ieeetest_str2[] =
+"        [speed]    - 1000: 1000Mbps,  100: 100Mbps,  10: 10Mbps\n"
+"        [option]   - For 1000Mbps\n"
+"			M1: Mode 1\n"
+"			M2: Mode 2\n"
+"			M3: Mode 3\n"
+"			M4: Mode 4\n\n"
+"		    - For 100Mbps\n"
+"			CA: Channel A\n"
+"			CB: Channel B\n\n"
+"		    - For 10Mbps\n"
+"			RP: Random Pattern\n"
+"			FF: Fixed Pattern(FF)\n"
+"			MDI: MDI\n\n";
+
+static int help_func(struct ax_command_info *info);
+static int ieeetest_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88179a_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"ieeetest",
+		AX88179A_READ_VERSION,
+		ieeetest_func,
+		ieeetest_str1,
+		ieeetest_str2
+	},
+	{NULL},
+};
+
+#pragma pack(push)
+#pragma pack(1)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179a_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+			       ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int ieeetest_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	if (info->argc != 4) {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (!strcmp(info->argv[2], "1000") && strlen(info->argv[2]) == 4) {
+		ioctl_cmd.ieee.speed = 1000;
+		if (!strcmp(info->argv[3], "M1")) {
+			printf("Test item: 1000M M1\n");
+			ioctl_cmd.ieee.type = IEEE_1000M1;
+		} else if (!strcmp(info->argv[3], "M2")) {
+			printf("Test item: 1000M M2\n");
+			ioctl_cmd.ieee.type = IEEE_1000M2;
+		} else if (!strcmp(info->argv[3], "M3")) {
+			printf("Test item: 1000M M3\n");
+			ioctl_cmd.ieee.type = IEEE_1000M3;
+		} else if (!strcmp(info->argv[3], "M4")) {
+			printf("Test item: 1000M M4\n");
+			ioctl_cmd.ieee.type = IEEE_1000M4;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else if (!strcmp(info->argv[2], "100") &&
+		   strlen(info->argv[2]) == 3) {
+		ioctl_cmd.ieee.speed = 100;
+		if (!strcmp(info->argv[3], "CA")) {
+			printf("Test item: 100M Channel A\n");
+			ioctl_cmd.ieee.type = IEEE_100CA;
+		} else if (!strcmp(info->argv[3], "CB")) {
+			printf("Test item: 100M Channel B\n");
+			ioctl_cmd.ieee.type = IEEE_100CB;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else if (!strcmp(info->argv[2], "10") &&
+		   strlen(info->argv[2]) == 2) {
+		ioctl_cmd.ieee.speed = 10;
+		if (!strcmp(info->argv[3], "RP")) {
+			printf("Test item: 10M Random Pattern\n");
+			ioctl_cmd.ieee.type = IEEE_10R;
+		} else if (!strcmp(info->argv[3], "FF")) {
+			printf("Test item: 10M Fixed Pattern(FF)\n");
+			ioctl_cmd.ieee.type = IEEE_10FF;
+		} else if (!strcmp(info->argv[3], "MDI")) {
+			printf("Test item: 10M MDI\n");
+			ioctl_cmd.ieee.type = IEEE_10MDI;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ioctl_cmd.ieee.stop = 0;
+
+	ioctl_cmd.ioctl_cmd = AX88179A_IEEE_TEST;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	printf("Press Enter to stop testing...");
+	getchar();
+
+	ioctl_cmd.ieee.stop = 1;
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		if (ioctl_cmd.ieee.status == -ERR_IEEE_INVALID_CHIP)
+			printf("Invalid speed and chip\n");
+		return -FAIL_IOCTL;
+	}
+
+	printf("Test completely\n");
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+			tmp = tmp->ifa_next;
+
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret;
+
+	printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179a_cmd_list[i].help_ins;
+			info.help_desc = ax88179a_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179a_cmd_list[i].ioctl_cmd;
+			ret = (ax88179a_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88179a_cmd_list[i].cmd == NULL) {
+		printf("%u\n", i);
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax88179a_programmer.c b/drivers/net/usb/asix_usb/ax88179a_programmer.c
new file mode 100755
index 000000000000..368224ac28fb
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_programmer.c
@@ -0,0 +1,1532 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <getopt.h>
+#include <endian.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+#ifdef ENABLE_IOCTL_DEBUG
+#define NOT_PROGRAM
+#endif
+#define RELOAD_DELAY_TIME	10	// sec
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+#define PRINT_SCAN_DEV_FAIL \
+fprintf(stderr, "%s: Scaning device failed.\n", __func__)
+#define PRINT_ALLCATE_MEM_FAIL \
+fprintf(stderr, "%s: Fail to allocate memory.\n", __func__)
+#define PRINT_LOAD_FILE_FAIL \
+fprintf(stderr, "%s: Read file failed.\n", __func__)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88179B/AX88179A/AX88772E/AX88772D Linux Flash/eFuse Programming Tool v2.0.0"
+
+const char help_str1[] =
+"./ax88179b_179a_772e_772d_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readverion_str1[] =
+"./ax88179b_179a_772e_772d_programmer rversion\n"
+"    -- AX88179B_179A_772E_772D Read Firmware Verion\n";
+static const char readverion_str2[] = "";
+
+const char readmac_str1[] =
+"./ax88179b_179a_772e_772d_programmer rmacaddr\n"
+"    -- AX88179B_179A_772E_772D Read MAC Address\n";
+static const char readmac_str2[] = "";
+
+const char writeflash_str1[] =
+"./ax88179b_179a_772e_772d_programmer wflash [file]\n"
+"    -- AX88179B_179A_772E_772D Write Flash\n";
+const char writeflash_str2[] =
+"        [file]    - Flash file path\n";
+
+const char writeefuse_str1[] =
+"./ax88179b_179a_772e_772d_programmer wefuse -m [MAC] -s [SN] -f [File] --led0 [value]"
+" --led1 [value] -p [device]\n"
+"    -- AX88179B_179A_772E_772D Write eFuse\n";
+const char writeefuse_str2[] =
+"        -m [MAC]    - MAC address (XX:XX:XX:XX:XX:XX)\n"
+"        -s [SN]     - Serial number\n"
+"        -f [File]   - eFuse file path\n"
+"        --led0 [value]   - value: control_blink (XXXX_XXXX)\n"
+"        --led1 [value]   - value: control_blink (XXXX_XXXX)\n"
+"        -p [device] - device: \"AX88179B\" or \"AX88179A\" or \"AX88772E\" or \"AX88772D\"\n";
+
+const char readefuse_str1[] =
+"./ax88179b_179a_772e_772d_programmer refuse -f [File]\n"
+"    -- AX88179B_179A_772E_772D Read eFuse\n";
+const char readefuse_str2[] =
+"        -f [File]   - eFuse file path\n";
+
+const char reload_str1[] =
+"./ax88179b_179a_772e_772d_programmer reload\n"
+"    -- AX88179B_179A_772E_772D Reload\n";
+static const char reload_str2[] = "";
+
+static int help_func(struct ax_command_info *info);
+static int readversion_func(struct ax_command_info *info);
+static int readmac_func(struct ax_command_info *info);
+static int writeflash_func(struct ax_command_info *info);
+static int writeefuse_func(struct ax_command_info *info);
+static int readefuse_func(struct ax_command_info *info);
+static int reload_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88179a_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"rversion",
+		AX88179A_READ_VERSION,
+		readversion_func,
+		readverion_str1,
+		readverion_str2
+	},
+	{
+		"rmacaddr",
+		~0,
+		readmac_func,
+		readmac_str1,
+		readmac_str2
+	},
+	{
+		"wflash",
+		AX88179A_WRITE_FLASH,
+		writeflash_func,
+		writeflash_str1,
+		writeflash_str2
+	},
+	{
+		"wefuse",
+		AX88179A_PROGRAM_EFUSE,
+		writeefuse_func,
+		writeefuse_str1,
+		writeefuse_str2
+	},
+	{
+		"refuse",
+		AX88179A_DUMP_EFUSE,
+		readefuse_func,
+		readefuse_str1,
+		readefuse_str2
+	},
+	{
+		"reload",
+		~0,
+		reload_func,
+		reload_str1,
+		reload_str2
+	},
+	{
+		NULL,
+		0,
+		NULL,
+		NULL,
+		NULL
+	}
+};
+
+static unsigned char sample_type1[] = {
+ 0x01, 0x0B, 0x95, 0x17,
+ 0x90, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x02,
+ 0x00, 0x0A, 0x07, 0xFF,
+ 0x17, 0x32, 0x20, 0x00
+};
+
+static unsigned char sample_type4[] = {
+ 0x04, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type11[] = {
+ 0x0B, 0x1F, 0x00, 0x00,
+ 0x00, 0x00, 0x1F, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x45, 0x00
+};
+
+#pragma pack(push)
+#pragma pack(1)
+enum _ef_Type_Def {
+	EF_TYPE_REV = 0x00,
+	EF_TYPE_01 = 0x01,
+	EF_TYPE_04 = 0x04,
+	EF_TYPE_11 = 0x0B,
+};
+struct _ef_type {
+#if __BYTE_ORDER == __BIG_ENDIAN
+	unsigned char	checksum: 4;
+	unsigned char	type	: 4;
+#else
+	unsigned char	type	: 4;
+	unsigned char	checksum: 4;
+#endif
+};
+
+struct _ef_type01 {
+	struct _ef_type	type;
+	unsigned short	vid;
+	unsigned short	pid;
+	unsigned char	mac[6];
+	unsigned short	bcdDevice;
+	unsigned char	bU1DevExitLat;
+	unsigned short	wU2DevExitLat;
+	unsigned char	SS_Max_Bus_Pw;
+	unsigned char	HS_Max_Bus_Pw;
+	unsigned char	IPSleep_Polling_Count;
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_01	sizeof(struct _ef_type01)
+
+struct _ef_type04 {
+	struct _ef_type	type;
+	unsigned char	serial[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_04	sizeof(struct _ef_type04)
+
+struct _ef_type11 {
+	struct _ef_type	type;
+	unsigned char	dev_type0;
+	unsigned short	reg0;
+	unsigned short	value0;
+	unsigned char	dev_type1;
+	unsigned short	reg1;
+	unsigned short	value1;
+	unsigned char	dev_type2;
+	unsigned short	reg2;
+	unsigned short	value2;
+	unsigned char	reserved1[2];
+	unsigned char	subtype;
+	unsigned char	reserved2;
+};
+#define EF_TYPE_STRUCT_SIZE_11	sizeof(struct _ef_type11)
+
+struct _ef_data_struct {
+	union {
+		struct _ef_type01 type01;
+		struct _ef_type04 type04;
+		struct _ef_type11 type11;
+	} ef_data;
+};
+#define EF_DATA_STRUCT_SIZE	sizeof(struct _ef_data_struct)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179a_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+			       ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int autosuspend_enable(struct ax_command_info *info,
+			      unsigned char enable)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_AUTOSUSPEND_EN;
+
+	ioctl_cmd.autosuspend.enable = enable;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int read_version(struct ax_command_info *info, char *version)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_VERSION;
+
+	memset(ioctl_cmd.version.version, 0, 16);
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	memcpy(version, ioctl_cmd.version.version, 16);
+
+	return SUCCESS;
+}
+
+static int read_mac_address(struct ax_command_info *info, unsigned char *mac)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ifr->ifr_flags &= 0;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ifr->ifr_flags = IFF_UP | IFF_BROADCAST | IFF_MULTICAST;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ret = ioctl(info->inet_sock, SIOCGIFHWADDR, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	memcpy(mac, ifr->ifr_hwaddr.sa_data, 6);
+
+	return SUCCESS;
+}
+
+static int readversion_func(struct ax_command_info *info)
+{
+	char version[16] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	ret = read_version(info, version);
+	if (ret == SUCCESS)
+		printf("Firmware Version: %s\n", version);
+
+	usleep(20000);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readmac_func(struct ax_command_info *info)
+{
+	unsigned char mac[6] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = read_mac_address(info, mac);
+	if (ret == SUCCESS)
+		printf("MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			mac[0],
+			mac[1],
+			mac[2],
+			mac[3],
+			mac[4],
+			mac[5]);
+
+	return ret;
+}
+
+static int write_flash(struct ax_command_info *info, unsigned char *data,
+		       unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_WRITE_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH WRITE status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	return SUCCESS;
+}
+
+static int read_flash(struct ax_command_info *info, unsigned char *data,
+		      unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH READ status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_flash(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_FLASH;
+	ioctl_cmd.flash.status = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int boot_to_rom(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ROOT_2_ROM;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	return SUCCESS;
+}
+
+static int sw_reset(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_SW_RESET;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	usleep(RELOAD_DELAY_TIME * 1000000);
+
+	return SUCCESS;
+}
+
+static int writeflash_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *wbuf = NULL, *rbuf = NULL;
+	FILE *pFile = NULL;
+	size_t result;
+	int length = 0;
+	int i, offset, len, ret;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 3) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	boot_to_rom(info);
+
+	usleep(1000000);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ret = erase_flash(info);
+	if (ret < 0) 
+		return ret;
+
+	pFile = fopen(info->argv[2], "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, info->argv[2]);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	fseek(pFile, 0, SEEK_END);
+	length = ftell(pFile);
+	fseek(pFile, 0, SEEK_SET);
+
+	wbuf = (unsigned char *)malloc((length + 256) & ~(0xFF));
+	if (!wbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(wbuf, 0, (length + 256) & ~(0xFF));
+	rbuf = (unsigned char *)malloc((length + 256) & ~(0xFF));
+	if (!rbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(rbuf, 0, (length + 256) & ~(0xFF));
+
+	result = fread(wbuf, 1, length, pFile);
+	if (result != length) {
+		PRINT_LOAD_FILE_FAIL;
+		ret = -PRINT_LOAD_FILE_FAIL;
+		goto fail;
+	}
+
+	offset = SWAP_32(*(unsigned long *)&wbuf[4]);
+	len = (SWAP_32(*(unsigned long *)&wbuf[8]) + 256) & ~(0xFF);
+
+	sprintf(fw_version, "v%d.%d.%d",
+		wbuf[offset + 0x1000],
+		wbuf[offset + 0x1001],
+		wbuf[offset + 0x1002]);
+	printf("File FW Version: %s\n", fw_version);
+
+	ret = write_flash(info, wbuf, offset, len);
+	if (ret < 0)
+		goto fail;
+
+	ret = read_flash(info, rbuf, offset, len);
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(&wbuf[offset], &rbuf[offset], len) != 0) {
+		fprintf(stderr, "%s: Program the FW failed.\n", __func__);
+		ret = -FAIL_FLASH_WRITE;
+		goto fail;
+	}
+
+	len = SWAP_32(*(unsigned long *)&wbuf[4]);
+
+	ret = write_flash(info, wbuf, 0, len);
+	if (ret < 0)
+		goto fail;
+
+	ret = read_flash(info, rbuf, 0, (length + 256) & ~(0xFF));
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(wbuf, rbuf,
+		   (SWAP_32(*(unsigned long *)&wbuf[8]) +
+		    SWAP_32(*(unsigned long *)&wbuf[4]))) != 0) {
+		fprintf(stderr, "%s: Program the Flash failed.\n", __func__);
+		ret = -FAIL_FLASH_WRITE;
+		goto fail;
+	}
+
+	ret = SUCCESS;
+	goto out;
+fail:
+	erase_flash(info);
+out:
+	if (rbuf)
+		free(rbuf);
+	if (wbuf)
+		free(wbuf);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+#define EFUSE_NUM_BLOCK	32
+
+static void checksum_efuse_block(unsigned char *block)
+{
+	unsigned int Sum = 0;
+	int j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			Sum += block[j] & 0xF;
+		else
+			Sum += block[j];
+	}
+
+	while (Sum > 0xF)
+		Sum = (Sum & 0xF) + (Sum >> 4);
+
+	Sum = 0xF - Sum;
+
+	block[0] = (block[0] & 0xF) | ((Sum << 4) & 0xF0);
+}
+
+static int __find_efuse_index(struct _ef_data_struct *efuse,
+			      enum _ef_Type_Def type)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 5; i < EFUSE_NUM_BLOCK; i++) {
+		if (efuse[i].ef_data.type01.type.type == type)
+			return i;
+	}
+
+	return -FAIL_GENERIAL_ERROR;
+}
+
+static int change_mac_address(struct _ef_data_struct *efuse, unsigned int *mac)
+{
+	int index, i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	index = __find_efuse_index(efuse, EF_TYPE_01);
+	if (index == -FAIL_GENERIAL_ERROR) {
+		fprintf(stderr, "%s: Not found type 1 from eFuese file\n",
+			__func__);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	for (i = 0; i < 6; i++)
+		efuse[index].ef_data.type01.mac[i] = (unsigned char)mac[i];
+	checksum_efuse_block((unsigned char *)&efuse[index]);
+
+	return SUCCESS;
+}
+
+static int change_serial_number(struct _ef_data_struct *efuse, char *serial)
+{
+	int index;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	index = __find_efuse_index(efuse, EF_TYPE_04);
+	if (index == -FAIL_GENERIAL_ERROR) {
+		fprintf(stderr, "%s: Not found type 4 from eFuese file\n",
+			__func__);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	memset(efuse[index].ef_data.type04.serial, 0, 18);
+	memcpy(efuse[index].ef_data.type04.serial, serial, strlen(serial));
+	checksum_efuse_block((unsigned char *)&efuse[index]);
+
+	return SUCCESS;
+}
+
+static void set_led(struct _ef_data_struct *efuse, char *led, int led_num)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	memcpy(efuse, sample_type11, EF_TYPE_STRUCT_SIZE_11);
+
+	efuse->ef_data.type11.reg0 = htobe16(0x0024 + (led_num << 1));
+	efuse->ef_data.type11.reg1 = htobe16(0x0025 + (led_num << 1));
+
+	led[4] = '\0';
+	efuse->ef_data.type11.value0 = htobe16(strtol(led, NULL, 16));
+	efuse->ef_data.type11.value1 = htobe16(strtol(&led[5], NULL, 16));
+
+	checksum_efuse_block((unsigned char *)efuse);
+}
+
+static int load_efuse_from_file(char *file_path, unsigned char *data)
+{
+	FILE *pFile = NULL;
+	int i, j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (!file_path)
+		return -FAIL_LOAD_FILE;
+
+	pFile = fopen(file_path, "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, file_path);
+		return -FAIL_LOAD_FILE;
+	}
+
+	for (i = 0; i < (20 * EFUSE_NUM_BLOCK); i += 4) {
+		unsigned int size = 0;
+
+		for (j = 3; j >= 0; j--) {
+			unsigned int tmp;
+
+			size = fscanf(pFile, "%02X ", &tmp);
+			if (size == ~0)
+				break;
+			data[i + j] = tmp & 0xFF;
+		}
+		if (size == ~0)
+			break;
+	}
+
+	if (pFile)
+		fclose(pFile);
+
+	return SUCCESS;
+}
+
+static int __dump_efuse(struct ax_command_info *info,
+			struct _ef_data_struct *efuse,
+			int block_offset, int block_num)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int i, limit = (block_offset + block_num);
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (limit > EFUSE_NUM_BLOCK) {
+		fprintf(stderr, "%s: Invalid dump block size\n", __func__);
+		return -FAIL_IVALID_VALUE;
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	ioctl_cmd.ioctl_cmd = AX88179A_DUMP_EFUSE;
+	ioctl_cmd.flash.length = 20;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	for (i = block_offset; i < limit; i++) {
+		int ret;
+
+		ioctl_cmd.flash.status = 0;
+		ioctl_cmd.flash.offset = i;
+		ioctl_cmd.flash.buf = (unsigned char *)&efuse[i];
+
+		ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+		if (ret < 0) {
+			if (ioctl_cmd.flash.status)
+				fprintf(stderr, "FLASH READ status: %d",
+					ioctl_cmd.flash.status);
+			PRINT_IOCTL_FAIL(ret);
+			return -FAIL_IOCTL;
+		}
+		usleep(200000);
+	}
+
+	return SUCCESS;
+}
+
+static int dump_efuse_from_chip(struct ax_command_info *info,
+				struct _ef_data_struct *efuse)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	return __dump_efuse(info, efuse, 0, 32);
+}
+
+static int find_empty_block_index(struct _ef_data_struct *efuse)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 5; i < EFUSE_NUM_BLOCK; i++) {
+		if (efuse[i].ef_data.type01.type.type == EF_TYPE_REV)
+			break;
+	}
+
+	return (i == EFUSE_NUM_BLOCK) ? -1 : i;
+}
+
+#ifdef ENABLE_IOCTL_DEBUG
+static void dump_efuse_data(struct _ef_data_struct *efuse)
+{
+	int i;
+	unsigned char *data = (unsigned char *)efuse;
+
+	for (i = 0; i < (20 * EFUSE_NUM_BLOCK); i += 4) {
+		printf("%02X %02X %02X %02X",
+			data[i + 3], data[i + 2], data[i + 1], data[i]);
+		if (i % 20 == 0)
+			printf(" == %d", i / 20);
+		printf("\n");
+	}
+
+}
+#define DUMP_EFUSE_DATA(efuse) dump_efuse_data(efuse)
+#else
+#define DUMP_EFUSE_DATA(efuse) while(0){}
+#endif
+
+static int check_efuse_block_valid(unsigned char *data)
+{
+	unsigned int sum = 0;
+	unsigned int tmp;
+	int j = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if ((data[0] & 0xF) == EF_TYPE_REV)
+		return -FAIL_IVALID_VALUE;
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			sum += data[j] & 0xF;
+		else
+			sum += data[j];
+	}
+
+	while (sum > 0xF)
+		sum = (sum & 0xF) + (sum >> 4);
+
+	sum = 0xF - sum;
+
+	tmp = (data[0] & 0xF) | ((sum << 4) & 0xF0);
+
+	if (tmp != data[0])
+		return -FAIL_IVALID_CHKSUM;
+
+	return SUCCESS;
+}
+
+static int merge_efuse(struct _ef_data_struct *dump_efuse,
+		       struct _ef_data_struct *file_efuse,
+		       unsigned int *program_block, unsigned int *program_index)
+{
+	int dump_empty_index, i, j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	dump_empty_index = find_empty_block_index(dump_efuse);
+	if (dump_empty_index < 0) {
+		fprintf(stderr, "%s: Non empty block.\n", __func__);
+		return -FAIL_NON_EMPTY_RFUSE_BLOCK;
+	}
+
+	*program_block = 0;
+	*program_index = -1;
+	for (i = 5, j = dump_empty_index; i < EFUSE_NUM_BLOCK; i++, j++) {
+		unsigned char *block = (unsigned char *)&file_efuse[i];
+		int ret;
+
+		if (file_efuse[i].ef_data.type01.type.type == EF_TYPE_REV)
+			break;
+
+		ret = check_efuse_block_valid(block);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: ERROR eFuse block in file.\n", __func__);
+			return ret;
+		}
+		memcpy(&dump_efuse[j], &file_efuse[i], EF_DATA_STRUCT_SIZE);
+		*program_block += 1;
+	}
+
+	*program_index = dump_empty_index;
+	return SUCCESS;
+}
+
+static int __program_efuse_block(struct ax_command_info *info,
+				 struct _ef_data_struct *efuse,
+				 unsigned int block_offset,
+				 unsigned int block_num)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int i, limit = (block_offset + block_num);
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (limit > EFUSE_NUM_BLOCK) {
+		fprintf(stderr, "%s: eFuse block not enough\n", __func__);
+		return -FAIL_IVALID_VALUE;
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	ioctl_cmd.ioctl_cmd = AX88179A_PROGRAM_EFUSE;
+	ioctl_cmd.flash.length = 20;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	for (i = block_offset; i < limit; i++) {
+		int ret;
+
+		ioctl_cmd.flash.status = 0;
+		ioctl_cmd.flash.offset = i;
+		ioctl_cmd.flash.buf = (unsigned char *)&efuse[i];
+
+		ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+		if (ret < 0) {
+			if (ioctl_cmd.flash.status)
+				fprintf(stderr, "FLASH PROGRAM status: %d",
+					ioctl_cmd.flash.status);
+			PRINT_IOCTL_FAIL(ret);
+			return -FAIL_IOCTL;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static struct option const long_options[] =
+{
+  {"file", required_argument, NULL, 'f'},
+  {"mac", required_argument, NULL, 'm'},
+  {"serial", required_argument, NULL, 's'},
+  {"device", required_argument, NULL, 'p'},
+  {"led0", required_argument, NULL, 'l'},
+  {"led1", required_argument, NULL, 'e'},
+  {NULL, 0, NULL, 0}
+};
+
+struct __wefuse {
+	char *mac_address;
+	char *serial_num;
+	char *file_path;
+	char *led0;
+	char *led1;
+	char *device;
+	unsigned int MAC[6];
+};
+
+static void creat_sample_efuse(struct _ef_data_struct *efuse,
+			       struct __wefuse *par)
+{
+	int index = 5;
+
+	if (par->mac_address) {
+		memcpy(&efuse[index], sample_type1, EF_TYPE_STRUCT_SIZE_01);
+		if (!strcasecmp(par->device , "AX88179A"))
+			efuse[index].ef_data.type01.bcdDevice = htobe16(0x0200);
+		if (!strcasecmp(par->device , "AX88772D"))
+			efuse[index].ef_data.type01.bcdDevice = htobe16(0x0300);
+		index++;
+	}
+
+	if (par->serial_num)
+		memcpy(&efuse[index++], sample_type4, EF_TYPE_STRUCT_SIZE_04);
+
+	if (par->led0)
+		set_led(&efuse[index++], par->led0, 0);
+
+	if (par->led1)
+		set_led(&efuse[index++], par->led1, 1);
+}
+
+static int print_msg(char *cmd)
+{
+	int i;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(cmd, ax88179a_cmd_list[i].cmd,
+				strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+}
+
+static int __check_led_parameter(char *led)
+{
+	if (!led)
+		return 1;
+
+	if (strlen(led) != 9 || led[4] != '_')
+		return 1;
+	do {
+		if (*led++ == '_')
+			continue;
+		if (!isxdigit(*led++))
+			return 1;
+	} while (*led);
+	return 0;
+}
+
+static int __check_wefuse_parameter(struct __wefuse *par)
+{
+	if (par->mac_address)
+		if (!par->device && !par->file_path)
+			return 1;
+
+	if (!par->led0 ^ !par->led1)
+		return 1;
+
+	return 0;
+}
+
+static int writeefuse_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ef_data_struct *file_efuse = NULL;
+	struct _ef_data_struct *dump_efuse = NULL;
+	int i, c, ret;
+	struct __wefuse argument = {0};
+	void *buf = NULL;
+	int oi = -1;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"m:s:f:p:l:e:",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'm':
+			argument.mac_address = optarg;
+			DEBUG_PRINT("%s \r\n", argument.mac_address);
+			i = sscanf(argument.mac_address,
+				   "%02X:%02X:%02X:%02X:%02X:%02X",
+				   (unsigned int *)&argument.MAC[0],
+				   (unsigned int *)&argument.MAC[1],
+				   (unsigned int *)&argument.MAC[2],
+				   (unsigned int *)&argument.MAC[3],
+				   (unsigned int *)&argument.MAC[4],
+				   (unsigned int *)&argument.MAC[5]);
+			if (i != 6)
+				return print_msg("wefuse");
+			break;
+		case 's':
+			argument.serial_num = optarg;
+			DEBUG_PRINT("%s \r\n", argument.serial_num);
+			if (strlen(argument.serial_num) > 18)
+				return print_msg("wefuse");
+			break;
+		case 'f':
+			argument.file_path = optarg;
+			DEBUG_PRINT("%s \r\n", argument.file_path);
+			break;
+		case 'l':
+			argument.led0 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led0);
+			if (__check_led_parameter(argument.led0))
+				return print_msg("wefuse");
+			break;
+		case 'e':
+			argument.led1 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led1);
+			if (__check_led_parameter(argument.led1))
+				return print_msg("wefuse");			
+			break;
+		case 'p':
+			argument.device = optarg;
+			DEBUG_PRINT("%s \r\n", argument.device);
+			if (strcasecmp(argument.device , "AX88179B") &&
+			    strcasecmp(argument.device , "AX88179A") &&
+				strcasecmp(argument.device , "AX88772E") &&
+			    strcasecmp(argument.device , "AX88772D"))
+				return print_msg("wefuse");
+			break;	
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	if (__check_wefuse_parameter(&argument))
+		return print_msg("wefuse");
+
+	buf = calloc(128, EF_DATA_STRUCT_SIZE);
+	if (!buf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		return -FAIL_ALLCATE_MEM;
+	}
+
+	file_efuse = (struct _ef_data_struct *)buf;
+	dump_efuse = (struct _ef_data_struct *)&file_efuse[64];
+
+	if (argument.file_path) {
+		if (load_efuse_from_file(argument.file_path,
+					 (unsigned char *)file_efuse)) {
+			PRINT_LOAD_FILE_FAIL;
+			ret = -PRINT_LOAD_FILE_FAIL;
+			goto fail;
+		}
+	} else {
+		creat_sample_efuse(file_efuse, &argument);
+	}
+
+	DUMP_EFUSE_DATA(file_efuse);
+
+	if (argument.mac_address) {
+		ret = change_mac_address(file_efuse, argument.MAC);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing MAC address failed.\n",
+				__func__);
+			goto fail;
+		}
+	}
+
+	if (argument.serial_num) {
+		ret = change_serial_number(file_efuse, argument.serial_num);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing serial number failed.\n",
+				__func__);
+			goto fail;
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	DUMP_EFUSE_DATA(file_efuse);
+
+	ret = dump_efuse_from_chip(info, dump_efuse);
+	if (ret < 0)
+		goto fail;
+
+	DUMP_EFUSE_DATA(dump_efuse);
+
+	do {
+		unsigned int program_block;
+		unsigned int program_index;
+
+		ret = merge_efuse(dump_efuse, file_efuse,
+				  &program_block, &program_index);
+		if (ret < 0)
+			goto fail;
+
+		DUMP_EFUSE_DATA(dump_efuse);
+#ifndef NOT_PROGRAM
+		ret = __program_efuse_block(info, dump_efuse,
+					    program_index, program_block);
+		if (ret < 0)
+			goto fail;
+#endif
+	} while (0);
+#ifndef NOT_PROGRAM
+	usleep(100000);
+
+	ret = dump_efuse_from_chip(info, file_efuse);
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(file_efuse, dump_efuse, (EF_DATA_STRUCT_SIZE * 32))) {
+		fprintf(stderr, "%s: Comparing efuse failed.\n", __func__);
+		ret = -FAIL_EFUSE_WRITE;
+		goto fail;
+	}
+#endif
+	ret = SUCCESS;
+fail:
+	if (buf)
+		free(buf);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readefuse_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ef_data_struct *dump_efuse = NULL;
+	FILE *pFile = NULL;
+	char str_buf[50];
+	int i, j, c, ret, oi = -1;
+	char *file_path = NULL;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"f",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'f':
+			file_path = info->argv[optind];
+			break;
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	if (file_path == NULL) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp("refuse", ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	dump_efuse = (struct _ef_data_struct *)malloc(EF_DATA_STRUCT_SIZE * 32);
+	if (!dump_efuse) {
+		PRINT_ALLCATE_MEM_FAIL;
+		return -FAIL_ALLCATE_MEM;
+	}
+	memset(dump_efuse, 0, EF_DATA_STRUCT_SIZE * 32);
+
+	autosuspend_enable(info, 0);
+
+	ret = dump_efuse_from_chip(info, dump_efuse);
+	if (ret < 0)
+		goto fail;
+
+	pFile = fopen(file_path, "w");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, file_path);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	DUMP_EFUSE_DATA(dump_efuse);
+
+	for (i = 0; i < 32; i++) {
+		unsigned char *buf = (unsigned char *)&dump_efuse[i];
+
+		for (j = 0; j < 5; j++) {
+			snprintf(str_buf, 50, "%02x %02x %02x %02x\n",
+				 buf[(j * 4) + 3],
+				 buf[(j * 4) + 2],
+				 buf[(j * 4) + 1],
+				 buf[(j * 4)]);
+			fputs(str_buf, pFile);
+		}
+	}
+
+	ret = SUCCESS;
+fail:
+	if (dump_efuse)
+		free(dump_efuse);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+	
+	return ret;
+}
+
+static int reload_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	autosuspend_enable(info, 0);
+
+	sw_reset(info);
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+			tmp = tmp->ifa_next;
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret = -FAIL_GENERIAL_ERROR;
+
+	printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#ifndef NOT_PROGRAM 
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+#endif
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179a_cmd_list[i].help_ins;
+			info.help_desc = ax88179a_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179a_cmd_list[i].ioctl_cmd;
+			ret = (ax88179a_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88179a_cmd_list[i].cmd == NULL) {
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax88279_programmer.c b/drivers/net/usb/asix_usb/ax88279_programmer.c
new file mode 100755
index 000000000000..875298361c5c
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88279_programmer.c
@@ -0,0 +1,1813 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <getopt.h>
+#include <endian.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+#ifdef ENABLE_IOCTL_DEBUG
+#define NOT_PROGRAM
+#endif
+#define RELOAD_DELAY_TIME	10	// sec
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+#define PRINT_SCAN_DEV_FAIL \
+fprintf(stderr, "%s: Scaning device failed.\n", __func__)
+#define PRINT_ALLCATE_MEM_FAIL \
+fprintf(stderr, "%s: Fail to allocate memory.\n", __func__)
+#define PRINT_LOAD_FILE_FAIL \
+fprintf(stderr, "%s: Read file failed.\n", __func__)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88279 Linux Flash Programming Tool v1.0.0 beat1"
+
+const char help_str1[] =
+"./ax88279_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readverion_str1[] =
+"./ax88279_programmer rversion\n"
+"    -- AX88279 Read Firmware Verion\n";
+static const char readverion_str2[] = "";
+
+const char readmac_str1[] =
+"./ax88279_programmer rmacaddr\n"
+"    -- AX88279 Read MAC Address\n";
+static const char readmac_str2[] = "";
+
+const char writeflash_str1[] =
+"./ax88279_programmer wflash [file]\n"
+"    -- AX88279 Write Flash\n";
+const char writeflash_str2[] =
+"        [file]    - Flash file path\n";
+
+const char writeparameter_str1[] =
+"./ax88279_programmer wpara -m [MAC] -s [SN] -p [PID] -v [VID] -P [PS] -M [MN] -D [dump]\n"
+"                           -S [SS] -H [HS] -w [wol] -l [led0 value] -e [led1 value] -d [led2 value]\n"
+"    -- AX88279 Write Parameter\n";
+const char writeparameter_str2[] =
+"        -m [MAC]   	 - MAC address (XX:XX:XX:XX:XX:XX) X:'0'-'F'\n"
+"        -s [SN]    	 - Serial Number (Characters must be less than 19 bytes) X:'0'-'F'\n"
+"        -p [PID]   	 - Product ID (XX:XX) X:'0'-'F'\n"
+"        -v [VID]   	 - Vendor ID (XX:XX) X:'0'-'F'\n"
+"        -P [PS]    	 - Product String (Characters must be less than 19 bytes)\n"
+"        -M [MN]    	 - Manufacture Name (Characters must be less than 19 bytes)\n"
+"        -D [dump]	 - The parameter content currently in flash (dump)\n"
+"        -S [SS]    	 - SS bus power (XX) X:0-896\n"
+"        -H [HS]    	 - HS bus power (XX) X:0-500\n"
+"        -w [wol]    	 - wake on LAN (XXXXXXXX) X:digit\n"
+"        -l [led0 value]	 - value: control_blink (XXXX_XXXX)\n"
+"        -e [led1 value]	 - value: control_blink (XXXX_XXXX)\n";
+
+const char reload_str1[] =
+"./ax88279_programmer reload\n"
+"    -- AX88279 Reload\n";
+static const char reload_str2[] = "";
+
+static int help_func(struct ax_command_info *info);
+static int readversion_func(struct ax_command_info *info);
+static int readmac_func(struct ax_command_info *info);
+static int writeflash_func(struct ax_command_info *info);
+static int writeparameter_func(struct ax_command_info *info);
+static int reload_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88279_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"rversion",
+		AX88179A_READ_VERSION,
+		readversion_func,
+		readverion_str1,
+		readverion_str2
+	},
+	{
+		"rmacaddr",
+		~0,
+		readmac_func,
+		readmac_str1,
+		readmac_str2
+	},
+	{
+		"wflash",
+		AX88179A_WRITE_FLASH,
+		writeflash_func,
+		writeflash_str1,
+		writeflash_str2
+	},
+	{
+		"wpara",
+		AX88179A_PROGRAM_EFUSE,
+		writeparameter_func,
+		writeparameter_str1,
+		writeparameter_str2
+	},
+	{
+		"reload",
+		~0,
+		reload_func,
+		reload_str1,
+		reload_str2
+	},
+	{
+		NULL,
+		0,
+		NULL,
+		NULL,
+		NULL
+	}
+};
+
+static struct option const long_options[] =
+{
+  {"mac", required_argument, NULL, 'm'},
+  {"serial", required_argument, NULL, 's'},
+  {"pid", required_argument, NULL, 'p'},
+  {"vid", required_argument, NULL, 'v'},
+  {"Product", required_argument, NULL, 'P'},
+  {"Manufacture", required_argument, NULL, 'M'},
+  {"dump", required_argument, NULL, 'D'},
+  {"ssbus", required_argument, NULL, 'S'},
+  {"hsbus", required_argument, NULL, 'H'},
+  {"wol", required_argument, NULL, 'w'},
+  {"led0", required_argument, NULL, 'l'},
+  {"led1", required_argument, NULL, 'e'},
+  {NULL, 0, NULL, 0}
+};
+
+struct __wpara {
+	char *mac_address;
+	char *serial_num;
+	char *PID;
+	char *VID;
+	char *product_string;
+	char *manufacture;
+	char *dump;
+	char *ss_bus;
+	char *hs_bus;
+	char *wol;
+	char *led0;
+	char *led1;
+	unsigned int iss_bus;
+	unsigned int ihs_bus;	
+	unsigned int MAC[6];
+	unsigned int LED0[9];
+	unsigned int LED1[9];
+	unsigned int pid[2];
+	unsigned int vid[2];
+	unsigned int ssbus[1];
+	unsigned int hsbus[1];
+};
+
+static unsigned char sample_type1[] = {
+ 0x01, 0x0B, 0x95, 0x17,
+ 0x90, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x01, 0x04,
+ 0x00, 0x0A, 0x07, 0xFF,
+ 0x39, 0xE1, 0x20, 0x00
+};
+
+static unsigned char sample_type2[] = {
+ 0x02, 0x41, 0x53, 0x49,
+ 0x58, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type3[] = {
+ 0x03, 0x41, 0x58, 0x38,
+ 0x38, 0x32, 0x37, 0x39,
+ 0x41, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type4[] = {
+ 0x04, 0x30, 0x30, 0x30,
+ 0x30, 0x30, 0x30, 0x30,
+ 0x31, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type11[] = {
+ 0x0B, 0x1F, 0x00, 0x00,
+ 0x00, 0x00, 0x1F, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x45, 0x0B
+};
+
+static unsigned char sample_type15[] = {
+ 0x0F, 0x7D, 0x01, 0x63,
+ 0x81, 0x7F, 0x7F, 0x5F,
+ 0x5D, 0x2F, 0x07, 0xE8,
+ 0x04, 0x7D, 0x00, 0xC8,
+ 0x08, 0x01, 0x04, 0x00
+};
+
+#pragma pack(push)
+#pragma pack(1)
+enum Para_Type_Def {
+	TYPE_REV = 0x00,
+	TYPE_01 = 0x01,
+	TYPE_02 = 0x02,
+	TYPE_03 = 0x03,
+	TYPE_04 = 0x04,
+	TYPE_11 = 0x0B,
+	TYPE_15 = 0x0F,
+};
+struct _ef_type {
+#if __BYTE_ORDER == __BIG_ENDIAN
+	unsigned char	checksum: 4;
+	unsigned char	type	: 4;
+#else
+	unsigned char	type	: 4;
+	unsigned char	checksum: 4;
+#endif
+};
+
+struct _ef_type01 {
+	struct _ef_type	type;
+	unsigned short	vid;
+	unsigned short	pid;
+	unsigned char	mac[6];
+	unsigned short	bcdDevice;
+	unsigned char	bU1DevExitLat;
+	unsigned short	wU2DevExitLat;
+	unsigned char	SS_Max_Bus_Pw;
+	unsigned char	HS_Max_Bus_Pw;
+	unsigned char	IPSleep_Polling_Count;
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_01	sizeof(struct _ef_type01)
+
+struct _ef_type02 {
+	struct _ef_type	type;
+	unsigned char	m_string[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_02	sizeof(struct _ef_type02)
+
+struct _ef_type03 {
+	struct _ef_type	type;
+	unsigned char	p_string[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_03	sizeof(struct _ef_type03)
+
+struct _ef_type04 {
+	struct _ef_type	type;
+	unsigned char	serial[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_04	sizeof(struct _ef_type04)
+
+struct _ef_type11 {
+	struct _ef_type	type;
+	unsigned char	dev_type0;
+	unsigned short	reg0;
+	unsigned short	value0;
+
+	unsigned char	dev_type1;
+	unsigned short	reg1;
+	unsigned short	value1;
+
+	unsigned char	dev_type2;
+	unsigned short	reg2;
+	unsigned short	value2;
+
+	unsigned char	reserved1[2];
+	unsigned char	subtype;
+	unsigned char	endofs;
+};
+#define EF_TYPE_STRUCT_SIZE_11	sizeof(struct _ef_type11)
+
+struct _ef_type15 {
+	struct _ef_type	type;
+	unsigned char	flag1;
+	unsigned char	flag2;
+	unsigned char	flag3;
+	unsigned char	flag4;
+	unsigned char	U1_inact_timer;
+	unsigned char	U2_inact_timer;
+	unsigned char	Lpm_besl_u3;
+	unsigned char	Lpm_besl;
+	unsigned char	Lpm_besld;
+	unsigned short	Ltm_belt_down;
+	unsigned short	Ltm_belt_up;
+	unsigned short	Ephy_poll_timer;
+
+	unsigned char	Pme_gpio_sel;
+	unsigned char	Pme_pulse_width;
+	unsigned char	Wol_mask_timer;
+
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_15	sizeof(struct _ef_type15)
+
+struct _ef_data_struct {
+	union {
+		struct _ef_type01 type01;
+		struct _ef_type02 type02;
+		struct _ef_type03 type03;
+		struct _ef_type04 type04;
+		struct _ef_type11 type11;
+		struct _ef_type15 type15;
+	} ef_data;
+};
+#define EF_DATA_STRUCT_SIZE	sizeof(struct _ef_data_struct)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88279_cmd_list[i].help_ins);
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88279_cmd_list[i].cmd,
+			    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+			       ax88279_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int autosuspend_enable(struct ax_command_info *info,
+			      unsigned char enable)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_AUTOSUSPEND_EN;
+
+	ioctl_cmd.autosuspend.enable = enable;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int read_version(struct ax_command_info *info, char *version)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_VERSION;
+
+	memset(ioctl_cmd.version.version, 0, 16);
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	memcpy(version, ioctl_cmd.version.version, 16);
+
+	return SUCCESS;
+}
+
+static int read_mac_address(struct ax_command_info *info, unsigned char *mac)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ifr->ifr_flags &= 0;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ifr->ifr_flags = IFF_UP | IFF_BROADCAST | IFF_MULTICAST;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ret = ioctl(info->inet_sock, SIOCGIFHWADDR, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	memcpy(mac, ifr->ifr_hwaddr.sa_data, 6);
+
+	return SUCCESS;
+}
+
+static int readversion_func(struct ax_command_info *info)
+{
+	char version[16] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = scan_ax_device(info->ifr, info->inet_sock);
+    if (ret < 0) {
+            PRINT_SCAN_DEV_FAIL;
+            return ret;
+    }
+
+	autosuspend_enable(info, 0);
+
+	ret = read_version(info, version);
+	if (ret == SUCCESS)
+		printf("Firmware Version: %s\n", version);
+
+	usleep(20000);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readmac_func(struct ax_command_info *info)
+{
+	unsigned char mac[6] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = read_mac_address(info, mac);
+	if (ret == SUCCESS)
+		printf("MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			mac[0],
+			mac[1],
+			mac[2],
+			mac[3],
+			mac[4],
+			mac[5]);
+
+	return ret;
+}
+
+static int write_flash(struct ax_command_info *info, unsigned char *data,
+		       unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_WRITE_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH WRITE status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	return SUCCESS;
+}
+
+static int read_flash(struct ax_command_info *info, unsigned char *data,
+		      unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH READ status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_flash(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_FLASH;
+	ioctl_cmd.flash.status = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_sector_flash(struct ax_command_info *info, int offset)
+{
+
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_SECTOR_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int boot_to_rom(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ROOT_2_ROM;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	return SUCCESS;
+}
+
+static int sw_reset(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_SW_RESET;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	usleep(RELOAD_DELAY_TIME * 100000);
+
+	return SUCCESS;
+}
+
+static int find_offest_min_index(int *offset_arr, int size)
+{
+	int i = 0;
+	int min = offset_arr[0];
+
+	for (i = 1; i < size; i++) {
+        if (offset_arr[i] < min) {
+            min = offset_arr[i];
+        }
+    }
+
+	return min;
+}
+
+static int find_offest_max_index(int *offset_arr, int size)
+{
+	int i = 0;
+	int max = offset_arr[0];
+
+	for (i = 1; i < size; i++) {
+		if (offset_arr[i] >= max) {
+				max = i;
+		}
+	}
+
+	return max;
+}
+
+static int writeflash_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *wbuf = NULL, *rbuf = NULL;
+	FILE *pFile = NULL;
+	size_t result;
+	int file_length = 0;
+	int i, offset, ret;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 3) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ret = erase_flash(info);
+	if (ret < 0) 
+		return ret;
+
+	pFile = fopen(info->argv[2], "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, info->argv[2]);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	fseek(pFile, 0, SEEK_END);
+	file_length = ftell(pFile);
+	fseek(pFile, 0, SEEK_SET);
+
+	wbuf = (unsigned char *)malloc((file_length + 256) & ~(0xFF));
+	if (!wbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(wbuf, 0, (file_length + 256) & ~(0xFF));
+
+	result = fread(wbuf, 1, file_length, pFile);
+	if (result != file_length) {
+		PRINT_LOAD_FILE_FAIL;
+		ret = -PRINT_LOAD_FILE_FAIL;
+		goto fail;
+	}
+
+	ret = write_flash(info, wbuf, FLASH_PARA_OFFSET, result);
+	if (ret < 0)
+		goto fail;
+
+	ret = write_flash(info, wbuf, 0, FLASH_PARA_OFFSET);
+	if (ret < 0)
+		goto fail;
+
+	offset = SWAP_32(*(unsigned long *)&wbuf[0]);
+	sprintf(fw_version, "v%d.%d.%d",
+		wbuf[offset + 0x1000],
+		wbuf[offset + 0x1001],
+		wbuf[offset + 0x1002]);
+	printf("File FW Version: %s\n", fw_version);
+	
+	ret = SUCCESS;
+	goto out;
+
+fail:
+	erase_flash(info);
+out:
+	if (wbuf)
+		free(wbuf);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int print_msg(char *cmd)
+{
+	int i;
+
+	printf("\n");
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(cmd, ax88279_cmd_list[i].cmd,
+				strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				ax88279_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+}
+
+static int find_block_index(unsigned char *rpara_databuf, int para_size
+							, enum Para_Type_Def type)
+{
+	int i = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < para_size; i += 20) {
+		if ((rpara_databuf[i] & 0x0F) == type)
+			return i / 20;
+	}
+
+	return -FAIL_GENERIAL_ERROR;
+}
+
+static int change_para_macaddr(unsigned char *rpara_databuf, int block_index, unsigned int *mac)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 6; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5 + i] = (unsigned char)mac[i];
+
+	return SUCCESS;
+}
+
+static int change_para_serialnum(unsigned char *rpara_databuf, int block_index, char *serial)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (serial[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = serial[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_pid(unsigned char *rpara_databuf, int block_index, unsigned int *pid)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 2; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3 + i] = (unsigned char)pid[i];
+
+	return SUCCESS;
+}
+
+static int change_para_vid(unsigned char *rpara_databuf, int block_index, unsigned int *vid)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 2; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = (unsigned char)vid[i];
+
+	return SUCCESS;
+}
+
+static int change_para_productstr(unsigned char *rpara_databuf, int block_index, char *productstr)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (productstr[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = productstr[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_manufacture(unsigned char *rpara_databuf, int block_index, char *manufac)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (manufac[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = manufac[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_ssbus(unsigned char *rpara_databuf, int block_index, int issbus)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 1; i++) 
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 16 + i] = (issbus / 8);
+
+	return SUCCESS;
+}
+
+static int change_para_hsbus(unsigned char *rpara_databuf, int block_index, int ihsbus)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 1; i++) 
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 17 + i] = (ihsbus / 2);
+
+	return SUCCESS;
+}
+
+static int change_para_wol(unsigned char *rpara_databuf, int block_index, char *wol)
+{
+	int i = 0;
+	unsigned int dwolEn = 0;
+	unsigned int s5wolEn = 0;
+	unsigned int pmeEn = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 8; i++) {
+		unsigned char bit_value = 0;
+		bit_value = wol[i] & 1;
+
+		if (i == 0 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] &= ~0x01;
+			break; 
+		}
+		if (i == 1 && bit_value == 1) {
+			pmeEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x10;
+		}
+		if (i == 2 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x1C;
+		}
+		if (i == 3 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x1A;
+		}
+		if (i == 4 && bit_value == 1) {
+			s5wolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x18;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] |= 0x28;
+		}
+		if (i == 5 && bit_value == 1) {
+			s5wolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x18;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] |= 0x18;
+		}
+
+		if (dwolEn || s5wolEn || pmeEn) {
+			if (i == 6 && bit_value == 1) {
+				rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x80;
+			}
+			if (i == 7 && bit_value == 1) {
+				rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x40;
+			}
+
+		}
+	}
+
+	return SUCCESS;
+}
+
+static void set_para_led0(unsigned char *rpara_databuf, int block_index,  unsigned int *led)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3] = 0x24;
+
+	if (led) {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = led[0];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = led[1];
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = led[2];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = led[3];
+	} else {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = 0xC1;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = 0x03;
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = 0x00;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = 0x00;
+	}
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 6] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 7] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 8] = 0x25;
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 18] = 0x45;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 19] = 0x0B;
+
+}
+
+static void set_para_led1(unsigned char *rpara_databuf, int block_index,  unsigned int *led)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3] = 0x26;
+
+	if (led) {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = led[0];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = led[1];
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = led[2];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = led[3];
+	} else {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = 0xC0;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = 0x00;
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = 0x0C;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = 0x0F;
+	}
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 6] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 7] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 8] = 0x27;
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 18] = 0x45;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 19] = 0x0B;
+}
+
+static int program_para_block(struct ax_command_info *info, unsigned char *rpara_databuf, int para_size)
+{
+	int ret;
+
+	ret = write_flash(info, rpara_databuf, 0, para_size);
+	if (ret < 0)
+		return -1;
+	
+	return 0;
+}
+
+static int calculate_para_offset(void *buf)
+{
+	unsigned char *data = (unsigned char *)buf;
+	int offset[8];
+	int len[8];
+	int max;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	offset[0] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW1_OFFSET]);
+	len[0] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW1_LENGTH]);
+	offset[1] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW1_OFFSET]);
+	len[1] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW1_LENGTH]);
+	offset[2] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW1_OFFSET]);
+	len[2] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW1_LENGTH]);
+	offset[3] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW1_OFFSET]);
+	len[3] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW1_LENGTH]);
+	offset[4] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW2_OFFSET]);
+	len[4] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW2_LENGTH]);
+	offset[5] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW2_OFFSET]);
+	len[5] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW2_LENGTH]);
+	offset[6] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW2_OFFSET]);
+	len[6] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW2_LENGTH]);
+	offset[7] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW2_OFFSET]);
+	len[7] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW2_LENGTH]);
+
+	max = find_offest_max_index(offset, 8);
+
+	return (offset[max] + len[max] + 0x10000) & ~(0xFFFF);
+}
+
+void dump(unsigned char *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		printf("%02X ", buf[i]);
+		if (i % 4 == 3)
+			printf("\n");
+	}
+	printf("\n");
+}
+
+static void checksum_efuse_block(unsigned char *block)
+{
+	unsigned int Sum = 0;
+	int j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			Sum += block[j] & 0xF;
+		else
+			Sum += block[j];
+	}
+
+	while (Sum > 0xF)
+		Sum = (Sum & 0xF) + (Sum >> 4);
+
+	Sum = 0xF - Sum;
+
+	block[0] = (block[0] & 0xF) | ((Sum << 4) & 0xF0);
+}
+
+static void checksum_para_header(unsigned short *header)
+{
+	unsigned int Sum = 0;
+	unsigned short j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 5; j++)
+		Sum += header[j];
+
+	while (Sum > 0xFFFF)
+		Sum = (Sum & 0xFFFF) + (Sum >> 16);
+
+	Sum = 0xFFFF - Sum;
+
+	header[5] = (Sum);
+}
+
+static int check_hex(char *temp, int size)
+{
+	int i = 0;
+	unsigned char *ptemp = temp;
+
+	for (i = 0; i < size; i++) {
+		if (ptemp[i] == ':') {
+			i++;
+			continue;
+		}
+		
+		if(!(isxdigit(ptemp[i])))
+			return -FAIL_INVALID_PARAMETER;
+	}
+
+	return 0;
+}
+
+static int check_led_parameter(char *led)
+{
+	if (!led)
+		return 1;
+
+	if (strlen(led) != 9 || led[4] != '_')
+		return 1;
+	do {
+		if (*led++ == '_')
+			continue;
+		if (!isxdigit(*led++))
+			return 1;
+	} while (*led);
+
+	return 0;
+}
+
+static int writeparameter_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *rpara_buf = NULL;
+	int para_offset, block_count, para_size, ret, block_index, c, i;
+	int oi = -1;
+	struct __wpara argument = {0};
+	int temp_para_offset = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"m:s:p:v:P:M:D:S:H:w:l:e:d:",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'm':
+			argument.mac_address = optarg;
+			DEBUG_PRINT("%s \r\n", argument.mac_address);
+			i = sscanf(argument.mac_address,
+				   "%02X:%02X:%02X:%02X:%02X:%02X",
+				   (unsigned int *)&argument.MAC[0],
+				   (unsigned int *)&argument.MAC[1],
+				   (unsigned int *)&argument.MAC[2],
+				   (unsigned int *)&argument.MAC[3],
+				   (unsigned int *)&argument.MAC[4],
+				   (unsigned int *)&argument.MAC[5]);
+			if (i != 6)
+				return print_msg("wpara");
+			break;
+		case 's':
+			argument.serial_num = optarg;
+			DEBUG_PRINT("%s \r\n", argument.serial_num);
+			if (strlen(argument.serial_num) > 18) {
+				printf("characters must be less than 19 bytes\n");
+				return print_msg("wpara");
+			}
+			break;
+		case 'p':
+			argument.PID = optarg;
+			DEBUG_PRINT("%s \r\n", argument.PID);
+			i = sscanf(argument.PID,
+				   "%02X:%02X",
+				   (unsigned int *)&argument.pid[0],
+				   (unsigned int *)&argument.pid[1]);
+			if (i != 2)
+				return print_msg("wpara");
+			break;
+		case 'v':
+			argument.VID = optarg;
+			DEBUG_PRINT("%s \r\n", argument.VID);
+			i = sscanf(argument.VID,
+				   "%02X:%02X",
+				   (unsigned int *)&argument.vid[0],
+				   (unsigned int *)&argument.vid[1]);
+			if (i != 2)
+				return print_msg("wpara");
+			break;
+		case 'P':
+			argument.product_string = optarg;
+			DEBUG_PRINT("%s \r\n", argument.product_string);
+			if (strlen(argument.product_string) > 18)
+				return print_msg("wpara");
+			break;
+		case 'D':
+			argument.dump = optarg;
+			DEBUG_PRINT("%s \r\n", argument.dump);
+			if (strcasecmp(argument.dump , "dump"))
+				return print_msg("wpara");
+			break;
+		case 'M':
+			argument.manufacture = optarg;
+			DEBUG_PRINT("%s \r\n", argument.manufacture);
+			if (strlen(argument.manufacture) > 18)
+				return print_msg("wpara");
+			break;
+		case 'S':
+			argument.ss_bus = optarg;
+			argument.iss_bus = atoi(argument.ss_bus);
+			DEBUG_PRINT("%s \r\n", argument.ss_bus);
+			break;
+		case 'H':
+			argument.hs_bus = optarg;
+			argument.ihs_bus = atoi(argument.hs_bus);
+			DEBUG_PRINT("%s \r\n", argument.hs_bus);
+			break;
+		case 'w':
+			argument.wol = optarg;
+			DEBUG_PRINT("%s \r\n", argument.wol);
+			break;
+		case 'l':
+			argument.led0 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led0);
+			i = sscanf(argument.led0,
+				   "%02X%02X_%02X%02X",
+				   (unsigned int *)&argument.LED0[0],
+				   (unsigned int *)&argument.LED0[1],
+				   (unsigned int *)&argument.LED0[2],
+				   (unsigned int *)&argument.LED0[3]);
+			break;
+		case 'e':
+			argument.led1 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led1);
+			i = sscanf(argument.led1,
+				   "%02X%02X_%02X%02X",
+				   (unsigned int *)&argument.LED1[0],
+				   (unsigned int *)&argument.LED1[1],
+				   (unsigned int *)&argument.LED1[2],
+				   (unsigned int *)&argument.LED1[3]);
+			break;
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	rpara_buf = (unsigned char *)malloc((FLASH_SIZE + 256) & ~(0xFF));
+	if (!rpara_buf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(rpara_buf, 0xFF, (FLASH_SIZE + 256) & ~(0xFF));
+
+	ret = read_flash(info, rpara_buf, 0, 0x3000);
+	if (ret < 0)
+		goto fail;
+
+	//temp_para_offset = calculate_para_offset(rpara_buf);
+
+	if (*(unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET] != 0xA55A) {
+		//printf("Not 0xA55A, use sample\n");
+		para_offset = 0x3000;
+		block_count = 0;
+	} else {
+		para_offset = SWAP_32(*(unsigned long *)&rpara_buf[PARAMETER_PRI_OFFSET]);
+		block_count = SWAP_16(*(unsigned short *)&rpara_buf[PARAMETER_PRI_BLOCK_COUNT]);
+	}
+
+	para_size = 0;
+	if (block_count) {
+		para_size = block_count * FLASH_BLOCK_SIZE;
+		ret = read_flash(info, rpara_buf, para_offset, para_size);
+		if (ret < 0)
+			goto fail;
+	}
+
+	block_index = -FAIL_GENERIAL_ERROR;
+	if (argument.mac_address) {
+		if(check_hex(argument.mac_address, 17) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.mac_address) != 17) {
+			printf("FAIL: MAC address should be 6 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_macaddr(&rpara_buf[para_offset], block_index, argument.MAC);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing MAC address failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.serial_num) {
+		if(check_hex(argument.serial_num, strlen(argument.serial_num)) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_04);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type4, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_serialnum(&rpara_buf[para_offset], block_index, argument.serial_num);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing serial number failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.PID) {
+		if(check_hex(argument.PID, 5) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.PID) != 5) {
+			printf("FAIL: PID be 2 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_pid(&rpara_buf[para_offset], block_index, argument.pid);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing PID failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.VID) {
+		if(check_hex(argument.VID, 5) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.VID) != 5) {
+			printf("FAIL: VID be 2 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_vid(&rpara_buf[para_offset], block_index, argument.vid);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing VID failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.product_string) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_03);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type3, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_productstr(&rpara_buf[para_offset], block_index, argument.product_string);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing Product String failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.manufacture) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_02);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type2, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_manufacture(&rpara_buf[para_offset], block_index, argument.manufacture);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing manufacture failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.ss_bus) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		if (argument.iss_bus > 896)	{
+			printf("FAIL: The value is between 0-896\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_ssbus(&rpara_buf[para_offset], block_index, argument.iss_bus);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing SS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.hs_bus) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		if (argument.ihs_bus > 500)	{
+			printf("FAIL: The value is between 0-500\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_hsbus(&rpara_buf[para_offset], block_index, argument.ihs_bus);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing HS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.wol) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_15);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type15, 20);
+			para_size += 20;
+		}
+
+		if (strlen(argument.wol) > 8)	{
+			printf("FAIL: The value must be 8 digit\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_wol(&rpara_buf[para_offset], block_index, argument.wol);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing HS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.led0) {
+	/*	if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_11);*/
+	//	if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type11, 20);
+			para_size += 20;
+	//	}
+		if (check_led_parameter(argument.led0)) {
+			printf("FAIL: The value invaild.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		set_para_led0(&rpara_buf[para_offset], block_index, argument.LED0);
+
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.led1) {
+	/*	if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_11);*/
+		//if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type11, 20);
+			para_size += 20;
+		//}
+		if (check_led_parameter(argument.led1)) {
+			printf("FAIL: The value invaild.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		set_para_led1(&rpara_buf[para_offset], block_index, argument.LED1);
+		
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.dump) {
+		int i = 0;
+		unsigned char buf[32 * 20];
+		if (para_size == 0) {
+			printf("\nThe parameter content currently in flash has no data\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+		printf("\nDump the parameter content currently in flash as parameter.txt file\n");
+
+		FILE *file = fopen("parameter.txt", "w");
+		if (file == NULL) {
+			perror("Error opening file");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		for (i = 0; i < para_size; i++) {
+			buf[i] = rpara_buf[para_offset + i];
+		}
+
+		for (i = 0; i < para_size; i++) {
+			fprintf(file, "%02X", buf[i]);
+
+			if(((i + 1) % 4 == 0))
+				fprintf(file, "\n");
+			else
+				fprintf(file, " ");
+		}
+
+		fclose(file);
+
+		dump(&rpara_buf[para_offset], para_size);
+	}
+
+	erase_sector_flash(info, PARAMETER_PRI_HEADER_OFFSET);
+	erase_sector_flash(info, para_offset);
+
+
+	if (*(unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET] != 0xA55A) {
+		//printf("Not 0xA55A, create header\n");
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET] = 0x5A;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 1] = 0xA5;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 2] = 0x04;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 3] = 0;
+	}
+	*(unsigned int *)&rpara_buf[PARAMETER_PRI_OFFSET] = SWAP_32(para_offset);
+	*(unsigned short *)&rpara_buf[PARAMETER_PRI_BLOCK_COUNT] = SWAP_16(para_size / 20);
+	checksum_para_header((unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET]);
+
+	write_flash(info, rpara_buf, PARAMETER_PRI_HEADER_OFFSET, 256);
+	write_flash(info, rpara_buf, para_offset, para_size);
+
+	sw_reset(info);
+fail:
+	if (rpara_buf)
+		free(rpara_buf);
+
+	return 0;
+}
+
+static int reload_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		int i;
+
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	autosuspend_enable(info, 0);
+
+	sw_reset(info);
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+			tmp = tmp->ifa_next;
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret = -FAIL_GENERIAL_ERROR;
+
+	//printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#ifndef NOT_PROGRAM 
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+#endif
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88279_cmd_list[i].cmd,
+			    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88279_cmd_list[i].help_ins;
+			info.help_desc = ax88279_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88279_cmd_list[i].ioctl_cmd;
+			ret = (ax88279_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88279_cmd_list[i].cmd == NULL) {
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax_ioctl.h b/drivers/net/usb/asix_usb/ax_ioctl.h
new file mode 100755
index 000000000000..f8321ddaf5a6
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ioctl.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_IOCTL_H
+#define __ASIX_IOCTL_H
+
+#ifdef ENABLE_IOCTL_DEBUG
+#define DEBUG_PRINT(fmt, args...) printf(fmt, ## args)
+#define DEBUG_PRINTK(fmt, args...) printk(fmt, ## args)
+#else
+#define DEBUG_PRINT(fmt, args...)
+#define DEBUG_PRINTK(fmt, args...)
+#endif
+
+// CHANGE NETWORK INTERFACE WAY
+// DEFAULT_SCAN   : scan "eth0" - "eth255"
+// INTERFACE_SCAN : scan all available network interfaces
+#define NET_INTERFACE	INTERFACE_SCAN
+#define DEFAULT_SCAN	0x00
+#define INTERFACE_SCAN	0x01
+
+#define AX88179_SIGNATURE	"AX88179_178A"
+#define AX88179_DRV_NAME	"AX88179_178A"
+#define AX88179A_SIGNATURE	"AX88179B_179A_772E_772D"
+#define AX88179A_DRV_NAME	"AX88179B_179A_772E_772D"
+
+#define AX_PRIVATE		SIOCDEVPRIVATE
+
+#define AX_SIGNATURE			0
+#define AX_USB_COMMAND			1
+#define AX88179_READ_EEPROM		2
+#define AX88179_WRITE_EEPROM		3
+#define AX88179A_READ_VERSION		2
+#define AX88179A_WRITE_FLASH		3
+#define AX88179A_ROOT_2_ROM		4
+#define AX88179A_ERASE_FLASH		5
+#define AX88179A_SW_RESET		6
+#define AX88179A_READ_FLASH		7
+#define AX88179A_PROGRAM_EFUSE		8
+#define AX88179A_DUMP_EFUSE		9
+#define AX88179A_IEEE_TEST		10
+#define AX88179A_AUTOSUSPEND_EN		11
+#define AX88179A_ERASE_SECTOR_FLASH	12
+
+#define IEEE_1000M1			0
+#define IEEE_1000M2			1
+#define IEEE_1000M3			2
+#define IEEE_1000M4			3
+#define IEEE_100CA			4
+#define IEEE_100CB			5
+#define IEEE_10R			6
+#define IEEE_10FF			7
+#define IEEE_10MDI			8
+
+#define ERR_FALSH_WRITE_EN		1
+#define ERR_FALSH_WRITE_DIS		2
+#define ERR_FALSH_ERASE_ALL		3
+#define ERR_FALSH_WRITE			4
+#define ERR_FALSH_READ			5
+#define ERR_EFUSE_READ			6
+#define ERR_EFUSE_WRITE			7
+#define ERR_IEEE_INVALID_CHIP		8
+#define ERR_BOOT_CODE			9
+#define ERR_FALSH_ERASE_SECTOR	10
+
+#define USB_READ_OPS			0
+#define USB_WRITE_OPS			1
+
+#define SCAN_DEV_MAX_RETRY		10
+
+#define FLASH_BLOCK_SIZE	20 //bytes
+#define WRITE_PARA_HEADER 0x2100
+#define FLASH_SIZE (16*1024*1024)
+#define FLASH_PARA_OFFSET 8448
+
+#define PRAM_PRI_FW1_OFFSET 0x0
+#define PRAM_PRI_FW1_LENGTH 0x4
+#define MD32_PRI_FW1_OFFSET 0x14
+#define MD32_PRI_FW1_LENGTH 0x18
+
+#define PRAM_SEC_FW1_OFFSET 0x28
+#define PRAM_SEC_FW1_LENGTH 0x2C
+#define MD32_SEC_FW1_OFFSET 0x3C
+#define MD32_SEC_FW1_LENGTH 0x40
+
+#define PRAM_PRI_FW2_OFFSET 0x1000
+#define PRAM_PRI_FW2_LENGTH 0x1004
+#define MD32_PRI_FW2_OFFSET 0x1014
+#define MD32_PRI_FW2_LENGTH 0x1018
+
+#define PRAM_SEC_FW2_OFFSET 0x1028
+#define PRAM_SEC_FW2_LENGTH 0x102C
+#define MD32_SEC_FW2_OFFSET 0x103C
+#define MD32_SEC_FW2_LENGTH 0x1040
+
+#define PARAMETER_PRI_HEADER_OFFSET 0x2000
+#define PARAMETER_SEC_HEADER_OFFSET 0x200C
+
+#define PARAMETER_PRI_OFFSET 0x2004
+#define PARAMETER_PRI_BLOCK_COUNT 0x2008
+#define PARAMETER_SEC_OFFSET 0x2010
+#define PARAMETER_SEC_BLOCK_COUNT 0x2014
+
+
+enum _exit_code {
+	SUCCESS			= 0,
+	FAIL_INVALID_PARAMETER	= 1,
+	FAIL_IOCTL,
+	FAIL_SCAN_DEV,
+	FAIL_ALLCATE_MEM,
+	FAIL_LOAD_FILE,
+	FAIL_FLASH_WRITE,
+	FAIL_IVALID_VALUE,
+	FAIL_IVALID_CHKSUM,
+	FAIL_NON_EMPTY_RFUSE_BLOCK,
+	FAIL_EFUSE_WRITE,
+	FAIL_GENERIAL_ERROR,
+};
+
+struct _ax_usb_command {
+	unsigned char	ops;
+	unsigned char	cmd;
+	unsigned short	value;
+	unsigned short	index;
+	unsigned short	size;
+	unsigned char	*data;
+	unsigned long	cmd_data;
+};
+
+struct _ax88179a_flash {
+	int status;
+	int length;
+	int offset;
+	unsigned char *buf;
+};
+
+struct _ax88179a_version {
+	unsigned char version[16];
+};
+
+struct _ax88179a_ieee {
+	unsigned int type;
+	unsigned int speed;
+	unsigned int stop;
+	int status;
+};
+
+struct _ax88179a_autosuspend {
+	unsigned int enable;
+};
+
+struct _ax_ioctl_command {
+	unsigned short	ioctl_cmd;
+	unsigned char	sig[32];
+	unsigned char	type;
+	unsigned short *buf;
+	unsigned short size;
+	unsigned char delay;
+	union {
+		struct _ax88179a_flash		flash;
+		struct _ax88179a_version	version;
+		struct _ax88179a_ieee		ieee;
+		struct _ax_usb_command		usb_cmd;
+		struct _ax88179a_autosuspend	autosuspend;
+	};
+};
+
+#define SWAP_32(val)	(((val >> 24) & 0x000000FF) | \
+			 ((val >>  8) & 0x0000FF00) | \
+			 ((val <<  8) & 0x00FF0000) | \
+			 ((val << 24) & 0xFF000000))
+#define SWAP_16(val)    ((val >> 8) & 0x00FF) | \
+                         ((val <<  8) & 0xFF00)
+
+struct ax_device;
+typedef int (*IOCTRL_TABLE)(struct ax_device *axdev,
+			    struct _ax_ioctl_command *info);
+
+struct ax_command_info {
+	int inet_sock;
+	struct ifreq *ifr;
+	int argc;
+	char **argv;
+	unsigned short ioctl_cmd;
+	const char *help_ins;
+	const char *help_desc;
+};
+
+typedef int (*MENU_FUNC)(struct ax_command_info *info);
+
+struct _command_list {
+	char *cmd;
+	unsigned short ioctl_cmd;
+	MENU_FUNC OptFunc;
+	const char *help_ins;
+	const char *help_desc;
+};
+
+#endif /* __ASIX_IOCTL_H */
diff --git a/drivers/net/usb/asix_usb/ax_main.c b/drivers/net/usb/asix_usb/ax_main.c
new file mode 100755
index 000000000000..ab8d1a9b0d9e
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_main.c
@@ -0,0 +1,2620 @@
+q// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179_178a.h"
+#include "ax88179a_772d.h"
+#ifdef ENABLE_PTP_FUNC
+#include "ax_ptp.h"
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+#include "ax_macsec.h"
+#endif
+
+#ifdef ENABLE_AUTODETACH_FUNC
+static int autodetach = -1;
+module_param(autodetach, int, 0);
+MODULE_PARM_DESC(autodetach, "Autodetach configuration");
+#endif
+
+static int bctrl = -1;
+module_param(bctrl, int, 0);
+MODULE_PARM_DESC(bctrl, "RX Bulk Control");
+
+static int blwt = -1;
+module_param(blwt, int, 0);
+MODULE_PARM_DESC(blwt, "RX Bulk Timer Low");
+
+static int bhit = -1;
+module_param(bhit, int, 0);
+MODULE_PARM_DESC(bhit, "RX Bulk Timer High");
+
+static int bsize = -1;
+module_param(bsize, int, 0);
+MODULE_PARM_DESC(bsize, "RX Bulk Queue Size");
+
+static int bifg = -1;
+module_param(bifg, int, 0);
+MODULE_PARM_DESC(bifg, "RX Bulk Inter Frame Gap");
+
+static int
+ax_submit_rx(struct ax_device *netdev, struct rx_desc *desc, gfp_t mem_flags);
+static void ax_set_carrier(struct ax_device *axdev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	strscpy(info->driver, MODULENAME, sizeof(info->driver));
+	strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(axdev->udev, info->bus_info, sizeof(info->bus_info));
+
+	sprintf(info->fw_version, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+}
+#else
+static size_t ax_strscpy(char *dest, const char *src, size_t size)
+{
+	size_t len = strnlen(src, size) + 1;
+	if(len > size) {
+		if (size)
+			dest[0] = '\0';
+		return 0;
+	}
+	memcpy(dest, src, len);
+	return len;
+}
+
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	ax_strscpy(info->driver, MODULENAME, sizeof(info->driver));
+	ax_strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(axdev->udev, info->bus_info, sizeof(info->bus_info));
+
+	sprintf(info->fw_version, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+}	
+#endif
+
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+int ax_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	if (!axdev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_gset(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+
+int ax_set_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_sset(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+#else
+int ax_get_link_ksettings(struct net_device *netdev,
+			  struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	if (!axdev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_get_link_ksettings(&axdev->mii, cmd);
+
+#ifdef ENABLE_AX88279
+	printk("============AX88279==========");
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 cmd->link_modes.supported, 1);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 1);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising,
+				 1);
+#else
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 cmd->link_modes.supported);
+
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.advertising);
+
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising);
+#endif
+		if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500)
+			cmd->base.speed = SPEED_2500;
+	}
+#endif
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+
+int ax_set_link_ksettings(struct net_device *netdev,
+			  const struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_set_link_ksettings(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+#endif
+u32 ax_get_msglevel(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	return axdev->msg_enable;
+}
+
+void ax_set_msglevel(struct net_device *netdev, u32 value)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	axdev->msg_enable = value;
+}
+
+void ax_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 reg8;
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE,
+			  1, 1, &reg8, 0);
+	if (ret < 0) {
+		wolinfo->supported = 0;
+		wolinfo->wolopts = 0;
+		return;
+	}
+
+	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
+
+	if (reg8 & AX_MONITOR_MODE_RWLC)
+		wolinfo->wolopts |= WAKE_PHY;
+	if (reg8 & AX_MONITOR_MODE_RWMP)
+		wolinfo->wolopts |= WAKE_MAGIC;
+}
+
+int ax_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 reg8 = 0;
+	int ret;
+
+	if (wolinfo->wolopts & WAKE_PHY)
+		reg8 |= AX_MONITOR_MODE_RWLC;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWLC;
+
+	if (wolinfo->wolopts & WAKE_MAGIC)
+		reg8 |= AX_MONITOR_MODE_RWMP;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWMP;
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const char ax_gstrings[][ETH_GSTRING_LEN] = {
+	"tx_packets",
+	"rx_packets",
+	"tx_bytes",
+	"rx_bytes",
+	"tx_dropped",
+	"rx_length_errors",
+	"rx_crc_errors",
+	"rx_dropped",
+	"buikin_complete",
+	"bulkin_error",
+	"bulkout_complete",
+	"bulkout_error",
+	"bulkint_complete",
+	"bulkint_error",
+#ifdef ENABLE_QUEUE_PRIORITY
+	"ep5_count",
+	"ep3_count",
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	"macsec_rx_in_pkts",
+	"macsec_rx_out_pkts",
+	"macsec_rx_ain_dec_pkts",
+	"macsec_rx_ain_byp_pkts",
+	"macsec_rx_ain_drp_pkts",
+	"macsec_rx_icv_fail_pkts",
+	"macsec_rx_icv_pass_pkts",
+	"macsec_rx_ctl",
+	"macsec_rx_untag",
+	"macsec_rx_sc",
+	"macsec_rx_nosc",
+	"macsec_rx_sc_null",
+	"macsec_rx_sc_untag",
+	"macsec_rx_sc_invalid_tag",
+	"macsec_rx_sc_nosc",
+	"macsec_rx_sc_dis",
+	"macsec_rx_sc_dec",
+	"macsec_tx_in_pkts",
+	"macsec_tx_out_pkts",
+	"macsec_tx_untag_pkts",
+	"macsec_tx_too_long_pkts",
+	"macsec_tx_enc_pkts",
+	"macsec_tx_byp_pkts",
+	"macsec_tx_drp_pkts",
+	"macsec_tx_ctl",
+	"macsec_tx_sc",
+	"macsec_tx_nosc",
+#endif
+};
+
+int ax_get_sset_count(struct net_device *netdev, int sset)
+{
+#ifdef ENABLE_MACSEC_FUNC
+	struct ax_device *axdev = netdev_priv(netdev);
+#endif
+	switch (sset) {
+	case ETH_SS_STATS:
+#ifdef ENABLE_MACSEC_FUNC
+		if (axdev->chip_version >= AX_VERSION_AX88279)
+			return ARRAY_SIZE(ax_gstrings);
+		else
+			return ARRAY_SIZE(ax_gstrings) - 27;
+#else
+		return ARRAY_SIZE(ax_gstrings);
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+void ax_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
+{
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(data, ax_gstrings, sizeof(ax_gstrings));
+		break;
+	}
+}
+
+void ax_get_ethtool_stats(struct net_device *netdev,
+			  struct ethtool_stats *stats, u64 *data)
+{
+	struct net_device_stats *net_stats = ax_get_stats(netdev);
+	struct ax_device *axdev = netdev_priv(netdev);
+	u64 *temp = data;
+
+	*temp++ = net_stats->tx_packets;
+	*temp++ = net_stats->rx_packets;
+	*temp++ = net_stats->tx_bytes;
+	*temp++ = net_stats->rx_bytes;
+	*temp++ = net_stats->tx_dropped;
+	*temp++ = net_stats->rx_length_errors;
+	*temp++ = net_stats->rx_crc_errors;
+	*temp++ = net_stats->rx_dropped;
+	*temp++ = axdev->bulkin_complete;
+	*temp++ = axdev->bulkin_error;
+	*temp++ = axdev->bulkout_complete;
+	*temp++ = axdev->bulkout_error;
+	*temp++ = axdev->bulkint_complete;
+	*temp++ = axdev->bulkint_error;
+#ifdef ENABLE_QUEUE_PRIORITY
+	*temp++ = axdev->ep5_count;
+	*temp++ = axdev->ep3_count;
+#endif
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->chip_version >= AX_VERSION_AX88279) {
+		u32 *macsec_dbg_count;
+		int i;
+
+		ax_get_rx_dbg_count(axdev);
+		ax_get_tx_dbg_count(axdev);
+		macsec_dbg_count = (u32 *)&axdev->macsec_cfg->rx_dbg_count;
+		for (i = 0; i < (AX_MACSEC_RX_DBG_CNT_SIZE / sizeof(u32)); i++)
+			*temp++ = macsec_dbg_count[i];
+		macsec_dbg_count = (u32 *)&axdev->macsec_cfg->tx_dbg_count;
+		for (i = 0; i < (AX_MACSEC_TX_DBG_CNT_SIZE / sizeof(u32)); i++)
+			*temp++ = macsec_dbg_count[i];
+	}
+#endif
+#endif
+}
+
+void ax_get_pauseparam(struct net_device *netdev,
+		       struct ethtool_pauseparam *pause)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 bmcr, lcladv, rmtadv;
+	u8 cap;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return;
+
+	bmcr = ax_mdio_read(netdev, axdev->mii.phy_id, MII_BMCR);
+	lcladv = ax_mdio_read(netdev, axdev->mii.phy_id, MII_ADVERTISE);
+	rmtadv = ax_mdio_read(netdev, axdev->mii.phy_id, MII_LPA);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	if (!(bmcr & BMCR_ANENABLE)) {
+		pause->autoneg = 0;
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+		return;
+	}
+
+	pause->autoneg = 1;
+
+	cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
+
+	if (cap & FLOW_CTRL_RX)
+		pause->rx_pause = 1;
+
+	if (cap & FLOW_CTRL_TX)
+		pause->tx_pause = 1;
+}
+
+int ax_set_pauseparam(struct net_device *netdev,
+		      struct ethtool_pauseparam *pause)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 old, new1, bmcr;
+	u8 cap = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	bmcr = ax_mdio_read(netdev, axdev->mii.phy_id, MII_BMCR);
+	if (pause->autoneg && !(bmcr & BMCR_ANENABLE)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pause->rx_pause)
+		cap |= FLOW_CTRL_RX;
+
+	if (pause->tx_pause)
+		cap |= FLOW_CTRL_TX;
+
+	old = ax_mdio_read(netdev, axdev->mii.phy_id, MII_ADVERTISE);
+	new1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) |
+		mii_advertise_flowctrl(cap);
+	if (old != new1)
+		ax_mdio_write(netdev, axdev->mii.phy_id, MII_ADVERTISE, new1);
+
+	mii_nway_restart(&axdev->mii);
+out:
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+int ax_get_regs_len(struct net_device *netdev)
+{
+	return 256;
+}
+
+void ax_get_regs(struct net_device *netdev,
+		 struct ethtool_regs *regs, void *buf)
+{
+	u8 *data = (u8 *)buf;
+	int i;
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	for (i = 0; i < 256; i++)
+		ax_read_cmd(axdev, AX_ACCESS_MAC, i, 1, 1, &data[i], 0);
+}
+
+static int __ax_usb_read_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			     u16 value, u16 index, void *data, u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (size) {
+		buf = kzalloc(size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	}
+
+	err = usb_control_msg(axdev->udev, usb_rcvctrlpipe(axdev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_GET_TIMEOUT);
+	if (err > 0 && err <= size) {
+		if (data)
+			memcpy(data, buf, err);
+		else
+			netdev_dbg(axdev->netdev,
+				   "Huh? Data requested but thrown away.\n");
+	}
+
+	kfree(buf);
+out:
+	return err;
+}
+
+static int __ax_usb_write_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			      u16 value, u16 index, const void *data, u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (data) {
+		buf = kmemdup(data, size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	} else {
+		if (size) {
+			WARN_ON_ONCE(1);
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	err = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_SET_TIMEOUT);
+	kfree(buf);
+
+out:
+	return err;
+}
+
+static int __ax_read_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			 u16 value, u16 index, void *data, u16 size)
+{
+	int ret;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return -ENODEV;
+
+	ret = __ax_usb_read_cmd(axdev, cmd, reqtype, value, index,
+				data, size);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+static int __ax_write_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			  u16 value, u16 index, const void *data, u16 size)
+{
+	int ret;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return -ENODEV;
+
+	ret = __ax_usb_write_cmd(axdev, cmd, reqtype, value, index,
+				 data, size);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+static int __ax_read_cmd_nopm(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			      u16 value, u16 index, void *data, u16 size)
+{
+	return __ax_usb_read_cmd(axdev, cmd, reqtype, value, index,
+				 data, size);
+}
+
+static int __ax_write_cmd_nopm(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			       u16 value, u16 index, const void *data,
+			       u16 size)
+{
+	return __ax_usb_write_cmd(axdev, cmd, reqtype, value, index,
+				  data, size);
+}
+
+static int __asix_read_cmd(struct ax_device *axdev, u8 cmd, u16 value,
+			   u16 index, u16 size, void *data, int in_pm)
+{
+	int ret;
+	_usb_read_function fn;
+
+	if (!in_pm)
+		fn = __ax_read_cmd;
+	else
+		fn = __ax_read_cmd_nopm;
+
+	ret = fn(axdev, cmd, USB_DIR_IN | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
+
+	if (unlikely(ret < 0))
+		dev_warn(&axdev->intf->dev,
+			 "Failed to read reg %04X_%04X_%04X_%04X (err %d)",
+			 cmd, value, index, size, ret);
+
+	return ret;
+}
+
+static int __asix_write_cmd(struct ax_device *axdev, u8 cmd, u16 value,
+			    u16 index, u16 size, void *data, int in_pm)
+{
+	int ret;
+	_usb_write_function fn;
+
+	if (!in_pm)
+		fn = __ax_write_cmd;
+	else
+		fn = __ax_write_cmd_nopm;
+
+	ret = fn(axdev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
+
+	if (unlikely(ret < 0))
+		dev_warn(&axdev->intf->dev,
+			 "Failed to write reg %04X_%04X_%04X_%04X (err %d)",
+			 cmd, value, index, size, ret);
+
+	return ret;
+}
+
+int ax_read_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
+		     u16 index, u16 size, void *data, int eflag)
+{
+	int ret;
+
+	if (eflag && (size == 2)) {
+		u16 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 1);
+		le16_to_cpus(&buf);
+		*((u16 *)data) = buf;
+	} else if (eflag && (size == 4)) {
+		u32 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 1);
+		le32_to_cpus(&buf);
+		*((u32 *)data) = buf;
+	} else {
+		ret = __asix_read_cmd(dev, cmd, value, index, size, data, 1);
+	}
+
+	return ret;
+}
+
+int ax_write_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
+		      u16 index, u16 size, void *data)
+{
+	int ret;
+
+	if (size == 2) {
+		u16 buf = 0;
+
+		buf = *((u16 *)data);
+		cpu_to_le16s(&buf);
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					  size, &buf, 1);
+	} else {
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					  size, data, 1);
+	}
+
+	return ret;
+}
+
+int ax_read_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index, u16 size,
+		void *data, int eflag)
+{
+	int ret;
+
+	if (eflag && (size == 2)) {
+		u16 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 0);
+		le16_to_cpus(&buf);
+		*((u16 *)data) = buf;
+	} else if (eflag && (size == 4)) {
+		u32 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 0);
+		le32_to_cpus(&buf);
+		*((u32 *)data) = buf;
+	} else {
+		ret = __asix_read_cmd(dev, cmd, value, index, size, data, 0);
+	}
+
+	return ret;
+}
+
+int ax_write_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index, u16 size,
+		 void *data)
+{
+	int ret;
+
+	if (size == 2) {
+		u16 buf = 0;
+
+		buf = *((u16 *)data);
+		cpu_to_le16s(&buf);
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					size, &buf, 0);
+	} else {
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					size, data, 0);
+	}
+
+	return ret;
+}
+
+#if KERNEL_VERSION(2, 6, 20) > LINUX_VERSION_CODE
+static void ax_async_write_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax_async_write_callback(struct urb *urb)
+#endif
+{
+	struct _async_cmd_handle *asyncdata = (typeof(asyncdata))urb->context;
+
+	if (urb->status < 0)
+		dev_err(&asyncdata->axdev->intf->dev,
+			"ax_async_write_callback() failed with %d",
+			urb->status);
+
+	kfree(asyncdata->req);
+	kfree(asyncdata);
+	usb_free_urb(urb);
+}
+
+int ax_write_cmd_async(struct ax_device *axdev, u8 cmd, u16 value, u16 index,
+		       u16 size, void *data)
+{
+	struct usb_ctrlrequest *req = NULL;
+	int status = 0;
+	struct urb *urb = NULL;
+	void *buf = NULL;
+	struct _async_cmd_handle *asyncdata = NULL;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		netdev_err(axdev->netdev,
+			   "Error allocating URB in %s!", __func__);
+		return -ENOMEM;
+	}
+
+	req = kzalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+	if (!req) {
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	asyncdata = kzalloc(sizeof(struct _async_cmd_handle), GFP_ATOMIC);
+	if (asyncdata == NULL) {
+		kfree(req);
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	asyncdata->req = req;
+	asyncdata->axdev = axdev;
+
+	if (size == 2) {
+		asyncdata->rxctl = *((u16 *)data);
+		cpu_to_le16s(&asyncdata->rxctl);
+		buf = &asyncdata->rxctl;
+	} else {
+		memcpy(asyncdata->m_filter, data, size);
+		buf = asyncdata->m_filter;
+	}
+
+	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = cmd;
+	req->wValue = cpu_to_le16(value);
+	req->wIndex = cpu_to_le16(index);
+	req->wLength = cpu_to_le16(size);
+
+	usb_fill_control_urb(urb, axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			     (void *)req, buf, size, ax_async_write_callback,
+			     asyncdata);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		netdev_err(axdev->netdev,
+			   "Error submitting the control message: status=%d",
+			   status);
+		kfree(req);
+		kfree(asyncdata);
+		usb_free_urb(urb);
+	}
+
+	return status;
+}
+
+int ax_mmd_read(struct net_device *netdev, int dev_addr, int reg)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = 0;
+
+	ax_read_cmd(axdev, AX88179A_PHY_CLAUSE45, (__u16)dev_addr,
+		    (__u16)reg, 2, &res, 1);
+
+	return res;
+}
+
+void ax_mmd_write(struct net_device *netdev, int dev_addr, int reg, int val)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = (u16)val;
+
+	ax_write_cmd(axdev, AX88179A_PHY_CLAUSE45, (__u16)dev_addr,
+		     (__u16)reg, 2, &res);
+}
+
+int ax_mdio_read(struct net_device *netdev, int phy_id, int reg)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res, 1);
+
+	return res;
+}
+
+void ax_mdio_write(struct net_device *netdev, int phy_id, int reg, int val)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = (u16)val;
+
+	ax_write_cmd_nopm(axdev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res);
+}
+
+static void ax_set_unplug(struct ax_device *axdev)
+{
+	if (axdev->udev->state == USB_STATE_NOTATTACHED)
+		set_bit(AX_UNPLUG, &axdev->flags);
+}
+
+static int ax_check_tx_queue_not_empty(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = (AX_TX_QUEUE_SIZE - 1); i >= 0; i--)
+		if (!skb_queue_empty(&axdev->tx_queue[i]))
+			return i;
+
+	return -1;
+}
+
+static bool ax_check_tx_queue_len(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++)
+		if (skb_queue_len(&axdev->tx_queue[i]) > axdev->tx_qlen)
+			return true;
+
+	return false;
+}
+
+static void ax_read_bulk_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	int status = urb->status;
+	struct rx_desc *desc;
+	struct ax_device *axdev;
+
+	desc = urb->context;
+	if (!desc)
+		return;
+
+	axdev = desc->context;
+	if (!axdev)
+		return;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	netdev = axdev->netdev;
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(axdev->udev);
+
+	if (status)
+		axdev->bulkin_error++;
+	else
+		axdev->bulkin_complete++;
+
+	switch (status) {
+	case 0:
+		if (urb->actual_length < ETH_ZLEN)
+			break;
+
+		spin_lock(&axdev->rx_lock);
+		list_add_tail(&desc->list, &axdev->rx_done);
+		spin_unlock(&axdev->rx_lock);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&axdev->rx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+		return;
+	case -ESHUTDOWN:
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+		return;
+	case -ENOENT:
+		return;
+	case -ETIME:
+		if (net_ratelimit())
+			netif_err(axdev, rx_err, netdev,
+				  "maybe reset is needed?\n");
+		break;
+	default:
+		if (net_ratelimit())
+			netif_err(axdev, rx_err, netdev,
+				  "RX status %d\n", status);
+		break;
+	}
+
+	ax_submit_rx(axdev, desc, GFP_ATOMIC);
+}
+
+void ax_write_bulk_callback(struct urb *urb)
+{
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	struct tx_desc *desc;
+	struct ax_device *axdev;
+	int status = urb->status;
+
+	desc = urb->context;
+	if (!desc)
+		return;
+
+	axdev = desc->context;
+	if (!axdev)
+		return;
+
+#ifdef ENABLE_PTP_FUNC
+	if (test_and_clear_bit(AX_TX_TIMESTAMPS, &desc->flags))
+		ax_ptp_ts_read_cmd_async(axdev);
+#endif
+	netdev = axdev->netdev;
+	stats = ax_get_stats(netdev);
+
+	if (status)
+		axdev->bulkout_error++;
+	else
+		axdev->bulkout_complete++;
+
+	if (status) {
+		if (net_ratelimit())
+			netif_warn(axdev, tx_err, netdev,
+				   "TX status %d\n", status);
+		stats->tx_errors += desc->skb_num;
+	} else {
+		stats->tx_packets += desc->skb_num;
+		stats->tx_bytes += desc->skb_len;
+	}
+
+	spin_lock(&axdev->tx_lock);
+	list_add_tail(&desc->list, &axdev->tx_free);
+	spin_unlock(&axdev->tx_lock);
+
+	usb_autopm_put_interface_async(axdev->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+	if (test_bit(AX_UNPLUG, &axdev->flags))
+		return;
+
+	if (ax_check_tx_queue_not_empty(axdev) >= 0)
+#ifdef ENABLE_TX_TASKLET
+		tasklet_schedule(&axdev->tx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+}
+
+static void ax_intr_callback(struct urb *urb)
+{
+	struct ax_device *axdev;
+	struct ax_device_int_data *event = NULL;
+	int status = urb->status;
+	int res;
+
+	axdev = urb->context;
+	if (!axdev)
+		return;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags) ||
+	    test_bit(AX_UNPLUG, &axdev->flags))
+		return;
+
+	if (status)
+		axdev->bulkint_error++;
+	else
+		axdev->bulkint_complete++;
+
+	switch (status) {
+	case 0:
+		break;
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+		netif_device_detach(axdev->netdev);
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -ENOENT:
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -EPROTO:
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -EOVERFLOW:
+		netif_err(axdev, intr, axdev->netdev,
+			  "intr status -EOVERFLOW\n");
+		goto resubmit;
+	default:
+		netif_err(axdev, intr, axdev->netdev,
+			  "intr status %d\n", status);
+		goto resubmit;
+	}
+
+	event = urb->transfer_buffer;
+	le64_to_cpus((u64 *)event);
+
+#ifndef ENABLE_INT_POLLING
+	axdev->link = event->link & AX_INT_PPLS_LINK;
+
+	if (axdev->link) {
+		if (!netif_carrier_ok(axdev->netdev)) {
+			axdev->intr_link_info = event->link_info;
+			set_bit(AX_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
+	} else {
+		if (netif_carrier_ok(axdev->netdev)) {
+			netif_stop_queue(axdev->netdev);
+			set_bit(AX_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
+	}
+#endif
+
+resubmit:
+	res = usb_submit_urb(urb, GFP_ATOMIC);
+	if (res == -ENODEV) {
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+	} else if (res) {
+		netif_err(axdev, intr, axdev->netdev,
+			  "can't resubmit intr, status %d\n", res);
+	}
+}
+
+#ifdef ENABLE_INT_POLLING
+static void __int_polling_work(struct work_struct *work)
+{
+	struct ax_device *axdev = container_of(work,
+				     struct ax_device, int_polling_work.work);
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 bmsr;
+	u16 speed;
+	
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	if (!mutex_trylock(&axdev->control)) {
+		schedule_delayed_work(&axdev->int_polling_work, 0);
+		return;
+	}
+
+	bmsr = ax_mdio_read(axdev->netdev, axdev->mii.phy_id, MII_BMSR);
+	axdev->link = bmsr & BMSR_LSTATUS;
+	
+	if (axdev->link) {
+		if (!netif_carrier_ok(axdev->netdev)) {
+			ax_set_carrier(axdev);
+			switch (link_info->eth_speed) {
+			case ETHER_LINK_10:
+				speed = 10;
+				break;
+			case ETHER_LINK_100:
+				speed = 100;
+				break;
+			case ETHER_LINK_1000:
+				speed = 1000;
+				break;
+			case ETHER_LINK_2500:
+				speed = 2500;
+				break;
+			}
+			netdev_info(axdev->netdev, "link up, %uMbps, %s-duplex\n",
+			    speed, link_info->full_duplex ? "full" : "half");
+		}
+	} else {
+		if (netif_carrier_ok(axdev->netdev)) {
+			netif_stop_queue(axdev->netdev);
+			ax_set_carrier(axdev);
+			netdev_info(axdev->netdev, "link down\n");
+		}
+	}
+
+	mutex_unlock(&axdev->control);
+
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+}
+#endif
+static void ax_free_buffer(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		usb_free_urb(axdev->rx_list[i].urb);
+		axdev->rx_list[i].urb = NULL;
+
+		kfree(axdev->rx_list[i].buffer);
+		axdev->rx_list[i].buffer = NULL;
+		axdev->rx_list[i].head = NULL;
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		usb_free_urb(axdev->tx_list[i].urb);
+		axdev->tx_list[i].urb = NULL;
+
+		kfree(axdev->tx_list[i].buffer);
+		axdev->tx_list[i].buffer = NULL;
+		axdev->tx_list[i].head = NULL;
+	}
+
+	usb_free_urb(axdev->intr_urb);
+	axdev->intr_urb = NULL;
+
+	kfree(axdev->intr_buff);
+	axdev->intr_buff = NULL;
+}
+
+static int ax_alloc_buffer(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	struct usb_interface *intf = axdev->intf;
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_host_endpoint *ep_intr = alt->endpoint;
+	struct urb *urb;
+	int node, i;
+	u8 *buf;
+
+	node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
+
+	spin_lock_init(&axdev->rx_lock);
+	spin_lock_init(&axdev->tx_lock);
+	INIT_LIST_HEAD(&axdev->tx_free);
+	INIT_LIST_HEAD(&axdev->rx_done);
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++)
+		skb_queue_head_init(&axdev->tx_queue[i]);
+	skb_queue_head_init(&axdev->rx_queue);
+
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		buf = kmalloc_node(axdev->driver_info->buf_rx_size,
+				   GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != __rx_buf_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(
+				axdev->driver_info->buf_rx_size + RX_ALIGN,
+				GFP_KERNEL,
+				node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		axdev->rx_list[i].context = axdev;
+		axdev->rx_list[i].urb = urb;
+		axdev->rx_list[i].buffer = buf;
+		axdev->rx_list[i].head = __rx_buf_align(buf);
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		buf = kmalloc_node(AX88179_BUF_TX_SIZE, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != __tx_buf_align(buf, axdev->tx_align_len)) {
+			kfree(buf);
+			buf = kmalloc_node(
+				AX88179_BUF_TX_SIZE + axdev->tx_align_len,
+				GFP_KERNEL, node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&axdev->tx_list[i].list);
+		axdev->tx_list[i].context = axdev;
+		axdev->tx_list[i].urb = urb;
+		axdev->tx_list[i].buffer = buf;
+		axdev->tx_list[i].head = __tx_buf_align(buf,
+							axdev->tx_align_len);
+
+		list_add_tail(&axdev->tx_list[i].list, &axdev->tx_free);
+	}
+
+	axdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!axdev->intr_urb)
+		goto err1;
+
+	axdev->intr_buff = kzalloc(INTBUFSIZE, GFP_KERNEL);
+	if (!axdev->intr_buff)
+		goto err1;
+
+	axdev->intr_interval = (int)ep_intr->desc.bInterval;
+	usb_fill_int_urb(axdev->intr_urb, axdev->udev,
+			 usb_rcvintpipe(axdev->udev, 1), axdev->intr_buff,
+			 INTBUFSIZE, ax_intr_callback, axdev,
+			 axdev->intr_interval);
+
+	return 0;
+err1:
+	ax_free_buffer(axdev);
+	return -ENOMEM;
+}
+
+static struct tx_desc *ax_get_tx_desc(struct ax_device *dev)
+{
+	struct tx_desc *desc = NULL;
+	unsigned long flags;
+
+	if (list_empty(&dev->tx_free))
+		return NULL;
+
+	spin_lock_irqsave(&dev->tx_lock, flags);
+	if (!list_empty(&dev->tx_free)) {
+		struct list_head *cursor;
+
+		cursor = dev->tx_free.next;
+		list_del_init(cursor);
+		desc = list_entry(cursor, struct tx_desc, list);
+	}
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
+
+	return desc;
+}
+
+static void ax_tx_bottom(struct ax_device *axdev)
+{
+	const struct driver_info *info = axdev->driver_info;
+	int ret;
+
+	do {
+		struct tx_desc *desc;
+		int index = -1;
+
+		index = ax_check_tx_queue_not_empty(axdev);
+		if (index < 0)
+			break;
+
+		desc = ax_get_tx_desc(axdev);
+		if (!desc)
+			break;
+#ifdef ENABLE_QUEUE_PRIORITY
+		desc->q_index = index;
+#else
+		desc->q_index = 0;
+#endif
+		ret = info->tx_fixup(axdev, desc);
+		if (ret) {
+			struct net_device *netdev = axdev->netdev;
+
+			if (ret == -ENODEV) {
+				ax_set_unplug(axdev);
+				netif_device_detach(netdev);
+			} else {
+				struct net_device_stats *stats;
+				unsigned long flags;
+
+				stats = ax_get_stats(netdev);
+				stats->tx_dropped += desc->skb_num;
+
+				spin_lock_irqsave(&axdev->tx_lock, flags);
+				list_add_tail(&desc->list, &axdev->tx_free);
+				spin_unlock_irqrestore(&axdev->tx_lock, flags);
+			}
+		}
+	} while (ret == 0);
+}
+#ifdef ENABLE_TX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+static void ax_bottom_half(unsigned long t)
+{
+	struct ax_device *axdev = (struct ax_device *)t;
+#else
+static void ax_bottom_half(struct tasklet_struct *t)
+{
+	struct ax_device *axdev = from_tasklet(axdev, t, tx_tl);
+#endif
+
+#else
+static void ax_bottom_half(struct ax_device *axdev)
+{
+#endif
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags) ||
+	    !netif_carrier_ok(axdev->netdev))
+		return;
+#ifdef ENABLE_TX_TASKLET
+	clear_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags);
+#else
+	clear_bit(AX_SCHEDULE_NAPI, &axdev->flags);
+#endif
+
+	ax_tx_bottom(axdev);
+}
+
+static int ax_rx_bottom(struct ax_device *axdev, int budget)
+{
+	unsigned long flags;
+	struct list_head *cursor, *next, rx_queue;
+	int ret = 0, work_done = 0;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+
+	if (!skb_queue_empty(&axdev->rx_queue)) {
+		while (work_done < budget) {
+			struct sk_buff *skb = __skb_dequeue(&axdev->rx_queue);
+			unsigned int pkt_len;
+
+			if (!skb)
+				break;
+
+			pkt_len = skb->len;
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(napi, skb);
+#endif
+			work_done++;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		}
+	}
+
+	if (list_empty(&axdev->rx_done))
+		return work_done;
+
+	INIT_LIST_HEAD(&rx_queue);
+	spin_lock_irqsave(&axdev->rx_lock, flags);
+	list_splice_init(&axdev->rx_done, &rx_queue);
+	spin_unlock_irqrestore(&axdev->rx_lock, flags);
+
+	list_for_each_safe(cursor, next, &rx_queue) {
+		struct rx_desc *desc;
+
+		list_del_init(cursor);
+
+		desc = list_entry(cursor, struct rx_desc, list);
+
+		if (desc->urb->actual_length < ETH_ZLEN)
+			goto submit;
+
+		if (unlikely(skb_queue_len(&axdev->rx_queue) >= 1000))
+			goto submit;
+
+		axdev->driver_info->rx_fixup(axdev, desc, &work_done, budget);
+submit:
+		if (!ret) {
+			ret = ax_submit_rx(axdev, desc, GFP_ATOMIC);
+		} else {
+			desc->urb->actual_length = 0;
+			list_add_tail(&desc->list, next);
+		}
+	}
+
+	if (!list_empty(&rx_queue)) {
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+
+	return work_done;
+}
+
+static
+int ax_submit_rx(struct ax_device *dev, struct rx_desc *desc, gfp_t mem_flags)
+{
+	int ret;
+
+	if (test_bit(AX_UNPLUG, &dev->flags) ||
+	    !test_bit(AX_ENABLE, &dev->flags) ||
+	    !netif_carrier_ok(dev->netdev))
+		return 0;
+
+	usb_fill_bulk_urb(desc->urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),
+			  desc->head, dev->driver_info->buf_rx_size,
+			  (usb_complete_t)ax_read_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, mem_flags);
+	if (ret == -ENODEV) {
+		ax_set_unplug(dev);
+		netif_device_detach(dev->netdev);
+	} else if (ret) {
+		struct urb *urb = desc->urb;
+		unsigned long flags;
+
+		urb->actual_length = 0;
+		spin_lock_irqsave(&dev->rx_lock, flags);
+		list_add_tail(&desc->list, &dev->rx_done);
+		spin_unlock_irqrestore(&dev->rx_lock, flags);
+
+		netif_err(dev, rx_err, dev->netdev,
+			  "Couldn't submit rx[%p], ret = %d\n", desc, ret);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&dev->rx_tl);
+#else
+		napi_schedule(&dev->napi);
+#endif
+	}
+
+	return ret;
+}
+
+static inline int __ax_poll(struct ax_device *axdev, int budget)
+{
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	int work_done;
+
+	work_done = ax_rx_bottom(axdev, budget);
+#ifndef ENABLE_TX_TASKLET
+	ax_bottom_half(axdev);
+#endif
+
+	if (work_done < budget) {
+#ifndef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+		napi_complete_done(napi, work_done);
+#else
+		if (!napi_complete_done(napi, work_done))
+			return work_done;
+#endif
+#endif
+		if (!list_empty(&axdev->rx_done))
+#ifdef ENABLE_RX_TASKLET
+			tasklet_schedule(&axdev->rx_tl);
+#else
+			napi_schedule(napi);
+#endif
+
+#ifndef ENABLE_TX_TASKLET
+		else if (ax_check_tx_queue_not_empty(axdev) >= 0 &&
+			 !list_empty(&axdev->tx_free))
+			napi_schedule(napi);
+#endif
+	}
+
+	return work_done;
+}
+
+#ifdef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+static void ax_poll(unsigned long t)
+{
+	struct ax_device *axdev = (struct ax_device *)t;
+#else
+static void ax_poll(struct tasklet_struct *t)
+{
+	struct ax_device *axdev = from_tasklet(axdev, t, rx_tl);
+#endif
+	__ax_poll(axdev, 256);
+}
+
+#else
+
+static int ax_poll(struct napi_struct *napi, int budget)
+{
+	struct ax_device *axdev = container_of(napi, struct ax_device, napi);
+
+	return __ax_poll(axdev, budget);
+}
+#endif
+
+static void ax_drop_queued_tx(struct ax_device *axdev)
+{
+	struct net_device_stats *stats = ax_get_stats(axdev->netdev);
+	struct sk_buff_head skb_head, *tx_queue = axdev->tx_queue;
+	struct sk_buff *skb;
+	int i;
+
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++) {
+		if (skb_queue_empty(&tx_queue[i]))
+			continue;
+
+		__skb_queue_head_init(&skb_head);
+		spin_lock_bh(&tx_queue[i].lock);
+		skb_queue_splice_init(&tx_queue[i], &skb_head);
+		spin_unlock_bh(&tx_queue[i].lock);
+
+		while ((skb = __skb_dequeue(&skb_head))) {
+			dev_kfree_skb(skb);
+			stats->tx_dropped++;
+		}
+	}
+}
+
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static void ax_tx_timeout(struct net_device *netdev, unsigned int txqueue)
+#else
+static void ax_tx_timeout(struct net_device *netdev)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	netif_warn(axdev, tx_err, netdev, "Tx timeout\n");
+
+	usb_queue_reset_device(axdev->intf);
+
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static u16 ax_select_queue(struct net_device *netdev, struct sk_buff *skb,
+			   struct net_device *sb_dev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct ax_link_info *link_info = &axdev->link_info;
+
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+#ifdef ENABLE_AX88279
+		if (axdev->chip_version >= AX_VERSION_AX88279)
+			return 1;
+#endif
+		if (link_info->eth_speed == ETHER_LINK_1000)
+			return 1;
+	}
+	return 0;
+}
+#endif
+
+static netdev_tx_t ax_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+#ifdef ENABLE_QUEUE_PRIORITY
+	u32 index = ax_select_queue(netdev, skb, NULL);
+#endif
+	skb_tx_timestamp(skb);
+#ifdef ENABLE_QUEUE_PRIORITY
+	skb_queue_tail(&axdev->tx_queue[index], skb);
+#else
+	skb_queue_tail(&axdev->tx_queue[0], skb);
+#endif
+	if (!list_empty(&axdev->tx_free)) {
+		if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags)) {
+#ifdef ENABLE_TX_TASKLET
+			set_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags);
+#else
+			set_bit(AX_SCHEDULE_NAPI, &axdev->flags);
+#endif
+			schedule_delayed_work(&axdev->schedule, 0);
+		} else {
+			usb_mark_last_busy(axdev->udev);
+#ifdef ENABLE_TX_TASKLET
+			tasklet_schedule(&axdev->tx_tl);
+#else
+			napi_schedule(&axdev->napi);
+#endif
+		}
+	} else if (ax_check_tx_queue_len(axdev)) {
+		netif_stop_queue(netdev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+void ax_set_tx_qlen(struct ax_device *dev)
+{
+	struct net_device *netdev = dev->netdev;
+
+	dev->tx_qlen = AX88179_BUF_TX_SIZE / (netdev->mtu + ETH_FCS_LEN + 8);
+}
+
+static int ax_start_rx(struct ax_device *axdev)
+{
+	int i, ret = 0;
+
+	INIT_LIST_HEAD(&axdev->rx_done);
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		ret = ax_submit_rx(axdev, &axdev->rx_list[i], GFP_KERNEL);
+		if (ret)
+			break;
+	}
+
+	if (ret && ++i < AX88179_MAX_RX) {
+		struct list_head rx_queue;
+		unsigned long flags;
+
+		INIT_LIST_HEAD(&rx_queue);
+
+		do {
+			struct rx_desc *desc = &axdev->rx_list[i++];
+			struct urb *urb = desc->urb;
+
+			urb->actual_length = 0;
+			list_add_tail(&desc->list, &rx_queue);
+		} while (i < AX88179_MAX_RX);
+
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+
+	return ret;
+}
+
+static int ax_stop_rx(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX88179_MAX_RX; i++)
+		usb_kill_urb(axdev->rx_list[i].urb);
+
+	while (!skb_queue_empty(&axdev->rx_queue))
+		dev_kfree_skb(__skb_dequeue(&axdev->rx_queue));
+
+	return 0;
+}
+
+static void ax_disable(struct ax_device *axdev)
+{
+	int i;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		return;
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++)
+		usb_kill_urb(axdev->tx_list[i].urb);
+
+	ax_stop_rx(axdev);
+}
+
+#if KERNEL_VERSION(2, 6, 39) <= LINUX_VERSION_CODE
+static int
+#if KERNEL_VERSION(3, 3, 0) <= LINUX_VERSION_CODE
+ax88179_set_features(struct net_device *net, netdev_features_t features)
+#else
+ax88179_set_features(struct net_device *net, u32 features)
+#endif
+{
+	struct ax_device *dev = netdev_priv(net);
+	u8 reg8;
+
+#if KERNEL_VERSION(3, 3, 0) <= LINUX_VERSION_CODE
+	netdev_features_t changed = net->features ^ features;
+#else
+	u32 changed = net->features ^ features;
+#endif
+
+	if (changed & NETIF_F_IP_CSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_TXCOE_TCP | AX_TXCOE_UDP;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	}
+
+	if (changed & NETIF_F_IPV6_CSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	}
+
+	if (changed & NETIF_F_RXCSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+			AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+	}
+
+	return 0;
+}
+#endif
+
+static void ax_set_carrier(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+
+	if (axdev->link) {
+#ifdef ENABLE_PTP_FUNC
+		axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+		if (!netif_carrier_ok(netdev)) {
+			if (axdev->driver_info->link_reset(axdev))
+				return;
+			netif_stop_queue(netdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			napi_disable(napi);
+#endif	
+			netif_carrier_on(netdev);
+			ax_start_rx(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif
+			netif_wake_queue(netdev);
+		} else if (netif_queue_stopped(netdev) &&
+			   ax_check_tx_queue_len(axdev)) {
+			netif_wake_queue(netdev);
+		}
+	} else {
+#ifdef ENABLE_PTP_FUNC
+		axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+		if (netif_carrier_ok(netdev)) {
+			netif_carrier_off(netdev);
+#ifdef ENABLE_TX_TASKLET
+			tasklet_disable(&axdev->tx_tl);
+#endif
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			napi_disable(napi);
+#endif			
+			ax_disable(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif	
+#ifdef ENABLE_TX_TASKLET
+			tasklet_enable(&axdev->tx_tl);
+#endif
+		}
+	}
+#ifdef ENABLE_AX88279
+	if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500) {
+		netdev_info(axdev->netdev,
+			    "link up, 2500Mbps, full-duplex\n");
+	}
+#endif
+}
+
+static inline void __ax_work_func(struct ax_device *axdev)
+{
+	if (test_bit(AX_UNPLUG, &axdev->flags) || !netif_running(axdev->netdev))
+		return;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		goto out;
+
+	if (!mutex_trylock(&axdev->control)) {
+		schedule_delayed_work(&axdev->schedule, 0);
+		goto out;
+	}
+
+	if (test_and_clear_bit(AX_LINK_CHG, &axdev->flags))
+		ax_set_carrier(axdev);
+
+#ifdef ENABLE_RX_TASKLET
+	if (test_and_clear_bit(AX_SCHEDULE_TASKLET_RX, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		tasklet_schedule(&axdev->rx_tl);
+#else
+	if (test_and_clear_bit(AX_SCHEDULE_NAPI, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		napi_schedule(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	if (test_and_clear_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		tasklet_schedule(&axdev->tx_tl);
+#endif
+
+	mutex_unlock(&axdev->control);
+
+out:
+	usb_autopm_put_interface(axdev->intf);
+}
+
+static void ax_work_func_t(struct work_struct *work)
+{
+	struct ax_device *axdev = container_of(work,
+					       struct ax_device, schedule.work);
+
+	__ax_work_func(axdev);
+}
+
+int ax_usb_command(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	struct _ax_usb_command *usb_cmd = &info->usb_cmd;
+	void *buf;
+	int err, timeout;
+	u16 size = usb_cmd->size;
+	u8 reqtype;
+
+	buf = kmemdup(&usb_cmd->cmd_data, size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (usb_cmd->ops == USB_READ_OPS) {
+		reqtype = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+		timeout = USB_CTRL_GET_TIMEOUT;
+	} else {
+		reqtype = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+		timeout = USB_CTRL_SET_TIMEOUT;
+	}
+
+	err = usb_control_msg(axdev->udev, usb_rcvctrlpipe(axdev->udev, 0),
+			      usb_cmd->cmd, reqtype, usb_cmd->value,
+			      usb_cmd->index, buf, size, timeout);
+	if (err > 0 && err <= size)
+		memcpy(&usb_cmd->cmd_data, buf, size);
+
+	kfree(buf);
+
+	return 0;
+}
+
+static int ax_open(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int res = 0;
+
+	res = ax_alloc_buffer(axdev);
+	if (res)
+		return res;
+
+	res = usb_autopm_get_interface(axdev->intf);
+	if (res < 0)
+		goto out_free;
+
+	mutex_lock(&axdev->control);
+
+	set_bit(AX_ENABLE, &axdev->flags);
+
+	res = axdev->driver_info->hw_init(axdev);
+	if (res < 0)
+		goto out_unlock;
+
+	res = usb_submit_urb(axdev->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(netdev);
+		netif_warn(axdev, ifup, netdev,
+			   "intr_urb submit failed: %d\n", res);
+		goto out_unlock;
+	}
+#ifdef ENABLE_INT_POLLING
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+#ifdef ENABLE_RX_TASKLET
+	tasklet_enable(&axdev->rx_tl);
+#else
+	napi_enable(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_enable(&axdev->tx_tl);
+#endif
+
+	netif_carrier_off(netdev);
+	netif_start_queue(netdev);
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+
+out_unlock:
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+out_free:
+	ax_free_buffer(axdev);
+	return res;
+}
+
+static int ax_close(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret = 0;
+
+	if (axdev->driver_info->stop)
+		axdev->driver_info->stop(axdev);
+
+#ifdef ENABLE_TX_TASKLET
+	tasklet_disable(&axdev->tx_tl);
+#endif
+	clear_bit(AX_ENABLE, &axdev->flags);
+	usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+	cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+	cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+	tasklet_disable(&axdev->rx_tl);
+#else
+	napi_disable(&axdev->napi);
+#endif
+	netif_stop_queue(axdev->netdev);
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0 || test_bit(AX_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		ax_stop_rx(axdev);
+	} else {
+		ax_disable(axdev);
+	}
+
+	if (!ret)
+		usb_autopm_put_interface(axdev->intf);
+
+	ax_free_buffer(axdev);
+
+	return ret;
+}
+
+static int ax88179_change_mtu(struct net_device *net, int new_mtu)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u16 reg16;
+
+	if (new_mtu <= 0 || new_mtu > net->max_mtu)
+		return -EINVAL;
+
+	net->mtu = new_mtu;
+
+	if (net->mtu > 1500) {
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16, 1);
+		reg16 |= AX_MEDIUM_JUMBO_EN;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			     2, 2, &reg16);
+	} else {
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16, 1);
+		reg16 &= ~AX_MEDIUM_JUMBO_EN;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			     2, 2, &reg16);
+	}
+
+	return 0;
+}
+
+int ax_get_mac_pass(struct ax_device *axdev, u8 *mac)
+{
+#ifdef ENABLE_MAC_PASS
+	efi_char16_t name[] = L"MacAddressPassTemp";
+	efi_guid_t guid = EFI_GUID(0xe2a741d8, 0xedf5, 0x47a1,
+				   0x8f, 0x94, 0xb0, 0xee,
+				   0x36, 0x8a, 0x3d, 0xe0);
+	u32 attr;
+	unsigned long data_size = sizeof(struct mac_pass);
+	struct mac_pass macpass;
+	efi_status_t status;
+#if KERNEL_VERSION(5, 7, 0) <= LINUX_VERSION_CODE
+	if (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))
+		return -EOPNOTSUPP;
+#else
+	if (!efi_enabled(EFI_RUNTIME_SERVICES))
+		return -EOPNOTSUPP;
+#endif
+	status = efi.get_variable(name, &guid, &attr, &data_size, &macpass);
+	if (status != EFI_SUCCESS) {
+		netdev_err(axdev->netdev, "Getting variable failed.(%ld)",
+			   status);
+		return status;
+	}
+
+	if (macpass.control == MAC_PASS_ENABLE_0)
+		memcpy(mac, macpass.mac0, 6);
+	else if (macpass.control == MAC_PASS_ENABLE_1)
+		memcpy(mac, macpass.mac1, 6);
+	else
+		return -1;
+#endif
+	return 0;
+}
+
+int ax_check_ether_addr(struct ax_device *axdev)
+{
+	u8 *addr = (u8 *)axdev->netdev->dev_addr;
+	u8 default_mac[6] = {0, 0x0e, 0xc6, 0x81, 0x79, 0x01};
+	u8 default_mac_178a[6] = {0, 0x0e, 0xc6, 0x81, 0x78, 0x01};
+
+	if (((addr[0] == 0) && (addr[1] == 0) && (addr[2] == 0)) ||
+	    !is_valid_ether_addr(addr) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac, ETH_ALEN) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac_178a, ETH_ALEN)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		eth_random_addr(addr);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	eth_hw_addr_random(axdev->netdev);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	axdev->netdev->addr_assign_type |= NET_ADDR_RANDOM;
+#endif
+random_ether_addr(axdev->netdev->dev_addr);
+#endif		
+#endif
+
+		addr[0] = 0;
+		addr[1] = 0x0E;
+		addr[2] = 0xC6;
+
+		return -EADDRNOTAVAIL;
+	}
+
+	return 0;
+}
+
+static int ax_get_chip_version(struct ax_device *axdev)
+{
+	int ret = 0;
+
+	axdev->chip_version = AX_VERSION_INVALID;
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_CHIP_STATUS,
+			  1, 1, &axdev->chip_version, 0);
+	if (ret < 0)
+		return ret;
+	axdev->chip_version = CHIP_CODE(axdev->chip_version);
+
+	return 0;
+}
+
+static void ax_get_chip_subversion(struct ax_device *axdev)
+{
+	if (axdev->chip_version < AX_VERSION_AX88179A_772D) {
+		axdev->sub_version = 0;
+		return;
+	}
+
+	if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, AX88179A_HW_EC_VERSION,
+			1, 1, &axdev->sub_version, 0) < 0)
+		axdev->sub_version = 0;
+}
+
+static int ax_get_chip_feature(struct ax_device *axdev)
+{
+	if (ax_get_chip_version(axdev))
+		return -ENODEV;
+
+	if (axdev->chip_version < AX_VERSION_AX88179)
+		return -ENODEV;
+
+	ax_get_chip_subversion(axdev);
+
+	return 0;
+}
+
+static int ax_get_mac_address(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	if (ax_read_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			ETH_ALEN, (void *)netdev->dev_addr, 0) < 0) {
+		dev_err(&axdev->intf->dev, "Failed to read MAC address");
+		return -ENODEV;
+	}
+
+	if (ax_check_ether_addr(axdev))
+		dev_warn(&axdev->intf->dev, "Found invalid MAC address value");
+
+	ax_get_mac_pass(axdev, (void *)netdev->dev_addr);
+
+
+	memcpy(netdev->perm_addr, (void *)netdev->dev_addr, ETH_ALEN);
+
+	if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			ETH_ALEN, (void *)netdev->dev_addr) < 0) {
+		dev_err(&axdev->intf->dev, "Failed to write MAC address");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+
+static bool ax_can_wakeup(struct ax_device *axdev)
+{
+	struct usb_device *udev = axdev->udev;
+
+	return (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);
+}
+
+static int ax_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	//struct usb_driver *driver = to_usb_driver(intf->dev.driver);
+	const struct driver_info *info;
+	struct net_device *netdev;
+	struct ax_device *axdev;
+	int ret;
+
+	if (udev->actconfig->desc.bConfigurationValue != 1) {
+		usb_driver_set_configuration(udev, 1);
+		return -ENODEV;
+	}
+
+	info = (const struct driver_info *)id->driver_info;
+	if (!info || !info->bind || !info->unbind) {
+		dev_err(&intf->dev, "Driver method not registered\n");
+		return -ENODEV;
+	}
+
+	netdev = alloc_etherdev(sizeof(struct ax_device));
+	if (!netdev) {
+		dev_err(&intf->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	axdev = netdev_priv(netdev);
+	axdev->driver_info = info;
+
+	netdev->watchdog_timeo = AX_TX_TIMEOUT;
+
+	axdev->udev = udev;
+	axdev->netdev = netdev;
+	axdev->intf = intf;
+	intf->needs_remote_wakeup = true;
+#ifdef ENABLE_AUTODETACH_FUNC
+	axdev->autodetach = (autodetach == -1) ? false : true;
+#else
+	axdev->autodetach = false;
+#endif
+	mutex_init(&axdev->control);
+	INIT_DELAYED_WORK(&axdev->schedule, ax_work_func_t);
+#ifdef ENABLE_TX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+	tasklet_init(&axdev->tx_tl, ax_bottom_half, (unsigned long) axdev);
+#else
+	tasklet_setup(&axdev->tx_tl, ax_bottom_half);
+#endif
+	tasklet_disable(&axdev->tx_tl);
+#endif
+
+	ret = ax_get_chip_feature(axdev);
+	if (ret) {
+		dev_err(&intf->dev, "Failed to get Device feature\n");
+		goto out;
+	}
+
+	ret = info->bind(axdev);
+	if (ret) {
+		dev_err(&intf->dev, "Device initialization failed\n");
+		goto out;
+	}
+
+	usb_set_intfdata(intf, axdev);
+#ifdef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+	tasklet_init(&axdev->rx_tl, ax_poll, (unsigned long) axdev);
+#else
+	tasklet_setup(&axdev->rx_tl, ax_poll);
+#endif
+	tasklet_disable(&axdev->rx_tl);
+#else
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_napi_add_weight(netdev, &axdev->napi, ax_poll, AX88179_NAPI_WEIGHT);
+#else
+	netif_napi_add(netdev, &axdev->napi, ax_poll, AX88179_NAPI_WEIGHT);
+#endif
+#endif
+	ret = ax_get_mac_address(axdev);
+	if (ret < 0)
+		goto out;
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+	ret = register_netdev(netdev);
+	if (ret != 0) {
+		netif_err(axdev, probe, netdev,
+			  "couldn't register the device\n");
+		goto out1;
+	}
+
+	device_set_wakeup_enable(&udev->dev, ax_can_wakeup(axdev));
+#ifdef ENABLE_INT_POLLING
+	INIT_DELAYED_WORK(&axdev->int_polling_work, __int_polling_work);
+#endif
+
+	return 0;
+out1:
+#ifdef ENABLE_RX_TASKLET
+	tasklet_kill(&axdev->rx_tl);
+#else
+	netif_napi_del(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_kill(&axdev->tx_tl);
+#endif
+	usb_set_intfdata(intf, NULL);
+out:
+	free_netdev(netdev);
+	return ret;
+}
+
+static void ax_disconnect(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (axdev) {
+		axdev->driver_info->unbind(axdev);
+		ax_set_unplug(axdev);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_kill(&axdev->rx_tl);
+#else
+		netif_napi_del(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+		tasklet_kill(&axdev->tx_tl);
+#endif
+		unregister_netdev(axdev->netdev);
+		free_netdev(axdev->netdev);
+	}
+}
+
+static int ax_pre_reset(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!axdev)
+		return 0;
+
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	netif_stop_queue(netdev);
+#ifdef ENABLE_TX_TASKLET
+	tasklet_disable(&axdev->tx_tl);
+#endif
+	clear_bit(AX_ENABLE, &axdev->flags);
+	usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+	cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+	cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+	tasklet_disable(&axdev->rx_tl);
+#else
+	napi_disable(&axdev->napi);
+#endif
+	return 0;
+}
+
+static int ax_post_reset(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!axdev)
+		return 0;
+
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	set_bit(AX_ENABLE, &axdev->flags);
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&axdev->control);
+		ax_start_rx(axdev);
+		mutex_unlock(&axdev->control);
+	}
+
+#ifdef ENABLE_RX_TASKLET
+	tasklet_enable(&axdev->rx_tl);
+#else
+	napi_enable(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_enable(&axdev->tx_tl);
+#endif
+	netif_wake_queue(netdev);
+	usb_submit_urb(axdev->intr_urb, GFP_KERNEL);
+#ifdef ENABLE_INT_POLLING
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+
+	if (!list_empty(&axdev->rx_done))
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&axdev->rx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+
+	return 0;
+}
+
+static int ax_system_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	netif_device_attach(netdev);
+
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+		netif_carrier_off(netdev);
+
+		axdev->driver_info->system_resume(axdev);
+		set_bit(AX_ENABLE, &axdev->flags);
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+#ifdef ENABLE_INT_POLLING
+		schedule_delayed_work(&axdev->int_polling_work,
+				      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+	}
+
+	return 0;
+}
+
+static int ax_runtime_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+#ifdef ENABLE_RX_TASKLET
+		tasklet_disable(&axdev->rx_tl);
+#else
+		struct napi_struct *napi = &axdev->napi;
+
+		napi_disable(napi);
+#endif
+		set_bit(AX_ENABLE, &axdev->flags);
+
+		if (netif_carrier_ok(netdev)) {
+			if (axdev->link) {
+				ax_start_rx(axdev);
+			} else {
+				netif_carrier_off(netdev);
+				if (axdev->driver_info->stop)
+					axdev->driver_info->stop(axdev);
+			}
+		}
+
+		axdev->driver_info->runtime_resume(axdev);
+
+#ifdef ENABLE_RX_TASKLET
+		tasklet_enable(&axdev->rx_tl);
+#else
+		napi_enable(napi);
+#endif	
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+		if (!list_empty(&axdev->rx_done)) {
+			local_bh_disable();
+#ifdef ENABLE_RX_TASKLET
+			tasklet_schedule(&axdev->rx_tl);
+#else
+			napi_schedule(&axdev->napi);
+#endif	
+			local_bh_enable();
+		}
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+	} else {
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+	}
+
+	return 0;
+}
+
+static int ax_system_suspend(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	int ret = 0;
+
+	netif_device_detach(netdev);
+
+	
+
+	if (netif_running(netdev) && test_bit(AX_ENABLE, &axdev->flags)) {
+#ifndef ENABLE_RX_TASKLET
+		struct napi_struct *napi = &axdev->napi;
+#endif
+
+		clear_bit(AX_ENABLE, &axdev->flags);
+		usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_TX_TASKLET
+		tasklet_disable(&axdev->tx_tl);
+#endif
+#ifdef ENABLE_INT_POLLING
+		cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+
+		ax_disable(axdev);
+
+		axdev->driver_info->system_suspend(axdev);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_disable(&axdev->rx_tl);
+#else
+		napi_disable(napi);
+#endif
+		cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_enable(&axdev->rx_tl);
+#else
+		napi_enable(napi);
+#endif
+		
+#ifdef ENABLE_TX_TASKLET
+		tasklet_enable(&axdev->tx_tl);
+#endif
+	}
+
+	return ret;
+}
+
+static int ax_runtime_suspend(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	set_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+
+	if (netif_running(netdev) && test_bit(AX_ENABLE, &axdev->flags)) {
+		clear_bit(AX_ENABLE, &axdev->flags);
+		usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+		cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+
+		if (netif_carrier_ok(netdev)) {
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			struct napi_struct *napi = &axdev->napi;
+
+			napi_disable(napi);
+#endif
+			
+			ax_stop_rx(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif
+		}
+
+		axdev->driver_info->runtime_suspend(axdev);
+	}
+
+	return 0;
+}
+
+static int ax_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&axdev->control);
+
+	if (PMSG_IS_AUTO(message))
+		ret = ax_runtime_suspend(axdev);
+	else
+		ret = ax_system_suspend(axdev);
+
+	mutex_unlock(&axdev->control);
+
+	return ret;
+}
+
+static int ax_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&axdev->control);
+
+	if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags))
+		ret = ax_runtime_resume(axdev);
+	else
+		ret = ax_system_resume(axdev);
+
+	mutex_unlock(&axdev->control);
+
+	return ret;
+}
+
+static int ax_reset_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+
+	clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+
+	return ax_resume(intf);
+}
+
+const struct net_device_ops ax88179_netdev_ops = {
+	.ndo_open		= ax_open,
+	.ndo_stop		= ax_close,
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+	.ndo_siocdevprivate	= ax88179_siocdevprivate,
+	.ndo_eth_ioctl		= ax88179_ioctl,
+#endif
+	.ndo_do_ioctl		= ax88179_ioctl,
+	.ndo_start_xmit		= ax_start_xmit,
+	.ndo_tx_timeout		= ax_tx_timeout,
+	.ndo_set_features	= ax88179_set_features,
+	.ndo_set_rx_mode	= ax88179_set_multicast,
+	.ndo_set_mac_address	= ax88179_set_mac_addr,
+	.ndo_change_mtu		= ax88179_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+const struct net_device_ops ax88179a_netdev_ops = {
+	.ndo_open		= ax_open,
+	.ndo_stop		= ax_close,
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+	.ndo_siocdevprivate	= ax88179a_siocdevprivate,
+	.ndo_eth_ioctl		= ax88179a_ioctl,
+#endif
+	.ndo_do_ioctl		= ax88179a_ioctl,
+	.ndo_start_xmit		= ax_start_xmit,
+	.ndo_tx_timeout		= ax_tx_timeout,
+	.ndo_set_features	= ax88179_set_features,
+	.ndo_set_rx_mode	= ax88179a_set_multicast,
+	.ndo_set_mac_address	= ax88179_set_mac_addr,
+	.ndo_change_mtu		= ax88179_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+#define ASIX_USB_DEVICE(vend, prod, lo, hi, info) { \
+	USB_DEVICE_VER(vend, prod, lo, hi), \
+	.driver_info = (unsigned long)&info \
+}
+
+static const struct usb_device_id ax_usb_table[] = {
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_178A, 0,
+			AX_BCDDEVICE_ID_178A, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_SITECOM, 0x0072, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_LENOVO, 0x304b, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_TOSHIBA, 0x0a13, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, 0xa100, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_DLINK, 0x4a00, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_MAGIC_CONTROL, 0x0179, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_772D, ax88179a_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_179A, ax88179a_info),
+#ifdef ENABLE_AX88279
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_279, ax88279_info),
+#endif
+	{/*END*/}
+};
+
+MODULE_DEVICE_TABLE(usb, ax_usb_table);
+
+static struct usb_driver ax_usb_driver = {
+	.name		= MODULENAME,
+	.id_table	= ax_usb_table,
+	.probe		= ax_probe,
+	.disconnect	= ax_disconnect,
+	.suspend	= ax_suspend,
+	.resume		= ax_resume,
+	.reset_resume	= ax_reset_resume,
+	.pre_reset	= ax_pre_reset,
+	.post_reset	= ax_post_reset,
+	.supports_autosuspend = 1,
+#if KERNEL_VERSION(3, 5, 0) <= LINUX_VERSION_CODE
+	.disable_hub_initiated_lpm = 1,
+#endif
+};
+
+module_usb_driver(ax_usb_driver);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
diff --git a/drivers/net/usb/asix_usb/ax_main.h b/drivers/net/usb/asix_usb/ax_main.h
new file mode 100755
index 000000000000..016ac446d4d2
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_main.h
@@ -0,0 +1,674 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_MAIN_H
+#define __ASIX_MAIN_H
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <uapi/linux/mdio.h>
+#include <linux/mdio.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/usb.h>
+#include <linux/if_vlan.h>
+#include <linux/usb/cdc.h>
+#include <linux/suspend.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <linux/efi.h>
+#include <linux/crc32.h>
+#include <linux/time.h>
+#include "ax_ioctl.h"
+
+#define napi_alloc_skb(napi, length) netdev_alloc_skb_ip_align(netdev, length)
+#define napi_complete_done(n, d) napi_complete(n)
+
+typedef int (*_usb_read_function)(struct ax_device *dev, u8 cmd, u8 reqtype,
+				  u16 value, u16 index, void *data, u16 size);
+typedef int (*_usb_write_function)(struct ax_device *dev, u8 cmd, u8 reqtype,
+				   u16 value, u16 index, const void *data,
+				   u16 size);
+typedef int (*usb_read_function)(struct ax_device *axdev, u8 cmd, u16 value,
+				 u16 index, u16 size, void *data, int eflag);
+typedef int (*usb_write_function)(struct ax_device *axdev, u8 cmd, u16 value,
+				  u16 index, u16 size, void *data);
+
+#define USB_VENDOR_ID_ASIX		0x0B95
+#define USB_VENDOR_ID_SITECOM		0x0DF6
+#define USB_VENDOR_ID_LENOVO		0x17EF
+#define USB_VENDOR_ID_TOSHIBA		0x0930
+#define USB_VENDOR_ID_SAMSUNG		0x04E8
+#define USB_VENDOR_ID_DLINK		0x2001
+#define USB_VENDOR_ID_MAGIC_CONTROL	0x0711
+
+#define AX_DEVICE_ID_179X	0x1790
+#define AX_BCDDEVICE_ID_179	0x0100
+#define AX_BCDDEVICE_ID_179A	0x0200
+#define AX_DEVICE_ID_178A	0x178A
+#define AX_BCDDEVICE_ID_178A	0x0100
+#define AX_DEVICE_ID_772D	AX_DEVICE_ID_179X
+#define AX_BCDDEVICE_ID_772D	0x0300
+#ifdef ENABLE_AX88279
+#define AX_BCDDEVICE_ID_279	0x0400
+#endif
+
+#define AX_DRIVER_STRING_179_178A \
+				"ASIX AX88179_178A USB Ethernet Controller"
+#define AX_DRIVER_STRING_179A_772D \
+				"ASIX AX88179B_179A_772E_772D USB Ethernet Controller"
+#ifdef ENABLE_AX88279
+#define AX_DRIVER_STRING_279 \
+				"ASIX AX88279 USB Ethernet Controller"
+#endif
+
+#define DRIVER_VERSION		"3.1.0"
+#define DRIVER_AUTHOR		"ASIX"
+#define DRIVER_DESC		"ASIX USB Ethernet Controller"
+#define MODULENAME		"ax_usb_nic"
+
+#define PRINT_VERSION(axdev, str) \
+	dev_info(&axdev->intf->dev, \
+		"%s %s (%d.%d.%d.%d_%d.%d)", \
+		str, DRIVER_VERSION, \
+		axdev->fw_version[0], \
+		axdev->fw_version[1], \
+		axdev->fw_version[2], \
+		axdev->fw_version[3], \
+		axdev->chip_version, \
+		axdev->sub_version)
+
+#define AX88179_MAX_TX		4
+#define AX88179_MAX_RX		10
+#define AX88179_BUF_TX_SIZE	(81 * 1024)
+#define AX_GSO_DEFAULT_SIZE	(16 * 1024)
+#define INTBUFSIZE		8
+#define TX_ALIGN		4
+#define RX_ALIGN		8
+#define TX_CASECADES_SIZE	AX_GSO_DEFAULT_SIZE
+
+#define AX_TX_HEADER_LEN	8
+#define AX_TX_TIMEOUT		(5 * HZ)
+#define AX_MCAST_FILTER_SIZE	8
+#define AX_MAX_MCAST		64
+#ifdef ENABLE_QUEUE_PRIORITY
+#define AX_TX_QUEUE_SIZE	2
+#else
+#define AX_TX_QUEUE_SIZE	1
+#endif
+
+#define US_TO_NS		1000
+
+#define AX_ACCESS_MAC			0x01
+#define AX_ACCESS_PHY			0x02
+#define AX_ACCESS_WAKEUP		0x03
+#define AX_ACCESS_EEPROM		0x04
+#define AX_ACCESS_EFUSE			0x05
+#define AX_RELOAD_EEPROM_EFUSE		0x06
+#define AX_RELOAD_FLASH_EFUSE		0x06
+#define AX_FW_MODE			0x08
+	#define AX_FW_MODE_179A			0x0001
+	#define AX_USB_EP5_EN			0x0001
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	#define AX_USB_EP4_EN			0x0002
+#endif
+#endif
+#define AX_WRITE_EFUSE_EN		0x09
+#define AX_WRITE_EFUSE_DIS		0x0A
+#define AX_ACCESS_MFAB			0x10
+#define AX_PHY_POLLING			0x90
+
+#define PHYSICAL_LINK_STATUS		0x02
+	#define	AX_USB_SS			0x04
+	#define	AX_USB_HS			0x02
+	#define	AX_USB_FS			0x01
+#define GENERAL_STATUS			0x03
+	#define	AX_SECLD			0x04
+#define AX_CHIP_STATUS			0x05
+	#define AX_CHIP_CODE_MASK		0x70
+	#define CHIP_CODE(x)		((x & AX_CHIP_CODE_MASK) >> 4)
+#define AX_SROM_ADDR			0x07
+#define AX_SROM_CMD			0x0a
+	#define EEP_RD				0x04
+	#define EEP_WR				0x08
+	#define EEP_BUSY			0x10
+#define AX_SROM_DATA_LOW		0x08
+#define AX_SROM_DATA_HIGH		0x09
+#define AX_RX_CTL			0x0b
+#define AX_RX_CTL_HI			0x0c
+	#define AX_RX_CTL_DROPCRCERR_HI		0x01
+	#define AX_RX_CTL_DROPCRCERR		0x0100
+	#define AX_RX_CTL_IPE			0x0200
+	#define AX_RX_CTL_TXPADCRC		0x0400
+	#define AX_RX_CTL_START			0x0080
+	#define AX_RX_CTL_AP			0x0020
+	#define AX_RX_CTL_AM			0x0010
+	#define AX_RX_CTL_AB			0x0008
+	#define AX_RX_CTL_HA8B			0x0004
+	#define AX_RX_CTL_AMALL			0x0002
+	#define AX_RX_CTL_PRO			0x0001
+	#define AX_RX_CTL_STOP			0x0000
+#define AX_NODE_ID			0x10
+#define AX_MULTI_FILTER_ARRY		0x16
+#define AX_MEDIUM_STATUS_MODE		0x22
+	#define AX_MEDIUM_GIGAMODE		0x0001
+	#define AX_MEDIUM_FULL_DUPLEX		0x0002
+	#define AX_MEDIUM_RXFLOW_CTRLEN		0x0010
+	#define AX_MEDIUM_TXFLOW_CTRLEN		0x0020
+	#define AX_MEDIUM_RECEIVE_EN		0x0100
+	#define AX_MEDIUM_PS			0x0200
+	#define AX_MEDIUM_JUMBO_EN		0x8040
+#define AX_MONITOR_MODE			0x24
+	#define AX_MONITOR_MODE_RWLC		0x02
+	#define AX_MONITOR_MODE_RWMP		0x04
+	#define AX_MONITOR_MODE_RWWF		0x08
+	#define AX_MONITOR_MODE_RW_FLAG		0x10
+	#define AX_MONITOR_MODE_PMEPOL		0x20
+	#define AX_MONITOR_MODE_PMETYPE		0x40
+#define AX_GPIO_CTRL			0x25
+	#define AX_GPIO_CTRL_GPIO3EN		0x80
+	#define AX_GPIO_CTRL_GPIO2EN		0x40
+	#define AX_GPIO_CTRL_GPIO1EN		0x20
+#define AX_PHYPWR_RSTCTL		0x26
+	#define AX_PHYPWR_RSTCTL_BZ		0x0010
+	#define AX_PHYPWR_RSTCTL_IPRL		0x0020
+	#define AX_PHYPWR_RSTCTL_AUTODETACH	0x1000
+#define AX_RX_BULKIN_QCTRL		0x2e
+	#define AX_RX_BULKIN_QCTRL_TIME		0x01
+	#define AX_RX_BULKIN_QCTRL_IFG		0x02
+	#define AX_RX_BULKIN_QCTRL_SIZE		0x04
+#define AX_RX_BULKIN_QTIMR_LOW		0x2f
+#define AX_RX_BULKIN_QTIMR_HIGH			0x30
+#define AX_RX_BULKIN_QSIZE			0x31
+#define AX_RX_BULKIN_QIFG			0x32
+#define AX_CLK_SELECT			0x33
+	#define AX_CLK_SELECT_BCS		0x01
+	#define AX_CLK_SELECT_ACS		0x02
+	#define AX_CLK_SELECT_ACSREQ		0x10
+	#define AX_CLK_SELECT_ULR		0x08
+#define AX_RXCOE_CTL			0x34
+	#define AX_RXCOE_IP			0x01
+	#define AX_RXCOE_TCP			0x02
+	#define AX_RXCOE_UDP			0x04
+	#define AX_RXCOE_ICMP			0x08
+	#define AX_RXCOE_IGMP			0x10
+	#define AX_RXCOE_TCPV6			0x20
+	#define AX_RXCOE_UDPV6			0x40
+	#define AX_RXCOE_ICMV6			0x80
+
+#if KERNEL_VERSION(2, 6, 22) < LINUX_VERSION_CODE
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP  | \
+					 AX_RXCOE_UDP	| AX_RXCOE_ICMV6 | \
+					 AX_RXCOE_TCPV6	| AX_RXCOE_UDPV6)
+#else
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP | \
+					 AX_RXCOE_UDP)
+#endif
+
+#define AX_TXCOE_CTL			0x35
+	#define AX_TXCOE_IP			0x01
+	#define AX_TXCOE_TCP			0x02
+	#define AX_TXCOE_UDP			0x04
+	#define AX_TXCOE_ICMP			0x08
+	#define AX_TXCOE_IGMP			0x10
+	#define AX_TXCOE_TCPV6			0x20
+	#define AX_TXCOE_UDPV6			0x40
+	#define AX_TXCOE_ICMV6			0x80
+#if KERNEL_VERSION(2, 6, 22) < LINUX_VERSION_CODE
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP   | AX_TXCOE_UDP | \
+					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
+#else
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP	| AX_TXCOE_UDP)
+#endif
+#define AX_PAUSE_WATERLVL_HIGH		0x54
+#define AX_PAUSE_WATERLVL_LOW		0x55
+#define AX_RX_FREE_BUF_LOW		0x57
+
+#define GMII_PHY_CONTROL		0x00
+	#define GMII_CONTROL_RESET		0x8000
+	#define GMII_CONTROL_LOOPBACK		0x4000
+	#define GMII_CONTROL_10MB		0x0000
+	#define GMII_CONTROL_100MB		0x2000
+	#define GMII_CONTROL_1000MB		0x0040
+	#define GMII_CONTROL_SPEED_BITS		0x2040
+	#define GMII_CONTROL_ENABLE_AUTO	0x1000
+	#define GMII_CONTROL_POWER_DOWN		0x0800
+	#define GMII_CONTROL_ISOLATE		0x0400
+	#define GMII_CONTROL_START_AUTO		0x0200
+	#define GMII_CONTROL_FULL_DUPLEX	0x0100
+#define GMII_PHY_STATUS			0x01
+	#define GMII_STATUS_100MB_MASK		0xE000
+	#define GMII_STATUS_10MB_MASK		0x1800
+	#define GMII_STATUS_AUTO_DONE		0x0020
+	#define GMII_STATUS_AUTO		0x0008
+	#define GMII_STATUS_LINK_UP		0x0004
+	#define GMII_STATUS_EXTENDED		0x0001
+	#define GMII_STATUS_100T4		0x8000
+	#define GMII_STATUS_100TXFD		0x4000
+	#define GMII_STATUS_100TX		0x2000
+	#define GMII_STATUS_10TFD		0x1000
+	#define GMII_STATUS_10T			0x0800
+#define GMII_PHY_OUI			0x02
+#define GMII_PHY_MODEL			0x03
+#define GMII_PHY_ANAR			0x04
+	#define GMII_ANAR_ASYM_PAUSE		0x0800
+	#define GMII_ANAR_PAUSE			0x0400
+	#define GMII_ANAR_100T4			0x0200
+	#define GMII_ANAR_100TXFD		0x0100
+	#define GMII_ANAR_100TX			0x0080
+	#define GMII_ANAR_10TFD			0x0040
+	#define GMII_ANAR_10T			0x0020
+	#define GMII_SELECTOR_FIELD		0x001F
+
+#define GMII_PHY_ANLPAR			0x05
+	#define GMII_ANLPAR_100T4		0x0200
+	#define GMII_ANLPAR_100TXFD		0x0100
+	#define GMII_ANLPAR_100TX		0x0080
+	#define GMII_ANLPAR_10TFD		0x0040
+	#define GMII_ANLPAR_10T			0x0020
+	#define GMII_ANLPAR_PAUSE		0x0400
+	#define GMII_ANLPAR_ASYM_PAUSE		0x0800
+	#define GMII_ANLPAR_ACK			0x4000
+	#define GMII_SELECTOR_8023		0x0001
+#define GMII_PHY_ANER			0x06
+#define GMII_PHY_1000BT_CONTROL		0x09
+#define GMII_PHY_1000BT_STATUS		0x0A
+#define GMII_PHY_MACR			0x0D
+#define GMII_PHY_MAADR			0x0E
+#define GMII_PHY_PHYSR			0x11
+	#define GMII_PHY_PHYSR_SMASK		0xc000
+	#define GMII_PHY_PHYSR_GIGA		0x8000
+	#define GMII_PHY_PHYSR_100		0x4000
+	#define GMII_PHY_PHYSR_FULL		0x2000
+	#define GMII_PHY_PHYSR_LINK		0x400
+
+#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
+#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200
+#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100
+#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800
+#define GMII_1000_AUX_STATUS_HD_CAPABLE		0x0400
+#define GMII_AUX_CTRL_STATUS		0x1C
+#define GMII_AUX_ANEG_CPLT			0x8000
+#define GMII_AUX_FDX				0x0020
+#define GMII_AUX_SPEED_1000			0x0010
+#define GMII_AUX_SPEED_100			0x0008
+#define GMII_LED_ACTIVE			0x1a
+	#define GMII_LED_ACTIVE_MASK		0xff8f
+	#define GMII_LED0_ACTIVE		(1 << 4)
+	#define GMII_LED1_ACTIVE		(1 << 5)
+	#define GMII_LED2_ACTIVE		(1 << 6)
+#define GMII_LED_LINK			0x1c
+	#define GMII_LED_LINK_MASK		0xf888
+	#define GMII_LED0_LINK_10		(1 << 0)
+	#define GMII_LED0_LINK_100		(1 << 1)
+	#define GMII_LED0_LINK_1000		(1 << 2)
+	#define GMII_LED1_LINK_10		(1 << 4)
+	#define GMII_LED1_LINK_100		(1 << 5)
+	#define GMII_LED1_LINK_1000		(1 << 6)
+	#define GMII_LED2_LINK_10		(1 << 8)
+	#define GMII_LED2_LINK_100		(1 << 9)
+	#define GMII_LED2_LINK_1000		(1 << 10)
+	#define	LED_VALID			(1 << 15)
+	#define	LED0_ACTIVE			(1 << 0)
+	#define	LED0_LINK_10			(1 << 1)
+	#define	LED0_LINK_100			(1 << 2)
+	#define	LED0_LINK_1000			(1 << 3)
+	#define	LED0_FD				(1 << 4)
+	#define LED0_USB3_MASK			0x001f
+	#define	LED1_ACTIVE			(1 << 5)
+	#define	LED1_LINK_10			(1 << 6)
+	#define	LED1_LINK_100			(1 << 7)
+	#define	LED1_LINK_1000			(1 << 8)
+	#define	LED1_FD				(1 << 9)
+	#define LED1_USB3_MASK			0x03e0
+	#define	LED2_ACTIVE			(1 << 10)
+	#define	LED2_LINK_1000			(1 << 13)
+	#define	LED2_LINK_100			(1 << 12)
+	#define	LED2_LINK_10			(1 << 11)
+	#define	LED2_FD				(1 << 14)
+	#define LED2_USB3_MASK			0x7c00
+#define GMII_PHYPAGE			0x1e
+#define GMII_PHY_PAGE_SELECT		0x1f
+	#define GMII_PHY_PAGE_SELECT_EXT	0x0007
+	#define GMII_PHY_PAGE_SELECT_PAGE0	0X0000
+	#define GMII_PHY_PAGE_SELECT_PAGE1	0X0001
+	#define GMII_PHY_PAGE_SELECT_PAGE2	0X0002
+	#define GMII_PHY_PAGE_SELECT_PAGE3	0X0003
+	#define GMII_PHY_PAGE_SELECT_PAGE4	0X0004
+	#define GMII_PHY_PAGE_SELECT_PAGE5	0X0005
+	#define GMII_PHY_PAGE_SELECT_PAGE6	0X0006
+
+enum ax_driver_flags {
+	AX_UNPLUG = 0,
+	AX_ENABLE,
+	AX_LINK_CHG,
+	AX_SELECTIVE_SUSPEND,
+	AX_SCHEDULE_NAPI,
+	AX_EN_RX,
+	AX_SCHEDULE_TASKLET_TX,
+	AX_SCHEDULE_TASKLET_RX,
+};
+
+enum ax_chip_version {
+	AX_VERSION_INVALID		= 0,
+	AX_VERSION_AX88179		= 4,
+	AX_VERSION_AX88179A_772D	= 6,
+#ifdef ENABLE_AX88279
+	AX_VERSION_AX88279		= 7,
+#endif
+};
+
+struct ax_device;
+
+struct rx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+};
+
+enum __ax_tx_flags {
+	AX_TX_NONE		= 0,
+	AX_TX_TIMESTAMPS	= 1,
+};
+
+enum __mac_pass_ctrl {
+	MAC_PASS_DISABLED	= 0,
+	MAC_PASS_ENABLE_0	= 1,
+	MAC_PASS_ENABLE_1	= 2,
+};
+
+struct mac_pass {
+	u8	control;
+	u8	mac0[8];
+	u8	mac1[8];
+} __packed;
+
+struct tx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+	u32 skb_num;
+	u32 skb_len;
+	unsigned long flags;
+	int q_index;
+};
+
+struct ax_bulkin_setting {
+	u8 custom;
+	u8 bulkin_setting[5];
+};
+
+enum ax_ether_link_speed {
+	ETHER_LINK_NONE	= 0,
+	ETHER_LINK_10	= 1,
+	ETHER_LINK_100	= 2,
+	ETHER_LINK_1000	= 3,
+	ETHER_LINK_2500	= 4,
+};
+
+struct ax_link_info {
+	u8 eth_speed	: 3,
+	   full_duplex	: 1,
+	   usb_speed	: 4;
+} __packed;
+
+struct ax_device {
+	unsigned long flags;
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct net_device *netdev;
+	const struct driver_info *driver_info;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct napi;
+#endif
+	struct urb *intr_urb;
+	struct tx_desc tx_list[32];
+	struct rx_desc rx_list[32];
+	struct list_head rx_done, tx_free;
+	struct sk_buff_head tx_queue[AX_TX_QUEUE_SIZE];
+	struct sk_buff_head rx_queue;
+	spinlock_t rx_lock, tx_lock;
+	struct delayed_work schedule;
+	struct mii_if_info mii;
+	struct mutex control;
+#ifdef ENABLE_TX_TASKLET
+	struct tasklet_struct tx_tl;
+#endif
+#ifdef ENABLE_RX_TASKLET
+	struct tasklet_struct rx_tl;
+#endif
+
+	int intr_interval;
+	u32 saved_wolopts;
+	u32 msg_enable;
+	u32 tx_qlen;
+	u32 coalesce;
+	u16 speed;
+	u8 *intr_buff;
+	u8 tx_align_len;
+	u8 link;
+	u16 rxctl;
+	u8 m_filter[8];
+	u32 tx_casecade_size;
+	u32 gso_max_size;
+	u8 fw_version[4];
+
+	struct ax_link_info link_info;
+	struct ax_link_info intr_link_info;
+	u8  eee_enabled;
+	u8  eee_active;
+	int autodetach;
+
+	struct ax_bulkin_setting bin_setting;
+	bool tx_header_cksum;
+	unsigned char chip_version;
+	unsigned char sub_version;
+#define AX_ETH_SPEED_MASK	0xF
+#define AX_ETH_DUPLEX_FULL	0x10
+	u8 int_link_info;
+	u8 int_link_chg;
+
+#ifdef ENABLE_PTP_FUNC
+	struct ax_ptp_cfg *ptp_cfg;
+	struct sk_buff_head tx_timestamp;
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	struct ax_macsec_cfg *macsec_cfg;
+#endif
+	u64 bulkin_complete;
+	u64 bulkin_error;
+	u64 bulkout_complete;
+	u64 bulkout_error;
+	u64 bulkint_complete;
+	u64 bulkint_error;
+#ifdef ENABLE_QUEUE_PRIORITY
+	u64 ep5_count;
+	u64 ep3_count;
+#endif
+#define CHIP_40PIN	0x03
+#define CHIP_32PIN	0x02
+	u8 chip_pin;
+#ifdef ENABLE_INT_POLLING
+#define INT_POLLING_TIMER	128	/* in milliseconds */
+	struct delayed_work int_polling_work;
+#endif
+	unsigned autosuspend_is_supported:1;
+};
+
+struct driver_info {
+	int	(*bind)(struct ax_device *axdev);
+	void	(*unbind)(struct ax_device *axdev);
+	int	(*hw_init)(struct ax_device *axdev);
+	int	(*stop)(struct ax_device *axdev);
+#ifdef ENABLE_QUEUE_PRIORITY
+	int	(*queue_priority)(struct ax_device *axdev);
+#endif
+	void	(*rx_fixup)(struct ax_device *axdev, struct rx_desc *desc,
+			    int *work_done, int budget);
+	int	(*tx_fixup)(struct ax_device *axdev, struct tx_desc *desc);
+	int	(*link_reset)(struct ax_device *axdev);
+	int	(*link_setting)(struct ax_device *axdev);
+	int	(*system_suspend)(struct ax_device *axdev);
+	int	(*system_resume)(struct ax_device *axdev);
+	int	(*runtime_suspend)(struct ax_device *axdev);
+	int	(*runtime_resume)(struct ax_device *axdev);
+
+#ifdef ENABLE_PTP_FUNC
+	int (*ptp_pps_ctrl)(struct ax_device *axdev, u8 enable);
+	int	(*ptp_init)(struct ax_device *axdev);
+	void	(*ptp_remove)(struct ax_device *axdev);
+#endif
+
+	unsigned long napi_weight;
+	size_t	buf_rx_size;
+};
+
+struct _async_cmd_handle {
+	struct ax_device *axdev;
+	struct usb_ctrlrequest *req;
+	u8 m_filter[8];
+	u16 rxctl;
+} __packed;
+
+#define AX_INT_PPLS_LINK	(1 << 0)
+#define AX_INT_SPLS_LINK	(1 << 1)
+#define AX_INT_CABOFF_UNPLUG	(1 << 7)
+struct ax_device_int_data {
+#ifdef __BIG_ENDIAN
+	u16 res3;
+	u8 status;
+	u16 res2;
+	u8 link;
+	union {
+		struct ax_link_info link_info;
+		u8 link_info_u8;
+	};
+	u8 res1;
+#else
+	u8 res1;
+	union {
+		struct ax_link_info link_info;
+		u8 link_info_u8;
+	};
+	u8 link;
+	u16 res2;
+	u8 status;
+	u16 res3;
+#endif
+} __packed;
+
+struct _ax_buikin_setting {
+	u8 ctrl;
+	u8 timer_l;
+	u8 timer_h;
+	u8 size;
+	u8 ifg;
+} __packed;
+
+#define AX_RXHDR_L4_ERR		(1 << 8)
+#define AX_RXHDR_L3_ERR		(1 << 9)
+
+#define AX_RXHDR_L4_TYPE_ICMP	2
+#define AX_RXHDR_L4_TYPE_IGMP	3
+#define AX_RXHDR_L4_TYPE_TCMPV6	5
+
+#define AX_RXHDR_L3_TYPE_IP	1
+#define AX_RXHDR_L3_TYPE_IPV6	2
+
+#define AX_RXHDR_L4_TYPE_MASK	0x1c
+#define AX_RXHDR_L4_TYPE_UDP	4
+#define AX_RXHDR_L4_TYPE_TCP	16
+#define AX_RXHDR_L3CSUM_ERR	2
+#define AX_RXHDR_L4CSUM_ERR	1
+#define AX_RXHDR_CRC_ERR	0x20000000
+#define AX_RXHDR_MII_ERR	0x40000000
+#define AX_RXHDR_DROP_ERR	0x80000000
+
+static inline void *__rx_buf_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, RX_ALIGN);
+}
+static inline void *__tx_buf_align(void *data, u8 tx_align_len)
+{
+	return (void *)ALIGN((uintptr_t)data, tx_align_len);
+}
+static inline struct net_device_stats *ax_get_stats(struct net_device *netdev)
+{
+	return &netdev->stats;
+}
+
+int ax_get_mac_pass(struct ax_device *axdev, u8 *mac);
+void ax_set_tx_qlen(struct ax_device *dev);
+void ax_write_bulk_callback(struct urb *urb);
+
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info);
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+int ax_get_settings(struct net_device *net, struct ethtool_cmd *cmd);
+int ax_set_settings(struct net_device *net, struct ethtool_cmd *cmd);
+#else
+int ax_get_link_ksettings(struct net_device *netdev,
+			  struct ethtool_link_ksettings *cmd);
+int ax_set_link_ksettings(struct net_device *netdev,
+			  const struct ethtool_link_ksettings *cmd);
+#endif
+u32 ax_get_msglevel(struct net_device *netdev);
+void ax_set_msglevel(struct net_device *netdev, u32 value);
+void ax_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
+int ax_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
+int ax_get_sset_count(struct net_device *dev, int sset);
+void ax_get_ethtool_stats
+(struct net_device *dev, struct ethtool_stats *stats, u64 *data);
+void ax_get_strings(struct net_device *netdev, u32 stringset, u8 *data);
+void ax_get_pauseparam
+(struct net_device *netdev, struct ethtool_pauseparam *pause);
+int ax_set_pauseparam
+(struct net_device *netdev, struct ethtool_pauseparam *pause);
+int ax_get_regs_len(struct net_device *netdev);
+void ax_get_regs
+(struct net_device *netdev, struct ethtool_regs *regs, void *buf);
+
+int ax_read_cmd
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data,
+int eflag);
+
+int ax_write_cmd
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_read_cmd_nopm
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data,
+int eflag);
+
+int ax_write_cmd_nopm
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_write_cmd_async
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_mmd_read(struct net_device *netdev, int dev_addr, int reg);
+void ax_mmd_write(struct net_device *netdev, int dev_addr, int reg, int val);
+
+int ax_mdio_read(struct net_device *netdev, int phy_id, int reg);
+void ax_mdio_write(struct net_device *netdev, int phy_id, int reg, int val);
+
+
+int ax_usb_command(struct ax_device *axdev, struct _ax_ioctl_command *info);
+#endif /* __ASIX_MAIN_H */
diff --git a/drivers/net/usb/asix_usb/ax_ptp.c b/drivers/net/usb/asix_usb/ax_ptp.c
new file mode 100755
index 000000000000..e46373493a08
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ptp.c
@@ -0,0 +1,1167 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax_ptp.h"
+#include "ax88179a_772d.h"
+
+#define ptp_to_dev(ptp) container_of(ptp, struct ax_ptp_cfg, ptp_caps)
+
+static void ax_reset_ptp_queue(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (!ptp_cfg)
+		return;
+
+	ptp_cfg->ptp_head = 0;
+	ptp_cfg->ptp_tail = 0;
+	ptp_cfg->num_items = 0;
+	ptp_cfg->get_timestamp_retry = 0;
+
+	memset(ptp_cfg->tx_ptp_info, 0, AX_PTP_INFO_SIZE * AX_PTP_QUEUE_SIZE);
+}
+
+static int ax88179a_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 remainder = 0;
+	u64 high_timer = 0;
+	s64 sec = 0, rnsec = 0;
+	s64 nsec = 0;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_OP, AX_GET_LOCAL_CLOCK, 0,
+			  AX_GET_LOCAL_CLOCK_SIZE, &timestamp, 0);
+	if (ret < 0)
+		return ret;
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	sec *= NSEC_PER_SEC;
+	rnsec = (nsec + sec + delta);
+
+	high_timer = div_u64_rem(rnsec, NSEC_PER_SEC, &remainder);
+	memcpy(timestamp, &remainder, 4);
+	memcpy(&timestamp[4], &high_timer, 6);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_LOCAL_CLOCK, 0,
+			    AX_SET_LOCAL_CLOCK_SIZE, &timestamp);
+	if (ret < 0)
+		return ret;
+
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int
+ax88179a_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+#else
+static int
+ax88179a_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	long ppb = scaled_ppm_to_ppb(scaled_ppm);
+#endif
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 new_addend_val;
+	u64 adjust_val;
+	int neg_adj = 0, ret;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	adjust_val = AX_BASE_ADDEND;
+	adjust_val *= ppb;
+	adjust_val = div_u64(adjust_val, NSEC_PER_SEC);
+
+	if (neg_adj)
+		new_addend_val = (u32)(AX_BASE_ADDEND - adjust_val);
+	else
+		new_addend_val = (u32)(AX_BASE_ADDEND + adjust_val);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ADDEND, 0,
+			   AX_SET_ADDEND_SIZE, &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88179a_ptp_gettime64
+(struct ptp_clock_info *ptp, struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec = 0;
+	u32 nsec = 0;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_OP, AX_GET_LOCAL_CLOCK, 0,
+			  AX_GET_LOCAL_CLOCK_SIZE, &timestamp, 0);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	ts->tv_nsec = nsec;
+	ts->tv_sec = sec;
+
+	return 0;
+}
+
+static int ax88179a_ptp_settime64
+(struct ptp_clock_info *ptp, const struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec;
+	u32 nsec;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	nsec = (u32)ts->tv_nsec;
+	memcpy(timestamp, &nsec, 4);
+	sec = (u64)ts->tv_sec;
+	memcpy(&timestamp[4], &sec, 6);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_LOCAL_CLOCK, 0,
+			    AX_SET_LOCAL_CLOCK_SIZE, &timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax_ptp_enable(struct ptp_clock_info *ptp,
+			 struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info ax88179a_772d_ptp_clock = {
+	.owner		= THIS_MODULE,
+	.name		= "asix ptp",
+	.max_adj	= 100000000,
+	.n_ext_ts	= 0,
+	.pps		= 0,
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
+	.adjfine	= NULL,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	.adjfine	= ax88179a_ptp_adjfine,
+#else
+	.adjfreq	= ax88179a_ptp_adjfreq,
+#endif
+	.adjtime	= ax88179a_ptp_adjtime,
+	.gettime64	= ax88179a_ptp_gettime64,
+	.settime64	= ax88179a_ptp_settime64,
+	.n_per_out	= 0,
+	.enable		= ax_ptp_enable,
+	.n_pins		= 0,
+	.verify		= NULL,
+	.pin_config	= NULL,
+};
+
+int ax88179a_ptp_init(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u32 new_addend_val = AX_BASE_ADDEND;
+	u8 reg8;
+	u8 ptpset;
+	u8 ptp_tx_delay[5] = { 0 };
+	u8 ptp_rx_delay[5] = { 0 };
+	u32 reg32;
+	u32 timeout = 0;
+	int ret;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+	if (axdev->sub_version < 3)
+		return 0;
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ADDEND, 0,
+			   AX_SET_ADDEND_SIZE, &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_PTP_PERIOD;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_TIMER_PERIOD,
+			    0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_2,
+			   0, 1, &reg8, 0);
+	if (ret < 0)
+		return ret;
+	reg8 |= AX_PTP_CTRL_SET_PERIOD;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_2, 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1,
+			   0, 1, &ptpset, 0);
+	if (ret < 0)
+		return ret;
+	ptpset |= AX_PTP_CTRL_L3_EN | AX_PTP_CTRL_EN | AX_PTP_TX_PLUS_DELAY |
+		  AX_PTP_TX_FILTER_GENERAL_MSG | AX_PTP_RX_FILTER_GENERAL_MSG;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1,
+			    0, 1, &ptpset);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_179A_PTP_INFO_SEG_SIZE * AX_PTP_HW_QUEUE_SIZE;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_MEM_SEG_SIZE,
+			   0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	do {
+		reg8 = 0;
+		ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_MEM_SEG_SET,
+				   0, 1, &reg8);
+		if (ret < 0)
+			return ret;
+
+		ret = ax_read_cmd(axdev, AX_PTP_CMD,
+				  AX88179A_PTP_MEM_SEG_STATUS, 0, 1, &reg8, 0);
+		if (ret < 0)
+			return ret;
+		reg8 &= AX_PTP_MEM_SEG_MASK;
+
+		if (timeout++ > 5)
+			break;
+	} while (reg8 != AX_PTP_MEM_SEG_0);
+
+	reg32 = AX_PPS_ACTIVE_DEFAULT_TIME;
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ACTIVE_TIME, 0,
+			   AX_SET_ACTIVE_TIME_SIZE, &reg32);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_100:
+		ptp_tx_delay[0] = 0x64;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0x22;
+		ptp_rx_delay[1] = 0x01;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	case ETHER_LINK_10:
+		ptp_tx_delay[0] = 0xB7;
+		ptp_tx_delay[1] = 0x0F;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0xAC;
+		ptp_rx_delay[1] = 0x0A;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		ptp_tx_delay[0] = 0x6E;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0xE4;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	}
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_TX_PHY_DELAY, 0,
+			   AX_SET_TX_PHY_DELAY_SIZE, ptp_tx_delay);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_RX_PHY_DELAY, 0,
+			   AX_SET_RX_PHY_DELAY_SIZE, ptp_rx_delay);
+	if (ret < 0)
+		return ret;
+
+	axdev->netdev->features &= ~(NETIF_F_SG | NETIF_F_TSO);
+	axdev->netdev->hw_features &= ~(NETIF_F_SG | NETIF_F_TSO);
+	axdev->netdev->vlan_features &= ~(NETIF_F_SG | NETIF_F_TSO);
+
+	return 0;
+}
+
+int ax88179a_ptp_pps_ctrl(struct ax_device *axdev, u8 enable)
+{
+	u32 reg32 = 0;
+	int ret;
+	
+	ret = ax_read_cmd(axdev, AX88179A_PBUS_REG, 0x1894, 0x000F, 4, &reg32, 1);
+	if (ret < 0)
+		return ret;
+
+	reg32 &= ~0x01000000;
+
+	if (enable) 
+		reg32 |= 0x01000000;
+
+	ret = ax_write_cmd(axdev, AX88179A_PBUS_REG, 0x1894, 0x000F, 4, &reg32);
+	if (ret < 0)
+		return ret;
+	
+	return 0;
+}
+
+int ax88279_ptp_pps_ctrl(struct ax_device *axdev, u8 enable)
+{
+	u32 reg32 = 0;
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PBUS_A32, 0xF8C8, 0x000C, 4, &reg32, 1);
+	if (ret < 0)
+		return ret;
+
+	reg32 &= ~0x00004000;
+	
+	if (enable) 
+		reg32 |= 0x00004000;
+
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, 0xF8C8, 0x000C, 4, &reg32);
+
+	return 0;
+}
+
+void ax88179a_ptp_remove(struct ax_device *axdev)
+{
+	u8 reg8;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+	if (axdev->sub_version < 3)
+		return;
+
+	ax_read_cmd(axdev, AX_PTP_CMD,  AX88179A_PTP_CTRL_1, 0, 1, &reg8, 0);
+	reg8 &= ~(AX_PTP_CTRL_L3_EN | AX_PTP_CTRL_EN);
+	ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1, 0, 1, &reg8);
+}
+
+void ax_ptp_unregister(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (axdev->driver_info->ptp_remove)
+		axdev->driver_info->ptp_remove(axdev);
+
+	if (ptp_cfg) {
+		if (ptp_cfg->ptp_clock)
+			ptp_clock_unregister(ptp_cfg->ptp_clock);
+	}
+}
+
+static u8 ax_find_ptp_item(struct ax_device *axdev, struct _ptp_header *ptp,
+			   struct sk_buff *skb)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info = ptp_cfg->tx_ptp_info;
+	u16 sequence_id;
+	u8 message_type = ptp->message_type;
+	int i, read_ptr;
+
+	read_ptr = ptp_cfg->ptp_head;
+#ifdef ENABLE_PTP_DEBUG
+	printk("%s - ptp_head: %d", __func__, read_ptr);
+#endif
+
+	if (axdev->chip_version == AX_VERSION_AX88179A_772D)
+		sequence_id = ntohs(ptp->sequence_id) & 0xFF;
+	else
+		sequence_id = ntohs(ptp->sequence_id) & 0xFFFF;
+
+	for (i = 0; i < ptp_cfg->num_items; i++) {
+		if ((temp_ptp_info[read_ptr].sequence_id == sequence_id) &&
+		    (temp_ptp_info[read_ptr].msg_type == message_type)) {
+			struct skb_shared_hwtstamps shhwtstamps;
+			u64 timestamp_h, timestamp_l, temp;
+			u64 time64;
+
+			ptp_cfg->num_items--;
+			ptp_cfg->ptp_head++;
+			if (ptp_cfg->ptp_head == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_head = 0;
+			timestamp_l = temp_ptp_info[read_ptr].nsec;
+			timestamp_h = temp_ptp_info[read_ptr].sec_l;
+			temp = temp_ptp_info[read_ptr].sec_h;
+			timestamp_h |= (temp << 32);
+			time64 = timestamp_h * NSEC_PER_SEC;
+			time64 += timestamp_l & 0xFFFFFFFF;
+			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+			shhwtstamps.hwtstamp = ns_to_ktime(time64);
+			if (ptp->flags & 0x2 ||
+			    (ptp->message_type != 0 && ptp->message_type != 3))
+				skb_tstamp_tx(skb, &shhwtstamps);
+#ifdef ENABLE_PTP_DEBUG
+			printk("%s - skb_tstamp_tx return", __func__);
+#endif
+			dev_kfree_skb_any(skb);
+			return 0;
+		}
+		read_ptr++;
+		if (read_ptr == AX_PTP_QUEUE_SIZE)
+			read_ptr = 0;
+	}
+	return AX_PTP_QUEUE_SIZE;
+}
+
+static void ax_tx_check_timestamp(struct ax_device *axdev, struct sk_buff *skb)
+{
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+		struct _ptp_header ptp;
+		unsigned int ptp_msg_offset;
+		u16 tmp, tx_ethertype, vlan_id = 0;
+		u8 vlan_size = 0, ptp_item = AX_PTP_QUEUE_SIZE;
+
+		skb_copy_from_linear_data_offset(skb, AX_ETHTYPE_OFFSET,
+						 &tmp, 2);
+		tx_ethertype = ntohs(tmp);
+		if (tx_ethertype == ETH_P_8021Q) {
+			skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 2,
+							 &tmp, 2);
+			vlan_id = ntohs(tmp) & 0xFFF;
+			vlan_size = 4;
+			skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 4,
+							 &tmp, 2);
+			tx_ethertype = ntohs(tmp);
+			if (tx_ethertype == ETH_P_8021Q) {
+				vlan_size = 8;
+				skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 4,
+							 &tmp, 2);
+				tx_ethertype = ntohs(tmp);
+			}
+		}
+		ptp_msg_offset = vlan_size;
+		if (tx_ethertype == ETH_P_1588)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L2;
+		else if (tx_ethertype == ETH_P_IP)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L3_IP;
+		else if (tx_ethertype == ETH_P_IPV6)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L3_IPV6;
+		else
+			return;
+
+		skb_copy_from_linear_data_offset(skb, ptp_msg_offset,
+						 &ptp, PTP_HDR_SIZE);
+
+		ptp_item = ax_find_ptp_item(axdev, &ptp, skb);
+		if (ptp_item == AX_PTP_QUEUE_SIZE) {
+			dev_err(&axdev->intf->dev,
+				"Not found item from PTP queue");
+			return;
+		}
+	}
+}
+
+static void ax_tx_timestamp(struct ax_device *axdev)
+{
+	struct sk_buff_head *tx_timestamp = &axdev->tx_timestamp;
+
+	while (!skb_queue_empty(tx_timestamp)) {
+		struct sk_buff *skb;
+
+		skb = __skb_dequeue(tx_timestamp);
+		if (!skb)
+			return;
+
+		ax_tx_check_timestamp(axdev, skb);
+	}
+}
+
+static struct _ax_ptp_info *ax_ptp_info_transform(struct ax_device *axdev,
+						  void *data)
+{
+	struct _ax_ptp_info temp[AX_PTP_HW_QUEUE_SIZE] = {0};
+	int i;
+
+	switch (axdev->chip_version) {
+	case AX_VERSION_AX88179A_772D:
+	{
+		struct _179a_ptp_info *_179a_ptp = (typeof(_179a_ptp))data;
+
+		for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+			memcpy(&temp[i], &_179a_ptp[i], 2);
+			temp[i].sequence_id &= 0xFF;
+			memcpy(&temp[i].nsec, &_179a_ptp[i].nsec, 10);
+		}
+		memcpy(data, temp, AX_PTP_INFO_SIZE);
+		break;
+	}
+	};
+
+	return (struct _ax_ptp_info *)data;
+}
+
+
+#if KERNEL_VERSION(2, 6, 20) > LINUX_VERSION_CODE
+static void ax_ptp_ts_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax_ptp_ts_callback(struct urb *urb)
+#endif
+{
+	struct _ax_ptp_usb_info *ptp_info = (typeof(ptp_info))urb->context;
+	struct ax_device *axdev = (struct ax_device *)ptp_info->axdev;
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info = ptp_info->ax_ptp_info;
+	int i, count = 0;
+#ifdef ENABLE_PTP_DEBUG
+	printk("%s - Start urb->actual_length: %d",
+		__func__, urb->actual_length);
+#endif
+	if (urb->status < 0) {
+		printk(KERN_ERR "failed get ts (%d)", urb->status);
+		goto free;
+	}
+
+	temp_ptp_info = ax_ptp_info_transform(axdev, ptp_info->ax_ptp_info);
+	if (temp_ptp_info == NULL) {
+		printk(KERN_ERR "Failed to transform ptp info.");
+		goto free;
+	}
+
+	for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+		if (temp_ptp_info[i].status) {
+			ptp_cfg->tx_ptp_info[ptp_cfg->ptp_tail++] = temp_ptp_info[i];
+			if (ptp_cfg->ptp_tail == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_tail = 0;
+			ptp_cfg->num_items++;
+#ifdef ENABLE_PTP_DEBUG
+printk("### ptp_tail: %ld, ptp_head: %ld, num_items: %ld",
+	ptp_cfg->ptp_tail, ptp_cfg->ptp_head, ptp_cfg->num_items);
+printk("### (%s) - DATA %d -------------###", __func__, i);
+printk("### status: %d", temp_ptp_info[i].status);
+printk("### type: 0x%02x", temp_ptp_info[i].msg_type);
+printk("### s_id: 0x%04x", temp_ptp_info[i].sequence_id);
+printk("### nsec: 0x%08x", temp_ptp_info[i].nsec);
+printk("###  sec: 0x%04x%08x", temp_ptp_info[i].sec_h, temp_ptp_info[i].sec_l);
+printk("### ----------------------------###\n");
+#endif
+			count++;
+			ptp_cfg->get_timestamp_retry = 0;
+		}
+	}
+	if (count == 0 &&
+	    ptp_cfg->get_timestamp_retry < EP0_GET_TIMESTAMP_RETRY) {
+		ax_ptp_ts_read_cmd_async(axdev);
+		ptp_cfg->get_timestamp_retry++;
+		goto free;
+	}
+
+	if (ptp_cfg->get_timestamp_retry == EP0_GET_TIMESTAMP_RETRY)
+		dev_err(&axdev->intf->dev, "Get timestamp failed.");
+
+	ax_tx_timestamp(axdev);
+free:
+	kfree(temp_ptp_info);
+	usb_free_urb(urb);
+}
+
+int ax_ptp_ts_read_cmd_async(struct ax_device *axdev)
+{
+	struct usb_ctrlrequest *req;
+	int status = 0;
+	struct urb *urb;
+	struct _ax_ptp_usb_info *info;
+	u16 size = AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE;
+
+	if (axdev->chip_version > AX_VERSION_AX88179A_772D)
+		return 0;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		dev_err(&axdev->intf->dev,
+			   "Error allocating URB in write_cmd_async!");
+		return -ENOMEM;
+	}
+
+	info = kzalloc(sizeof(struct _ax_ptp_usb_info), GFP_ATOMIC);
+	if (!info) {
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	info->axdev = axdev;
+	req = &info->req;
+
+	req->bRequestType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = AX_PTP_TIMESTAMP;
+	req->wValue = cpu_to_le16(0);
+	req->wIndex = cpu_to_le16(0);
+	req->wLength = cpu_to_le16(size);
+
+	memset(info->ax_ptp_info, 0, AX_PTP_INFO_SIZE * AX_PTP_QUEUE_SIZE);
+
+	usb_fill_control_urb(urb, axdev->udev,
+			     usb_sndctrlpipe(axdev->udev, 0),
+			     (void *)req, info->ax_ptp_info, size,
+			     ax_ptp_ts_callback, info);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		dev_err(&axdev->intf->dev,
+			   "Error submitting the control message: status=%d",
+			   status);
+		kfree(info);
+		usb_free_urb(urb);
+	}
+
+	return 0;
+}
+
+void ax_rx_get_timestamp(struct sk_buff *skb, u64 *pkt_hdr)
+{
+	struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+	u64 timestamp_h, timestamp_l;
+	u64 time64;
+
+	timestamp_l = *((u64 *)(++pkt_hdr));
+	timestamp_h = *((u64 *)(++pkt_hdr));
+#ifdef ENABLE_PTP_DEBUG
+	printk("### (%s) h: 0x%llx, l: 0x%llx %lld###", __func__,
+		timestamp_h, timestamp_l, timestamp_l);
+#endif
+	timestamp_h <<= 32;
+	timestamp_h |= (timestamp_l >> 32) & 0xFFFFFFFF;
+	time64 = (timestamp_h * NSEC_PER_SEC);
+	time64 += (timestamp_l & 0xFFFFFFFF);
+#ifdef ENABLE_PTP_DEBUG
+	printk("### (%s) h: %lld, time64: %lld ###", __func__,
+		timestamp_h, time64);
+#endif
+	memset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamps->hwtstamp = ns_to_ktime(time64);
+}
+
+#ifdef ENABLE_AX88279
+static int ax_ptp_pbus_write(struct ax_device *axdev, u16 offset, u16 len,
+			     void *data)
+{
+	int ret = 0;
+
+	ret = ax_write_cmd(axdev,
+			    AX_PBUS_A32,
+			    offset,
+			    AX_PTP_REG_BASE_ADDR_HI,
+			    len,
+			    data);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int ax_ptp_clk_write(struct ax_device *axdev, u16 offset, u16 len,
+			    void *data)
+{
+	int ret = 0;
+
+	ret = ax_write_cmd(axdev,
+			    AX_PBUS_A32,
+			    offset,
+			    AX_PTP_REG_BASE_ADDR_HI,
+			    len,
+			    data);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int ax_ptp_clk_read(struct ax_device *axdev, u16 offset, u16 len,
+			   void *data)
+{
+	int ret = 0;
+
+	ret = ax_read_cmd(axdev,
+			   AX_PTP_CLK,
+			   0x0002,
+			   offset,
+			   len,
+			   data,
+			   0);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int ax88279_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+#else
+static int ax88279_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	long ppb = scaled_ppm_to_ppb(scaled_ppm);
+#endif
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 new_addend_val;
+	u64 adjust_val;
+	int neg_adj = 0, ret;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	adjust_val = AX_BASE_ADDEND;
+	adjust_val *= ppb;
+	adjust_val = div_u64(adjust_val, NSEC_PER_SEC);
+
+	if (neg_adj)
+		new_addend_val = (u32)(AX_BASE_ADDEND - adjust_val);
+	else
+		new_addend_val = (u32)(AX_BASE_ADDEND + adjust_val);
+
+	ret = ax_ptp_pbus_write(axdev,
+			   AX_PTP_TIMER_ADDEND,
+			   sizeof(new_addend_val),
+			   &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 remainder = 0;
+	u64 high_timer = 0;
+	s64 sec = 0;
+	s64 nsec = 0;
+	u8 timestamp[12] = {0};
+	int ret;
+
+	ret = ax_ptp_clk_read(axdev, AX_PTP_GET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	sec *= NSEC_PER_SEC;
+	nsec = (sec + delta);
+
+	high_timer = div_u64_rem(nsec, NSEC_PER_SEC, &remainder);
+	memcpy(timestamp, &remainder, 4);
+	memcpy(&timestamp[4], &high_timer, 6);
+
+	ret = ax_ptp_clk_write(axdev, AX_PTP_SET_80B_LCK_VAL0, 12, timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_ptp_gettime64(struct ptp_clock_info *ptp,
+				struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec = 0;
+	u32 nsec = 0;
+	u8 timestamp[12] = {0};
+	int ret;
+
+	ret = ax_ptp_clk_read(axdev, AX_PTP_GET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	ts->tv_nsec = nsec;
+	ts->tv_sec = sec;
+
+	return 0;
+}
+
+static int ax88279_ptp_settime64(struct ptp_clock_info *ptp,
+				const struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec;
+	u32 nsec;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	nsec = (u32)ts->tv_nsec;
+	memcpy(timestamp, &nsec, 4);
+	sec = (u64)ts->tv_sec;
+	memcpy(&timestamp[4], &sec, 6);
+
+	ret = ax_ptp_clk_write(axdev, AX_PTP_SET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct ptp_clock_info ax88279_ptp_clock = {
+	.owner		= THIS_MODULE,
+	.name		= "asix ptp",
+	.max_adj	= 100000000,
+	.n_ext_ts	= 0,
+	.pps		= 0,
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
+	.adjfine	= NULL,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	.adjfine	= ax88279_ptp_adjfine,
+#else
+	.adjfreq	= ax88279_ptp_adjfreq,
+#endif
+	.adjtime	= ax88279_ptp_adjtime,
+	.gettime64	= ax88279_ptp_gettime64,
+	.settime64	= ax88279_ptp_settime64,
+	.n_per_out	= 0,
+	.enable		= ax_ptp_enable,
+	.n_pins		= 0,
+	.verify		= NULL,
+	.pin_config	= NULL,
+};
+
+int ax88279_ptp_init(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u32 reg32;
+	u8 reg8;
+	int ret;
+
+	ax_reset_ptp_queue(axdev);
+
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+
+	reg32 = (AX_PTP_MEM_SEG_SIZE_279_5 << 24) |
+		(AX_PTP_MEM_START_ADDR << 8) | AX_PTP_PTP_CPU_EN;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_MEM_SETTING, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PPS_ACTIVE_DEFAULT_TIME;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_PPS_ACTIVE_TIME, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PTP_LCK_CTRL0_EN | AX_PTP_LCK_CTRL0_80B_NS_EN |
+		AX_PTP_LCK_CTRL0_80B_S_EN | AX_PTP_LCK_CTRL0_48B_EN |
+		AX_PTP_LCK_CTRL0_PPS_EN | AX_PTP_LCK_CTRL0_TX_DEL_VEC;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_LCK_CTRL0, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_BASE_ADDEND;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TIMER_ADDEND, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PTP_PERIOD;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TIMER_PERIOD, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MAC_BFM_CTRL, 1, 1, &reg8, 0);
+	if (ret < 0)
+		return ret;
+	reg8 |= AX_CS_TRAIL_UDPV4_EN | AX_CS_TRAIL_UDPV6_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MAC_BFM_CTRL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_100:
+		reg32 = (AX_IPG_COUNTER_100M) |
+			(AX_SOF_DELAY_COUNTER_100M << 8) |
+			(AX_VAILD_DELAY_COUNTER_100M << 16);
+		ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_TX_READY_CTRL,
+				   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT |
+			(0x10 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_1000:
+		reg32 = (AX_IPG_COUNTER_1G) |
+			(AX_SOF_DELAY_COUNTER_1G << 8) |
+			(AX_VAILD_DELAY_COUNTER_1G << 16);
+		ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_TX_READY_CTRL,
+				   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT |
+			(0x8 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_2500:
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT | AX_PTP_RXC0_XGMII_EN;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT | AX_PTP_TXC0_XGMII_EN |
+			(0x8 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	}
+
+	reg32 = 0;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_DELAY, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = 0;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_DELAY, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_EXT_INT_ON | AX_PTP_TX_TX_INT_EN;
+	ret = ax_write_cmd(axdev, AX_PTP_TOD_CTRL,
+			   (AX_PTP_TS_INT | AX_EXT_INT), 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg32 = 0;
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_MAC_CLK_CTRL,
+			   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = (0 << AX_DIVIDE_PTP_CLK_SHIFT) |
+		(1 << AX_DIVIDE_AES_CLK_SHIFT) |
+		AX_PTP_CLK_EN | AX_AES_CLK_EN |
+		AX_PTP_CLK_SELECT_DIVIDE | AX_AES_CLK_SELECT_DIVIDE |
+		AX_XGMAC_TX_CLK_EN | AX_XGMAC_RX_CLK_EN;
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_MAC_CLK_CTRL,
+			   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+void ax88279_ptp_remove(struct ax_device *axdev)
+{
+	u32 reg32 = 0;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+	ax_ptp_pbus_write(axdev, AX_PTP_LCK_CTRL0, 4, &reg32);
+	ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+	ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+}
+
+static int ax88279_submit_ts(struct ax_device *axdev);
+static void ax88279_read_ts_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	struct ax_device *axdev;
+	struct ax_ptp_cfg *ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info;
+	int i, index;
+
+	axdev = urb->context;
+	if (!axdev)
+		return;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	netdev = axdev->netdev;
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(axdev->udev);
+
+	ptp_cfg = axdev->ptp_cfg;
+
+	if (urb->status < 0) {
+		dev_err(&axdev->intf->dev,
+			"failed get ts (%d)", urb->status);
+		goto out;
+	}
+#ifdef ENABLE_PTP_DEBUG
+	printk("EP4 Valid: 0x%x", ptp_cfg->ep4_buf[AX_PTP_EP4_SIZE - 1]);
+#endif
+	index = (ptp_cfg->ep4_buf[AX_PTP_EP4_SIZE - 1] & AX_TS_SEG_1) ?
+		0 : (AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE);
+#ifdef ENABLE_PTP_DEBUG
+	printk("index: %d", index);
+#endif
+	temp_ptp_info = (struct _ax_ptp_info *)&ptp_cfg->ep4_buf[index];
+	for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+		if (temp_ptp_info[i].status) {
+			ptp_cfg->tx_ptp_info[ptp_cfg->ptp_tail++] =
+							temp_ptp_info[i];
+			if (ptp_cfg->ptp_tail == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_tail = 0;
+			ptp_cfg->num_items++;
+#ifdef ENABLE_PTP_DEBUG
+printk("### ptp_tail: %ld, ptp_head: %ld, num_items: %ld",
+	ptp_cfg->ptp_tail, ptp_cfg->ptp_head, ptp_cfg->num_items);
+printk("### (%s) - DATA %d -------------###", __func__, i);
+printk("### status: %d", temp_ptp_info[i].status);
+printk("### type: 0x%02x", temp_ptp_info[i].msg_type);
+printk("### s_id: 0x%04x", temp_ptp_info[i].sequence_id);
+printk("### nsec: 0x%08x", temp_ptp_info[i].nsec);
+printk("###  sec: 0x%04x%08x", temp_ptp_info[i].sec_h, temp_ptp_info[i].sec_l);
+printk("### ----------------------------###\n");
+#endif
+		}
+	}
+
+	ax_tx_timestamp(axdev);
+out:
+	ax88279_submit_ts(axdev);
+}
+
+static int ax88279_submit_ts(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct urb *urb = ptp_cfg->urb;
+	int ret;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return 0;
+
+	memset(ptp_cfg->ep4_buf, 0, AX_PTP_EP4_SIZE);
+
+	usb_fill_bulk_urb(urb, axdev->udev,
+			   usb_rcvbulkpipe(axdev->udev, 4),
+			   (void *)ptp_cfg->ep4_buf, AX_PTP_EP4_SIZE,
+			   (usb_complete_t)ax88279_read_ts_callback, axdev);
+
+	ret = usb_submit_urb(urb, GFP_KERNEL);
+	if (ret == -ENODEV)
+		netif_device_detach(axdev->netdev);
+
+	urb->actual_length = 0;
+
+	return ret;
+}
+
+int ax88279_start_get_ts(struct ax_device *axdev)
+{
+	int ret;
+
+	if (axdev->chip_version <= AX_VERSION_AX88179A_772D)
+		return 0;
+
+	ret = ax88279_submit_ts(axdev);
+	if (ret < 0)
+		dev_err(&axdev->intf->dev, "Failed to submit EP4 for TS\n");
+
+	return ret;
+}
+
+void ax88279_stop_get_ts(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (axdev->chip_version <= AX_VERSION_AX88179A_772D)
+		return;
+
+	if (ptp_cfg->urb)
+		usb_kill_urb(ptp_cfg->urb);
+}
+#endif
+
+int ax_ptp_register(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg;
+	int ret;
+
+	ptp_cfg = kzalloc(sizeof(struct ax_ptp_cfg), GFP_KERNEL);
+	if (!ptp_cfg)
+		return -ENOMEM;
+	axdev->ptp_cfg = ptp_cfg;
+
+	switch (axdev->chip_version) {
+#ifdef ENABLE_AX88279
+	case AX_VERSION_AX88279:
+		ptp_cfg->urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ptp_cfg->urb)
+			goto fail;
+
+		ptp_cfg->ptp_caps = ax88279_ptp_clock;
+		break;
+#endif
+	case AX_VERSION_AX88179A_772D:
+		if (axdev->sub_version < 3)
+			return 0;
+		ptp_cfg->ptp_caps = ax88179a_772d_ptp_clock;
+		break;
+	default:
+		return 0;
+	};
+
+	ptp_cfg->ptp_clock = ptp_clock_register(&ptp_cfg->ptp_caps,
+						&axdev->udev->dev);
+	if (IS_ERR(ptp_cfg->ptp_clock)) {
+		dev_err(&axdev->intf->dev, "ptp_clock_register failed\n");
+		ret = PTR_ERR(ptp_cfg->ptp_clock);
+		goto fail;
+	}
+
+	ptp_cfg->phc_index = ptp_clock_index(ptp_cfg->ptp_clock);
+	skb_queue_head_init(&axdev->tx_timestamp);
+
+	ptp_cfg->axdev = axdev;
+
+	return 0;
+fail:
+#ifdef ENABLE_AX88279
+	if (ptp_cfg->urb)
+		usb_free_urb(axdev->intr_urb);
+#endif
+	kfree(axdev->ptp_cfg);
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax_ptp.h b/drivers/net/usb/asix_usb/ax_ptp.h
new file mode 100755
index 000000000000..719344f4bfe0
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ptp.h
@@ -0,0 +1,242 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_PTP_H
+#define __ASIX_PTP_H
+
+#include <linux/ptp_clock_kernel.h>
+#include <linux/net_tstamp.h>
+
+#define AX_MAC_BFM_CTRL		0xC1
+	#define AX_CS_TRAIL_UDPV4_EN		0x40
+	#define AX_CS_TRAIL_UDPV6_EN		0x80
+
+#define EP0_GET_TIMESTAMP_RETRY	10
+
+#define AX_PTP_CMD		0x09
+#define AX_PTP_OP		0x0E
+	#define AX_SET_LOCAL_CLOCK	0x01
+	#define AX_SET_LOCAL_CLOCK_SIZE		0x0A
+	#define AX_GET_LOCAL_CLOCK	0x02
+	#define AX_GET_LOCAL_CLOCK_SIZE		0x0A
+	#define AX_SET_ADDEND		0x03
+	#define AX_SET_ADDEND_SIZE		0x04
+	#define AX_SET_ACTIVE_TIME	0x06
+	#define AX_SET_ACTIVE_TIME_SIZE	0x04
+	#define AX_SET_TX_PHY_DELAY	0x07
+	#define AX_SET_TX_PHY_DELAY_SIZE	0x05
+	#define AX_SET_RX_PHY_DELAY	0x08
+	#define AX_SET_RX_PHY_DELAY_SIZE	AX_SET_TX_PHY_DELAY_SIZE
+#define AX_PTP_TIMESTAMP	0x0A
+#define AX_PTP_CLK		0x13
+#define AX_PTP_TOD_CTRL	0x15
+	#define AX_PTP_TS_INT		0x02
+	#define AX_EXT_INT		0x04
+	#define AX_EXT_INT_ON		0x10
+	#define AX_PTP_TX_TX_INT_EN	0x40
+
+// Ethernet: 14B, IPv4: 20B, UDP: 8B
+#define AX_TX_PTPHDR_OFFSET_L3_IP	42
+// Ethernet: 14B, IPv6: 40B, UDP: 8B
+#define AX_TX_PTPHDR_OFFSET_L3_IPV6	62
+// Ethernet: 14B
+#define AX_TX_PTPHDR_OFFSET_L2	14
+#define AX_ETHTYPE_OFFSET		12
+#define AX_IP_PROTO_OFFSET		9
+#define AX_UDP_PORT_OFFSET		22
+#define AX_PTP_EVENT_PORT_NUM		0x13F
+#define PTP_HDR_SIZE			34
+
+#define AX_PPS_ACTIVE_DEFAULT_TIME	0x1DCD6500
+#define AX_BASE_ADDEND			0xCCCCCCCC
+#define AX_PTP_PERIOD			0xA
+
+#define AX88179A_PTP_CTRL_1		0x00
+	#define AX_PTP_TX_PLUS_DELAY		0x20
+	#define AX_PTP_RX_FILTER_GENERAL_MSG	0x10
+	#define AX_PTP_TX_FILTER_GENERAL_MSG	0x08
+	#define AX_PTP_CTRL_L3_EN		0x02
+	#define AX_PTP_CTRL_EN			0x01
+#define AX88179A_PTP_CTRL_2		0x01
+	#define AX_PTP_CTRL_SET_PERIOD		0x08
+	#define AX_PTP_CTRL_SET_ADDEND		0x04
+	#define AX_PTP_CTRL_GET_CLK		0x02
+	#define AX_PTP_CTRL_SET_CLK		0x01
+#define AX88179A_PTP_TIMER_PERIOD	0x0A
+#define AX88179A_PTP_MEM_SEG_SIZE	0x21
+#define AX88179A_PTP_MEM_SEG_SET	0x22
+#define AX88179A_PTP_MEM_SEG_STATUS	0x23
+	#define AX_PTP_MEM_SEG_MASK		0x01
+	#define AX_PTP_MEM_SEG_0		0
+
+#ifdef ENABLE_AX88279
+#define AX_PTP_REG_BASE_ADDR_HI		0x0012
+#define AX_PTP_TX_MEM_SETTING		0x0000
+	#define AX_PTP_PTP_CPU_EN		0x0001
+	/* TODO:: Change to Product code */
+	#define AX_PTP_MEM_SEG_SIZE_279_4	0x34	// USB 2.0
+	#define AX_PTP_MEM_SEG_SIZE_279_5	0x41
+	#define AX_PTP_MEM_START_ADDR		0x800
+#define AX_PTP_LCK_CTRL0		0x1000
+	#define AX_PTP_LCK_CTRL0_EN		0x0001
+	#define AX_PTP_LCK_CTRL0_80B_NS_EN	0x0002
+	#define AX_PTP_LCK_CTRL0_80B_S_EN	0x0004
+	#define AX_PTP_LCK_CTRL0_48B_EN		0x0008
+	#define AX_PTP_LCK_CTRL0_PPS_EN		0x0010
+	#define AX_PTP_LCK_CTRL0_TX_DEL_VEC	0x0040
+#define AX_PTP_LCK_CTRL1			0x1004
+#define AX_PTP_SET_80B_LCK_VAL0		0x1008
+#define AX_PTP_GET_80B_LCK_VAL0		0x1014
+#define AX_PTP_GET_80B_LCK_VAL1		0x1018
+#define AX_PTP_GET_80B_LCK_VAL2		0x101C
+#define AX_PTP_TIMER_ADDEND			0x1030
+#define AX_PTP_TIMER_PERIOD			0x1034
+#define AX_PTP_TX_DELAY			0x1038
+#define AX_PTP_RX_DELAY			0x103C
+#define AX_PTP_PPS_ACTIVE_TIME		0x1040
+
+#define AX_PTP_RX_CTRL0			0x2000
+	#define AX_PTP_RXC0_EN			0x0001
+	#define AX_PTP_RXC0_XGMII_EN		0x0002
+	#define AX_RXC0_PARSER_L2_EN		0x0010
+	#define AX_RXC0_PARSER_L2_PTP_EN	0x0020
+	#define AX_RXC0_PARSER_IPV4_EN	0x0040
+	#define AX_RXC0_PARSER_IPV6_EN	0x0080
+	#define AX_RXC0_PARSER_VLAN_EN	0x0100
+	#define AX_RXC0_PARSER_PPPOE_EN	0x0200
+	#define AX_RXC0_PARSER_SNAP_EN	0x0400
+	#define AX_RXC0_PARSER_UDP_EN		0x0800
+	#define AX_RXC0_PARSER_UDPV6_EN	0x1000
+	#define AX_RXC0_PARSER_UDP_PTP_EN	0x2000
+	#define AX_RXC0_PARSER_UDPV6_PTP_EN	0x4000
+	#define AX_RXC0_PARSER_EVENT_PORT_EN	0x00010000
+	#define AX_RXC0_VAL_DELAY_CNT_SHIFT	24
+
+#define AX_PTP_RX_CTRL0_DEFAULT	\
+	(AX_PTP_RXC0_EN | AX_RXC0_PARSER_L2_EN | AX_RXC0_PARSER_L2_PTP_EN | \
+	AX_RXC0_PARSER_IPV4_EN | AX_RXC0_PARSER_IPV6_EN | \
+	AX_RXC0_PARSER_VLAN_EN | AX_RXC0_PARSER_PPPOE_EN | \
+	AX_RXC0_PARSER_SNAP_EN | AX_RXC0_PARSER_UDP_EN | \
+	AX_RXC0_PARSER_UDPV6_EN | AX_RXC0_PARSER_UDP_PTP_EN | \
+	AX_RXC0_PARSER_UDPV6_PTP_EN | AX_RXC0_PARSER_EVENT_PORT_EN)
+
+#define AX_PTP_TX_CTRL0			0x3000
+	#define AX_PTP_TXC0_EN			0x0001
+	#define AX_PTP_TXC0_XGMII_EN		0x0002
+	#define AX_TXC0_PARSER_L2_EN		0x0010
+	#define AX_TXC0_PARSER_L2_PTP_EN	0x0020
+	#define AX_TXC0_PARSER_IPV4_EN	0x0040
+	#define AX_TXC0_PARSER_IPV6_EN	0x0080
+	#define AX_TXC0_PARSER_VLAN_EN	0x0100
+	#define AX_TXC0_PARSER_PPPOE_EN	0x0200
+	#define AX_TXC0_PARSER_SNAP_EN	0x0400
+	#define AX_TXC0_PARSER_UDP_EN		0x0800
+	#define AX_TXC0_PARSER_UDPV6_EN	0x1000
+	#define AX_TXC0_PARSER_UDP_PTP_EN	0x2000
+	#define AX_TXC0_PARSER_UDPV6_PTP_EN	0x4000
+	#define AX_TXC0_PARSER_EVENT_PORT_EN	0x00010000
+	#define AX_TXC0_VAL_DELAY_CNT_SHIFT	24
+
+#define AX_PTP_TX_CTRL0_DEFAULT	\
+	(AX_PTP_TXC0_EN | AX_TXC0_PARSER_L2_EN | AX_TXC0_PARSER_L2_PTP_EN | \
+	AX_TXC0_PARSER_IPV4_EN | AX_TXC0_PARSER_IPV6_EN | \
+	AX_TXC0_PARSER_VLAN_EN | AX_TXC0_PARSER_PPPOE_EN | \
+	AX_TXC0_PARSER_SNAP_EN | AX_TXC0_PARSER_UDP_EN | \
+	AX_TXC0_PARSER_UDPV6_EN | AX_TXC0_PARSER_UDP_PTP_EN | \
+	AX_TXC0_PARSER_UDPV6_PTP_EN | AX_TXC0_PARSER_EVENT_PORT_EN)
+#endif
+
+
+struct _ptp_header {
+	u16	message_type		:4,
+		transport_specific	:4,
+		reserved		:4,
+		version_ptp		:4;
+	u16	message_len;
+	u8	domain_num;
+	u8	reserved1;
+	u16	flags;
+	u64	correction_field;
+	u32	reserved2;
+	u8	source_port_id[10];
+	u16	sequence_id;
+	u8	ctrl_field;
+	u8	log_msg_interval;
+} __packed;
+
+struct _179a_ptp_info {
+	u8	reserved	:3,
+		status		:1,
+		msg_type	:4;
+	u8	sequence_id;
+	u32	nsec;
+	u32	sec_l;
+	u16	sec_h;
+} __packed;
+#define AX_179A_PTP_INFO_SEG_SIZE sizeof(struct _179a_ptp_info)
+
+struct _ax_ptp_info {
+	u8	reserved	:3,
+		status		:1,
+		msg_type	:4;
+	u16	sequence_id;
+	u32	nsec;
+	u32	sec_l;
+	u16	sec_h;
+} __packed;
+#define AX_PTP_HW_QUEUE_SIZE	5
+#define AX_PTP_QUEUE_SIZE	AX_PTP_HW_QUEUE_SIZE
+#define AX_PTP_INFO_SIZE	sizeof(struct _ax_ptp_info)
+
+struct _ax_ptp_usb_info {
+	struct _ax_ptp_info ax_ptp_info[AX_PTP_HW_QUEUE_SIZE];
+	struct usb_ctrlrequest req;
+	void *axdev;
+};
+
+struct ax_ptp_cfg {
+	void *axdev;
+	struct ptp_clock_info ptp_caps;
+	struct ptp_clock *ptp_clock;
+	unsigned int phc_index;
+	struct _ax_ptp_info tx_ptp_info[AX_PTP_QUEUE_SIZE];
+	unsigned long ptp_head, ptp_tail, num_items;
+	int get_timestamp_retry;
+#ifdef ENABLE_AX88279
+#define AX_PTP_EP4_SIZE	((2 * AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE) + 1)
+#define AX_TS_SEG_1		1
+#define AX_EP4_INFO_SIZE (AX_PTP_QUEUE_SIZE * AX_PTP_EP4_SIZE)
+	struct urb *urb;
+	unsigned char ep4_buf[AX_PTP_EP4_SIZE];
+	struct _ax_ptp_info ep4_ptp_info[AX_EP4_INFO_SIZE];
+#endif
+};
+
+int ax_ptp_register(struct ax_device *axdev);
+void ax_ptp_unregister(struct ax_device *axdev);
+int ax88179a_ptp_pps_ctrl(struct ax_device *axdev, u8 enable);
+int ax88179a_ptp_init(struct ax_device *axdev);
+void ax88179a_ptp_remove(struct ax_device *axdev);
+#ifdef ENABLE_AX88279
+int ax88279_ptp_pps_ctrl(struct ax_device *axdev, u8 enable);
+int ax88279_ptp_init(struct ax_device *axdev);
+void ax88279_ptp_remove(struct ax_device *axdev);
+int ax88279_start_get_ts(struct ax_device *axdev);
+void ax88279_stop_get_ts(struct ax_device *axdev);
+#endif
+int ax_ptp_ts_read_cmd_async(struct ax_device *axdev);
+void ax_rx_get_timestamp(struct sk_buff *skb, u64 *pkt_hdr);
+#endif /* End of __ASIX_PTP_H */
diff --git a/drivers/net/usb/asix_usb/axcmd.c b/drivers/net/usb/asix_usb/axcmd.c
new file mode 100755
index 000000000000..c40c1901efcd
--- /dev/null
+++ b/drivers/net/usb/asix_usb/axcmd.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define ASIX_IOCTL_VERSION "ASIX Linux Command Tool v1.0.0"
+
+const char help_str1[] =
+"./ioctl help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char usbcommand_str1[] =
+"./axcmd usb [ops] [cmd] [value] [index] [size] [data]\n"
+"    -- ASIX USB Command\n";
+const char usbcommand_str2[] =
+"        [ops]     - 0: Read,  1: Write\n"
+"        [cmd]     - USB Command (0 - 0xFF)\n"
+"        [value]   - USB wvalue (0 - 0xFFFF)\n"
+"        [index]   - USB windex (0 - 0xFFFF)\n"
+"        [size]    - USB wlength (0 - 0xFFFF)\n"
+"        [data]    - Data (0 - 0xFFFFFFFF)\n";
+
+static int help_func(struct ax_command_info *info);
+static int usbcommand_func(struct ax_command_info *info);
+
+struct _command_list asix_cmd_list[] = {
+	{	"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{	"usb",
+		AX_USB_COMMAND,
+		usbcommand_func,
+		usbcommand_str1,
+		usbcommand_str2
+	},
+	{NULL},
+};
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", asix_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp,
+				unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			printf("%s%s\n",
+				asix_cmd_list[i].help_ins,
+				asix_cmd_list[i].help_desc);
+		}
+	}
+
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[1],
+			    asix_cmd_list[i].cmd,
+			    strlen(asix_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n",
+				asix_cmd_list[i].help_ins,
+				asix_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+}
+
+static int usbcommand_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	struct _ax_usb_command *usb_cmd;
+	int i;
+
+	if (info->argc > 8 || info->argc < 7) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], asix_cmd_list[i].cmd,
+				    strlen(asix_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", asix_cmd_list[i].help_ins,
+						 asix_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	usb_cmd = &ioctl_cmd.usb_cmd;
+	memset(usb_cmd, 0, sizeof(*usb_cmd));
+
+	usb_cmd->ops = STR_TO_U32(info->argv[2], NULL, 16);
+	usb_cmd->cmd = STR_TO_U32(info->argv[3], NULL, 16);
+	usb_cmd->value = STR_TO_U32(info->argv[4], NULL, 16);
+	usb_cmd->index = STR_TO_U32(info->argv[5], NULL, 16);
+	usb_cmd->size = STR_TO_U32(info->argv[6], NULL, 16);
+
+	if (usb_cmd->ops > USB_WRITE_OPS) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], asix_cmd_list[i].cmd,
+				    strlen(asix_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", asix_cmd_list[i].help_ins,
+						 asix_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (usb_cmd->ops == USB_WRITE_OPS)
+		usb_cmd->cmd_data = STR_TO_U32(info->argv[7], NULL, 16);
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = usb_cmd->size;
+	ioctl_cmd.buf = NULL;
+	ioctl_cmd.type = 0;
+	ioctl_cmd.delay = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		return -FAIL_IOCTL;
+	}
+
+	if (usb_cmd->ops == USB_READ_OPS) {
+		printf("Read Command: CMD: 0x%02X\n", usb_cmd->cmd);
+		printf("wValue: 0x%04X, wIndex: 0x%04X, wLength: 0x%04X",
+			usb_cmd->value, usb_cmd->index, usb_cmd->size);
+		printf("\nData: 0x%08lX\n", usb_cmd->cmd_data);
+	}
+
+	printf("Command completely\n");
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	int inet_sock;
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned char i;
+	unsigned char count = 0;
+	struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+	struct ifaddrs *addrs, *tmp;
+	unsigned char	dev_exist;
+#endif
+
+	if (argc < 2) {
+		show_usage();
+		return 0;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#if NET_INTERFACE == INTERFACE_SCAN
+	getifaddrs(&addrs);
+	tmp = addrs;
+	dev_exist = 0;
+
+	while (tmp) {
+		memset(&ioctl_cmd, 0, sizeof(ioctl_cmd));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+		sprintf(ifr.ifr_name, "%s", tmp->ifa_name);
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+		tmp = tmp->ifa_next;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+
+		if (strncmp(ioctl_cmd.sig, AX88179A_DRV_NAME,
+			    strlen(AX88179A_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+	}
+
+	freeifaddrs(addrs);
+
+	if (dev_exist == 0) {
+		printf("No ASIX device found\n");
+		return 0;
+	}
+#else
+	for (i = 0; i < 255; i++) {
+
+		memset(&ioctl_cmd, 0, sizeof(ioctl_cmd));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "eth%d", i);
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0)
+			break;
+
+		if (strncmp(ioctl_cmd.sig, AX88179A_DRV_NAME,
+			    strlen(AX88179A_DRV_NAME)) == 0)
+			break;
+	}
+
+	if (i == 255) {
+		printf("No ASIX device found\n");
+		return 0;
+	}
+#endif
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1], asix_cmd_list[i].cmd,
+			    strlen(asix_cmd_list[i].cmd)) == 0) {
+			info.help_ins = asix_cmd_list[i].help_ins;
+			info.help_desc = asix_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = asix_cmd_list[i].ioctl_cmd;
+			(asix_cmd_list[i].OptFunc)(&info);
+			return 0;
+		}
+	}
+
+	printf("Wrong command\n");
+
+	return 0;
+}
-- 
2.47.0

