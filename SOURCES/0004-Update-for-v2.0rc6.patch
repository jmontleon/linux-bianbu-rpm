From ba3d65b81e22fe990f05655fb277811c9848af35 Mon Sep 17 00:00:00 2001
From: James Deng <james.deng@spacemit.com>
Date: Tue, 10 Sep 2024 17:47:09 +0800
Subject: [PATCH 04/21] Update for v2.0rc6

---
 .../dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts  |  16 +
 .../boot/dts/spacemit/k1-x_MUSE-Paper.dts     |  23 +-
 .../dts/spacemit/k1-x_thermal_cooling.dtsi    |  48 +-
 arch/riscv/configs/k1_defconfig               |   4 +
 drivers/gpu/drm/img-rogue/rgxdebug_common.c   |  22 +-
 drivers/gpu/drm/spacemit/lt8911exb.c          |  36 +-
 drivers/iio/light/stk3310.c                   |  11 +
 drivers/pci/controller/dwc/pcie-k1x.c         |   2 +-
 drivers/usb/gadget/udc/k1x_udc_core.c         |  71 +-
 drivers/usb/misc/Kconfig                      |   4 +-
 drivers/usb/typec/husb239.c                   | 336 ++++++----
 sound/soc/spacemit/Kconfig                    |  24 +
 sound/soc/spacemit/spacemit-snd-pcm-dma.c     | 615 +++++++++++++++++-
 13 files changed, 1014 insertions(+), 198 deletions(-)

diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
index cd256bdf1912..68fb018652c4 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper-mini-4g.dts
@@ -365,6 +365,22 @@ con_u2_ep: endpoint {
 			};
 		};
 	};
+
+	cw2015: cw2015@62 {
+		compatible = "cellwise,cw2015";
+		reg = <0x62>;
+		cellwise,battery-profile = /bits/ 8 <
+			0x17 0x67 0x74 0x68 0x67 0x66 0x64 0x5B
+			0x63 0x70 0x42 0x58 0x59 0x50 0x44 0x3A
+			0x32 0x2A 0x23 0x1C 0x24 0x36 0x46 0x4B
+			0x14 0x87 0x06 0x66 0x17 0x2F 0x4A 0x56
+			0x67 0x68 0x66 0x6B 0x3F 0x1C 0x77 0x56
+			0x0B 0x24 0x25 0x56 0x81 0x95 0x9C 0x10
+			0x2B 0x78 0x9B 0xAB 0x80 0x57 0x7F 0xCB
+			0x2F 0x00 0x64 0xA5 0xB5 0xC1 0x46 0xAE
+		>;
+		status = "okay";
+	};
 };
 
 &i2c5 {
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
index f344687ddad7..8c8fd9fec450 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
+++ b/arch/riscv/boot/dts/spacemit/k1-x_MUSE-Paper.dts
@@ -375,6 +375,7 @@ husb239_u3: tcpc@42 {
 		chg-gpio = <&gpio 04 0>;
 		int-gpio = <&gpio 01 0>;
 		aud-gpio = <&gpio 86 0>;
+		mic-gpio = <&gpio 79 0>;
 		orient-oe-gpio  = <&gpio 48 0>;
 		orient-sel-gpio = <&gpio 78 0>;
 		orientation;
@@ -399,10 +400,26 @@ &i2c5 {
         pinctrl-0 = <&pinctrl_i2c5_0>;
         status = "okay";
 
+	accelerometer: accel@15 {
+		compatible = "memsic,mxc4005";
+		reg = <0x15>;
+		status = "okay";
+	};
+
         icm42607@68 {
                 compatible = "invn,icm42607";
                 reg = <0x68>;
         };
+
+	light: light-sensor@48 {
+		compatible = "sensortek,stk3311";
+		reg = <0x48>;
+		proximity-near-level = <25>;
+		interrupt-parent = <&gpio>;
+		interrupts = <72 2>; /* PB0 */
+		pwr-gpios = <&gpio 73 0>;
+		status = "okay";
+	};
 };
 
 &i2c6 {
@@ -648,8 +665,7 @@ &range PRI_TCK  1 (MUX_MODE1 | EDGE_NONE | PULL_DOWN | PAD_1V8_DS2)
 		&range PRI_TDO  1 (MUX_MODE1 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_74  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_76  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
-		&range GPIO_78  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
-		&range GPIO_80  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
+		&range GPIO_78  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_3V_DS4)
 		&range GPIO_81  3 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_86  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
 		&range GPIO_89  1 (MUX_MODE0 | EDGE_NONE | PULL_UP   | PAD_1V8_DS2)
@@ -689,8 +705,7 @@ &pinctrl 63  GPIO_63  5
 		&pinctrl 70  PRI_TDI  4
 		&pinctrl 74  GPIO_74  1
 		&pinctrl 76  GPIO_76  1
-		&pinctrl 78  GPIO_78  1
-		&pinctrl 80  GPIO_80  4
+		&pinctrl 78  GPIO_78  6
 		&pinctrl 86  GPIO_86  1
 		&pinctrl 89  GPIO_89  4
 		&pinctrl 96  DVL0     2
diff --git a/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi b/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
index e2d73dd2f6c3..b11d653af813 100644
--- a/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
+++ b/arch/riscv/boot/dts/spacemit/k1-x_thermal_cooling.dtsi
@@ -9,24 +9,30 @@ cluster0_thermal {
 
 		thermal0_trips: trips {
 			cls0_trip0: cls0-trip-point0 {
-				temperature = <90000>;
-				hysteresis = <4000>;
+				temperature = <75000>;
+				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls0_trip1: cls0-trip-point1 {
-				temperature = <95000>;
+				temperature = <85000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls0_trip2: cls0-trip-point2 {
-				temperature = <105000>;
+				temperature = <95000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls0_trip3: cls0-trip-point3 {
+				temperature = <105000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+
+			cls0_trip4: cls0-trip-point4 {
 				temperature = <115000>;
 				hysteresis = <5000>;
 				type = "critical";
@@ -36,6 +42,18 @@ cls0_trip3: cls0-trip-point3 {
 		cooling-maps {
 			map0 {
 				trip = <&cls0_trip0>;
+				cooling-device = <&cpu_0 0 0>,
+						 <&cpu_1 0 0>,
+						 <&cpu_2 0 0>,
+						 <&cpu_3 0 0>,
+						 <&cpu_4 0 0>,
+						 <&cpu_5 0 0>,
+						 <&cpu_6 0 0>,
+						 <&cpu_7 0 0>;
+			};
+
+			map1 {
+				trip = <&cls0_trip1>;
 				cooling-device = <&cpu_0 1 1>,
 						 <&cpu_1 1 1>,
 						 <&cpu_2 1 1>,
@@ -46,8 +64,8 @@ map0 {
 						 <&cpu_7 1 1>;
 			};
 
-			map1 {
-				trip = <&cls0_trip1>;
+			map2 {
+				trip = <&cls0_trip2>;
 				cooling-device = <&cpu_0 2 3>,
 						 <&cpu_1 2 3>,
 						 <&cpu_2 2 3>,
@@ -58,8 +76,8 @@ map1 {
 						 <&cpu_7 2 3>;
 			};
 
-			map2 {
-				trip = <&cls0_trip2>;
+			map3 {
+				trip = <&cls0_trip3>;
 				cooling-device = <&cpu_0 4 5>,
 						 <&cpu_1 4 5>,
 						 <&cpu_2 4 5>,
@@ -79,24 +97,30 @@ cluster1_thermal {
 
 		thermal1_trips: trips {
 			cls1_trip0: cls1-trip-point0 {
-				temperature = <90000>;
-				hysteresis = <4000>;
+				temperature = <75000>;
+				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls1_trip1: cls1-trip-point1 {
-				temperature = <95000>;
+				temperature = <85000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls1_trip2: cls1-trip-point2 {
-				temperature = <105000>;
+				temperature = <95000>;
 				hysteresis = <5000>;
 				type = "passive";
 			};
 
 			cls1_trip3: cls1-trip-point3 {
+				temperature = <105000>;
+				hysteresis = <5000>;
+				type = "passive";
+			};
+
+			cls1_trip4: cls1-trip-point4 {
 				temperature = <115000>;
 				hysteresis = <5000>;
 				type = "critical";
diff --git a/arch/riscv/configs/k1_defconfig b/arch/riscv/configs/k1_defconfig
index 886618a5d211..463c5ef2fe65 100644
--- a/arch/riscv/configs/k1_defconfig
+++ b/arch/riscv/configs/k1_defconfig
@@ -1034,6 +1034,9 @@ CONFIG_SPACEMIT_V2D=y
 CONFIG_SPACEMIT_RFKILL=y
 CONFIG_EXTCON_USB_K1XCI=y
 CONFIG_EXTCON_USB_GPIO=y
+CONFIG_IIO=y
+CONFIG_MXC4005=y
+CONFIG_STK3310=y
 CONFIG_PWM=y
 CONFIG_PWM_PXA=y
 CONFIG_RESET_CONTROLLER=y
@@ -1298,6 +1301,7 @@ CONFIG_SCHED_STACK_END_CHECK=y
 CONFIG_KFENCE=y
 CONFIG_DETECT_HUNG_TASK=y
 CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_ATOMIC_SLEEP=y
 # CONFIG_RCU_TRACE is not set
 # CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/drivers/gpu/drm/img-rogue/rgxdebug_common.c b/drivers/gpu/drm/img-rogue/rgxdebug_common.c
index 8684309e9f7f..4b1393558a51 100644
--- a/drivers/gpu/drm/img-rogue/rgxdebug_common.c
+++ b/drivers/gpu/drm/img-rogue/rgxdebug_common.c
@@ -1459,8 +1459,7 @@ typedef struct _FAULT_INFO_LOG_
 static FAULT_INFO_LOG gsFaultInfoLog = { 0 };
 
 static void _FillAppForFWFaults(PVRSRV_RGXDEV_INFO *psDevInfo,
-							FAULT_INFO *psInfo,
-							RGXMEM_PROCESS_INFO *psProcInfo)
+							FAULT_INFO *psInfo)
 {
 	IMG_UINT32 i, j;
 
@@ -1471,14 +1470,17 @@ static void _FillAppForFWFaults(PVRSRV_RGXDEV_INFO *psDevInfo,
 			IMG_BOOL bFound;
 
 			RGXMEM_PROCESS_INFO *psProcInfo = &psInfo->asQueryOut[i].sResults[j].sProcessInfo;
-			bFound = RGXPCPIDToProcessInfo(psDevInfo,
-								psProcInfo->uiPID,
-								psProcInfo);
-			if (!bFound)
+			if (!psProcInfo)
 			{
-				OSStringLCopy(psProcInfo->szProcessName,
-								"(unknown)",
-								sizeof(psProcInfo->szProcessName));
+				bFound = RGXPCPIDToProcessInfo(psDevInfo,
+									psProcInfo->uiPID,
+									psProcInfo);
+				if (!bFound)
+				{
+					OSStringLCopy(psProcInfo->szProcessName,
+									"(unknown)",
+									sizeof(psProcInfo->szProcessName));
+				}
 			}
 		}
 	}
@@ -1641,7 +1643,7 @@ static void _RecordFaultInfo(PVRSRV_RGXDEV_INFO *psDevInfo,
 
 					if (sProcessInfo.uiPID == RGXMEM_SERVER_PID_FIRMWARE)
 					{
-						_FillAppForFWFaults(psDevInfo, psInfo, &sProcessInfo);
+						_FillAppForFWFaults(psDevInfo, psInfo);
 					}
 				}
 			}
diff --git a/drivers/gpu/drm/spacemit/lt8911exb.c b/drivers/gpu/drm/spacemit/lt8911exb.c
index 6065698ece85..84ab49676381 100644
--- a/drivers/gpu/drm/spacemit/lt8911exb.c
+++ b/drivers/gpu/drm/spacemit/lt8911exb.c
@@ -380,7 +380,7 @@ void lt8911exb_read_edid(struct lt8911exb *lt8911exb)
 	regmap_write(lt8911exb->regmap, 0x2b, 0x00 ); //data lenth
 	regmap_write(lt8911exb->regmap, 0x2c, 0x00 ); //start Aux read edid
 
-	mdelay(20);                         //more than 10ms
+	mdelay(15);                         //more than 10ms
 	regmap_read(lt8911exb->regmap, 0x25, &reg);
 	DRM_INFO("lt8911exb_read_edid 0x25 0x%x\n", reg);
 
@@ -673,7 +673,7 @@ void lt8911exb_setup(struct lt8911exb *lt8911exb)
 	regmap_write(lt8911exb->regmap, 0xff, 0x87);
 
 	for (i = 0; i < 5; i++) {//Check Tx PLL
-		mdelay(5);
+		mdelay(2);
 		regmap_read(lt8911exb->regmap, 0x37, &chip_read);
 		if (chip_read & 0x02) {
 			DRM_DEBUG("\r\n LT8911 tx pll locked");
@@ -766,7 +766,7 @@ void lt8911exb_video_check(struct lt8911exb *lt8911exb)
 	regmap_write(lt8911exb->regmap, 0x09, 0x7d);
 	regmap_write(lt8911exb->regmap, 0x09, 0xfd);
 	regmap_write(lt8911exb->regmap, 0xff, 0x85);
-	mdelay(200);
+	mdelay(30);
 
 	regmap_read(lt8911exb->regmap, 0x50, &temp2);
 	if (temp2 == 0x03) {
@@ -896,7 +896,7 @@ unsigned int DpcdRead( struct lt8911exb *lt8911exb, u32 Address )
 	regmap_write(lt8911exb->regmap, 0x2b, 0x00);	//data lenth
 	regmap_write(lt8911exb->regmap, 0x2c, 0x00);	//start Aux read edid
 
-	mdelay(50);	//more than 10ms
+	mdelay(20);	//more than 10ms
 	regmap_read(lt8911exb->regmap, 0x25, &reg);
 	if ((reg & 0x0f) == 0x0c) {
 		regmap_read(lt8911exb->regmap, 0x39, &temp);
@@ -942,7 +942,7 @@ void lt8911exb_link_train(struct lt8911exb *lt8911exb)
 		mdelay(10);
 		DpcdWrite(lt8911exb, 0x010a, 0x01);
 
-		mdelay(200);
+		mdelay(20);
 		//*/
 	} else {
 		regmap_write(lt8911exb->regmap, 0xa1, 0x02); // DP scramble mode;
@@ -976,9 +976,9 @@ void lt8911exb_link_train(struct lt8911exb *lt8911exb)
 	regmap_write(lt8911exb->regmap, 0x01, 0x0a);
 	regmap_write(lt8911exb->regmap, 0x14, 0x80);
 	regmap_write(lt8911exb->regmap, 0x14, 0x81);
-	mdelay(50);
+	mdelay(10);
 	regmap_write(lt8911exb->regmap, 0x14, 0x84);
-	mdelay(50);
+	mdelay(10);
 	regmap_write(lt8911exb->regmap, 0x14, 0xc0);
 #endif
 }
@@ -991,11 +991,11 @@ void lt8911exb_reset(struct lt8911exb *lt8911exb)
 	}
 
 	gpiod_direction_output(lt8911exb->reset_gpio, 1);
-	usleep_range(50*1000, 100*1000); //100ms
+	usleep_range(5*1000, 10*1000); //10ms
 	gpiod_direction_output(lt8911exb->reset_gpio, 0);
-	usleep_range(50*1000, 100*1000); //100ms
+	usleep_range(5*1000, 10*1000); //10ms
 	gpiod_direction_output(lt8911exb->reset_gpio, 1);
-	usleep_range(100*1000, 150*1000); //150ms
+	usleep_range(5*1000, 10*1000); //10ms
 }
 
 void LT8911EX_TxSwingPreSet(struct lt8911exb *lt8911exb)
@@ -1039,9 +1039,9 @@ void LT8911EXB_LinkTrainResultCheck( struct lt8911exb *lt8911exb)
 				regmap_write(lt8911exb->regmap, 0x01, 0x0a);
 				regmap_write(lt8911exb->regmap, 0x14, 0x80);
 				regmap_write(lt8911exb->regmap, 0x14, 0x81);
-				mdelay(50);
+				mdelay(10);
 				regmap_write(lt8911exb->regmap, 0x14, 0x84);
-				mdelay(50);
+				mdelay(10);
 				regmap_write(lt8911exb->regmap, 0x14, 0xc0);
 			}
 
@@ -1054,10 +1054,10 @@ void LT8911EXB_LinkTrainResultCheck( struct lt8911exb *lt8911exb)
 			//DRM_DEBUG_ATOMIC("\r\nLT8911_LinkTrainResultCheck: panel link count: 0x%bx",val);
 			DRM_INFO( "\r\npanel link count:0x%x ", val);
 #endif
-			mdelay(100); // return;
+			mdelay(10); // return;
 		} else {
 			//DRM_DEBUG_ATOMIC("\r\nLT8911_LinkTrainResultCheck: link trian on going...");
-			mdelay(100);
+			mdelay(10);
 		}
 	}
 #endif
@@ -1088,7 +1088,7 @@ void LT8911EX_link_train_result(struct lt8911exb *lt8911exb)
 		} else {
 			DRM_DEBUG("\r\nlink trian on going...");
 		}
-		mdelay(100);
+		mdelay(10);
 	}
 }
 
@@ -1154,7 +1154,7 @@ static int lt8911exb_panel_enable(struct drm_panel *panel)
 	DRM_INFO("%s()\n", __func__);
 
 	schedule_delayed_work(&lt8911exb->init_work,
-				msecs_to_jiffies(500));
+				msecs_to_jiffies(100));
 	lt8911exb->init_work_pending = true;
 
 	return 0;
@@ -1244,7 +1244,7 @@ static void init_work_func(struct work_struct *work)
 	DRM_DEBUG(" %s() \n", __func__);
 
 	gpiod_direction_output(lt8911exb->standby_gpio, 1);
-	usleep_range(50*1000, 100*1000); //100ms
+	// usleep_range(5*1000,10*1000); //10ms
 
 	lt8911exb_reset(lt8911exb);
 	lt8911exb_chip_id(lt8911exb);
@@ -1262,7 +1262,7 @@ static void init_work_func(struct work_struct *work)
 	lt8911exb_video_check(lt8911exb); //just for Check MIPI Input
 
 	DRM_DEBUG("\r\nDpcdRead(0x0202) = 0x%x\r\n",DpcdRead(lt8911exb, 0x0202));
-
+	mdelay(50);
 	PCR_Status(lt8911exb);
 
 	if (!IS_ERR_OR_NULL(lt8911exb->enable_gpio)) {
diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 72b08d870d33..b44c9081fc5a 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -16,6 +16,7 @@
 #include <linux/iio/events.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
+#include <linux/gpio.h>
 
 #define STK3310_REG_STATE			0x00
 #define STK3310_REG_PSCTRL			0x01
@@ -591,6 +592,9 @@ static int stk3310_probe(struct i2c_client *client)
 	int ret;
 	struct iio_dev *indio_dev;
 	struct stk3310_data *data;
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	struct gpio_desc *pwr;
+#endif
 
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
 	if (!indio_dev) {
@@ -605,6 +609,13 @@ static int stk3310_probe(struct i2c_client *client)
 	device_property_read_u32(&client->dev, "proximity-near-level",
 				 &data->ps_near_level);
 
+#ifdef CONFIG_SOC_SPACEMIT_K1X
+	pwr = devm_gpiod_get(&client->dev, "pwr", GPIOD_OUT_LOW);
+	if(IS_ERR(pwr))
+		return PTR_ERR(pwr);
+	gpiod_set_value(pwr, 1);
+#endif
+
 	mutex_init(&data->lock);
 
 	ret = stk3310_regmap_init(data);
diff --git a/drivers/pci/controller/dwc/pcie-k1x.c b/drivers/pci/controller/dwc/pcie-k1x.c
index cd807578749a..fe1281ad2629 100644
--- a/drivers/pci/controller/dwc/pcie-k1x.c
+++ b/drivers/pci/controller/dwc/pcie-k1x.c
@@ -741,7 +741,7 @@ irqreturn_t k1x_handle_msi_irq(struct dw_pcie_rp *pp)
 
 	val = k1x_pcie_phy_ahb_readl(k1x, ADDR_MSI_RECV_CTRL);
 	if(val & MSIX_AFIFO_FULL)
-		pr_err("AXI monitor FIFO FULL.\n");
+		dev_warn_once(pci->dev, "AXI monitor FIFO FULL.\n");
 
 	for (i = 0; i < FIFO_LEN; i++) {
 
diff --git a/drivers/usb/gadget/udc/k1x_udc_core.c b/drivers/usb/gadget/udc/k1x_udc_core.c
index dae5be9edbc3..157a0d90dac2 100644
--- a/drivers/usb/gadget/udc/k1x_udc_core.c
+++ b/drivers/usb/gadget/udc/k1x_udc_core.c
@@ -190,7 +190,7 @@ static int process_ep_req(struct mv_udc *udc, int index,
 					break;
 			}
 		} else {
-			dev_info(&udc->dev->dev,
+			dev_err(&udc->dev->dev,
 				"complete_tr error: ep=%d %s: error = 0x%x\n",
 				index >> 1, direction ? "SEND" : "RECV",
 				errors);
@@ -407,18 +407,43 @@ static struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,
 	struct mv_dtd *dtd;
 	struct mv_udc *udc;
 	struct mv_dqh *dqh;
-	u32 temp, mult = 0;
+	u32 temp, mult = 0, max = 0;
 
 	/* how big will this transfer be? */
 	if (usb_endpoint_xfer_isoc(req->ep->ep.desc)) {
 		dqh = req->ep->dqh;
+		max = req->ep->ep.maxpacket;
 		mult = (dqh->max_packet_length >> EP_QUEUE_HEAD_MULT_POS)
 				& 0x3;
 		*length = min(req->req.length - req->req.actual,
-				(unsigned)(mult * req->ep->ep.maxpacket));
-	} else
+				(unsigned)(mult * max));
+		/*
+		* USB Specification 2.0 Section 5.9.2 states that: "If
+		* there is only a single transaction in the microframe,
+		* only a DATA0 data packet PID is used.  If there are
+		* two transactions per microframe, DATA1 is used for
+		* the first transaction data packet and DATA0 is used
+		* for the second transaction data packet.  If there are
+		* three transactions per microframe, DATA2 is used for
+		* the first transaction data packet, DATA1 is used for
+		* the second, and DATA0 is used for the third."
+		*
+		* IOW, we should satisfy the following cases:
+		*
+		* 1) length <= maxpacket
+		*	- DATA0
+		*
+		* 2) maxpacket < length <= (2 * maxpacket)
+		*	- DATA1, DATA0
+		*
+		* 3) (2 * maxpacket) < length <= (3 * maxpacket)
+		*	- DATA2, DATA1, DATA0
+		*/
+		mult = DIV_ROUND_UP(*length, max);
+	} else {
 		*length = min(req->req.length - req->req.actual,
 				(unsigned)EP_MAX_LENGTH_TRANSFER);
+	}
 
 	udc = req->ep->udc;
 
@@ -564,8 +589,7 @@ static int mv_ep_enable(struct usb_ep *_ep,
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
 		/* Calculate transactions needed for high bandwidth iso */
-		mult = (unsigned char)(1 + ((max >> 11) & 0x03));
-		max = max & 0x7ff;	/* bit 0~10 */
+		mult = usb_endpoint_maxp_mult(desc);
 		/* 3 transactions at most */
 		if (mult > 3)
 			goto en_done;
@@ -626,6 +650,8 @@ static int mv_ep_enable(struct usb_ep *_ep,
 	return -EINVAL;
 }
 
+static void mv_ep_fifo_flush(struct usb_ep *_ep);
+
 static int  mv_ep_disable(struct usb_ep *_ep)
 {
 	struct mv_udc *udc;
@@ -675,6 +701,11 @@ static int  mv_ep_disable(struct usb_ep *_ep)
 	/* nuke all pending requests (does flush) */
 	nuke(ep, -ESHUTDOWN);
 
+	/* prevent done in nuke initiate prime again,
+	 * which will cause next ep_enable fail.
+	 */
+	mv_ep_fifo_flush(_ep);
+
 	ep->ep.desc = NULL;
 	ep->stopped = 1;
 
@@ -839,10 +870,6 @@ mv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 		goto err_unmap_dma;
 	}
 
-	/* Update ep0 state */
-	if (ep->ep_num == 0)
-		udc->ep0_state = DATA_STATE_XMIT;
-
 	/* irq handler advances the queue */
 	list_add_tail(&req->queue, &ep->queue);
 	spin_unlock_irqrestore(&udc->lock, flags);
@@ -1086,7 +1113,7 @@ static void udc_stop(struct mv_udc *udc)
 {
 	u32 tmp;
 
-	pr_info("udc_stop ...\n");
+	pr_debug("udc_stop ...\n");
 	/* Disable interrupts */
 	tmp = readl(&udc->op_regs->usbintr);
 	tmp &= ~(USBINTR_INT_EN | USBINTR_ERR_INT_EN |
@@ -1106,7 +1133,7 @@ static void udc_start(struct mv_udc *udc)
 {
 	u32 usbintr;
 
-	pr_info("udc_start ...\n");
+	pr_debug("udc_start ...\n");
 	usbintr = USBINTR_INT_EN | USBINTR_ERR_INT_EN | USBINTR_SYS_ERR
 		| USBINTR_PORT_CHANGE_DETECT_EN
 		| USBINTR_RESET_EN | USBINTR_DEVICE_SUSPEND;
@@ -1125,7 +1152,7 @@ static int udc_reset(struct mv_udc *udc)
 	unsigned int loops;
 	u32 tmp;
 
-	pr_info("udc_reset ...\n");
+	pr_debug("udc_reset ...\n");
 
 	/* Stop the controller */
 	tmp = readl(&udc->op_regs->usbcmd);
@@ -1479,7 +1506,7 @@ static int mv_udc_start(struct usb_gadget *gadget,
 	int retval = 0;
 	unsigned long flags;
 
-	pr_info("mv_udc_start ... \n");
+	pr_debug("mv_udc_start ... \n");
 	udc = container_of(gadget, struct mv_udc, gadget);
 
 	if (udc->driver)
@@ -1520,7 +1547,7 @@ static int mv_udc_stop(struct usb_gadget *gadget)
 	struct mv_udc *udc;
 	unsigned long flags;
 
-	pr_info("mv_udc_stop ... \n");
+	pr_debug("mv_udc_stop ... \n");
 	udc = container_of(gadget, struct mv_udc, gadget);
 
 	spin_lock_irqsave(&udc->lock, flags);
@@ -2190,27 +2217,27 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 	}
 
 	if (status & USBSTS_ERR) {
-		pr_info("usb ctrl error ... \n");
+		pr_err("usb ctrl error ... \n");
 		irq_process_error(udc);
 	}
 
 	if (status & USBSTS_RESET) {
-		pr_info("usb reset ... \n");
+		pr_debug("usb reset ... \n");
 		irq_process_reset(udc);
 	}
 
 	if (status & USBSTS_PORT_CHANGE) {
-		pr_info("usb port change ... \n");
+		pr_debug("usb port change ... \n");
 		irq_process_port_change(udc);
 	}
 
 	if (status & USBSTS_SUSPEND) {
-		pr_info("usb suspend ... \n");
+		pr_debug("usb suspend ... \n");
 		irq_process_suspend(udc);
 	}
 
 	if (status & USBSTS_SYS_ERR)
-		pr_info("system error ... \n");
+		pr_err("system error ... \n");
 
 	spin_unlock(&udc->lock);
 
@@ -2222,7 +2249,7 @@ static int mv_udc_vbus_notifier_call(struct notifier_block *nb,
 {
 	struct mv_udc *udc = container_of(nb, struct mv_udc, notifier);
 
-	pr_info("mv_udc_vbus_notifier_call : udc->vbus_work\n");
+	pr_debug("mv_udc_vbus_notifier_call : udc->vbus_work\n");
 	/* polling VBUS and init phy may cause too much time*/
 	if (udc->qwork)
 		queue_work(udc->qwork, &udc->vbus_work);
@@ -2425,7 +2452,7 @@ static int mv_udc_probe(struct platform_device *pdev)
 		goto err_disable_internal;
 	}
 	udc->ep_dqh_size = size;
-	pr_err("mv_udc: dqh size = 0x%zx  udc->ep_dqh_dma = 0x%llx\n", size, udc->ep_dqh_dma);
+	pr_info("mv_udc: dqh size = 0x%zx  udc->ep_dqh_dma = 0x%llx\n", size, udc->ep_dqh_dma);
 
 	/* create dTD dma_pool resource */
 	udc->dtd_pool = dma_pool_create("mv_dtd",
diff --git a/drivers/usb/misc/Kconfig b/drivers/usb/misc/Kconfig
index 40a93ea313cf..0c19e8ae2ba4 100644
--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -321,8 +321,8 @@ config USB_ONBOARD_HUB
 
 config SPACEMIT_ONBOARD_USB_HUB
 	tristate "Spacemit onboard USB hub support"
-	depends on ARCH_SPACEMIT || COMPILE_TEST
-	default SOC_SPACEMIT_K1X && USB_DWC3_SPACEMIT
+	depends on OF || COMPILE_TEST
+	default SOC_SPACEMIT_K1X
 	help
 	  Say Y here if you want to support onboard usb hubs on Spacemit
 	  platform. If unsure, say Y when compile for Spacemit platform.
diff --git a/drivers/usb/typec/husb239.c b/drivers/usb/typec/husb239.c
index 4c0b565c40d8..1f78b3082570 100644
--- a/drivers/usb/typec/husb239.c
+++ b/drivers/usb/typec/husb239.c
@@ -41,6 +41,9 @@
 #define HUSB239_REG_STATUS			0x63
 #define HUSB239_REG_STATUS1			0x64
 #define HUSB239_REG_TYPE			0x65
+#define HUSB239_REG_DPDM_STATUS		0x66
+#define HUSB239_REG_CONTRACT_STATUS0	0x67
+#define HUSB239_REG_CONTRACT_STATUS1	0x68
 
 #define HUSB239_REG_SRC_PDO_5V		0x6A
 #define HUSB239_REG_SRC_PDO_9V		0x6B
@@ -140,19 +143,25 @@
 #define HUSB239_REG_TYPE_AUDIOVBUS				BIT(1)
 #define HUSB239_REG_TYPE_AUDIO					BIT(0)
 
+#define HUSB239_PD_CONTRACT_MASK				GENMASK(7, 4)
+#define HUSB239_PD_CONTRACT_SHIFT				4
+
 #define HUSB239_REG_SRC_DETECT					(0x1 << 7)
 
 #define HUSB239_DATA_ROLE(s)					(!!((s) & BIT(0)))
 #define HUSB239_PD_COMM(s)						(!!((s) & BIT(4)))
 #define HUSB239_POWER_ROLE(s)					(!!((s) & BIT(6)))
 
-struct typec_info {
-	int request_current; /* ma */
-	int request_voltage; /* mv */
-
-	int data_role;
-	int power_role;
+enum husb239_snkcap {
+	SNKCAP_5V = 1,
+	SNKCAP_9V,
+	SNKCAP_12V,
+	SNKCAP_15V,
+	SNKCAP_20V,
+	MAX_SNKCAP
+};
 
+struct typec_info {
 	struct typec_port *port;
 	struct typec_partner *partner;
 	struct typec_switch_dev *sw;
@@ -167,8 +176,9 @@ struct typec_info {
 
 	u8 src_pdo_nr;
 	u8 sink_pdo_nr;
-	u8 sink_watt;
-	u8 sink_voltage;
+	u32 sink_watt;
+	u32 sink_voltage;/* uv */
+	u32 sink_current;/* ua */
 };
 
 struct husb239 {
@@ -180,6 +190,7 @@ struct husb239 {
 	struct gpio_desc *en_gpiod; /* chip enable gpio */
 	struct gpio_desc *chg_gpiod;/* stop charge while set vbus */
 	struct gpio_desc *aud_gpiod;/* audio switch gpio */
+	struct gpio_desc *mic_gpiod;/* mic switch gpio */
 
 	struct gpio_desc *sel_gpiod;/* sel gpio, for orient switch */
 	struct gpio_desc *oe_gpiod; /* oe gpio, for orient switch */
@@ -191,14 +202,13 @@ struct husb239 {
 
 	struct typec_info info;
 
-	bool vbus_on;
-	bool audio_on;
-	bool attached;
+	bool vbus_online;
+	bool audio_online;
+	bool psy_online;
 
-	u32 voltage;
-	u32 req_voltage;
-	u32 max_current;
-	u32 op_current;
+	u32 voltage;/* uv */
+	u32 req_voltage;/* mv */
+	u32 op_current;/* ua */
 
 	enum power_supply_usb_type usb_type;
 	struct power_supply *psy;
@@ -263,6 +273,83 @@ static enum typec_accessory husb239_get_accessory(struct husb239 *husb239)
 	}
 }
 
+#define STEP_BOUNDARY 0x7d
+static void husb239_update_operating_status(struct husb239 *husb239)
+{
+	unsigned int status, status0, status1, type, pd_contract;
+	u32 voltage, op_current;
+	int ret;
+
+	ret = regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status) ||
+		  regmap_read(husb239->regmap, HUSB239_REG_TYPE, &type);
+	if (ret < 0)
+		return;
+
+	dev_dbg(husb239->dev, "update operating status: %x type: %x\n", status, type);
+
+	if (!(status & HUSB239_REG_STATUS_ATTACH)) {
+		husb239->voltage = 0;
+		husb239->op_current = 0;
+		husb239->psy_online = false;
+		goto out;
+	}
+
+	ret = regmap_read(husb239->regmap, HUSB239_REG_CONTRACT_STATUS0, &status0);
+	if (ret < 0)
+		return;
+
+	dev_dbg(husb239->dev, "contract status0: %x\n", status0);
+	pd_contract = (status0 & HUSB239_PD_CONTRACT_MASK) >> HUSB239_PD_CONTRACT_SHIFT;
+
+	if (!(type & HUSB239_REG_TYPE_SINK))
+		return;
+
+	if (!pd_contract) {
+		husb239->voltage = 5000 * 1000;
+		husb239->op_current = 500 * 1000;
+		husb239->psy_online = true;
+		goto out;
+	}
+
+	switch (pd_contract) {
+	case SNKCAP_5V:
+		voltage = 5000;
+		break;
+	case SNKCAP_9V:
+		voltage = 9000;
+		break;
+	case SNKCAP_12V:
+		voltage = 12000;
+		break;
+	case SNKCAP_15V:
+		voltage = 15000;
+		break;
+	case SNKCAP_20V:
+		voltage = 20000;
+		break;
+	default:
+		return;
+	}
+
+	ret = regmap_read(husb239->regmap, HUSB239_REG_CONTRACT_STATUS1, &status1);
+	if (ret < 0)
+		return;
+
+	if (status1 < STEP_BOUNDARY)
+		op_current = 500 + status1 * 20;
+	else
+		op_current = 3000 + (status1 - STEP_BOUNDARY) * 40;
+
+	/* covert mV/mA to uV/uA */
+	husb239->voltage = voltage * 1000;
+	husb239->op_current = op_current * 1000;
+	husb239->psy_online = true;
+
+out:
+	dev_info(husb239->dev, "update sink voltage: %d current: %d\n", husb239->voltage, husb239->op_current);
+	power_supply_changed(husb239->psy);
+}
+
 static void husb239_set_data_role(struct husb239 *husb239,
 				    enum typec_data_role data_role,
 				    bool attached)
@@ -353,12 +440,41 @@ static int husb239_register_partner(struct husb239 *husb239,
 
 static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 {
+	struct typec_info *info = &husb239->info;
 	unsigned int src_pdo;
-	int ret;
+	int ret, snk_sel;
 	int count = 10;
 
+	if (!husb239->psy_online || !info->pd_supported)
+		return -EINVAL;
+
+	if (husb239->voltage == husb239->req_voltage)
+		return 0;
+
+	switch (husb239->req_voltage) {
+	case 5000:
+		snk_sel = SNKCAP_5V;
+		break;
+	case 9000:
+		snk_sel = SNKCAP_9V;
+		break;
+	case 12000:
+		snk_sel = SNKCAP_12V;
+		break;
+	case 15000:
+		snk_sel = SNKCAP_15V;
+		break;
+	case 20000:
+		snk_sel = SNKCAP_20V;
+		break;
+	default:
+		dev_err(husb239->dev, "voltage %d is not support, use default 9v\n", husb239->req_voltage);
+		snk_sel = SNKCAP_9V;
+		break;
+	}
+
 	while(--count) {
-		ret = regmap_read(husb239->regmap, HUSB239_REG_SRC_PDO_9V, &src_pdo);
+		ret = regmap_read(husb239->regmap, HUSB239_REG_SRC_PDO_5V + snk_sel - 1, &src_pdo);
 		if (ret)
 			return ret;
 
@@ -374,7 +490,7 @@ static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 
 	dev_info(husb239->dev, "pd detect \n");
 	ret = regmap_update_bits(husb239->regmap, HUSB239_REG_SRC_PDO,
-				HUSB239_REG_SRC_PDO_SEL_MASK, HUSB239_REG_SRC_PDO_SEL_9V);
+				HUSB239_REG_SRC_PDO_SEL_MASK, (snk_sel << 3));
 	if (ret)
 		return ret;
 
@@ -391,10 +507,11 @@ static int husb239_usbpd_request_voltage(struct husb239 *husb239)
 static int husb239_attach(struct husb239 *husb239)
 {
 	struct typec_info *info = &husb239->info;
-	int ret, status, status1;
+	int ret, status, status1, type;
 
 	if (regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status) ||
-		regmap_read(husb239->regmap, HUSB239_REG_STATUS1, &status1))
+		regmap_read(husb239->regmap, HUSB239_REG_STATUS1, &status1) ||
+		regmap_read(husb239->regmap, HUSB239_REG_TYPE, &type))
 		return -EINVAL;
 
 	dev_info(husb239->dev, "husb239_attach status: %x status1: %x\n", status, status1);
@@ -403,66 +520,43 @@ static int husb239_attach(struct husb239 *husb239)
 	if (ret)
 		return ret;
 
-	if (husb239->aud_gpiod &&
-			(husb239_get_accessory(husb239) == TYPEC_ACCESSORY_AUDIO)) {
+	if (husb239_get_accessory(husb239) == TYPEC_ACCESSORY_AUDIO) {
 		/* sel = 0 audp/audn, sel = 1 hdp/hdn */
-		gpiod_set_value(husb239->aud_gpiod, 1);
-		husb239->audio_on = true;
-		dev_info(husb239->dev, "audo accessory attach\n");
-		ret = husb239_register_partner(husb239, 0, TYPEC_ACCESSORY_AUDIO);
-		if (ret) {
-			dev_info(husb239->dev, "register partner failed: %d\n", ret);
-			goto vbus_disable;
+		if (husb239->aud_gpiod) {
+			gpiod_set_value(husb239->aud_gpiod, 1);
+			/* sel = 0 micp = sleeve, sel = 1 micp = ring2 */
+			gpiod_set_value(husb239->mic_gpiod, 1);
+			husb239->audio_online = true;
 		}
-		return ret;
+		dev_info(husb239->dev, "audio accessory attach\n");
+		ret = husb239_register_partner(husb239, 0, TYPEC_ACCESSORY_AUDIO);
+		if (ret)
+			dev_err(husb239->dev, "register partner failed: %d\n", ret);
 	}
 
 	if (HUSB239_POWER_ROLE(status1) == TYPEC_SOURCE) {
 		if (husb239->vbus_supply) {
 			ret = regulator_enable(husb239->vbus_supply);
-			if (ret) {
-				dev_err(husb239->dev,
-					"Failed to enable vbus supply: %d\n", ret);
-				return ret;
-			}
+			if (ret)
+				dev_err(husb239->dev, "failed to enable vbus supply: %d\n", ret);
 		}
 		gpiod_set_value(husb239->chg_gpiod, 1);
 		husb239_set_gpios_value(husb239->vbus_gpiod, 1);
-		husb239->vbus_on = true;
+		husb239->vbus_online = true;
 		dev_info(husb239->dev, "enable vbus supply\n");
-	} else {
-		if (!husb239_usbpd_request_voltage(husb239)) {
-			husb239->voltage     = 9000;
-			husb239->op_current  = 2000;
-			husb239->max_current = 2000;
-		} else {
-			husb239->voltage     = 5000;
-			husb239->op_current  = 500;
-			husb239->max_current = 500;
-		}
-		power_supply_changed(husb239->psy);
 	}
 
 	typec_set_pwr_role(info->port, HUSB239_POWER_ROLE(status1));
 	typec_set_pwr_opmode(info->port, husb239_get_pwr_opmode(husb239));
 	husb239_set_data_role(husb239, HUSB239_DATA_ROLE(status1), true);
 
-	husb239->attached = true;
-	return 0;
-
-vbus_disable:
-	if (husb239->audio_on) {
-		gpiod_set_value(husb239->aud_gpiod, 0);
-		husb239->audio_on = false;
-	}
-	if (husb239->vbus_on) {
-		husb239_set_gpios_value(husb239->vbus_gpiod, 0);
-		gpiod_set_value(husb239->chg_gpiod, 0);
-		if (husb239->vbus_supply)
-			regulator_disable(husb239->vbus_supply);
-		husb239->vbus_on = false;
-		dev_info(husb239->dev, "disable vbus supply\n");
+	/* pd contract,  try max voltage */
+	if (type & HUSB239_REG_TYPE_SINK) {
+		husb239_update_operating_status(husb239);
+		husb239->req_voltage = info->sink_voltage / 1000;/* mv */
+		husb239_usbpd_request_voltage(husb239);
 	}
+
 	return ret;
 }
 
@@ -484,35 +578,29 @@ static void husb239_detach(struct husb239 *husb239)
 	typec_set_pwr_opmode(info->port, TYPEC_PWR_MODE_USB);
 	husb239_set_data_role(husb239, HUSB239_DATA_ROLE(status1), false);
 
-	if (husb239->audio_on) {
+	if (husb239->audio_online) {
 		gpiod_set_value(husb239->aud_gpiod, 0);
-		husb239->audio_on = false;
-		dev_info(husb239->dev, "audo accessory detach\n");
+		gpiod_set_value(husb239->mic_gpiod, 0);
+		husb239->audio_online = false;
+		dev_info(husb239->dev, "audio accessory detach\n");
 	}
 
-	if (husb239->vbus_on) {
+	if (husb239->vbus_online) {
 		husb239_set_gpios_value(husb239->vbus_gpiod, 0);
 		gpiod_set_value(husb239->chg_gpiod, 0);
 		if (husb239->vbus_supply)
 			regulator_disable(husb239->vbus_supply);
-		husb239->vbus_on = false;
+		husb239->vbus_online = false;
 		dev_info(husb239->dev, "disable vbus supply\n");
 	}
 
-	husb239->attached = false;
-	husb239->voltage  = 0;
-	husb239->max_current = husb239->op_current = 0;
-	power_supply_changed(husb239->psy);
+	husb239_update_operating_status(husb239);
 }
 
 static void husb239_pd_contract(struct husb239 *husb239)
 {
-	int status, status1;
-
-	if (regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status) ||
-		regmap_read(husb239->regmap, HUSB239_REG_STATUS1, &status1))
-		return;
-	dev_info(husb239->dev, "husb239_pd_contract status: %x status1: %x\n", status, status1);
+	husb239_update_operating_status(husb239);
+	husb239_register_partner(husb239, 1, TYPEC_ACCESSORY_NONE);
 }
 
 static void husb239_get_gpio_irq(struct husb239 *husb239)
@@ -547,10 +635,14 @@ static int husb239_chip_init(struct husb239 *husb239)
 
 	husb239->en_gpiod = devm_gpiod_get_optional(husb239->dev, "en", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->en_gpiod)) {
+		dev_err(husb239->dev, "get enable gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->en_gpiod);
 	}
-	gpiod_set_value(husb239->en_gpiod, 0);
-	msleep(10);
+
+	if (!IS_ERR_OR_NULL(husb239->en_gpiod)) {
+		gpiod_set_value(husb239->en_gpiod, 0);
+		msleep(10);
+	}
 
 	/* PORTROLE init */
 	ret = regmap_write(husb239->regmap, HUSB239_REG_PORTROLE,
@@ -590,16 +682,6 @@ static int husb239_chip_init(struct husb239 *husb239)
 	if (ret)
 		return ret;
 
-	/* Clear all interruption */
-	ret = (regmap_update_bits(husb239->regmap, HUSB239_REG_INT,
-				HUSB239_REG_MASK_ALL, HUSB239_REG_MASK_ALL) ||
-			regmap_update_bits(husb239->regmap, HUSB239_REG_INT1,
-				HUSB239_REG_MASK_ALL, HUSB239_REG_MASK_ALL) ||
-			regmap_update_bits(husb239->regmap, HUSB239_REG_INT2,
-				HUSB239_REG_MASK_ALL, HUSB239_REG_MASK_ALL));
-	if (ret)
-		return ret;
-
 	return 0;
 }
 
@@ -617,20 +699,15 @@ static void husb239_work_func(struct work_struct *work)
 	regmap_write(husb239->regmap, HUSB239_REG_INT1, int1);
 
 	if (int1 & HUSB239_REG_MASK_ATTACH) {
-		ret = husb239_attach(husb239);
-		if (ret) {
+		if (husb239_attach(husb239))
 			dev_err(husb239->dev, "husb239_attach error, ret: %x\n", ret);
-			goto err;
-		}
 	}
 
-	if (int1 & HUSB239_REG_MASK_DETACH) {
+	if (int1 & HUSB239_REG_MASK_DETACH)
 		husb239_detach(husb239);
-	}
 
-	if (int0 & HUSB239_REG_MASK2_PD_HV) {
+	if (int0 & HUSB239_REG_MASK2_PD_HV)
 		husb239_pd_contract(husb239);
-	}
 
 err:
 	enable_irq(husb239->gpio_irq);
@@ -649,7 +726,7 @@ static irqreturn_t husb239_irq_handler(int irq, void *data)
 
 static int husb239_irq_init(struct husb239 *husb239)
 {
-	int ret;
+	int ret, status;
 
 	INIT_WORK(&husb239->work, husb239_work_func);
 	husb239->workqueue = alloc_workqueue("husb239_work",
@@ -662,6 +739,13 @@ static int husb239_irq_init(struct husb239 *husb239)
 		return ret;
 	}
 
+	if (regmap_read(husb239->regmap, HUSB239_REG_STATUS, &status)) {
+		goto free_wq;
+	}
+
+	if (status & HUSB239_REG_STATUS_ATTACH)
+		husb239_attach(husb239);
+
 	ret = devm_request_threaded_irq(husb239->dev, husb239->gpio_irq, NULL,
 				husb239_irq_handler,
 				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
@@ -695,7 +779,7 @@ static int husb239_typec_port_probe(struct husb239 *husb239)
 	struct typec_capability *cap = &info->cap;
 	struct fwnode_handle *connector, *ep;
 	struct device *dev = husb239->dev;
-	int ret, i;
+	int ret, i, vol, cur;
 
 	husb239->vbus_supply = devm_regulator_get_optional(dev, "vbus");
 	if (IS_ERR(husb239->vbus_supply)) {
@@ -707,19 +791,28 @@ static int husb239_typec_port_probe(struct husb239 *husb239)
 
 	husb239->vbus_gpiod = devm_gpiod_get_array_optional(dev, "vbus", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->vbus_gpiod)) {
+		dev_err(husb239->dev, "get vbus gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->vbus_gpiod);
 	}
 
 	husb239->chg_gpiod = devm_gpiod_get_optional(dev, "chg", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->chg_gpiod)) {
+		dev_err(husb239->dev, "get charge gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->chg_gpiod);
 	}
 
 	husb239->aud_gpiod = devm_gpiod_get_optional(dev, "aud", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->aud_gpiod)) {
+		dev_err(husb239->dev, "get audio gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->aud_gpiod);
 	}
 
+	husb239->mic_gpiod = devm_gpiod_get_optional(dev, "mic", GPIOD_OUT_LOW);
+	if (IS_ERR(husb239->mic_gpiod)) {
+		dev_err(husb239->dev, "get mic gpio failed, ignore it.\n");
+		return PTR_ERR(husb239->mic_gpiod);
+	}
+
 	connector = device_get_named_child_node(dev, "connector");
 	if (connector) {
 		info->role_sw = fwnode_usb_role_switch_get(connector);
@@ -771,28 +864,28 @@ static int husb239_typec_port_probe(struct husb239 *husb239)
 		}
 
 		for (i = 0; i < info->sink_pdo_nr; i++) {
-			ret = 0;
 			switch (pdo_type(info->sink_pdo[i])) {
 			case PDO_TYPE_FIXED:
-				ret = pdo_fixed_voltage(info->sink_pdo[i]);
+				vol = pdo_fixed_voltage(info->sink_pdo[i]);
 				break;
 			case PDO_TYPE_BATT:
 			case PDO_TYPE_VAR:
-				ret = pdo_max_voltage(info->sink_pdo[i]);
+				vol = pdo_max_voltage(info->sink_pdo[i]);
+				cur = pdo_max_current(info->sink_pdo[i]);
 				break;
 			case PDO_TYPE_APDO:
 			default:
 				ret = 0;
 				break;
 			}
-
-			/* 100mv per unit */
-			info->sink_voltage = max(5000, ret) / 100;
+			/* max sink voltage/current */
+			info->sink_voltage = max(5000, vol) * 1000;/* uv */
+			info->sink_current = max(500, cur) * 1000;/* ua */
 		}
 	}
 
 	if (!fwnode_property_read_u32(connector, "op-sink-microwatt", &ret)) {
-		info->sink_watt = ret / 500000; /* 500mw per unit */
+		info->sink_watt = ret;
 	}
 
 	cap->revision = USB_TYPEC_REV_1_2;
@@ -829,11 +922,13 @@ static int husb239_typec_switch_probe(struct husb239 *husb239)
 
 	husb239->oe_gpiod = devm_gpiod_get_optional(husb239->dev, "orient-oe", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->oe_gpiod)) {
+		dev_err(husb239->dev, "get orient-oe gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->oe_gpiod);
 	}
 
 	husb239->sel_gpiod = devm_gpiod_get_optional(husb239->dev, "orient-sel", GPIOD_OUT_LOW);
 	if (IS_ERR(husb239->sel_gpiod)) {
+		dev_err(husb239->dev, "get orient-sel gpio failed, ignore it.\n");
 		return PTR_ERR(husb239->sel_gpiod);
 	}
 
@@ -860,6 +955,7 @@ static enum power_supply_usb_type husb239_psy_usb_types[] = {
 static const enum power_supply_property husb239_psy_props[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_USB_TYPE,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_CURRENT_MAX,
 	POWER_SUPPLY_PROP_CURRENT_NOW
@@ -870,10 +966,14 @@ static int husb239_psy_set_prop(struct power_supply *psy,
 				const union power_supply_propval *val)
 {
 	struct husb239 *husb239 = power_supply_get_drvdata(psy);
+	int ret = 0;
 
 	if (psp == POWER_SUPPLY_PROP_VOLTAGE_NOW) {
-		husb239->req_voltage = val->intval / 1000;
-		return husb239_usbpd_request_voltage(husb239);
+		husb239->req_voltage = val->intval / 1000; /* mv */
+		ret =  husb239_usbpd_request_voltage(husb239);
+		if (!ret)
+			husb239_update_operating_status(husb239);
+		return ret;
 	}
 
 	return -EINVAL;
@@ -884,20 +984,24 @@ static int husb239_psy_get_prop(struct power_supply *psy,
 				union power_supply_propval *val)
 {
 	struct husb239 *husb239 = power_supply_get_drvdata(psy);
+	struct typec_info *info = &husb239->info;
 	int ret = 0;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
-		val->intval = husb239->attached;
+		val->intval = husb239->psy_online;
 		break;
 	case POWER_SUPPLY_PROP_USB_TYPE:
 		val->intval = husb239->usb_type;
 		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = info->sink_voltage;
+		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
 		val->intval = husb239->voltage;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
-		val->intval = husb239->max_current;
+		val->intval = info->sink_current;
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		val->intval = husb239->op_current;
@@ -970,13 +1074,17 @@ static int husb239_probe(struct i2c_client *client)
 	i2c_set_clientdata(client, husb239);
 
 	husb239->regmap = devm_regmap_init_i2c(client, &config);
-	if (IS_ERR(husb239->regmap))
+	if (IS_ERR(husb239->regmap)) {
+		dev_err(husb239->dev, "fail to init i2c regmap.\n");
 		return PTR_ERR(husb239->regmap);
+	}
 
 	/* Initialize the hardware */
 	ret = husb239_chip_init(husb239);
-	if (ret)
+	if (ret) {
+		dev_err(husb239->dev, "fail to init chip ret: %d\n", ret);
 		return ret;
+	}
 
 	ret = husb239_typec_port_probe(husb239);
 	if (ret) {
@@ -1007,8 +1115,10 @@ static int husb239_probe(struct i2c_client *client)
 	}
 
 	ret = husb239_irq_init(husb239);
-	if (ret)
+	if (ret) {
+		dev_err(husb239->dev, "fail to init irq ret: %d\n", ret);
 		goto err_unreg_switch;
+	}
 
 	return 0;
 
diff --git a/sound/soc/spacemit/Kconfig b/sound/soc/spacemit/Kconfig
index 8c1b74cb3dfb..6e0a73fd2577 100644
--- a/sound/soc/spacemit/Kconfig
+++ b/sound/soc/spacemit/Kconfig
@@ -5,3 +5,27 @@ config SND_SOC_SPACEMIT
 	help
 	  Say Y or M here if you want support for audio on SPACEMIT SoC.
 
+config SPACEMIT_AUDIO_DATA_DEBUG
+        bool "Audio Data Dump"
+        depends on SND_SOC_SPACEMIT
+        help
+          Say Y or N here if you want to enable audio data dump function
+
+config SPACEMIT_PLAY_DEBUG
+        bool "Audio Playback Debug"
+        depends on SPACEMIT_AUDIO_DATA_DEBUG
+        help
+          Say Y or N here if you want to open playback debug
+
+config SPACEMIT_CAPT_DEBUG
+        bool "Audio Capture Debug"
+        depends on SPACEMIT_AUDIO_DATA_DEBUG
+        help
+          Say Y or N here if you want to open capture debug
+
+config  ADD_WAV_HEADER
+        bool "Dump File Adds Wave Header"
+        depends on SPACEMIT_AUDIO_DATA_DEBUG
+        help
+          Say Y or N here if you want to add wave header to dump file
+
diff --git a/sound/soc/spacemit/spacemit-snd-pcm-dma.c b/sound/soc/spacemit/spacemit-snd-pcm-dma.c
index 50fee6701fd9..c844276f8ed1 100644
--- a/sound/soc/spacemit/spacemit-snd-pcm-dma.c
+++ b/sound/soc/spacemit/spacemit-snd-pcm-dma.c
@@ -17,6 +17,53 @@
 #include <sound/dmaengine_pcm.h>
 #include <linux/genalloc.h>
 
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+#include <linux/time.h>
+#include <linux/timex.h>
+#include <linux/ktime.h>
+#include <linux/rtc.h>
+#include <linux/vmalloc.h>
+#include <linux/kthread.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <linux/wait.h>
+#include <linux/debugfs.h>
+#include <linux/namei.h>
+
+#define SPACEMIT_DBG_BUFF_SIZE (128*1024)
+struct spacemit_dbg_buf {
+	char *pStart;
+	char *pEnd;
+	char *pRdPtr;
+	char *pWrPtr;
+	int uBufSize;
+	int uDataSize;
+	int type;
+	int mode;
+	int malloc_flag;
+	wait_queue_head_t data;
+	struct mutex lock;
+	struct task_struct *daemon;
+	struct snd_pcm_runtime *runtime;
+};
+struct dentry *g_debug_file;
+static char dump_file_dir[64] = "/tmp";
+static unsigned int dump_id = 0;
+
+#define SPACEMIT_CODEC_TYPE 0
+#define SPACEMIT_HDMI_TYPE  1
+
+#define SPACEMIT_PLAY_MODE  0
+#define SPACEMIT_CAPT_MODE  1
+
+#define OUTPUT_BUFFER_SIZE 256
+#endif
+
 #define DRV_NAME "spacemit-snd-dma"
 
 #define I2S_PERIOD_SIZE          1024
@@ -62,6 +109,14 @@ struct spacemit_snd_dmadata {
 	struct snd_pcm_substream *substream;
 	unsigned long pos;
 	bool playback_data;
+
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	int play_flag;
+	int capt_flag;
+	int debug_flag;
+	struct spacemit_dbg_buf play_buf;
+	struct spacemit_dbg_buf capt_buf;
+#endif
 };
 
 struct spacemit_snd_soc_device {
@@ -79,15 +134,15 @@ struct hdmi_priv {
 
 /* HDMI initalization data */
 struct hdmi_codec_priv {
-    uint32_t srate;
-    uint32_t channels;
-    uint8_t iec_offset;
+	uint32_t srate;
+	uint32_t channels;
+	uint8_t iec_offset;
 };
 
 static struct hdmi_codec_priv hdmi_ptr = {0};
 static const bool ParityTable256[256] =
 {
-    P6(0), P6(1), P6(1), P6(0)
+	P6(0), P6(1), P6(1), P6(0)
 };
 static struct hdmi_priv priv;
 static dma_addr_t hdmiraw_dma_addr;
@@ -96,7 +151,248 @@ static unsigned char *hdmiraw_dma_area;	/* DMA area */
 #ifdef HDMI_REFORMAT_ENABLE
 static unsigned char *hdmiraw_dma_area_tmp;
 #endif
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+#ifdef CONFIG_ADD_WAV_HEADER
+typedef struct {
+	char riffType[4];
+	char wavType[4];
+	char formatType[4];
+	char dataType[4];
+	unsigned short audioFormat;
+	unsigned short numChannels;
+	unsigned short blockAlign;
+	unsigned short bitsPerSample;
+	unsigned int formatSize;
+	unsigned int sampleRate;
+	unsigned int bytesPerSecond;
+	unsigned int riffSize;
+	unsigned int dataSize;
+} head_data_t;
+#endif
+
+#if defined CONFIG_SPACEMIT_PLAY_DEBUG || defined CONFIG_SPACEMIT_CAPT_DEBUG
+static struct file *try_to_create_pcm_file(char *type, int dma_id)
+{
+	char fname[128];
+	struct timespec64 ts;
+	struct rtc_time tm;
+	struct file *filep = NULL;
+
+	ktime_get_real_ts64(&ts);
+	if (ts.tv_nsec)
+		ts.tv_sec++;
+	ts.tv_sec+=8*60*60;
+	rtc_time64_to_tm(ts.tv_sec, &tm);
+
+	//create file
+	memset(fname, 0, sizeof(fname));
+	strcat(fname, dump_file_dir);
+	if(dma_id < DMA_HDMI) {
+		sprintf(fname+strlen(fname), "/dump-i2s%d-%s-%d-%02d-%02d-%02d-%02d-%02d.pcm", dma_id, type,
+			tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	} else {
+		sprintf(fname+strlen(fname), "/dump-hdmi-%s-%d-%02d-%02d-%02d-%02d-%02d.pcm", type,
+			tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+	}
+	filep = filp_open(fname, O_RDWR|O_CREAT, 0666);
+	if (IS_ERR(filep)) {
+			pr_err("filp_open %s error\n", fname);
+			return NULL;
+	}
+	return filep;
+}
+
+#ifdef CONFIG_ADD_WAV_HEADER
+static int pcm_add_wave_header(struct file *fp, unsigned int channels,
+					unsigned int bits, unsigned int sample_rate,
+					unsigned int len)
+{
+	loff_t wav_pos = 0;
+	ssize_t ret;
+	head_data_t wav_header;
+	if (NULL == fp) {
+		pr_err("Input file ptr is null:%s\n", __func__);
+		return -1;
+	}
+	memcpy(wav_header.riffType, "RIFF", strlen("RIFF"));
+	wav_header.riffSize = len - 8;
+	memcpy(wav_header.wavType, "WAVE", strlen("WAVE"));
+	memcpy(wav_header.formatType, "fmt ", strlen("fmt "));
+	wav_header.formatSize = 16;
+	wav_header.audioFormat = 1;
+	wav_header.numChannels = channels;
+	wav_header.sampleRate = sample_rate;
+	wav_header.blockAlign = channels * bits / 8;
+	wav_header.bitsPerSample = bits;
+	wav_header.bytesPerSecond = wav_header.sampleRate * wav_header.blockAlign;
+	memcpy(wav_header.dataType, "data", strlen("data"));
+	wav_header.dataSize = len - 44;
+	ret = kernel_write(fp, &wav_header, 44, &wav_pos);
+	if (ret > 0) {
+		printk("add wav header size:%ld", ret);
+	} else {
+		pr_err("kernel_write error:%s,line: %d\n", __func__, __LINE__);
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+static int spacemit_debug_data_daemon(void *data)
+{
+	loff_t pos = 0;
+	int ret;
+	char *wr_ptr;
+	struct file *dump_filep = NULL;
+	struct spacemit_dbg_buf *dbgPara = (struct spacemit_dbg_buf *)data;
+	struct spacemit_snd_dmadata *dmadata = dbgPara->runtime->private_data;
+
+	dump_filep = try_to_create_pcm_file(dbgPara->mode == 0 ? "play":"capt", dmadata->dma_id);
+	if (IS_ERR(dump_filep)) {
+		pr_err("ERR: %s try to create pcm file failed!\n", __func__);
+		goto thread_out;
+	}
+
+	/* init the buffer parameter */
+	mutex_lock(&dbgPara->lock);
+	dbgPara->uBufSize = SPACEMIT_DBG_BUFF_SIZE;
+	dbgPara->pRdPtr = dbgPara->pStart;
+	dbgPara->pWrPtr = dbgPara->pStart;
+	printk("dbgPara->pStart :%p", dbgPara->pStart);
+	dbgPara ->uDataSize = 0;
+	dbgPara->pEnd = dbgPara->pStart + SPACEMIT_DBG_BUFF_SIZE;
+	mutex_unlock(&dbgPara->lock);
+
+	#ifdef CONFIG_ADD_WAV_HEADER
+	pos = 44;	//wave header offset
+	#endif
+
+	for(;;){
+		if (kthread_should_stop()) break;
+		while(dbgPara->uDataSize) {
+			wr_ptr = dbgPara->pWrPtr;
+			if (dbgPara->pRdPtr > wr_ptr) {
+				/* write the tail */
+				kernel_write(dump_filep, dbgPara->pRdPtr, dbgPara->pEnd - dbgPara->pRdPtr, &pos);
+				mutex_lock(&dbgPara->lock);
+				dbgPara->uDataSize -= dbgPara->pEnd - dbgPara->pRdPtr;
+				if (dbgPara->uDataSize<0)
+					dbgPara->uDataSize = 0;
+				dbgPara->pRdPtr = dbgPara->pStart;
+				mutex_unlock(&dbgPara->lock);
+			} else {
+				/* write the head */
+				kernel_write(dump_filep, dbgPara->pRdPtr, wr_ptr - dbgPara->pRdPtr, &pos);
+				mutex_lock(&dbgPara->lock);
+				dbgPara->uDataSize -= wr_ptr - dbgPara->pRdPtr;
+				if (dbgPara->uDataSize<0)
+					dbgPara->uDataSize = 0;
+				dbgPara->pRdPtr = (wr_ptr>=dbgPara->pEnd)? dbgPara->pStart : wr_ptr;
+				mutex_unlock(&dbgPara->lock);
+			}
+		}
+
+		ret = wait_event_interruptible(dbgPara->data, (dbgPara->uDataSize > 0) || kthread_should_stop());
+		if (ret < 0) break;
+	}
+
+thread_out:
+	pr_info("thread_out\n");
+	pr_info("dump file size:%llu", pos);
+
+#ifdef CONFIG_ADD_WAV_HEADER
+	pcm_add_wave_header(dump_filep, dbgPara->runtime->channels,
+				dbgPara->runtime->sample_bits,
+				dbgPara->runtime->rate, pos);
+#endif
+
+	if (dump_filep) {
+		filp_close(dump_filep, NULL);
+	}
+	if (dbgPara->pStart) {
+		vfree(dbgPara->pStart);
+		dbgPara->pStart = 0;
+	}
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+	}
+
+	return 0;
+}
+
+static void spacemit_debug_data(char *hwbuf, struct spacemit_dbg_buf *debug_buf,
+				int *debug_flag, int *mode_flag,
+				struct snd_pcm_runtime *runtime,
+				unsigned long bytes, int type, int mode,
+				int malloc_flag)
+{
+	char thread_name[24];
+	struct spacemit_snd_dmadata *dmadata = runtime->private_data;
+
+	if (*debug_flag && !(*mode_flag)) {
+		/* start task */
+		memset(debug_buf, 0, sizeof(*debug_buf));
+		debug_buf->type = type;
+		debug_buf->mode = mode;
+		debug_buf->runtime = runtime;
+		debug_buf->malloc_flag = malloc_flag;
+		init_waitqueue_head(&debug_buf->data);
+		mutex_init(&debug_buf->lock);
+		if ((type == SPACEMIT_CODEC_TYPE) && (mode == SPACEMIT_PLAY_MODE)) {
+			snprintf(thread_name, sizeof(thread_name), "i2s%d-play-dbg", dmadata->dma_id);
+		} else if ((type == SPACEMIT_CODEC_TYPE) && (mode == SPACEMIT_CAPT_MODE)) {
+			snprintf(thread_name, sizeof(thread_name), "i2s%d-capt-dbg", dmadata->dma_id);
+		} else if ((type == SPACEMIT_HDMI_TYPE) && (mode == SPACEMIT_PLAY_MODE)) {
+			snprintf(thread_name, sizeof(thread_name), "hdmi-play-dbg");
+		}
+		if (thread_name[0] != '\0') {
+			debug_buf->daemon = kthread_run(spacemit_debug_data_daemon, debug_buf, thread_name);
+		}
+		*mode_flag = 1;
+	} else if (!(*debug_flag) && *mode_flag) {
+		/* stop task */
+		kthread_stop(debug_buf->daemon);
+		memset(debug_buf, 0, sizeof(*debug_buf));
+		*mode_flag = 0;
+	}
+	if (!debug_buf->malloc_flag) {
+		debug_buf->pStart = vmalloc(SPACEMIT_DBG_BUFF_SIZE);
+		if (!debug_buf->pStart) {
+			pr_err("ERR: %s try to vmalloc %d bytes failed!\n", __func__, SPACEMIT_DBG_BUFF_SIZE);
+		} else {
+			pr_info("try to vmalloc buffer success\n");
+		}
+		debug_buf->malloc_flag = 1;
+	}
+	if (*debug_flag && *mode_flag && debug_buf->pStart && debug_buf->uBufSize) {
+		size_t size = bytes;
+		if (size > (debug_buf->uBufSize - debug_buf->uDataSize)) {
+			size = debug_buf->uBufSize - debug_buf->uDataSize;
+		}
 
+		if (size <= (debug_buf->pEnd - debug_buf->pWrPtr)) {
+			memcpy(debug_buf->pWrPtr, hwbuf, size);
+			mutex_lock(&debug_buf->lock);
+			debug_buf->pWrPtr += size;
+			debug_buf->uDataSize += size;
+			if (debug_buf->pWrPtr == debug_buf->pEnd)
+				debug_buf->pWrPtr = debug_buf->pStart;
+			mutex_unlock(&debug_buf->lock);
+		} else {
+			memcpy(debug_buf->pWrPtr, hwbuf, debug_buf->pEnd - debug_buf->pWrPtr);
+			memcpy(debug_buf->pStart, hwbuf+(debug_buf->pEnd - debug_buf->pWrPtr), size-(debug_buf->pEnd - debug_buf->pWrPtr));
+			mutex_lock(&debug_buf->lock);
+			debug_buf->pWrPtr = debug_buf->pStart + size - (debug_buf->pEnd - debug_buf->pWrPtr);
+			debug_buf->uDataSize += size;
+			mutex_unlock(&debug_buf->lock);
+		}
+		/* wakeup the daemon */
+		wake_up(&debug_buf->data);
+	}
+}
+#endif
+#endif
 static int spacemit_snd_dma_init(struct device *paraent, struct spacemit_snd_soc_device *dev,
 			     struct spacemit_snd_dmadata *dmadata);
 
@@ -637,6 +933,20 @@ static int spacemit_snd_pcm_open(struct snd_soc_component *component, struct snd
 	spin_lock_irqsave(&dev->lock, flags);
 
 	dmadata = &dev->dmadata[substream->stream];
+
+	#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	dmadata->debug_flag = 1;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		#ifdef CONFIG_SPACEMIT_PLAY_DEBUG
+		dmadata->play_flag = 0;
+		#endif
+	} else {
+		#ifdef CONFIG_SPACEMIT_CAPT_DEBUG
+		dmadata->capt_flag = 0;
+		#endif
+	}
+	#endif
+
 	if (dmadata->dma_id == DMA_HDMI) {
 		ret = snd_soc_set_runtime_hwparams(substream, &spacemit_snd_pcm_hardware_hdmi);
 	} else {
@@ -685,11 +995,35 @@ static int spacemit_snd_pcm_close(struct snd_soc_component *component, struct sn
 	}
 unlock:
 	spin_unlock_irqrestore(&dev->lock, flags);
+
+	#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	dmadata->debug_flag = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		#ifdef CONFIG_SPACEMIT_PLAY_DEBUG
+		if (dmadata->play_flag) {
+			/* stop task */
+			kthread_stop(dmadata->play_buf.daemon);
+			vfree(dmadata->play_buf.pStart);
+			memset(&dmadata->play_buf, 0, sizeof(dmadata->play_buf));
+			dmadata->play_flag = 0;
+		}
+		#endif
+	} else {
+		#ifdef CONFIG_SPACEMIT_CAPT_DEBUG
+		if (dmadata->capt_flag) {
+			kthread_stop(dmadata->capt_buf.daemon);
+			memset(&dmadata->capt_buf, 0, sizeof(dmadata->capt_buf));
+			dmadata->capt_flag = 0;
+		}
+		#endif
+	}
+	#endif
+
 	return 0;
 }
 
 static int spacemit_snd_pcm_lib_ioctl(struct snd_soc_component *component, struct snd_pcm_substream *substream,
-		      unsigned int cmd, void *arg)
+				unsigned int cmd, void *arg)
 {
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
@@ -752,7 +1086,7 @@ static int spacemit_snd_pcm_new(struct snd_soc_component *component, struct snd_
 }
 
 static int spacemit_snd_dma_init(struct device *paraent, struct spacemit_snd_soc_device *dev,
-			     struct spacemit_snd_dmadata *dmadata)
+					struct spacemit_snd_dmadata *dmadata)
 {
 	dma_cap_mask_t mask;
 	spin_lock_init(&dmadata->dma_lock);
@@ -868,21 +1202,64 @@ static void hdmi_reformat(void *dst, void *src, int len)
 	}
 }
 
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
 static int spacemit_snd_pcm_copy(struct snd_soc_component *component,
-                          struct snd_pcm_substream *substream,
-                          int channel, unsigned long hwoff,
-                          struct iov_iter *iter, unsigned long bytes)
+							struct snd_pcm_substream *substream,
+							int channel, unsigned long hwoff,
+							struct iov_iter *iter, unsigned long bytes)
 {
 	int ret = 0;
 	char *hwbuf;
-	char *hdmihw_area;
 	struct snd_pcm_runtime *runtime = substream->runtime;
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	struct spacemit_snd_dmadata *dmadata = runtime->private_data;
+#endif
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_from_iter(hwbuf, bytes, iter) != bytes)
+						return -EFAULT;
+#ifdef CONFIG_SPACEMIT_PLAY_DEBUG
+		if (dump_id & (1 << (2 * dmadata->dma_id))) {
+			spacemit_debug_data(hwbuf, &dmadata->play_buf, &dmadata->debug_flag, &dmadata->play_flag, runtime,
+				bytes, SPACEMIT_CODEC_TYPE, SPACEMIT_PLAY_MODE, 0);
+		}
+#endif
+
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_to_iter(hwbuf, bytes, iter) != bytes)
+						return -EFAULT;
+#ifdef CONFIG_SPACEMIT_CAPT_DEBUG
+		if ((dump_id & (1 << (2 * dmadata->dma_id + 1)))) {
+			spacemit_debug_data(hwbuf, &dmadata->capt_buf, &dmadata->debug_flag, &dmadata->capt_flag, runtime,
+				bytes, SPACEMIT_CODEC_TYPE, SPACEMIT_CAPT_MODE,0);
+		}
+#endif
+
+	}
+
+	return ret;
+}
+#endif
+
+static int spacemit_snd_pcm_hdmi_copy(struct snd_soc_component *component,
+							struct snd_pcm_substream *substream,
+							int channel, unsigned long hwoff,
+							struct iov_iter *iter, unsigned long bytes)
+{
+	int ret = 0;
+	char *hwbuf;
+	char *hdmihw_area;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	struct spacemit_snd_dmadata *dmadata = runtime->private_data;
+#endif
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 #ifdef HDMI_REFORMAT_ENABLE
 		hwbuf = runtime->dma_area + hwoff;
 		if (copy_from_iter(hwbuf, bytes, iter) != bytes)
-                        return -EFAULT;
+						return -EFAULT;
 		hdmihw_area = hdmiraw_dma_area_tmp + 2 * hwoff;
 		hdmi_reformat((int *)hdmihw_area, (short *)hwbuf, bytes_to_frames(substream->runtime, bytes));
 		memcpy((void *)(hdmiraw_dma_area + 2 * hwoff), (void *)hdmihw_area, bytes * 2);
@@ -891,18 +1268,27 @@ static int spacemit_snd_pcm_copy(struct snd_soc_component *component,
 		if (hwbuf == NULL)
 			pr_err("%s addr null !!!!!!!!!!!!\n", __func__);
 		if (copy_from_iter(hwbuf, bytes, iter) != bytes)
-                        return -EFAULT;
-
+						return -EFAULT;
+#endif
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+#ifdef CONFIG_SPACEMIT_PLAY_DEBUG
+		if (dump_id & (1 << (2 * dmadata->dma_id))) {
+			spacemit_debug_data(hwbuf, &dmadata->play_buf, &dmadata->debug_flag, &dmadata->play_flag, runtime,
+				bytes, SPACEMIT_HDMI_TYPE,SPACEMIT_PLAY_MODE, 0);
+		}
+#endif
 #endif
 
 	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		hwbuf = runtime->dma_area + hwoff;
 		if (copy_to_iter(hwbuf, bytes, iter) != bytes)
-                        return -EFAULT;
+						return -EFAULT;
 	}
 
 	return ret;
 }
+
+
 static const struct snd_soc_component_driver spacemit_snd_dma_component = {
 	.name          = DRV_NAME,
 	.probe		   = spacemit_snd_pcm_probe,
@@ -915,6 +1301,9 @@ static const struct snd_soc_component_driver spacemit_snd_dma_component = {
 	.trigger	   = spacemit_snd_pcm_trigger,
 	.pointer	   = spacemit_snd_pcm_pointer,
 	.pcm_construct = spacemit_snd_pcm_new,
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+	.copy		   = spacemit_snd_pcm_copy,
+#endif
 };
 
 static const struct snd_soc_component_driver spacemit_snd_dma_component_hdmi = {
@@ -929,7 +1318,7 @@ static const struct snd_soc_component_driver spacemit_snd_dma_component_hdmi = {
 	.trigger	   = spacemit_snd_pcm_trigger,
 	.pointer	   = spacemit_snd_pcm_hdmi_pointer,
 	.pcm_construct = spacemit_snd_pcm_new,
-	.copy		= spacemit_snd_pcm_copy,
+	.copy		   = spacemit_snd_pcm_hdmi_copy,
 };
 
 static int spacemit_snd_dma_pdev_probe(struct platform_device *pdev)
@@ -941,7 +1330,7 @@ static int spacemit_snd_dma_pdev_probe(struct platform_device *pdev)
 
 	device = devm_kzalloc(&pdev->dev, sizeof(*device), GFP_KERNEL);
 	if (!device) {
-		pr_err("%s: alloc memoery failed\n", __FUNCTION__);
+		pr_err("%s: alloc memory failed\n", __FUNCTION__);
 		return -ENOMEM;
 	}
 
@@ -1020,5 +1409,199 @@ static int spacemit_snd_pcm_init(void)
 late_initcall_sync(spacemit_snd_pcm_init);
 #endif
 
+#ifdef CONFIG_SPACEMIT_AUDIO_DATA_DEBUG
+
+static int check_path_exists(const char *path)
+{
+	struct path kp;
+	if (kern_path(path, LOOKUP_PARENT, &kp) == 0) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static void print_dump_config(char *buffer, int size)
+{
+	int i;
+	unsigned int mask = 0x1;
+	const char *dma_chans[] = {"I2S0", "I2S1", "HDMI"};
+	int remaining_size;
+	int playback_enabled, capture_enabled, line_length;
+	snprintf(buffer, size,
+				"Dump Configuration:\n"
+				"Dmahan  Playback  Capture\n"
+				"------- --------  -------\n");
+	remaining_size = size - strlen(buffer);
+	if (remaining_size <= 0) {
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dma_chans); i++) {
+		playback_enabled = (dump_id & (mask << (2 * i))) ? 1 : 0;
+		capture_enabled = (dump_id & (mask << (2 * i + 1))) ? 1 : 0;
+
+		line_length = snprintf(NULL, 0, "%6s %5d %10d\n", dma_chans[i], playback_enabled, capture_enabled);
+		if (remaining_size < line_length + 1) {
+			break;
+		}
+		snprintf(buffer + strlen(buffer), remaining_size, "%6s %5d %10d\n",
+			dma_chans[i], playback_enabled, capture_enabled);
+		remaining_size -= line_length;
+	}
+}
+
+static int config_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t config_read(struct file *file, char __user *buffer, size_t count, loff_t *pos)
+{
+	char *output = NULL;
+	int len, retval;
+	size_t alloc_size = OUTPUT_BUFFER_SIZE;
+
+	output = vmalloc(alloc_size);
+	if (!output) {
+		return -ENOMEM;
+	}
+
+	memset(output, 0, alloc_size);
+
+	print_dump_config(output, alloc_size);
+	len = strlen(output);
+
+	if (*pos >= len) {
+		retval = 0;
+		goto out_free;
+	}
+
+	if (count > len - *pos)
+		count = len - *pos;
+
+	if (copy_to_user(buffer, output + *pos, count)) {
+		retval = -EFAULT;
+		goto out_free;
+	}
+
+	*pos += count;
+	retval = count;
+
+out_free:
+	vfree(output);
+	return retval;
+}
+
+static ssize_t config_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	char input[32];
+	char *p_input = input;
+	char *param[4];
+	char *token;
+	char *endptr;
+	int param_count = 0;
+	unsigned int dma_chan;
+	const char *usage_info=
+		"Usage: [dma_chan:%%d] [mode:c/p] [enable:1/0] [/path/to/file]\n"
+		"dma_chan: 0: I2S0, 1: I2S1, 2: HDMI\n"
+		"mode:     c: capture, p: playback\n"
+		"enable:   1: enable, 0: disable\n"
+		"example: echo 0 p 1 /tmp/dump > /sys/kernel/debug/asoc/dump\n"
+		"echo help/h > /sys/kernel/debug/asoc/dump\n";
+
+	if (count > sizeof(input) - 1)
+		count = sizeof(input) - 1;
+
+	if (copy_from_user(input, buffer, count))
+		return -EFAULT;
+
+	input[count-1] = '\0';
+	if (strcmp(input, "help") == 0 || strcmp(input, "h") == 0) {
+		pr_info("%s", usage_info);
+		return count;
+	}
+
+	while ((token = strsep(&p_input, " ")) != NULL) {
+		if (param_count >= 4) {
+			pr_err("Too many parameters.\n");
+			return -EINVAL;
+		}
+		param[param_count++] = token;
+	}
+
+	if (param_count > 4 || param_count < 3) {
+		pr_info("%s", usage_info);
+		return -EINVAL;
+	}
+
+	dma_chan = (unsigned int)simple_strtol(param[0], &endptr, 10);
+	if (endptr == param[0] || *endptr != '\0') {
+		pr_err("Invalid dma_chan, please input a number\n");
+		return -EINVAL;
+	}
+	if (dma_chan < DMA_I2S0 || dma_chan > DMA_HDMI) {
+		pr_err("Invalid dma_chan, please input a number between %d and %d\n", DMA_I2S0, DMA_HDMI);
+		return -EINVAL;
+	}
+
+	if (strcmp(param[1], "p") != 0 && strcmp(param[1], "c") != 0) {
+		pr_err("Invalid mode: please input 'c' for capture or 'p' for playback\n");
+		return -EINVAL;
+	} else if (strcmp(param[2], "1") != 0 && strcmp(param[2], "0") != 0) {
+		pr_err("Invalid status: please input '1' to enable or '0' to disable\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(param[1], "p") == 0 && strcmp(param[2], "0") == 0)
+		dump_id &= ~(1 << (2 * dma_chan));
+	else if (strcmp(param[1], "p") == 0 && strcmp(param[2], "1") == 0)
+		dump_id |= (1 << (2 * dma_chan));
+	else if (strcmp(param[1], "c") == 0 && strcmp(param[2], "0") == 0)
+		dump_id &= ~(1 << (2 * dma_chan + 1));
+	else if (strcmp(param[1], "c") == 0 && strcmp(param[2], "1") == 0)
+		dump_id |= (1 << (2 * dma_chan + 1));
+	else
+		return -EINVAL;
+
+	if (param_count == 4) {
+		if (check_path_exists(param[3]) == 0) {
+			pr_err("Path does not exist\n");
+			return -EINVAL;
+		} else {
+			strncpy(dump_file_dir, param[3], sizeof(dump_file_dir) - 1);
+		}
+	}
+	return count;
+}
+
+static const struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.read  = config_read,
+	.write = config_write,
+	.open = config_open,
+};
+
+static int __init dump_debugfs_init(void)
+{
+	g_debug_file = debugfs_create_file("dump", 0666, snd_soc_debugfs_root, NULL, &fops);
+	if (!g_debug_file) {
+		pr_err("Failed to create debugfs file\n");
+		return -ENOMEM;
+	}
+	pr_info("Dump debugfs initialized\n");
+	return 0;
+}
+
+static void __exit dump_debugfs_exit(void)
+{
+	debugfs_remove(g_debug_file);
+	pr_info("Debugfs removed\n");
+}
+module_init(dump_debugfs_init);
+module_exit(dump_debugfs_exit);
+#endif
+
 MODULE_DESCRIPTION("SPACEMIT ASoC PCM Platform Driver");
 MODULE_LICENSE("GPL");
-- 
2.47.0

