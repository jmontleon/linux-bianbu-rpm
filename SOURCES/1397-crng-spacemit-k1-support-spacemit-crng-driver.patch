From 97443dea0a7dc1d5ff9fd0934611bfb876c438d6 Mon Sep 17 00:00:00 2001
From: yanhaodong <haodong.yan@spacemit.com>
Date: Tue, 24 Dec 2024 11:12:26 +0800
Subject: [PATCH 1397/1451] crng: spacemit/k1: support spacemit crng driver

Change-Id: I2cf5d81539ea26b5e802e1ae70eadfe9600e2361
---
 drivers/char/hw_random/Kconfig         |   9 +
 drivers/char/hw_random/Makefile        |   1 +
 drivers/char/hw_random/spacemit-crng.c | 492 +++++++++++++++++++++++++
 3 files changed, 502 insertions(+)
 create mode 100644 drivers/char/hw_random/spacemit-crng.c

diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index 8de74dcfa18c..c70bce0289d3 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -573,6 +573,15 @@ config HW_RANDOM_JH7110
 	  To compile this driver as a module, choose M here.
 	  The module will be called jh7110-trng.
 
+config HW_RANDOM_SPACEMIT
+	tristate "SPACEMIT K1 Random Number Generator support"
+	depends on SOC_SPACEMIT_K1X
+	help
+	  This driver provides support for the True Random Number
+	  Generator in Spacemit K1.
+
+	  To compile this driver as a module, choose M here.
+	  The module will be called spacemit-crng.
 endif # HW_RANDOM
 
 config UML_RANDOM
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index 32549a1186dc..c384b45d3c8f 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -49,3 +49,4 @@ obj-$(CONFIG_HW_RANDOM_ARM_SMCCC_TRNG) += arm_smccc_trng.o
 obj-$(CONFIG_HW_RANDOM_CN10K) += cn10k-rng.o
 obj-$(CONFIG_HW_RANDOM_POLARFIRE_SOC) += mpfs-rng.o
 obj-$(CONFIG_HW_RANDOM_JH7110) += jh7110-trng.o
+obj-$(CONFIG_HW_RANDOM_SPACEMIT) += spacemit-crng.o
diff --git a/drivers/char/hw_random/spacemit-crng.c b/drivers/char/hw_random/spacemit-crng.c
new file mode 100644
index 000000000000..d46a6583048c
--- /dev/null
+++ b/drivers/char/hw_random/spacemit-crng.c
@@ -0,0 +1,492 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2024 Spacemit corporation.
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/init.h>
+#include <linux/random.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/hw_random.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/ktime.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+
+#define RNG_BYTE_CNT		0x4
+#define RNG_SRC_ADDR		0x14
+#define RNG_DEST_ADDR		0x24
+#define RNG_NEXT_DESC_PTR	0x34
+#define RNG_SQU_CTRL		0x44
+#define RNG_CURR_DESC_PTR	0x74
+#define RNG_INT_MASK		0x84
+#define RNG_REST_SEL		0x94
+#define RNG_INT_STATUS		0xa4
+#define RNG_CTRL			0xc0
+#define RNG_DATA			0xc4
+#define RNG_SEED_VAL		0xc8
+#define RNG_CTRL_EXT		0xd0
+
+#define SQU_CTRL_FIFO_CLR	BIT(30)
+#define SQU_CTRL_ENABLE_DMA	(0x03c60383)
+#define RNG_INT_DONE_MASK	BIT(0)
+#define RESET_SEL_MASK		BIT(0)
+#define CTRL_RNG_EN			BIT(0)
+#define CTRL_RNG_VALID		BIT(31)
+#define CTRL_RNG_SEED_VALID	BIT(30)
+#define CTRL_RNG_SEED_EN	BIT(1)
+#define RNG_REG_SEL			BIT(4)
+#define RNG_REG_LDO_PU		BIT(6)
+#define RNG_SUCCESS			0x55
+#define RNG_FAIL			0xaa
+
+#define DMA_MAX_SIZE 0xfff0
+
+#define to_spacemit_crng(p)	container_of(p, struct spacemit_crng, rng)
+
+struct spacemit_crng {
+	void __iomem *base;
+	struct hwrng rng;
+	struct clk *clk;
+	struct reset_control *reset;
+	spinlock_t lock;
+};
+
+static void _hw_rng_dump_reg(struct spacemit_crng *priv)
+{
+	uint32_t val;
+
+	printk("===============================================\n");
+	val = readl(priv->base + RNG_BYTE_CNT);
+	pr_info("RNG_BYTE_CNT:0x%x, value:0x%x\n", RNG_BYTE_CNT, val);
+	val = readl(priv->base + RNG_SRC_ADDR);
+	pr_info("RNG_SRC_ADDR:0x%x, value:0x%x\n", RNG_SRC_ADDR, val);
+	val = readl(priv->base + RNG_DEST_ADDR);
+	pr_info("RNG_DEST_ADDR:0x%x, value:0x%x\n", RNG_DEST_ADDR, val);
+	val = readl(priv->base + RNG_NEXT_DESC_PTR);
+	pr_info("RNG_NEXT_DESC_PTR:0x%x, value:0x%x\n", RNG_NEXT_DESC_PTR, val);
+	val = readl(priv->base + RNG_SQU_CTRL);
+	pr_info("RNG_SQU_CTRL:0x%x, value:0x%x\n", RNG_SQU_CTRL, val);
+	val = readl(priv->base + RNG_CURR_DESC_PTR);
+	pr_info("RNG_CURR_DESC_PTR:0x%x, value:0x%x\n", RNG_CURR_DESC_PTR, val);
+	val = readl(priv->base + RNG_INT_MASK);
+	pr_info("RNG_INT_MASK:0x%x, value:0x%x\n", RNG_INT_MASK, val);
+	val = readl(priv->base + RNG_REST_SEL);
+	pr_info("RNG_REST_SEL:0x%x, value:0x%x\n", RNG_REST_SEL, val);
+	val = readl(priv->base + RNG_INT_STATUS);
+	pr_info("RNG_INT_STATUS:0x%x, value:0x%x\n", RNG_INT_STATUS, val);
+	val = readl(priv->base + RNG_CTRL);
+	pr_info("RNG_CTRL:0x%x, value:0x%x\n", RNG_CTRL, val);
+	val = readl(priv->base + RNG_DATA);
+	pr_info("RNG_DATA:0x%x, value:0x%x\n", RNG_DATA, val);
+	val = readl(priv->base + RNG_SEED_VAL);
+	pr_info("RNG_SEED_VAL:0x%x, value:0x%x\n", RNG_SEED_VAL, val);
+	val = readl(priv->base + RNG_CTRL_EXT);
+	pr_info("RNG_CTRL_EXT:0x%x, value:0x%x\n", RNG_CTRL_EXT, val);
+	printk("===============================================\n");
+}
+
+static void _hw_rng_clr_fifo(struct spacemit_crng *priv)
+{
+	uint32_t val;
+
+	val = readl(priv->base + RNG_SQU_CTRL);
+	val |= SQU_CTRL_FIFO_CLR;
+	writel(val, priv->base + RNG_SQU_CTRL);
+}
+
+__maybe_unused static void spacemit_crng_cleanup(struct hwrng *rng)
+{
+	struct spacemit_crng *priv = to_spacemit_crng(rng);
+	_hw_rng_clr_fifo(priv);
+}
+
+static void _hw_rng_reset_status(struct spacemit_crng *priv)
+{
+	uint32_t val;
+
+	/* clr squ fifo */
+	_hw_rng_clr_fifo(priv);
+
+	/* clr rng and seed ctrl bit */
+	val = readl(priv->base + RNG_CTRL);
+	val &= ~(CTRL_RNG_EN | CTRL_RNG_VALID);
+	val &= ~(CTRL_RNG_SEED_EN | CTRL_RNG_SEED_VALID);
+	writel(val, priv->base + RNG_CTRL);
+}
+
+static int hw_rng_dma_setup(struct spacemit_crng *priv, uint32_t pa, size_t size)
+{
+	uint32_t val, val_size;
+	int ret;
+
+	/* dma setup */
+	val = readl(priv->base + RNG_INT_MASK);
+	val |= (0x1 << 0);
+	writel(val, priv->base + RNG_INT_MASK);
+
+	val = readl(priv->base + RNG_BYTE_CNT);
+	val = size;
+	writel(val, priv->base + RNG_BYTE_CNT);
+
+	val = readl(priv->base + RNG_SRC_ADDR);
+	val = 0x0;
+	writel(val, priv->base + RNG_SRC_ADDR);
+
+	val = readl(priv->base + RNG_DEST_ADDR);
+	val = pa;
+	writel(val, priv->base + RNG_DEST_ADDR);
+
+	val = readl(priv->base + RNG_REST_SEL);
+	val |= 0x1;
+	writel(val, priv->base + RNG_REST_SEL);
+
+	/* enable dma  */
+	val = readl(priv->base + RNG_SQU_CTRL);
+	val = SQU_CTRL_ENABLE_DMA;
+	writel(val, priv->base + RNG_SQU_CTRL);
+	ret = RNG_SUCCESS;
+	return ret;
+}
+
+static int get_rng_seed(struct spacemit_crng *priv)
+{
+	uint32_t seed = 0;
+	uint8_t rng_seed_retry = 0;
+	s64 timeout = 100000, mytime = 0;
+	ktime_t base_time, delta_time;
+	uint32_t val;
+
+retry:
+	seed = (u32)ktime_to_us(ktime_get());
+
+	/* generate software seed */
+	writel(seed, priv->base + RNG_SEED_VAL);
+
+	val = readl(priv->base + RNG_CTRL);
+	val |= CTRL_RNG_SEED_EN;
+	writel(val, priv->base + RNG_CTRL);
+
+	base_time = ktime_get();
+
+	do {
+		val = readl(priv->base + RNG_CTRL);
+		if (val & CTRL_RNG_SEED_VALID)
+			break;
+
+		delta_time = ktime_sub(ktime_get(), base_time);
+		mytime = ktime_to_us(delta_time);
+		if (mytime >= timeout) {
+			if (rng_seed_retry == 0) {
+				_hw_rng_reset_status(priv);
+				rng_seed_retry = 1;
+				pr_err("generate rng seed timeout and retry! \n");
+				goto retry;
+			} else {
+				_hw_rng_dump_reg(priv);
+				pr_err("fail to generate rng seed, time out! \n");
+				return RNG_FAIL;
+			}
+		}
+	} while (1);
+
+	return RNG_SUCCESS;
+}
+
+static int hw_get_random_dma(struct spacemit_crng *priv, uint64_t pa, size_t size, void *buf)
+{
+	uint32_t val;
+	int ret = 0;
+	uint32_t dest_addr;
+	uint32_t timeout = 50 * 1000;
+
+	spin_lock(&priv->lock);
+
+	ret = get_rng_seed(priv);
+	if (ret != RNG_SUCCESS) {
+		pr_err("fail to generate rng seed!\n");
+		goto exit;
+	}
+
+	/* enable rng */
+	val = readl(priv->base + RNG_CTRL_EXT);
+	val &= ~(RNG_REG_SEL | RNG_REG_LDO_PU);
+	writel(val, priv->base + RNG_CTRL_EXT);
+
+	val = readl(priv->base + RNG_CTRL);
+	val |= CTRL_RNG_EN;
+	writel(val, priv->base + RNG_CTRL);
+	dest_addr = (uint32_t)(pa & 0xFFFFFFFF);
+
+	/* hw rng dma setup and enable */
+	ret = hw_rng_dma_setup(priv, pa, size);
+	if (ret != RNG_SUCCESS) {
+		pr_err("Fail to setup and enable dma mode, dest_addr=0x%lx, size=0x%x! \n",
+				(unsigned long)pa, (uint32_t)size);
+		goto exit;
+	}
+
+	while (timeout) {
+		val = readl(priv->base + RNG_INT_STATUS);
+		if ((val & 0x1) == 0x1)
+			break;
+		timeout -= 2000;
+		udelay(2000);
+
+		if (timeout == 0) {
+			pr_err("rng wait dma timeout !!! timeout = %d , paddr=0x%lx, size=0x%x\n",
+				timeout, (unsigned long)pa, (uint32_t)size);
+			ret = -1;
+			goto exit;
+		}
+	}
+
+exit:
+	spin_unlock(&priv->lock);
+	return ret;
+}
+
+static uint32_t _hw_get_random(struct spacemit_crng *priv)
+{
+	uint32_t random = 0;
+
+	/* get random value */
+	random = readl(priv->base + RNG_DATA);
+
+	return random;
+}
+
+static uint8_t hw_get_random_byte(struct spacemit_crng *priv)
+{
+	return (uint8_t)_hw_get_random(priv);
+}
+
+static uint32_t hw_get_random_32(struct spacemit_crng *priv)
+{
+	return (uint32_t)_hw_get_random(priv);
+}
+
+static int hw_get_random_cpu(struct spacemit_crng *priv, void *buf, size_t size)
+{
+	uint8_t *b = buf;
+	size_t n;
+	uint32_t update_len = 0, finish_len = 0;
+	uint32_t val, val_old = 0;
+	s64 timeout = 100000, mytime = 0;
+	ktime_t base_time, delta_time;
+	int ret = 0;
+	uint8_t rng_val_retry = 0;
+
+	spin_lock(&priv->lock);
+retry:
+	/* generate hw-rng seed */
+	ret = get_rng_seed(priv);
+	if (ret != RNG_SUCCESS) {
+		pr_err("Fail to generate rng seed ! \n");
+		ret = -EINVAL;
+		goto exit;
+	}
+	/* generate random value */
+	val = readl(priv->base + RNG_CTRL);
+	val |= CTRL_RNG_EN;
+	writel(val, priv->base + RNG_CTRL);
+	base_time = ktime_get();
+	do {
+		val = readl(priv->base + RNG_CTRL);
+		if (val & CTRL_RNG_VALID)
+			break;
+
+		delta_time = ktime_sub(ktime_get(), base_time);
+		mytime = ktime_to_us(delta_time);
+		udelay(200);
+		if (mytime >= timeout) {
+			if (rng_val_retry == 0) {
+				_hw_rng_reset_status(priv);
+				rng_val_retry = 1;
+				pr_err("generate rng value timeout and retry! \n");
+				goto retry;
+			} else {
+				_hw_rng_dump_reg(priv);
+				pr_err("fail to generate rng value, time out! \n");
+				ret = RNG_FAIL;
+				goto exit;
+			}
+		}
+	} while (1);
+	update_len = (size / 4) * 4;
+	finish_len = size % 4;
+
+	/* get random value */
+	if (update_len) {
+		for (n = 0; n < update_len; n += 4) {
+readval32:
+			/* clr squ fifo */
+			_hw_rng_clr_fifo(priv);
+			val = hw_get_random_32(priv);
+
+			if (val != val_old) {
+				b[n] = val & 0xFF;
+				b[n + 1] = (val >> 8) & 0xFF;
+				b[n + 2] = (val >> 16) & 0xFF;
+				b[n + 3] = (val >> 24) & 0xFF;
+			} else {
+				goto readval32;
+			}
+
+			val_old = val;
+		}
+	}
+
+	if (finish_len) {
+		for (n = 0; n < finish_len; n++) {
+readvalbyte:
+			/* clr squ fifo */
+			_hw_rng_clr_fifo(priv);
+
+			val = hw_get_random_byte(priv);
+
+			if (val != val_old)
+				b[update_len + n] = val;
+			else
+				goto readvalbyte;
+
+			val_old = val;
+		}
+	}
+
+	ret = RNG_SUCCESS;
+
+exit:
+	spin_unlock(&priv->lock);
+	return ret;
+}
+
+static int spacemit_crng_init(struct hwrng *rng)
+{
+	return 0;
+}
+
+static int spacemit_crng_read(struct hwrng *rng, void *buf, size_t max, bool wait)
+{
+	struct spacemit_crng *priv = to_spacemit_crng(rng);
+	struct device *dev = (struct device *)priv->rng.priv;
+	uint64_t data_addr, align_addr;
+	int ret = 0;
+	size_t header_sz = 0, aligned_sz = 0, tail_sz = 0;
+	size_t left_bytes = 0, process_sz;
+	size_t pos = 0;
+	void *data_buf;
+
+	/* use cpu mode */
+	left_bytes = max;
+	while (left_bytes > 0) {
+		process_sz = left_bytes > 0x10 ? 0x10 : left_bytes;
+		hw_get_random_cpu(priv, buf, process_sz);
+		_hw_rng_reset_status(priv);
+		buf = buf + process_sz;
+		left_bytes -= process_sz;
+		ret += process_sz;
+	}
+
+/*
+	if (max < 16) {
+		hw_get_random_cpu(priv, buf, max);
+		return ret;
+	}
+
+	data_buf = dma_alloc_coherent(dev, max, &data_addr, GFP_KERNEL);
+	if(!data_buf)
+		return -ENOMEM;
+	align_addr = (data_addr + 15) & ~0xf;
+	header_sz = align_addr - data_addr;
+	aligned_sz = (max - header_sz) & ~0xF;
+	tail_sz = max - header_sz - aligned_sz;
+
+	if (header_sz) {
+		ret = hw_get_random_cpu(priv, buf, header_sz);
+		if (ret != RNG_SUCCESS)
+			return -1;
+	}
+
+	left_bytes = aligned_sz;
+	while (left_bytes > 0) {
+		process_sz = left_bytes > DMA_MAX_SIZE ? DMA_MAX_SIZE : left_bytes;
+		ret = hw_get_random_dma(priv, align_addr + pos, process_sz, data_buf);
+		if(ret != RNG_SUCCESS)
+			return -1;
+		left_bytes -= process_sz;
+		pos += process_sz;
+	}
+
+	if (tail_sz) {
+		ret = hw_get_random_cpu(priv, (void *)((unsigned long)buf + header_sz + aligned_sz), tail_sz);
+		if (ret != RNG_SUCCESS)
+			return -1;
+	}
+	memcpy(buf, data_buf, max);
+	dma_free_coherent(dev, max, data_buf, GFP_KERNEL);
+*/
+	return ret;
+}
+
+
+static int spacemit_crng_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct spacemit_crng *priv;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->rng.name = pdev->name;
+	priv->rng.read = spacemit_crng_read;
+	priv->rng.init = spacemit_crng_init;
+	//priv->rng.cleanup = spacemit_crng_cleanup;
+	priv->rng.priv = (unsigned long)&pdev->dev;
+	priv->rng.quality = 900;
+	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk))
+		return PTR_ERR(priv->clk);
+	clk_prepare_enable(priv->clk);
+
+	priv->reset = devm_reset_control_get_optional_shared(&pdev->dev, NULL);
+	if (IS_ERR(priv->reset))
+		return PTR_ERR(priv->reset);
+	reset_control_deassert(priv->reset);
+	spin_lock_init(&priv->lock);
+	priv->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	ret = devm_hwrng_register(&pdev->dev, &priv->rng);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register rng device: %d\n", ret);
+		return ret;
+	}
+
+	dev_set_drvdata(&pdev->dev, priv);
+	dev_info(&pdev->dev, "registered RNG driver\n");
+	return 0;
+}
+
+static const struct of_device_id spacemit_crng_of_match[] = {
+	{ .compatible = "spacemit,hw_crng", },
+	{}
+};
+
+static struct platform_driver spacemit_crng_driver = {
+		.driver  = {
+			.name = "spacemit_hwcrng",
+			.owner = THIS_MODULE,
+			.of_match_table = spacemit_crng_of_match,
+		},
+		.probe = spacemit_crng_probe,
+};
+
+module_platform_driver(spacemit_crng_driver);
-- 
2.47.0

